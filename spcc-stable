#!/usr/bin/env node

//Error.stackTraceLimit = 100;


const { performance } = require('perf_hooks');


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


/*  HACK

    TODO this is super brittle
    once we have a proper Platform system in place, the platform can probably
    use its internal Meta to figure out the proper constructor

*/
const maybe_nothing = [ "$corelib$Maybe$Nothing" ];
const maybe_just = (a) => [ "$corelib$Maybe$Just", a ];



//
// Basic ops
//


const sp_equal = (a) => (b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i])(b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k])(b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a) => (b) => {
  return !sp_equal(a)(b);
}


const sp_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = sp_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = sp_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (right) => (left) => {
  if (right === 0) return 0;
  return left / right;
}


const basics_modBy = (a) => (b) => b % a;

const basics_compare = (a) => (b) => sp_compare(a, b);


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message) => (thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.info("");
        console.info("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.info(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const sp_toHuman = (a) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a) || sp_toHumanAsUnion(a);

  if (typeof a === 'function') {
    return '<function>';
  }

  if (typeof a === 'object') {
    let x = [];
    for (let i in a) x.push(i + ' = ' + sp_toHuman(a[i]));
    return '{' + x.join(', ') + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a) => {
  return a[0] + ' ' + a.slice(1).map(arg => '(' + sp_toHuman(arg) + ')').join(' ');
}


const sp_toHumanAsList = (arrayAccum, list) => {
  if (list[0] === '$core$SPCore$Cons') {
    arrayAccum.push(sp_toHuman(list[1]));
    return sp_toHumanAsList(arrayAccum, list[2]);
  }

  if (list[0] === '$core$SPCore$Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ? maybe_nothing : maybe_just(n);
}

const text_split = (separator) => (target) => array_toList(target.split(separator));

const text_length = (s) => s.length;

const text_slice = (start) => (end) => (s) => s.slice(start, end);

const text_startsWith = (sub) => (s) => s.startsWith(sub);

const text_startsWithRegex = (regex) => {
  let re;
  try {
    re = new RegExp('^' + regex);
  } catch (e) {
    return () => ""
  }

  return (s) => {
    let m = s.match(re);
    return m ? m[0] : "";
  }
}

const text_replaceRegex = (regex) => {
  let re;
  try {
    re = new RegExp(regex, 'g');
  } catch (e) {
    return () => () => ""
  }

  return (replacer) => (s) => s.replace(re, replacer);
}

const text_trimLeft = (s) => {
  return s.trimLeft();
}

const text_dropLeft = (n) => (s) => {
  return s.slice(n);
}

const text_forEach = (s) => (f) => {
  for (let i of s) f(i);
  return null;
}


//
// Hashes
//

const hash_empty = {};


const hash_insert = (hash) => (key) => (value) => {
    const h = hash.obj[hash.attr];
    h[JSON.stringify(key)] = [key, value];
    return null;
}


const hash_remove = (hash) => (key) => {
    const h = hash.obj[hash.attr];
    delete h[JSON.stringify(key)];
    return null;
}


const hash_get = (hash) => (key) => {
    const r = hash[JSON.stringify(key)];
    return r === undefined ? maybe_nothing : maybe_just(r[1]);
}


const hash_for = (hash) => (f) => (acc) => {
    for (let k in hash) {
        const kv = hash[k];
        acc = f(kv[0])(kv[1])(acc);
    }
    return acc;
}


const hash_each = (hash) => (f) => {
    for (let k in hash) {
        const kv = hash[k];
        f(kv[0])(kv[1]);
    }
    return null;
}


//
// Arrays
//

const array_push = (array) => (item) => {
    array.obj[array.attr].push(item);
    return null;
}

const array_pop = (array) => {
    const a = array.obj[array.attr];
    return a.length ? maybe_just(a.pop()) : maybe_nothing;
}

const array_get = (array) => (index) => {
    const r = array[index];
    return r === undefined ? maybe_nothing : maybe_just(r);
}

const array_set = (array) => (index) => (item) => {
    if (index < 0) return false;
    const a = array.obj[array.attr];
    if (index >= a.length) return false;
    a[index] = item;
    return true;
}

const array_sortBy = (array) => (f) => {
    const arr = array.obj[array.attr];
    arr.sort((a, b) => sp_compare(f(a), f(b)));
    return null;
}

const array_toList = (array) => {
  let length = array.length;
  let list = [ '$core$SPCore$Nil' ];
  for (let i = length - 1; i >= 0; i--) {
      list = [ '$core$SPCore$Cons', array[i], list ];
  }
  return list;
}

const array_fromList = (list) => {
  const array = [];
  const rec = (ls) => {
    if (ls[0] === '$core$SPCore$Nil')
      return array;

    array.push(ls[1]);
    return rec(ls[2]);
  };

  return rec(list);
}



//
// Lists
//


const sp_cons = (list) => (item) => {
  return [ '$core$SPCore$Cons', item, list];
}

const list_sortBy = (f) => (list) => array_toList(array_fromList(list).sort((a, b) => sp_compare(f(a), f(b))));


//
// Platform: IO
//
const fs = require('fs');

const io_wrap = (f) => [ "IO.IO", f ];

const io_parallel = (iosAsList) => io_wrap((never) => {
    // as [IO a]: IO [a]

    const ios = array_fromList(iosAsList);

    // TODO actually run them in parallel!

    let arr = [];
    for (let io of ios) {
        const r = io[1](never);
        if (r[0] === "$corelib$Result$Ok")
            arr.push(r[1]);
        else
            return $corelib$Result$Err(r[1]);
    }

    return $corelib$Result$Ok(array_toList(arr));
});


const io_readDir = (dirPath) => io_wrap((never) => {
    // as Text: IO [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(array_toList(entries.map((dirent) => ({
        first: dirent.isDirectory(),
        second: dirent.name,
    }))));
});


const io_readFile = (path) => io_wrap((never) => {
    // as Text: IO Text

    var content;
    try {
        content = fs.readFileSync(path, 'utf8');
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(content);
});


const io_writeFile = (path) => (content) => io_wrap((never) => {
    // as Text: Text: IO None

    try {
        fs.writeFileSync(path, content);
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(null);
});


const io_writeStdout = (content) => io_wrap((never) => {
    // as Text: IO None

    console.info(content);
    return $corelib$Result$Ok(null);
});

    const or = (($a) => {
  return (($b) => {
    return ($b || $a);
  });
});

const and = (($a) => {
  return (($b) => {
    return ($b && $a);
  });
});

const greaterOrEqual = (($a) => {
  return (($b) => {
    return ($b >= $a);
  });
});

const greaterThan = (($a) => {
  return (($b) => {
    return ($b > $a);
  });
});

const lesserOrEqual = (($a) => {
  return (($b) => {
    return ($b <= $a);
  });
});

const lesserThan = (($a) => {
  return (($b) => {
    return ($b < $a);
  });
});

const mutass = (($a) => {
  return (($b) => {
    return (($b.obj)[$b.attr] = $a, null);
  });
});

const strcon = (($a) => {
  return (($b) => {
    return ($b + $a);
  });
});

const sub = (($a) => {
  return (($b) => {
    return ($b - $a);
  });
});

const mutadd = (($a) => {
  return (($b) => {
    return (($b.obj)[$b.attr] += $a, null);
  });
});

const add = (($a) => {
  return (($b) => {
    return ($b + $a);
  });
});

const mul = (($a) => {
  return (($b) => {
    return ($b * $a);
  });
});

const $sp$Types$Token$With = ([
  "$sp$Types$Token$With",
]);

const $sp$Types$Token$UpperName = (($1) => (($2) => ([
  "$sp$Types$Token$UpperName",
  $1,
  $2,
])));

const $sp$Types$Token$Unop = (($1) => ([
  "$sp$Types$Token$Unop",
  $1,
]));

const $sp$Types$Token$Try = ([
  "$sp$Types$Token$Try",
]);

const $sp$Types$Token$Token = (($1) => (($2) => (($3) => ([
  "$sp$Types$Token$Token",
  $1,
  $2,
  $3,
]))));

const $sp$Types$Token$Then = ([
  "$sp$Types$Token$Then",
]);

const $sp$Types$Token$TextLiteral = (($1) => ([
  "$sp$Types$Token$TextLiteral",
  $1,
]));

const $sp$Types$Token$SquareBracket = (($1) => ([
  "$sp$Types$Token$SquareBracket",
  $1,
]));

const $sp$Types$Token$RoundParen = (($1) => ([
  "$sp$Types$Token$RoundParen",
  $1,
]));

const $sp$Types$Token$Open = ([
  "$sp$Types$Token$Open",
]);

const $sp$Types$Token$NumberLiteral = (($1) => ([
  "$sp$Types$Token$NumberLiteral",
  $1,
]));

const $sp$Types$Token$NewSiblingLine = ([
  "$sp$Types$Token$NewSiblingLine",
]);

const $sp$Types$Token$NameStartsWithDot = ([
  "$sp$Types$Token$NameStartsWithDot",
]);

const $sp$Types$Token$NameNoModifier = ([
  "$sp$Types$Token$NameNoModifier",
]);

const $sp$Types$Token$NameMutable = ([
  "$sp$Types$Token$NameMutable",
]);

const $sp$Types$Token$MutableColon = ([
  "$sp$Types$Token$MutableColon",
]);

const $sp$Types$Token$LowerName = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$Token$LowerName",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$Token$If = ([
  "$sp$Types$Token$If",
]);

const $sp$Types$Token$ErrorUnterminated = (($1) => ([
  "$sp$Types$Token$ErrorUnterminated",
  $1,
]));

const $sp$Types$Token$ErrorUnknownOp = (($1) => ([
  "$sp$Types$Token$ErrorUnknownOp",
  $1,
]));

const $sp$Types$Token$ErrorBlock = (($1) => ([
  "$sp$Types$Token$ErrorBlock",
  $1,
]));

const $sp$Types$Token$Else = ([
  "$sp$Types$Token$Else",
]);

const $sp$Types$Token$Defop = (($1) => ([
  "$sp$Types$Token$Defop",
  $1,
]));

const $sp$Types$Token$CurlyBrace = (($1) => ([
  "$sp$Types$Token$CurlyBrace",
  $1,
]));

const $sp$Types$Token$Comment = ([
  "$sp$Types$Token$Comment",
]);

const $sp$Types$Token$Comma = ([
  "$sp$Types$Token$Comma",
]);

const $sp$Types$Token$Colon = ([
  "$sp$Types$Token$Colon",
]);

const $sp$Types$Token$Closed = ([
  "$sp$Types$Token$Closed",
]);

const $sp$Types$Token$BlockStart = ([
  "$sp$Types$Token$BlockStart",
]);

const $sp$Types$Token$BlockEnd = ([
  "$sp$Types$Token$BlockEnd",
]);

const $sp$Types$Token$Binop = (($1) => ([
  "$sp$Types$Token$Binop",
  $1,
]));

const $sp$Types$Token$BadIndent = ([
  "$sp$Types$Token$BadIndent",
]);

const $sp$Types$Token$As = ([
  "$sp$Types$Token$As",
]);

const $sp$Types$Pos$T = ([
  "$sp$Types$Pos$T",
]);

const $sp$Types$Pos$S = ([
  "$sp$Types$Pos$S",
]);

const $sp$Types$Pos$P = (($1) => (($2) => (($3) => ([
  "$sp$Types$Pos$P",
  $1,
  $2,
  $3,
]))));

const $sp$Types$Pos$N = ([
  "$sp$Types$Pos$N",
]);

const $sp$Types$Pos$I = (($1) => ([
  "$sp$Types$Pos$I",
  $1,
]));

const $sp$Types$Pos$G = ([
  "$sp$Types$Pos$G",
]);

const $sp$Types$Pos$End = (($1) => ([
  "$sp$Types$Pos$End",
  $1,
]));

const $sp$Types$Pos$At = (($1) => (($2) => ([
  "$sp$Types$Pos$At",
  $1,
  $2,
])));

const $sp$Types$Op$Tuple = ([
  "$sp$Types$Op$Tuple",
]);

const $sp$Types$Op$Right = ([
  "$sp$Types$Op$Right",
]);

const $sp$Types$Op$Pipe = ([
  "$sp$Types$Op$Pipe",
]);

const $sp$Types$Op$NonAssociative = ([
  "$sp$Types$Op$NonAssociative",
]);

const $sp$Types$Op$Mutop = ([
  "$sp$Types$Op$Mutop",
]);

const $sp$Types$Op$Multiplicative = ([
  "$sp$Types$Op$Multiplicative",
]);

const $sp$Types$Op$Logical = ([
  "$sp$Types$Op$Logical",
]);

const $sp$Types$Op$Left = ([
  "$sp$Types$Op$Left",
]);

const $sp$Types$Op$Exponential = ([
  "$sp$Types$Op$Exponential",
]);

const $sp$Types$Op$Cons = ([
  "$sp$Types$Op$Cons",
]);

const $sp$Types$Op$Comparison = ([
  "$sp$Types$Op$Comparison",
]);

const $sp$Types$Op$Addittive = ([
  "$sp$Types$Op$Addittive",
]);

const $sp$Types$Meta$USR = (($1) => (($2) => ([
  "$sp$Types$Meta$USR",
  $1,
  $2,
])));

const $sp$Types$Meta$UMR = (($1) => (($2) => ([
  "$sp$Types$Meta$UMR",
  $1,
  $2,
])));

const $sp$Types$Meta$SourceDir = (($1) => ([
  "$sp$Types$Meta$SourceDir",
  $1,
]));

const $sp$Types$Meta$Core = ([
  "$sp$Types$Meta$Core",
]);

const $sp$Types$JavascriptAst$Var = (($1) => ([
  "$sp$Types$JavascriptAst$Var",
  $1,
]));

const $sp$Types$JavascriptAst$Unop = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$Unop",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$SimpleLambda = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$SimpleLambda",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Return = (($1) => ([
  "$sp$Types$JavascriptAst$Return",
  $1,
]));

const $sp$Types$JavascriptAst$Record = (($1) => ([
  "$sp$Types$JavascriptAst$Record",
  $1,
]));

const $sp$Types$JavascriptAst$Mutop = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$JavascriptAst$Mutop",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$JavascriptAst$Literal = (($1) => ([
  "$sp$Types$JavascriptAst$Literal",
  $1,
]));

const $sp$Types$JavascriptAst$If = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$If",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Eval = (($1) => ([
  "$sp$Types$JavascriptAst$Eval",
  $1,
]));

const $sp$Types$JavascriptAst$Define = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$Define",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Conditional = (($1) => (($2) => (($3) => ([
  "$sp$Types$JavascriptAst$Conditional",
  $1,
  $2,
  $3,
]))));

const $sp$Types$JavascriptAst$Call = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$Call",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$BlockLambda = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$BlockLambda",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Binop = (($1) => (($2) => (($3) => ([
  "$sp$Types$JavascriptAst$Binop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$JavascriptAst$Array = (($1) => ([
  "$sp$Types$JavascriptAst$Array",
  $1,
]));

const $sp$Types$JavascriptAst$AccessWithDot = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$AccessWithDot",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$AccessWithBrackets = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$AccessWithBrackets",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Variable = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$Variable",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$Unop = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Unop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$UnionDef = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$UnionDef",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeVariable = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeVariable",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeTuple = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeTuple",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeRecord = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeRecord",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeList = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeList",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeFunction = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$TypeFunction",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$TypeConstant = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$TypeConstant",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$TypeAlias = (($1) => ([
  "$sp$Types$FormattableAst$TypeAlias",
  $1,
]));

const $sp$Types$FormattableAst$Try = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Try",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$RecordShorthand = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$RecordShorthand",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Record = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Record",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PrefixBinop = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PrefixBinop",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternTuple = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternTuple",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternRecord = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternRecord",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternLiteralText = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternLiteralText",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternLiteralNumber = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternLiteralNumber",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternListCons = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternListCons",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternList = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternList",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternConstructor = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$PatternConstructor",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$PatternAny = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$PatternAny",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$Mutable = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Mutable",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$LiteralText = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$LiteralText",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$LiteralNumber = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$LiteralNumber",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$List = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$List",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Lambda = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$Lambda",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$If = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$If",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$FunctionCall = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$FunctionCall",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Evaluation = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Evaluation",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Definition = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Definition",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$DefNormal = ([
  "$sp$Types$FormattableAst$DefNormal",
]);

const $sp$Types$FormattableAst$DefMutable = ([
  "$sp$Types$FormattableAst$DefMutable",
]);

const $sp$Types$FormattableAst$DefCallback = ([
  "$sp$Types$FormattableAst$DefCallback",
]);

const $sp$Types$FormattableAst$Constructor = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Constructor",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Binop = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Binop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$Variable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$Variable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$TypeVariable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$TypeVariable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$TypeRecord = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$TypeRecord",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeFunction = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$CanonicalAst$TypeFunction",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$CanonicalAst$TypeDefUnion = (($1) => ([
  "$sp$Types$CanonicalAst$TypeDefUnion",
  $1,
]));

const $sp$Types$CanonicalAst$TypeDefAlias = (($1) => ([
  "$sp$Types$CanonicalAst$TypeDefAlias",
  $1,
]));

const $sp$Types$CanonicalAst$TypeConstant = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$TypeConstant",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeAlias = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$TypeAlias",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$Try = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Try",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$RefRoot = (($1) => ([
  "$sp$Types$CanonicalAst$RefRoot",
  $1,
]));

const $sp$Types$CanonicalAst$RefBlock = (($1) => ([
  "$sp$Types$CanonicalAst$RefBlock",
  $1,
]));

const $sp$Types$CanonicalAst$Record = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Record",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$PatternRecord = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$PatternRecord",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternLiteralText = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$PatternLiteralText",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternLiteralNumber = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$PatternLiteralNumber",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternConstructor = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$PatternConstructor",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$PatternAny = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$PatternAny",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$ParameterPattern = (($1) => ([
  "$sp$Types$CanonicalAst$ParameterPattern",
  $1,
]));

const $sp$Types$CanonicalAst$ParameterMutable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$ParameterMutable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LiteralText = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$LiteralText",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LiteralNumber = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$LiteralNumber",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LetIn = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$LetIn",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Lambda = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Lambda",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$If = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$If",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Constructor = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$Constructor",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Call = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Call",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$ArgumentMutable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$ArgumentMutable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$ArgumentExpression = (($1) => ([
  "$sp$Types$CanonicalAst$ArgumentExpression",
  $1,
]));

const $sp$Test$Success = ([
  "$sp$Test$Success",
]);

const $sp$Test$Skipped = ([
  "$sp$Test$Skipped",
]);

const $sp$Test$Single = (($1) => (($2) => (($3) => ([
  "$sp$Test$Single",
  $1,
  $2,
  $3,
]))));

const $sp$Test$NotNow = (($1) => ([
  "$sp$Test$NotNow",
  $1,
]));

const $sp$Test$Group = (($1) => (($2) => ([
  "$sp$Test$Group",
  $1,
  $2,
])));

const $sp$Test$Error = (($1) => ([
  "$sp$Test$Error",
  $1,
]));

const $sp$Test$CodeExpectation = (($1) => ([
  "$sp$Test$CodeExpectation",
  $1,
]));

const $sp$SPON$Rejected = (($1) => ([
  "$sp$SPON$Rejected",
  $1,
]));

const $sp$SPON$Failed = (($1) => ([
  "$sp$SPON$Failed",
  $1,
]));

const $sp$SPON$Accepted = (($1) => (($2) => ([
  "$sp$SPON$Accepted",
  $1,
  $2,
])));

const $sp$SPLib$Parser$Rejected = ([
  "$sp$SPLib$Parser$Rejected",
]);

const $sp$SPLib$Parser$Accepted = (($1) => (($2) => ([
  "$sp$SPLib$Parser$Accepted",
  $1,
  $2,
])));

const $sp$SPLib$Parser$Aborted = (($1) => (($2) => ([
  "$sp$SPLib$Parser$Aborted",
  $1,
  $2,
])));

const $sp$ModulesFile$Lib = (($1) => ([
  "$sp$ModulesFile$Lib",
  $1,
]));

const $sp$ModulesFile$Dir = (($1) => ([
  "$sp$ModulesFile$Dir",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_TryPattern = ([
  "$sp$Compiler$TypeCheck$UnifyReason_TryPattern",
]);

const $sp$Compiler$TypeCheck$UnifyReason_TryBlock = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_TryBlock",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_Override = ([
  "$sp$Compiler$TypeCheck$UnifyReason_Override",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IsLambda = ([
  "$sp$Compiler$TypeCheck$UnifyReason_IsLambda",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction = (($1) => (($2) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction",
  $1,
  $2,
])));

const $sp$Compiler$TypeCheck$UnifyReason_IfCondition = ([
  "$sp$Compiler$TypeCheck$UnifyReason_IfCondition",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IfBranches = ([
  "$sp$Compiler$TypeCheck$UnifyReason_IfBranches",
]);

const $sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern = ([
  "$sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern",
]);

const $sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_CallArgument = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_CallArgument",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AttributeAccess = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_AttributeAccess",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock = (($1) => (($2) => (($3) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock",
  $1,
  $2,
  $3,
]))));

const $sp$Compiler$TypeCheck$UnifyReason_AnnotationSimple = ([
  "$sp$Compiler$TypeCheck$UnifyReason_AnnotationSimple",
]);

const $sp$Compiler$TypeCheck$SubstitutingAnnotation = (($1) => ([
  "$sp$Compiler$TypeCheck$SubstitutingAnnotation",
  $1,
]));

const $sp$Compiler$TypeCheck$OkThisIsActuallyPossible = ([
  "$sp$Compiler$TypeCheck$OkThisIsActuallyPossible",
]);

const $sp$Compiler$TypeCheck$NonFunctionContainsFunction = (($1) => ([
  "$sp$Compiler$TypeCheck$NonFunctionContainsFunction",
  $1,
]));

const $sp$Compiler$TypeCheck$NI = (($1) => ([
  "$sp$Compiler$TypeCheck$NI",
  $1,
]));

const $sp$Compiler$TypeCheck$IncompatibleTypes = ([
  "$sp$Compiler$TypeCheck$IncompatibleTypes",
]);

const $sp$Compiler$TypeCheck$IncompatibleRecords = (($1) => ([
  "$sp$Compiler$TypeCheck$IncompatibleRecords",
  $1,
]));

const $sp$Compiler$TypeCheck$IncompatibleMutability = ([
  "$sp$Compiler$TypeCheck$IncompatibleMutability",
]);

const $sp$Compiler$TypeCheck$Cycle = (($1) => ([
  "$sp$Compiler$TypeCheck$Cycle",
  $1,
]));

const $sp$Compiler$Lexer$Word = (($1) => ([
  "$sp$Compiler$Lexer$Word",
  $1,
]));

const $sp$Compiler$Lexer$TripleQuote = (($1) => ([
  "$sp$Compiler$Lexer$TripleQuote",
  $1,
]));

const $sp$Compiler$Lexer$Tabs = ([
  "$sp$Compiler$Lexer$Tabs",
]);

const $sp$Compiler$Lexer$Squiggles = ([
  "$sp$Compiler$Lexer$Squiggles",
]);

const $sp$Compiler$Lexer$Spaces = ([
  "$sp$Compiler$Lexer$Spaces",
]);

const $sp$Compiler$Lexer$SingleQuote = (($1) => ([
  "$sp$Compiler$Lexer$SingleQuote",
  $1,
]));

const $sp$Compiler$Lexer$NumberLiteral = ([
  "$sp$Compiler$Lexer$NumberLiteral",
]);

const $sp$Compiler$Lexer$NoTabsOrSpacesYet = ([
  "$sp$Compiler$Lexer$NoTabsOrSpacesYet",
]);

const $sp$Compiler$Lexer$Mutable = ([
  "$sp$Compiler$Lexer$Mutable",
]);

const $sp$Compiler$Lexer$LineComment = ([
  "$sp$Compiler$Lexer$LineComment",
]);

const $sp$Compiler$Lexer$Indent = ([
  "$sp$Compiler$Lexer$Indent",
]);

const $sp$Compiler$Lexer$Dot = ([
  "$sp$Compiler$Lexer$Dot",
]);

const $sp$Compiler$Lexer$Default = ([
  "$sp$Compiler$Lexer$Default",
]);

const $sp$Compiler$Lexer$ContentOpeningQuotes_Two = ([
  "$sp$Compiler$Lexer$ContentOpeningQuotes_Two",
]);

const $sp$Compiler$Lexer$ContentOpeningQuotes_One = ([
  "$sp$Compiler$Lexer$ContentOpeningQuotes_One",
]);

const $sp$Compiler$Lexer$ContentOpeningBlockComment = ([
  "$sp$Compiler$Lexer$ContentOpeningBlockComment",
]);

const $sp$Compiler$Lexer$BlockComment = (($1) => ([
  "$sp$Compiler$Lexer$BlockComment",
  $1,
]));

const $sp$Compiler$Error$Simple = (($1) => (($2) => ([
  "$sp$Compiler$Error$Simple",
  $1,
  $2,
])));

const $sp$Compiler$Error$Nested = (($1) => ([
  "$sp$Compiler$Error$Nested",
  $1,
]));

const $sp$Compiler$Error$HighlightWord = (($1) => ([
  "$sp$Compiler$Error$HighlightWord",
  $1,
]));

const $sp$Compiler$Error$HighlightBlock = (($1) => ([
  "$sp$Compiler$Error$HighlightBlock",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Warning = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Warning",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Emphasys = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Emphasys",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Default = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Default",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Decoration = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Decoration",
  $1,
]));

const $sp$Compiler$CanonicalToJs$Right = (($1) => ([
  "$sp$Compiler$CanonicalToJs$Right",
  $1,
]));

const $sp$Compiler$CanonicalToJs$NodeName = (($1) => (($2) => ([
  "$sp$Compiler$CanonicalToJs$NodeName",
  $1,
  $2,
])));

const $sp$Compiler$CanonicalToJs$NodeDef = (($1) => (($2) => ([
  "$sp$Compiler$CanonicalToJs$NodeDef",
  $1,
  $2,
])));

const $sp$Compiler$CanonicalToJs$Left = (($1) => ([
  "$sp$Compiler$CanonicalToJs$Left",
  $1,
]));

const $posix$IO$Never = (($1) => ([
  "$posix$IO$Never",
  $1,
]));

const $posix$IO$IO = (($1) => ([
  "$posix$IO$IO",
  $1,
]));

const $corelib$Result$Ok = (($1) => ([
  "$corelib$Result$Ok",
  $1,
]));

const $corelib$Result$Err = (($1) => ([
  "$corelib$Result$Err",
  $1,
]));

const $corelib$Maybe$Nothing = ([
  "$corelib$Maybe$Nothing",
]);

const $corelib$Maybe$Just = (($1) => ([
  "$corelib$Maybe$Just",
  $1,
]));

const $corelib$Hash$Hash__ = (($1) => ([
  "$corelib$Hash$Hash__",
  $1,
]));

const $corelib$Dict$Red = ([
  "$corelib$Dict$Red",
]);

const $corelib$Dict$RBNode_elm_builtin = (($1) => (($2) => (($3) => (($4) => (($5) => ([
  "$corelib$Dict$RBNode_elm_builtin",
  $1,
  $2,
  $3,
  $4,
  $5,
]))))));

const $corelib$Dict$RBEmpty_elm_builtin = ([
  "$corelib$Dict$RBEmpty_elm_builtin",
]);

const $corelib$Dict$Black = ([
  "$corelib$Dict$Black",
]);

const $corelib$Array$Array__ = (($1) => ([
  "$corelib$Array$Array__",
  $1,
]));

const $core$SPCore$Nil = ([
  "$core$SPCore$Nil",
]);

const $core$SPCore$Cons = (($1) => (($2) => ([
  "$core$SPCore$Cons",
  $1,
  $2,
])));

const $sp$Test$maybeToOutcome = (($m) => {
  const $$try0 = $m;
  if (("$corelib$Maybe$Just" === ($$try0)[0])) {
    const $e = ($$try0)[1];
    return ($sp$Test$Error)($e);
  }
  if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
    return $sp$Test$Success;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 15:4', (sp_toHuman)($$try0));
});

const $sp$Test$valueTest = (($toText) => {
  return (($title) => {
    return (($generateValue) => {
      return (($ce) => {
        const toMaybeError$$ = $ce;
        const $toMaybeError = (toMaybeError$$)[1];
        return ((($sp$Test$Single)($title))(""))((() => {
          return ($sp$Test$maybeToOutcome)((($toMaybeError)($toText))(($corelib$Result$Ok)(($generateValue)(null))));
        }));
      });
    });
  });
});

const $corelib$Array_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$Text$join = (($sep) => {
  return (($listOfText) => {
    const $$try0 = $listOfText;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return "";
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $head = ($$try0)[1];
      const $rec = (($ls) => {
        return (($acc) => {
          const $$try1 = $ls;
          if (("$core$SPCore$Nil" === ($$try1)[0])) {
            return $acc;
          }
          if (("$core$SPCore$Cons" === ($$try1)[0])) {
            const $t = ($$try1)[2];
            const $h = ($$try1)[1];
            return (($rec)($t))(($acc + ($sep + $h)));
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 135:12', (sp_toHuman)($$try1));
        });
      });
      return (($rec)($tail))($head);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 127:4', (sp_toHuman)($$try0));
  });
});

const $sp$Test$isOkAndEqualTo = (($expectedOk) => {
  return ($sp$Test$CodeExpectation)((($toText) => {
    return (($result) => {
      const $$try0 = $result;
      if (("$corelib$Result$Err" === ($$try0)[0])) {
        const $e = ($$try0)[1];
        return ($corelib$Maybe$Just)($e);
      }
      if (("$corelib$Result$Ok" === ($$try0)[0])) {
        const $actualOk = ($$try0)[1];
        return (((sp_equal)($expectedOk))($actualOk)
          ? $corelib$Maybe$Nothing
          : ($corelib$Maybe$Just)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("expected = "))((($core$SPCore$Cons)(($toText)($expectedOk)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("actual = "))((($core$SPCore$Cons)(($toText)($actualOk)))($core$SPCore$Nil))))))));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 81:6', (sp_toHuman)($$try0));
    });
  }));
});

const $corelib$Array_Test$tests = (($sp$Test$Group)("Array"))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("push"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)),
    }),
  });
  ((array_push)($a))("b");
  ((array_push)($a))("c");
  return (array_toList)((sp_clone)(($a.obj)[$a.attr]));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("pop 1"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("x"))((($core$SPCore$Cons)("y"))((($core$SPCore$Cons)("z"))($core$SPCore$Nil)))),
    }),
  });
  const $b = (array_pop)($a);
  const $c = (array_pop)($a);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  b: ($corelib$Maybe$Just)("z"),
  c: ($corelib$Maybe$Just)("y"),
  l: (($core$SPCore$Cons)("x"))($core$SPCore$Nil),
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("pop empty"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)($core$SPCore$Nil),
    }),
  });
  const $b = (array_pop)($a);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    b: $b,
    l: $l,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  b: $corelib$Maybe$Nothing,
  l: $core$SPCore$Nil,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("get Just"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("p"))((($core$SPCore$Cons)("q"))($core$SPCore$Nil))),
    }),
  });
  return ((array_get)((sp_clone)(($a.obj)[$a.attr])))(1);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)("q")))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("get Nothing"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("p"))((($core$SPCore$Cons)("q"))($core$SPCore$Nil))),
    }),
  });
  return ((array_get)((sp_clone)(($a.obj)[$a.attr])))(3);
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("set success"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil))),
    }),
  });
  const $r = (((array_set)($a))(0))(10);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    l: $l,
    r: $r,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  l: (($core$SPCore$Cons)(10))((($core$SPCore$Cons)(9))($core$SPCore$Nil)),
  r: true,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("set fail"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil))),
    }),
  });
  const $r = (((array_set)($a))(3))(10);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    l: $l,
    r: $r,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  l: (($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil)),
  r: false,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("sortBy"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)(55))((($core$SPCore$Cons)(99))((($core$SPCore$Cons)(22))($core$SPCore$Nil)))),
    }),
  });
  ((array_sortBy)($a))((($x) => {
    return -($x);
  }));
  return (array_toList)((sp_clone)(($a.obj)[$a.attr]));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(99))((($core$SPCore$Cons)(55))((($core$SPCore$Cons)(22))($core$SPCore$Nil)))))))($core$SPCore$Nil)))))))));

const $corelib$Basics$btw = (($f) => {
  return (($a) => {
    return (($c) => {
      ($f)($a);
      return $c;
    });
  });
});

const $corelib$Basics$clamp = (($low) => {
  return (($high) => {
    return (($n) => {
      return (($n < $low)
        ? $low
        : (($n > $high)
          ? $high
          : $n));
    });
  });
});

const $corelib$Basics$identity = (($a) => {
  return $a;
});

const $corelib$Basics$max = (($a) => {
  return (($b) => {
    return (($a > $b)
      ? $a
      : $b);
  });
});

const $corelib$Basics$min = (($a) => {
  return (($b) => {
    return (($a < $b)
      ? $a
      : $b);
  });
});

const $corelib$Basics$not = (($b) => {
  return ($b
    ? false
    : true);
});

const $corelib$Dict$balance = (($color) => {
  return (($key) => {
    return (($value) => {
      return (($left) => {
        return (($right) => {
          const $$try0 = $right;
          if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && ("$corelib$Dict$Red" === (($$try0)[1])[0]))) {
            const $rRight = ($$try0)[5];
            const $rLeft = ($$try0)[4];
            const $rV = ($$try0)[3];
            const $rK = ($$try0)[2];
            const $$try1 = $left;
            if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0]) && ("$corelib$Dict$Red" === (($$try1)[1])[0]))) {
              const $lRight = ($$try1)[5];
              const $lLeft = ($$try1)[4];
              const $lV = ($$try1)[3];
              const $lK = ($$try1)[2];
              return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($rK))($rV))($rLeft))($rRight));
            }
            if (true) {
              return ((((($corelib$Dict$RBNode_elm_builtin)($color))($rK))($rV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($left))($rLeft)))($rRight);
            }
            (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 117:6', (sp_toHuman)($$try1));
            return null;
          }
          if (true) {
            const $$try1 = $left;
            if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0]) && (("$corelib$Dict$Red" === (($$try1)[1])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try1)[4])[0]) && ("$corelib$Dict$Red" === ((($$try1)[4])[1])[0]))))) {
              const $lRight = ($$try1)[5];
              const $llRight = (($$try1)[4])[5];
              const $llLeft = (($$try1)[4])[4];
              const $llV = (($$try1)[4])[3];
              const $llK = (($$try1)[4])[2];
              const $lV = ($$try1)[3];
              const $lK = ($$try1)[2];
              return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($llK))($llV))($llLeft))($llRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($key))($value))($lRight))($right));
            }
            if (true) {
              return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))($left))($right);
            }
            (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 130:6', (sp_toHuman)($$try1));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 115:2', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $corelib$Dict$for = (($dict) => {
  return (($func) => {
    return (($acc) => {
      const $$try0 = $dict;
      if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
        return $acc;
      }
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
        const $right = ($$try0)[5];
        const $left = ($$try0)[4];
        const $value = ($$try0)[3];
        const $key = ($$try0)[2];
        return ((($corelib$Dict$for)($right))($func))(((($func)($key))($value))(((($corelib$Dict$for)($left))($func))($acc)));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 449:2', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$Dict$moveRedLeft = (($dict) => {
  const $$try0 = $dict;
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[4])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[5])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === ((($$try0)[5])[4])[0]) && ("$corelib$Dict$Red" === (((($$try0)[5])[4])[1])[0])))))) {
    const $rRight = (($$try0)[5])[5];
    const $rlR = ((($$try0)[5])[4])[5];
    const $rlL = ((($$try0)[5])[4])[4];
    const $rlV = ((($$try0)[5])[4])[3];
    const $rlK = ((($$try0)[5])[4])[2];
    const $rV = (($$try0)[5])[3];
    const $rK = (($$try0)[5])[2];
    const $rClr = (($$try0)[5])[1];
    const $lRight = (($$try0)[4])[5];
    const $lLeft = (($$try0)[4])[4];
    const $lV = (($$try0)[4])[3];
    const $lK = (($$try0)[4])[2];
    const $lClr = (($$try0)[4])[1];
    const $v = ($$try0)[3];
    const $k = ($$try0)[2];
    const $clr = ($$try0)[1];
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rlK))($rlV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))($rlL)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($rK))($rV))($rlR))($rRight));
  }
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[4])[0]) && ("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[5])[0])))) {
    const $rRight = (($$try0)[5])[5];
    const $rLeft = (($$try0)[5])[4];
    const $rV = (($$try0)[5])[3];
    const $rK = (($$try0)[5])[2];
    const $rClr = (($$try0)[5])[1];
    const $lRight = (($$try0)[4])[5];
    const $lLeft = (($$try0)[4])[4];
    const $lV = (($$try0)[4])[3];
    const $lK = (($$try0)[4])[2];
    const $lClr = (($$try0)[4])[1];
    const $v = ($$try0)[3];
    const $k = ($$try0)[2];
    const $clr = ($$try0)[1];
    const $$try1 = $clr;
    if (("$corelib$Dict$Black" === ($$try1)[0])) {
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
    }
    if (("$corelib$Dict$Red" === ($$try1)[0])) {
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 285:6', (sp_toHuman)($$try1));
    return null;
  }
  if (true) {
    return $dict;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 275:2', (sp_toHuman)($$try0));
});

const $corelib$Dict$getMin = (($dict) => {
  const $$try0 = $dict;
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
    const $left = ($$try0)[4];
    const $$try1 = $left;
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0])) {
      return ($corelib$Dict$getMin)($left);
    }
    if (true) {
      return $dict;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 234:6', (sp_toHuman)($$try1));
    return null;
  }
  if (true) {
    return $dict;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 232:2', (sp_toHuman)($$try0));
});

const $corelib$Dict$removeMin = (($dict) => {
  const $$try0 = $dict;
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
    const $right = ($$try0)[5];
    const $left = ($$try0)[4];
    const $value = ($$try0)[3];
    const $key = ($$try0)[2];
    const $color = ($$try0)[1];
    const $$try1 = $left;
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0])) {
      const $lLeft = ($$try1)[4];
      const $lColor = ($$try1)[1];
      const $$try2 = $lColor;
      if (("$corelib$Dict$Black" === ($$try2)[0])) {
        const $$try3 = $lLeft;
        if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try3)[0]) && ("$corelib$Dict$Red" === (($$try3)[1])[0]))) {
          return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))(($corelib$Dict$removeMin)($left)))($right);
        }
        if (true) {
          const $$try4 = ($corelib$Dict$moveRedLeft)($dict);
          if (("$corelib$Dict$RBNode_elm_builtin" === ($$try4)[0])) {
            const $nRight = ($$try4)[5];
            const $nLeft = ($$try4)[4];
            const $nValue = ($$try4)[3];
            const $nKey = ($$try4)[2];
            const $nColor = ($$try4)[1];
            return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))(($corelib$Dict$removeMin)($nLeft)))($nRight);
          }
          if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try4)[0])) {
            return $corelib$Dict$RBEmpty_elm_builtin;
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 257:18', (sp_toHuman)($$try4));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 252:14', (sp_toHuman)($$try3));
        return null;
      }
      if (true) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))(($corelib$Dict$removeMin)($left)))($right);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 250:10', (sp_toHuman)($$try2));
      return null;
    }
    if (true) {
      return $corelib$Dict$RBEmpty_elm_builtin;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 248:6', (sp_toHuman)($$try1));
    return null;
  }
  if (true) {
    return $corelib$Dict$RBEmpty_elm_builtin;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 246:2', (sp_toHuman)($$try0));
});

const $corelib$Dict$removeHelpEQGT = (($targetKey) => {
  return (($dict) => {
    const $$try0 = $dict;
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
      const $right = ($$try0)[5];
      const $left = ($$try0)[4];
      const $value = ($$try0)[3];
      const $key = ($$try0)[2];
      const $color = ($$try0)[1];
      return (((sp_equal)($key))($targetKey)
        ? ((() => {
          const $$try1 = ($corelib$Dict$getMin)($right);
          if (("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0])) {
            const $minValue = ($$try1)[3];
            const $minKey = ($$try1)[2];
            return ((((($corelib$Dict$balance)($color))($minKey))($minValue))($left))(($corelib$Dict$removeMin)($right));
          }
          if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try1)[0])) {
            return $corelib$Dict$RBEmpty_elm_builtin;
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 217:8', (sp_toHuman)($$try1));
        }))()
        : ((((($corelib$Dict$balance)($color))($key))($value))($left))((($corelib$Dict$removeHelp)($targetKey))($right)));
    }
    if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
      return $corelib$Dict$RBEmpty_elm_builtin;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 214:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$moveRedRight = (($dict) => {
  const $$try0 = $dict;
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[4])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === ((($$try0)[4])[4])[0]) && (("$corelib$Dict$Red" === (((($$try0)[4])[4])[1])[0]) && ("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[5])[0])))))) {
    const $rRight = (($$try0)[5])[5];
    const $rLeft = (($$try0)[5])[4];
    const $rV = (($$try0)[5])[3];
    const $rK = (($$try0)[5])[2];
    const $rClr = (($$try0)[5])[1];
    const $lRight = (($$try0)[4])[5];
    const $llRight = ((($$try0)[4])[4])[5];
    const $llLeft = ((($$try0)[4])[4])[4];
    const $llV = ((($$try0)[4])[4])[3];
    const $llK = ((($$try0)[4])[4])[2];
    const $lV = (($$try0)[4])[3];
    const $lK = (($$try0)[4])[2];
    const $lClr = (($$try0)[4])[1];
    const $v = ($$try0)[3];
    const $k = ($$try0)[2];
    const $clr = ($$try0)[1];
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($llK))($llV))($llLeft))($llRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($lRight))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight)));
  }
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[4])[0]) && ("$corelib$Dict$RBNode_elm_builtin" === (($$try0)[5])[0])))) {
    const $rRight = (($$try0)[5])[5];
    const $rLeft = (($$try0)[5])[4];
    const $rV = (($$try0)[5])[3];
    const $rK = (($$try0)[5])[2];
    const $rClr = (($$try0)[5])[1];
    const $lRight = (($$try0)[4])[5];
    const $lLeft = (($$try0)[4])[4];
    const $lV = (($$try0)[4])[3];
    const $lK = (($$try0)[4])[2];
    const $lClr = (($$try0)[4])[1];
    const $v = ($$try0)[3];
    const $k = ($$try0)[2];
    const $clr = ($$try0)[1];
    const $$try1 = $clr;
    if (("$corelib$Dict$Black" === ($$try1)[0])) {
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
    }
    if (("$corelib$Dict$Red" === ($$try1)[0])) {
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 318:6', (sp_toHuman)($$try1));
    return null;
  }
  if (true) {
    return $dict;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 308:2', (sp_toHuman)($$try0));
});

const $corelib$Dict$removeHelpPrepEQGT = (($targetKey) => {
  return (($dict) => {
    return (($color) => {
      return (($key) => {
        return (($value) => {
          return (($left) => {
            return (($right) => {
              const $$try0 = $left;
              if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && ("$corelib$Dict$Red" === (($$try0)[1])[0]))) {
                const $lRight = ($$try0)[5];
                const $lLeft = ($$try0)[4];
                const $lV = ($$try0)[3];
                const $lK = ($$try0)[2];
                return ((((($corelib$Dict$RBNode_elm_builtin)($color))($lK))($lV))($lLeft))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($lRight))($right));
              }
              if (true) {
                const $$try1 = $right;
                if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0]) && (("$corelib$Dict$Black" === (($$try1)[1])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try1)[4])[0]) && ("$corelib$Dict$Black" === ((($$try1)[4])[1])[0]))))) {
                  return ($corelib$Dict$moveRedRight)($dict);
                }
                if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0]) && (("$corelib$Dict$Black" === (($$try1)[1])[0]) && ("$corelib$Dict$RBEmpty_elm_builtin" === (($$try1)[4])[0])))) {
                  return ($corelib$Dict$moveRedRight)($dict);
                }
                if (true) {
                  return $dict;
                }
                (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 199:6', (sp_toHuman)($$try1));
                return null;
              }
              (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 189:2', (sp_toHuman)($$try0));
            });
          });
        });
      });
    });
  });
});

const $corelib$Dict$removeHelp = (($targetKey) => {
  return (($dict) => {
    const $$try0 = $dict;
    if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
      return $corelib$Dict$RBEmpty_elm_builtin;
    }
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
      const $right = ($$try0)[5];
      const $left = ($$try0)[4];
      const $value = ($$try0)[3];
      const $key = ($$try0)[2];
      const $color = ($$try0)[1];
      return (((sp_equal)((0 - 1)))(((basics_compare)($targetKey))($key))
        ? ((() => {
          const $$try1 = $left;
          if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try1)[0]) && ("$corelib$Dict$Black" === (($$try1)[1])[0]))) {
            const $lLeft = ($$try1)[4];
            const $$try2 = $lLeft;
            if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try2)[0]) && ("$corelib$Dict$Red" === (($$try2)[1])[0]))) {
              return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))((($corelib$Dict$removeHelp)($targetKey))($left)))($right);
            }
            if (true) {
              const $$try3 = ($corelib$Dict$moveRedLeft)($dict);
              if (("$corelib$Dict$RBNode_elm_builtin" === ($$try3)[0])) {
                const $nRight = ($$try3)[5];
                const $nLeft = ($$try3)[4];
                const $nValue = ($$try3)[3];
                const $nKey = ($$try3)[2];
                const $nColor = ($$try3)[1];
                return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))((($corelib$Dict$removeHelp)($targetKey))($nLeft)))($nRight);
              }
              if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try3)[0])) {
                return $corelib$Dict$RBEmpty_elm_builtin;
              }
              (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 173:16', (sp_toHuman)($$try3));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 168:12', (sp_toHuman)($$try2));
            return null;
          }
          if (true) {
            return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))((($corelib$Dict$removeHelp)($targetKey))($left)))($right);
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 166:8', (sp_toHuman)($$try1));
        }))()
        : (($corelib$Dict$removeHelpEQGT)($targetKey))(((((((($corelib$Dict$removeHelpPrepEQGT)($targetKey))($dict))($color))($key))($value))($left))($right)));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 160:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$remove = (($key) => {
  return (($dict) => {
    const $$try0 = (($corelib$Dict$removeHelp)($key))($dict);
    if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && ("$corelib$Dict$Red" === (($$try0)[1])[0]))) {
      const $r = ($$try0)[5];
      const $l = ($$try0)[4];
      const $v = ($$try0)[3];
      const $k = ($$try0)[2];
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($l))($r);
    }
    if (true) {
      const $x = $$try0;
      return $x;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 148:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$diff = (($t1) => {
  return (($t2) => {
    return ((($corelib$Dict$for)($t2))((($k) => {
      return (($v) => {
        return (($t) => {
          return (($corelib$Dict$remove)($k))($t);
        });
      });
    })))($t1);
  });
});

const $corelib$Dict$empty = $corelib$Dict$RBEmpty_elm_builtin;

const $corelib$Dict$insertHelp = (($key) => {
  return (($value) => {
    return (($dict) => {
      const $$try0 = $dict;
      if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($corelib$Dict$RBEmpty_elm_builtin))($corelib$Dict$RBEmpty_elm_builtin);
      }
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
        const $nRight = ($$try0)[5];
        const $nLeft = ($$try0)[4];
        const $nValue = ($$try0)[3];
        const $nKey = ($$try0)[2];
        const $nColor = ($$try0)[1];
        const $$try1 = ((basics_compare)($key))($nKey);
        if ((1 === $$try1)) {
          return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))($nLeft))(((($corelib$Dict$insertHelp)($key))($value))($nRight));
        }
        if ((0 === $$try1)) {
          return ((((($corelib$Dict$RBNode_elm_builtin)($nColor))($nKey))($value))($nLeft))($nRight);
        }
        if (true) {
          return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))(((($corelib$Dict$insertHelp)($key))($value))($nLeft)))($nRight);
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 101:6', (sp_toHuman)($$try1));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 94:2', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$Dict$insert = (($key) => {
  return (($value) => {
    return (($dict) => {
      const $$try0 = ((($corelib$Dict$insertHelp)($key))($value))($dict);
      if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0]) && ("$corelib$Dict$Red" === (($$try0)[1])[0]))) {
        const $r = ($$try0)[5];
        const $l = ($$try0)[4];
        const $v = ($$try0)[3];
        const $k = ($$try0)[2];
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($l))($r);
      }
      if (true) {
        const $x = $$try0;
        return $x;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 83:2', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$Dict$filter = (($isGood) => {
  return (($dict) => {
    return ((($corelib$Dict$for)($dict))((($k) => {
      return (($v) => {
        return (($d) => {
          return ((($isGood)($k))($v)
            ? ((($corelib$Dict$insert)($k))($v))($d)
            : $d);
        });
      });
    })))($corelib$Dict$empty);
  });
});

const $corelib$Result$onOk = (($f) => {
  return (($result) => {
    const $$try0 = $result;
    if (("$corelib$Result$Err" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return ($corelib$Result$Err)($e);
    }
    if (("$corelib$Result$Ok" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return ($f)($a);
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 18:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$forRes = (($dict) => {
  return (($func) => {
    return (($acc) => {
      const $$try0 = $dict;
      if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
        return ($corelib$Result$Ok)($acc);
      }
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
        const $right = ($$try0)[5];
        const $left = ($$try0)[4];
        const $value = ($$try0)[3];
        const $key = ($$try0)[2];
        return (($corelib$Result$onOk)((($l) => {
          return (($corelib$Result$onOk)((($f) => {
            return ((($corelib$Dict$forRes)($right))($func))($f);
          })))(((($func)($key))($value))($l));
        })))(((($corelib$Dict$forRes)($left))($func))($acc));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 459:4', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$Dict$forReversed = (($t) => {
  return (($func) => {
    return (($acc) => {
      const $$try0 = $t;
      if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
        return $acc;
      }
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
        const $right = ($$try0)[5];
        const $left = ($$try0)[4];
        const $value = ($$try0)[3];
        const $key = ($$try0)[2];
        return ((($corelib$Dict$forReversed)($left))($func))(((($func)($key))($value))(((($corelib$Dict$forReversed)($right))($func))($acc)));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 471:2', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$List$for = (($aList) => {
  return (($function) => {
    return (($init) => {
      const $$try0 = $aList;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return $init;
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $tail = ($$try0)[2];
        const $h = ($$try0)[1];
        return ((($corelib$List$for)($tail))($function))((($function)($h))($init));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 65:4', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$Dict$fromList = (($assocs) => {
  return ((($corelib$List$for)($assocs))((($keyAndValue) => {
    return (($dict) => {
      return ((($corelib$Dict$insert)($keyAndValue.first))($keyAndValue.second))($dict);
    });
  })))($corelib$Dict$empty);
});

const $corelib$Dict$get = (($targetKey) => {
  return (($dict) => {
    const $$try0 = $dict;
    if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
      return $corelib$Maybe$Nothing;
    }
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
      const $right = ($$try0)[5];
      const $left = ($$try0)[4];
      const $value = ($$try0)[3];
      const $key = ($$try0)[2];
      const $$try1 = ((basics_compare)($targetKey))($key);
      if ((1 === $$try1)) {
        return (($corelib$Dict$get)($targetKey))($right);
      }
      if ((0 === $$try1)) {
        return ($corelib$Maybe$Just)($value);
      }
      if (true) {
        return (($corelib$Dict$get)($targetKey))($left);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 25:6', (sp_toHuman)($$try1));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 20:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$member = (($key) => {
  return (($dict) => {
    const $$try0 = (($corelib$Dict$get)($key))($dict);
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      return true;
    }
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return false;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 42:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$intersect = (($t1) => {
  return (($t2) => {
    return (($corelib$Dict$filter)((($k) => {
      return (() => {
        return (($corelib$Dict$member)($k))($t2);
      });
    })))($t1);
  });
});

const $corelib$Dict$isEmpty = (($dict) => {
  const $$try0 = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
    return true;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 70:2', (sp_toHuman)($$try0));
});

const $corelib$Dict$join = (($a) => {
  return (($corelib$Dict$for)($a))($corelib$Dict$insert);
});

const $corelib$Dict$keys = (($dict) => {
  return ((($corelib$Dict$forReversed)($dict))((($key) => {
    return (($value) => {
      return (($keyList) => {
        return ((sp_cons)($keyList))($key);
      });
    });
  })))($core$SPCore$Nil);
});

const $corelib$Dict$map = (($func) => {
  return (($dict) => {
    const $$try0 = $dict;
    if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
      return $corelib$Dict$RBEmpty_elm_builtin;
    }
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
      const $right = ($$try0)[5];
      const $left = ($$try0)[4];
      const $value = ($$try0)[3];
      const $key = ($$try0)[2];
      const $color = ($$try0)[1];
      return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))((($func)($key))($value)))((($corelib$Dict$map)($func))($left)))((($corelib$Dict$map)($func))($right));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 426:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$mapRes = (($func) => {
  return (($dict) => {
    const $$try0 = $dict;
    if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
      return ($corelib$Result$Ok)($corelib$Dict$RBEmpty_elm_builtin);
    }
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
      const $right = ($$try0)[5];
      const $left = ($$try0)[4];
      const $value = ($$try0)[3];
      const $key = ($$try0)[2];
      const $color = ($$try0)[1];
      return (($corelib$Result$onOk)((($one) => {
        return (($corelib$Result$onOk)((($two) => {
          return (($corelib$Result$onOk)((($three) => {
            return ($corelib$Result$Ok)(((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($one))($two))($three));
          })))((($corelib$Dict$mapRes)($func))($right));
        })))((($corelib$Dict$mapRes)($func))($left));
      })))((($func)($key))($value));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 436:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Dict$toList = (($dict) => {
  const $f = (($key) => {
    return (($value) => {
      return (($list) => {
        return ((sp_cons)($list))(({
          first: $key,
          second: $value,
        }));
      });
    });
  });
  return ((($corelib$Dict$forReversed)($dict))($f))($core$SPCore$Nil);
});

const $corelib$Dict$merge = (($leftStep) => {
  return (($bothStep) => {
    return (($rightStep) => {
      return (($leftDict) => {
        return (($rightDict) => {
          return (($initialResult) => {
            const $stepState = (($rKey) => {
              return (($rValue) => {
                return (($q) => {
                  const list$$ = $q;
                  const $res = list$$.second;
                  const $list = list$$.first;
                  const $$try0 = $list;
                  if (("$core$SPCore$Nil" === ($$try0)[0])) {
                    return ({
                      first: $list,
                      second: ((($rightStep)($rKey))($rValue))($res),
                    });
                  }
                  if (("$core$SPCore$Cons" === ($$try0)[0])) {
                    const $rest = ($$try0)[2];
                    const $lValue = ($$try0)[1].second;
                    const $lKey = ($$try0)[1].first;
                    const $$try1 = ((basics_compare)($lKey))($rKey);
                    if ((1 === $$try1)) {
                      return ({
                        first: $list,
                        second: ((($rightStep)($rKey))($rValue))($res),
                      });
                    }
                    if ((0 === $$try1)) {
                      return ({
                        first: $rest,
                        second: (((($bothStep)($lKey))($lValue))($rValue))($res),
                      });
                    }
                    if (true) {
                      return ((($stepState)($rKey))($rValue))(({
                        first: $rest,
                        second: ((($leftStep)($lKey))($lValue))($res),
                      }));
                    }
                    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 395:10', (sp_toHuman)($$try1));
                    return null;
                  }
                  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 390:4', (sp_toHuman)($$try0));
                });
              });
            });
            const intermediateResult$$ = ((($corelib$Dict$for)($rightDict))($stepState))(({
              first: ($corelib$Dict$toList)($leftDict),
              second: $initialResult,
            }));
            const $intermediateResult = intermediateResult$$.second;
            const $leftovers = intermediateResult$$.first;
            const $liftLeftStep = (($t) => {
              return (($res) => {
                const k$$ = $t;
                const $v = k$$.second;
                const $k = k$$.first;
                return ((($leftStep)($k))($v))($res);
              });
            });
            return ((($corelib$List$for)($leftovers))($liftLeftStep))($intermediateResult);
          });
        });
      });
    });
  });
});

const $corelib$Dict$partition = (($isGood) => {
  return (($dict) => {
    const $add = (($key) => {
      return (($value) => {
        return (($t) => {
          const t1$$ = $t;
          const $t2 = t1$$.second;
          const $t1 = t1$$.first;
          return ((($isGood)($key))($value)
            ? ({
              first: ((($corelib$Dict$insert)($key))($value))($t1),
              second: $t2,
            })
            : ({
              first: $t1,
              second: ((($corelib$Dict$insert)($key))($value))($t2),
            }));
        });
      });
    });
    return ((($corelib$Dict$for)($dict))($add))(({
      first: $corelib$Dict$empty,
      second: $corelib$Dict$empty,
    }));
  });
});

const $corelib$Dict$singleton = (($key) => {
  return (($value) => {
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($key))($value))($corelib$Dict$RBEmpty_elm_builtin))($corelib$Dict$RBEmpty_elm_builtin);
  });
});

const $corelib$Dict$size = ((() => {
  const $sizeHelp = (($n) => {
    return (($dict) => {
      const $$try0 = $dict;
      if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try0)[0])) {
        return $n;
      }
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try0)[0])) {
        const $right = ($$try0)[5];
        const $left = ($$try0)[4];
        return (($sizeHelp)((($sizeHelp)(($n + 1)))($right)))($left);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 57:4', (sp_toHuman)($$try0));
    });
  });
  return ($sizeHelp)(0);
}))();

const $corelib$Dict$update = (($targetKey) => {
  return (($alter) => {
    return (($dictionary) => {
      const $$try0 = ($alter)((($corelib$Dict$get)($targetKey))($dictionary));
      if (("$corelib$Maybe$Just" === ($$try0)[0])) {
        const $value = ($$try0)[1];
        return ((($corelib$Dict$insert)($targetKey))($value))($dictionary);
      }
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return (($corelib$Dict$remove)($targetKey))($dictionary);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 343:2', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$Dict$values = (($dict) => {
  return ((($corelib$Dict$forReversed)($dict))((($key) => {
    return (($value) => {
      return (($valueList) => {
        return ((sp_cons)($valueList))($value);
      });
    });
  })))($core$SPCore$Nil);
});

const $corelib$Dict_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$Dict_Test$insertAndGet = (($sp$Test$Group)("insertAndGet"))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("get, success"))((() => {
  return (($corelib$Dict$get)(($corelib$Maybe$Just)("a")))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty)));
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)(1)))))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("get, fail"))((() => {
  return (($corelib$Dict$get)(($corelib$Maybe$Just)("c")))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty)));
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))($core$SPCore$Nil)));

const $corelib$Dict_Test$lists = (($sp$Test$Group)("lists"))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("keys"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))(($corelib$Dict$keys)(((($corelib$Dict$insert)($corelib$Maybe$Nothing))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty)))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(($corelib$Maybe$Just)("a")))((($core$SPCore$Cons)(($corelib$Maybe$Just)("b")))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("values"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))(($corelib$Dict$values)(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(({
    a: 3,
  })))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(({
    a: 1,
  })))($corelib$Dict$empty))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  a: 1,
})))((($core$SPCore$Cons)(({
  a: 3,
})))($core$SPCore$Nil))))))($core$SPCore$Nil)));

const $corelib$Dict_Test$tests = (($sp$Test$Group)("SPCore/Dict"))((($core$SPCore$Cons)($corelib$Dict_Test$insertAndGet))((($core$SPCore$Cons)($corelib$Dict_Test$lists))($core$SPCore$Nil)));

const $corelib$List$each = (($ls) => {
  return (($f) => {
    const $$try0 = $ls;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return null;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $h = ($$try0)[1];
      ($f)($h);
      return (($corelib$List$each)($tail))($f);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 316:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Hash$fromList = (($l) => {
  const $h = ({
    attr: "$",
    obj: ({
      $: (sp_clone)(hash_empty),
    }),
  });
  (($corelib$List$each)($l))(((k$$) => {
    const $v = k$$.second;
    const $k = k$$.first;
    return (((hash_insert)($h))($k))($v);
  }));
  return (sp_clone)(($h.obj)[$h.attr]);
});

const $corelib$Hash$toList = (($h) => {
  return (((hash_for)($h))((($k) => {
    return (($v) => {
      return (($l) => {
        return ((sp_cons)($l))(({
          first: $k,
          second: $v,
        }));
      });
    });
  })))($core$SPCore$Nil);
});

const $corelib$Hash_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$List$range = (($low) => {
  return (($high) => {
    const $rec = (($accum) => {
      return (($up) => {
        return (($up > $low)
          ? (($rec)(((sp_cons)($accum))($up)))(($up - 1))
          : (((sp_equal)($low))($up)
            ? ((sp_cons)($accum))($up)
            : $accum));
      });
    });
    return (($rec)($core$SPCore$Nil))($high);
  });
});

const $corelib$Tuple$first = (($t) => {
  return $t.first;
});

const $corelib$Hash_Test$tests = (($sp$Test$Group)("Hash"))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("insert"))((() => {
  const $h = ({
    attr: "$",
    obj: ({
      $: ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
        first: 1,
        second: 2,
      })))($core$SPCore$Nil)),
    }),
  });
  (((hash_insert)($h))(2))(3);
  return (sp_clone)(($h.obj)[$h.attr]);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 2,
  second: 3,
})))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("remove"))((() => {
  const $h = ({
    attr: "$",
    obj: ({
      $: ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
        first: 1,
        second: 2,
      })))((($core$SPCore$Cons)(({
        first: 3,
        second: 4,
      })))($core$SPCore$Nil))),
    }),
  });
  ((hash_remove)($h))(1);
  return (sp_clone)(($h.obj)[$h.attr]);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: 3,
  second: 4,
})))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("get Just"))((() => {
  const $h = ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 3,
    second: 4,
  })))($core$SPCore$Nil)));
  return ((hash_get)($h))(1);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)(2)))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("get Nothing"))((() => {
  const $h = ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 3,
    second: 4,
  })))($core$SPCore$Nil)));
  return ((hash_get)($h))(66);
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("for"))((() => {
  return (((hash_for)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: ($corelib$Maybe$Just)(true),
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: $corelib$Maybe$Nothing,
    second: 4,
  })))($core$SPCore$Nil)))))((($k) => {
    return (($v) => {
      return (($a) => {
        return ((list_sortBy)($corelib$Tuple$first))(((sp_cons)($a))(({
          first: $v,
          second: $k,
        })));
      });
    });
  })))($core$SPCore$Nil);
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: 2,
  second: ($corelib$Maybe$Just)(true),
})))((($core$SPCore$Cons)(({
  first: 4,
  second: $corelib$Maybe$Nothing,
})))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("each"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)($core$SPCore$Nil),
    }),
  });
  ((hash_each)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: ($corelib$Maybe$Just)(true),
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: $corelib$Maybe$Nothing,
    second: 1,
  })))($core$SPCore$Nil)))))((($k) => {
    return (($v) => {
      return (($corelib$List$each)((($corelib$List$range)(1))($v)))((() => {
        return ((array_push)($a))($k);
      }));
    });
  }));
  ((array_sortBy)($a))($corelib$Basics$identity);
  return (sp_clone)(($a.obj)[$a.attr]);
})))(($sp$Test$isOkAndEqualTo)((array_fromList)((($core$SPCore$Cons)(($corelib$Maybe$Just)(true)))((($core$SPCore$Cons)(($corelib$Maybe$Just)(true)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil))))))))($core$SPCore$Nil)))))));

const $corelib$List$all = (($fun) => {
  return (($list) => {
    const $$try0 = $list;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return true;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $t = ($$try0)[2];
      const $h = ($$try0)[1];
      return (($fun)($h)
        ? (($corelib$List$all)($fun))($t)
        : false);
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 13:4', (sp_toHuman)($$try0));
  });
});

const $corelib$List$any = (($fun) => {
  return (($list) => {
    const $$try0 = $list;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return false;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $t = ($$try0)[2];
      const $h = ($$try0)[1];
      return (($fun)($h)
        ? true
        : (($corelib$List$any)($fun))($t));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 6:4', (sp_toHuman)($$try0));
  });
});

const $corelib$List$reverse = (($aList) => {
  return ((($corelib$List$for)($aList))($core$SPCore$Cons))($core$SPCore$Nil);
});

const $corelib$List$forReversed = (($list) => {
  return (($f) => {
    return (($init) => {
      const $foldrHelper = (($acc) => {
        return (($ctr) => {
          return (($ls) => {
            const $$try0 = $ls;
            if (("$core$SPCore$Nil" === ($$try0)[0])) {
              return $acc;
            }
            if (("$core$SPCore$Cons" === ($$try0)[0])) {
              const $r1 = ($$try0)[2];
              const $a = ($$try0)[1];
              const $$try1 = $r1;
              if (("$core$SPCore$Nil" === ($$try1)[0])) {
                return (($f)($a))($acc);
              }
              if (("$core$SPCore$Cons" === ($$try1)[0])) {
                const $r2 = ($$try1)[2];
                const $b = ($$try1)[1];
                const $$try2 = $r2;
                if (("$core$SPCore$Nil" === ($$try2)[0])) {
                  return (($f)($a))((($f)($b))($acc));
                }
                if (("$core$SPCore$Cons" === ($$try2)[0])) {
                  const $r3 = ($$try2)[2];
                  const $c = ($$try2)[1];
                  const $$try3 = $r3;
                  if (("$core$SPCore$Nil" === ($$try3)[0])) {
                    return (($f)($a))((($f)($b))((($f)($c))($acc)));
                  }
                  if (("$core$SPCore$Cons" === ($$try3)[0])) {
                    const $r4 = ($$try3)[2];
                    const $d = ($$try3)[1];
                    const $res = (($ctr > 500)
                      ? ((($corelib$List$for)(($corelib$List$reverse)($r4)))($f))($acc)
                      : ((($foldrHelper)($acc))(($ctr + 1)))($r4));
                    return (($f)($a))((($f)($b))((($f)($c))((($f)($d))($res))));
                    return null;
                  }
                  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 93:32', (sp_toHuman)($$try3));
                  return null;
                }
                (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 88:24', (sp_toHuman)($$try2));
                return null;
              }
              (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 83:16', (sp_toHuman)($$try1));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 78:8', (sp_toHuman)($$try0));
          });
        });
      });
      return ((($foldrHelper)($init))(0))($list);
    });
  });
});

const $corelib$List$append = (($xs) => {
  return (($ys) => {
    const $$try0 = $ys;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return $xs;
    }
    if (true) {
      return ((($corelib$List$forReversed)($xs))($core$SPCore$Cons))($ys);
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 183:2', (sp_toHuman)($$try0));
  });
});

const $corelib$List$concat = (($lists) => {
  return ((($corelib$List$forReversed)($lists))($corelib$List$append))($core$SPCore$Nil);
});

const $corelib$List$map = (($f) => {
  return (($list) => {
    return ((($corelib$List$forReversed)($list))((($x) => {
      return (($acc) => {
        return ((sp_cons)($acc))(($f)($x));
      });
    })))($core$SPCore$Nil);
  });
});

const $corelib$List$concatMap = (($f) => {
  return (($list) => {
    return ($corelib$List$concat)((($corelib$List$map)($f))($list));
  });
});

const $corelib$List$drop = (($n) => {
  return (($ls) => {
    return (((sp_equal)(0))($n)
      ? $ls
      : ((() => {
        const $$try0 = $ls;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return $core$SPCore$Nil;
        }
        if (("$core$SPCore$Cons" === ($$try0)[0])) {
          const $tail = ($$try0)[2];
          const $h = ($$try0)[1];
          return (($corelib$List$drop)(($n - 1)))($tail);
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 346:6', (sp_toHuman)($$try0));
      }))());
  });
});

const $corelib$List$filter = (($f) => {
  return (($ls) => {
    return ((($corelib$List$forReversed)($ls))((($item) => {
      return (($acc) => {
        return (($f)($item)
          ? ((sp_cons)($acc))($item)
          : $acc);
      });
    })))($core$SPCore$Nil);
  });
});

const $corelib$List$filterMap = (($f) => {
  return (($la) => {
    const $update = (($a) => {
      return (($acc) => {
        const $$try0 = ($f)($a);
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $b = ($$try0)[1];
          return ((sp_cons)($acc))($b);
        }
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return $acc;
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 293:6', (sp_toHuman)($$try0));
      });
    });
    return ((($corelib$List$forReversed)($la))($update))($core$SPCore$Nil);
  });
});

const $corelib$List$find = (($test) => {
  return (($list) => {
    const $$try0 = $list;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return $corelib$Maybe$Nothing;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $t = ($$try0)[2];
      const $h = ($$try0)[1];
      return (($test)($h)
        ? ($corelib$Maybe$Just)($h)
        : (($corelib$List$find)($test))($t));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 24:4', (sp_toHuman)($$try0));
  });
});

const $corelib$List$foldlRes = (($f) => {
  return (($ls) => {
    return (($accum) => {
      const $$try0 = $ls;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ($corelib$Result$Ok)($accum);
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $t = ($$try0)[2];
        const $h = ($$try0)[1];
        const $$try1 = (($f)($h))($accum);
        if (("$corelib$Result$Err" === ($$try1)[0])) {
          const $x = ($$try1)[1];
          return ($corelib$Result$Err)($x);
        }
        if (("$corelib$Result$Ok" === ($$try1)[0])) {
          const $newAccum = ($$try1)[1];
          return ((($corelib$List$foldlRes)($f))($t))($newAccum);
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 149:12', (sp_toHuman)($$try1));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 144:4', (sp_toHuman)($$try0));
    });
  });
});

const $corelib$List$head = (($list) => {
  const $$try0 = $list;
  if (("$core$SPCore$Nil" === ($$try0)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$core$SPCore$Cons" === ($$try0)[0])) {
    const $t = ($$try0)[2];
    const $h = ($$try0)[1];
    return ($corelib$Maybe$Just)($h);
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 200:4', (sp_toHuman)($$try0));
});

const $corelib$List$indexBy = (($getIndex) => {
  return (($list) => {
    return ((($corelib$List$for)($list))((($i) => {
      return (($corelib$Dict$insert)(($getIndex)($i)))($i);
    })))($corelib$Dict$empty);
  });
});

const $corelib$List$indexedMap = (($f) => {
  const $rec = (($accum) => {
    return (($n) => {
      return (($list) => {
        const $$try0 = $list;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return ($corelib$List$reverse)($accum);
        }
        if (("$core$SPCore$Cons" === ($$try0)[0])) {
          const $t = ($$try0)[2];
          const $h = ($$try0)[1];
          return ((($rec)(((sp_cons)($accum))((($f)($n))($h))))(($n + 1)))($t);
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 174:8', (sp_toHuman)($$try0));
      });
    });
  });
  return (($rec)($core$SPCore$Nil))(0);
});

const $corelib$List$last = (($list) => {
  const $$try0 = $list;
  if (("$core$SPCore$Nil" === ($$try0)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
    const $h = ($$try0)[1];
    return ($corelib$Maybe$Just)($h);
  }
  if (("$core$SPCore$Cons" === ($$try0)[0])) {
    const $t = ($$try0)[2];
    const $h = ($$try0)[1];
    return ($corelib$List$last)($t);
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 207:4', (sp_toHuman)($$try0));
});

const $corelib$List$length = (($list) => {
  return ((($corelib$List$for)($list))((() => {
    return (($a) => {
      return ($a + 1);
    });
  })))(0);
});

const $corelib$List$map2 = (($f) => {
  const $rec = (($accum) => {
    return (($ax) => {
      return (($bx) => {
        const $$try0 = ({
          first: $ax,
          second: $bx,
        });
        if ((("$core$SPCore$Cons" === ($$try0.first)[0]) && ("$core$SPCore$Cons" === ($$try0.second)[0]))) {
          const $btail = ($$try0.second)[2];
          const $bhead = ($$try0.second)[1];
          const $atail = ($$try0.first)[2];
          const $ahead = ($$try0.first)[1];
          return ((($rec)(((sp_cons)($accum))((($f)($ahead))($bhead))))($atail))($btail);
        }
        if (true) {
          return ($corelib$List$reverse)($accum);
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 124:6', (sp_toHuman)($$try0));
      });
    });
  });
  return ($rec)($core$SPCore$Nil);
});

const $corelib$List$mapFirst = (($f) => {
  return (($ls) => {
    const $$try0 = $ls;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return $corelib$Maybe$Nothing;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $h = ($$try0)[1];
      const $r = ($f)($h);
      return (((sp_equal)($corelib$Maybe$Nothing))($r)
        ? (($corelib$List$mapFirst)($f))($tail)
        : $r);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 302:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Result$map = (($f) => {
  return (($result) => {
    const $$try0 = $result;
    if (("$corelib$Result$Err" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return ($corelib$Result$Err)($e);
    }
    if (("$corelib$Result$Ok" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return ($corelib$Result$Ok)(($f)($a));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 10:4', (sp_toHuman)($$try0));
  });
});

const $corelib$List$mapRes = (($f) => {
  return (($list) => {
    const $fun = (($a) => {
      return (($acc) => {
        return (($corelib$Result$map)((($b) => {
          return ((sp_cons)($acc))($b);
        })))(($f)($a));
      });
    });
    return (($corelib$Result$map)($corelib$List$reverse))(((($corelib$List$foldlRes)($fun))($list))($core$SPCore$Nil));
  });
});

const $corelib$List$member = (($a) => {
  return (($list) => {
    const $$try0 = $list;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return false;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $t = ($$try0)[2];
      const $h = ($$try0)[1];
      return (((sp_equal)($h))($a)
        ? true
        : (($corelib$List$member)($a))($t));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 35:4', (sp_toHuman)($$try0));
  });
});

const $corelib$List$minimum = (($list) => {
  const $$try0 = $list;
  if (("$core$SPCore$Cons" === ($$try0)[0])) {
    const $xs = ($$try0)[2];
    const $x = ($$try0)[1];
    return ($corelib$Maybe$Just)(((($corelib$List$for)($xs))($corelib$Basics$min))($x));
  }
  if (true) {
    return $corelib$Maybe$Nothing;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 353:4', (sp_toHuman)($$try0));
});

const $corelib$List$repeat = (($n) => {
  return (($a) => {
    const $rec = (($c) => {
      return (($acc) => {
        return (($c > 0)
          ? (($rec)(($c - 1)))(((sp_cons)($acc))($a))
          : $acc);
      });
    });
    return (($rec)($n))($core$SPCore$Nil);
  });
});

const $corelib$List$sort = (list_sortBy)($corelib$Basics$identity);

const $corelib$List$takeReverse = (($n) => {
  return (($list) => {
    return (($kept) => {
      return (($n < 1)
        ? $kept
        : ((() => {
          const $$try0 = $list;
          if (("$core$SPCore$Nil" === ($$try0)[0])) {
            return $kept;
          }
          if (("$core$SPCore$Cons" === ($$try0)[0])) {
            const $xs = ($$try0)[2];
            const $x = ($$try0)[1];
            return ((($corelib$List$takeReverse)(($n - 1)))($xs))((($core$SPCore$Cons)($x))($kept));
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 257:4', (sp_toHuman)($$try0));
        }))());
    });
  });
});

const $corelib$List$takeTailRec = (($n) => {
  return (($list) => {
    return ($corelib$List$reverse)(((($corelib$List$takeReverse)($n))($list))($core$SPCore$Nil));
  });
});

const $corelib$List$takeFast = (($ctr) => {
  return (($n) => {
    return (($list) => {
      return (($n < 1)
        ? $core$SPCore$Nil
        : ((() => {
          const $$try0 = ({
            first: $n,
            second: $list,
          });
          if (("$core$SPCore$Nil" === ($$try0.second)[0])) {
            return $list;
          }
          if (((1 === $$try0.first) && ("$core$SPCore$Cons" === ($$try0.second)[0]))) {
            const $x = ($$try0.second)[1];
            return (($core$SPCore$Cons)($x))($core$SPCore$Nil);
          }
          if (((2 === $$try0.first) && (("$core$SPCore$Cons" === ($$try0.second)[0]) && ("$core$SPCore$Cons" === (($$try0.second)[2])[0])))) {
            const $y = (($$try0.second)[2])[1];
            const $x = ($$try0.second)[1];
            return (($core$SPCore$Cons)($x))((($core$SPCore$Cons)($y))($core$SPCore$Nil));
          }
          if (((3 === $$try0.first) && (("$core$SPCore$Cons" === ($$try0.second)[0]) && (("$core$SPCore$Cons" === (($$try0.second)[2])[0]) && ("$core$SPCore$Cons" === ((($$try0.second)[2])[2])[0]))))) {
            const $z = ((($$try0.second)[2])[2])[1];
            const $y = (($$try0.second)[2])[1];
            const $x = ($$try0.second)[1];
            return (($core$SPCore$Cons)($x))((($core$SPCore$Cons)($y))((($core$SPCore$Cons)($z))($core$SPCore$Nil)));
          }
          if ((("$core$SPCore$Cons" === ($$try0.second)[0]) && (("$core$SPCore$Cons" === (($$try0.second)[2])[0]) && (("$core$SPCore$Cons" === ((($$try0.second)[2])[2])[0]) && ("$core$SPCore$Cons" === (((($$try0.second)[2])[2])[2])[0]))))) {
            const $tl = (((($$try0.second)[2])[2])[2])[2];
            const $w = (((($$try0.second)[2])[2])[2])[1];
            const $z = ((($$try0.second)[2])[2])[1];
            const $y = (($$try0.second)[2])[1];
            const $x = ($$try0.second)[1];
            const $cons = $core$SPCore$Cons;
            return (($ctr > 1000)
              ? (($cons)($x))((($cons)($y))((($cons)($z))((($cons)($w))((($corelib$List$takeTailRec)(($n - 4)))($tl)))))
              : (($cons)($x))((($cons)($y))((($cons)($z))((($cons)($w))(((($corelib$List$takeFast)(($ctr + 1)))(($n - 4)))($tl))))));
            return null;
          }
          if (true) {
            return $list;
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 223:4', (sp_toHuman)($$try0));
        }))());
    });
  });
});

const $corelib$List$take = ($corelib$List$takeFast)(0);

const $corelib$List$takeWhile = (($test) => {
  const $rec = (($accum) => {
    return (($list) => {
      const $$try0 = $list;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ($corelib$List$reverse)($accum);
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $tail = ($$try0)[2];
        const $head = ($$try0)[1];
        return (($test)($head)
          ? (($rec)(((sp_cons)($accum))($head)))($tail)
          : ($corelib$List$reverse)($accum));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 270:6', (sp_toHuman)($$try0));
    });
  });
  return ($rec)($core$SPCore$Nil);
});

const $corelib$List_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$List_Test$concat = (($sp$Test$Group)("concat"))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("concats two lists"))((() => {
  return ($corelib$List$concat)((($core$SPCore$Cons)((($core$SPCore$Cons)(1))((($core$SPCore$Cons)(2))($core$SPCore$Nil))))((($core$SPCore$Cons)((($core$SPCore$Cons)(3))((($core$SPCore$Cons)(4))($core$SPCore$Nil))))($core$SPCore$Nil)));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(1))((($core$SPCore$Cons)(2))((($core$SPCore$Cons)(3))((($core$SPCore$Cons)(4))($core$SPCore$Nil))))))))($core$SPCore$Nil));

const $corelib$List_Test$sortBy = (($sp$Test$Group)("sortBy"))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Can actually sort stuff"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(($corelib$Maybe$Just)(23)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))((($core$SPCore$Cons)(($corelib$Maybe$Just)(11)))($core$SPCore$Nil))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(($corelib$Maybe$Just)(11)))((($core$SPCore$Cons)(($corelib$Maybe$Just)(23)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Correctly orders tuple-2"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(({
    first: 23,
    second: 1,
  })))((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 11,
    second: 3,
  })))($core$SPCore$Nil))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 11,
  second: 3,
})))((($core$SPCore$Cons)(({
  first: 23,
  second: 1,
})))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Correctly orders tuple-3"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(({
    first: "z",
    second: "a",
    third: "2",
  })))((($core$SPCore$Cons)(({
    first: "a",
    second: "b",
    third: "33",
  })))((($core$SPCore$Cons)(({
    first: "z",
    second: "a",
    third: "1",
  })))((($core$SPCore$Cons)(({
    first: "z",
    second: "b",
    third: "3",
  })))($core$SPCore$Nil)))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: "a",
  second: "b",
  third: "33",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "1",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "2",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "b",
  third: "3",
})))($core$SPCore$Nil))))))))($core$SPCore$Nil))));

const $corelib$List_Test$tests = (($sp$Test$Group)("SPCore/List"))((($core$SPCore$Cons)($corelib$List_Test$sortBy))((($core$SPCore$Cons)($corelib$List_Test$concat))($core$SPCore$Nil)));

const $corelib$Maybe$andThen = (($f) => {
  return (($ma) => {
    const $$try0 = $ma;
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return $corelib$Maybe$Nothing;
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return ($f)($a);
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 9:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Maybe$map = (($f) => {
  return (($m) => {
    const $$try0 = $m;
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return $corelib$Maybe$Nothing;
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $v = ($$try0)[1];
      return ($corelib$Maybe$Just)(($f)($v));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 16:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Maybe$map2 = (($f) => {
  return (($ma) => {
    return (($mb) => {
      return (($corelib$Maybe$andThen)((($a) => {
        return (($corelib$Maybe$andThen)((($b) => {
          return ($corelib$Maybe$Just)((($f)($a))($b));
        })))($mb);
      })))($ma);
    });
  });
});

const $corelib$Maybe$map3 = (($f) => {
  return (($ma) => {
    return (($mb) => {
      return (($mc) => {
        return (($corelib$Maybe$andThen)((($a) => {
          return (($corelib$Maybe$andThen)((($b) => {
            return (($corelib$Maybe$andThen)((($c) => {
              return ($corelib$Maybe$Just)(((($f)($a))($b))($c));
            })))($mc);
          })))($mb);
        })))($ma);
      });
    });
  });
});

const $corelib$Maybe$mapRes = (($f) => {
  return (($m) => {
    const $$try0 = $m;
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return ($corelib$Result$Ok)($corelib$Maybe$Nothing);
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return (($corelib$Result$map)($corelib$Maybe$Just))(($f)($a));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 38:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Maybe$withDefault = (($default) => {
  return (($maybe) => {
    const $$try0 = $maybe;
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $v = ($$try0)[1];
      return $v;
    }
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return $default;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 48:2', (sp_toHuman)($$try0));
  });
});

const $corelib$Result$fromMaybe = (($err) => {
  return (($maybe) => {
    const $$try0 = $maybe;
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return ($corelib$Result$Err)($err);
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return ($corelib$Result$Ok)($a);
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 34:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Result$mapError = (($f) => {
  return (($result) => {
    const $$try0 = $result;
    if (("$corelib$Result$Ok" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return ($corelib$Result$Ok)($a);
    }
    if (("$corelib$Result$Err" === ($$try0)[0])) {
      const $e1 = ($$try0)[1];
      return ($corelib$Result$Err)(($f)($e1));
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 26:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Result$withDefault = (($default) => {
  return (($result) => {
    const $$try0 = $result;
    if (("$corelib$Result$Ok" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return $a;
    }
    if (("$corelib$Result$Err" === ($$try0)[0])) {
      return $default;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 42:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Set$diff = $corelib$Dict$diff;

const $corelib$Set$empty = $corelib$Dict$empty;

const $corelib$Set$insert = (($a) => {
  return (($corelib$Dict$insert)($a))(null);
});

const $corelib$Set$fromList = (($list) => {
  return ((($corelib$List$for)($list))($corelib$Set$insert))($corelib$Set$empty);
});

const $corelib$Set$intersect = $corelib$Dict$intersect;

const $corelib$Set$isEmpty = $corelib$Dict$isEmpty;

const $corelib$Set$join = $corelib$Dict$join;

const $corelib$Set$map = (($f) => {
  return (($set) => {
    return ((($corelib$Dict$for)($set))((($k) => {
      return (() => {
        return (($corelib$Dict$insert)(($f)($k)))(null);
      });
    })))($corelib$Dict$empty);
  });
});

const $corelib$Set$member = $corelib$Dict$member;

const $corelib$Set$remove = $corelib$Dict$remove;

const $corelib$Set$singleton = (($a) => {
  return (($corelib$Dict$singleton)($a))(null);
});

const $corelib$Set$size = $corelib$Dict$size;

const $corelib$Set$toList = $corelib$Dict$keys;

const $corelib$Text$contains = (($sub) => {
  return (($str) => {
    const $$try0 = ((text_split)($sub))($str);
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
      return false;
    }
    if (true) {
      return true;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 115:4', (sp_toHuman)($$try0));
  });
});

const $corelib$Text$dropRight = (($n) => {
  return (($s) => {
    return (($n > 0)
      ? (((text_slice)(0))((0 - $n)))($s)
      : $s);
  });
});

const $corelib$Text$repeat = (($n) => {
  return (($s) => {
    return (($corelib$Text$join)(""))((($corelib$List$repeat)($n))($s));
  });
});

const $corelib$Text$padLeft = (($minLength) => {
  return (($pad) => {
    return (($s) => {
      const $textLength = (text_length)($s);
      return (($textLength < $minLength)
        ? ((() => {
          const $times = ((sp_divide)((text_length)($pad)))(($textLength - $minLength));
          return ((($corelib$Text$repeat)($times))($pad) + $s);
        }))()
        : $s);
    });
  });
});

const $corelib$Text$padRight = (($minLength) => {
  return (($pad) => {
    return (($s) => {
      const $textLength = (text_length)($s);
      return (($textLength < $minLength)
        ? ((() => {
          const $times = ((sp_divide)((text_length)($pad)))(($textLength - $minLength));
          return ($s + (($corelib$Text$repeat)($times))($pad));
        }))()
        : $s);
    });
  });
});

const $corelib$Text$replace = (($toRemove) => {
  return (($toPut) => {
    return (($s) => {
      return (($corelib$Text$join)($toPut))(((text_split)($toRemove))($s));
    });
  });
});

const $corelib$Tuple$mapBoth = (($fa) => {
  return (($fb) => {
    return (($t) => {
      return ({
        first: ($fa)($t.first),
        second: ($fb)($t.second),
      });
    });
  });
});

const $corelib$Tuple$mapFirst = (($f) => {
  return (($t) => {
    return ({
      first: ($f)($t.first),
      second: $t.second,
    });
  });
});

const $corelib$Tuple$mapSecond = (($f) => {
  return (($t) => {
    return ({
      first: $t.first,
      second: ($f)($t.second),
    });
  });
});

const $corelib$Tuple$pair = (($a) => {
  return (($b) => {
    return ({
      first: $a,
      second: $b,
    });
  });
});

const $corelib$Tuple$second = (($t) => {
  return $t.second;
});

const $posix$IO$_run = (($never) => {
  return (($r) => {
    const neverToResult$$ = $r;
    const $neverToResult = (neverToResult$$)[1];
    return ($neverToResult)($never);
  });
});

const $posix$IO$fail = (($message) => {
  return ($posix$IO$IO)((($never) => {
    return ($corelib$Result$Err)($message);
  }));
});

const $posix$IO$onResult = (($f) => {
  return (($m) => {
    return ($posix$IO$IO)((($never) => {
      return (($posix$IO$_run)($never))(($f)((($posix$IO$_run)($never))($m)));
    }));
  });
});

const $posix$IO$onSuccess = (($f) => {
  return (($m) => {
    return ($posix$IO$IO)((($never) => {
      const $$try0 = (($posix$IO$_run)($never))($m);
      if (("$corelib$Result$Ok" === ($$try0)[0])) {
        const $a = ($$try0)[1];
        return (($posix$IO$_run)($never))(($f)($a));
      }
      if (("$corelib$Result$Err" === ($$try0)[0])) {
        const $e = ($$try0)[1];
        return ($corelib$Result$Err)($e);
      }
      (sp_throw)('Missing pattern in try..as', 'posix/IO.sp 39:8', (sp_toHuman)($$try0));
    }));
  });
});

const $posix$IO$succeed = (($a) => {
  return ($posix$IO$IO)((($never) => {
    return ($corelib$Result$Ok)($a);
  }));
});

const $sp$Compiler$CanonicalToJs$accessAttrs = (($attrPath) => {
  return (($e) => {
    return ((($corelib$List$for)($attrPath))($sp$Types$JavascriptAst$AccessWithDot))($e);
  });
});

const $sp$Compiler$CanonicalToJs$accessAttrsButTheLast = (($attrHead) => {
  return (($attrTail) => {
    return (($e) => {
      const $fold = (($attr) => {
        return ((expr$$) => {
          const $last = expr$$.second;
          const $expr = expr$$.first;
          return ({
            first: (($sp$Types$JavascriptAst$AccessWithDot)($last))($expr),
            second: $attr,
          });
        });
      });
      return ((($corelib$List$for)($attrTail))($fold))(({
        first: $e,
        second: $attrHead,
      }));
    });
  });
});

const $sp$Compiler$CanonicalToJs$accessWithBracketsInt = (($index) => {
  return ($sp$Types$JavascriptAst$AccessWithBrackets)(($sp$Types$JavascriptAst$Var)((text_fromNumber)($index)));
});

const $sp$Compiler$CanonicalToJs$accessConstructorArg = $sp$Compiler$CanonicalToJs$accessWithBracketsInt;

const $sp$Compiler$CanonicalToJs$nativeBinops = ((($corelib$Dict$insert)("and"))(({
  fnName: "and",
  jsSymb: "&&",
  mutates: false,
})))(((($corelib$Dict$insert)("or"))(({
  fnName: "or",
  jsSymb: "||",
  mutates: false,
})))(((($corelib$Dict$insert)("<="))(({
  fnName: "lesserOrEqual",
  jsSymb: "<=",
  mutates: false,
})))(((($corelib$Dict$insert)(">="))(({
  fnName: "greaterOrEqual",
  jsSymb: ">=",
  mutates: false,
})))(((($corelib$Dict$insert)("<"))(({
  fnName: "lesserThan",
  jsSymb: "<",
  mutates: false,
})))(((($corelib$Dict$insert)(">"))(({
  fnName: "greaterThan",
  jsSymb: ">",
  mutates: false,
})))(((($corelib$Dict$insert)(".."))(({
  fnName: "strcon",
  jsSymb: "+",
  mutates: false,
})))(((($corelib$Dict$insert)("+="))(({
  fnName: "mutadd",
  jsSymb: "+=",
  mutates: true,
})))(((($corelib$Dict$insert)(":="))(({
  fnName: "mutass",
  jsSymb: "=",
  mutates: true,
})))(((($corelib$Dict$insert)("-"))(({
  fnName: "sub",
  jsSymb: "-",
  mutates: false,
})))(((($corelib$Dict$insert)("*"))(({
  fnName: "mul",
  jsSymb: "*",
  mutates: false,
})))(((($corelib$Dict$insert)("+"))(({
  fnName: "add",
  jsSymb: "+",
  mutates: false,
})))($corelib$Dict$empty))))))))))));

const $sp$Compiler$CoreTypes$umr = (($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore");

const $sp$Compiler$CoreTypes$makeUsr = ($sp$Types$Meta$USR)($sp$Compiler$CoreTypes$umr);

const $sp$Compiler$CoreTypes$false = ($sp$Compiler$CoreTypes$makeUsr)("False");

const $sp$Compiler$CoreTypes$noneName = "None";

const $sp$Compiler$CoreTypes$noneValue = ($sp$Compiler$CoreTypes$makeUsr)($sp$Compiler$CoreTypes$noneName);

const $sp$Compiler$CoreTypes$true = ($sp$Compiler$CoreTypes$makeUsr)("True");

const $sp$Compiler$CoreTypes$p = $sp$Types$Pos$N;

const $sp$Compiler$CoreTypes$defToType = (($def) => {
  return (($sp$Types$CanonicalAst$TypeConstant)($sp$Compiler$CoreTypes$p))($def.usr);
});

const $sp$Compiler$CoreTypes$numberDef = ({
  args: $core$SPCore$Nil,
  constructors: $corelib$Dict$empty,
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Number"),
});

const $sp$Compiler$CoreTypes$number = (($sp$Compiler$CoreTypes$defToType)($sp$Compiler$CoreTypes$numberDef))($core$SPCore$Nil);

const $sp$Prelude$tyFun = ($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N);

const $sp$Prelude$tyVar = ($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N);

const $sp$Prelude$compare = ({
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  type: ((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))($sp$Compiler$CoreTypes$number)),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("compare"),
});

const $sp$Compiler$CoreTypes$nameToType = (($name) => {
  return (($sp$Types$CanonicalAst$TypeConstant)($sp$Compiler$CoreTypes$p))(($sp$Compiler$CoreTypes$makeUsr)($name));
});

const $sp$Compiler$CoreTypes$none = (($sp$Compiler$CoreTypes$nameToType)($sp$Compiler$CoreTypes$noneName))($core$SPCore$Nil);

const $sp$Prelude$debugBenchStart = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$none))(false))($sp$Compiler$CoreTypes$none),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("benchStart"),
});

const $sp$Compiler$CoreTypes$textDef = ({
  args: $core$SPCore$Nil,
  constructors: $corelib$Dict$empty,
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Text"),
});

const $sp$Compiler$CoreTypes$text = (($sp$Compiler$CoreTypes$defToType)($sp$Compiler$CoreTypes$textDef))($core$SPCore$Nil);

const $sp$Prelude$debugBenchStop = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))($sp$Compiler$CoreTypes$none),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("benchStop"),
});

const $sp$Prelude$debugLog = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("a"))),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("log"),
});

const $sp$Prelude$debugToHuman = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))($sp$Compiler$CoreTypes$text),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("toHuman"),
});

const $sp$Prelude$debugTodo = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))(($sp$Prelude$tyVar)("a")),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("todo"),
});

const $sp$Types$Meta$spCorePath = "SPCore";

const $sp$Types$Meta$spCoreUmr = (($sp$Types$Meta$UMR)($sp$Types$Meta$Core))($sp$Types$Meta$spCorePath);

const $sp$Types$Meta$spCoreUSR = ($sp$Types$Meta$USR)($sp$Types$Meta$spCoreUmr);

const $sp$Compiler$CanonicalToJs$allNatives = ((() => {
  const $corelib = (($m) => {
    return (($n) => {
      return (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("corelib")))($m)))($n);
    });
  });
  const $ioModule = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("posix")))("IO"));
  return ((($corelib$Dict$insert)(($ioModule)("writeStdout")))("io_writeStdout"))(((($corelib$Dict$insert)(($ioModule)("writeFile")))("io_writeFile"))(((($corelib$Dict$insert)(($ioModule)("readFile")))("io_readFile"))(((($corelib$Dict$insert)(($ioModule)("readDir")))("io_readDir"))(((($corelib$Dict$insert)(($ioModule)("parallel")))("io_parallel"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("/=")))("sp_not_equal"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("==")))("sp_equal"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("::")))("sp_cons"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("/")))("sp_divide"))(((($corelib$Dict$insert)((($corelib)("List"))("sortBy")))("list_sortBy"))(((($corelib$Dict$insert)((($corelib)("Array"))("toList")))("array_toList"))(((($corelib$Dict$insert)((($corelib)("Array"))("fromList")))("array_fromList"))(((($corelib$Dict$insert)((($corelib)("Array"))("sortBy")))("array_sortBy"))(((($corelib$Dict$insert)((($corelib)("Array"))("set")))("array_set"))(((($corelib$Dict$insert)((($corelib)("Array"))("get")))("array_get"))(((($corelib$Dict$insert)((($corelib)("Array"))("pop")))("array_pop"))(((($corelib$Dict$insert)((($corelib)("Array"))("push")))("array_push"))(((($corelib$Dict$insert)((($corelib)("Hash"))("each")))("hash_each"))(((($corelib$Dict$insert)((($corelib)("Hash"))("for")))("hash_for"))(((($corelib$Dict$insert)((($corelib)("Hash"))("get")))("hash_get"))(((($corelib$Dict$insert)((($corelib)("Hash"))("remove")))("hash_remove"))(((($corelib$Dict$insert)((($corelib)("Hash"))("insert")))("hash_insert"))(((($corelib$Dict$insert)((($corelib)("Hash"))("empty")))("hash_empty"))(((($corelib$Dict$insert)((($corelib)("Text"))("forEach")))("text_forEach"))(((($corelib$Dict$insert)((($corelib)("Text"))("dropLeft")))("text_dropLeft"))(((($corelib$Dict$insert)((($corelib)("Text"))("trimLeft")))("text_trimLeft"))(((($corelib$Dict$insert)((($corelib)("Text"))("replaceRegex")))("text_replaceRegex"))(((($corelib$Dict$insert)((($corelib)("Text"))("startsWithRegex")))("text_startsWithRegex"))(((($corelib$Dict$insert)((($corelib)("Text"))("startsWith")))("text_startsWith"))(((($corelib$Dict$insert)((($corelib)("Text"))("slice")))("text_slice"))(((($corelib$Dict$insert)((($corelib)("Text"))("length")))("text_length"))(((($corelib$Dict$insert)((($corelib)("Text"))("split")))("text_split"))(((($corelib$Dict$insert)((($corelib)("Text"))("toNumber")))("text_toNumber"))(((($corelib$Dict$insert)((($corelib)("Text"))("fromNumber")))("text_fromNumber"))(((($corelib$Dict$insert)((($corelib)("Basics"))("modBy")))("basics_modBy"))(((($corelib$Dict$insert)($sp$Prelude$compare.usr))("basics_compare"))(((($corelib$Dict$insert)($sp$Prelude$debugBenchStop.usr))("sp_benchStop"))(((($corelib$Dict$insert)($sp$Prelude$debugBenchStart.usr))("sp_benchStart"))(((($corelib$Dict$insert)($sp$Prelude$debugToHuman.usr))("sp_toHuman"))(((($corelib$Dict$insert)($sp$Prelude$debugTodo.usr))("sp_todo"))(((($corelib$Dict$insert)($sp$Prelude$debugLog.usr))("sp_log"))(((($corelib$Dict$insert)($sp$Compiler$CoreTypes$noneValue))("null"))(((($corelib$Dict$insert)($sp$Compiler$CoreTypes$false))("false"))(((($corelib$Dict$insert)($sp$Compiler$CoreTypes$true))("true"))(((($corelib$Dict$for)($sp$Compiler$CanonicalToJs$nativeBinops))((($symbol) => {
    return (($v) => {
      return (($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)($symbol)))($v.fnName);
    });
  })))($corelib$Dict$empty)))))))))))))))))))))))))))))))))))))))))))));
}))();

const $sp$Compiler$CanonicalToJs$translateSource = (($src) => {
  const $$try0 = $src;
  if (("$sp$Types$Meta$Core" === ($$try0)[0])) {
    return "core";
  }
  if (("$sp$Types$Meta$SourceDir" === ($$try0)[0])) {
    const $path = ($$try0)[1];
    return (((sp_equal)(""))(((text_startsWithRegex)("[a-zA-Z0-9_./]*$"))($path))
      ? (sp_todo)(("Invalid chars in source dir name: " + $path))
      : ((($corelib$Text$replace)("/"))("$"))(((($corelib$Text$replace)("."))("_"))($path)));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 269:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$CanonicalToJs$translateUsr = (($usr) => {
  const $$try0 = (($corelib$Dict$get)($usr))($sp$Compiler$CanonicalToJs$allNatives);
  if (("$corelib$Maybe$Just" === ($$try0)[0])) {
    const $nv = ($$try0)[1];
    return $nv;
  }
  if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
    const modulePath$$ = $usr;
    const $name = (modulePath$$)[2];
    const $modulePath = ((modulePath$$)[1])[2];
    const $source = ((modulePath$$)[1])[1];
    return ("$" + (($sp$Compiler$CanonicalToJs$translateSource)($source) + ("$" + (((($corelib$Text$replace)("/"))("$"))($modulePath) + ("$" + $name)))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 254:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$CanonicalToJs$translateRef = (($ref) => {
  const $$try0 = $ref;
  if (("$sp$Types$CanonicalAst$RefBlock" === ($$try0)[0])) {
    const $name = ($$try0)[1];
    return ("$" + $name);
  }
  if (("$sp$Types$CanonicalAst$RefRoot" === ($$try0)[0])) {
    const $usr = ($$try0)[1];
    return ($sp$Compiler$CanonicalToJs$translateUsr)($usr);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 243:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$CanonicalToJs$assignPattern = (($nameToReference) => {
  return (($insert) => {
    return (($pattern) => {
      return (($exprAccum) => {
        return (($accum) => {
          const $$try0 = $pattern;
          if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Nothing" === (($$try0)[2])[0]))) {
            return $accum;
          }
          if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[2])[0]))) {
            const $name = (($$try0)[2])[1];
            return ((($insert)($name))((($sp$Types$JavascriptAst$Define)(($sp$Compiler$CanonicalToJs$translateRef)(($nameToReference)($name))))($exprAccum)))($accum);
          }
          if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
            return $accum;
          }
          if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
            return $accum;
          }
          if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
            const $pas = ($$try0)[3];
            const $path = ($$try0)[2];
            const $foldEveryArgument = ((index$$) => {
              const $pa = index$$.second;
              const $index = index$$.first;
              return (((($sp$Compiler$CanonicalToJs$assignPattern)($nameToReference))($insert))($pa))((($sp$Compiler$CanonicalToJs$accessConstructorArg)(($index + 1)))($exprAccum));
            });
            return ((($corelib$List$for)((($corelib$List$indexedMap)($corelib$Tuple$pair))($pas)))($foldEveryArgument))($accum);
            return null;
          }
          if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
            const $attrs = ($$try0)[2];
            return ((($corelib$Dict$for)($attrs))((($name) => {
              return (($pa) => {
                return (((($sp$Compiler$CanonicalToJs$assignPattern)($nameToReference))($insert))($pa))((($sp$Types$JavascriptAst$AccessWithDot)($name))($exprAccum));
              });
            })))($accum);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 902:4', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $sp$Compiler$CanonicalToJs$binopChain = (($default) => {
  return (($op) => {
    return (($es) => {
      const $$try0 = $es;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return $default;
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $tail = ($$try0)[2];
        const $head = ($$try0)[1];
        return ((($corelib$List$for)($tail))(($sp$Types$JavascriptAst$Binop)($op)))($head);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 827:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$CanonicalToJs$circularIsError = (($nodesByUsr) => {
  return (($usrs) => {
    return (($corelib$List$any)((($usr) => {
      const $$try0 = (($corelib$Dict$get)($usr))($nodesByUsr);
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return false;
      }
      if ((("$corelib$Maybe$Just" === ($$try0)[0]) && ("$sp$Compiler$CanonicalToJs$NodeName" === (($$try0)[1])[0]))) {
        return true;
      }
      if ((("$corelib$Maybe$Just" === ($$try0)[0]) && ("$sp$Compiler$CanonicalToJs$NodeDef" === (($$try0)[1])[0]))) {
        const $def = (($$try0)[1])[2];
        const $$try1 = $def.body;
        if (("$sp$Types$CanonicalAst$Lambda" === ($$try1)[0])) {
          return false;
        }
        if (true) {
          return true;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 434:14', (sp_toHuman)($$try1));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 425:6', (sp_toHuman)($$try0));
    })))($usrs);
  });
});

const $sp$Compiler$CanonicalToJs$clone = (($expr) => {
  return (($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Var)("sp_clone")))((($core$SPCore$Cons)($expr))($core$SPCore$Nil));
});

const $sp$Compiler$CanonicalToJs$constructorArgumentName = (($i) => {
  return ("$" + (text_fromNumber)($i));
});

const $sp$Compiler$CanonicalToJs$envToTryName = (($env) => {
  return ({
    first: ("$$try" + (text_fromNumber)($env.tryCounter)),
    second: (Object.assign)({}, $env, ({
      tryCounter: ($env.tryCounter + 1),
    })),
  });
});

const $sp$Types$CanonicalAst$patternNames = (($p) => {
  const $$try0 = $p;
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Nothing" === (($$try0)[2])[0]))) {
    const $pos = ($$try0)[1];
    return $corelib$Dict$empty;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[2])[0]))) {
    const $n = (($$try0)[2])[1];
    const $pos = ($$try0)[1];
    return (($corelib$Dict$singleton)($n))($pos);
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $corelib$Dict$empty;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $corelib$Dict$empty;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
    const $ps = ($$try0)[3];
    const $path = ($$try0)[2];
    const $pos = ($$try0)[1];
    return ((($corelib$List$for)($ps))((($x) => {
      return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($x));
    })))($corelib$Dict$empty);
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
    const $ps = ($$try0)[2];
    const $pos = ($$try0)[1];
    return ((($corelib$Dict$for)($ps))((($k) => {
      return (($v) => {
        return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($v));
      });
    })))($corelib$Dict$empty);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 212:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$CanonicalToJs$getValueDefName = (($def) => {
  return (($corelib$Maybe$withDefault)("BLARGH"))(($corelib$List$head)(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($def.pattern))));
});

const $sp$Compiler$CoreTypes$cons = ($sp$Compiler$CoreTypes$makeUsr)("Cons");

const $sp$Compiler$CanonicalToJs$listCons = ($sp$Compiler$CanonicalToJs$translateUsr)($sp$Compiler$CoreTypes$cons);

const $sp$Compiler$CoreTypes$nil = ($sp$Compiler$CoreTypes$makeUsr)("Nil");

const $sp$Compiler$CanonicalToJs$listNil = ($sp$Compiler$CanonicalToJs$translateUsr)($sp$Compiler$CoreTypes$nil);

const $sp$Compiler$CanonicalToJs$makeUsr = (($module) => {
  return (($name) => {
    return (($sp$Types$Meta$USR)($module.umr))($name);
  });
});

const $sp$Types$CanonicalAst$skipLetIns = (($expr) => {
  const $$try0 = $expr;
  if (("$sp$Types$CanonicalAst$LetIn" === ($$try0)[0])) {
    const $e = ($$try0)[2];
    const $def = ($$try0)[1];
    return ($sp$Types$CanonicalAst$skipLetIns)($e);
  }
  if (true) {
    return $expr;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 175:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$CanonicalToJs$maybeCloneMutable = (($caDef) => {
  return (($expr) => {
    return (($corelib$Basics$not)($caDef.mutable)
      ? $expr
      : ((() => {
        const $$try0 = ($sp$Types$CanonicalAst$skipLetIns)($caDef.body);
        if (("$sp$Types$CanonicalAst$Variable" === ($$try0)[0])) {
          const $ar = ($$try0)[2];
          return ($sp$Compiler$CanonicalToJs$clone)($expr);
        }
        if (true) {
          return $expr;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 500:8', (sp_toHuman)($$try0));
      }))());
  });
});

const $sp$Compiler$CanonicalToJs$none = ($sp$Compiler$CanonicalToJs$translateUsr)($sp$Compiler$CoreTypes$noneValue);

const $sp$Compiler$CanonicalToJs$quoteAndEscape = (($s) => {
  const $escaped = ((($corelib$Text$replace)("\""))("\\\""))(((($corelib$Text$replace)("\n"))("\\n"))($s));
  return ("\"" + ($escaped + "\""));
});

const $sp$Prelude$typeUnopUniform = (($type) => {
  return ((($sp$Prelude$tyFun)($type))(false))($type);
});

const $sp$Prelude$unaryMinus = ({
  symbol: "0 -",
  type: ($sp$Prelude$typeUnopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$unaryPlus = ({
  symbol: "0 +",
  type: ($sp$Prelude$typeUnopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Compiler$CanonicalToJs$nativeUnops = ((($corelib$Dict$insert)($sp$Prelude$unaryMinus.symbol))(({
  jsSymb: "-",
})))(((($corelib$Dict$insert)($sp$Prelude$unaryPlus.symbol))(({
  jsSymb: "+",
})))($corelib$Dict$empty));

const $sp$Compiler$CanonicalToJs$maybeNativeUnop = (($env) => {
  return (($reference) => {
    return (($argument) => {
      const $$try0 = $reference;
      if ((("$sp$Types$CanonicalAst$Variable" === ($$try0)[0]) && (("$sp$Types$CanonicalAst$RefRoot" === (($$try0)[2].ref)[0]) && ("$sp$Types$Meta$USR" === ((($$try0)[2].ref)[1])[0])))) {
        const $name = ((($$try0)[2].ref)[1])[2];
        const $attrPath = ($$try0)[2].attrPath;
        const $$try1 = (($corelib$Dict$get)($name))($sp$Compiler$CanonicalToJs$nativeUnops);
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return $corelib$Maybe$Nothing;
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $jsSymb = ($$try1)[1].jsSymb;
          return ($corelib$Maybe$Just)((($sp$Types$JavascriptAst$Unop)($jsSymb))($argument));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 783:12', (sp_toHuman)($$try1));
        return null;
      }
      if (true) {
        return $corelib$Maybe$Nothing;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 781:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$CanonicalToJs$patternDefinitions = (($mainName) => {
  return (($pattern) => {
    const $$try0 = $pattern;
    if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[2])[0]))) {
      const $pos = ($$try0)[1];
      return $core$SPCore$Nil;
    }
    if (true) {
      return ((((($sp$Compiler$CanonicalToJs$assignPattern)($sp$Types$CanonicalAst$RefBlock))((() => {
        return (($s) => {
          return (($a) => {
            return ((sp_cons)($a))($s);
          });
        });
      })))($pattern))(($sp$Types$JavascriptAst$Var)($mainName)))($core$SPCore$Nil);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 929:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$CanonicalToJs$pickMainName = (($pattern) => {
  const $x = ((() => {
    const $$try0 = $pattern;
    if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[2])[0]))) {
      const $name = (($$try0)[2])[1];
      return ($corelib$Maybe$Just)(("$" + $name));
    }
    if (true) {
      return (($corelib$Maybe$map)((($s) => {
        return ($s + "$$");
      })))(($corelib$List$head)(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($pattern))));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 296:8', (sp_toHuman)($$try0));
  }))();
  return (($corelib$Maybe$map)((($s) => {
    return ((($corelib$Text$replace)("."))("$"))(((($corelib$Text$replace)("/"))("$"))($s));
  })))($x);
});

const $sp$Compiler$CanonicalToJs$testPattern = (($pattern) => {
  return (($valueToTest) => {
    return (($accum) => {
      const $$try0 = $pattern;
      if (("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0])) {
        return $accum;
      }
      if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
        const $text = ($$try0)[2];
        return ((sp_cons)($accum))(((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)($text))))($valueToTest));
      }
      if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
        const $num = ($$try0)[2];
        return ((sp_cons)($accum))(((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)((text_fromNumber)($num))))($valueToTest));
      }
      if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
        const $pas = ($$try0)[3];
        const $usr = ($$try0)[2];
        const $head = ((() => {
          const $$try1 = (($corelib$Dict$get)($usr))($sp$Compiler$CanonicalToJs$allNatives);
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $nv = ($$try1)[1];
            return ((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)($nv)))($valueToTest);
          }
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return ((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)))))((($sp$Compiler$CanonicalToJs$accessWithBracketsInt)(0))($valueToTest));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 878:16', (sp_toHuman)($$try1));
        }))();
        const $foldArg = (($argPattern) => {
          return ((acc$$) => {
            const $acc = acc$$.second;
            const $index = acc$$.first;
            return ({
              first: ($index + 1),
              second: ((($sp$Compiler$CanonicalToJs$testPattern)($argPattern))((($sp$Compiler$CanonicalToJs$accessWithBracketsInt)($index))($valueToTest)))($acc),
            });
          });
        });
        return ($corelib$Tuple$second)(((($corelib$List$for)($pas))($foldArg))(({
          first: 1,
          second: ((sp_cons)($accum))($head),
        })));
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
        const $attrs = ($$try0)[2];
        const $foldAttr = (($name) => {
          return (($pa) => {
            return (($sp$Compiler$CanonicalToJs$testPattern)($pa))((($sp$Types$JavascriptAst$AccessWithDot)($name))($valueToTest));
          });
        });
        return ((($corelib$Dict$for)($attrs))($foldAttr))($accum);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 865:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$CanonicalToJs$wrapMutable = (($mutable) => {
  return (($expr) => {
    return ($mutable
      ? ($sp$Types$JavascriptAst$Record)(((($corelib$Dict$insert)("obj"))(($sp$Types$JavascriptAst$Record)((($corelib$Dict$singleton)("$"))($expr))))(((($corelib$Dict$insert)("attr"))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)("$"))))($corelib$Dict$empty)))
      : $expr);
  });
});

const $sp$Compiler$CanonicalToJs$translateLocalValueDef = (($env) => {
  return (($caDef) => {
    const $$try0 = ($sp$Compiler$CanonicalToJs$pickMainName)($caDef.pattern);
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return ({
        first: (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Eval)((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($caDef.body))))($core$SPCore$Nil),
        second: $env,
      });
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $mainName = ($$try0)[1];
      const $a = (($sp$Types$JavascriptAst$Define)($mainName))((($sp$Compiler$CanonicalToJs$wrapMutable)($caDef.mutable))((($sp$Compiler$CanonicalToJs$maybeCloneMutable)($caDef))((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($caDef.body))));
      const $b = ($caDef.mutable
        ? (Object.assign)({}, $env, ({
          mutables: (($corelib$Set$insert)($mainName))($env.mutables),
        }))
        : $env);
      return ({
        first: ((sp_cons)((($sp$Compiler$CanonicalToJs$patternDefinitions)($mainName))($caDef.pattern)))($a),
        second: $b,
      });
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 509:8', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$CanonicalToJs$unwrapMutable = (($x) => {
  const $ja_x = ($sp$Types$JavascriptAst$Var)($x);
  return (($sp$Types$JavascriptAst$AccessWithBrackets)((($sp$Types$JavascriptAst$AccessWithDot)("attr"))($ja_x)))((($sp$Types$JavascriptAst$AccessWithDot)("obj"))($ja_x));
});

const $sp$Compiler$CanonicalToJs$translateVar = (($env) => {
  return (($varArgs) => {
    const attrPath$$ = $varArgs;
    const $ref = attrPath$$.ref;
    const $attrPath = attrPath$$.attrPath;
    const $jname = ($sp$Compiler$CanonicalToJs$translateRef)($ref);
    return ((($corelib$Set$member)($jname))($env.mutables)
      ? ($sp$Compiler$CanonicalToJs$clone)((($sp$Compiler$CanonicalToJs$accessAttrs)($attrPath))(($sp$Compiler$CanonicalToJs$unwrapMutable)($jname)))
      : (($sp$Compiler$CanonicalToJs$accessAttrs)($attrPath))(($sp$Types$JavascriptAst$Var)($jname)));
  });
});

const $sp$Compiler$Error$positionToLineAndColumn = (($s) => {
  return (($index) => {
    const $before = (((text_slice)(0))($index))($s);
    const $lines = ((text_split)("\n"))($before);
    const $lineNumber = ($corelib$List$length)($lines);
    const $colNumber = (($corelib$Maybe$withDefault)(0))((($corelib$Maybe$map)(text_length))(($corelib$List$last)($lines)));
    return ({
      col: $colNumber,
      line: $lineNumber,
    });
  });
});

const $sp$Compiler$Error$highlightSplit = (($h) => {
  return (($x) => {
    const lines$$ = $x;
    const $lines = lines$$.second;
    const $words = lines$$.first;
    const $$try0 = $h;
    if (("$sp$Compiler$Error$HighlightWord" === ($$try0)[0])) {
      const $line = ($$try0)[1].line;
      const $colStart = ($$try0)[1].colStart;
      const $colEnd = ($$try0)[1].colEnd;
      return ({
        first: ((($corelib$Dict$insert)($line))(({
          first: $colStart,
          second: $colEnd,
        })))($words),
        second: $lines,
      });
    }
    if (("$sp$Compiler$Error$HighlightBlock" === ($$try0)[0])) {
      const $lineStart = ($$try0)[1].lineStart;
      const $lineEnd = ($$try0)[1].lineEnd;
      return ({
        first: $words,
        second: ((($corelib$List$for)((($corelib$List$range)($lineStart))($lineEnd)))($corelib$Set$insert))($lines),
      });
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 141:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$Error$formatSeparator = "$|$|$";

const $sp$Compiler$Error$formatSuffix = "$`$`$";

const $sp$Compiler$Error$formatWrap = (($fmtName) => {
  return (($text) => {
    return ($sp$Compiler$Error$formatSeparator + ($fmtName + ($sp$Compiler$Error$formatSuffix + ($text + $sp$Compiler$Error$formatSeparator))));
  });
});

const $sp$Compiler$Error$warn = ($sp$Compiler$Error$formatWrap)("warning");

const $sp$Compiler$Error$fmtBlock = (($start) => {
  return (($highlights) => {
    return (($ls) => {
      const highlightedLines$$ = ((($corelib$List$for)($highlights))($sp$Compiler$Error$highlightSplit))(({
        first: $corelib$Dict$empty,
        second: $corelib$Set$empty,
      }));
      const $highlightedLines = highlightedLines$$.second;
      const $highlightedWords = highlightedLines$$.first;
      const $pad = (text_length)((text_fromNumber)(($start + ($corelib$List$length)($ls))));
      const $wordHighlight = (($lineNumber) => {
        const $$try0 = (($corelib$Dict$get)($lineNumber))($highlightedWords);
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return "";
        }
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $e = ($$try0)[1].second;
          const $s = ($$try0)[1].first;
          return ("\n" + ((($corelib$Text$repeat)($pad))(" ") + ("   " + ((($corelib$Text$repeat)(($s - 1)))(" ") + ($sp$Compiler$Error$warn)((($corelib$Text$repeat)((($corelib$Basics$max)(1))(($e - $s))))("^"))))));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 162:8', (sp_toHuman)($$try0));
      });
      const $lineDem = (($lineIndex) => {
        return ((($corelib$Set$member)($lineIndex))($highlightedLines)
          ? ($sp$Compiler$Error$warn)(" > ")
          : " | ");
      });
      const $fmtLine = (($i) => {
        return (($line) => {
          const $index = ($i + $start);
          const $s = ((($corelib$Text$padLeft)($pad))(" "))((text_fromNumber)($index));
          return ($s + (($lineDem)($index) + ($line + ($wordHighlight)($index))));
        });
      });
      return ((($s) => {
        return ($s + "\n");
      }))((($corelib$Text$join)("\n"))((($corelib$List$indexedMap)($fmtLine))($ls)));
    });
  });
});

const $sp$Compiler$Error$showCodeBlock = (($code) => {
  return (($start) => {
    return (($end) => {
      return (($end.line < 0)
        ? ""
        : ((() => {
          const $highlight = (((sp_not_equal)($end.line))($start.line)
            ? ($sp$Compiler$Error$HighlightBlock)(({
              lineEnd: $end.line,
              lineStart: $start.line,
            }))
            : ($sp$Compiler$Error$HighlightWord)(({
              colEnd: $end.col,
              colStart: $start.col,
              line: $start.line,
            })));
          const $extraLines = 2;
          const $lines = ((text_split)("\n"))($code);
          const $maxLines = ($corelib$List$length)($lines);
          const $startLine = ((($corelib$Basics$clamp)(0))(($maxLines - 1)))(($start.line - ($extraLines - 1)));
          const $endLine = ((($corelib$Basics$clamp)(0))(($maxLines - 1)))(($end.line + $extraLines));
          const $size = (($corelib$Basics$max)(1))(($endLine - $startLine));
          return ((($sp$Compiler$Error$fmtBlock)(($startLine + 1)))((($core$SPCore$Cons)($highlight))($core$SPCore$Nil)))((($corelib$List$take)($size))((($corelib$List$drop)($startLine))($lines)));
        }))());
    });
  });
});

const $sp$Compiler$Error$posToHuman = (($eEnv) => {
  return (($pos) => {
    const $noBlock = (($loc) => {
      return ({
        block: "",
        location: $loc,
      });
    });
    const $$try0 = $pos;
    if (("$sp$Types$Pos$P" === ($$try0)[0])) {
      const $endAsInt = ($$try0)[3];
      const $startAsInt = ($$try0)[2];
      const $moduleName = ($$try0)[1];
      const $$try1 = (($corelib$Dict$get)($moduleName))($eEnv.moduleByName);
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $mod = ($$try1)[1];
        const $start = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))($startAsInt);
        const $end = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))($endAsInt);
        return ({
          block: ((($sp$Compiler$Error$showCodeBlock)($mod.content))($start))($end),
          location: ($mod.fsPath + (" " + ((text_fromNumber)($start.line) + (":" + (text_fromNumber)($start.col))))),
        });
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 252:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$Pos$End" === ($$try0)[0])) {
      const $moduleName = ($$try0)[1];
      const $$try1 = (($corelib$Dict$get)($moduleName))($eEnv.moduleByName);
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $mod = ($$try1)[1];
        const $end = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))(((text_length)($mod.content) - 1));
        const $start = ({
          col: 0,
          line: ($end.line - 8),
        });
        return ({
          block: ((($sp$Compiler$Error$showCodeBlock)($mod.content))($start))($end),
          location: ($mod.fsPath + (" " + ((text_fromNumber)($end.line) + ":0 (end of file)"))),
        });
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 268:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$Pos$N" === ($$try0)[0])) {
      return ($noBlock)("<native code>");
    }
    if (("$sp$Types$Pos$S" === ($$try0)[0])) {
      return ($noBlock)("<the location information has been stripped>");
    }
    if (("$sp$Types$Pos$T" === ($$try0)[0])) {
      return ($noBlock)("<defined in test modules>");
    }
    if (("$sp$Types$Pos$I" === ($$try0)[0])) {
      const $n = ($$try0)[1];
      return ($noBlock)(("<inferred " + ((text_fromNumber)($n) + ">")));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 250:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$CanonicalToJs$translateExpressionToEither = (($env) => {
  return (($expression) => {
    const $$try0 = $expression;
    if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try0)[0])) {
      const $num = ($$try0)[2];
      return ($sp$Compiler$CanonicalToJs$Left)(($sp$Types$JavascriptAst$Literal)((text_fromNumber)($num)));
    }
    if (("$sp$Types$CanonicalAst$LiteralText" === ($$try0)[0])) {
      const $text = ($$try0)[2];
      return ($sp$Compiler$CanonicalToJs$Left)(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)($text)));
    }
    if (("$sp$Types$CanonicalAst$Variable" === ($$try0)[0])) {
      const $ar = ($$try0)[2];
      return ($sp$Compiler$CanonicalToJs$Left)((($sp$Compiler$CanonicalToJs$translateVar)($env))($ar));
    }
    if (("$sp$Types$CanonicalAst$Constructor" === ($$try0)[0])) {
      const $usr = ($$try0)[2];
      const $$try1 = (($corelib$Dict$get)($usr))($sp$Compiler$CanonicalToJs$allNatives);
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ($sp$Compiler$CanonicalToJs$Left)(($sp$Types$JavascriptAst$Var)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)));
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $n = ($$try1)[1];
        return ($sp$Compiler$CanonicalToJs$Left)(($sp$Types$JavascriptAst$Var)($n));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 566:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$Lambda" === ($$try0)[0])) {
      const $body = ($$try0)[3];
      const $parameter = ($$try0)[2];
      const $pos = ($$try0)[1];
      const args$$ = ((() => {
        const $$try1 = $parameter;
        if (("$sp$Types$CanonicalAst$ParameterMutable" === ($$try1)[0])) {
          const $name = ($$try1)[2];
          const $jaName = ("$" + $name);
          return ({
            first: (($core$SPCore$Cons)($jaName))($core$SPCore$Nil),
            second: $core$SPCore$Nil,
            third: (Object.assign)({}, $env, ({
              mutables: (($corelib$Set$insert)($jaName))($env.mutables),
            })),
          });
          return null;
        }
        if (("$sp$Types$CanonicalAst$ParameterPattern" === ($$try1)[0])) {
          const $pattern = ($$try1)[1];
          const $$try2 = ($sp$Compiler$CanonicalToJs$pickMainName)($pattern);
          if (("$corelib$Maybe$Nothing" === ($$try2)[0])) {
            return ({
              first: $core$SPCore$Nil,
              second: $core$SPCore$Nil,
              third: $env,
            });
          }
          if (("$corelib$Maybe$Just" === ($$try2)[0])) {
            const $mainName = ($$try2)[1];
            return ({
              first: (($core$SPCore$Cons)($mainName))($core$SPCore$Nil),
              second: (($sp$Compiler$CanonicalToJs$patternDefinitions)($mainName))($pattern),
              third: $env,
            });
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 582:24', (sp_toHuman)($$try2));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 575:16', (sp_toHuman)($$try1));
      }))();
      const $localEnv = args$$.third;
      const $extraJaStatements = args$$.second;
      const $args = args$$.first;
      const $statements = ((() => {
        const $$try1 = (($sp$Compiler$CanonicalToJs$translateExpressionToEither)($localEnv))($body);
        if (("$sp$Compiler$CanonicalToJs$Left" === ($$try1)[0])) {
          const $expr = ($$try1)[1];
          return (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)($expr)))($core$SPCore$Nil);
        }
        if (("$sp$Compiler$CanonicalToJs$Right" === ($$try1)[0])) {
          const $block = ($$try1)[1];
          return $block;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 590:16', (sp_toHuman)($$try1));
      }))();
      return ($sp$Compiler$CanonicalToJs$Left)((($sp$Types$JavascriptAst$BlockLambda)($args))(($corelib$List$concat)((($core$SPCore$Cons)($extraJaStatements))((($core$SPCore$Cons)($statements))($core$SPCore$Nil)))));
      return null;
    }
    if (("$sp$Types$CanonicalAst$Record" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $extends = ($$try0)[2];
      const $obj = ($sp$Types$JavascriptAst$Record)((($corelib$Dict$map)((($k) => {
        return ($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env);
      })))($attrs));
      const $$try1 = $extends;
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ($sp$Compiler$CanonicalToJs$Left)($obj);
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $extend = ($$try1)[1];
        return ($sp$Compiler$CanonicalToJs$Left)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Var)("Object.assign")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Record)($corelib$Dict$empty)))((($core$SPCore$Cons)((($sp$Compiler$CanonicalToJs$translateVar)($env))($extend)))((($core$SPCore$Cons)($obj))($core$SPCore$Nil)))));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 602:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$Call" === ($$try0)[0])) {
      const $arg = ($$try0)[3];
      const $ref = ($$try0)[2];
      const $$try1 = ((($sp$Compiler$CanonicalToJs$maybeNativeBinop)($env))($ref))($arg);
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $jaExpr = ($$try1)[1];
        return ($sp$Compiler$CanonicalToJs$Left)($jaExpr);
      }
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        const $jsArg = ((($sp$Compiler$CanonicalToJs$translateArg)(({
          nativeBinop: false,
        })))($env))($arg);
        const $$try2 = ((($sp$Compiler$CanonicalToJs$maybeNativeUnop)($env))($ref))($jsArg);
        if (("$corelib$Maybe$Just" === ($$try2)[0])) {
          const $jaExpr = ($$try2)[1];
          return ($sp$Compiler$CanonicalToJs$Left)($jaExpr);
        }
        if (("$corelib$Maybe$Nothing" === ($$try2)[0])) {
          return ($sp$Compiler$CanonicalToJs$Left)((($sp$Types$JavascriptAst$Call)((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($ref)))((($core$SPCore$Cons)($jsArg))($core$SPCore$Nil)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 622:20', (sp_toHuman)($$try2));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 615:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$If" === ($$try0)[0])) {
      const $ar = ($$try0)[2];
      return ($sp$Compiler$CanonicalToJs$Left)(((($sp$Types$JavascriptAst$Conditional)((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($ar.condition)))((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($ar.true)))((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($ar.false)));
    }
    if (("$sp$Types$CanonicalAst$Try" === ($$try0)[0])) {
      const $tries = ($$try0)[3];
      const $value = ($$try0)[2];
      const $pos = ($$try0)[1];
      const newEnv$$ = ($sp$Compiler$CanonicalToJs$envToTryName)($env);
      const $newEnv = newEnv$$.second;
      const $tryName = newEnv$$.first;
      const $head = (($sp$Types$JavascriptAst$Define)($tryName))((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($newEnv))($value));
      const $init = ($sp$Types$JavascriptAst$Var)($tryName);
      const $testPa = ((block$$) => {
        const $block = block$$.second;
        const $pattern = block$$.first;
        const $extraStats = ((((($sp$Compiler$CanonicalToJs$assignPattern)($sp$Types$CanonicalAst$RefBlock))((() => {
          return (($stat) => {
            return (($acc) => {
              return ((sp_cons)($acc))($stat);
            });
          });
        })))($pattern))(($sp$Types$JavascriptAst$Var)($tryName)))($core$SPCore$Nil);
        const $condition = ((($sp$Compiler$CanonicalToJs$binopChain)(($sp$Types$JavascriptAst$Literal)("true")))("&&"))(((($sp$Compiler$CanonicalToJs$testPattern)($pattern))($init))($core$SPCore$Nil));
        const $whenConditionMatches = ((() => {
          const $$try1 = (($sp$Compiler$CanonicalToJs$translateExpressionToEither)($newEnv))($block);
          if (("$sp$Compiler$CanonicalToJs$Left" === ($$try1)[0])) {
            const $e = ($$try1)[1];
            return ($corelib$List$concat)((($core$SPCore$Cons)($extraStats))((($core$SPCore$Cons)((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)($e)))($core$SPCore$Nil)))($core$SPCore$Nil)));
          }
          if (("$sp$Compiler$CanonicalToJs$Right" === ($$try1)[0])) {
            const $bl = ($$try1)[1];
            return ($corelib$List$concat)((($core$SPCore$Cons)($extraStats))((($core$SPCore$Cons)($bl))((($core$SPCore$Cons)((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)(($sp$Types$JavascriptAst$Literal)("null"))))($core$SPCore$Nil)))($core$SPCore$Nil))));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 674:20', (sp_toHuman)($$try1));
        }))();
        return (($sp$Types$JavascriptAst$If)($condition))($whenConditionMatches);
      });
      const $human = (($sp$Compiler$Error$posToHuman)($newEnv.errorEnv))($pos);
      const $default = ($sp$Types$JavascriptAst$Eval)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Literal)("sp_throw")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Literal)("'Missing pattern in try..as'")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Literal)(("'" + ($human.location + "'")))))((($core$SPCore$Cons)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Literal)("sp_toHuman")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Var)($tryName)))($core$SPCore$Nil))))($core$SPCore$Nil)))));
      return ($sp$Compiler$CanonicalToJs$Right)(($corelib$List$concat)((($core$SPCore$Cons)(((sp_cons)((($corelib$List$map)($testPa))($tries)))($head)))((($core$SPCore$Cons)((($core$SPCore$Cons)($default))($core$SPCore$Nil)))($core$SPCore$Nil))));
      return null;
    }
    if (("$sp$Types$CanonicalAst$LetIn" === ($$try0)[0])) {
      const $expression = ($$try0)[2];
      const $valueDef = ($$try0)[1];
      const defStatements$$ = (($sp$Compiler$CanonicalToJs$translateLocalValueDef)($env))($valueDef);
      const $localEnv = defStatements$$.second;
      const $defStatements = defStatements$$.first;
      const $exprStatements = ((() => {
        const $$try1 = (($sp$Compiler$CanonicalToJs$translateExpressionToEither)($localEnv))($expression);
        if (("$sp$Compiler$CanonicalToJs$Right" === ($$try1)[0])) {
          const $stats = ($$try1)[1];
          return $stats;
        }
        if (("$sp$Compiler$CanonicalToJs$Left" === ($$try1)[0])) {
          const $jaExpression = ($$try1)[1];
          return (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)($jaExpression)))($core$SPCore$Nil);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 703:16', (sp_toHuman)($$try1));
      }))();
      return ($sp$Compiler$CanonicalToJs$Right)(($corelib$List$concat)((($core$SPCore$Cons)($defStatements))((($core$SPCore$Cons)($exprStatements))($core$SPCore$Nil))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 555:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$CanonicalToJs$translateExpressionToExpression = (($env) => {
  return (($expr) => {
    const $$try0 = (($sp$Compiler$CanonicalToJs$translateExpressionToEither)($env))($expr);
    if (("$sp$Compiler$CanonicalToJs$Left" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return $e;
    }
    if (("$sp$Compiler$CanonicalToJs$Right" === ($$try0)[0])) {
      const $block = ($$try0)[1];
      return (($sp$Types$JavascriptAst$Call)((($sp$Types$JavascriptAst$BlockLambda)($core$SPCore$Nil))($block)))($core$SPCore$Nil);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 713:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$CanonicalToJs$translateArg = (($stuff) => {
  return (($env) => {
    return (($arg) => {
      const nativeBinop$$ = $stuff;
      const $nativeBinop = nativeBinop$$.nativeBinop;
      const $$try0 = $arg;
      if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try0)[0])) {
        const $e = ($$try0)[1];
        return (($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($e);
      }
      if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try0)[0])) {
        const $ref = ($$try0)[2].ref;
        const $attrPath = ($$try0)[2].attrPath;
        return ($nativeBinop
          ? (($sp$Compiler$CanonicalToJs$accessAttrs)($attrPath))(($sp$Compiler$CanonicalToJs$unwrapMutable)(($sp$Compiler$CanonicalToJs$translateRef)($ref)))
          : ((() => {
            const $$try1 = $attrPath;
            if (("$core$SPCore$Nil" === ($$try1)[0])) {
              return ($sp$Types$JavascriptAst$Var)(($sp$Compiler$CanonicalToJs$translateRef)($ref));
            }
            if (("$core$SPCore$Cons" === ($$try1)[0])) {
              const $tail = ($$try1)[2];
              const $head = ($$try1)[1];
              return (((lastAttrName$$) => {
                const $lastAttrName = lastAttrName$$.second;
                const $wrappedExpr = lastAttrName$$.first;
                return ($sp$Types$JavascriptAst$Record)(((($corelib$Dict$insert)("attr"))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)($lastAttrName))))(((($corelib$Dict$insert)("obj"))($wrappedExpr))($corelib$Dict$empty)));
              }))(((($sp$Compiler$CanonicalToJs$accessAttrsButTheLast)($head))($tail))(($sp$Compiler$CanonicalToJs$unwrapMutable)(($sp$Compiler$CanonicalToJs$translateRef)($ref))));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 740:16', (sp_toHuman)($$try1));
          }))());
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 726:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$CanonicalToJs$maybeNativeBinop = (($env) => {
  return (($reference) => {
    return (($argument) => {
      const $$try0 = $reference;
      if ((("$sp$Types$CanonicalAst$Call" === ($$try0)[0]) && (("$sp$Types$CanonicalAst$Variable" === (($$try0)[2])[0]) && (("$sp$Types$CanonicalAst$RefRoot" === ((($$try0)[2])[2].ref)[0]) && ("$sp$Types$Meta$USR" === (((($$try0)[2])[2].ref)[1])[0]))))) {
        const $rightArg = ($$try0)[3];
        const $name = (((($$try0)[2])[2].ref)[1])[2];
        const $attrPath = (($$try0)[2])[2].attrPath;
        const $$try1 = (($corelib$Dict$get)($name))($sp$Compiler$CanonicalToJs$nativeBinops);
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return $corelib$Maybe$Nothing;
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $mutates = ($$try1)[1].mutates;
          const $jsSymb = ($$try1)[1].jsSymb;
          const $fnName = ($$try1)[1].fnName;
          const $cons = ($mutates
            ? (($sp$Types$JavascriptAst$Mutop)($jsSymb))($sp$Compiler$CanonicalToJs$none)
            : ($sp$Types$JavascriptAst$Binop)($jsSymb));
          const $z = (($cons)(((($sp$Compiler$CanonicalToJs$translateArg)(({
            nativeBinop: true,
          })))($env))($argument)))(((($sp$Compiler$CanonicalToJs$translateArg)(({
            nativeBinop: true,
          })))($env))($rightArg));
          return ($corelib$Maybe$Just)($z);
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 803:12', (sp_toHuman)($$try1));
        return null;
      }
      if (true) {
        return $corelib$Maybe$Nothing;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 800:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$CanonicalToJs$nativeBinopToFunction = (($spName) => {
  return (($stuff) => {
    return (($acc) => {
      const fnName$$ = $stuff;
      const $mutates = fnName$$.mutates;
      const $jsSymb = fnName$$.jsSymb;
      const $fnName = fnName$$.fnName;
      const $d = $sp$Types$Pos$N;
      const $usr = ($sp$Compiler$CoreTypes$makeUsr)($spName);
      const $call1 = ((($sp$Types$CanonicalAst$Call)($d))((($sp$Types$CanonicalAst$Variable)($d))(({
        attrPath: $core$SPCore$Nil,
        ref: ($sp$Types$CanonicalAst$RefRoot)($usr),
      }))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($d))(({
        attrPath: $core$SPCore$Nil,
        ref: ($sp$Types$CanonicalAst$RefBlock)("a"),
      }))));
      const $call1arg = ($mutates
        ? (($sp$Types$CanonicalAst$ArgumentMutable)($d))(({
          attrPath: $core$SPCore$Nil,
          ref: ($sp$Types$CanonicalAst$RefBlock)("b"),
        }))
        : ($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($d))(({
          attrPath: $core$SPCore$Nil,
          ref: ($sp$Types$CanonicalAst$RefBlock)("b"),
        }))));
      const $a = (($sp$Types$JavascriptAst$Define)($fnName))((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)(({
        errorEnv: ({
          moduleByName: $corelib$Dict$empty,
        }),
        mutables: $corelib$Set$empty,
        tryCounter: 0,
      })))(((($sp$Types$CanonicalAst$Lambda)($d))(($sp$Types$CanonicalAst$ParameterPattern)(((($sp$Types$CanonicalAst$PatternAny)($d))(($corelib$Maybe$Just)("a")))($corelib$Maybe$Nothing))))(((($sp$Types$CanonicalAst$Lambda)($d))(($sp$Types$CanonicalAst$ParameterPattern)(((($sp$Types$CanonicalAst$PatternAny)($d))(($corelib$Maybe$Just)("b")))($corelib$Maybe$Nothing))))(((($sp$Types$CanonicalAst$Call)($d))($call1))($call1arg)))));
      return ((sp_cons)($acc))($a);
    });
  });
});

const $sp$Compiler$CanonicalToJs$nativeBinopsAsFns = ((($corelib$Dict$for)($sp$Compiler$CanonicalToJs$nativeBinops))($sp$Compiler$CanonicalToJs$nativeBinopToFunction))($core$SPCore$Nil);

const $sp$Compiler$CanonicalToJs$nativeDefinitions = ("#!/usr/bin/env node\n\n//Error.stackTraceLimit = 100;\n\n\nconst { performance } = require('perf_hooks');\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n/*  HACK\n\n    TODO this is super brittle\n    once we have a proper Platform system in place, the platform can probably\n    use its internal Meta to figure out the proper constructor\n\n*/\nconst maybe_nothing = [ \"$corelib$Maybe$Nothing\" ];\nconst maybe_just = (a) => [ \"$corelib$Maybe$Just\", a ];\n\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a) => (b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i])(b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k])(b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a) => (b) => {\n  return !sp_equal(a)(b);\n}\n\n\nconst sp_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = sp_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = sp_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (right) => (left) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\nconst basics_modBy = (a) => (b) => b % a;\n\nconst basics_compare = (a) => (b) => sp_compare(a, b);\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message) => (thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\nprocess.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.info(\"\");\n        console.info(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.info(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst sp_toHuman = (a) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a) || sp_toHumanAsUnion(a);\n\n  if (typeof a === 'function') {\n    return '<function>';\n  }\n\n  if (typeof a === 'object') {\n    let x = [];\n    for (let i in a) x.push(i + ' = ' + sp_toHuman(a[i]));\n    return '{' + x.join(', ') + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a) => {\n  return a[0] + ' ' + a.slice(1).map(arg => '(' + sp_toHuman(arg) + ')').join(' ');\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list) => {\n  if (list[0] === '" + ($sp$Compiler$CanonicalToJs$listCons + ("') {\n    arrayAccum.push(sp_toHuman(list[1]));\n    return sp_toHumanAsList(arrayAccum, list[2]);\n  }\n\n  if (list[0] === '" + ($sp$Compiler$CanonicalToJs$listNil + ("')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ? maybe_nothing : maybe_just(n);\n}\n\nconst text_split = (separator) => (target) => array_toList(target.split(separator));\n\nconst text_length = (s) => s.length;\n\nconst text_slice = (start) => (end) => (s) => s.slice(start, end);\n\nconst text_startsWith = (sub) => (s) => s.startsWith(sub);\n\nconst text_startsWithRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp('^' + regex);\n  } catch (e) {\n    return () => \"\"\n  }\n\n  return (s) => {\n    let m = s.match(re);\n    return m ? m[0] : \"\";\n  }\n}\n\nconst text_replaceRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp(regex, 'g');\n  } catch (e) {\n    return () => () => \"\"\n  }\n\n  return (replacer) => (s) => s.replace(re, replacer);\n}\n\nconst text_trimLeft = (s) => {\n  return s.trimLeft();\n}\n\nconst text_dropLeft = (n) => (s) => {\n  return s.slice(n);\n}\n\nconst text_forEach = (s) => (f) => {\n  for (let i of s) f(i);\n  return null;\n}\n\n\n//\n// Hashes\n//\n\nconst hash_empty = {};\n\n\nconst hash_insert = (hash) => (key) => (value) => {\n    const h = hash.obj[hash.attr];\n    h[JSON.stringify(key)] = [key, value];\n    return null;\n}\n\n\nconst hash_remove = (hash) => (key) => {\n    const h = hash.obj[hash.attr];\n    delete h[JSON.stringify(key)];\n    return null;\n}\n\n\nconst hash_get = (hash) => (key) => {\n    const r = hash[JSON.stringify(key)];\n    return r === undefined ? maybe_nothing : maybe_just(r[1]);\n}\n\n\nconst hash_for = (hash) => (f) => (acc) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        acc = f(kv[0])(kv[1])(acc);\n    }\n    return acc;\n}\n\n\nconst hash_each = (hash) => (f) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        f(kv[0])(kv[1]);\n    }\n    return null;\n}\n\n\n//\n// Arrays\n//\n\nconst array_push = (array) => (item) => {\n    array.obj[array.attr].push(item);\n    return null;\n}\n\nconst array_pop = (array) => {\n    const a = array.obj[array.attr];\n    return a.length ? maybe_just(a.pop()) : maybe_nothing;\n}\n\nconst array_get = (array) => (index) => {\n    const r = array[index];\n    return r === undefined ? maybe_nothing : maybe_just(r);\n}\n\nconst array_set = (array) => (index) => (item) => {\n    if (index < 0) return false;\n    const a = array.obj[array.attr];\n    if (index >= a.length) return false;\n    a[index] = item;\n    return true;\n}\n\nconst array_sortBy = (array) => (f) => {\n    const arr = array.obj[array.attr];\n    arr.sort((a, b) => sp_compare(f(a), f(b)));\n    return null;\n}\n\nconst array_toList = (array) => {\n  let length = array.length;\n  let list = [ '" + ($sp$Compiler$CanonicalToJs$listNil + ("' ];\n  for (let i = length - 1; i >= 0; i--) {\n      list = [ '" + ($sp$Compiler$CanonicalToJs$listCons + ("', array[i], list ];\n  }\n  return list;\n}\n\nconst array_fromList = (list) => {\n  const array = [];\n  const rec = (ls) => {\n    if (ls[0] === '" + ($sp$Compiler$CanonicalToJs$listNil + ("')\n      return array;\n\n    array.push(ls[1]);\n    return rec(ls[2]);\n  };\n\n  return rec(list);\n}\n\n\n\n//\n// Lists\n//\n\n\nconst sp_cons = (list) => (item) => {\n  return [ '" + ($sp$Compiler$CanonicalToJs$listCons + "', item, list];\n}\n\nconst list_sortBy = (f) => (list) => array_toList(array_fromList(list).sort((a, b) => sp_compare(f(a), f(b))));\n\n\n//\n// Platform: IO\n//\nconst fs = require('fs');\n\nconst io_wrap = (f) => [ \"IO.IO\", f ];\n\nconst io_parallel = (iosAsList) => io_wrap((never) => {\n    // as [IO a]: IO [a]\n\n    const ios = array_fromList(iosAsList);\n\n    // TODO actually run them in parallel!\n\n    let arr = [];\n    for (let io of ios) {\n        const r = io[1](never);\n        if (r[0] === \"$corelib$Result$Ok\")\n            arr.push(r[1]);\n        else\n            return $corelib$Result$Err(r[1]);\n    }\n\n    return $corelib$Result$Ok(array_toList(arr));\n});\n\n\nconst io_readDir = (dirPath) => io_wrap((never) => {\n    // as Text: IO [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(array_toList(entries.map((dirent) => ({\n        first: dirent.isDirectory(),\n        second: dirent.name,\n    }))));\n});\n\n\nconst io_readFile = (path) => io_wrap((never) => {\n    // as Text: IO Text\n\n    var content;\n    try {\n        content = fs.readFileSync(path, 'utf8');\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(content);\n});\n\n\nconst io_writeFile = (path) => (content) => io_wrap((never) => {\n    // as Text: Text: IO None\n\n    try {\n        fs.writeFileSync(path, content);\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(null);\n});\n\n\nconst io_writeStdout = (content) => io_wrap((never) => {\n    // as Text: IO None\n\n    console.info(content);\n    return $corelib$Result$Ok(null);\n});\n\n    "))))))))))));

const $sp$Compiler$CanonicalToJs$not_ = (($bool) => {
  return ($bool
    ? false
    : true);
});

const $sp$RefHierarchy$resolve = (($getEdges) => {
  return (($target) => {
    return (($path) => {
      return (($state0) => {
        return ((($corelib$List$member)($target))($state0.resolved)
          ? $state0
          : ((($corelib$List$member)($target))($path)
            ? ((() => {
              const $circ = ((sp_cons)((($corelib$List$takeWhile)((($key) => {
                return ((sp_not_equal)($target))($key);
              })))($path)))($target);
              return (Object.assign)({}, $state0, ({
                circular: ((($corelib$Dict$insert)(($corelib$Set$fromList)($circ)))($circ))($state0.circular),
              }));
            }))()
            : ((() => {
              const $s = ((($corelib$Dict$for)(($getEdges)($target)))((($a) => {
                return (() => {
                  return ((($sp$RefHierarchy$resolve)($getEdges))($a))(((sp_cons)($path))($target));
                });
              })))($state0);
              return (Object.assign)({}, $s, ({
                resolved: ((sp_cons)($s.resolved))($target),
              }));
            }))()));
      });
    });
  });
});

const $sp$RefHierarchy$reorder = (($nodeToEdges) => {
  return (($nodesById) => {
    const $keyToEdges = (($id) => {
      const $$try0 = (($corelib$Dict$get)($id))($nodesById);
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return $corelib$Set$empty;
      }
      if (("$corelib$Maybe$Just" === ($$try0)[0])) {
        const $node = ($$try0)[1];
        return ($nodeToEdges)($node);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/RefHierarchy.sp 44:8', (sp_toHuman)($$try0));
    });
    const $state0 = ({
      circular: $corelib$Dict$empty,
      resolved: $core$SPCore$Nil,
    });
    const $stateF = ((($corelib$Dict$for)($nodesById))((($k) => {
      return (($v) => {
        return ((($sp$RefHierarchy$resolve)($keyToEdges))($k))($core$SPCore$Nil);
      });
    })))($state0);
    return ({
      first: ($corelib$Dict$values)($stateF.circular),
      second: ($corelib$List$reverse)($stateF.resolved),
    });
  });
});

const $sp$Compiler$CanonicalToJs$reorderModuleValues = (($modules) => {
  (sp_benchStart)(null);
  const $nodesByUsr = ((($corelib$List$for)($modules))((($module) => {
    return (($corelib$Dict$for)($module.valueDefs))((() => {
      return (($def) => {
        return (($accum) => {
          const $$try0 = $def.pattern;
          if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[2])[0]))) {
            const $name = (($$try0)[2])[1];
            const $usr = (($sp$Compiler$CanonicalToJs$makeUsr)($module))($name);
            return ((($corelib$Dict$member)($usr))($sp$Compiler$CanonicalToJs$allNatives)
              ? $accum
              : ((($corelib$Dict$insert)($usr))((($sp$Compiler$CanonicalToJs$NodeDef)($usr))($def)))($accum));
            return null;
          }
          if (true) {
            const $$try1 = ($sp$Compiler$CanonicalToJs$pickMainName)($def.pattern);
            if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
              return $accum;
            }
            if (("$corelib$Maybe$Just" === ($$try1)[0])) {
              const $mainName = ($$try1)[1];
              const $mainUsr = (($sp$Compiler$CanonicalToJs$makeUsr)($module))($mainName);
              const $jsStatementsByUsr = ((((($sp$Compiler$CanonicalToJs$assignPattern)((($n) => {
                return ($sp$Types$CanonicalAst$RefRoot)((($sp$Compiler$CanonicalToJs$makeUsr)($module))($n));
              })))((($n) => {
                return (($stat) => {
                  return (($corelib$Dict$insert)((($sp$Compiler$CanonicalToJs$makeUsr)($module))($n)))($stat);
                });
              })))($def.pattern))(($sp$Types$JavascriptAst$Var)($mainName)))($corelib$Dict$empty);
              return ((($corelib$Dict$for)($jsStatementsByUsr))((($usr) => {
                return (($stat) => {
                  return (($a) => {
                    return ((($corelib$Dict$insert)($usr))((($sp$Compiler$CanonicalToJs$NodeName)($mainUsr))($stat)))($a);
                  });
                });
              })))(((($corelib$Dict$insert)($mainUsr))((($sp$Compiler$CanonicalToJs$NodeDef)($mainUsr))($def)))($accum));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 372:28', (sp_toHuman)($$try1));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 363:20', (sp_toHuman)($$try0));
        });
      });
    }));
  })))($corelib$Dict$empty);
  const $nodeToDeps = (($node) => {
    const $$try0 = $node;
    if (("$sp$Compiler$CanonicalToJs$NodeName" === ($$try0)[0])) {
      const $d_usr = ($$try0)[1];
      return ($corelib$Set$singleton)($d_usr);
    }
    if (("$sp$Compiler$CanonicalToJs$NodeDef" === ($$try0)[0])) {
      const $def = ($$try0)[2];
      const $usr = ($$try0)[1];
      return $def.directValueDeps;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 395:8', (sp_toHuman)($$try0));
  });
  const circulars$$ = (($sp$RefHierarchy$reorder)($nodeToDeps))($nodesByUsr);
  const $reorderedNodes = circulars$$.second;
  const $circulars = circulars$$.first;
  (sp_benchStop)("reorderModuleValues");
  const $errors = (($corelib$List$filter)(($sp$Compiler$CanonicalToJs$circularIsError)($nodesByUsr)))($circulars);
  return (((sp_not_equal)($core$SPCore$Nil))($errors)
    ? ($corelib$Result$Err)($errors)
    : ($corelib$Result$Ok)((($corelib$List$filterMap)((($usr) => {
      return (($corelib$Dict$get)($usr))($nodesByUsr);
    })))($reorderedNodes)));
});

const $sp$Compiler$CanonicalToJs$translateNode = (($env) => {
  return (($node) => {
    const $$try0 = $node;
    if (("$sp$Compiler$CanonicalToJs$NodeName" === ($$try0)[0])) {
      const $jaStatement = ($$try0)[2];
      const $usr = ($$try0)[1];
      return $jaStatement;
    }
    if (("$sp$Compiler$CanonicalToJs$NodeDef" === ($$try0)[0])) {
      const $valueDef = ($$try0)[2];
      const $usr = ($$try0)[1];
      return (($sp$Types$JavascriptAst$Define)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)))((($sp$Compiler$CanonicalToJs$translateExpressionToExpression)($env))($valueDef.body));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 478:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$CanonicalToJs$translateUnionConstructor = (($usr) => {
  return (($cons) => {
    const $n = ($corelib$List$length)($cons.args);
    const $range = (($corelib$List$range)(1))($n);
    const $storedArgs = (($corelib$List$map)((($x) => {
      return ($sp$Types$JavascriptAst$Var)(($sp$Compiler$CanonicalToJs$constructorArgumentName)($x));
    })))($range);
    const $name = ($sp$Compiler$CanonicalToJs$quoteAndEscape)(($sp$Compiler$CanonicalToJs$translateUsr)($usr));
    const $expr = ($sp$Types$JavascriptAst$Array)(((sp_cons)($storedArgs))(($sp$Types$JavascriptAst$Literal)($name)));
    const $lambdas = ((($corelib$List$forReversed)($range))((($i) => {
      return ($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)(($sp$Compiler$CanonicalToJs$constructorArgumentName)($i)))($core$SPCore$Nil));
    })))($expr);
    return (($sp$Types$JavascriptAst$Define)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)))($lambdas);
  });
});

const $sp$Compiler$CanonicalToJs$translateAll = (($eenv) => {
  return (($globals) => {
    return (($modules) => {
      const $$try0 = ($sp$Compiler$CanonicalToJs$reorderModuleValues)($modules);
      if (("$corelib$Result$Err" === ($$try0)[0])) {
        const $circular = ($$try0)[1];
        ((sp_log)("translateAll: circular"))("");
        (($corelib$List$each)($circular))((($usr) => {
          return ((sp_log)("^"))($usr);
        }));
        return (sp_todo)("translateAll circular");
        return null;
      }
      if (("$corelib$Result$Ok" === ($$try0)[0])) {
        const $nodes = ($$try0)[1];
        const $env = ({
          errorEnv: $eenv,
          mutables: $corelib$Set$empty,
          tryCounter: 0,
        });
        const $values = (($corelib$List$map)(($sp$Compiler$CanonicalToJs$translateNode)($env)))($nodes);
        const $constructors = ((($corelib$Dict$for)($globals.constructors))((($usr) => {
          return (($cons) => {
            return (($acc) => {
              return ((($corelib$Dict$member)($usr))($sp$Compiler$CanonicalToJs$allNatives)
                ? $acc
                : ((sp_cons)($acc))((($sp$Compiler$CanonicalToJs$translateUnionConstructor)($usr))($cons)));
            });
          });
        })))($core$SPCore$Nil);
        return ($corelib$List$concat)((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs$nativeBinopsAsFns))((($core$SPCore$Cons)($constructors))((($core$SPCore$Cons)($values))($core$SPCore$Nil))));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 445:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Test$codeTest = (($toText) => {
  return (($title) => {
    return (($code) => {
      return (($functionToTest) => {
        return (($ce) => {
          const toMaybeError$$ = $ce;
          const $toMaybeError = (toMaybeError$$)[1];
          return ((($sp$Test$Single)($title))($code))((() => {
            return ($sp$Test$maybeToOutcome)((($toMaybeError)($toText))(($functionToTest)($code)));
          }));
        });
      });
    });
  });
});

const $sp$Compiler$CanonicalToJs_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$CanonicalToJs_Test$eval = (($value) => {
  return (($code) => {
    return ($corelib$Result$Ok)("CanonicalToJS.eval not implemented");
  });
});

const $sp$Compiler$CanonicalToJs_Test$ifs = (($sp$Test$Group)("ifs"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("a =\n  if True:\n    1\n  else\n    2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("1"))))($core$SPCore$Nil));

const $sp$Compiler$CanonicalToJs_Test$misc = (($sp$Test$Group)("misc"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("definitions and mutations return None"))("x =\n  m @= 0\n\ny =\n  m @= 0\n  @m += 1\n\na =\n  { x, y }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("{\"x\":null,\"y\":null}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("Cons"))("a = 1 :: []"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("[\"SPCore.Cons\",1,[\"SPCore.Nil\"]]"))))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs_Test$mutation = (($sp$Test$Group)("mutation"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("a =\n  m @= 0\n  @m += 1\n  x = m\n  @m := 10\n  y = m\n  @m += 1\n  z = m\n  { x, y, z, m }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("{\"m\":11,\"x\":1,\"y\":10,\"z\":11}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("nested record"))("record = { x = { y = { z = 4 } } }\n\nresult =\n   m @= record\n   @m.x.y :=  { z = 1 }\n   @m.x.y.z += 1\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"x\":{\"y\":{\"z\":2}}}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("pass mutable to function"))("fun @m =\n  @m += 55\n\nresult =\n   m @= 2\n   fun @m\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("57"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("pass nested mutable value to function"))("fun @m =\n  @m += 55\n\nrecord = { x = { y = { z = 4 } } }\n\nresult =\n   m @= record\n   fun @m.x.y.z\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"x\":{\"y\":{\"z\":59}}}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("[reg] mut args should be dereferenced and cloned"))("result =\n    l @= 3\n    f @l\n\nf @a =\n    as Number @: Number\n    a"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("3"))))($core$SPCore$Nil))))));

const $sp$Test$errorContains = (($snippets) => {
  return ($sp$Test$CodeExpectation)((($toText) => {
    return (($result) => {
      const $$try0 = $result;
      if (("$corelib$Result$Ok" === ($$try0)[0])) {
        const $ok = ($$try0)[1];
        return ($corelib$Maybe$Just)(("I was expecting an error, but got: Ok " + ($toText)($ok)));
      }
      if (("$corelib$Result$Err" === ($$try0)[0])) {
        const $e = ($$try0)[1];
        const $missing = (($corelib$List$filter)((($sn) => {
          return ($corelib$Basics$not)((($corelib$Text$contains)($sn))($e));
        })))($snippets);
        return (((sp_equal)($core$SPCore$Nil))($missing)
          ? $corelib$Maybe$Nothing
          : ((() => {
            const $indentedError = (($corelib$Text$join)("\n"))((($corelib$List$map)((($l) => {
              return ("    " + $l);
            })))(((text_split)("\n"))($e)));
            return ($corelib$Maybe$Just)(("Error message:\n\n" + ($indentedError + ("\n\nis missing snippets: " + (($corelib$Text$join)(", "))($missing)))));
          }))());
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 102:6', (sp_toHuman)($$try0));
    });
  }));
});

const $sp$Compiler$CanonicalToJs_Test$natives = (($sp$Test$Group)("natives"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.log"))("result = log \"this is produced by a test\" True"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("true"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.log, partially applied"))("result = log \"if this gets actually logged, we have a problem\""))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("undefined"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.todo"))("a = todo \"blah\"\nresult = 1"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("Text concat (..)"))("result = \"a\" .. \"b\" .. \"c\""))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("\"abc\""))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("add"))("result = 1 + 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("3"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("subtract"))("result = 5 - 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("2"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("multiply"))("result = 3 * 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("6"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("divide"))("result = 3 / 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("1.5"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("divide by zero"))("result = 3 / 0"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("0"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("lesser than (<)"))("result = 3 < 2 & 2 < 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"first\":false,\"second\":true}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("greater than (>)"))("result = 3 > 2 & 2 > 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"first\":true,\"second\":false}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("partial application"))("result = (-) 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("undefined"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("mutable partial application"))("f = (+=) 3\n\nresult =\n   m @= 1\n   f @m\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("4"))))($core$SPCore$Nil))))))))))))));

const $sp$Compiler$CanonicalToJs_Test$try_ = (($sp$Test$Group)("try"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("union A = A Number, B, C Bool\n\na x =\n  try x as\n    A 1: 11\n    A n: n\n    B: 3\n    C False: 5\n    C _: 6\n\nresult =\n { x = a (A 2)\n , y = a (A 1)\n , z = a B\n , w = a (C False)\n , k = a (C True)\n }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"k\":6,\"w\":6,\"x\":2,\"y\":11,\"z\":3}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("[reg]: pattern any"))("result =\n   try 2 as\n     x: x"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("2"))))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs_Test$tests = (($sp$Test$Group)("CanonicalToJS"))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$misc))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$mutation))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$ifs))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$try_))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$natives))($core$SPCore$Nil))))));

const $sp$Compiler$CoreTypes$bool = (($sp$Compiler$CoreTypes$nameToType)("Bool"))($core$SPCore$Nil);

const $sp$Compiler$CoreTypes$boolDef = ((() => {
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)("Bool");
  return ({
    args: $core$SPCore$Nil,
    constructors: ((($corelib$Dict$insert)("False"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: $sp$Compiler$CoreTypes$bool,
      typeUsr: $usr,
    })))(((($corelib$Dict$insert)("True"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: $sp$Compiler$CoreTypes$bool,
      typeUsr: $usr,
    })))($corelib$Dict$empty)),
    directTypeDeps: $corelib$Set$empty,
    usr: $usr,
  });
}))();

const $sp$Compiler$CoreTypes$list = (($item) => {
  return (($sp$Compiler$CoreTypes$nameToType)("List"))((($core$SPCore$Cons)($item))($core$SPCore$Nil));
});

const $sp$Compiler$CoreTypes$listDef = ((() => {
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)("List");
  const $item = (($sp$Types$CanonicalAst$TypeVariable)($sp$Compiler$CoreTypes$p))("item");
  const $consDef = ({
    args: (($core$SPCore$Cons)($item))((($core$SPCore$Cons)(($sp$Compiler$CoreTypes$list)($item)))($core$SPCore$Nil)),
    pos: $sp$Compiler$CoreTypes$p,
    type: ((($corelib$List$forReversed)((($core$SPCore$Cons)($item))((($core$SPCore$Cons)(($sp$Compiler$CoreTypes$list)($item)))($core$SPCore$Nil))))((($ar) => {
      return (($ty) => {
        return (((($sp$Types$CanonicalAst$TypeFunction)($sp$Compiler$CoreTypes$p))($ar))(false))($ty);
      });
    })))(($sp$Compiler$CoreTypes$list)($item)),
    typeUsr: $usr,
  });
  return ({
    args: (($core$SPCore$Cons)("item"))($core$SPCore$Nil),
    constructors: ((($corelib$Dict$insert)("Cons"))($consDef))(((($corelib$Dict$insert)("Nil"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: ($sp$Compiler$CoreTypes$list)($item),
      typeUsr: $usr,
    })))($corelib$Dict$empty)),
    directTypeDeps: $corelib$Set$empty,
    usr: $usr,
  });
}))();

const $sp$Compiler$CoreTypes$noneDef = ((() => {
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)($sp$Compiler$CoreTypes$noneName);
  return ({
    args: $core$SPCore$Nil,
    constructors: (($corelib$Dict$singleton)($sp$Compiler$CoreTypes$noneName))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: $sp$Compiler$CoreTypes$none,
      typeUsr: $usr,
    })),
    directTypeDeps: $corelib$Set$empty,
    usr: $usr,
  });
}))();

const $sp$Compiler$CoreTypes$allDefs = (($core$SPCore$Cons)($sp$Compiler$CoreTypes$noneDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$boolDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$listDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$textDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$numberDef))($core$SPCore$Nil)))));

const $sp$Compiler$CoreTypes$usrToVariable = (($u) => {
  return (($sp$Types$CanonicalAst$Variable)($sp$Compiler$CoreTypes$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Types$CanonicalAst$RefRoot)($u),
  }));
});

const $sp$Compiler$Error$breakDownText = (($text) => {
  const $formatSnippet = (($index) => {
    return (($snippet) => {
      return (((sp_equal)(0))(((basics_modBy)(2))($index))
        ? ($sp$Compiler$Error$FormattedText_Default)($snippet)
        : ((() => {
          const $$try0 = ((text_split)($sp$Compiler$Error$formatSuffix))($snippet);
          if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("emphasys" === ($$try0)[1]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[2])[2])[0]))))) {
            const $s = (($$try0)[2])[1];
            return ($sp$Compiler$Error$FormattedText_Emphasys)($s);
          }
          if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("warning" === ($$try0)[1]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[2])[2])[0]))))) {
            const $s = (($$try0)[2])[1];
            return ($sp$Compiler$Error$FormattedText_Warning)($s);
          }
          if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("decoration" === ($$try0)[1]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[2])[2])[0]))))) {
            const $s = (($$try0)[2])[1];
            return ($sp$Compiler$Error$FormattedText_Decoration)($s);
          }
          if (true) {
            return ($sp$Compiler$Error$FormattedText_Default)($snippet);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 69:10', (sp_toHuman)($$try0));
        }))());
    });
  });
  return (($corelib$List$indexedMap)($formatSnippet))(((text_split)($sp$Compiler$Error$formatSeparator))($text));
});

const $sp$Compiler$Error$deco = ($sp$Compiler$Error$formatWrap)("decoration");

const $sp$Compiler$Error$emph = ($sp$Compiler$Error$formatWrap)("emphasys");

const $sp$Compiler$Error$flatten = (($e) => {
  return (($accum) => {
    const $$try0 = $e;
    if (("$sp$Compiler$Error$Simple" === ($$try0)[0])) {
      const $descr = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((sp_cons)($accum))(({
        first: $pos,
        second: $descr,
      }));
    }
    if (("$sp$Compiler$Error$Nested" === ($$try0)[0])) {
      const $ls = ($$try0)[1];
      return ((($corelib$List$for)($ls))($sp$Compiler$Error$flatten))($accum);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 104:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$Error$res = (($pos) => {
  return (($desc) => {
    return ($corelib$Result$Err)((($sp$Compiler$Error$Simple)($pos))($desc));
  });
});

const $sp$Compiler$Error$toText = (($env) => {
  return (($pos) => {
    return (($desc) => {
      const block$$ = (($sp$Compiler$Error$posToHuman)($env))($pos);
      const $location = block$$.location;
      const $block = block$$.block;
      const $description = (($corelib$Text$join)("\n"))((($corelib$List$map)((($s) => {
        return ("  " + $s);
      })))((($corelib$List$concatMap)((text_split)("\n")))(((($d) => {
        return ((sp_cons)($d))($block);
      }))(($desc)($env)))));
      return ($sp$Compiler$Error$breakDownText)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(($sp$Compiler$Error$deco)(((($corelib$Text$padRight)(50))("-"))(($location + " ")))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($description))((($core$SPCore$Cons)(""))($core$SPCore$Nil))))))));
    });
  });
});

const $sp$Compiler$Error$toFormattedText = (($eenv) => {
  return (($e) => {
    const $newline = ($sp$Compiler$Error$FormattedText_Default)("");
    const $tupleToFormattedText = (($x) => {
      const descr$$ = $x;
      const $descr = descr$$.second;
      const $pos = descr$$.first;
      return ((($sp$Compiler$Error$toText)($eenv))($pos))($descr);
    });
    return (($corelib$List$concatMap)($tupleToFormattedText))((($sp$Compiler$Error$flatten)($e))($core$SPCore$Nil));
  });
});

const $sp$Compiler$ExpandTypes$error = (($pos) => {
  return (($description) => {
    return (($sp$Compiler$Error$res)($pos))((() => {
      return $description;
    }));
  });
});

const $sp$Compiler$ExpandTypes$expandAliasVariables = (($typeByArgName) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $$try1 = (($corelib$Dict$get)($name))($typeByArgName);
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return $ty;
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $t = ($$try1)[1];
        return $t;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 185:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $fromIsMutable = ($$try0)[3];
      const $from = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($from)))($fromIsMutable))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($to));
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $extensible = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible))((($corelib$Dict$map)((($k) => {
        return ($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName);
      })))($attrs));
    }
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      const $args = ($$try0)[3];
      const $usr = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))((($corelib$List$map)(($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName)))($args));
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      const $t = ($$try0)[3];
      const $usr = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($sp$Types$CanonicalAst$TypeAlias)($pos))($usr))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($t));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 183:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$ExpandTypes$expandInType = (($ga) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($corelib$Result$Ok)($ty);
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $fromIsMutable = ($$try0)[3];
      const $from = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Result$onOk)((($f) => {
        return (($corelib$Result$onOk)((($t) => {
          return ($corelib$Result$Ok)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($f))($fromIsMutable))($t));
        })))((($sp$Compiler$ExpandTypes$expandInType)($ga))($to));
      })))((($sp$Compiler$ExpandTypes$expandInType)($ga))($from));
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $extensible = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Result$map)((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible)))((($corelib$Dict$mapRes)((($k) => {
        return ($sp$Compiler$ExpandTypes$expandInType)($ga);
      })))($attrs));
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      const $t = ($$try0)[3];
      const $path = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)("Did we apply aliases twice?"))($core$SPCore$Nil));
    }
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      const $args = ($$try0)[3];
      const $usr = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Result$onOk)((($replacedArgs) => {
        const $$try1 = (($ga)($pos))($usr);
        if (("$corelib$Result$Err" === ($$try1)[0])) {
          const $e = ($$try1)[1];
          return ($corelib$Result$Err)($e);
        }
        if ((("$corelib$Result$Ok" === ($$try1)[0]) && ("$sp$Types$CanonicalAst$TypeDefUnion" === (($$try1)[1])[0]))) {
          const $un = (($$try1)[1])[1];
          return (((sp_not_equal)(($corelib$List$length)($un.args)))(($corelib$List$length)($replacedArgs))
            ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("union " + ((sp_toHuman)($un.usr) + (" needs " + ((text_fromNumber)(($corelib$List$length)($un.args)) + " args,"))))))((($core$SPCore$Cons)(("but was used with " + (text_fromNumber)(($corelib$List$length)($replacedArgs)))))($core$SPCore$Nil)))
            : ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))($replacedArgs)));
        }
        if ((("$corelib$Result$Ok" === ($$try1)[0]) && ("$sp$Types$CanonicalAst$TypeDefAlias" === (($$try1)[1])[0]))) {
          const $al = (($$try1)[1])[1];
          return (((sp_not_equal)(($corelib$List$length)($replacedArgs)))(($corelib$List$length)($al.args))
            ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("alias " + ((sp_toHuman)($al.usr) + (" needs " + ((text_fromNumber)(($corelib$List$length)($al.args)) + (" args, but was used with " + (text_fromNumber)(($corelib$List$length)($replacedArgs)))))))))($core$SPCore$Nil))
            : ((() => {
              const $typeByArgName = ($corelib$Dict$fromList)(((($corelib$List$map2)(((name$$) => {
                const $name = (name$$)[2];
                return (($r) => {
                  return ({
                    first: $name,
                    second: $r,
                  });
                });
              })))($al.args))($replacedArgs));
              return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeAlias)($pos))($usr))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($al.type)));
            }))());
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 39:12', (sp_toHuman)($$try1));
      })))((($corelib$List$mapRes)(($sp$Compiler$ExpandTypes$expandInType)($ga)))($args));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 19:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions = (($nonFunctionPos) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      return $core$SPCore$Nil;
    }
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      return $core$SPCore$Nil;
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      const $t = ($$try0)[3];
      const $path = ($$try0)[2];
      return (($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos))($t);
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $fromIsMutable = ($$try0)[3];
      const $from = ($$try0)[2];
      const $functionPos = ($$try0)[1];
      return ($corelib$List$concat)((($core$SPCore$Cons)(((() => {
        const $$try1 = $nonFunctionPos;
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $constraintPos = ($$try1)[1];
          return (($core$SPCore$Cons)(({
            first: $constraintPos,
            second: $functionPos,
          })))($core$SPCore$Nil);
        }
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return $core$SPCore$Nil;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 104:14', (sp_toHuman)($$try1));
      }))()))((($core$SPCore$Cons)((($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)(($fromIsMutable
        ? ($corelib$Maybe$Just)($functionPos)
        : $corelib$Maybe$Nothing)))($from)))((($core$SPCore$Cons)((($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos))($to)))($core$SPCore$Nil))));
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $ext = ($$try0)[2];
      return (($corelib$List$concatMap)(($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos)))(($corelib$Dict$values)($attrs));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 85:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$ExpandTypes$expandAndValidateType = (($ga) => {
  return (($rawTy) => {
    return (($corelib$Result$onOk)((($expandedTy) => {
      const $$try0 = (($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($corelib$Maybe$Nothing))($expandedTy);
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ($corelib$Result$Ok)($expandedTy);
      }
      if (true) {
        const $errors = $$try0;
        return (($sp$Compiler$ExpandTypes$error)(($sp$Types$Pos$I)(567)))((($core$SPCore$Cons)("Mutable arguments can't be or contain functions!"))((($core$SPCore$Cons)((($corelib$Text$join)("\n"))((($corelib$List$map)(sp_toHuman))($errors))))($core$SPCore$Nil)));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 71:4', (sp_toHuman)($$try0));
    })))((($sp$Compiler$ExpandTypes$expandInType)($ga))($rawTy));
  });
});

const $sp$Compiler$ExpandTypes$expandAndInsertAlias = (($allTypes) => {
  return (($al) => {
    return (($expandedTypes) => {
      const $getAlias = (($pos) => {
        return (($usr) => {
          const $$try0 = (($corelib$Dict$get)($usr))($expandedTypes);
          if (("$corelib$Maybe$Just" === ($$try0)[0])) {
            const $type = ($$try0)[1];
            return ($corelib$Result$Ok)($type);
          }
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            const $$try1 = (($corelib$Dict$get)($usr))($allTypes);
            if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
              return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil));
            }
            if ((("$corelib$Maybe$Just" === ($$try1)[0]) && ("$sp$Types$CanonicalAst$TypeDefAlias" === (($$try1)[1])[0]))) {
              const $a = (($$try1)[1])[1];
              return (sp_todo)(("expandAndInsertAlias should-not-happen: " + (sp_toHuman)($usr)));
            }
            if ((("$corelib$Maybe$Just" === ($$try1)[0]) && ("$sp$Types$CanonicalAst$TypeDefUnion" === (($$try1)[1])[0]))) {
              const $u = (($$try1)[1])[1];
              return ($corelib$Result$Ok)(($sp$Types$CanonicalAst$TypeDefUnion)($u));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 166:16', (sp_toHuman)($$try1));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 161:8', (sp_toHuman)($$try0));
        });
      });
      return (($corelib$Result$onOk)((($type) => {
        return ($corelib$Result$Ok)(((($corelib$Dict$insert)($al.usr))(($sp$Types$CanonicalAst$TypeDefAlias)((Object.assign)({}, $al, ({
          type: $type,
        })))))($expandedTypes));
      })))((($sp$Compiler$ExpandTypes$expandAndValidateType)($getAlias))($al.type));
    });
  });
});

const $sp$Compiler$ExpandTypes$getTypeForUnion = (($allTypes) => {
  return (($expandedTypes) => {
    return (($pos) => {
      return (($usr) => {
        const $$try0 = (($corelib$Dict$get)($usr))($expandedTypes);
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $t = ($$try0)[1];
          return ($corelib$Result$Ok)($t);
        }
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          const $$try1 = (($corelib$Dict$get)($usr))($allTypes);
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $t = ($$try1)[1];
            return ($corelib$Result$Ok)($t);
          }
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type usr: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 230:12', (sp_toHuman)($$try1));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 223:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$ExpandTypes$expandAndInsertUnion = (($allTypes) => {
  return (($usr) => {
    return (($typeDef) => {
      return (($expandedTypes) => {
        const $$try0 = $typeDef;
        if (("$sp$Types$CanonicalAst$TypeDefAlias" === ($$try0)[0])) {
          return ($corelib$Result$Ok)($expandedTypes);
        }
        if (("$sp$Types$CanonicalAst$TypeDefUnion" === ($$try0)[0])) {
          const $u = ($$try0)[1];
          const $gt = (($sp$Compiler$ExpandTypes$getTypeForUnion)($allTypes))($expandedTypes);
          const $mapConstructor = (($name) => {
            return (($c) => {
              return (($corelib$Result$onOk)((($type) => {
                return (($corelib$Result$onOk)((($args) => {
                  return ($corelib$Result$Ok)((Object.assign)({}, $c, ({
                    args: $args,
                    type: $type,
                  })));
                })))((($corelib$List$mapRes)(($sp$Compiler$ExpandTypes$expandAndValidateType)($gt)))($c.args));
              })))((($sp$Compiler$ExpandTypes$expandAndValidateType)($gt))($c.type));
            });
          });
          return (($corelib$Result$onOk)((($cs) => {
            return ($corelib$Result$Ok)(((($corelib$Dict$insert)($usr))(($sp$Types$CanonicalAst$TypeDefUnion)((Object.assign)({}, $u, ({
              constructors: $cs,
            })))))($expandedTypes));
          })))((($corelib$Dict$mapRes)($mapConstructor))($u.constructors));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 242:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$ExpandTypes$referencedAliases = (($allAliases) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      const $args = ($$try0)[3];
      const $usr = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $init = ((($corelib$Dict$member)($usr))($allAliases)
        ? ($corelib$Set$singleton)($usr)
        : $corelib$Set$empty);
      return ((($corelib$List$for)($args))((($ar) => {
        return ($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($ar));
      })))(($corelib$Set$singleton)($usr));
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      return $corelib$Dict$empty;
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $maybeMut = ($$try0)[3];
      const $from = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($from)))((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($to));
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $extensible = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($corelib$Dict$for)($attrs))((($name) => {
        return (($t) => {
          return ($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($t));
        });
      })))($corelib$Dict$empty);
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      const $t = ($$try0)[3];
      const $path = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($t);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 131:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$ExpandTypes$expandAllTypes = (($allTypes) => {
  const $allAliases = ((() => {
    const $insertAlias = (($usr) => {
      return (($typeDef) => {
        return (($acc) => {
          const $$try0 = $typeDef;
          if (("$sp$Types$CanonicalAst$TypeDefAlias" === ($$try0)[0])) {
            const $a = ($$try0)[1];
            return ((($corelib$Dict$insert)($usr))($a))($acc);
          }
          if (true) {
            return $acc;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 280:12', (sp_toHuman)($$try0));
        });
      });
    });
    return ((($corelib$Dict$for)($allTypes))($insertAlias))($corelib$Dict$empty);
  }))();
  const circulars$$ = (($sp$RefHierarchy$reorder)((($al) => {
    return (($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($al.type);
  })))($allAliases);
  const $orderedAliasRefs = circulars$$.second;
  const $circulars = circulars$$.first;
  return (((sp_not_equal)($core$SPCore$Nil))($circulars)
    ? ((() => {
      const $circularToError = (($circular) => {
        return (($sp$Compiler$Error$Simple)(($sp$Types$Pos$I)(121)))((() => {
          return (($core$SPCore$Cons)("circular alias: "))((($core$SPCore$Cons)((($corelib$Text$join)(" <- "))((($corelib$List$map)(sp_toHuman))($circular))))($core$SPCore$Nil));
        }));
      });
      return ($corelib$Result$Err)(($sp$Compiler$Error$Nested)((($corelib$List$map)($circularToError))($circulars)));
    }))()
    : ((() => {
      const $oa = (($corelib$List$filterMap)((($ref) => {
        return (($corelib$Dict$get)($ref))($allAliases);
      })))($orderedAliasRefs);
      return (($corelib$Result$onOk)((($corelib$Dict$forRes)($allTypes))(($sp$Compiler$ExpandTypes$expandAndInsertUnion)($allTypes))))(((($corelib$List$foldlRes)(($sp$Compiler$ExpandTypes$expandAndInsertAlias)($allTypes)))($oa))($corelib$Dict$empty));
    }))());
});

const $sp$Compiler$ExpandTypes$expandAnnotation = (($allExpandedTypes) => {
  return (($type) => {
    const $gt = (($pos) => {
      return (($usr) => {
        const $$try0 = (($corelib$Dict$get)($usr))($allExpandedTypes);
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $t = ($$try0)[1];
          return ($corelib$Result$Ok)($t);
        }
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type usr: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 324:8', (sp_toHuman)($$try0));
      });
    });
    return (($sp$Compiler$ExpandTypes$expandAndValidateType)($gt))($type);
  });
});

const $sp$Compiler$ExpandTypes$insertModuleTypes = (($module) => {
  return (($allTypes) => {
    return ((($corelib$Dict$for)($module.unionDefs))((($name) => {
      return (($def) => {
        return (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefUnion)($def));
      });
    })))(((($corelib$Dict$for)($module.aliasDefs))((($name) => {
      return (($def) => {
        return (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefAlias)($def));
      });
    })))($allTypes));
  });
});

const $sp$Compiler$JsToText$id = (($level) => {
  return (($corelib$Text$repeat)($level))("  ");
});

const $sp$Compiler$JsToText$emitExpr = (($l) => {
  return (($expression) => {
    const $$try0 = $expression;
    if (("$sp$Types$JavascriptAst$Literal" === ($$try0)[0])) {
      const $s = ($$try0)[1];
      return $s;
    }
    if (("$sp$Types$JavascriptAst$Var" === ($$try0)[0])) {
      const $n = ($$try0)[1];
      return $n;
    }
    if (("$sp$Types$JavascriptAst$Call" === ($$try0)[0])) {
      const $args = ($$try0)[2];
      const $ref = ($$try0)[1];
      return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($ref) + (")(" + ((($corelib$Text$join)(", "))((($corelib$List$map)(($sp$Compiler$JsToText$emitExpr)($l)))($args)) + ")"))));
    }
    if (("$sp$Types$JavascriptAst$Unop" === ($$try0)[0])) {
      const $left = ($$try0)[2];
      const $op = ($$try0)[1];
      return ($op + ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + ")")));
    }
    if (("$sp$Types$JavascriptAst$Binop" === ($$try0)[0])) {
      const $right = ($$try0)[3];
      const $left = ($$try0)[2];
      const $op = ($$try0)[1];
      return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + (" " + ($op + (" " + ((($sp$Compiler$JsToText$emitExpr)($l))($right) + ")"))))));
    }
    if (("$sp$Types$JavascriptAst$Mutop" === ($$try0)[0])) {
      const $right = ($$try0)[4];
      const $left = ($$try0)[3];
      const $yield = ($$try0)[2];
      const $op = ($$try0)[1];
      return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + (" " + ($op + (" " + ((($sp$Compiler$JsToText$emitExpr)($l))($right) + (", " + ($yield + ")"))))))));
    }
    if (("$sp$Types$JavascriptAst$SimpleLambda" === ($$try0)[0])) {
      const $expr = ($$try0)[2];
      const $params = ($$try0)[1];
      return ("((" + ((($corelib$Text$join)(", "))($params) + (") => " + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + ")"))));
    }
    if (("$sp$Types$JavascriptAst$BlockLambda" === ($$try0)[0])) {
      const $stats = ($$try0)[2];
      const $params = ($$try0)[1];
      return ("((" + ((($corelib$Text$join)(", "))($params) + (") => " + ((($sp$Compiler$JsToText$emitBlock)($l))($stats) + ")"))));
    }
    if (("$sp$Types$JavascriptAst$Record" === ($$try0)[0])) {
      const $attrs = ($$try0)[1];
      return (((sp_equal)($corelib$Dict$empty))($attrs)
        ? "{}"
        : ((($a) => {
          return ("({\n" + ((($corelib$Text$join)("\n"))($a) + ("\n" + (($sp$Compiler$JsToText$id)($l) + "})"))));
        }))((($corelib$List$map)(((key$$) => {
          const $value = key$$.second;
          const $key = key$$.first;
          return (($sp$Compiler$JsToText$id)(($l + 1)) + ($key + (": " + ((($sp$Compiler$JsToText$emitExpr)(($l + 1)))($value) + ","))));
        })))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs)))));
    }
    if (("$sp$Types$JavascriptAst$AccessWithDot" === ($$try0)[0])) {
      const $e = ($$try0)[2];
      const $name = ($$try0)[1];
      return ((($sp$Compiler$JsToText$emitExpr)($l))($e) + ("." + $name));
    }
    if (("$sp$Types$JavascriptAst$AccessWithBrackets" === ($$try0)[0])) {
      const $expr = ($$try0)[2];
      const $i = ($$try0)[1];
      return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + (")[" + ((($sp$Compiler$JsToText$emitExpr)($l))($i) + "]"))));
    }
    if (("$sp$Types$JavascriptAst$Conditional" === ($$try0)[0])) {
      const $false = ($$try0)[3];
      const $true = ($$try0)[2];
      const $p = ($$try0)[1];
      return (("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($p) + "\n")) + ((($sp$Compiler$JsToText$id)(($l + 1)) + ("? " + (($sp$Compiler$JsToText$emitExpr)(($l + 1)))($true))) + ("\n" + ((($sp$Compiler$JsToText$id)(($l + 1)) + (": " + (($sp$Compiler$JsToText$emitExpr)(($l + 1)))($false))) + ")"))));
    }
    if (("$sp$Types$JavascriptAst$Array" === ($$try0)[0])) {
      const $items = ($$try0)[1];
      return (((sp_equal)($core$SPCore$Nil))($items)
        ? "[]"
        : ((($a) => {
          return ("([\n" + ((($corelib$Text$join)("\n"))($a) + ("\n" + (($sp$Compiler$JsToText$id)($l) + "])"))));
        }))((($corelib$List$map)((($i) => {
          return (($sp$Compiler$JsToText$id)(($l + 1)) + ((($sp$Compiler$JsToText$emitExpr)(($l + 1)))($i) + ","));
        })))($items)));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/JsToText.sp 41:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$JsToText$emitStatement = (($l) => {
  return (($stat) => {
    const $std = (($mid) => {
      return (($expr) => {
        return (($sp$Compiler$JsToText$id)($l) + ($mid + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + ";")));
      });
    });
    const $$try0 = $stat;
    if (("$sp$Types$JavascriptAst$Eval" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return (($std)(""))($e);
    }
    if (("$sp$Types$JavascriptAst$Return" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return (($std)("return "))($e);
    }
    if (("$sp$Types$JavascriptAst$Define" === ($$try0)[0])) {
      const $e = ($$try0)[2];
      const $name = ($$try0)[1];
      return (($std)(("const " + ($name + " = "))))($e);
    }
    if (("$sp$Types$JavascriptAst$If" === ($$try0)[0])) {
      const $block = ($$try0)[2];
      const $condition = ($$try0)[1];
      return (($sp$Compiler$JsToText$id)($l) + ("if (" + ((($sp$Compiler$JsToText$emitExpr)($l))($condition) + (") " + (($sp$Compiler$JsToText$emitBlock)($l))($block)))));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/JsToText.sp 14:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$JsToText$emitBlock = (($l) => {
  return (($block) => {
    const $lines = (($corelib$Text$join)("\n"))((($corelib$List$map)(($sp$Compiler$JsToText$emitStatement)(($l + 1))))($block));
    return ("{\n" + ($lines + ("\n" + (($sp$Compiler$JsToText$id)($l) + "}"))));
  });
});

const $sp$Compiler$Lexer$addIndentToken = (($pos) => {
  return (($kind) => {
    return (($state) => {
      return ((array_push)(({
        attr: "tokens",
        obj: ($state.obj)[$state.attr],
      })))(((($sp$Types$Token$Token)($pos))($pos))($kind));
    });
  });
});

const $sp$Compiler$Lexer$updateIndent = (($start) => {
  return (($end) => {
    return (($kind) => {
      return (($state) => {
        const $manageIndent = (($head) => {
          return (((sp_clone)(($state.obj)[$state.attr].lineIndent) > $head.indent)
            ? ((() => {
              const $newIndent = ({
                indent: (sp_clone)(($state.obj)[$state.attr].lineIndent),
                isBlock: (sp_clone)(($state.obj)[$state.attr].indentStartsABlock),
              });
              (($state.obj)[$state.attr].indentStack = ((sp_cons)((sp_clone)(($state.obj)[$state.attr].indentStack)))($newIndent), null);
              return ((sp_clone)(($state.obj)[$state.attr].indentStartsABlock)
                ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$BlockStart))($state)
                : null);
            }))()
            : (($head.isBlock && ((sp_not_equal)($sp$Types$Token$Comment))($kind))
              ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$NewSiblingLine))($state)
              : null));
        });
        const $$try0 = (sp_clone)(($state.obj)[$state.attr].indentStack);
        if (("$core$SPCore$Cons" === ($$try0)[0])) {
          const $tail = ($$try0)[2];
          const $head = ($$try0)[1];
          return (((sp_clone)(($state.obj)[$state.attr].lineIndent) < $head.indent)
            ? ((() => {
              (($state.obj)[$state.attr].indentStack = $tail, null);
              ($head.isBlock
                ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$BlockEnd))($state)
                : null);
              return (((($sp$Compiler$Lexer$updateIndent)($start))($end))($kind))($state);
            }))()
            : ($manageIndent)($head));
        }
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return ($manageIndent)(({
            indent: 0,
            isBlock: true,
          }));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 145:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$Lexer$absAddToken = (($start) => {
  return (($end) => {
    return (($kind) => {
      return (($state) => {
        ((sp_clone)(($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine)
          ? ((() => {
            (($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine = false, null);
            return (((($sp$Compiler$Lexer$updateIndent)($start))($end))($kind))($state);
          }))()
          : null);
        const $indentStartsABlock = ((() => {
          const $$try0 = $kind;
          if (("$sp$Types$Token$Then" === ($$try0)[0])) {
            return true;
          }
          if (("$sp$Types$Token$Else" === ($$try0)[0])) {
            return true;
          }
          if (("$sp$Types$Token$As" === ($$try0)[0])) {
            return true;
          }
          if (("$sp$Types$Token$Colon" === ($$try0)[0])) {
            return true;
          }
          if (("$sp$Types$Token$MutableColon" === ($$try0)[0])) {
            return true;
          }
          if (("$sp$Types$Token$Defop" === ($$try0)[0])) {
            return true;
          }
          if (("$sp$Types$Token$Comment" === ($$try0)[0])) {
            return (sp_clone)(($state.obj)[$state.attr].indentStartsABlock);
          }
          if (true) {
            return false;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 174:8', (sp_toHuman)($$try0));
        }))();
        (($state.obj)[$state.attr].indentStartsABlock = $indentStartsABlock, null);
        ((array_push)(({
          attr: "tokens",
          obj: ($state.obj)[$state.attr],
        })))(((($sp$Types$Token$Token)($start))($end))($kind));
        return (($state.obj)[$state.attr].tokenStart = $end, null);
      });
    });
  });
});

const $sp$Compiler$Lexer$getPos = (($state) => {
  return (sp_clone)(($state.obj)[$state.attr].buffer.nextPos);
});

const $sp$Compiler$Lexer$addError = (($message) => {
  return (($state) => {
    const $end = ($sp$Compiler$Lexer$getPos)($state);
    const $error = (($sp$Compiler$Error$Simple)(((($sp$Types$Pos$P)((sp_clone)(($state.obj)[$state.attr].moduleName)))((sp_clone)(($state.obj)[$state.attr].tokenStart)))($end)))((() => {
      return (($core$SPCore$Cons)($message))($core$SPCore$Nil);
    }));
    (($state.obj)[$state.attr].errors = ((sp_cons)((sp_clone)(($state.obj)[$state.attr].errors)))($error), null);
    return (($state.obj)[$state.attr].tokenStart = $end, null);
  });
});

const $sp$Compiler$Lexer$startsWithUpperChar = (($s) => {
  const $$try0 = ((text_startsWithRegex)("[A-Z]"))($s);
  if (("" === $$try0)) {
    return false;
  }
  if (true) {
    return true;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 264:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$Lexer$addLowerOrUpperWord = (($start) => {
  return (($end) => {
    return (($modifier) => {
      return (($chunk) => {
        return (($state) => {
          const $upperName = (($maybeModule) => {
            return (($name) => {
              const $$try0 = $modifier;
              if (("$sp$Types$Token$NameNoModifier" === ($$try0)[0])) {
                return (((($sp$Compiler$Lexer$absAddToken)($start))($end))((($sp$Types$Token$UpperName)($maybeModule))($name)))($state);
              }
              if (("$sp$Types$Token$NameStartsWithDot" === ($$try0)[0])) {
                return (($sp$Compiler$Lexer$addError)("Types or constructors can't start with `.` and attribute names can't start with an uppercase letter. =|"))($state);
              }
              if (("$sp$Types$Token$NameMutable" === ($$try0)[0])) {
                return (($sp$Compiler$Lexer$addError)("Types or constructors can't be mutable on their own, only variables can!"))($state);
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 274:8', (sp_toHuman)($$try0));
            });
          });
          const $lowerName = (($maybeModule) => {
            return (($name) => {
              return (($attrs) => {
                return ((($corelib$List$any)($sp$Compiler$Lexer$startsWithUpperChar))($attrs)
                  ? (($sp$Compiler$Lexer$addError)("attribute names must start with a lowercase letter"))($state)
                  : ((((sp_not_equal)($corelib$Maybe$Nothing))($maybeModule) && ((sp_not_equal)($sp$Types$Token$NameNoModifier))($modifier))
                    ? (($sp$Compiler$Lexer$addError)("can't use . or @ modifier on an imported value"))($state)
                    : (((($sp$Compiler$Lexer$absAddToken)($start))($end))((((($sp$Types$Token$LowerName)($modifier))($maybeModule))($name))($attrs)))($state)));
              });
            });
          });
          const $snips = ((text_split)("."))($chunk);
          return ((($corelib$List$any)((($s) => {
            return ((sp_equal)(""))($s);
          })))($snips)
            ? (($sp$Compiler$Lexer$addError)("use spaces around `..` to concatenate Text"))($state)
            : ((() => {
              const $$try0 = $snips;
              if (("$core$SPCore$Nil" === ($$try0)[0])) {
                return (sp_todo)("should not happen");
              }
              if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
                const $one = ($$try0)[1];
                return (($sp$Compiler$Lexer$startsWithUpperChar)($one)
                  ? (($upperName)($corelib$Maybe$Nothing))($one)
                  : ((($lowerName)($corelib$Maybe$Nothing))($one))($core$SPCore$Nil));
              }
              if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Cons" === (($$try0)[2])[0]))) {
                const $more = (($$try0)[2])[2];
                const $second = (($$try0)[2])[1];
                const $first = ($$try0)[1];
                const $$try1 = ({
                  first: ($sp$Compiler$Lexer$startsWithUpperChar)($first),
                  second: ($sp$Compiler$Lexer$startsWithUpperChar)($second),
                });
                if (((false === $$try1.first) && (false === $$try1.second))) {
                  return ((($lowerName)($corelib$Maybe$Nothing))($first))(((sp_cons)($more))($second));
                }
                if (((true === $$try1.first) && (false === $$try1.second))) {
                  return ((($lowerName)(($corelib$Maybe$Just)($first)))($second))($more);
                }
                if (((true === $$try1.first) && (true === $$try1.second))) {
                  return (((sp_not_equal)($core$SPCore$Nil))($more)
                    ? (($sp$Compiler$Lexer$addError)("Types and constructors can't have .attributes"))($state)
                    : (($upperName)(($corelib$Maybe$Just)($first)))($second));
                }
                if (((false === $$try1.first) && (true === $$try1.second))) {
                  return (($sp$Compiler$Lexer$addError)("Something wrong with uppercases?"))($state);
                }
                (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 319:12', (sp_toHuman)($$try1));
                return null;
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 300:6', (sp_toHuman)($$try0));
            }))());
        });
      });
    });
  });
});

const $sp$SPLib$Buffer$slice = (($start) => {
  return (($end) => {
    return (($b) => {
      return (((text_slice)($start))($end))($b.fullText);
    });
  });
});

const $sp$Compiler$Lexer$getChunk = (($state) => {
  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
  const $end = ($sp$Compiler$Lexer$getPos)($state);
  return ({
    first: $start,
    second: $end,
    third: ((($sp$SPLib$Buffer$slice)((sp_clone)(($state.obj)[$state.attr].tokenStart)))($end))((sp_clone)(($state.obj)[$state.attr].buffer)),
  });
});

const $sp$Compiler$Lexer$addNumberToken = (($state) => {
  const chunk$$ = ($sp$Compiler$Lexer$getChunk)($state);
  const $chunk = chunk$$.third;
  const $end = chunk$$.second;
  const $start = chunk$$.first;
  return (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$NumberLiteral)($chunk)))($state);
});

const $sp$Compiler$Lexer$addOneIndentToken = (($kind) => {
  return (($state) => {
    const $pos = ($sp$Compiler$Lexer$getPos)($state);
    return ((array_push)(({
      attr: "tokens",
      obj: ($state.obj)[$state.attr],
    })))(((($sp$Types$Token$Token)($pos))($pos))($kind));
  });
});

const $sp$Compiler$Lexer$relAddToken = (($ds) => {
  return (($de) => {
    return (($kind) => {
      return (($state) => {
        const $pos = ($sp$Compiler$Lexer$getPos)($state);
        return (((($sp$Compiler$Lexer$absAddToken)(($pos + $ds)))(($pos + $de)))($kind))($state);
      });
    });
  });
});

const $sp$Compiler$Lexer$addParenOrCommaToken = (($char) => {
  return (($state) => {
    const $add = (($kind) => {
      return (((($sp$Compiler$Lexer$relAddToken)(0))(1))($kind))($state);
    });
    const $$try0 = $char;
    if (("(" === $$try0)) {
      return ($add)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open));
    }
    if ((")" === $$try0)) {
      return ($add)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed));
    }
    if (("[" === $$try0)) {
      return ($add)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open));
    }
    if (("]" === $$try0)) {
      return ($add)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed));
    }
    if (("{" === $$try0)) {
      return ($add)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Open));
    }
    if (("}" === $$try0)) {
      return ($add)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Closed));
    }
    if (("," === $$try0)) {
      return ($add)($sp$Types$Token$Comma);
    }
    if (true) {
      return (($sp$Compiler$Lexer$addError)(("I can't make sense of this piece of text: `" + ($char + "`"))))($state);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 456:4', (sp_toHuman)($$try0));
  });
});

const $sp$Prelude$typeBinop = (($mutates) => {
  return (($left) => {
    return (($right) => {
      return (($return) => {
        return ((($sp$Prelude$tyFun)($right))(false))(((($sp$Prelude$tyFun)($left))($mutates))($return));
      });
    });
  });
});

const $sp$Prelude$typeBinopUniform = (($ty) => {
  return (((($sp$Prelude$typeBinop)(false))($ty))($ty))($ty);
});

const $sp$Prelude$add = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "+",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$and_ = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Logical,
  symbol: "and",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$divide = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Multiplicative,
  symbol: "/",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$equal = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "==",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$greaterOrEqualThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: ">=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$greaterThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: ">",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$lesserOrEqualThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "<=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$lesserThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "<",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$listCons = ((() => {
  const $item = ($sp$Prelude$tyVar)("item");
  return ({
    associativity: $sp$Types$Op$Right,
    nonFn: $core$SPCore$Nil,
    precedence: $sp$Types$Op$Cons,
    symbol: "::",
    type: (((($sp$Prelude$typeBinop)(false))($item))(($sp$Compiler$CoreTypes$list)($item)))(($sp$Compiler$CoreTypes$list)($item)),
  });
}))();

const $sp$Prelude$multiply = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Multiplicative,
  symbol: "*",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$mutableAdd = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: "+=",
  type: (((($sp$Prelude$typeBinop)(true))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$none),
});

const $sp$Prelude$mutableAssign = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: ":=",
  type: (((($sp$Prelude$typeBinop)(true))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$none),
});

const $sp$Prelude$mutableSubtract = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: "-=",
  type: (((($sp$Prelude$typeBinop)(true))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$none),
});

const $sp$Prelude$notEqual = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "/=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$or_ = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Logical,
  symbol: "or",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$sendLeft = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: "<<",
  type: (((($sp$Prelude$typeBinop)(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("b"))))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("b")),
});

const $sp$Prelude$sendRight = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("b"))))(($sp$Prelude$tyVar)("b")),
});

const $sp$Prelude$subtract = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "-",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$textConcat = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "..",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$text),
});

const $sp$Prelude$tuple = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Tuple,
  symbol: "&",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("b")))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$N))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))(($sp$Prelude$tyVar)("b")))(((($corelib$Dict$insert)("first"))(($sp$Prelude$tyVar)("a")))($corelib$Dict$empty)))),
});

const $sp$Prelude$binops = ((($list) => {
  return ((($corelib$List$for)($list))((($bop) => {
    return (($corelib$Dict$insert)($bop.symbol))($bop);
  })))($corelib$Dict$empty);
}))((($core$SPCore$Cons)($sp$Prelude$and_))((($core$SPCore$Cons)($sp$Prelude$or_))((($core$SPCore$Cons)($sp$Prelude$textConcat))((($core$SPCore$Cons)($sp$Prelude$listCons))((($core$SPCore$Cons)($sp$Prelude$tuple))((($core$SPCore$Cons)($sp$Prelude$add))((($core$SPCore$Cons)($sp$Prelude$subtract))((($core$SPCore$Cons)($sp$Prelude$multiply))((($core$SPCore$Cons)($sp$Prelude$divide))((($core$SPCore$Cons)($sp$Prelude$mutableAssign))((($core$SPCore$Cons)($sp$Prelude$mutableAdd))((($core$SPCore$Cons)($sp$Prelude$mutableSubtract))((($core$SPCore$Cons)($sp$Prelude$equal))((($core$SPCore$Cons)($sp$Prelude$notEqual))((($core$SPCore$Cons)($sp$Prelude$lesserThan))((($core$SPCore$Cons)($sp$Prelude$greaterThan))((($core$SPCore$Cons)($sp$Prelude$lesserOrEqualThan))((($core$SPCore$Cons)($sp$Prelude$greaterOrEqualThan))((($core$SPCore$Cons)($sp$Prelude$sendRight))((($core$SPCore$Cons)($sp$Prelude$sendLeft))($core$SPCore$Nil)))))))))))))))))))));

const $sp$Compiler$Lexer$addSquiggleToken = (($nextIsSpace) => {
  return (($state) => {
    const chunk$$ = ($sp$Compiler$Lexer$getChunk)($state);
    const $chunk = chunk$$.third;
    const $end = chunk$$.second;
    const $start = chunk$$.first;
    const $add = (($kind) => {
      return (((($sp$Compiler$Lexer$absAddToken)($start))($end))($kind))($state);
    });
    const $$try0 = $chunk;
    if ((":" === $$try0)) {
      return ($add)($sp$Types$Token$Colon);
    }
    if (("@:" === $$try0)) {
      return ($add)($sp$Types$Token$MutableColon);
    }
    if (("=" === $$try0)) {
      return ($add)(($sp$Types$Token$Defop)(({
        mutable: false,
      })));
    }
    if (("@=" === $$try0)) {
      return ($add)(($sp$Types$Token$Defop)(({
        mutable: true,
      })));
    }
    if (("-" === $$try0)) {
      return ($add)(($nextIsSpace
        ? ($sp$Types$Token$Binop)($sp$Prelude$subtract)
        : ($sp$Types$Token$Unop)($sp$Prelude$unaryMinus)));
    }
    if (("+" === $$try0)) {
      return ($add)(($nextIsSpace
        ? ($sp$Types$Token$Binop)($sp$Prelude$add)
        : ($sp$Types$Token$Unop)($sp$Prelude$unaryPlus)));
    }
    if (true) {
      const $op = $$try0;
      const $$try1 = (($corelib$Dict$get)($chunk))($sp$Prelude$binops);
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $binop = ($$try1)[1];
        return ($add)(($sp$Types$Token$Binop)($binop));
      }
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return (($sp$Compiler$Lexer$addError)(("Invalid operator: `" + ($chunk + "`"))))($state);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 440:12', (sp_toHuman)($$try1));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 432:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$Lexer$addWordToken = (($modifier) => {
  return (($state) => {
    const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
    const $end = ($sp$Compiler$Lexer$getPos)($state);
    const $ds = (((sp_equal)($sp$Types$Token$NameNoModifier))($modifier)
      ? 0
      : 1);
    const $chunk = ((($sp$SPLib$Buffer$slice)(((sp_clone)(($state.obj)[$state.attr].tokenStart) + $ds)))($end))((sp_clone)(($state.obj)[$state.attr].buffer));
    const $maybeKeywordKind = ((() => {
      const $$try0 = $chunk;
      if (("if" === $$try0)) {
        return ($corelib$Maybe$Just)($sp$Types$Token$If);
      }
      if (("then" === $$try0)) {
        return ($corelib$Maybe$Just)($sp$Types$Token$Then);
      }
      if (("else" === $$try0)) {
        return ($corelib$Maybe$Just)($sp$Types$Token$Else);
      }
      if (("try" === $$try0)) {
        return ($corelib$Maybe$Just)($sp$Types$Token$Try);
      }
      if (("as" === $$try0)) {
        return ($corelib$Maybe$Just)($sp$Types$Token$As);
      }
      if (("with" === $$try0)) {
        return ($corelib$Maybe$Just)($sp$Types$Token$With);
      }
      if (("and" === $$try0)) {
        return ($corelib$Maybe$Just)(($sp$Types$Token$Binop)($sp$Prelude$and_));
      }
      if (("or" === $$try0)) {
        return ($corelib$Maybe$Just)(($sp$Types$Token$Binop)($sp$Prelude$or_));
      }
      if (true) {
        return $corelib$Maybe$Nothing;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 356:8', (sp_toHuman)($$try0));
    }))();
    const $$try0 = ({
      first: $maybeKeywordKind,
      second: $modifier,
    });
    if ((("$corelib$Maybe$Just" === ($$try0.first)[0]) && ("$sp$Types$Token$NameNoModifier" === ($$try0.second)[0]))) {
      const $kind = ($$try0.first)[1];
      return (((($sp$Compiler$Lexer$absAddToken)($start))($end))($kind))($state);
    }
    if (("$corelib$Maybe$Just" === ($$try0.first)[0])) {
      const $kind = ($$try0.first)[1];
      return (($sp$Compiler$Lexer$addError)(($chunk + " as a keyword, you can't really use it this way")))($state);
    }
    if (true) {
      return ((((($sp$Compiler$Lexer$addLowerOrUpperWord)($start))($end))($modifier))($chunk))($state);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 367:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$Lexer$closeOpenBlocks = (($state) => {
  const $pos = ($sp$Compiler$Lexer$getPos)($state);
  return (($corelib$List$each)((sp_clone)(($state.obj)[$state.attr].indentStack)))((() => {
    return ((array_push)(({
      attr: "tokens",
      obj: ($state.obj)[$state.attr],
    })))(((($sp$Types$Token$Token)($pos))($pos))($sp$Types$Token$BlockEnd));
  }));
});

const $sp$Compiler$Lexer$isNumber = (($char) => {
  return ((sp_not_equal)(""))(((text_startsWithRegex)("[0-9_.]"))($char));
});

const $sp$Compiler$Lexer$isSquiggle = (($char) => {
  const $$try0 = $char;
  if (("=" === $$try0)) {
    return true;
  }
  if ((":" === $$try0)) {
    return true;
  }
  if (("*" === $$try0)) {
    return true;
  }
  if (("+" === $$try0)) {
    return true;
  }
  if (("-" === $$try0)) {
    return true;
  }
  if (("/" === $$try0)) {
    return true;
  }
  if ((">" === $$try0)) {
    return true;
  }
  if (("<" === $$try0)) {
    return true;
  }
  if (("!" === $$try0)) {
    return true;
  }
  if (("&" === $$try0)) {
    return true;
  }
  if (("^" === $$try0)) {
    return true;
  }
  if (true) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 408:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$Lexer$isWordBody = (($char) => {
  return ((sp_not_equal)(""))(((text_startsWithRegex)("[a-zA-Z./_0-9]"))($char));
});

const $sp$Compiler$Lexer$isWordStart = (($char) => {
  return ((sp_not_equal)(""))(((text_startsWithRegex)("[a-zA-Z._]"))($char));
});

const $sp$Compiler$Lexer$setMode = (($mode) => {
  return (($state) => {
    return (($state.obj)[$state.attr].mode = $mode, null);
  });
});

const $sp$Compiler$Lexer$tryIndent = (($indentChar) => {
  return (($char) => {
    return (($state) => {
      return ((((sp_equal)($indentChar))($char) || ((sp_equal)(""))($char))
        ? null
        : ((((sp_equal)(" "))($char) || ((sp_equal)("\t"))($char))
          ? (($sp$Compiler$Lexer$addError)("mixing tabs and spaces!"))($state)
          : (((sp_equal)("\n"))($char)
            ? ((() => {
              (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1), null);
              return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Indent))($state);
            }))()
            : (((sp_equal)("#"))($char)
              ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$LineComment))($state)
              : ((() => {
                (($state.obj)[$state.attr].lineIndent = (sp_clone)(($state.obj)[$state.attr].column), null);
                (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                return (($sp$Compiler$Lexer$lexOne)($char))($state);
              }))()))));
    });
  });
});

const $sp$Compiler$Lexer$unindent = (($raw) => {
  return (($corelib$Basics$not)(((text_startsWith)("\n"))($raw))
    ? $raw
    : ((() => {
      const $multilineText = ((text_dropLeft)(1))($raw);
      const $lines = ((text_split)("\n"))($multilineText);
      const $countLeadingSpaces = (($line) => {
        return (text_length)(((text_startsWithRegex)("[ ]*"))($line));
      });
      const $minLead = (($corelib$Maybe$withDefault)(0))(($corelib$List$minimum)((($corelib$List$map)($countLeadingSpaces))((($corelib$List$filter)((($s) => {
        return ((sp_not_equal)(""))((text_trimLeft)($s));
      })))($lines))));
      return (((text_replaceRegex)("\n[ ]*$"))(""))((($corelib$Text$join)("\n"))((($corelib$List$map)((text_dropLeft)($minLead)))($lines)));
    }))());
});

const $sp$Compiler$Lexer$lexOne = (($char) => {
  return (($state) => {
    const $pos = ($sp$Compiler$Lexer$getPos)($state);
    const $$try0 = (sp_clone)(($state.obj)[$state.attr].mode);
    if (("$sp$Compiler$Lexer$Indent" === ($$try0)[0])) {
      const $$try1 = (sp_clone)(($state.obj)[$state.attr].tabsOrSpaces);
      if (("$sp$Compiler$Lexer$Tabs" === ($$try1)[0])) {
        return ((($sp$Compiler$Lexer$tryIndent)("\t"))($char))($state);
      }
      if (("$sp$Compiler$Lexer$Spaces" === ($$try1)[0])) {
        return ((($sp$Compiler$Lexer$tryIndent)(" "))($char))($state);
      }
      if (("$sp$Compiler$Lexer$NoTabsOrSpacesYet" === ($$try1)[0])) {
        const $$try2 = $char;
        if ((" " === $$try2)) {
          (($state.obj)[$state.attr].tabsOrSpaces = $sp$Compiler$Lexer$Spaces, null);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
          return null;
        }
        if (("\t" === $$try2)) {
          (($state.obj)[$state.attr].tabsOrSpaces = $sp$Compiler$Lexer$Tabs, null);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
          return null;
        }
        if (true) {
          return ((($sp$Compiler$Lexer$tryIndent)(" "))($char))($state);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 492:14', (sp_toHuman)($$try2));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 484:10', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Compiler$Lexer$Default" === ($$try0)[0])) {
      const $$try1 = $char;
      if (("" === $$try1)) {
        return null;
      }
      if (("." === $$try1)) {
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Dot))($state);
      }
      if (("@" === $$try1)) {
        (($state.obj)[$state.attr].tokenStart = ($sp$Compiler$Lexer$getPos)($state), null);
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Mutable))($state);
        return null;
      }
      if (("#" === $$try1)) {
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$LineComment))($state);
      }
      if (("[" === $$try1)) {
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningBlockComment))($state);
      }
      if (("\"" === $$try1)) {
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningQuotes_One))($state);
      }
      if (("\n" === $$try1)) {
        (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1), null);
        (($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine = true, null);
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Indent))($state);
        return null;
      }
      if ((" " === $$try1)) {
        return (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1), null);
      }
      if (true) {
        (($state.obj)[$state.attr].tokenStart = ($sp$Compiler$Lexer$getPos)($state), null);
        return (($sp$Compiler$Lexer$isWordStart)($char)
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameNoModifier)))($state)
          : (($sp$Compiler$Lexer$isNumber)($char)
            ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$NumberLiteral))($state)
            : (($sp$Compiler$Lexer$isSquiggle)($char)
              ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Squiggles))($state)
              : (($sp$Compiler$Lexer$addParenOrCommaToken)($char))($state))));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 503:10', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Compiler$Lexer$Dot" === ($$try0)[0])) {
      return (((sp_equal)("."))($char)
        ? ((() => {
          (((($sp$Compiler$Lexer$relAddToken)((0 - 1)))(1))(($sp$Types$Token$Binop)($sp$Prelude$textConcat)))($state);
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
        }))()
        : (($sp$Compiler$Lexer$isWordStart)($char)
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameStartsWithDot)))($state)
          : (($sp$Compiler$Lexer$isNumber)($char)
            ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$NumberLiteral))($state)
            : (($sp$Compiler$Lexer$addError)("no idea what this is"))($state))));
    }
    if (("$sp$Compiler$Lexer$Mutable" === ($$try0)[0])) {
      return (($sp$Compiler$Lexer$isWordStart)($char)
        ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameMutable)))($state)
        : (($sp$Compiler$Lexer$isSquiggle)($char)
          ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Squiggles))($state)
          : (($sp$Compiler$Lexer$addError)("no idea what this is"))($state)));
    }
    if (("$sp$Compiler$Lexer$Word" === ($$try0)[0])) {
      const $modifier = ($$try0)[1];
      return (($sp$Compiler$Lexer$isWordBody)($char)
        ? null
        : ((() => {
          (($sp$Compiler$Lexer$addWordToken)($modifier))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$NumberLiteral" === ($$try0)[0])) {
      return (($sp$Compiler$Lexer$isNumber)($char)
        ? null
        : ((() => {
          ($sp$Compiler$Lexer$addNumberToken)($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$Squiggles" === ($$try0)[0])) {
      return (($sp$Compiler$Lexer$isSquiggle)($char)
        ? null
        : ((() => {
          (($sp$Compiler$Lexer$addSquiggleToken)(((sp_equal)(" "))($char)))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$ContentOpeningQuotes_One" === ($$try0)[0])) {
      return (((sp_equal)("\""))($char)
        ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningQuotes_Two))($state)
        : (((sp_equal)(""))($char)
          ? (($sp$Compiler$Lexer$addError)("there's no closing quotes"))($state)
          : ((() => {
            (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) - 1), null);
            (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
              lastEscape: -(1),
            }))))($state);
            return (($sp$Compiler$Lexer$lexOne)($char))($state);
          }))()));
    }
    if (("$sp$Compiler$Lexer$ContentOpeningQuotes_Two" === ($$try0)[0])) {
      return (((sp_equal)("\""))($char)
        ? ((() => {
          (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) - 2), null);
          return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
            closingQuotes: 0,
            lastEscape: -(1),
          }))))($state);
        }))()
        : ((() => {
          (((($sp$Compiler$Lexer$relAddToken)((0 - 2)))(0))(($sp$Types$Token$TextLiteral)("")))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$SingleQuote" === ($$try0)[0])) {
      const $lastEscape = ($$try0)[1].lastEscape;
      const $previousIsEscape = ((sp_equal)(($lastEscape + 1)))($pos);
      return (((sp_equal)(""))($char)
        ? (($sp$Compiler$Lexer$addError)("there's no closing quotes"))($state)
        : ($previousIsEscape
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
            lastEscape: $lastEscape,
          }))))($state)
          : ((() => {
            const $$try1 = $char;
            if (("\"" === $$try1)) {
              const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
              const $end = ($pos + 1);
              const $value = ((($corelib$Text$replace)("\\\""))("\""))(((($sp$SPLib$Buffer$slice)(($start + 1)))(($end - 1)))((sp_clone)(($state.obj)[$state.attr].buffer)));
              (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$TextLiteral)($value)))($state);
              return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
              return null;
            }
            if (("\\" === $$try1)) {
              return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
                lastEscape: $pos,
              }))))($state);
            }
            if (true) {
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 629:12', (sp_toHuman)($$try1));
          }))()));
      return null;
    }
    if (("$sp$Compiler$Lexer$TripleQuote" === ($$try0)[0])) {
      const $lastEscape = ($$try0)[1].lastEscape;
      const $closingQuotes = ($$try0)[1].closingQuotes;
      const $previousIsEscape = ((sp_equal)(($lastEscape + 1)))($pos);
      return (((sp_equal)(""))($char)
        ? (($sp$Compiler$Lexer$addError)("unterminated triple quotes"))($state)
        : ($previousIsEscape
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
            closingQuotes: 0,
            lastEscape: $lastEscape,
          }))))($state)
          : ((() => {
            const $$try1 = $char;
            if (("\"" === $$try1)) {
              return (((sp_equal)(2))($closingQuotes)
                ? ((() => {
                  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
                  const $end = ($pos + 1);
                  const $value = ($sp$Compiler$Lexer$unindent)(((($sp$SPLib$Buffer$slice)(($start + 3)))(($end - 3)))((sp_clone)(($state.obj)[$state.attr].buffer)));
                  (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$TextLiteral)($value)))($state);
                  return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                }))()
                : (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                  closingQuotes: ($closingQuotes + 1),
                  lastEscape: $lastEscape,
                }))))($state));
            }
            if (("\\" === $$try1)) {
              return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                closingQuotes: 0,
                lastEscape: $pos,
              }))))($state);
            }
            if (true) {
              return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                closingQuotes: 0,
                lastEscape: $lastEscape,
              }))))($state);
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 669:13', (sp_toHuman)($$try1));
          }))()));
      return null;
    }
    if (("$sp$Compiler$Lexer$LineComment" === ($$try0)[0])) {
      return ((((sp_equal)("\n"))($char) || ((sp_equal)(""))($char))
        ? ((() => {
          (((($sp$Compiler$Lexer$absAddToken)((sp_clone)(($state.obj)[$state.attr].tokenStart)))(($sp$Compiler$Lexer$getPos)($state)))($sp$Types$Token$Comment))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))()
        : null);
    }
    if (("$sp$Compiler$Lexer$ContentOpeningBlockComment" === ($$try0)[0])) {
      return (((sp_equal)("#"))($char)
        ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$BlockComment)(({
          nesting: 1,
          previous: "",
        }))))($state)
        : ((() => {
          (((($sp$Compiler$Lexer$relAddToken)((0 - 1)))(0))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$BlockComment" === ($$try0)[0])) {
      const $previous = ($$try0)[1].previous;
      const $nesting = ($$try0)[1].nesting;
      const $continueWithDeltaNesting = (($dn) => {
        return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$BlockComment)(({
          nesting: ($nesting + $dn),
          previous: $char,
        }))))($state);
      });
      const $$try1 = ({
        first: $previous,
        second: $char,
      });
      if ((("[" === $$try1.first) && ("#" === $$try1.second))) {
        return ($continueWithDeltaNesting)(1);
      }
      if ((("#" === $$try1.first) && ("]" === $$try1.second))) {
        return (($nesting > 1)
          ? ($continueWithDeltaNesting)((0 - 1))
          : ((() => {
            (((($sp$Compiler$Lexer$absAddToken)((sp_clone)(($state.obj)[$state.attr].tokenStart)))(($sp$Compiler$Lexer$getPos)($state)))($sp$Types$Token$Comment))($state);
            return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          }))());
      }
      if (("" === $$try1.second)) {
        return (($sp$Compiler$Lexer$addError)("unterminated block comment"))($state);
      }
      if (true) {
        return ($continueWithDeltaNesting)(0);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 713:10', (sp_toHuman)($$try1));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 481:4', (sp_toHuman)($$try0));
  });
});

const $sp$SPLib$Buffer$init = (($s) => {
  return ({
    fullSize: (text_length)($s),
    fullText: $s,
    nextPos: 0,
  });
});

const $sp$Compiler$Lexer$readStateInit = (($moduleName) => {
  return (($moduleCode) => {
    return ({
      buffer: ($sp$SPLib$Buffer$init)($moduleCode),
      column: 0,
      errors: $core$SPCore$Nil,
      indentStack: $core$SPCore$Nil,
      indentStartsABlock: true,
      line: 0,
      lineIndent: 0,
      mode: $sp$Compiler$Lexer$Indent,
      moduleName: $moduleName,
      soFarThereAreNoTokensInThisLine: true,
      tabsOrSpaces: $sp$Compiler$Lexer$NoTabsOrSpacesYet,
      tokenStart: 0,
      tokens: (array_fromList)($core$SPCore$Nil),
    });
  });
});

const $sp$Compiler$Lexer$lexer = (($moduleName) => {
  return (($moduleCode) => {
    (sp_benchStart)(null);
    const $state = ({
      attr: "$",
      obj: ({
        $: (($sp$Compiler$Lexer$readStateInit)($moduleName))($moduleCode),
      }),
    });
    ((text_forEach)($moduleCode))((($char) => {
      (($sp$Compiler$Lexer$lexOne)($char))($state);
      (($state.obj)[$state.attr].buffer.nextPos += 1, null);
      return (((sp_equal)("\n"))($char)
        ? ((() => {
          (($state.obj)[$state.attr].line += 1, null);
          return (($state.obj)[$state.attr].column = 0, null);
        }))()
        : (($state.obj)[$state.attr].column += 1, null));
    }));
    (($sp$Compiler$Lexer$lexOne)(""))($state);
    return (((sp_equal)($core$SPCore$Nil))((sp_clone)(($state.obj)[$state.attr].errors))
      ? ((() => {
        ($sp$Compiler$Lexer$closeOpenBlocks)($state);
        return ((($corelib$Basics$btw)(sp_benchStop))("lexer"))(($corelib$Result$Ok)((array_toList)((sp_clone)(($state.obj)[$state.attr].tokens))));
      }))()
      : ((($corelib$Basics$btw)(sp_benchStop))("lexer"))(($corelib$Result$Err)(($sp$Compiler$Error$Nested)((sp_clone)(($state.obj)[$state.attr].errors)))));
  });
});

const $sp$Compiler$Lexer_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$TestHelpers$moduleName = "(test)";

const $sp$Compiler$TestHelpers$dummyErrorEnv = (($code) => {
  return ({
    moduleByName: (($corelib$Dict$singleton)($sp$Compiler$TestHelpers$moduleName))(({
      content: $code,
      fsPath: "<TestPath>",
    })),
  });
});

const $sp$Compiler$TestHelpers$formattedToStrippedText = (($formatted) => {
  const $strip = (($fmt) => {
    const $$try0 = $fmt;
    if (("$sp$Compiler$Error$FormattedText_Default" === ($$try0)[0])) {
      const $t = ($$try0)[1];
      return $t;
    }
    if (("$sp$Compiler$Error$FormattedText_Emphasys" === ($$try0)[0])) {
      const $t = ($$try0)[1];
      return $t;
    }
    if (("$sp$Compiler$Error$FormattedText_Warning" === ($$try0)[0])) {
      const $t = ($$try0)[1];
      return $t;
    }
    if (("$sp$Compiler$Error$FormattedText_Decoration" === ($$try0)[0])) {
      const $t = ($$try0)[1];
      return $t;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TestHelpers.sp 62:8', (sp_toHuman)($$try0));
  });
  return (($corelib$Text$join)(""))((($corelib$List$map)($strip))($formatted));
});

const $sp$Compiler$TestHelpers$resErrorToStrippedText = (($code) => {
  return ($corelib$Result$mapError)((($e) => {
    return ($sp$Compiler$TestHelpers$formattedToStrippedText)((($sp$Compiler$Error$toFormattedText)(($sp$Compiler$TestHelpers$dummyErrorEnv)($code)))($e));
  }));
});

const $sp$Compiler$Lexer_Test$lexTokens = (($s) => {
  return (($sp$Compiler$TestHelpers$resErrorToStrippedText)($s))((($sp$Compiler$Lexer$lexer)($sp$Compiler$TestHelpers$moduleName))($s));
});

const $sp$Compiler$Lexer_Test$non_mut_name = (($n) => {
  return (((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))($n))($core$SPCore$Nil);
});

const $sp$Compiler$Lexer_Test$comments = (($sp$Test$Group)("Comments"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] statement after comment"))("\n#\na = 1\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(3))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(5))(6))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] nested comments allow a spurious newline?"))("\n[#[##]#]\na = 1\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(8))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(10))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(11))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(14))(15))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Single line"))("# hello"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(7))($sp$Types$Token$Comment)))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Multi line"))("[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(16))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(19))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(20))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(32))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(34))(35))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(36))(37))(($sp$Types$Token$NumberLiteral)("1"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(58))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(61))(78))($sp$Types$Token$Comment)))($core$SPCore$Nil))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("brackets"))("[]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] Inline comments should not break a block"))("allTests = [\n    , a\n#\n    ]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(8))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("allTests"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(9))(10))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(11))(12))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(17))(18))($sp$Types$Token$Comma)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(20))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("a"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(22))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(27))(28))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(28))(28))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil)))))))))))))($core$SPCore$Nil)))))));

const $sp$Compiler$Lexer_Test$indentation = (($sp$Test$Group)("Blocks, sibling lines, indentation"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("1"))("\na =\n 1\nb = 1"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(1))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(6))(6))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(6))(7))(($sp$Types$Token$NumberLiteral)("1"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(8))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(8))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(9))(($sp$Compiler$Lexer_Test$non_mut_name)("b"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(11))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil))))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] spurious spaces in front of field name"))("module =\n   importAs =\n      SPCore\n   globalTypes =\n      None"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("module"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(12))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(20))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("importAs"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(22))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(29))(29))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(29))(35))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("SPCore"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(39))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(39))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(50))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("globalTypes"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(51))(52))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(59))(59))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(59))(63))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("None"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(63))(63))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(63))(63))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil))))))))))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Blocks and not"))((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("module ="))((($core$SPCore$Cons)("   i ="))((($core$SPCore$Cons)("        j"))((($core$SPCore$Cons)("            >> k"))((($core$SPCore$Cons)("            >> s"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   importAs ="))((($core$SPCore$Cons)("      SPCore"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   globalTypes ="))((($core$SPCore$Cons)("      None"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   a +     # no block start!"))((($core$SPCore$Cons)("        b   # no sibling"))((($core$SPCore$Cons)("        c"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   d =     # block start"))((($core$SPCore$Cons)("        e   # sibling!"))((($core$SPCore$Cons)("        f"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   g = h"))($core$SPCore$Nil))))))))))))))))))))))))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("module"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(12))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("i"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(14))(15))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(24))(24))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(24))(25))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("j"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(38))(40))(($sp$Types$Token$Binop)(({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))))(false))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))),
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(41))(42))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("k"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(55))(57))(($sp$Types$Token$Binop)(({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))))(false))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))),
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(58))(59))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("s"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(64))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(64))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(72))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("importAs"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(73))(74))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(81))(81))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(81))(87))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("SPCore"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(92))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(92))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(103))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("globalTypes"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(104))(105))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(112))(112))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(112))(116))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("None"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(121))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(121))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(122))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("a"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(123))(124))(($sp$Types$Token$Binop)(({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "+",
  type: (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$N))((($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("Number")))($core$SPCore$Nil)))(false))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$N))((($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("Number")))($core$SPCore$Nil)))(false))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$N))((($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("Number")))($core$SPCore$Nil))),
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(129))(146))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(155))(156))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(159))(171))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(180))(181))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(186))(186))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(186))(187))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("d"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(188))(189))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(194))(207))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(216))(216))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(216))(217))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("e"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(220))(230))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(239))(239))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(239))(240))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("f"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(245))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(245))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(246))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("g"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(247))(248))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(249))(250))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("h"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(250))(250))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))($core$SPCore$Nil))));

const $sp$Compiler$Lexer_Test$keywords = (($sp$Test$Group)("keywords"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] can't @ keywords"))("@with"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("keyword"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$lexTokensAndDrop = (($n) => {
  return (($s) => {
    return (($corelib$Result$map)(($corelib$List$drop)($n)))(($sp$Compiler$Lexer_Test$lexTokens)($s));
  });
});

const $sp$Compiler$Lexer_Test$ops = (($sp$Test$Group)("Operators"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] .. set Default"))(".. []"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$Binop)($sp$Prelude$textConcat))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(4))(5))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))($core$SPCore$Nil))))))))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$position = (($sp$Test$Group)("Position"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] ops position"))("blah <>"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah <>"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] ops position, with newline"))("blah <>\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah <>"))($core$SPCore$Nil)))))($core$SPCore$Nil)));

const $sp$Compiler$Lexer_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $sp$Compiler$Lexer_Test$textLiterals = (($sp$Test$Group)("Text literals"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Empty Text"))("\"\""))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$TextLiteral)(""))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Followed by colon"))("\"n\":\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(3))(($sp$Types$Token$TextLiteral)("n"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))($sp$Types$Token$Colon)))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] should not add the indent!"))("try char as\n    \"\":\n        None\n\n    \"@\""))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(11)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(38))(41))(($sp$Types$Token$TextLiteral)("@"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(41))(41))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($sp$Compiler$Lexer_Test$valueTest)("Unindent function"))((() => {
  return ($sp$Compiler$Lexer$unindent)((($corelib$Text$join)(""))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("  a\n"))((($core$SPCore$Cons)("      \n"))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("  b\n"))((($core$SPCore$Cons)("  "))($core$SPCore$Nil))))))));
})))(($sp$Test$isOkAndEqualTo)((($corelib$Text$join)(""))((($core$SPCore$Cons)("a\n"))((($core$SPCore$Cons)("    \n"))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("b"))($core$SPCore$Nil)))))))))($core$SPCore$Nil)))));

const $sp$Compiler$Lexer_Test$unaryAddittiveOps = (($sp$Test$Group)("Unary addittive ops"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("-a"))("-a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("a - -a"))("a - -a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(2))(3))(($sp$Types$Token$Binop)($sp$Prelude$subtract))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(4))(5))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(5))(6))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("a-a"))("a-a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(2))(3))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Mutable colon:"))("@:"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))($sp$Types$Token$MutableColon)))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("-="))("-="))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$Binop)($sp$Prelude$mutableSubtract))))($core$SPCore$Nil))))))($core$SPCore$Nil))))));

const $sp$Compiler$Lexer_Test$underscores = (($sp$Test$Group)("Underscores"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'_' as a Name"))("_"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("_"))($core$SPCore$Nil))))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'_10_20' as a Name"))("_10_20"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("_10_20"))($core$SPCore$Nil))))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'10_20' as a Number"))("10_20"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(5))(($sp$Types$Token$NumberLiteral)("10_20"))))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$Lexer_Test$tests = (($sp$Test$Group)("Lexer"))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$keywords))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$ops))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$unaryAddittiveOps))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$indentation))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$comments))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$underscores))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$position))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$textLiterals))($core$SPCore$Nil)))))))));

const $sp$Compiler$MakeCanonical$makeError = (($pos) => {
  return (($msg) => {
    return (($sp$Compiler$Error$res)($pos))((($errorEnv) => {
      return $msg;
    }));
  });
});

const $sp$Compiler$MakeCanonical$maybeForeignUsr = (($getter) => {
  return (($ro) => {
    return (($maybeModule) => {
      return (($name) => {
        const $$try0 = $maybeModule;
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $moduleName = ($$try0)[1];
          const $$try1 = (($corelib$Dict$get)($moduleName))($ro.meta.moduleVisibleAsToUmr);
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $umr = ($$try1)[1];
            return ($corelib$Maybe$Just)((($sp$Types$Meta$USR)($umr))($name));
          }
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return (sp_todo)(("!!resolveToUsr can't find the module: " + ($moduleName + (" (for: " + ($name + ")")))));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 105:12', (sp_toHuman)($$try1));
          return null;
        }
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return (($corelib$Dict$get)($name))(($getter)($ro.meta));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 103:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToUsr = (($getter) => {
  return (($ro) => {
    return (($maybeModule) => {
      return (($name) => {
        return (($corelib$Maybe$withDefault)((($sp$Types$Meta$USR)($ro.currentModule))($name)))((((($sp$Compiler$MakeCanonical$maybeForeignUsr)($getter))($ro))($maybeModule))($name));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToTypeUsr = ($sp$Compiler$MakeCanonical$resolveToUsr)((($m) => {
  return $m.globalTypes;
}));

const $sp$Compiler$MakeCanonical$translateType = (($mrf) => {
  return (($ro) => {
    return (($faType) => {
      const $$try0 = $faType;
      if (("$sp$Types$FormattableAst$TypeVariable" === ($$try0)[0])) {
        const $name = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = $mrf;
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$TypeVariable)($pos))($name));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $renameFunction = ($$try1)[1];
          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$TypeVariable)($pos))((($renameFunction)($pos))($name)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 915:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$FormattableAst$TypeConstant" === ($$try0)[0])) {
        const $args = ($$try0)[4];
        const $name = ($$try0)[3];
        const $maybeModule = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($corelib$Result$onOk)((($caArgs) => {
          return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeConstant)($pos))(((($sp$Compiler$MakeCanonical$resolveToTypeUsr)($ro))($maybeModule))($name)))($caArgs));
        })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro)))($args));
      }
      if (("$sp$Types$FormattableAst$TypeFunction" === ($$try0)[0])) {
        const $fa_to = ($$try0)[4];
        const $fromIsMut = ($$try0)[3];
        const $fa_from = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($corelib$Result$onOk)((($ca_from) => {
          return (($corelib$Result$onOk)((($ca_to) => {
            return ($corelib$Result$Ok)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($ca_from))($fromIsMut))($ca_to));
          })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($fa_to));
        })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($fa_from));
      }
      if (("$sp$Types$FormattableAst$TypeTuple" === ($$try0)[0])) {
        const $types = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = $types;
        if ((("$core$SPCore$Cons" === ($$try1)[0]) && (("$core$SPCore$Cons" === (($$try1)[2])[0]) && ("$core$SPCore$Nil" === ((($$try1)[2])[2])[0])))) {
          const $faSecond = (($$try1)[2])[1];
          const $faFirst = ($$try1)[1];
          return (($corelib$Result$onOk)((($caFirst) => {
            return (($corelib$Result$onOk)((($caSecond) => {
              return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($caSecond))(((($corelib$Dict$insert)("first"))($caFirst))($corelib$Dict$empty))));
            })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faSecond));
          })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faFirst));
        }
        if ((("$core$SPCore$Cons" === ($$try1)[0]) && (("$core$SPCore$Cons" === (($$try1)[2])[0]) && (("$core$SPCore$Cons" === ((($$try1)[2])[2])[0]) && ("$core$SPCore$Nil" === (((($$try1)[2])[2])[2])[0]))))) {
          const $faThird = ((($$try1)[2])[2])[1];
          const $faSecond = (($$try1)[2])[1];
          const $faFirst = ($$try1)[1];
          return (($corelib$Result$onOk)((($caFirst) => {
            return (($corelib$Result$onOk)((($caSecond) => {
              return (($corelib$Result$onOk)((($caThird) => {
                return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("third"))($caThird))(((($corelib$Dict$insert)("second"))($caSecond))(((($corelib$Dict$insert)("first"))($caFirst))($corelib$Dict$empty)))));
              })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faThird));
            })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faSecond));
          })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faFirst));
        }
        if (true) {
          return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Tuples can only have size 2 or 3. Use a record."))($core$SPCore$Nil));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 934:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$FormattableAst$TypeList" === ($$try0)[0])) {
        const $faItem = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($corelib$Result$onOk)((($caItem) => {
          return ($corelib$Result$Ok)(($sp$Compiler$CoreTypes$list)($caItem));
        })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faItem));
      }
      if (("$sp$Types$FormattableAst$TypeRecord" === ($$try0)[0])) {
        const $recordArgs = ($$try0)[2];
        const $p = ($$try0)[1];
        return (((sp_not_equal)($corelib$Maybe$Nothing))($recordArgs.extends)
          ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)("For now extensible types are disabled, I want to see if it's good to do without them"))($core$SPCore$Nil))
          : (((($sp$Compiler$MakeCanonical$addAttributes)($ro))($p))($recordArgs.attrs))($corelib$Dict$empty));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 913:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$MakeCanonical$addAttributes = (($ro) => {
  return (($pos) => {
    return (($faAttrs) => {
      return (($caAttrsAccum) => {
        const $$try0 = $faAttrs;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($caAttrsAccum));
        }
        if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$Pos$At" === (($$try0)[1].first)[0]))) {
          const $faTail = ($$try0)[2];
          const $maybeFaType = ($$try0)[1].second;
          const $name = (($$try0)[1].first)[2];
          const $p = (($$try0)[1].first)[1];
          const $$try1 = $maybeFaType;
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)(("Attribute `" + ($name + "` must have a type"))))($core$SPCore$Nil));
          }
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $faType = ($$try1)[1];
            return (($corelib$Result$onOk)((($caType) => {
              return (((($sp$Compiler$MakeCanonical$addAttributes)($ro))($p))($faTail))(((($corelib$Dict$insert)($name))($caType))($caAttrsAccum));
            })))(((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro))($faType));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 898:12', (sp_toHuman)($$try1));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 892:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$deps_init = ({
  cons: $corelib$Set$empty,
  types: $corelib$Set$empty,
  values: $corelib$Set$empty,
});

const $sp$Compiler$MakeCanonical$typeDeps = (($type) => {
  return (($acc) => {
    const $$try0 = $type;
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      const $args = ($$try0)[3];
      const $usr = ($$try0)[2];
      return ((($corelib$List$for)($args))($sp$Compiler$MakeCanonical$typeDeps))((($corelib$Set$insert)($usr))($acc));
    }
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      return $acc;
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $from = ($$try0)[2];
      return (($sp$Compiler$MakeCanonical$typeDeps)($to))((($sp$Compiler$MakeCanonical$typeDeps)($from))($acc));
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      return ((($corelib$Dict$for)($attrs))((($k) => {
        return $sp$Compiler$MakeCanonical$typeDeps;
      })))($acc);
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      return (sp_todo)("typeDeps: Should not happen");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 158:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$MakeCanonical$patternDeps = (($pattern) => {
  return (($deps) => {
    const $$try0 = $pattern;
    if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
      const $ps = ($$try0)[3];
      const $usr = ($$try0)[2];
      return ((($corelib$List$for)($ps))($sp$Compiler$MakeCanonical$patternDeps))((Object.assign)({}, $deps, ({
        cons: (($corelib$Set$insert)($usr))($deps.cons),
      })));
    }
    if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
      const $ps = ($$try0)[2];
      return ((($corelib$Dict$for)($ps))((($k) => {
        return $sp$Compiler$MakeCanonical$patternDeps;
      })))($deps);
    }
    if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[3])[0]))) {
      const $type = (($$try0)[3])[1];
      return (Object.assign)({}, $deps, ({
        types: (($sp$Compiler$MakeCanonical$typeDeps)($type))($deps.types),
      }));
    }
    if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Nothing" === (($$try0)[3])[0]))) {
      return $deps;
    }
    if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
      return $deps;
    }
    if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
      return $deps;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 182:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$MakeCanonical$expressionDeps = (($expr) => {
  return (($deps) => {
    const $$try0 = $expr;
    if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try0)[0])) {
      return $deps;
    }
    if (("$sp$Types$CanonicalAst$LiteralText" === ($$try0)[0])) {
      return $deps;
    }
    if ((("$sp$Types$CanonicalAst$Variable" === ($$try0)[0]) && ("$sp$Types$CanonicalAst$RefRoot" === (($$try0)[2].ref)[0]))) {
      const $usr = (($$try0)[2].ref)[1];
      const $attrPath = ($$try0)[2].attrPath;
      return (Object.assign)({}, $deps, ({
        values: (($corelib$Set$insert)($usr))($deps.values),
      }));
    }
    if (("$sp$Types$CanonicalAst$Variable" === ($$try0)[0])) {
      return $deps;
    }
    if (("$sp$Types$CanonicalAst$Constructor" === ($$try0)[0])) {
      const $usr = ($$try0)[2];
      return (Object.assign)({}, $deps, ({
        cons: (($corelib$Set$insert)($usr))($deps.cons),
      }));
    }
    if ((("$sp$Types$CanonicalAst$Lambda" === ($$try0)[0]) && ("$sp$Types$CanonicalAst$ParameterPattern" === (($$try0)[2])[0]))) {
      const $body = ($$try0)[3];
      const $pa = (($$try0)[2])[1];
      return (($sp$Compiler$MakeCanonical$expressionDeps)($body))((($sp$Compiler$MakeCanonical$patternDeps)($pa))($deps));
    }
    if ((("$sp$Types$CanonicalAst$Lambda" === ($$try0)[0]) && ("$sp$Types$CanonicalAst$ParameterMutable" === (($$try0)[2])[0]))) {
      const $body = ($$try0)[3];
      return (($sp$Compiler$MakeCanonical$expressionDeps)($body))($deps);
    }
    if ((("$sp$Types$CanonicalAst$Record" === ($$try0)[0]) && ("$corelib$Maybe$Nothing" === (($$try0)[2])[0]))) {
      const $exprByName = ($$try0)[3];
      return ((($corelib$Dict$for)($exprByName))((($name) => {
        return $sp$Compiler$MakeCanonical$expressionDeps;
      })))($deps);
    }
    if ((("$sp$Types$CanonicalAst$Record" === ($$try0)[0]) && (("$corelib$Maybe$Just" === (($$try0)[2])[0]) && ("$sp$Types$CanonicalAst$RefRoot" === ((($$try0)[2])[1].ref)[0])))) {
      const $exprByName = ($$try0)[3];
      const $usr = ((($$try0)[2])[1].ref)[1];
      const $attrPath = (($$try0)[2])[1].attrPath;
      return ((($corelib$Dict$for)($exprByName))((($name) => {
        return $sp$Compiler$MakeCanonical$expressionDeps;
      })))((Object.assign)({}, $deps, ({
        values: (($corelib$Set$insert)($usr))($deps.values),
      })));
    }
    if (("$sp$Types$CanonicalAst$Record" === ($$try0)[0])) {
      const $exprByName = ($$try0)[3];
      return ((($corelib$Dict$for)($exprByName))((($name) => {
        return $sp$Compiler$MakeCanonical$expressionDeps;
      })))($deps);
    }
    if ((("$sp$Types$CanonicalAst$Call" === ($$try0)[0]) && ("$sp$Types$CanonicalAst$ArgumentExpression" === (($$try0)[3])[0]))) {
      const $e1 = (($$try0)[3])[1];
      const $e0 = ($$try0)[2];
      return (($sp$Compiler$MakeCanonical$expressionDeps)($e1))((($sp$Compiler$MakeCanonical$expressionDeps)($e0))($deps));
    }
    if ((("$sp$Types$CanonicalAst$Call" === ($$try0)[0]) && ("$sp$Types$CanonicalAst$ArgumentMutable" === (($$try0)[3])[0]))) {
      const $e0 = ($$try0)[2];
      return (($sp$Compiler$MakeCanonical$expressionDeps)($e0))($deps);
    }
    if (("$sp$Types$CanonicalAst$If" === ($$try0)[0])) {
      const $args = ($$try0)[2];
      return (($sp$Compiler$MakeCanonical$expressionDeps)($args.false))((($sp$Compiler$MakeCanonical$expressionDeps)($args.true))((($sp$Compiler$MakeCanonical$expressionDeps)($args.condition))($deps)));
    }
    if (("$sp$Types$CanonicalAst$Try" === ($$try0)[0])) {
      const $patternsAndBodies = ($$try0)[3];
      const $e = ($$try0)[2];
      return ((($corelib$List$for)($patternsAndBodies))(((b$$) => {
        const $b = b$$.second;
        const $p = b$$.first;
        return (($d) => {
          return (($sp$Compiler$MakeCanonical$expressionDeps)($b))((($sp$Compiler$MakeCanonical$patternDeps)($p))($d));
        });
      })))((($sp$Compiler$MakeCanonical$expressionDeps)($e))($deps));
    }
    if (("$sp$Types$CanonicalAst$LetIn" === ($$try0)[0])) {
      const $expr = ($$try0)[2];
      const $valueDef = ($$try0)[1];
      return (($sp$Compiler$MakeCanonical$expressionDeps)($expr))((($sp$Compiler$MakeCanonical$expressionDeps)($valueDef.body))((($sp$Compiler$MakeCanonical$patternDeps)($valueDef.pattern))($deps)));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 193:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$MakeCanonical$initEnv = (($ro) => {
  return ({
    defsPath: $core$SPCore$Nil,
    maybeShorthandTarget: $corelib$Maybe$Nothing,
    nonRootValues: $corelib$Dict$empty,
    ro: $ro,
    tyvarRenames: $corelib$Dict$empty,
  });
});

const $sp$Compiler$MakeCanonical$insertParamNames = (($param) => {
  const $$try0 = $param;
  if (("$sp$Types$CanonicalAst$ParameterMutable" === ($$try0)[0])) {
    const $n = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($corelib$Dict$insert)($n))($pos);
  }
  if (("$sp$Types$CanonicalAst$ParameterPattern" === ($$try0)[0])) {
    const $pa = ($$try0)[1];
    return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($pa));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 264:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$MakeCanonical$translateConstructor = (($ro) => {
  return (($unionType) => {
    return (($unionUsr) => {
      return ((faArgs$$) => {
        const $faArgs = faArgs$$.second;
        const $name = (faArgs$$.first)[2];
        const $pos = (faArgs$$.first)[1];
        return (($constructors) => {
          return ((($corelib$Dict$member)($name))($constructors)
            ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(("constructor " + ($name + " is duplicate"))))($core$SPCore$Nil))
            : (($corelib$Result$onOk)((($caArgs) => {
              const $c = ({
                args: $caArgs,
                pos: $pos,
                type: ((($corelib$List$forReversed)($caArgs))((($ar) => {
                  return (($ty) => {
                    return (((($sp$Types$CanonicalAst$TypeFunction)($pos))($ar))(false))($ty);
                  });
                })))($unionType),
                typeUsr: $unionUsr,
              });
              return ($corelib$Result$Ok)(((($corelib$Dict$insert)($name))($c))($constructors));
            })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro)))($faArgs)));
        });
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToConstructorUsr = ($sp$Compiler$MakeCanonical$resolveToUsr)((($m) => {
  return $m.globalValues;
}));

const $sp$Compiler$MakeCanonical$translateNumber = (($constructor) => {
  return (($pos) => {
    return (($numberAsText) => {
      const $$try0 = (text_toNumber)($numberAsText);
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(("invalid number: `" + ($numberAsText + "`"))))((($core$SPCore$Cons)("TODO link to documentation on valid number formats"))($core$SPCore$Nil)));
      }
      if (("$corelib$Maybe$Just" === ($$try0)[0])) {
        const $n = ($$try0)[1];
        return ($corelib$Result$Ok)((($constructor)($pos))($n));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 628:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Types$FormattableAst$patternPos = (($pa) => {
  const $$try0 = $pa;
  if (("$sp$Types$FormattableAst$PatternAny" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralNumber" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralText" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternConstructor" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternList" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternListCons" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternRecord" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PatternTuple" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 161:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$MakeCanonical$translatePattern = (($ann) => {
  return (($env) => {
    return (($fa) => {
      const $$try0 = $fa;
      if ((("$sp$Types$FormattableAst$PatternAny" === ($$try0)[0]) && (true === ($$try0)[2]))) {
        const $s = ($$try0)[3];
        const $pos = ($$try0)[1];
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("This is the wrong place to use `@`"))($core$SPCore$Nil));
      }
      if ((("$sp$Types$FormattableAst$PatternAny" === ($$try0)[0]) && (false === ($$try0)[2]))) {
        const $maybeFaType = ($$try0)[4];
        const $name = ($$try0)[3];
        const $pos = ($$try0)[1];
        return ((((sp_equal)($corelib$Maybe$Nothing))($ann) && ((sp_not_equal)($corelib$Maybe$Nothing))($maybeFaType))
          ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Can't use annotations here"))($core$SPCore$Nil))
          : (($corelib$Result$onOk)((($maybeCaType) => {
            const $n = (((sp_equal)("_"))($name)
              ? $corelib$Maybe$Nothing
              : ($corelib$Maybe$Just)($name));
            return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$PatternAny)($pos))($n))($maybeCaType));
          })))((($corelib$Maybe$mapRes)((($sp$Compiler$MakeCanonical$translateType)($ann))($env.ro)))($maybeFaType)));
      }
      if (("$sp$Types$FormattableAst$PatternLiteralNumber" === ($$try0)[0])) {
        const $l = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ((($sp$Compiler$MakeCanonical$translateNumber)($sp$Types$CanonicalAst$PatternLiteralNumber))($pos))($l);
      }
      if (("$sp$Types$FormattableAst$PatternLiteralText" === ($$try0)[0])) {
        const $l = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$PatternLiteralText)($pos))($l));
      }
      if (("$sp$Types$FormattableAst$PatternConstructor" === ($$try0)[0])) {
        const $faArgs = ($$try0)[4];
        const $name = ($$try0)[3];
        const $maybeModule = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($corelib$Result$onOk)((($caArgs) => {
          return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$PatternConstructor)($pos))(((($sp$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro))($maybeModule))($name)))($caArgs));
        })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($faArgs));
      }
      if (("$sp$Types$FormattableAst$PatternList" === ($$try0)[0])) {
        const $fas = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $fold = (($pattern) => {
          return (($last) => {
            return ((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$cons))((($core$SPCore$Cons)($pattern))((($core$SPCore$Cons)($last))($core$SPCore$Nil)));
          });
        });
        return (($corelib$Result$onOk)((($cas) => {
          return ($corelib$Result$Ok)(((($corelib$List$forReversed)($cas))($fold))(((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$nil))($core$SPCore$Nil)));
        })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($fas));
        return null;
      }
      if (("$sp$Types$FormattableAst$PatternRecord" === ($$try0)[0])) {
        const $recordArgs = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (((sp_not_equal)($corelib$Maybe$Nothing))($recordArgs.extends)
          ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("can't use `with` inside patterns"))($core$SPCore$Nil))
          : ((() => {
            const $fold = ((maybePattern$$) => {
              const $maybePattern = maybePattern$$.second;
              const $name = (maybePattern$$.first)[2];
              const $p = (maybePattern$$.first)[1];
              return (($dict) => {
                return ((($corelib$Dict$member)($name))($dict)
                  ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)(("duplicate attribute name in pattern: " + $name)))($core$SPCore$Nil))
                  : ((() => {
                    const $$try1 = $maybePattern;
                    if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
                      return ($corelib$Result$Ok)(((($corelib$Dict$insert)($name))(((($sp$Types$CanonicalAst$PatternAny)($p))(($corelib$Maybe$Just)($name)))($corelib$Maybe$Nothing)))($dict));
                    }
                    if (("$corelib$Maybe$Just" === ($$try1)[0])) {
                      const $faPattern = ($$try1)[1];
                      return (($corelib$Result$map)((($caPattern) => {
                        return ((($corelib$Dict$insert)($name))($caPattern))($dict);
                      })))(((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))($faPattern));
                    }
                    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 393:24', (sp_toHuman)($$try1));
                  }))());
              });
            });
            return (($corelib$Result$map)((($x) => {
              return (($sp$Types$CanonicalAst$PatternRecord)($pos))($x);
            })))(((($corelib$List$foldlRes)($fold))($recordArgs.attrs))($corelib$Dict$empty));
          }))());
      }
      if (("$sp$Types$FormattableAst$PatternListCons" === ($$try0)[0])) {
        const $pas = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($corelib$Result$onOk)((($caPas) => {
          const $$try1 = ($corelib$List$reverse)($caPas);
          if (("$core$SPCore$Cons" === ($$try1)[0])) {
            const $rest = ($$try1)[2];
            const $last = ($$try1)[1];
            return ($corelib$Result$Ok)(((($corelib$List$for)($rest))((($item) => {
              return (($list) => {
                return ((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$cons))((($core$SPCore$Cons)($item))((($core$SPCore$Cons)($list))($core$SPCore$Nil)));
              });
            })))($last));
          }
          if (("$core$SPCore$Nil" === ($$try1)[0])) {
            return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("should not happen: empty cons pattern"))($core$SPCore$Nil));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 407:12', (sp_toHuman)($$try1));
        })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($pas));
      }
      if (("$sp$Types$FormattableAst$PatternTuple" === ($$try0)[0])) {
        const $fas = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = $fas;
        if ((("$core$SPCore$Cons" === ($$try1)[0]) && (("$core$SPCore$Cons" === (($$try1)[2])[0]) && ("$core$SPCore$Nil" === ((($$try1)[2])[2])[0])))) {
          const $fa2 = (($$try1)[2])[1];
          const $fa1 = ($$try1)[1];
          return ((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))((($sp$Types$FormattableAst$PatternRecord)($pos))(({
            attrs: (($core$SPCore$Cons)(({
              first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa1)))("first"),
              second: ($corelib$Maybe$Just)($fa1),
            })))((($core$SPCore$Cons)(({
              first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa2)))("second"),
              second: ($corelib$Maybe$Just)($fa2),
            })))($core$SPCore$Nil)),
            extends: $corelib$Maybe$Nothing,
          })));
        }
        if ((("$core$SPCore$Cons" === ($$try1)[0]) && (("$core$SPCore$Cons" === (($$try1)[2])[0]) && (("$core$SPCore$Cons" === ((($$try1)[2])[2])[0]) && ("$core$SPCore$Nil" === (((($$try1)[2])[2])[2])[0]))))) {
          const $fa3 = ((($$try1)[2])[2])[1];
          const $fa2 = (($$try1)[2])[1];
          const $fa1 = ($$try1)[1];
          return ((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))((($sp$Types$FormattableAst$PatternRecord)($pos))(({
            attrs: (($core$SPCore$Cons)(({
              first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa1)))("first"),
              second: ($corelib$Maybe$Just)($fa1),
            })))((($core$SPCore$Cons)(({
              first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa2)))("second"),
              second: ($corelib$Maybe$Just)($fa2),
            })))((($core$SPCore$Cons)(({
              first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa3)))("third"),
              second: ($corelib$Maybe$Just)($fa3),
            })))($core$SPCore$Nil))),
            extends: $corelib$Maybe$Nothing,
          })));
        }
        if (true) {
          return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("tuples can be only of size 2 or 3"))($core$SPCore$Nil));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 417:12', (sp_toHuman)($$try1));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 351:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$MakeCanonical$makeUpdateTarget = (($pos) => {
  return (($env) => {
    return (($maybeShorthandTarget) => {
      const $$try0 = (($corelib$Maybe$map)(($sp$Compiler$MakeCanonical$translateExpression)((Object.assign)({}, $env, ({
        maybeShorthandTarget: $corelib$Maybe$Nothing,
      })))))($maybeShorthandTarget);
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return ($corelib$Result$Ok)(({
          maybeName: $corelib$Maybe$Nothing,
          wrapper: $corelib$Basics$identity,
        }));
      }
      if ((("$corelib$Maybe$Just" === ($$try0)[0]) && ("$corelib$Result$Err" === (($$try0)[1])[0]))) {
        const $e = (($$try0)[1])[1];
        return ($corelib$Result$Err)($e);
      }
      if ((("$corelib$Maybe$Just" === ($$try0)[0]) && (("$corelib$Result$Ok" === (($$try0)[1])[0]) && ("$sp$Types$CanonicalAst$Variable" === ((($$try0)[1])[1])[0])))) {
        const $args = ((($$try0)[1])[1])[2];
        return ($corelib$Result$Ok)(({
          maybeName: ($corelib$Maybe$Just)($args),
          wrapper: $corelib$Basics$identity,
        }));
      }
      if ((("$corelib$Maybe$Just" === ($$try0)[0]) && ("$corelib$Result$Ok" === (($$try0)[1])[0]))) {
        const $expr = (($$try0)[1])[1];
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("NI { (expr) with ...} not yet implemented =("))($core$SPCore$Nil));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 641:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToValueRef = (($ro) => {
  return (($declaredInsideFunction) => {
    return (($maybeModule) => {
      return (($name) => {
        const $$try0 = (((($sp$Compiler$MakeCanonical$maybeForeignUsr)((($m) => {
          return $m.globalValues;
        })))($ro))($maybeModule))($name);
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $usr = ($$try0)[1];
          return ($sp$Types$CanonicalAst$RefRoot)($usr);
        }
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return ($declaredInsideFunction
            ? ($sp$Types$CanonicalAst$RefBlock)($name)
            : ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($ro.currentModule))($name)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 131:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateArgument = (($env) => {
  return (($faExpr) => {
    const $$try0 = $faExpr;
    if (("$sp$Types$FormattableAst$Mutable" === ($$try0)[0])) {
      const $attrPath = ($$try0)[3];
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($corelib$Dict$member)($name))($env.nonRootValues)
        ? ($corelib$Result$Ok)((($sp$Types$CanonicalAst$ArgumentMutable)($pos))(({
          attrPath: $attrPath,
          ref: ($sp$Types$CanonicalAst$RefBlock)($name),
        })))
        : (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("only values declared inside a function scope can be mutated!"))($core$SPCore$Nil)));
    }
    if (true) {
      return (($corelib$Result$map)($sp$Types$CanonicalAst$ArgumentExpression))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 685:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$MakeCanonical$translateAttrsRec = (($env) => {
  return (($faAttrs) => {
    return (($caAttrsAccum) => {
      const $$try0 = $faAttrs;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ($corelib$Result$Ok)($caAttrsAccum);
      }
      if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$Pos$At" === (($$try0)[1].first)[0]))) {
        const $faTail = ($$try0)[2];
        const $maybeAttrExpression = ($$try0)[1].second;
        const $attrName = (($$try0)[1].first)[2];
        const $pos = (($$try0)[1].first)[1];
        const $exprRes = ((() => {
          const $$try1 = $maybeAttrExpression;
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $faExpr = ($$try1)[1];
            return (($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr);
          }
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            const $declaredInsideFunction = (($corelib$Dict$member)($attrName))($env.nonRootValues);
            return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
              attrPath: $core$SPCore$Nil,
              ref: (((($sp$Compiler$MakeCanonical$resolveToValueRef)($env.ro))($declaredInsideFunction))($corelib$Maybe$Nothing))($attrName),
            })));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 665:16', (sp_toHuman)($$try1));
        }))();
        return (($corelib$Result$onOk)((($expr) => {
          return ((($sp$Compiler$MakeCanonical$translateAttrsRec)($env))($faTail))(((($corelib$Dict$insert)($attrName))($expr))($caAttrsAccum));
        })))($exprRes);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 659:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$MakeCanonical$notAllSeparators = (($f) => {
  return (($ls) => {
    const $$try0 = $ls;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return false;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $item = ($$try0)[1].second;
      const $sep = ($$try0)[1].first;
      return (($f)($sep)
        ? (($sp$Compiler$MakeCanonical$notAllSeparators)($f))($tail)
        : true);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 783:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$MakeCanonical$sameDirectionAs = (($a) => {
  return (($b) => {
    return (((sp_equal)($b.symbol))($a.symbol)
      ? true
      : ((() => {
        const $$try0 = $a.symbol;
        if ((">" === $$try0)) {
          return ((sp_equal)(">="))($b.symbol);
        }
        if ((">=" === $$try0)) {
          return ((sp_equal)(">"))($b.symbol);
        }
        if (("<" === $$try0)) {
          return ((sp_equal)("<="))($b.symbol);
        }
        if (("<=" === $$try0)) {
          return ((sp_equal)("<"))($b.symbol);
        }
        if (true) {
          return false;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 801:8', (sp_toHuman)($$try0));
      }))());
  });
});

const $sp$Compiler$MakeCanonical$makeBinop = (($pos) => {
  return (($left) => {
    return (($op) => {
      return (($right) => {
        const $$try0 = ({
          first: $left,
          second: $op.symbol,
          third: $right,
        });
        if (((">>" === $$try0.second) && ("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try0.third)[0]))) {
          const $rightExpr = ($$try0.third)[1];
          return ((($sp$Types$CanonicalAst$Call)($pos))($rightExpr))($left);
        }
        if ((("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try0.first)[0]) && ("<<" === $$try0.second))) {
          const $leftExpr = ($$try0.first)[1];
          return ((($sp$Types$CanonicalAst$Call)($pos))($leftExpr))($right);
        }
        if (true) {
          return ((($sp$Types$CanonicalAst$Call)($pos))(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Variable)($pos))(({
            attrPath: $core$SPCore$Nil,
            ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Types$Meta$spCoreUSR)($op.symbol)),
          }))))($right)))($left);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 855:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinopSepListRec = (($env) => {
  return (($pos) => {
    return (($leftAccum) => {
      return (($opsAndRight) => {
        const $$try0 = $opsAndRight;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return ($corelib$Result$Ok)($leftAccum);
        }
        if (("$core$SPCore$Cons" === ($$try0)[0])) {
          const $tail = ($$try0)[2];
          const $faRight = ($$try0)[1].second;
          const $op = ($$try0)[1].first;
          return (($corelib$Result$onOk)((($caRight) => {
            return (((($sp$Compiler$MakeCanonical$translateBinopSepListRec)($env))($pos))((((($sp$Compiler$MakeCanonical$makeBinop)($pos))(($sp$Types$CanonicalAst$ArgumentExpression)($leftAccum)))($op))($caRight)))($tail);
          })))((($sp$Compiler$MakeCanonical$translateArgument)($env))($faRight));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 839:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinopSepList_leftAssociative = (($env) => {
  return (($pos) => {
    return (($leftAccum) => {
      return (($opsAndRight) => {
        return (($corelib$Result$onOk)((($caLeftAccum) => {
          return (((($sp$Compiler$MakeCanonical$translateBinopSepListRec)($env))($pos))($caLeftAccum))($opsAndRight);
        })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($leftAccum));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative = (($env) => {
  return (($pos) => {
    return (($left) => {
      return (($opsAndRight) => {
        return (($corelib$Result$onOk)((($caLeft) => {
          const $$try0 = $opsAndRight;
          if (("$core$SPCore$Nil" === ($$try0)[0])) {
            return ($corelib$Result$Ok)($caLeft);
          }
          if (("$core$SPCore$Cons" === ($$try0)[0])) {
            const $tail = ($$try0)[2];
            const $right = ($$try0)[1].second;
            const $op = ($$try0)[1].first;
            return (($corelib$Result$onOk)((($caRight) => {
              return ($corelib$Result$Ok)((((($sp$Compiler$MakeCanonical$makeBinop)($pos))(($sp$Types$CanonicalAst$ArgumentExpression)($caLeft)))($op))(($sp$Types$CanonicalAst$ArgumentExpression)($caRight)));
            })))((((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($right))($tail));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 821:4', (sp_toHuman)($$try0));
        })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($left));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateSimpleBinop = (($env) => {
  return (($pos) => {
    return (($left) => {
      return (($op) => {
        return (($right) => {
          return (($corelib$Result$onOk)((($l) => {
            return (($corelib$Result$onOk)((($r) => {
              return ($corelib$Result$Ok)((((($sp$Compiler$MakeCanonical$makeBinop)($pos))($l))($op))($r));
            })))((($sp$Compiler$MakeCanonical$translateArgument)($env))($right));
          })))((($sp$Compiler$MakeCanonical$translateArgument)($env))($left));
        });
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinops = (($env) => {
  return (($pos) => {
    return (($group) => {
      return ((firstItem$$) => {
        const $firstTail = firstItem$$.second;
        const $firstItem = firstItem$$.first;
        const $$try0 = $firstTail;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return (($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem);
        }
        if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
          const $secondItem = ($$try0)[1].second;
          const $firstSep = ($$try0)[1].first;
          const $$try1 = $group;
          if (("$sp$Types$Op$Tuple" === ($$try1)[0])) {
            return (($corelib$Result$onOk)((($first) => {
              return (($corelib$Result$onOk)((($second) => {
                return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Record)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($second))(((($corelib$Dict$insert)("first"))($first))($corelib$Dict$empty))));
              })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($secondItem));
            })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem));
          }
          if (true) {
            return ((((($sp$Compiler$MakeCanonical$translateSimpleBinop)($env))($pos))($firstItem))($firstSep))($secondItem);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 714:12', (sp_toHuman)($$try1));
          return null;
        }
        if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Cons" === (($$try0)[2])[0]))) {
          const $thirdTail = (($$try0)[2])[2];
          const $thirdItem = (($$try0)[2])[1].second;
          const $secondSep = (($$try0)[2])[1].first;
          const $secondItem = ($$try0)[1].second;
          const $firstSep = ($$try0)[1].first;
          const $secondTail = ((sp_cons)($thirdTail))(({
            first: $secondSep,
            second: $thirdItem,
          }));
          const $$try1 = $group;
          if (("$sp$Types$Op$Comparison" === ($$try1)[0])) {
            return ((($sp$Compiler$MakeCanonical$notAllSeparators)(($sp$Compiler$MakeCanonical$sameDirectionAs)($firstSep)))($secondTail)
              ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("can't mix comparison ops with different direction"))($core$SPCore$Nil))
              : (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("NI compops expansion"))($core$SPCore$Nil)));
          }
          if (("$sp$Types$Op$Logical" === ($$try1)[0])) {
            return ((($sp$Compiler$MakeCanonical$notAllSeparators)((($x) => {
              return ((sp_equal)($firstSep))($x);
            })))($secondTail)
              ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Mixing `and` and `or` is ambiguous. Use parens!"))($core$SPCore$Nil))
              : (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail));
          }
          if (("$sp$Types$Op$Tuple" === ($$try1)[0])) {
            return (((sp_not_equal)($core$SPCore$Nil))($thirdTail)
              ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Tuples can't have more than 3 items, use a record instead."))($core$SPCore$Nil))
              : (($corelib$Result$onOk)((($first) => {
                return (($corelib$Result$onOk)((($second) => {
                  return (($corelib$Result$onOk)((($third) => {
                    return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Record)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("third"))($third))(((($corelib$Dict$insert)("second"))($second))(((($corelib$Dict$insert)("first"))($first))($corelib$Dict$empty)))));
                  })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($thirdItem));
                })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($secondItem));
              })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem)));
          }
          if (("$sp$Types$Op$Pipe" === ($$try1)[0])) {
            return ((($sp$Compiler$MakeCanonical$notAllSeparators)((($x) => {
              return ((sp_equal)($firstSep))($x);
            })))($secondTail)
              ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Mixing pipes is ambigous. Use parens."))($core$SPCore$Nil))
              : (((sp_equal)($sp$Types$Op$Right))($firstSep.associativity)
                ? (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail)
                : (((($sp$Compiler$MakeCanonical$translateBinopSepList_leftAssociative)($env))($pos))($firstItem))($firstTail)));
          }
          if (("$sp$Types$Op$Mutop" === ($$try1)[0])) {
            return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("mutops can't be chained"))($core$SPCore$Nil));
          }
          if (true) {
            return (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 732:12', (sp_toHuman)($$try1));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 709:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateParameter = (($env) => {
  return (($mutable) => {
    return (($faParam) => {
      const $$try0 = ({
        first: $faParam,
        second: $mutable,
      });
      if ((("$sp$Types$FormattableAst$PatternAny" === ($$try0.first)[0]) && ((false === ($$try0.first)[2]) && (("$corelib$Maybe$Nothing" === (($$try0.first)[4])[0]) && (true === $$try0.second))))) {
        const $name = ($$try0.first)[3];
        const $pos = ($$try0.first)[1];
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$ParameterMutable)($pos))($name));
      }
      if ((("$sp$Types$FormattableAst$PatternAny" === ($$try0.first)[0]) && (true === ($$try0.first)[2]))) {
        const $name = ($$try0.first)[3];
        const $pos = ($$try0.first)[1];
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Can't annotate this. =("))((($core$SPCore$Cons)("TODO link to rationale for forbidding annotations"))($core$SPCore$Nil)));
      }
      if (true) {
        return (($corelib$Result$onOk)((($caPattern) => {
          return ($corelib$Result$Ok)(($sp$Types$CanonicalAst$ParameterPattern)($caPattern));
        })))(((($sp$Compiler$MakeCanonical$translatePattern)($corelib$Maybe$Nothing))($env))($faParam));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 445:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$MakeCanonical$translateExpression = (($env) => {
  return (($faExpr) => {
    const $$try0 = $faExpr;
    if (("$sp$Types$FormattableAst$LiteralNumber" === ($$try0)[0])) {
      const $str = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($sp$Compiler$MakeCanonical$translateNumber)($sp$Types$CanonicalAst$LiteralNumber))($pos))($str);
    }
    if (("$sp$Types$FormattableAst$LiteralText" === ($$try0)[0])) {
      const $v = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LiteralText)($pos))($v));
    }
    if (("$sp$Types$FormattableAst$PrefixBinop" === ($$try0)[0])) {
      const $symbol = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
        attrPath: $core$SPCore$Nil,
        ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)($symbol)),
      })));
    }
    if (("$sp$Types$FormattableAst$Variable" === ($$try0)[0])) {
      const $attrs = ($$try0)[4];
      const $name = ($$try0)[3];
      const $maybeModule = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $declaredInsideFunction = (($corelib$Dict$member)($name))($env.nonRootValues);
      return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
        attrPath: $attrs,
        ref: (((($sp$Compiler$MakeCanonical$resolveToValueRef)($env.ro))($declaredInsideFunction))($maybeModule))($name),
      })));
      return null;
    }
    if (("$sp$Types$FormattableAst$Constructor" === ($$try0)[0])) {
      const $name = ($$try0)[3];
      const $maybeModule = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Constructor)($pos))(((($sp$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro))($maybeModule))($name)));
    }
    if (("$sp$Types$FormattableAst$Mutable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($name + ": mutable values can be used only as arguments for function or mutation operators")))($core$SPCore$Nil));
    }
    if (("$sp$Types$FormattableAst$RecordShorthand" === ($$try0)[0])) {
      const $attrPath = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $$try1 = $env.maybeShorthandTarget;
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Record update shorthands must be used inside a record update such as"))((($core$SPCore$Cons)(("    { aRecord with anAttribute = doSomethingWith ." + ((($corelib$Text$join)("."))($attrPath) + " }"))))((($core$SPCore$Cons)("but we are not inside a record update!"))($core$SPCore$Nil))));
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $shorthandTarget = ($$try1)[1];
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))((Object.assign)({}, $shorthandTarget, ({
          attrPath: ($corelib$List$concat)((($core$SPCore$Cons)($shorthandTarget.attrPath))((($core$SPCore$Cons)($attrPath))($core$SPCore$Nil))),
        }))));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 539:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$FormattableAst$Lambda" === ($$try0)[0])) {
      const $faBody = ($$try0)[4];
      const $mutable = ($$try0)[3];
      const $faParam = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Result$onOk)((($caParam) => {
        const $localEnv = (Object.assign)({}, $env, ({
          nonRootValues: (($sp$Compiler$MakeCanonical$insertParamNames)($caParam))($env.nonRootValues),
        }));
        return (($corelib$Result$onOk)((($caBody) => {
          return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Lambda)($pos))($caParam))($caBody));
        })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($localEnv))($faBody));
      })))(((($sp$Compiler$MakeCanonical$translateParameter)($env))($mutable))($faParam));
    }
    if (("$sp$Types$FormattableAst$FunctionCall" === ($$try0)[0])) {
      const $arguments = ($$try0)[3];
      const $reference = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $fold = (($argument) => {
        return (($refAccum) => {
          return ((($sp$Types$CanonicalAst$Call)($pos))($refAccum))($argument);
        });
      });
      return (($corelib$Result$onOk)((($ref) => {
        return (($corelib$Result$onOk)((($args) => {
          return ($corelib$Result$Ok)(((($corelib$List$for)($args))($fold))($ref));
        })))((($corelib$List$mapRes)(($sp$Compiler$MakeCanonical$translateArgument)($env)))($arguments));
      })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($reference));
      return null;
    }
    if (("$sp$Types$FormattableAst$If" === ($$try0)[0])) {
      const $true = ($$try0)[2].true;
      const $isCompact = ($$try0)[2].isCompact;
      const $false = ($$try0)[2].false;
      const $condition = ($$try0)[2].condition;
      const $pos = ($$try0)[1];
      return (($corelib$Result$onOk)((($c) => {
        return (($corelib$Result$onOk)((($t) => {
          return (($corelib$Result$onOk)((($f) => {
            return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$If)($pos))(({
              condition: $c,
              false: $f,
              true: $t,
            })));
          })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($false));
        })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($true));
      })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($condition));
    }
    if (("$sp$Types$FormattableAst$Unop" === ($$try0)[0])) {
      const $faOperand = ($$try0)[3];
      const $op = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Result$onOk)((($caOperand) => {
        return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Variable)($pos))(({
          attrPath: $core$SPCore$Nil,
          ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)($op.symbol)),
        }))))(($sp$Types$CanonicalAst$ArgumentExpression)($caOperand)));
      })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faOperand));
    }
    if (("$sp$Types$FormattableAst$Binop" === ($$try0)[0])) {
      const $sepList = ($$try0)[3];
      const $group = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (((($sp$Compiler$MakeCanonical$translateBinops)($env))($pos))($group))($sepList);
    }
    if (("$sp$Types$FormattableAst$Record" === ($$try0)[0])) {
      const $faArgs = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$Result$onOk)((($caUpdateTarget) => {
        return (($corelib$Result$onOk)((($caAttrs) => {
          return ($corelib$Result$Ok)(($caUpdateTarget.wrapper)(((($sp$Types$CanonicalAst$Record)($pos))($caUpdateTarget.maybeName))($caAttrs)));
        })))(((($sp$Compiler$MakeCanonical$translateAttrsRec)((Object.assign)({}, $env, ({
          maybeShorthandTarget: $caUpdateTarget.maybeName,
        }))))($faArgs.attrs))($corelib$Dict$empty));
      })))(((($sp$Compiler$MakeCanonical$makeUpdateTarget)($pos))($env))($faArgs.extends));
    }
    if (("$sp$Types$FormattableAst$List" === ($$try0)[0])) {
      const $faItems = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $cons = (($item) => {
        return (($list) => {
          return ((($sp$Types$CanonicalAst$Call)($pos))(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Constructor)($pos))($sp$Compiler$CoreTypes$cons)))(($sp$Types$CanonicalAst$ArgumentExpression)($item))))(($sp$Types$CanonicalAst$ArgumentExpression)($list));
        });
      });
      return (($corelib$Result$onOk)((($es) => {
        return ($corelib$Result$Ok)(((($corelib$List$forReversed)($es))($cons))((($sp$Types$CanonicalAst$Constructor)($pos))($sp$Compiler$CoreTypes$nil)));
      })))((($corelib$List$mapRes)(($sp$Compiler$MakeCanonical$translateExpression)($env)))($faItems));
      return null;
    }
    if (("$sp$Types$FormattableAst$Try" === ($$try0)[0])) {
      const $fa = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $translatePatternAndStatements = ((faPattern$$) => {
        const $faStatements = faPattern$$.second;
        const $faPattern = faPattern$$.first;
        return (($corelib$Result$onOk)((($caPattern) => {
          return (($corelib$Result$onOk)((($block) => {
            return ($corelib$Result$Ok)(({
              first: $caPattern,
              second: $block,
            }));
          })))((($sp$Compiler$MakeCanonical$translateStatementBlock)((Object.assign)({}, $env, ({
            nonRootValues: (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($caPattern)))($env.nonRootValues),
          }))))($faStatements));
        })))(((($sp$Compiler$MakeCanonical$translatePattern)($corelib$Maybe$Nothing))($env))($faPattern));
      });
      return (($corelib$Result$onOk)((($caValue) => {
        return (($corelib$Result$onOk)((($caPatternsAndStatements) => {
          return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Try)($pos))($caValue))($caPatternsAndStatements));
        })))((($corelib$List$mapRes)($translatePatternAndStatements))($fa.patterns));
      })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($fa.value));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 506:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$MakeCanonical$translateStatementBlock = (($env) => {
  return (($stats) => {
    const $$try0 = $stats;
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$FormattableAst$TypeAlias" === (($$try0)[1])[0]))) {
      const $fa = (($$try0)[1])[1];
      const pos$$ = $fa.name;
      const $pos = (pos$$)[1];
      return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Aliases can be declared only in the root scope"))($core$SPCore$Nil));
      return null;
    }
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$FormattableAst$UnionDef" === (($$try0)[1])[0]))) {
      const $fa = (($$try0)[1])[2];
      const $pos = (($$try0)[1])[1];
      return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Types can be declared only in the root scope"))($core$SPCore$Nil));
    }
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Constructor)($sp$Types$Pos$G))($sp$Compiler$CoreTypes$noneValue));
    }
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try0)[1])[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0])))) {
      const $faExpr = (($$try0)[1])[2];
      const $pos = (($$try0)[1])[1];
      return (($corelib$Result$onOk)((($e) => {
        return ($corelib$Result$Ok)($e);
      })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr));
    }
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$FormattableAst$Evaluation" === (($$try0)[1])[0]))) {
      const $tail = ($$try0)[2];
      const $faExpr = (($$try0)[1])[2];
      const $pos = (($$try0)[1])[1];
      const $valueDef = ({
        body: (($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($pos))($faExpr)))($core$SPCore$Nil),
        mutable: false,
        nonFn: $core$SPCore$Nil,
        pattern: (((($sp$Types$FormattableAst$PatternAny)($sp$Types$Pos$G))(false))("_"))($corelib$Maybe$Nothing),
      });
      return (($corelib$Result$onOk)((($d) => {
        return (($corelib$Result$onOk)((($tailBlockExpression) => {
          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LetIn)($d))($tailBlockExpression));
        })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($tail));
      })))(((($sp$Compiler$MakeCanonical$translateDefinition)(false))($env))($valueDef));
      return null;
    }
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$FormattableAst$Definition" === (($$try0)[1])[0]))) {
      const $tail = ($$try0)[2];
      const $fa = (($$try0)[1])[2];
      const $pos = (($$try0)[1])[1];
      return (($corelib$Result$onOk)((($d) => {
        return (($corelib$Result$onOk)((($tailBlockExpression) => {
          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LetIn)($d))($tailBlockExpression));
        })))((($sp$Compiler$MakeCanonical$translateStatementBlock)((Object.assign)({}, $env, ({
          nonRootValues: (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($d.pattern)))($env.nonRootValues),
        }))))($tail));
      })))(((($sp$Compiler$MakeCanonical$translateDefinition)(false))($env))($fa));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 464:4', (sp_toHuman)($$try0));
  });
});

const $sp$Types$CanonicalAst$patternPos = (($pa) => {
  const $$try0 = $pa;
  if (("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0])) {
    const $n = ($$try0)[2];
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
    const $ps = ($$try0)[3];
    const $path = ($$try0)[2];
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
    const $ps = ($$try0)[2];
    const $p = ($$try0)[1];
    return $p;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 202:4', (sp_toHuman)($$try0));
});

const $sp$Types$Pos$start = (($pos) => {
  const $$try0 = $pos;
  if (("$sp$Types$Pos$P" === ($$try0)[0])) {
    const $e = ($$try0)[3];
    const $s = ($$try0)[2];
    const $m = ($$try0)[1];
    return $s;
  }
  if (true) {
    return 0;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 29:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$MakeCanonical$translateDefinition = (($isRoot) => {
  return (($env) => {
    return (($fa) => {
      const $dict = ({
        attr: "$",
        obj: ({
          $: (sp_clone)($env.tyvarRenames),
        }),
      });
      const $renameTyvar = (($pos) => {
        return (($faName) => {
          const $$try0 = (($corelib$Dict$get)($faName))((sp_clone)(($dict.obj)[$dict.attr]));
          if (("$corelib$Maybe$Just" === ($$try0)[0])) {
            const $n = ($$try0)[1];
            return $n;
          }
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            const $n = ((text_fromNumber)(($sp$Types$Pos$start)($pos)) + $faName);
            (($dict.obj)[$dict.attr] = ((($corelib$Dict$insert)($faName))($n))((sp_clone)(($dict.obj)[$dict.attr])), null);
            return $n;
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 287:8', (sp_toHuman)($$try0));
        });
      });
      return (($corelib$Result$onOk)((($pattern) => {
        const $nonRootValues1 = ($isRoot
          ? $env.nonRootValues
          : (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($pattern)))($env.nonRootValues));
        const $localEnv0 = (Object.assign)({}, $env, ({
          defsPath: ((sp_cons)($env.defsPath))($pattern),
          nonRootValues: $nonRootValues1,
          tyvarRenames: (sp_clone)(($dict.obj)[$dict.attr]),
        }));
        const $updNonFn = (($tyvarName) => {
          return (($nonFn) => {
            const $$try0 = (($corelib$Dict$get)($tyvarName))($localEnv0.tyvarRenames);
            if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
              return (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$CanonicalAst$patternPos)($pattern)))((($core$SPCore$Cons)("non fn on variable that's not in the annotation"))($core$SPCore$Nil));
            }
            if (("$corelib$Maybe$Just" === ($$try0)[0])) {
              const $tr = ($$try0)[1];
              return ($corelib$Result$Ok)(((($corelib$Dict$insert)($tr))(null))($nonFn));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 311:8', (sp_toHuman)($$try0));
          });
        });
        return (($corelib$Result$onOk)((($nonFn) => {
          return (($corelib$Result$onOk)((($body) => {
            const $deps = ($isRoot
              ? (($sp$Compiler$MakeCanonical$expressionDeps)($body))((($sp$Compiler$MakeCanonical$patternDeps)($pattern))($sp$Compiler$MakeCanonical$deps_init))
              : $sp$Compiler$MakeCanonical$deps_init);
            return ($corelib$Result$Ok)(({
              body: $body,
              directConsDeps: $deps.cons,
              directTypeDeps: $deps.types,
              directValueDeps: $deps.values,
              mutable: $fa.mutable,
              native: false,
              nonFn: $nonFn,
              parentDefinitions: $env.defsPath,
              pattern: $pattern,
            }));
          })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($localEnv0))($fa.body));
        })))(((($corelib$List$foldlRes)($updNonFn))($fa.nonFn))($corelib$Dict$empty));
      })))(((($sp$Compiler$MakeCanonical$translatePattern)(($corelib$Maybe$Just)($renameTyvar)))($env))($fa.pattern));
    });
  });
});

const $sp$Types$FormattableAst$expressionPos = (($expr) => {
  const $$try0 = $expr;
  if (("$sp$Types$FormattableAst$LiteralText" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$LiteralNumber" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Variable" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Constructor" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Mutable" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$PrefixBinop" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Lambda" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$FunctionCall" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Binop" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Unop" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$If" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Try" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$Record" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$RecordShorthand" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$List" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 141:4', (sp_toHuman)($$try0));
});

const $sp$Types$Pos$drop = (($x) => {
  const a$$ = $x;
  const $a = (a$$)[2];
  const $pos = (a$$)[1];
  return $a;
});

const $sp$Compiler$MakeCanonical$insertRootStatement = (($ro) => {
  return (($faStatement) => {
    return (($caModule) => {
      const $$try0 = $faStatement;
      if (("$sp$Types$FormattableAst$Evaluation" === ($$try0)[0])) {
        const $expr = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$FormattableAst$expressionPos)($expr)))((($core$SPCore$Cons)("Root Evaluations don't really do much =|"))($core$SPCore$Nil));
      }
      if (("$sp$Types$FormattableAst$Definition" === ($$try0)[0])) {
        const $fa = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($corelib$Result$onOk)((($def) => {
          return ($def.mutable
            ? (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$CanonicalAst$patternPos)($def.pattern)))((($core$SPCore$Cons)("Mutable values can be declared only inside functions."))($core$SPCore$Nil))
            : ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
              valueDefs: ((($corelib$Dict$insert)($def.pattern))($def))($caModule.valueDefs),
            }))));
        })))(((($sp$Compiler$MakeCanonical$translateDefinition)(true))(($sp$Compiler$MakeCanonical$initEnv)($ro)))($fa));
      }
      if (("$sp$Types$FormattableAst$TypeAlias" === ($$try0)[0])) {
        const $fa = ($$try0)[1];
        const name$$ = $fa.name;
        const $name = (name$$)[2];
        const $pos = (name$$)[1];
        return (((($corelib$Dict$member)($name))($caModule.aliasDefs) || (($corelib$Dict$member)($name))($caModule.unionDefs))
          ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($name + " declared twice!")))($core$SPCore$Nil))
          : (($corelib$Result$onOk)((($type) => {
            const $aliasDef = ({
              args: $fa.args,
              directTypeDeps: (($sp$Compiler$MakeCanonical$typeDeps)($type))($corelib$Set$empty),
              type: $type,
              usr: (($sp$Types$Meta$USR)($ro.currentModule))(($sp$Types$Pos$drop)($fa.name)),
            });
            return ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
              aliasDefs: ((($corelib$Dict$insert)($name))($aliasDef))($caModule.aliasDefs),
            })));
          })))(((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro))($fa.ty)));
        return null;
      }
      if (("$sp$Types$FormattableAst$UnionDef" === ($$try0)[0])) {
        const $fa = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (((($corelib$Dict$member)($fa.name))($caModule.aliasDefs) || (($corelib$Dict$member)($fa.name))($caModule.unionDefs))
          ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($fa.name + " declared twice!")))($core$SPCore$Nil))
          : ((() => {
            const $usr = (($sp$Types$Meta$USR)($ro.currentModule))($fa.name);
            const $type = ((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))((($corelib$List$map)(($sp$Types$CanonicalAst$TypeVariable)($pos)))($fa.args));
            return (($corelib$Result$onOk)((($constructors) => {
              const $unionDef = ({
                args: $fa.args,
                constructors: $constructors,
                directTypeDeps: ((($corelib$Dict$for)($constructors))((($k) => {
                  return (($c) => {
                    return (($corelib$List$for)($c.args))($sp$Compiler$MakeCanonical$typeDeps);
                  });
                })))($corelib$Set$empty),
                usr: $usr,
              });
              return ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
                unionDefs: ((($corelib$Dict$insert)($fa.name))($unionDef))($caModule.unionDefs),
              })));
            })))(((($corelib$List$foldlRes)(((($sp$Compiler$MakeCanonical$translateConstructor)($ro))($type))($usr)))($fa.constructors))($corelib$Dict$empty));
          }))());
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 1002:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Types$CanonicalAst$initModule = (($asText) => {
  return (($umr) => {
    return ({
      aliasDefs: $corelib$Dict$empty,
      asText: $asText,
      umr: $umr,
      unionDefs: $corelib$Dict$empty,
      valueDefs: $corelib$Dict$empty,
    });
  });
});

const $sp$Compiler$MakeCanonical$translateModule = (($ro) => {
  return (($asText) => {
    return (($umr) => {
      return (($faModule) => {
        (sp_benchStart)(null);
        const $module = (($sp$Types$CanonicalAst$initModule)($asText))($umr);
        return ((($corelib$Basics$btw)(sp_benchStop))("translateModule"))(((($corelib$List$foldlRes)(($sp$Compiler$MakeCanonical$insertRootStatement)($ro)))($faModule))($module));
      });
    });
  });
});

const $sp$SPLib$Parser$andThen = (($chainedParser) => {
  return (($firstParser) => {
    return (($re0) => {
      return (($readState) => {
        const $$try0 = (($firstParser)($re0))($readState);
        if (("$sp$SPLib$Parser$Accepted" === ($$try0.second)[0])) {
          const $a = ($$try0.second)[2];
          const $nextReadState = ($$try0.second)[1];
          const $re1 = $$try0.first;
          return ((($chainedParser)($a))($re1))($nextReadState);
        }
        if (("$sp$SPLib$Parser$Rejected" === ($$try0.second)[0])) {
          const $re1 = $$try0.first;
          return ({
            first: $re1,
            second: $sp$SPLib$Parser$Rejected,
          });
        }
        if (("$sp$SPLib$Parser$Aborted" === ($$try0.second)[0])) {
          const $e = ($$try0.second)[2];
          const $rs = ($$try0.second)[1];
          const $re1 = $$try0.first;
          return ({
            first: $re1,
            second: (($sp$SPLib$Parser$Aborted)($rs))($e),
          });
        }
        (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 85:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$Parser$andThen = $sp$SPLib$Parser$andThen;

const $sp$SPLib$Parser$consumeOne = (($rejections) => {
  return (($readState) => {
    const $$try0 = $readState;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return ({
        first: ((sp_cons)($rejections))($readState),
        second: $sp$SPLib$Parser$Rejected,
      });
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $nextState = ($$try0)[2];
      const $token = ($$try0)[1];
      return ({
        first: $rejections,
        second: (($sp$SPLib$Parser$Accepted)($nextState))($token),
      });
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 69:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$Parser$oneToken = $sp$SPLib$Parser$consumeOne;

const $sp$SPLib$Parser$accept = (($a) => {
  return (($rejections) => {
    return (($readState) => {
      return ({
        first: $rejections,
        second: (($sp$SPLib$Parser$Accepted)($readState))($a),
      });
    });
  });
});

const $sp$SPLib$Parser$reject = (($rejections) => {
  return (($readState) => {
    return ({
      first: ((sp_cons)($rejections))($readState),
      second: $sp$SPLib$Parser$Rejected,
    });
  });
});

const $sp$Compiler$Parser$kind = (($targetKind) => {
  return (($sp$Compiler$Parser$andThen)((($token) => {
    const k$$ = $token;
    const $k = (k$$)[3];
    return (((sp_equal)($k))($targetKind)
      ? ($sp$SPLib$Parser$accept)($token)
      : $sp$SPLib$Parser$reject);
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$discardFirst = (($a) => {
  return (($b) => {
    return (($sp$Compiler$Parser$andThen)((() => {
      return $b;
    })))($a);
  });
});

const $sp$SPLib$Parser$thenWithDefault = (($fallbackParser) => {
  return (($chainedParser) => {
    return (($firstParser) => {
      return (($re0) => {
        return (($readState) => {
          const $$try0 = (($firstParser)($re0))($readState);
          if (("$sp$SPLib$Parser$Aborted" === ($$try0.second)[0])) {
            const $reason = ($$try0.second)[2];
            const $rs = ($$try0.second)[1];
            const $re1 = $$try0.first;
            return ({
              first: $re1,
              second: (($sp$SPLib$Parser$Aborted)($rs))($reason),
            });
          }
          if (("$sp$SPLib$Parser$Rejected" === ($$try0.second)[0])) {
            const $re1 = $$try0.first;
            return (($fallbackParser)($re1))($readState);
          }
          if (("$sp$SPLib$Parser$Accepted" === ($$try0.second)[0])) {
            const $a = ($$try0.second)[2];
            const $nextReadState = ($$try0.second)[1];
            const $re1 = $$try0.first;
            return ((($chainedParser)($a))($re1))($nextReadState);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 100:4', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $sp$SPLib$Parser$zeroOrMore = (($p) => {
  return ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)($core$SPCore$Nil)))((($head) => {
    return (($sp$SPLib$Parser$andThen)((($tail) => {
      return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))($head));
    })))(($sp$SPLib$Parser$zeroOrMore)($p));
  })))($p);
});

const $sp$Compiler$Parser$oomSeparatedBy = (($sep) => {
  return (($pa) => {
    return (($sp$Compiler$Parser$andThen)((($head) => {
      return (($sp$Compiler$Parser$andThen)((($tail) => {
        return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))($head));
      })))(($sp$SPLib$Parser$zeroOrMore)((($sp$Compiler$Parser$discardFirst)($sep))($pa)));
    })))($pa);
  });
});

const $sp$Compiler$Parser$defop = (($sp$Compiler$Parser$andThen)((($token) => {
  const $$try0 = $token;
  if ((("$sp$Types$Token$Token" === ($$try0)[0]) && ("$sp$Types$Token$Defop" === (($$try0)[3])[0]))) {
    const $arg = (($$try0)[3])[1];
    return ($sp$SPLib$Parser$accept)($arg);
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 194:4', (sp_toHuman)($$try0));
})))($sp$Compiler$Parser$oneToken);

const $sp$SPLib$Parser$here = (($rejections) => {
  return (($readState) => {
    return ({
      first: $rejections,
      second: (($sp$SPLib$Parser$Accepted)($readState))($readState),
    });
  });
});

const $sp$Compiler$Parser$here = (($sp$Compiler$Parser$andThen)((($tokens) => {
  return ($sp$SPLib$Parser$accept)(((() => {
    const $$try0 = $tokens;
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$Token$Token" === (($$try0)[1])[0]))) {
      const $rest = ($$try0)[2];
      const $end = (($$try0)[1])[3];
      const $start = (($$try0)[1])[2];
      const $mod = (($$try0)[1])[1];
      return $start;
    }
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return 0;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 47:9', (sp_toHuman)($$try0));
  }))());
})))($sp$SPLib$Parser$here);

const $sp$SPLib$Parser$surroundWith = (($left) => {
  return (($right) => {
    return (($parser) => {
      return (($sp$SPLib$Parser$andThen)((() => {
        return (($sp$SPLib$Parser$andThen)((($p) => {
          return (($sp$SPLib$Parser$andThen)((() => {
            return ($sp$SPLib$Parser$accept)($p);
          })))($right);
        })))($parser);
      })))($left);
    });
  });
});

const $sp$Compiler$Parser$surroundStrict = (($left) => {
  return (($right) => {
    return (($sp$SPLib$Parser$surroundWith)(($sp$Compiler$Parser$kind)($left)))(($sp$Compiler$Parser$kind)($right));
  });
});

const $sp$Compiler$Parser$block = (($sp$Compiler$Parser$surroundStrict)($sp$Types$Token$BlockStart))($sp$Types$Token$BlockEnd);

const $sp$Compiler$Parser$sib = ($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine));

const $sp$SPLib$Parser$oneOf = (($ps) => {
  return (($rejections) => {
    return (($readState) => {
      const $$try0 = $ps;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ({
          first: $rejections,
          second: $sp$SPLib$Parser$Rejected,
        });
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $tailParsers = ($$try0)[2];
        const $headParser = ($$try0)[1];
        const $$try1 = (($headParser)($rejections))($readState);
        if (("$sp$SPLib$Parser$Rejected" === ($$try1.second)[0])) {
          const $re1 = $$try1.first;
          return ((($sp$SPLib$Parser$oneOf)($tailParsers))($re1))($readState);
        }
        if (true) {
          const $acceptedOrAborted = $$try1;
          return $acceptedOrAborted;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 147:12', (sp_toHuman)($$try1));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 142:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$Parser$inlineOrBelowOrIndented = (($p) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)($p)))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)($p)))((($core$SPCore$Cons)($p))($core$SPCore$Nil))));
});

const $sp$Compiler$Parser$binaryOperators = (($group) => {
  return (($sp$Compiler$Parser$andThen)(((e$$) => {
    const $k = (e$$)[3];
    const $e = (e$$)[2];
    const $s = (e$$)[1];
    const $$try0 = $k;
    if (("$sp$Types$Token$Binop" === ($$try0)[0])) {
      const $op = ($$try0)[1];
      return (((sp_equal)($group))($op.precedence)
        ? ($sp$SPLib$Parser$accept)($op)
        : $sp$SPLib$Parser$reject);
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1228:4', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$pos = (($env) => {
  return (($start) => {
    return (($end) => {
      return ($env.stripLocations
        ? $sp$Types$Pos$T
        : ((($sp$Types$Pos$P)($env.moduleName))($start))($end));
    });
  });
});

const $sp$Compiler$Parser$sepListAtSep = (($sep) => {
  return (($item) => {
    return (($sp$Compiler$Parser$andThen)((($sep0) => {
      const $theParserStillSucks = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$sepListAtItem)($sep))($item))))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)((($sp$Compiler$Parser$sepListAtItem)($sep))($item))))((($core$SPCore$Cons)((($sp$Compiler$Parser$sepListAtItem)($sep))($item)))($core$SPCore$Nil))));
      return (($sp$Compiler$Parser$andThen)(((item0$$) => {
        const $tail = item0$$.second;
        const $item0 = item0$$.first;
        return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))(({
          first: $sep0,
          second: $item0,
        })));
      })))($theParserStillSucks);
    })))($sep);
  });
});

const $sp$Compiler$Parser$sepListAtItem = (($sep) => {
  return (($item) => {
    return (($sp$Compiler$Parser$andThen)((($item0) => {
      const $theParserStillSucks = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$sepListAtSep)($sep))($item))))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)((($sp$Compiler$Parser$sepListAtSep)($sep))($item))))((($core$SPCore$Cons)((($sp$Compiler$Parser$sepListAtSep)($sep))($item)))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($core$SPCore$Nil)))($core$SPCore$Nil)))));
      return (($sp$Compiler$Parser$andThen)((($sepsAndItems) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $item0,
          second: $sepsAndItems,
        }));
      })))($theParserStillSucks);
    })))($item);
  });
});

const $sp$Compiler$Parser$sepList = $sp$Compiler$Parser$sepListAtItem;

const $sp$Compiler$Parser$binopsOr = (($env) => {
  return (($group) => {
    return (($higher) => {
      return (($sp$Compiler$Parser$andThen)((($start) => {
        return (($sp$Compiler$Parser$andThen)(((head$$) => {
          const $sepTail = head$$.second;
          const $head = head$$.first;
          return (($sp$Compiler$Parser$andThen)((($end) => {
            return (((sp_equal)($core$SPCore$Nil))($sepTail)
              ? ($sp$SPLib$Parser$accept)($head)
              : ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Binop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($group))(({
                first: $head,
                second: $sepTail,
              }))));
          })))($sp$Compiler$Parser$here);
        })))((($sp$Compiler$Parser$sepList)(($sp$Compiler$Parser$binaryOperators)($group)))($higher));
      })))($sp$Compiler$Parser$here);
    });
  });
});

const $sp$Compiler$Parser$discardSecond = (($a) => {
  return (($b) => {
    return (($sp$Compiler$Parser$andThen)((($aa) => {
      return (($sp$Compiler$Parser$andThen)((() => {
        return ($sp$SPLib$Parser$accept)($aa);
      })))($b);
    })))($a);
  });
});

const $sp$SPLib$Parser$tuple2 = (($pa) => {
  return (($pb) => {
    return (($sp$SPLib$Parser$andThen)((($a) => {
      return (($sp$SPLib$Parser$andThen)((($b) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $a,
          second: $b,
        }));
      })))($pb);
    })))($pa);
  });
});

const $sp$SPLib$Parser$oneOrMore = (($p) => {
  return (($sp$SPLib$Parser$tuple2)($p))(($sp$SPLib$Parser$zeroOrMore)($p));
});

const $sp$Compiler$Parser$lambdaBody = (($env) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)(((h$$) => {
    const $t = h$$.second;
    const $h = h$$.first;
    return ($sp$SPLib$Parser$accept)(((sp_cons)($t))($h));
  })))(($sp$SPLib$Parser$oneOrMore)(($sp$Compiler$Parser$sib)(($sp$Compiler$Parser$statement)($env))))))((($core$SPCore$Cons)(($sp$Compiler$Parser$inlineStatementOrBlock)($env)))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$lambdaParser = (($env) => {
  return (($mutable) => {
    return (($pa) => {
      return (($sp$Compiler$Parser$andThen)((($body) => {
        return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$Lambda)(($sp$Types$FormattableAst$patternPos)($pa)))($pa))($mutable))($body));
      })))(($sp$Compiler$Parser$lambdaBody)($env));
    });
  });
});

const $sp$SPLib$Parser$maybe = (($p) => {
  return ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)($corelib$Maybe$Nothing)))((($x) => {
    return ($sp$SPLib$Parser$accept)(($corelib$Maybe$Just)($x));
  })))($p);
});

const $sp$Compiler$Parser$rawList = (($item) => {
  const $sibsep = ($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)($sp$Types$Token$Comma));
  return (($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)($sibsep)))((($sp$Compiler$Parser$oomSeparatedBy)($sibsep))($item));
});

const $sp$Compiler$Parser$surroundMultiline = (($left) => {
  return (($right) => {
    return (($content) => {
      return (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($left)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)((($sp$Compiler$Parser$discardSecond)($content))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)($right)))));
    });
  });
});

const $sp$Compiler$Parser$list = (($env) => {
  return (($constructor) => {
    return (($main) => {
      return (($sp$Compiler$Parser$andThen)((($start) => {
        return (($sp$Compiler$Parser$andThen)((($maybeLs) => {
          return (($sp$Compiler$Parser$andThen)((($end) => {
            const $theParserStillSucks = ((() => {
              const $$try0 = $maybeLs;
              if (("$corelib$Maybe$Just" === ($$try0)[0])) {
                const $ls = ($$try0)[1];
                return $ls;
              }
              if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
                return $core$SPCore$Nil;
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 629:8', (sp_toHuman)($$try0));
            }))();
            return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($theParserStillSucks));
          })))($sp$Compiler$Parser$here);
        })))(((($sp$Compiler$Parser$surroundMultiline)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed)))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$rawList)($main))));
      })))($sp$Compiler$Parser$here);
    });
  });
});

const $sp$Compiler$Parser$parens = (($sp$SPLib$Parser$surroundWith)(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed))));

const $sp$Compiler$Parser$lowerNameBare = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($token) => {
    const $$try0 = $token;
    if ((("$sp$Types$Token$Token" === ($$try0)[0]) && (("$sp$Types$Token$LowerName" === (($$try0)[3])[0]) && (("$sp$Types$Token$NameNoModifier" === ((($$try0)[3])[1])[0]) && (("$corelib$Maybe$Nothing" === ((($$try0)[3])[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[3])[4])[0])))))) {
      const $name = (($$try0)[3])[3];
      const $end = ($$try0)[2];
      const $start = ($$try0)[1];
      return ($sp$SPLib$Parser$accept)((($sp$Types$Pos$At)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 184:4', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$record = (($env) => {
  return (($assign) => {
    return (($constructor) => {
      return (($main) => {
        const $attrAssignment = (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($assign)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)($main));
        const $attr = (($sp$Compiler$Parser$andThen)((($name) => {
          return (($sp$Compiler$Parser$andThen)((($maybeAssignment) => {
            return ($sp$SPLib$Parser$accept)(({
              first: $name,
              second: $maybeAssignment,
            }));
          })))(($sp$SPLib$Parser$maybe)($attrAssignment));
        })))(($sp$Compiler$Parser$lowerNameBare)($env));
        const $updateTarget = (($sp$Compiler$Parser$andThen)((($h) => {
          return (($sp$Compiler$Parser$andThen)((() => {
            return ($sp$SPLib$Parser$accept)($h);
          })))(($sp$Compiler$Parser$kind)($sp$Types$Token$With));
        })))($main);
        const $content = (($start) => {
          return (($sp$Compiler$Parser$andThen)((($maybeUpdateTarget) => {
            return (($sp$Compiler$Parser$andThen)((($attrs) => {
              return (($sp$Compiler$Parser$andThen)((($end) => {
                return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
                  attrs: $attrs,
                  extends: $maybeUpdateTarget,
                })));
              })))($sp$Compiler$Parser$here);
            })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$rawList)($attr)));
          })))(($sp$SPLib$Parser$maybe)($updateTarget));
        });
        return (($sp$Compiler$Parser$andThen)((($s) => {
          return (($sp$Compiler$Parser$andThen)((($maybeRecord) => {
            return (($sp$Compiler$Parser$andThen)((($e) => {
              const $$try0 = $maybeRecord;
              if (("$corelib$Maybe$Just" === ($$try0)[0])) {
                const $re = ($$try0)[1];
                return ($sp$SPLib$Parser$accept)($re);
              }
              if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
                return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($s))($e)))(({
                  attrs: $core$SPCore$Nil,
                  extends: $corelib$Maybe$Nothing,
                })));
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 676:4', (sp_toHuman)($$try0));
            })))($sp$Compiler$Parser$here);
          })))(((($sp$Compiler$Parser$surroundMultiline)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Open)))(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Closed)))(($sp$SPLib$Parser$maybe)(($content)($s))));
        })))($sp$Compiler$Parser$here);
      });
    });
  });
});

const $sp$Compiler$Parser$typeConstructorAppOr = (($env) => {
  return (($higher) => {
    return (($sp$Compiler$Parser$andThen)((($ty) => {
      const $$try0 = $ty;
      if ((("$sp$Types$FormattableAst$TypeConstant" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[4])[0]))) {
        const $name = ($$try0)[3];
        const $maybeModule = ($$try0)[2];
        const $p1 = ($$try0)[1];
        return (($sp$Compiler$Parser$andThen)((($args) => {
          return (($sp$Compiler$Parser$andThen)((($end2) => {
            return (((sp_equal)($core$SPCore$Nil))($args)
              ? ($sp$SPLib$Parser$accept)($ty)
              : ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$TypeConstant)($p1))($maybeModule))($name))($args)));
          })))($sp$Compiler$Parser$here);
        })))(($sp$SPLib$Parser$zeroOrMore)($higher));
      }
      if (true) {
        return ($sp$SPLib$Parser$accept)($ty);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 962:4', (sp_toHuman)($$try0));
    })))($higher);
  });
});

const $sp$Compiler$Parser$arrow = (($env) => {
  return (($sp$Compiler$Parser$andThen)(((end$$) => {
    const $k = (end$$)[3];
    const $end = (end$$)[2];
    const $start = (end$$)[1];
    const $$try0 = $k;
    if (("$sp$Types$Token$Colon" === ($$try0)[0])) {
      return ($sp$SPLib$Parser$accept)(({
        first: false,
        second: ((($sp$Compiler$Parser$pos)($env))($start))($end),
      }));
    }
    if (("$sp$Types$Token$MutableColon" === ($$try0)[0])) {
      return ($sp$SPLib$Parser$accept)(({
        first: true,
        second: ((($sp$Compiler$Parser$pos)($env))($start))($end),
      }));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 947:4', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$typeFunctionOr = (($env) => {
  return (($higher) => {
    const $arrowAndHigher = (($sp$Compiler$Parser$andThen)(((mutable$$) => {
      const $p = mutable$$.second;
      const $mutable = mutable$$.first;
      return (($sp$Compiler$Parser$andThen)((($h) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $mutable,
          second: $p,
          third: $h,
        }));
      })))($higher);
    })))(($sp$Compiler$Parser$arrow)($env));
    const $fold = ((nextIsMutable$$) => {
      const $ty = nextIsMutable$$.third;
      const $p = nextIsMutable$$.second;
      const $nextIsMutable = nextIsMutable$$.first;
      return ((accum$$) => {
        const $accum = accum$$.second;
        const $thisIsMutable = accum$$.first;
        return ({
          first: $nextIsMutable,
          second: (((($sp$Types$FormattableAst$TypeFunction)($p))($ty))($thisIsMutable))($accum),
        });
      });
    });
    return (($sp$Compiler$Parser$andThen)((($fs) => {
      return (($sp$Compiler$Parser$andThen)((($e) => {
        return (($sp$Compiler$Parser$andThen)((($fe) => {
          return (($sp$Compiler$Parser$andThen)((($es) => {
            const $firstPos = ((($sp$Compiler$Parser$pos)($env))($fs))($fe);
            const $reverseRec = (($a) => {
              return (($ls) => {
                return (($accum) => {
                  const $$try0 = $ls;
                  if (("$core$SPCore$Nil" === ($$try0)[0])) {
                    return ({
                      first: $a,
                      second: $accum,
                    });
                  }
                  if (("$core$SPCore$Cons" === ($$try0)[0])) {
                    const $tail = ($$try0)[2];
                    const $head = ($$try0)[1];
                    return ((($reverseRec)($head))($tail))(((sp_cons)($accum))($a));
                  }
                  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 926:8', (sp_toHuman)($$try0));
                });
              });
            });
            const p$$ = ((($reverseRec)(({
              first: false,
              second: $firstPos,
              third: $e,
            })))($es))($core$SPCore$Nil);
            const $reversedArgs = p$$.second;
            const $return = p$$.first.third;
            const $p = p$$.first.second;
            const $thisIsMutable = p$$.first.first;
            return ((($x) => {
              return ($sp$SPLib$Parser$accept)($x.second);
            }))(((($corelib$List$for)($reversedArgs))($fold))(({
              first: $thisIsMutable,
              second: $return,
            })));
          })))(($sp$SPLib$Parser$zeroOrMore)($arrowAndHigher));
        })))($sp$Compiler$Parser$here);
      })))($higher);
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$Compiler$Parser$typeList = (($env) => {
  return (($main) => {
    return (($sp$Compiler$Parser$andThen)((($start) => {
      return (($sp$Compiler$Parser$andThen)((($t) => {
        return (($sp$Compiler$Parser$andThen)((($end) => {
          return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeList)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($t));
        })))($sp$Compiler$Parser$here);
      })))(((($sp$Compiler$Parser$surroundStrict)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed)))($main));
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$Compiler$Parser$typeParens = (($main) => {
  return ((($sp$Compiler$Parser$surroundStrict)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open)))(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)))($main);
});

const $sp$Compiler$Parser$typeTerm = (($env) => {
  return (($sp$Compiler$Parser$andThen)(((end$$) => {
    const $k = (end$$)[3];
    const $end = (end$$)[2];
    const $start = (end$$)[1];
    const $$try0 = $k;
    if (("$sp$Types$Token$UpperName" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $maybeModule = ($$try0)[1];
      return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$TypeConstant)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($maybeModule))($name))($core$SPCore$Nil));
    }
    if ((("$sp$Types$Token$LowerName" === ($$try0)[0]) && (("$sp$Types$Token$NameNoModifier" === (($$try0)[1])[0]) && (("$corelib$Maybe$Nothing" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === (($$try0)[4])[0]))))) {
      const $name = ($$try0)[3];
      return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeVariable)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 833:4', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$typeTupleOr = (($env) => {
  return (($higher) => {
    const $binopAndPrev = (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$binaryOperators)($sp$Types$Op$Tuple)))($higher);
    return (($sp$Compiler$Parser$andThen)((($start) => {
      return (($sp$Compiler$Parser$andThen)((($head) => {
        return (($sp$Compiler$Parser$andThen)((($tail) => {
          return (($sp$Compiler$Parser$andThen)((($end) => {
            return (((sp_equal)($core$SPCore$Nil))($tail)
              ? ($sp$SPLib$Parser$accept)($head)
              : ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeTuple)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(((sp_cons)($tail))($head))));
          })))($sp$Compiler$Parser$here);
        })))(($sp$SPLib$Parser$zeroOrMore)($binopAndPrev));
      })))($higher);
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$SPLib$Parser$breakCircularDefinition = (($a) => {
  return (($sp$SPLib$Parser$andThen)($a))(($sp$SPLib$Parser$accept)(null));
});

const $sp$SPLib$Parser$expression = (($term) => {
  return (($ops) => {
    const $$try0 = $ops;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return $term;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $rest = ($$try0)[2];
      const $op = ($$try0)[1];
      return (($sp$SPLib$Parser$expression)(($op)($term)))($rest);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 230:4', (sp_toHuman)($$try0));
  });
});

const $sp$SPLib$Parser$higherOr = (($parser) => {
  return (($higher) => {
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($higher))((($core$SPCore$Cons)($parser))($core$SPCore$Nil)));
  });
});

const $sp$Compiler$Parser$typeExpr = (($env) => {
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$typeExpr)($env);
  }));
  const $higherOr = $sp$SPLib$Parser$higherOr;
  return (($sp$SPLib$Parser$expression)(($sp$Compiler$Parser$typeTerm)($env)))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$typeParens)($nest))))((($core$SPCore$Cons)(($higherOr)((($sp$Compiler$Parser$typeList)($env))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))($sp$Types$Token$As))($sp$Types$FormattableAst$TypeRecord))($nest))))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeConstructorAppOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeTupleOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeFunctionOr)($env)))($core$SPCore$Nil)))))));
});

const $sp$Compiler$Parser$typeAnnotation = (($env) => {
  return (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($sp$Types$Token$As)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeExpr)($env)));
});

const $sp$Compiler$Parser$patternApplication = (($env) => {
  return (($param) => {
    return (($sp$Compiler$Parser$andThen)(((end$$) => {
      const $k = (end$$)[3];
      const $end = (end$$)[2];
      const $start = (end$$)[1];
      const $p = ((($sp$Compiler$Parser$pos)($env))($start))($end);
      const $$try0 = $k;
      if (("$sp$Types$Token$NumberLiteral" === ($$try0)[0])) {
        const $s = ($$try0)[1];
        return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PatternLiteralNumber)($p))($s));
      }
      if (("$sp$Types$Token$TextLiteral" === ($$try0)[0])) {
        const $s = ($$try0)[1];
        return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PatternLiteralText)($p))($s));
      }
      if ((("$sp$Types$Token$LowerName" === ($$try0)[0]) && (("$corelib$Maybe$Nothing" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === (($$try0)[4])[0])))) {
        const $name = ($$try0)[3];
        const $modifier = ($$try0)[1];
        const $thingy = (($mutable) => {
          return (($sp$Compiler$Parser$andThen)((($maybeTy) => {
            return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$PatternAny)($p))($mutable))($name))($maybeTy));
          })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeAnnotation)($env))));
        });
        const $$try1 = $modifier;
        if (("$sp$Types$Token$NameNoModifier" === ($$try1)[0])) {
          return ($thingy)(false);
        }
        if (("$sp$Types$Token$NameMutable" === ($$try1)[0])) {
          return ($thingy)(true);
        }
        if (("$sp$Types$Token$NameStartsWithDot" === ($$try1)[0])) {
          return $sp$SPLib$Parser$reject;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1080:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$Token$UpperName" === ($$try0)[0])) {
        const $name = ($$try0)[2];
        const $maybeModule = ($$try0)[1];
        return (($sp$Compiler$Parser$andThen)((($params) => {
          return (($sp$Compiler$Parser$andThen)((($end1) => {
            return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$PatternConstructor)(((($sp$Compiler$Parser$pos)($env))($start))($end1)))($maybeModule))($name))($params));
          })))($sp$Compiler$Parser$here);
        })))(($sp$SPLib$Parser$zeroOrMore)($param));
      }
      if (true) {
        return $sp$SPLib$Parser$reject;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1063:4', (sp_toHuman)($$try0));
    })))($sp$Compiler$Parser$oneToken);
  });
});

const $sp$Compiler$Parser$functionParameter = (($env) => {
  return (($nest) => {
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$patternApplication)($env))($sp$SPLib$Parser$reject)))((($core$SPCore$Cons)(($sp$Compiler$Parser$parens)($nest)))((($core$SPCore$Cons)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$PatternList))($nest)))((($core$SPCore$Cons)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)(({
      mutable: false,
    }))))($sp$Types$FormattableAst$PatternRecord))($nest)))($core$SPCore$Nil)))));
  });
});

const $sp$Compiler$Parser$patternBinopOr = (($env) => {
  return (($precedenceGroup) => {
    return (($constructor) => {
      return (($higher) => {
        return (($sp$Compiler$Parser$andThen)((($start) => {
          return (($sp$Compiler$Parser$andThen)(((head$$) => {
            const $sepTail = head$$.second;
            const $head = head$$.first;
            return (($sp$Compiler$Parser$andThen)((($end) => {
              return (((sp_equal)($core$SPCore$Nil))($sepTail)
                ? ($sp$SPLib$Parser$accept)($head)
                : ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(((sp_cons)((($corelib$List$map)((($x) => {
                  return $x.second;
                })))($sepTail)))($head))));
            })))($sp$Compiler$Parser$here);
          })))((($sp$Compiler$Parser$sepList)(($sp$Compiler$Parser$binaryOperators)($precedenceGroup)))($higher));
        })))($sp$Compiler$Parser$here);
      });
    });
  });
});

const $sp$Compiler$Parser$pattern = (($env) => {
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$pattern)($env);
  }));
  const $higherOr = $sp$SPLib$Parser$higherOr;
  return (($sp$SPLib$Parser$expression)((($sp$Compiler$Parser$patternApplication)($env))((($sp$Compiler$Parser$functionParameter)($env))($nest))))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$parens)($nest))))((($core$SPCore$Cons)(($higherOr)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$PatternList))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)(({
    mutable: false,
  }))))($sp$Types$FormattableAst$PatternRecord))($nest))))((($core$SPCore$Cons)(((($sp$Compiler$Parser$patternBinopOr)($env))($sp$Types$Op$Cons))($sp$Types$FormattableAst$PatternListCons)))((($core$SPCore$Cons)(((($sp$Compiler$Parser$patternBinopOr)($env))($sp$Types$Op$Tuple))($sp$Types$FormattableAst$PatternTuple)))($core$SPCore$Nil))))));
});

const $sp$SPLib$Parser$map = (($f) => {
  return (($p) => {
    return (($sp$SPLib$Parser$andThen)((($b) => {
      return ($sp$SPLib$Parser$accept)(($f)($b));
    })))($p);
  });
});

const $sp$Compiler$Parser$exprWithLeftDelimiter = (($env) => {
  const $colon = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => {
    return false;
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$Colon))))((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => {
    return true;
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$MutableColon))))($core$SPCore$Nil)));
  const $maybeColon = ($sp$SPLib$Parser$maybe)($colon);
  return (($sp$Compiler$Parser$andThen)(((end$$) => {
    const $k = (end$$)[3];
    const $end = (end$$)[2];
    const $start = (end$$)[1];
    const $p = ((($sp$Compiler$Parser$pos)($env))($start))($end);
    const $$try0 = $k;
    if (("$sp$Types$Token$NumberLiteral" === ($$try0)[0])) {
      const $s = ($$try0)[1];
      return (($sp$Compiler$Parser$andThen)((($mc) => {
        const $$try1 = $mc;
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$LiteralNumber)($p))($s));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $mutable = ($$try1)[1];
          return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((($sp$Types$FormattableAst$PatternLiteralNumber)($p))($s));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 478:20', (sp_toHuman)($$try1));
      })))($maybeColon);
    }
    if (("$sp$Types$Token$TextLiteral" === ($$try0)[0])) {
      const $s = ($$try0)[1];
      return (($sp$Compiler$Parser$andThen)((($mc) => {
        const $$try1 = $mc;
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$LiteralText)($p))($s));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $mutable = ($$try1)[1];
          return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((($sp$Types$FormattableAst$PatternLiteralText)($p))($s));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 485:20', (sp_toHuman)($$try1));
      })))($maybeColon);
    }
    if (("$sp$Types$Token$LowerName" === ($$try0)[0])) {
      const $attrs = ($$try0)[4];
      const $name = ($$try0)[3];
      const $maybeModule = ($$try0)[2];
      const $modifier = ($$try0)[1];
      const $$try1 = $modifier;
      if (("$sp$Types$Token$NameMutable" === ($$try1)[0])) {
        return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Mutable)($p))($name))($attrs));
      }
      if (("$sp$Types$Token$NameStartsWithDot" === ($$try1)[0])) {
        return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$RecordShorthand)($p))(((sp_cons)($attrs))($name)));
      }
      if (("$sp$Types$Token$NameNoModifier" === ($$try1)[0])) {
        return (($sp$Compiler$Parser$andThen)((($mc) => {
          const $$try2 = $mc;
          if (("$corelib$Maybe$Nothing" === ($$try2)[0])) {
            return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$Variable)($p))($maybeModule))($name))($attrs));
          }
          if (("$corelib$Maybe$Just" === ($$try2)[0])) {
            const $mutable = ($$try2)[1];
            return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((((($sp$Types$FormattableAst$PatternAny)($p))(false))($name))($corelib$Maybe$Nothing));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 499:28', (sp_toHuman)($$try2));
        })))($maybeColon);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 490:16', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$Token$UpperName" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $maybeModule = ($$try0)[1];
      return (($sp$Compiler$Parser$andThen)((($mc) => {
        const $$try1 = $mc;
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Constructor)($p))($maybeModule))($name));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $mutable = ($$try1)[1];
          return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((((($sp$Types$FormattableAst$PatternConstructor)($p))($maybeModule))($name))($core$SPCore$Nil));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 506:20', (sp_toHuman)($$try1));
      })))($maybeColon);
    }
    if ((("$sp$Types$Token$RoundParen" === ($$try0)[0]) && ("$sp$Types$Token$Open" === (($$try0)[1])[0]))) {
      const $paParser = (($sp$Compiler$Parser$andThen)((($pa) => {
        return (($sp$Compiler$Parser$andThen)((() => {
          return (($sp$Compiler$Parser$andThen)((($mutable) => {
            return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))($pa);
          })))($colon);
        })))(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)));
      })))(($sp$Compiler$Parser$pattern)($env));
      const $exprParser = (($sp$Compiler$Parser$discardSecond)(($sp$Compiler$Parser$expr)($env)))(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)));
      return ($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($paParser))((($core$SPCore$Cons)($exprParser))($core$SPCore$Nil))));
      return null;
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 475:8', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$maybeWithDefault = (($a) => {
  return (($p) => {
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($p))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($a)))($core$SPCore$Nil)));
  });
});

const $sp$Compiler$Parser$recInlineOrIndentedOrBelow = (($higher) => {
  return (($accum) => {
    return (($sp$Compiler$Parser$andThen)((($h) => {
      const $r = ((sp_cons)($accum))($h);
      return (($sp$Compiler$Parser$maybeWithDefault)($r))(($sp$Compiler$Parser$inlineOrBelowOrIndented)((($sp$Compiler$Parser$recInlineOrIndentedOrBelow)($higher))($r)));
    })))($higher);
  });
});

const $sp$Compiler$Parser$functionApplicationOr = (($env) => {
  return (($higher) => {
    const $recInlineOrIndented = (($accum) => {
      return (($sp$Compiler$Parser$andThen)((($h) => {
        const $r = ((sp_cons)($accum))($h);
        return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$recInlineOrIndentedOrBelow)($higher))($r))))((($core$SPCore$Cons)(($recInlineOrIndented)($r)))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($r)))($core$SPCore$Nil))));
      })))($higher);
    });
    return (($sp$Compiler$Parser$andThen)((($start) => {
      return (($sp$Compiler$Parser$andThen)((($reversedArgs) => {
        return (($sp$Compiler$Parser$andThen)((($end) => {
          const $$try0 = ($corelib$List$reverse)($reversedArgs);
          if (("$core$SPCore$Nil" === ($$try0)[0])) {
            return $sp$SPLib$Parser$reject;
          }
          if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
            const $fnExpression = ($$try0)[1];
            return ($sp$SPLib$Parser$accept)($fnExpression);
          }
          if (("$core$SPCore$Cons" === ($$try0)[0])) {
            const $args = ($$try0)[2];
            const $fnExpression = ($$try0)[1];
            return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$FunctionCall)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($fnExpression))($args));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1152:4', (sp_toHuman)($$try0));
        })))($sp$Compiler$Parser$here);
      })))(($recInlineOrIndented)($core$SPCore$Nil));
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$SPLib$Parser$abort = (($error) => {
  return (($rejections) => {
    return (($readState) => {
      return ({
        first: $rejections,
        second: (($sp$SPLib$Parser$Aborted)($readState))($error),
      });
    });
  });
});

const $sp$Compiler$Parser$if_ = (($env) => {
  const $maybeNewLine = (($k) => {
    return (($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine))))(($sp$Compiler$Parser$kind)($k));
  });
  return (($sp$Compiler$Parser$andThen)(((start$$) => {
    const $start = (start$$)[1];
    return (($sp$Compiler$Parser$andThen)((($condition) => {
      return (($sp$Compiler$Parser$andThen)((($maybeThen) => {
        return (((sp_equal)($corelib$Maybe$Nothing))($maybeThen)
          ? ($sp$SPLib$Parser$abort)("`if` should be followed by a `then` but I can't find it")
          : (($sp$Compiler$Parser$andThen)((($true) => {
            return (($sp$Compiler$Parser$andThen)((() => {
              return (($sp$Compiler$Parser$andThen)((() => {
                return (($sp$Compiler$Parser$andThen)((($false) => {
                  return (($sp$Compiler$Parser$andThen)((($end) => {
                    return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$If)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
                      condition: $condition,
                      false: $false,
                      isCompact: false,
                      true: $true,
                    })));
                  })))($sp$Compiler$Parser$here);
                })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env));
              })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$Colon)));
            })))(($maybeNewLine)($sp$Types$Token$Else));
          })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env)));
      })))(($sp$SPLib$Parser$maybe)(($maybeNewLine)($sp$Types$Token$Then)));
    })))(($sp$Compiler$Parser$expr)($env));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$If));
});

const $sp$Compiler$Parser$try_ = (($env) => {
  const $maybeNewLine = ($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)));
  const $maybeNewLineKind = (($k) => {
    return ($maybeNewLine)(($sp$Compiler$Parser$kind)($k));
  });
  const $patternAndAccept = (($sp$Compiler$Parser$andThen)((($p) => {
    return (($sp$Compiler$Parser$andThen)((() => {
      return (($sp$Compiler$Parser$andThen)((($accept) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $p,
          second: $accept,
        }));
      })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env));
    })))(($maybeNewLineKind)($sp$Types$Token$Colon));
  })))(($sp$Compiler$Parser$pattern)($env));
  return (($sp$Compiler$Parser$andThen)(((start$$) => {
    const $start = (start$$)[1];
    return (($sp$Compiler$Parser$andThen)((($value) => {
      return (($sp$Compiler$Parser$andThen)((() => {
        return (($sp$Compiler$Parser$andThen)((($patterns) => {
          return (($sp$Compiler$Parser$andThen)((($end) => {
            return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Try)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
              isCompact: false,
              patterns: $patterns,
              value: $value,
            })));
          })))($sp$Compiler$Parser$here);
        })))(($sp$Compiler$Parser$block)(($sp$SPLib$Parser$zeroOrMore)(($maybeNewLine)($patternAndAccept))));
      })))(($maybeNewLineKind)($sp$Types$Token$As));
    })))(($sp$Compiler$Parser$expr)($env));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$Try));
});

const $sp$Compiler$Parser$unaryOperator = (($sp$Compiler$Parser$andThen)((($token) => {
  const $$try0 = $token;
  if ((("$sp$Types$Token$Token" === ($$try0)[0]) && ("$sp$Types$Token$Unop" === (($$try0)[3])[0]))) {
    const $op = (($$try0)[3])[1];
    const $e = ($$try0)[2];
    const $s = ($$try0)[1];
    return ($sp$SPLib$Parser$accept)(({
      first: $op,
      second: $token,
    }));
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1186:4', (sp_toHuman)($$try0));
})))($sp$Compiler$Parser$oneToken);

const $sp$Compiler$Parser$unopsOr = (($env) => {
  return (($higher) => {
    return (($sp$Compiler$Parser$andThen)((($maybeUnary) => {
      return (($sp$Compiler$Parser$andThen)((($right) => {
        return (($sp$Compiler$Parser$andThen)((($end) => {
          const $$try0 = $maybeUnary;
          if ((("$corelib$Maybe$Just" === ($$try0)[0]) && ("$sp$Types$Token$Token" === (($$try0)[1].second)[0]))) {
            const $start = (($$try0)[1].second)[1];
            const $op = ($$try0)[1].first;
            return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Unop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($op))($right));
          }
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            return ($sp$SPLib$Parser$accept)($right);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1175:4', (sp_toHuman)($$try0));
        })))($sp$Compiler$Parser$here);
      })))($higher);
    })))(($sp$SPLib$Parser$maybe)($sp$Compiler$Parser$unaryOperator));
  });
});

const $sp$Compiler$Parser$expr = (($env) => {
  const $higherOr = $sp$SPLib$Parser$higherOr;
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$expr)($env);
  }));
  return (($sp$SPLib$Parser$expression)(($sp$Compiler$Parser$exprWithLeftDelimiter)($env)))((($core$SPCore$Cons)(($higherOr)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$List))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)(({
    mutable: false,
  }))))($sp$Types$FormattableAst$Record))($nest))))((($core$SPCore$Cons)(($sp$Compiler$Parser$unopsOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$functionApplicationOr)($env)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Exponential)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Multiplicative)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Addittive)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Comparison)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Logical)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Tuple)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Cons)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Pipe)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Mutop)))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$if_)($env))))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$try_)($env))))($core$SPCore$Nil))))))))))))))));
});

const $sp$Compiler$Parser$inlineStatementOrBlock = (($env) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($e) => {
    return ($sp$SPLib$Parser$accept)((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)(($sp$Types$FormattableAst$expressionPos)($e)))($e)))($core$SPCore$Nil));
  })))(($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$expr)($env);
  })))))((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$oomSeparatedBy)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))(($sp$Compiler$Parser$statement)($env)))))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$upperNameBare = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($token) => {
    const $$try0 = $token;
    if ((("$sp$Types$Token$Token" === ($$try0)[0]) && (("$sp$Types$Token$UpperName" === (($$try0)[3])[0]) && ("$corelib$Maybe$Nothing" === ((($$try0)[3])[1])[0])))) {
      const $name = (($$try0)[3])[2];
      const $end = ($$try0)[2];
      const $start = ($$try0)[1];
      return ($sp$SPLib$Parser$accept)((($sp$Types$Pos$At)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 174:4', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$nonFunction = (($env) => {
  return (($sp$Compiler$Parser$andThen)((() => {
    return (($sp$Compiler$Parser$andThen)((($nf) => {
      return (($sp$Compiler$Parser$andThen)(((n$$) => {
        const $n = (n$$)[2];
        return (((sp_equal)("NonFunction"))($n)
          ? ($sp$SPLib$Parser$accept)((($corelib$List$map)($sp$Types$Pos$drop))($nf))
          : ($sp$SPLib$Parser$abort)("Only NonFunction is supported for now"));
      })))(($sp$Compiler$Parser$upperNameBare)($env));
    })))(($sp$Compiler$Parser$rawList)(($sp$Compiler$Parser$lowerNameBare)($env)));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$With));
});

const $sp$Compiler$Parser$definition = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($start) => {
    return (($sp$Compiler$Parser$andThen)((($p) => {
      return (($sp$Compiler$Parser$andThen)((($nf) => {
        return (($sp$Compiler$Parser$andThen)((($defopArgs) => {
          return (($sp$Compiler$Parser$andThen)((($body) => {
            return (($sp$Compiler$Parser$andThen)((($end) => {
              return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Definition)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
                body: $body,
                mutable: $defopArgs.mutable,
                nonFn: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($nf),
                pattern: $p,
              })));
            })))($sp$Compiler$Parser$here);
          })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env));
        })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)($sp$Compiler$Parser$defop));
      })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$nonFunction)($env))));
    })))(($sp$Compiler$Parser$pattern)($env));
  })))($sp$Compiler$Parser$here);
});

const $sp$Compiler$Parser$errorCantUseMutableAssignmentHere = "Can't use mutable assignment here";

const $sp$Compiler$Parser$typeAlias = (($env) => {
  return (($sp$Compiler$Parser$andThen)((() => {
    return (($sp$Compiler$Parser$andThen)((($name) => {
      return (($sp$Compiler$Parser$andThen)((($args) => {
        return (($sp$Compiler$Parser$andThen)((($defopArgs) => {
          return (($sp$Compiler$Parser$andThen)((($ty) => {
            return ($defopArgs.mutable
              ? ($sp$SPLib$Parser$abort)($sp$Compiler$Parser$errorCantUseMutableAssignmentHere)
              : ($sp$SPLib$Parser$accept)(($sp$Types$FormattableAst$TypeAlias)(({
                args: $args,
                name: $name,
                ty: $ty,
              }))));
          })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeExpr)($env)));
        })))($sp$Compiler$Parser$defop);
      })))(($sp$SPLib$Parser$zeroOrMore)(($sp$Compiler$Parser$lowerNameBare)($env)));
    })))(($sp$Compiler$Parser$upperNameBare)($env));
  })))(($sp$Compiler$Parser$kind)((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("alias"))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$unionConstructor = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($type) => {
    const $$try0 = $type;
    if ((("$sp$Types$FormattableAst$TypeConstant" === ($$try0)[0]) && ("$corelib$Maybe$Nothing" === (($$try0)[2])[0]))) {
      const $args = ($$try0)[4];
      const $name = ($$try0)[3];
      const $p = ($$try0)[1];
      return ($sp$SPLib$Parser$accept)(({
        first: (($sp$Types$Pos$At)($p))($name),
        second: $args,
      }));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 403:4', (sp_toHuman)($$try0));
  })))(($sp$Compiler$Parser$typeExpr)($env));
});

const $sp$Compiler$Parser$unionDef = (($env) => {
  return (($sp$Compiler$Parser$andThen)((() => {
    return (($sp$Compiler$Parser$andThen)(((name$$) => {
      const $name = (name$$)[2];
      const $p = (name$$)[1];
      return (($sp$Compiler$Parser$andThen)((($args) => {
        return (($sp$Compiler$Parser$andThen)((($defopArgs) => {
          return (($sp$Compiler$Parser$andThen)((($cons) => {
            return ($defopArgs.mutable
              ? ($sp$SPLib$Parser$abort)($sp$Compiler$Parser$errorCantUseMutableAssignmentHere)
              : ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$UnionDef)($p))(({
                args: (($corelib$List$map)($sp$Types$Pos$drop))($args),
                constructors: $cons,
                name: $name,
              }))));
          })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$rawList)(($sp$Compiler$Parser$unionConstructor)($env))));
        })))($sp$Compiler$Parser$defop);
      })))(($sp$SPLib$Parser$zeroOrMore)(($sp$Compiler$Parser$lowerNameBare)($env)));
    })))(($sp$Compiler$Parser$upperNameBare)($env));
  })))(($sp$Compiler$Parser$kind)((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("union"))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$statement = (($env) => {
  return ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return (($sp$Compiler$Parser$andThen)((() => {
      return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$typeAlias)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$unionDef)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$definition)($env)))((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($e) => {
        return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Evaluation)(($sp$Types$FormattableAst$expressionPos)($e)))($e));
      })))(($sp$Compiler$Parser$expr)($env))))($core$SPCore$Nil)))));
    })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)));
  }));
});

const $sp$SPLib$Parser$without = (($p) => {
  return ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)(null)))((() => {
    return $sp$SPLib$Parser$reject;
  })))($p);
});

const $sp$SPLib$Parser$end = ($sp$SPLib$Parser$without)($sp$SPLib$Parser$consumeOne);

const $sp$Compiler$Parser$module_ = (($env) => {
  const $start = ($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine));
  const $e = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$kind)($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))($core$SPCore$Nil)));
  const $zzz = (($sp$Compiler$Parser$andThen)((() => {
    return $sp$SPLib$Parser$end;
  })))(($sp$SPLib$Parser$zeroOrMore)($e));
  const $statements = (($sp$Compiler$Parser$oomSeparatedBy)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))(($sp$Compiler$Parser$statement)($env));
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => {
    return $core$SPCore$Nil;
  })))($sp$SPLib$Parser$end)))((($core$SPCore$Cons)(((($sp$SPLib$Parser$surroundWith)($start))($zzz))($statements)))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$makeError = (($moduleName) => {
  return (($readState) => {
    return (($message) => {
      const $p = ((() => {
        const $$try0 = $readState;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return ((($sp$Types$Pos$P)($moduleName))(0))(1);
        }
        if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$sp$Types$Token$Token" === (($$try0)[1])[0]))) {
          const $rest = ($$try0)[2];
          const $k = (($$try0)[1])[3];
          const $end = (($$try0)[1])[2];
          const $start = (($$try0)[1])[1];
          return ((($sp$Types$Pos$P)($moduleName))($start))($end);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 69:8', (sp_toHuman)($$try0));
      }))();
      return (($sp$Compiler$Error$res)($p))((($eenv) => {
        return (($core$SPCore$Cons)($message))($core$SPCore$Nil);
      }));
    });
  });
});

const $sp$SPLib$Parser$runParser = (($parser) => {
  return (($readState) => {
    return (($parser)((($core$SPCore$Cons)($readState))($core$SPCore$Nil)))($readState);
  });
});

const $sp$Compiler$Parser$runParser = (($moduleName) => {
  return (($parser) => {
    return (($tokens) => {
      const failureStates$$ = (($sp$SPLib$Parser$runParser)($parser))((($corelib$List$filter)(((e$$) => {
        const $k = (e$$)[3];
        const $e = (e$$)[2];
        const $s = (e$$)[1];
        return ((sp_not_equal)($sp$Types$Token$Comment))($k);
      })))($tokens));
      const $outcome = failureStates$$.second;
      const $failureStates = failureStates$$.first;
      const $$try0 = $outcome;
      if (("$sp$SPLib$Parser$Accepted" === ($$try0)[0])) {
        const $output = ($$try0)[2];
        const $readState = ($$try0)[1];
        return ($corelib$Result$Ok)($output);
      }
      if (("$sp$SPLib$Parser$Aborted" === ($$try0)[0])) {
        const $message = ($$try0)[2];
        const $readState = ($$try0)[1];
        return ((($sp$Compiler$Parser$makeError)($moduleName))($readState))($message);
      }
      if (("$sp$SPLib$Parser$Rejected" === ($$try0)[0])) {
        const $findMin = (($readState) => {
          return (($best) => {
            return ((($corelib$List$length)($readState) < ($corelib$List$length)($best))
              ? $readState
              : $best);
          });
        });
        const $readState = ((($corelib$List$for)($failureStates))($findMin))($tokens);
        const $message = ((() => {
          const $$try1 = $readState;
          if (("$core$SPCore$Nil" === ($$try1)[0])) {
            return "I got to the end of file and I can't make sense of it. =(";
          }
          if (true) {
            return "I got stuck parsing here. =(";
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 118:16', (sp_toHuman)($$try1));
        }))();
        return ((($sp$Compiler$Parser$makeError)($moduleName))($readState))($message);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 103:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$Parser$parse = (($stripLocations) => {
  return (($moduleName) => {
    return (($tokens) => {
      const $parser = ($sp$Compiler$Parser$module_)(({
        moduleName: $moduleName,
        stripLocations: $stripLocations,
      }));
      return ((($sp$Compiler$Parser$runParser)($moduleName))($parser))($tokens);
    });
  });
});

const $sp$Compiler$Parser$textToFormattableModule = (($pars) => {
  return (($code) => {
    const $tokensResult = (($sp$Compiler$Lexer$lexer)($pars.name))($code);
    const $tokensToStatsResult = (($tokens) => {
      (sp_benchStart)(null);
      return ((($corelib$Basics$btw)(sp_benchStop))("parse"))(((($sp$Compiler$Parser$parse)($pars.stripLocations))($pars.name))($tokens));
    });
    return (($corelib$Result$onOk)($tokensToStatsResult))($tokensResult);
  });
});

const $sp$Compiler$MakeCanonical$textToCanonicalModule = (($pars) => {
  return (($code) => {
    const $ro = ({
      currentModule: (($sp$Types$Meta$UMR)($pars.source))($pars.name),
      meta: $pars.meta,
    });
    const $umr = (($sp$Types$Meta$UMR)($pars.source))($pars.name);
    return (($corelib$Result$onOk)(((($sp$Compiler$MakeCanonical$translateModule)($ro))($code))($umr)))((($sp$Compiler$Parser$textToFormattableModule)(({
      name: $pars.name,
      stripLocations: $pars.stripLocations,
    })))($code));
  });
});

const $sp$Compiler$MakeCanonical_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$DefaultModules$asText = "library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\"\n\n    module =\n       path = SPCore\n       importAs = SPCore\n       globalTypes =\n          None\n          Bool\n          Text\n          Number\n       globalValues =\n          None\n          True\n          False\n\n    module =\n       path = SPCore/List\n       importAs = List\n\n    module =\n       path = SPCore/Maybe\n       importAs = Maybe\n       globalTypes =\n          Maybe\n       globalValues =\n          Just\n          Nothing\n\n    module =\n       path = SPCore/Text\n       importAs = Text\n\n    module =\n       path = SPCore/Tuple\n       importAs = Tuple\n\n    module =\n       path = SPCore/Debug\n       importAs = Debug\n       globalValues =\n          log\n          todo\n\n    module =\n       path = SPCore/Basics\n       globalValues =\n            assert\n            clamp\n            identity\n            modBy\n            min\n            max\n\n    module =\n       path = SPCore/Dict\n       importAs = Dict\n       globalTypes = Dict\n\n    module =\n       path = SPCore/Set\n       importAs = Set\n       globalTypes = Set\n\n    module =\n       path = SPCore/Result\n       importAs = Result\n       globalTypes = Result\n       globalValues =\n          Ok\n          Err";

const $sp$ModulesFile$initModulesFile = ({
  libraries: $core$SPCore$Nil,
  sourceDirs: $core$SPCore$Nil,
});

const $sp$SPON$posEnd = ($sp$Types$Pos$End)("");

const $sp$Types$FormattableAst$statementPos = (($statement) => {
  const $$try0 = $statement;
  if (("$sp$Types$FormattableAst$Evaluation" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$FormattableAst$Definition" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if ((("$sp$Types$FormattableAst$TypeAlias" === ($$try0)[0]) && ("$sp$Types$Pos$At" === (($$try0)[1].name)[0]))) {
    const $ty = ($$try0)[1].ty;
    const $pos = (($$try0)[1].name)[1];
    const $args = ($$try0)[1].args;
    return $pos;
  }
  if (("$sp$Types$FormattableAst$UnionDef" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 121:4', (sp_toHuman)($$try0));
});

const $sp$SPON$field = (($fieldName) => {
  return (($fieldReader) => {
    return (($statements) => {
      const $$try0 = $statements;
      if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$sp$Types$FormattableAst$Definition" === (($$try0)[1])[0]) && (("$sp$Types$FormattableAst$PatternAny" === ((($$try0)[1])[2].pattern)[0]) && ((false === ((($$try0)[1])[2].pattern)[2]) && ("$corelib$Maybe$Nothing" === (((($$try0)[1])[2].pattern)[4])[0])))))) {
        const $tail = ($$try0)[2];
        const $name = ((($$try0)[1])[2].pattern)[3];
        const $nonFn = (($$try0)[1])[2].nonFn;
        const $mutable = (($$try0)[1])[2].mutable;
        const $body = (($$try0)[1])[2].body;
        const $pos = (($$try0)[1])[1];
        return (((sp_equal)($fieldName))($name)
          ? ((() => {
            const $$try1 = ($fieldReader)($body);
            if (("$sp$SPON$Accepted" === ($$try1)[0])) {
              const $a = ($$try1)[2];
              const $unreadStatements = ($$try1)[1];
              const $$try2 = $unreadStatements;
              if (("$core$SPCore$Nil" === ($$try2)[0])) {
                return (($sp$SPON$Accepted)($tail))($a);
              }
              if (("$core$SPCore$Cons" === ($$try2)[0])) {
                const $head = ($$try2)[1];
                return ($sp$SPON$Failed)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($head)))(("Could not make sense of all the statements in field `" + ($fieldName + "`."))));
              }
              (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 202:24', (sp_toHuman)($$try2));
              return null;
            }
            if (true) {
              const $otherwise = $$try1;
              return $otherwise;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 200:16', (sp_toHuman)($$try1));
          }))()
          : ($sp$SPON$Rejected)((($sp$Types$Pos$At)($pos))(("expecting `" + ($fieldName + " =`")))));
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $tail = ($$try0)[2];
        const $head = ($$try0)[1];
        return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($head)))("missing a simple assignment (ie `something = `)"));
      }
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ($sp$SPON$Rejected)((($sp$Types$Pos$At)($sp$SPON$posEnd))("unexpected end of file"));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 197:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$SPON$lowerOrUpperName = (($statements) => {
  const $$try0 = $statements;
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try0)[1])[0]) && (("$sp$Types$FormattableAst$Variable" === ((($$try0)[1])[2])[0]) && (("$corelib$Maybe$Nothing" === (((($$try0)[1])[2])[2])[0]) && ("$core$SPCore$Nil" === (((($$try0)[1])[2])[4])[0])))))) {
    const $tail = ($$try0)[2];
    const $name = ((($$try0)[1])[2])[3];
    const $pos = ((($$try0)[1])[2])[1];
    return (($sp$SPON$Accepted)($tail))($name);
  }
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try0)[1])[0]) && (("$sp$Types$FormattableAst$Constructor" === ((($$try0)[1])[2])[0]) && ("$corelib$Maybe$Nothing" === (((($$try0)[1])[2])[2])[0]))))) {
    const $tail = ($$try0)[2];
    const $name = ((($$try0)[1])[2])[3];
    const $pos = ((($$try0)[1])[2])[1];
    return (($sp$SPON$Accepted)($tail))($name);
  }
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
    const $s = ($$try0)[1];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting an Uppercase or lowercase name"));
  }
  if (true) {
    return ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a single statement"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 111:4', (sp_toHuman)($$try0));
});

const $sp$SPON$many = (($readerA) => {
  const $rec = (($accum) => {
    return (($statements) => {
      return (((sp_equal)($core$SPCore$Nil))($statements)
        ? (($sp$SPON$Accepted)($core$SPCore$Nil))(($corelib$List$reverse)($accum))
        : ((() => {
          const $$try0 = ($readerA)($statements);
          if (("$sp$SPON$Accepted" === ($$try0)[0])) {
            const $a = ($$try0)[2];
            const $tail = ($$try0)[1];
            return (($rec)(((sp_cons)($accum))($a)))($tail);
          }
          if (("$sp$SPON$Rejected" === ($$try0)[0])) {
            const $e = ($$try0)[1];
            return ($sp$SPON$Rejected)($e);
          }
          if (("$sp$SPON$Failed" === ($$try0)[0])) {
            const $e = ($$try0)[1];
            return ($sp$SPON$Failed)($e);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 168:12', (sp_toHuman)($$try0));
        }))());
    });
  });
  return ($rec)($core$SPCore$Nil);
});

const $sp$SPON$maybe = (($readerA) => {
  return (($statements) => {
    const $$try0 = ($readerA)($statements);
    if (("$sp$SPON$Accepted" === ($$try0)[0])) {
      const $a = ($$try0)[2];
      const $tail = ($$try0)[1];
      return (($sp$SPON$Accepted)($tail))(($corelib$Maybe$Just)($a));
    }
    if (("$sp$SPON$Rejected" === ($$try0)[0])) {
      return (($sp$SPON$Accepted)($statements))($corelib$Maybe$Nothing);
    }
    if (("$sp$SPON$Failed" === ($$try0)[0])) {
      const $r = ($$try0)[1];
      return ($sp$SPON$Failed)($r);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 183:4', (sp_toHuman)($$try0));
  });
});

const $sp$SPON$onAcc = (($chainedReaderB) => {
  return (($readerA) => {
    return (($statements) => {
      const $$try0 = ($readerA)($statements);
      if (("$sp$SPON$Accepted" === ($$try0)[0])) {
        const $a = ($$try0)[2];
        const $newStatements = ($$try0)[1];
        return (($chainedReaderB)($a))($newStatements);
      }
      if (("$sp$SPON$Rejected" === ($$try0)[0])) {
        const $reason = ($$try0)[1];
        return ($sp$SPON$Rejected)($reason);
      }
      if (("$sp$SPON$Failed" === ($$try0)[0])) {
        const $reason = ($$try0)[1];
        return ($sp$SPON$Failed)($reason);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 14:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$SPON$return = (($a) => {
  return (($statements) => {
    return (($sp$SPON$Accepted)($statements))($a);
  });
});

const $sp$SPON$upperName = (($statements) => {
  const $$try0 = $statements;
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try0)[1])[0]) && (("$sp$Types$FormattableAst$Constructor" === ((($$try0)[1])[2])[0]) && ("$corelib$Maybe$Nothing" === (((($$try0)[1])[2])[2])[0]))))) {
    const $tail = ($$try0)[2];
    const $name = ((($$try0)[1])[2])[3];
    const $pos = ((($$try0)[1])[2])[1];
    return (($sp$SPON$Accepted)($tail))($name);
  }
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
    const $s = ($$try0)[1];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting an Uppercase name"));
  }
  if (true) {
    return ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a statement"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 98:4', (sp_toHuman)($$try0));
});

const $sp$ModulesFile$moduleReader = (($sp$SPON$onAcc)((($path) => {
  return (($sp$SPON$onAcc)((($visibleAs) => {
    return (($sp$SPON$onAcc)((($globalTypes) => {
      return (($sp$SPON$onAcc)((($globalValues) => {
        return ($sp$SPON$return)(({
          globalTypes: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($globalTypes),
          globalValues: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($globalValues),
          path: $path,
          visibleAs: (($corelib$Maybe$withDefault)($path))($visibleAs),
        }));
      })))(($sp$SPON$maybe)((($sp$SPON$field)("globalValues"))(($sp$SPON$many)($sp$SPON$lowerOrUpperName))));
    })))(($sp$SPON$maybe)((($sp$SPON$field)("globalTypes"))(($sp$SPON$many)($sp$SPON$upperName))));
  })))(($sp$SPON$maybe)((($sp$SPON$field)("importAs"))($sp$SPON$upperName)));
})))((($sp$SPON$field)("path"))($sp$SPON$upperName));

const $sp$SPON$text = (($statements) => {
  const $$try0 = $statements;
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try0)[1])[0]) && (("$sp$Types$FormattableAst$LiteralText" === ((($$try0)[1])[2])[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))))) {
    const $t = ((($$try0)[1])[2])[2];
    const $pos = ((($$try0)[1])[2])[1];
    return (($sp$SPON$Accepted)($core$SPCore$Nil))($t);
  }
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
    const $s = ($$try0)[1];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting a text literal"));
  }
  if (true) {
    return ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a single statement"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 85:4', (sp_toHuman)($$try0));
});

const $sp$ModulesFile$libraryReader = (($sp$SPON$onAcc)((($source) => {
  return (($sp$SPON$onAcc)((($modules) => {
    return ($sp$SPON$return)(({
      modules: $modules,
      source: $source,
    }));
  })))(($sp$SPON$many)((($sp$SPON$field)("module"))($sp$ModulesFile$moduleReader)));
})))((($sp$SPON$field)("source"))($sp$SPON$text));

const $sp$ModulesFile$sourceDirectoryReader = (($sp$SPON$onAcc)((($path) => {
  return (($sp$SPON$onAcc)((($modules) => {
    return ($sp$SPON$return)(({
      modules: $modules,
      path: $path,
    }));
  })))(($sp$SPON$many)((($sp$SPON$field)("module"))($sp$ModulesFile$moduleReader)));
})))((($sp$SPON$field)("path"))($sp$SPON$text));

const $sp$SPON$oneOf = (($readers) => {
  return (($statements) => {
    const $$try0 = $readers;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      const $pos = ((() => {
        const $$try1 = $statements;
        if (("$core$SPCore$Cons" === ($$try1)[0])) {
          const $head = ($$try1)[1];
          return ($sp$Types$FormattableAst$statementPos)($head);
        }
        if (true) {
          return $sp$SPON$posEnd;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 136:16', (sp_toHuman)($$try1));
      }))();
      return ($sp$SPON$Rejected)((($sp$Types$Pos$At)($pos))("options exhausted"));
      return null;
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $headReader = ($$try0)[1];
      const $$try1 = ($headReader)($statements);
      if (("$sp$SPON$Rejected" === ($$try1)[0])) {
        return (($sp$SPON$oneOf)($tail))($statements);
      }
      if (true) {
        const $otherwise = $$try1;
        return $otherwise;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 143:12', (sp_toHuman)($$try1));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 133:4', (sp_toHuman)($$try0));
  });
});

const $sp$ModulesFile$modulesFileReader = ($sp$SPON$many)(($sp$SPON$oneOf)((($core$SPCore$Cons)((($sp$SPON$onAcc)((($lib) => {
  return ($sp$SPON$return)(($sp$ModulesFile$Lib)($lib));
})))((($sp$SPON$field)("library"))($sp$ModulesFile$libraryReader))))((($core$SPCore$Cons)((($sp$SPON$onAcc)((($dir) => {
  return ($sp$SPON$return)(($sp$ModulesFile$Dir)($dir));
})))((($sp$SPON$field)("sourceDir"))($sp$ModulesFile$sourceDirectoryReader))))($core$SPCore$Nil))));

const $sp$SPON$unhackPosEnd = (($moduleName) => {
  return (($pos) => {
    const $$try0 = $pos;
    if (("$sp$Types$Pos$End" === ($$try0)[0])) {
      return ($sp$Types$Pos$End)($moduleName);
    }
    if (true) {
      return $pos;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 37:4', (sp_toHuman)($$try0));
  });
});

const $sp$SPON$run = (($readerA) => {
  return (($sponName) => {
    return (($statements) => {
      const $$try0 = ($readerA)($statements);
      if ((("$sp$SPON$Accepted" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[1])[0]))) {
        const $a = ($$try0)[2];
        return ($corelib$Result$Ok)($a);
      }
      if ((("$sp$SPON$Accepted" === ($$try0)[0]) && ("$core$SPCore$Cons" === (($$try0)[1])[0]))) {
        const $a = ($$try0)[2];
        const $tail = (($$try0)[1])[2];
        const $head = (($$try0)[1])[1];
        return (($sp$Compiler$Error$res)(($sp$Types$FormattableAst$statementPos)($head)))((() => {
          return (($core$SPCore$Cons)("unread statements"))($core$SPCore$Nil);
        }));
      }
      if ((("$sp$SPON$Rejected" === ($$try0)[0]) && ("$sp$Types$Pos$At" === (($$try0)[1])[0]))) {
        const $r = (($$try0)[1])[2];
        const $pos = (($$try0)[1])[1];
        return (($sp$Compiler$Error$res)((($sp$SPON$unhackPosEnd)($sponName))($pos)))((() => {
          return (($core$SPCore$Cons)($r))($core$SPCore$Nil);
        }));
      }
      if ((("$sp$SPON$Failed" === ($$try0)[0]) && ("$sp$Types$Pos$At" === (($$try0)[1])[0]))) {
        const $r = (($$try0)[1])[2];
        const $pos = (($$try0)[1])[1];
        return (($sp$Compiler$Error$res)((($sp$SPON$unhackPosEnd)($sponName))($pos)))((() => {
          return (($core$SPCore$Cons)($r))($core$SPCore$Nil);
        }));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 44:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$SPON$read = (($reader) => {
  return (($sponName) => {
    return (($sponContent) => {
      return (($corelib$Result$onOk)((($sp$SPON$run)($reader))($sponName)))((($corelib$Result$onOk)((($sp$Compiler$Parser$parse)(false))($sponName)))((($sp$Compiler$Lexer$lexer)($sponName))($sponContent)));
    });
  });
});

const $sp$ModulesFile$textToModulesFile = (($sponName) => {
  return (($sponContent) => {
    const $insert = (($rootEntry) => {
      return (($mf) => {
        const $$try0 = $rootEntry;
        if (("$sp$ModulesFile$Lib" === ($$try0)[0])) {
          const $lib = ($$try0)[1];
          return (Object.assign)({}, $mf, ({
            libraries: ((sp_cons)($mf.libraries))($lib),
          }));
        }
        if (("$sp$ModulesFile$Dir" === ($$try0)[0])) {
          const $dir = ($$try0)[1];
          return (Object.assign)({}, $mf, ({
            sourceDirs: ((sp_cons)($mf.sourceDirs))($dir),
          }));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/ModulesFile.sp 149:8', (sp_toHuman)($$try0));
      });
    });
    return (($corelib$Result$map)((($rootEntries) => {
      return ((($corelib$List$for)($rootEntries))($insert))($sp$ModulesFile$initModulesFile);
    })))(((($sp$SPON$read)($sp$ModulesFile$modulesFileReader))($sponName))($sponContent));
  });
});

const $sp$ModulesFile$insertModule = (($source) => {
  return (($mod) => {
    return (($meta) => {
      const $visibleAs = $mod.visibleAs;
      const $umr = (($sp$Types$Meta$UMR)($source))($mod.path);
      const $insertGlobal = (($varName) => {
        return (($corelib$Dict$insert)($varName))((($sp$Types$Meta$USR)($umr))($varName));
      });
      return ({
        globalTypes: ((($corelib$List$for)($mod.globalTypes))($insertGlobal))($meta.globalTypes),
        globalValues: ((($corelib$List$for)($mod.globalValues))($insertGlobal))($meta.globalValues),
        moduleVisibleAsToUmr: ((($corelib$Dict$insert)($visibleAs))($umr))($meta.moduleVisibleAsToUmr),
        umrToModuleVisibleAs: ((($corelib$Dict$insert)($umr))($visibleAs))($meta.umrToModuleVisibleAs),
      });
    });
  });
});

const $sp$ModulesFile$insertLibrary = (($lib) => {
  return (($meta) => {
    return (((sp_not_equal)("spcore"))($lib.source)
      ? (sp_todo)(("Library source `" + ($lib.source + "` is not supported.")))
      : ((($corelib$List$for)($lib.modules))(($sp$ModulesFile$insertModule)($sp$Types$Meta$Core)))($meta));
  });
});

const $sp$ModulesFile$insertModules = (($sd) => {
  return (($corelib$List$for)($sd.modules))(($sp$ModulesFile$insertModule)(($sp$Types$Meta$SourceDir)($sd.path)));
});

const $sp$Types$Meta$init = ({
  globalTypes: $corelib$Dict$empty,
  globalValues: $corelib$Dict$empty,
  moduleVisibleAsToUmr: $corelib$Dict$empty,
  umrToModuleVisibleAs: $corelib$Dict$empty,
});

const $sp$ModulesFile$toMeta = (($mf) => {
  return ((($corelib$List$for)($mf.sourceDirs))($sp$ModulesFile$insertModules))(((($corelib$List$for)($mf.libraries))($sp$ModulesFile$insertLibrary))($sp$Types$Meta$init));
});

const $sp$ModulesFile$textToMeta = (($sponName) => {
  return (($sponContent) => {
    return (($corelib$Result$map)($sp$ModulesFile$toMeta))((($sp$ModulesFile$textToModulesFile)($sponName))($sponContent));
  });
});

const $sp$Compiler$TestHelpers$meta = ((() => {
  const $eenv = ({
    moduleByName: (($corelib$Dict$singleton)("DefaultModules"))(({
      content: $sp$DefaultModules$asText,
      fsPath: "<DefaultModules>",
    })),
  });
  const $metaResult = (($corelib$Result$mapError)((($e) => {
    return ($sp$Compiler$TestHelpers$formattedToStrippedText)((($sp$Compiler$Error$toFormattedText)($eenv))($e));
  })))((($sp$ModulesFile$textToMeta)("DefaultModules"))($sp$DefaultModules$asText));
  const $$try0 = $metaResult;
  if (("$corelib$Result$Err" === ($$try0)[0])) {
    const $e = ($$try0)[1];
    ((sp_log)(("Error in DefaultModules.sp: " + $e)))(null);
    return (sp_todo)("error loading DefaultModules.sp");
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try0)[0])) {
    const $m = ($$try0)[1];
    return $m;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TestHelpers.sp 46:4', (sp_toHuman)($$try0));
}))();

const $sp$Compiler$TestHelpers$source = ($sp$Types$Meta$SourceDir)("<Test>");

const $sp$Compiler$MakeCanonical_Test$params = ({
  meta: $sp$Compiler$TestHelpers$meta,
  name: $sp$Compiler$TestHelpers$moduleName,
  source: $sp$Compiler$TestHelpers$source,
  stripLocations: true,
});

const $sp$Compiler$MakeCanonical_Test$textToModule = (($code) => {
  return (($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($sp$Compiler$MakeCanonical_Test$params))($code));
});

const $sp$Compiler$MakeCanonical_Test$firstDefinition = (($code) => {
  return (($corelib$Result$onOk)((($mod) => {
    return (($corelib$Result$fromMaybe)("firstDefinition fail"))(($corelib$List$head)(($corelib$Dict$values)($mod.valueDefs)));
  })))(($sp$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sp$Compiler$MakeCanonical_Test$firstEvaluation = (($name) => {
  return (($code) => {
    return (($corelib$Result$onOk)((($def) => {
      return ($corelib$Result$Ok)($def.body);
    })))(($sp$Compiler$MakeCanonical_Test$firstDefinition)($code));
  });
});

const $sp$Test$isOk = ($sp$Test$CodeExpectation)((($toText) => {
  return (($result) => {
    const $$try0 = $result;
    if (("$corelib$Result$Err" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return ($corelib$Maybe$Just)($e);
    }
    if (("$corelib$Result$Ok" === ($$try0)[0])) {
      const $actualOk = ($$try0)[1];
      return $corelib$Maybe$Nothing;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 69:8', (sp_toHuman)($$try0));
  });
}));

const $sp$Compiler$MakeCanonical_Test$annotations = (($sp$Test$Group)("Annotations"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation on mutable value"))("x =\n  a as Number @=\n    3\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation on immutable value"))("b as Number =\n  3"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("b")))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$MakeCanonical_Test$p = $sp$Types$Pos$T;

const $sp$Test$freeform = (($test) => {
  return ($sp$Test$CodeExpectation)((($toText) => {
    return (($result) => {
      const $$try0 = $result;
      if (("$corelib$Result$Err" === ($$try0)[0])) {
        const $e = ($$try0)[1];
        return ($corelib$Maybe$Just)($e);
      }
      if (("$corelib$Result$Ok" === ($$try0)[0])) {
        const $actualOk = ($$try0)[1];
        return ($test)($actualOk);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 62:4', (sp_toHuman)($$try0));
    });
  }));
});

const $sp$Compiler$MakeCanonical_Test$shouldHaveSameAB = (($getter) => {
  return ($sp$Test$freeform)(((a$$) => {
    const $b = a$$.second;
    const $a = a$$.first;
    return (((sp_equal)(($getter)($b)))(($getter)($a))
      ? $corelib$Maybe$Nothing
      : ($corelib$Maybe$Just)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("The two don't match:"))((($core$SPCore$Cons)((sp_toHuman)(($getter)($a))))((($core$SPCore$Cons)((sp_toHuman)(($getter)($b))))($core$SPCore$Nil))))));
  }));
});

const $sp$Compiler$MakeCanonical_Test$transformAB = (($code) => {
  const $findAB = (($mod) => {
    const $$try0 = ((list_sortBy)((($def) => {
      return $def.pattern;
    })))(($corelib$Dict$values)($mod.valueDefs));
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[2])[2])[0])))) {
      const $b = (($$try0)[2])[1];
      const $a = ($$try0)[1];
      return ($corelib$Maybe$Just)(({
        first: $a,
        second: $b,
      }));
    }
    if (true) {
      return $corelib$Maybe$Nothing;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical_Test.sp 48:8', (sp_toHuman)($$try0));
  });
  return (($corelib$Result$onOk)((($x) => {
    return (($corelib$Result$fromMaybe)("findAB fail"))(($findAB)($x));
  })))(($sp$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sp$Compiler$MakeCanonical_Test$binops = (($sp$Test$Group)("Binops"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("left associativity"))("a = v >> f >> g\nb = (v >> f) >> g"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("right associativity"))("a = v :: f :: g\nb = v :: (f :: g)"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("precedence"))("a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP functional notation"))("a = (-)"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)("-")),
}))))))($core$SPCore$Nil)))));

const $sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps = (($code) => {
  return (($corelib$Result$map)((($v) => {
    return (Object.assign)({}, $v, ({
      directConsDeps: $corelib$Dict$empty,
      directTypeDeps: $corelib$Dict$empty,
      directValueDeps: $corelib$Dict$empty,
    }));
  })))(($sp$Compiler$MakeCanonical_Test$firstDefinition)($code));
});

const $sp$Compiler$MakeCanonical_Test$functions = (($sp$Test$Group)("Functions"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("[rec] lambda with two arguments"))("f =\n  a: b: 1"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("f")))($sp$Test$isOk)))($core$SPCore$Nil));

const $sp$Compiler$TestHelpers$boolType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("Bool")))($core$SPCore$Nil);

const $sp$Compiler$TestHelpers$moduleUmr = (($sp$Types$Meta$UMR)($sp$Compiler$TestHelpers$source))($sp$Compiler$TestHelpers$moduleName);

const $sp$Compiler$TestHelpers$rootLocal = (($name) => {
  return ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))($name));
});

const $sp$Compiler$MakeCanonical_Test$lists = (($sp$Test$Group)("Lists"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("list type sugar"))("l as [ Bool ] =\n  l"))($sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps))(($sp$Test$isOkAndEqualTo)(({
  body: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("l"),
  })),
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
  mutable: false,
  native: false,
  nonFn: $corelib$Dict$empty,
  parentDefinitions: $core$SPCore$Nil,
  pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)("l")))(($corelib$Maybe$Just)(($sp$Compiler$CoreTypes$list)($sp$Compiler$TestHelpers$boolType))),
})))))($core$SPCore$Nil));

const $sp$Compiler$MakeCanonical_Test$moduleAndAttributePaths = ((() => {
  const $accept = (($s) => {
    return (((($sp$Compiler$MakeCanonical_Test$codeTest)($s))(("a = " + $s)))($sp$Compiler$MakeCanonical_Test$firstDefinition))($sp$Test$isOk);
  });
  const $reject = (($s) => {
    return (($m) => {
      return (((($sp$Compiler$MakeCanonical_Test$codeTest)($s))(("a = " + $s)))($sp$Compiler$MakeCanonical_Test$firstDefinition))(($sp$Test$errorContains)((($core$SPCore$Cons)($m))($core$SPCore$Nil)));
    });
  });
  return (($sp$Test$Group)("Module and Attribute Paths"))((($core$SPCore$Cons)(($accept)("blah.blah.blah")))((($core$SPCore$Cons)((($reject)("Blah.Blah.blah"))("constructor")))((($core$SPCore$Cons)((($reject)("blah.Blah.blah"))("case")))((($core$SPCore$Cons)((($reject)("List.blah.Blah"))("lower")))((($core$SPCore$Cons)((($reject)("List..blah"))("space")))((($core$SPCore$Cons)((($reject)(".Blah"))("upper")))((($core$SPCore$Cons)((($reject)(".blah.blah"))("shorthand")))((($core$SPCore$Cons)((($reject)(".blah"))("shorthand")))((($core$SPCore$Cons)((($reject)("..."))("")))((($core$SPCore$Cons)(($accept)("x .. y")))($core$SPCore$Nil)))))))))));
}))();

const $sp$Compiler$MakeCanonical_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("[reg] record patterns are NOT extensible"))("a =\n  { b with c } = d"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("with"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$MakeCanonical_Test$pipes = (($sp$Test$Group)("Pipes"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("sendLeft is inlined"))("a = thing >> function"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Call)($sp$Compiler$MakeCanonical_Test$p))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("function"),
}))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("thing"),
}))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("sendRight is inlined"))("a = function << thing"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Call)($sp$Compiler$MakeCanonical_Test$p))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("function"),
}))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("thing"),
}))))))))($core$SPCore$Nil)));

const $sp$Compiler$MakeCanonical_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("functional update"))("a = { m with b, c = 1 }"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("m"),
}))))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "c",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "b",
  second: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("b"),
  })),
})))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("update shorthand"))("b = { a.k with y = .x }"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("b")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)(({
  attrPath: (($core$SPCore$Cons)("k"))($core$SPCore$Nil),
  ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
}))))((($corelib$Dict$singleton)("y"))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: (($core$SPCore$Cons)("k"))((($core$SPCore$Cons)("x"))($core$SPCore$Nil)),
  ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
}))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation, extensible"))("a as { b with x as Bool } =\n  a"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("disabled"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$TestHelpers$numberType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("Number")))($core$SPCore$Nil);

const $sp$Compiler$MakeCanonical_Test$tuples = (($sp$Test$Group)("Tuples"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple2"))("a = 1 & 2"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "first",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "second",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(2),
})))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple3"))("a = 1 & 2 & 3"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "first",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "second",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(2),
})))((($core$SPCore$Cons)(({
  first: "third",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(3),
})))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple4"))("a = 1 & 2 & 3 & 4"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("use a record"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple2 type"))("a as Number & Number =\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps))(($sp$Test$isOkAndEqualTo)(({
  body: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
  })),
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
  mutable: false,
  native: false,
  nonFn: $corelib$Dict$empty,
  parentDefinitions: $core$SPCore$Nil,
  pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)("a")))(($corelib$Maybe$Just)(((($sp$Types$CanonicalAst$TypeRecord)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($sp$Compiler$TestHelpers$numberType))(((($corelib$Dict$insert)("first"))($sp$Compiler$TestHelpers$numberType))($corelib$Dict$empty))))),
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple4, type"))("a as Blah & Blah & Blah & Blah =\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinition))(($sp$Test$errorContains)((($core$SPCore$Cons)("Use a record"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$MakeCanonical_Test$unionTypes = (($sp$Test$Group)("Union types"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP tuples op precedence"))("union A = X Bool & Bool"))($sp$Compiler$MakeCanonical_Test$textToModule))(($sp$Test$errorContains)((($core$SPCore$Cons)("operators"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("Tuples op precedence works with parens"))("union A = X (Bool & Bool)"))($sp$Compiler$MakeCanonical_Test$textToModule))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP [reg] Should reject uppercase arg name"))("union Outcome Token output = A"))($sp$Compiler$MakeCanonical_Test$textToModule))(($sp$Test$errorContains)((($core$SPCore$Cons)("Token"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$MakeCanonical_Test$tests = (($sp$Test$Group)("MakeCanonical"))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$unionTypes))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$binops))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$tuples))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$lists))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$moduleAndAttributePaths))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$records))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$annotations))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$pipes))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$functions))($core$SPCore$Nil)))))))))));

const $sp$Compiler$Parser$binopInsideParens = (($env) => {
  return (($sp$Compiler$Parser$andThen)(((end$$) => {
    const $k = (end$$)[3];
    const $end = (end$$)[2];
    const $start = (end$$)[1];
    const $$try0 = $k;
    if (("$sp$Types$Token$Binop" === ($$try0)[0])) {
      const $binop = ($$try0)[1];
      return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PrefixBinop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($binop.symbol));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1204:4', (sp_toHuman)($$try0));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$inlineOrIndented = (($p) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)($p)))((($core$SPCore$Cons)($p))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$Parser_Test$asDefinition = (($s) => {
  const $$try0 = $s;
  if (("$sp$Types$FormattableAst$Definition" === ($$try0)[0])) {
    const $a = ($$try0)[2];
    return ($corelib$Result$Ok)($a);
  }
  if (true) {
    return ($corelib$Result$Err)("Test says: no def");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 29:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$Parser_Test$firstStatement = (($code) => {
  const $grabFirst = (($stats) => {
    const $$try0 = $stats;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return ($corelib$Result$Err)("Test says: no statements");
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $head = ($$try0)[1];
      return ($corelib$Result$Ok)($head);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 52:8', (sp_toHuman)($$try0));
  });
  return (($corelib$Result$onOk)($grabFirst))((($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))((($sp$Compiler$Parser$textToFormattableModule)(({
    name: "Test",
    stripLocations: true,
  })))($code)));
});

const $sp$Compiler$Parser_Test$firstAnnotation = (($code) => {
  const $grabAnnotation = (($def) => {
    const $$try0 = $def.pattern;
    if ((("$sp$Types$FormattableAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[4])[0]))) {
      const $ty = (($$try0)[4])[1];
      const $mutable = ($$try0)[3];
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($corelib$Result$Ok)($ty);
    }
    if (true) {
      return ($corelib$Result$Err)("no annotation");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 94:8', (sp_toHuman)($$try0));
  });
  return (($corelib$Result$onOk)($grabAnnotation))((($corelib$Result$onOk)($sp$Compiler$Parser_Test$asDefinition))(($sp$Compiler$Parser_Test$firstStatement)($code)));
});

const $sp$Compiler$Parser_Test$p = $sp$Types$Pos$T;

const $sp$Compiler$Parser_Test$typeConstant = (($name) => {
  return (((($sp$Types$FormattableAst$TypeConstant)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))($name))($core$SPCore$Nil);
});

const $sp$Compiler$Parser_Test$annotations = (($sp$Test$Group)("Annotations"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Mutability 1"))("a as Number @: Int: None =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Number")))(true))((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int")))(false))(($sp$Compiler$Parser_Test$typeConstant)("None")))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Mutability 2"))("a as Number: Int @: None =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Number")))(false))((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int")))(true))(($sp$Compiler$Parser_Test$typeConstant)("None")))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Tuple precedence"))("a as Int & Int: Bool =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$TypeTuple)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)(($sp$Compiler$Parser_Test$typeConstant)("Int")))((($core$SPCore$Cons)(($sp$Compiler$Parser_Test$typeConstant)("Int")))($core$SPCore$Nil)))))(false))(($sp$Compiler$Parser_Test$typeConstant)("Bool"))))))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$asEvaluation = (($s) => {
  const $$try0 = $s;
  if (("$sp$Types$FormattableAst$Evaluation" === ($$try0)[0])) {
    const $a = ($$try0)[2];
    return ($corelib$Result$Ok)($a);
  }
  if (true) {
    return ($corelib$Result$Err)("Test says: no eval");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 39:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$Parser_Test$firstDefinition = (($code) => {
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asDefinition))(($sp$Compiler$Parser_Test$firstStatement)($code));
});

const $sp$Compiler$Parser_Test$firstEvaluationOfDefinition = (($code) => {
  const $grabFirst = (($def) => {
    const $$try0 = $def.body;
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return ($corelib$Result$Err)("Test says: empty def body");
    }
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $head = ($$try0)[1];
      return ($corelib$Result$Ok)($head);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 79:8', (sp_toHuman)($$try0));
  });
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asEvaluation))((($corelib$Result$onOk)($grabFirst))(($sp$Compiler$Parser_Test$firstDefinition)($code)));
});

const $sp$Compiler$Parser_Test$binops = ((() => {
  const $sendBtoC = (($b) => {
    return (($c) => {
      return ((($sp$Types$FormattableAst$Binop)($sp$Compiler$Parser_Test$p))($sp$Types$Op$Pipe))(({
        first: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil),
        second: (($core$SPCore$Cons)(({
          first: $sp$Prelude$sendRight,
          second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil),
        })))($core$SPCore$Nil),
      }));
    });
  });
  const $sendBtoCtoD = (($b) => {
    return (($c) => {
      return (($d) => {
        return ((($sp$Types$FormattableAst$Binop)($sp$Compiler$Parser_Test$p))($sp$Types$Op$Pipe))(({
          first: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil),
          second: (($core$SPCore$Cons)(({
            first: $sp$Prelude$sendRight,
            second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil),
          })))((($core$SPCore$Cons)(({
            first: $sp$Prelude$sendRight,
            second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("d"))($core$SPCore$Nil),
          })))($core$SPCore$Nil)),
        }));
      });
    });
  });
  return (($sp$Test$Group)("Binops"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("no indent"))("a = b >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(5))(10)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("assignment indent"))("a =\n    b >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(9))(14)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pipe indent"))("a =\n    b\n      >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(9))(20)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pipe indent"))("a =\n    b\n      >> c\n      >> d"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)(((($sendBtoCtoD)(9))(20))(31)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pyramid indent"))("a =\n    b\n      >> c\n        >> d"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)(((($sendBtoCtoD)(9))(20))(33)))))($core$SPCore$Nil))))));
}))();

const $sp$Compiler$Parser_Test$firstEvaluation = (($code) => {
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asEvaluation))(($sp$Compiler$Parser_Test$firstStatement)($code));
});

const $sp$Compiler$Parser_Test$ifs = (($sp$Test$Group)("Ifs"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("inline"))("a = if a then b else c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP multiline, formatted"))("x =\n    if a then\n        b\n    else\n        c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, compact"))("x =\n  if a then b\n  else c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$lambdas = (($sp$Test$Group)("lambdas"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Inline nesting"))("a: b: 3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Block nesting"))("a:\n  b:\n    3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Sibling nesting"))("a:\nb:\n3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Tuple has precedence over lambda"))("x =\n  a & b: a"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] pass to function without parens"))("i =\n  x @= 1\n  xxx y: y"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil))))));

const $sp$Compiler$Parser_Test$lists = (($sp$Test$Group)("Lists"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Inline"))("[1, 2]"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Multiline canonical"))("a =\n  [\n  , 1\n  , 2\n  ]"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Multiline compact"))("a = [\n  , 1\n  , 2\n  ]"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$parens = (($sp$Test$Group)("Parens"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Can exist on multiple lines even when useless"))("tests =\n    (Ok\n    )"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Can exist on multiple lines"))("tests =\n    blah\n        (Ok\n        )"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list unpacking"))("[a, b] = x"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$PatternList)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))((($core$SPCore$Cons)((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list unpacking, inner block"))("x =\n   [ a, b ] = c"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("record unpacking"))("{ a, b } = x"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$PatternRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("a"),
    second: $corelib$Maybe$Nothing,
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("b"),
    second: $corelib$Maybe$Nothing,
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("record unpacking, inner block"))("x =\n  { a, b } = c"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))($sp$Test$isOk)))($core$SPCore$Nil)))));

const $sp$Compiler$Parser_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("inline"))("a = { x = 1 }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline"))("a =\n  {\n  , x = 1\n  , y = 2\n  }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("y"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")),
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline compact"))("a = {\n  , x = 1\n  , y = 2\n  }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("y"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")),
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Annotation, inline"))("a as { x as Bool } =\n  a"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Annotation, own line"))("a as\n   { x as Bool }\n   =\n   1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Annotation, multiline"))("a as {\n   , x as Bool\n   }\n      =\n      a"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, inline"))("a = { b with c }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, as block"))("a =\n  { b with c }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, as block"))("a =\n  { b with c = 1 }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] real-world use"))("a =\n  { state with\n      , pos = endPos\n      , code = rest\n      , accum =\n          { kind = Token.Comment\n          , start = startPos\n          , end = endPos\n          }\n              :: state.accum\n  }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)))))))))));

const $sp$Compiler$Parser_Test$tries = (($sp$Test$Group)("Try"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, formatted"))("x =\n  try a as\n    b:\n      c\n    d:\n      e"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, compact"))("x =\n  try a as\n    b: c\n    d: e"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$unionDefs = ((() => {
  const $asTypeDef = (($s) => {
    const $$try0 = $s;
    if (("$sp$Types$FormattableAst$UnionDef" === ($$try0)[0])) {
      const $a = ($$try0)[2];
      return ($corelib$Result$Ok)($a);
    }
    if (true) {
      return ($corelib$Result$Err)("no type def");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 322:8', (sp_toHuman)($$try0));
  });
  const $firstTypeDef = (($x) => {
    return (($corelib$Result$onOk)($asTypeDef))(($sp$Compiler$Parser_Test$firstStatement)($x));
  });
  return (($sp$Test$Group)("Type Definitions"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Parse inline def"))("union A b c = V1 b, V2 c, V3, V4 b c"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: (($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)),
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V1"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("b")))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V2"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("c")))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V3"),
      second: $core$SPCore$Nil,
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V4"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("b")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("c")))($core$SPCore$Nil)),
    })))($core$SPCore$Nil)))),
    name: "A",
  })))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Parse multiline def"))("union A =\n   , V1\n   , V2"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: $core$SPCore$Nil,
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V1"),
      second: $core$SPCore$Nil,
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V2"),
      second: $core$SPCore$Nil,
    })))($core$SPCore$Nil)),
    name: "A",
  })))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list argument"))("union A = A [Int]"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: $core$SPCore$Nil,
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("A"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeList)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int"))))($core$SPCore$Nil),
    })))($core$SPCore$Nil),
    name: "A",
  })))))($core$SPCore$Nil))));
}))();

const $sp$Compiler$Parser_Test$values = (($sp$Test$Group)("Values"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] Unop"))("a = f -n"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] deal with spurious NewSiblingLine introduced by inline comments"))("library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\""))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$tests = (($sp$Test$Group)("Parser"))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$values))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$parens))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$lambdas))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$annotations))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$unionDefs))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$lists))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$records))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$ifs))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$tries))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$binops))($core$SPCore$Nil))))))))))));

const $sp$Compiler$Pipeline$insertUnionConstructors = (($typeDef) => {
  return (($constructors) => {
    const $$try0 = $typeDef;
    if (("$sp$Types$CanonicalAst$TypeDefAlias" === ($$try0)[0])) {
      return $constructors;
    }
    if (("$sp$Types$CanonicalAst$TypeDefUnion" === ($$try0)[0])) {
      const $def = ($$try0)[1];
      const umr$$ = $def.usr;
      const $umr = (umr$$)[1];
      return ((($corelib$Dict$for)($def.constructors))((($name) => {
        return ($corelib$Dict$insert)((($sp$Types$Meta$USR)($umr))($name));
      })))($constructors);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Pipeline.sp 31:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$Pipeline$coreConstructors = ((($corelib$List$for)($sp$Compiler$CoreTypes$allDefs))((($u) => {
  return ($sp$Compiler$Pipeline$insertUnionConstructors)(($sp$Types$CanonicalAst$TypeDefUnion)($u));
})))($corelib$Dict$empty);

const $sp$Compiler$Pipeline$coreTypes = ((($corelib$List$for)($sp$Compiler$CoreTypes$allDefs))((($def) => {
  return (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefUnion)($def));
})))($corelib$Dict$empty);

const $sp$Prelude$functions = (($core$SPCore$Cons)($sp$Prelude$compare))((($core$SPCore$Cons)($sp$Prelude$debugTodo))((($core$SPCore$Cons)($sp$Prelude$debugLog))((($core$SPCore$Cons)($sp$Prelude$debugToHuman))((($core$SPCore$Cons)($sp$Prelude$debugBenchStart))((($core$SPCore$Cons)($sp$Prelude$debugBenchStop))($core$SPCore$Nil))))));

const $sp$Types$CanonicalAst$typeTyvars = (($ty) => {
  const $$try0 = $ty;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
    const $name = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($corelib$Dict$singleton)($name))($pos);
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
    const $to = ($$try0)[4];
    const $fromIsMutable = ($$try0)[3];
    const $from = ($$try0)[2];
    return (($corelib$Dict$join)(($sp$Types$CanonicalAst$typeTyvars)($from)))(($sp$Types$CanonicalAst$typeTyvars)($to));
  }
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
    const $args = ($$try0)[3];
    const $ref = ($$try0)[2];
    const $pos = ($$try0)[1];
    return ((($corelib$List$for)($args))((($a) => {
      return ($corelib$Dict$join)(($sp$Types$CanonicalAst$typeTyvars)($a));
    })))($corelib$Dict$empty);
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
    const $t = ($$try0)[3];
    const $path = ($$try0)[2];
    return ($sp$Types$CanonicalAst$typeTyvars)($t);
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
    const $attrs = ($$try0)[3];
    const $extensible = ($$try0)[2];
    const $pos = ($$try0)[1];
    const $init = ((() => {
      const $$try1 = $extensible;
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return $corelib$Dict$empty;
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $name = ($$try1)[1];
        return (($corelib$Dict$singleton)($name))($pos);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 301:16', (sp_toHuman)($$try1));
    }))();
    return ((($corelib$Dict$for)($attrs))((($n) => {
      return (($t) => {
        return ($corelib$Dict$join)(($sp$Types$CanonicalAst$typeTyvars)($t));
      });
    })))($init);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 285:4', (sp_toHuman)($$try0));
});

const $sp$Types$CanonicalAst$getFreeTypeVars = (($nonFreeTyvars) => {
  return (($nonFn) => {
    return (($ty) => {
      const $posToTyvar = (($name) => {
        return (($pos) => {
          return ({
            nonFn: (($corelib$Dict$member)($name))($nonFn),
          });
        });
      });
      return (($corelib$Dict$map)($posToTyvar))((($corelib$Dict$diff)(($sp$Types$CanonicalAst$typeTyvars)($ty)))($nonFreeTyvars));
    });
  });
});

const $sp$Compiler$Pipeline$coreVariables = ((() => {
  const $insertUnop = (($unop) => {
    const $ref = ($sp$Types$CanonicalAst$RefRoot)(($sp$Types$Meta$spCoreUSR)($unop.symbol));
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: $corelib$Dict$empty,
      isMutable: false,
      ty: $unop.type,
    });
    return (($corelib$Dict$insert)($ref))($iv);
  });
  const $insertBinop = (($symbol) => {
    return (($binop) => {
      const $ref = ($sp$Types$CanonicalAst$RefRoot)(($sp$Types$Meta$spCoreUSR)($symbol));
      const $iv = ({
        definedAt: $sp$Types$Pos$N,
        freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))(($corelib$Set$fromList)($binop.nonFn)))($binop.type),
        isMutable: false,
        ty: $binop.type,
      });
      return (($corelib$Dict$insert)($ref))($iv);
    });
  });
  const $insertCoreFunction = (($coreFn) => {
    const $ref = ($sp$Types$CanonicalAst$RefRoot)($coreFn.usr);
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))(($corelib$Set$fromList)($coreFn.nonFn)))($coreFn.type),
      isMutable: false,
      ty: $coreFn.type,
    });
    return (($corelib$Dict$insert)($ref))($iv);
  });
  return ((($corelib$List$for)($sp$Prelude$functions))($insertCoreFunction))(((($corelib$Dict$for)($sp$Prelude$binops))($insertBinop))((($insertUnop)($sp$Prelude$unaryMinus))((($insertUnop)($sp$Prelude$unaryPlus))($corelib$Dict$empty))));
}))();

const $sp$Types$CanonicalAst$patternNamedTypes = (($p) => {
  const $$try0 = $p;
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Nothing" === (($$try0)[2])[0]))) {
    const $pos = ($$try0)[1];
    return $corelib$Dict$empty;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0]) && ("$corelib$Maybe$Just" === (($$try0)[2])[0]))) {
    const $maybeType = ($$try0)[3];
    const $n = (($$try0)[2])[1];
    const $pos = ($$try0)[1];
    return (($corelib$Dict$singleton)($n))(({
      first: $pos,
      second: $maybeType,
    }));
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $corelib$Dict$empty;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $corelib$Dict$empty;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
    const $ps = ($$try0)[3];
    const $path = ($$try0)[2];
    const $pos = ($$try0)[1];
    return ((($corelib$List$for)($ps))((($x) => {
      return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNamedTypes)($x));
    })))($corelib$Dict$empty);
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
    const $ps = ($$try0)[2];
    const $pos = ($$try0)[1];
    return ((($corelib$Dict$for)($ps))((($k) => {
      return (($v) => {
        return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNamedTypes)($v));
      });
    })))($corelib$Dict$empty);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 223:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$Pipeline$expandAndInsertModuleAnnotations = (($types) => {
  return (($module) => {
    const $insertName = (($def) => {
      return (($name) => {
        return ((maybeType$$) => {
          const $maybeType = maybeType$$.second;
          const $pos = maybeType$$.first;
          return (($d) => {
            const $$try0 = $maybeType;
            if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
              return ($corelib$Result$Ok)($d);
            }
            if (("$corelib$Maybe$Just" === ($$try0)[0])) {
              const $rawType = ($$try0)[1];
              return (($corelib$Result$onOk)((($type) => {
                const $ref = ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($module.umr))($name));
                const $iv = ({
                  definedAt: $pos,
                  freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($def.nonFn))($type),
                  isMutable: false,
                  ty: $type,
                });
                return ($corelib$Result$Ok)(((($corelib$Dict$insert)($ref))($iv))($d));
              })))((($sp$Compiler$ExpandTypes$expandAnnotation)($types))($rawType));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Pipeline.sp 54:8', (sp_toHuman)($$try0));
          });
        });
      });
    });
    const $insertValueDef = (($def) => {
      return (($corelib$Dict$forRes)(($sp$Types$CanonicalAst$patternNamedTypes)($def.pattern)))(($insertName)($def));
    });
    return (($corelib$Dict$forRes)($module.valueDefs))((() => {
      return $insertValueDef;
    }));
  });
});

const $sp$Compiler$Pipeline$globalExpandedTypes = (($allModules) => {
  return (($corelib$Result$onOk)((($types) => {
    const $constructors = ((($corelib$Dict$for)($types))((() => {
      return $sp$Compiler$Pipeline$insertUnionConstructors;
    })))($sp$Compiler$Pipeline$coreConstructors);
    return (($corelib$Result$onOk)((($instanceVariables) => {
      return ($corelib$Result$Ok)(({
        constructors: $constructors,
        instanceVariables: $instanceVariables,
        types: $types,
      }));
    })))(((($corelib$Dict$forRes)($allModules))((() => {
      return ($sp$Compiler$Pipeline$expandAndInsertModuleAnnotations)($types);
    })))($sp$Compiler$Pipeline$coreVariables));
  })))(($sp$Compiler$ExpandTypes$expandAllTypes)(((($corelib$Dict$for)($allModules))((() => {
    return $sp$Compiler$ExpandTypes$insertModuleTypes;
  })))($sp$Compiler$Pipeline$coreTypes)));
});

const $sp$Compiler$TestHelpers$listType = (($itemType) => {
  return ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("List")))((($core$SPCore$Cons)($itemType))($core$SPCore$Nil));
});

const $sp$Compiler$TestHelpers$localType = (($name) => {
  return (($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))($name);
});

const $sp$Compiler$TestHelpers$noneType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("None")))($core$SPCore$Nil);

const $sp$Compiler$TypeCheck$insertError = (($e) => {
  return (($state) => {
    return ({
      first: null,
      second: (Object.assign)({}, $state, ({
        errors: ((sp_cons)($state.errors))($e),
      })),
    });
  });
});

const $sp$Compiler$TypeCheck$addCheckError = (($pos) => {
  return (($message) => {
    return ($sp$Compiler$TypeCheck$insertError)((($sp$Compiler$Error$Simple)($pos))((() => {
      return $message;
    })));
  });
});

const $sp$StateMonad$andThen = (($f) => {
  return (($m) => {
    return (($state0) => {
      const a$$ = ($m)($state0);
      const $state1 = a$$.second;
      const $a = a$$.first;
      return (($f)($a))($state1);
    });
  });
});

const $sp$Compiler$TypeCheck$andThen = $sp$StateMonad$andThen;

const $sp$StateMonad$return = (($a) => {
  return (($state) => {
    return ({
      first: $a,
      second: $state,
    });
  });
});

const $sp$StateMonad$list_foldl = (($f) => {
  return (($items) => {
    return (($accum) => {
      const $$try0 = $items;
      if (("$core$SPCore$Nil" === ($$try0)[0])) {
        return ($sp$StateMonad$return)($accum);
      }
      if (("$core$SPCore$Cons" === ($$try0)[0])) {
        const $tail = ($$try0)[2];
        const $head = ($$try0)[1];
        return (($sp$StateMonad$andThen)((($sp$StateMonad$list_foldl)($f))($tail)))((($f)($head))($accum));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/StateMonad.sp 81:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$TypeCheck$list_for = (($l) => {
  return (($f) => {
    return (($sp$StateMonad$list_foldl)($f))($l);
  });
});

const $sp$Compiler$TypeCheck$return = $sp$StateMonad$return;

const $sp$Compiler$TypeCheck$addCheckConstructorError = (($pos) => {
  return (($env) => {
    return (($remainingArgs) => {
      return (($message) => {
        return (($sp$Compiler$TypeCheck$andThen)((() => {
          return ((($sp$Compiler$TypeCheck$list_for)($remainingArgs))((($argPattern) => {
            return (($envX) => {
              return ($sp$Compiler$TypeCheck$return)($envX);
            });
          })))($env);
        })))((($sp$Compiler$TypeCheck$addCheckError)($pos))($message));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$newName = (($f) => {
  return (($state) => {
    return ({
      first: ($f)((text_fromNumber)($state.nextName)),
      second: (Object.assign)({}, $state, ({
        nextName: ($state.nextName + 1),
      })),
    });
  });
});

const $sp$Compiler$TypeCheck$newType = (($pos) => {
  return ($sp$Compiler$TypeCheck$newName)(($sp$Types$CanonicalAst$TypeVariable)($pos));
});

const $sp$Compiler$TypeCheck$addErrorWithEEnv = (($pos) => {
  return (($messageConstructor) => {
    return (($sp$Compiler$TypeCheck$andThen)((() => {
      return ($sp$Compiler$TypeCheck$newType)($pos);
    })))(($sp$Compiler$TypeCheck$insertError)((($sp$Compiler$Error$Simple)($pos))($messageConstructor)));
  });
});

const $sp$Compiler$TypeCheck$addError = (($pos) => {
  return (($message) => {
    return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))((() => {
      return $message;
    }));
  });
});

const $sp$StateMonad$get = (($getter) => {
  return (($state) => {
    return ({
      first: ($getter)($state),
      second: $state,
    });
  });
});

const $sp$Compiler$TypeCheck$get = $sp$StateMonad$get;

const $sp$Compiler$TypeCheck$replaceTypeVariables = (($subs) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      const $args = ($$try0)[3];
      const $ref = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($sp$Types$CanonicalAst$TypeConstant)($pos))($ref))((($corelib$List$map)(($sp$Compiler$TypeCheck$replaceTypeVariables)($subs)))($args));
    }
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $$try1 = (($corelib$Dict$get)($name))($subs);
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $substitutionType = ($$try1)[1];
        return $substitutionType;
      }
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return $ty;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2190:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $fromIsMutable = ($$try0)[3];
      const $from = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($from)))($fromIsMutable))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($to));
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      const $t = ($$try0)[3];
      const $path = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((($sp$Types$CanonicalAst$TypeAlias)($pos))($path))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($t));
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $extensible = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $$try1 = (($corelib$Maybe$andThen)((($name) => {
        return (($corelib$Dict$get)($name))($subs);
      })))($extensible);
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible))((($corelib$Dict$map)((($name) => {
          return ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs);
        })))($attrs));
      }
      if ((("$corelib$Maybe$Just" === ($$try1)[0]) && ("$sp$Types$CanonicalAst$TypeVariable" === (($$try1)[1])[0]))) {
        const $n = (($$try1)[1])[2];
        const $p = (($$try1)[1])[1];
        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($n)))((($corelib$Dict$map)((($name) => {
          return ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs);
        })))($attrs));
      }
      if ((("$corelib$Maybe$Just" === ($$try1)[0]) && ("$sp$Types$CanonicalAst$TypeRecord" === (($$try1)[1])[0]))) {
        const $attrs2 = (($$try1)[1])[3];
        const $ext2 = (($$try1)[1])[2];
        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($ext2))((($corelib$Dict$map)((($name) => {
          return ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs);
        })))((($corelib$Dict$join)($attrs2))($attrs)));
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $what = ($$try1)[1];
        ((sp_log)("what"))((sp_toHuman)($what));
        return (sp_todo)("replacing record extension with non-var");
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2209:12', (sp_toHuman)($$try1));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2185:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$applySubsToType = (($ty) => {
  return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
    return ($sp$Compiler$TypeCheck$return)((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($ty));
  })))(($sp$Compiler$TypeCheck$get)((($x) => {
    return $x.substitutions;
  })));
});

const $sp$Compiler$TypeCheck$errorTodo = (($pos) => {
  return (($message) => {
    return (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)($message))($core$SPCore$Nil));
  });
});

const $sp$Compiler$TypeCheck$typeContainsFunctions = (($ty) => {
  const $$try0 = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
    const $args = ($$try0)[3];
    return (($corelib$List$any)($sp$Compiler$TypeCheck$typeContainsFunctions))($args);
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
    return false;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
    const $to = ($$try0)[4];
    const $fromIsMutable = ($$try0)[3];
    const $from = ($$try0)[2];
    return true;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
    const $t = ($$try0)[3];
    const $path = ($$try0)[2];
    return ($sp$Compiler$TypeCheck$typeContainsFunctions)($t);
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
    const $attrs = ($$try0)[3];
    const $extensible = ($$try0)[2];
    return (($corelib$List$any)($sp$Compiler$TypeCheck$typeContainsFunctions))(($corelib$Dict$values)($attrs));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1963:4', (sp_toHuman)($$try0));
});

const $sp$Human$CanonicalAst$parensIf = (($test) => {
  return (($s) => {
    return ($test
      ? ("(" + ($s + ")"))
      : $s);
  });
});

const $sp$Human$CanonicalAst$usrToText = (($currentUmr) => {
  return (($meta) => {
    return (($usr) => {
      const moduleUmr$$ = $usr;
      const $name = (moduleUmr$$)[2];
      const $moduleUmr = (moduleUmr$$)[1];
      return (((sp_equal)($moduleUmr))($currentUmr)
        ? $name
        : ((() => {
          const $maybeGlobal = (($corelib$List$find)(((k$$) => {
            const $v = k$$.second;
            const $k = k$$.first;
            return ((sp_equal)($usr))($v);
          })))(($corelib$Dict$toList)($meta.globalTypes));
          const $$try0 = $maybeGlobal;
          if (("$corelib$Maybe$Just" === ($$try0)[0])) {
            const $v = ($$try0)[1].second;
            const $k = ($$try0)[1].first;
            return $k;
          }
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            const $$try1 = (($corelib$Dict$get)($moduleUmr))($meta.umrToModuleVisibleAs);
            if (("$corelib$Maybe$Just" === ($$try1)[0])) {
              const $moduleAlias = ($$try1)[1];
              return ($moduleAlias + ("." + $name));
            }
            if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
              const modulePath$$ = $moduleUmr;
              const $modulePath = (modulePath$$)[2];
              const $souece = (modulePath$$)[1];
              return ($modulePath + ("." + $name));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 52:16', (sp_toHuman)($$try1));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 47:8', (sp_toHuman)($$try0));
        }))());
    });
  });
});

const $sp$Human$CanonicalAst$typeToPriorityAndText = (($currentUmr) => {
  return (($meta) => {
    return (($type) => {
      const $parensIfGreaterThan = (($threshold) => {
        return (($ty) => {
          const pri$$ = ((($sp$Human$CanonicalAst$typeToPriorityAndText)($currentUmr))($meta))($ty);
          const $str = pri$$.second;
          const $pri = pri$$.first;
          return (($sp$Human$CanonicalAst$parensIf)(($pri > $threshold)))($str);
        });
      });
      const $$try0 = $type;
      if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
        const $args = ($$try0)[3];
        const $usr = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ({
          first: (((sp_equal)($core$SPCore$Nil))($args)
            ? 0
            : 1),
          second: (($corelib$Text$join)(" "))(((sp_cons)((($corelib$List$map)(($parensIfGreaterThan)(0)))($args)))(((($sp$Human$CanonicalAst$usrToText)($currentUmr))($meta))($usr))),
        });
      }
      if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
        const $name = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ({
          first: 0,
          second: $name,
        });
      }
      if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
        const $to = ($$try0)[4];
        const $fromIsMut = ($$try0)[3];
        const $from = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $arrow = ($fromIsMut
          ? " @: "
          : ": ");
        return ({
          first: 2,
          second: (($corelib$Text$join)(""))((($core$SPCore$Cons)((($parensIfGreaterThan)(1))($from)))((($core$SPCore$Cons)($arrow))((($core$SPCore$Cons)((($parensIfGreaterThan)(2))($to)))($core$SPCore$Nil)))),
        });
        return null;
      }
      if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
        const $attrs = ($$try0)[3];
        const $extend = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $attrsString = (($corelib$Text$join)(", "))((($corelib$List$map)(((name$$) => {
          const $ty = name$$.second;
          const $name = name$$.first;
          return ($name + (" as " + ((($sp$Human$CanonicalAst$typeToText)($currentUmr))($meta))($ty)));
        })))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs))));
        const $l = (($core$SPCore$Cons)("{"))((($core$SPCore$Cons)(((() => {
          const $$try1 = $extend;
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return "";
          }
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $n = ($$try1)[1];
            return ($n + " with");
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 109:16', (sp_toHuman)($$try1));
        }))()))((($core$SPCore$Cons)($attrsString))((($core$SPCore$Cons)("}"))($core$SPCore$Nil))));
        return ({
          first: 0,
          second: (($corelib$Text$join)(" "))($l),
        });
        return null;
      }
      if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
        const $ty2 = ($$try0)[3];
        const $usr = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ({
          first: 0,
          second: ((($sp$Human$CanonicalAst$usrToText)($currentUmr))($meta))($usr),
        });
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 83:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Human$CanonicalAst$typeToText = (($currentUmr) => {
  return (($meta) => {
    return (($t) => {
      return ($corelib$Tuple$second)(((($sp$Human$CanonicalAst$typeToPriorityAndText)($currentUmr))($meta))($t));
    });
  });
});

const $sp$Compiler$TypeCheck$typeToText = (($env) => {
  return (($sp$Human$CanonicalAst$typeToText)($env.currentModule))($env.meta);
});

const $sp$Compiler$TypeCheck$checkNonFunction = (($env) => {
  return (($name) => {
    return (($ty) => {
      const $nope = ({
        freeVarsToFlag: $core$SPCore$Nil,
      });
      return (($sp$Compiler$TypeCheck$andThen)((($nonFnTyvars) => {
        const $$try0 = (($corelib$Dict$get)($name))($nonFnTyvars);
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return ($sp$Compiler$TypeCheck$return)($nope);
        }
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $rejectReasons = ($$try0)[1];
          return (($sp$Compiler$TypeCheck$typeContainsFunctions)($ty)
            ? (($sp$Compiler$TypeCheck$andThen)((() => {
              return ($sp$Compiler$TypeCheck$return)($nope);
            })))((($sp$Compiler$TypeCheck$errorTodo)(($sp$Types$Pos$I)(26)))(("type `" + ($name + ("` should not contain functions, but is " + (($sp$Compiler$TypeCheck$typeToText)($env))($ty))))))
            : ($sp$Compiler$TypeCheck$return)($nope));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1927:4', (sp_toHuman)($$try0));
      })))(($sp$Compiler$TypeCheck$get)((($x) => {
        return $x.nonFnTyvars;
      })));
    });
  });
});

const $sp$Compiler$TypeCheck$flagFreeVars = (($names) => {
  return ($sp$Compiler$TypeCheck$return)(null);
});

const $sp$Compiler$TypeCheck$isAnnotation = (($n) => {
  return ((sp_equal)($corelib$Maybe$Nothing))((text_toNumber)($n));
});

const $sp$Compiler$TypeCheck$typeHasTyvar = (($n) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $name = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ((sp_equal)($name))($n);
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
      const $to = ($$try0)[4];
      const $fromIsMutable = ($$try0)[3];
      const $from = ($$try0)[2];
      return ((($sp$Compiler$TypeCheck$typeHasTyvar)($n))($from) || (($sp$Compiler$TypeCheck$typeHasTyvar)($n))($to));
    }
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
      const $args = ($$try0)[3];
      const $ref = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($corelib$List$any)(($sp$Compiler$TypeCheck$typeHasTyvar)($n)))($args);
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
      const $t = ($$try0)[3];
      const $path = ($$try0)[2];
      return (($sp$Compiler$TypeCheck$typeHasTyvar)($n))($t);
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
      const $attrs = ($$try0)[3];
      const $extensible = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (((sp_equal)($extensible))(($corelib$Maybe$Just)($n)) || (($corelib$List$any)(($sp$Compiler$TypeCheck$typeHasTyvar)($n)))(($corelib$Dict$values)($attrs)));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1984:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$typeIsTyvar = (($name) => {
  return (($ty) => {
    const $$try0 = $ty;
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $n = ($$try0)[2];
      return ((sp_equal)($name))($n);
    }
    if (true) {
      return false;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1912:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$insertTypeClash = (($id) => {
  return (($t1) => {
    return (($t2) => {
      return (($err) => {
        return (($state) => {
          const $$try0 = $state.typeClashesByPlaceholderId;
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            return ((($x) => {
              return (sp_todo)(("Inserting type clash outside of unify" + $x));
            }))((sp_toHuman)(({
              err: $err,
              id: $id,
              t1: $t1,
              t2: $t2,
            })));
          }
          if (("$corelib$Maybe$Just" === ($$try0)[0])) {
            const $dict = ($$try0)[1];
            const $x = ($corelib$Maybe$Just)(((($corelib$Dict$insert)($id))(({
              err: $err,
              t1: $t1,
              t2: $t2,
            })))($dict));
            return ({
              first: null,
              second: (Object.assign)({}, $state, ({
                typeClashesByPlaceholderId: $x,
              })),
            });
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 295:4', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unifyError = (($pos) => {
  return (($error) => {
    return (($t1) => {
      return (($t2) => {
        return (($sp$Compiler$TypeCheck$andThen)((($name) => {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)((($sp$Types$CanonicalAst$TypeVariable)($pos))($name));
          })))((((($sp$Compiler$TypeCheck$insertTypeClash)($name))($t1))($t2))($error));
        })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
      });
    });
  });
});

const $sp$StateMonad$list_map2 = (($f) => {
  return (($la) => {
    return (($lb) => {
      const $apply = ((a$$) => {
        const $b = a$$.second;
        const $a = a$$.first;
        return (($accum) => {
          return (($sp$StateMonad$andThen)((($c) => {
            return ($sp$StateMonad$return)(((sp_cons)($accum))($c));
          })))((($f)($a))($b));
        });
      });
      return (($sp$StateMonad$andThen)((($x) => {
        return ($sp$StateMonad$return)(($corelib$List$reverse)($x));
      })))(((($sp$StateMonad$list_foldl)($apply))(((($corelib$List$map2)($corelib$Tuple$pair))($la))($lb)))($core$SPCore$Nil));
    });
  });
});

const $sp$Compiler$TypeCheck$list_map2 = $sp$StateMonad$list_map2;

const $sp$StateMonad$dict_foldl = (($f) => {
  return (($x) => {
    return (($sp$StateMonad$list_foldl)(((k$$) => {
      const $v = k$$.second;
      const $k = k$$.first;
      return (($f)($k))($v);
    })))(($corelib$Dict$toList)($x));
  });
});

const $sp$StateMonad$dict_map = (($f) => {
  return (($dict) => {
    const $insert = (($c) => {
      return (($a) => {
        return (($d) => {
          return (($sp$StateMonad$andThen)((($b) => {
            return ($sp$StateMonad$return)(((($corelib$Dict$insert)($c))($b))($d));
          })))((($f)($c))($a));
        });
      });
    });
    return ((($sp$StateMonad$dict_foldl)($insert))($dict))($corelib$Dict$empty);
  });
});

const $sp$Compiler$TypeCheck$dict_map = $sp$StateMonad$dict_map;

const $sp$Compiler$TypeCheck$unifyToNonExtensibleRecord = (($env) => {
  return (($pos) => {
    return (($reason) => {
      return (($aName) => {
        return (($aOnly) => {
          return (($bOnly) => {
            return (($bothUnified) => {
              return (((sp_not_equal)($corelib$Dict$empty))($aOnly)
                ? (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("record is missing attrs: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($aOnly)))))((($core$SPCore$Cons)((sp_toHuman)($reason)))($core$SPCore$Nil)))
                : (($sp$Compiler$TypeCheck$andThen)((($ext) => {
                  return (($sp$Compiler$TypeCheck$andThen)((() => {
                    return ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))((($corelib$Dict$join)($bothUnified))($bOnly)));
                  })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("ne"))($pos))($reason))($aName))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(5)))($ext))($bOnly)));
                })))(($sp$Compiler$TypeCheck$newName)($corelib$Maybe$Just)));
            });
          });
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unifyRecords = (($env) => {
  return (($reason) => {
    return (($pos) => {
      return ((a_attrs$$) => {
        const $a_attrs = a_attrs$$.second;
        const $a_ext = a_attrs$$.first;
        return ((b_attrs$$) => {
          const $b_attrs = b_attrs$$.second;
          const $b_ext = b_attrs$$.first;
          const $init = ({
            aOnly: $corelib$Dict$empty,
            bOnly: $corelib$Dict$empty,
            both: $corelib$Dict$empty,
          });
          const $onA = (($name) => {
            return (($type_) => {
              return (($state) => {
                return (Object.assign)({}, $state, ({
                  aOnly: ((($corelib$Dict$insert)($name))($type_))($state.aOnly),
                }));
              });
            });
          });
          const $onB = (($name) => {
            return (($type_) => {
              return (($state) => {
                return (Object.assign)({}, $state, ({
                  bOnly: ((($corelib$Dict$insert)($name))($type_))($state.bOnly),
                }));
              });
            });
          });
          const $onBoth = (($name) => {
            return (($aType) => {
              return (($bType) => {
                return (($state) => {
                  return (Object.assign)({}, $state, ({
                    both: ((($corelib$Dict$insert)($name))(({
                      first: $aType,
                      second: $bType,
                    })))($state.both),
                  }));
                });
              });
            });
          });
          const aOnly$$ = (((((($corelib$Dict$merge)($onA))($onBoth))($onB))($a_attrs))($b_attrs))($init);
          const $both = aOnly$$.both;
          const $bOnly = aOnly$$.bOnly;
          const $aOnly = aOnly$$.aOnly;
          return (($sp$Compiler$TypeCheck$andThen)((($bothUnified) => {
            const $$try0 = ({
              first: $a_ext,
              second: $b_ext,
            });
            if ((("$corelib$Maybe$Just" === ($$try0.first)[0]) && ("$corelib$Maybe$Nothing" === ($$try0.second)[0]))) {
              const $aName = ($$try0.first)[1];
              return ((((((($sp$Compiler$TypeCheck$unifyToNonExtensibleRecord)($env))($pos))($reason))($aName))($aOnly))($bOnly))($bothUnified);
            }
            if ((("$corelib$Maybe$Nothing" === ($$try0.first)[0]) && ("$corelib$Maybe$Just" === ($$try0.second)[0]))) {
              const $bName = ($$try0.second)[1];
              return ((((((($sp$Compiler$TypeCheck$unifyToNonExtensibleRecord)($env))($pos))($reason))($bName))($bOnly))($aOnly))($bothUnified);
            }
            if ((("$corelib$Maybe$Nothing" === ($$try0.first)[0]) && ("$corelib$Maybe$Nothing" === ($$try0.second)[0]))) {
              return ((((sp_equal)($corelib$Dict$empty))($bOnly) && ((sp_equal)($corelib$Dict$empty))($aOnly))
                ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(4)))($corelib$Maybe$Nothing))($bothUnified))
                : ((() => {
                  const $e = ($sp$Compiler$TypeCheck$IncompatibleRecords)(({
                    aOnly: ($corelib$Dict$keys)($aOnly),
                    bOnly: ($corelib$Dict$keys)($bOnly),
                    bothUnified: ($corelib$Dict$keys)($bothUnified),
                  }));
                  return (((($sp$Compiler$TypeCheck$unifyError)($pos))($e))(((($sp$Types$CanonicalAst$TypeRecord)($pos))($a_ext))($a_attrs)))(((($sp$Types$CanonicalAst$TypeRecord)($pos))($b_ext))($b_attrs));
                }))());
            }
            if ((("$corelib$Maybe$Just" === ($$try0.first)[0]) && ("$corelib$Maybe$Just" === ($$try0.second)[0]))) {
              const $bName = ($$try0.second)[1];
              const $aName = ($$try0.first)[1];
              return ((((sp_equal)($bName))($aName) && (((sp_equal)($corelib$Dict$empty))($aOnly) && ((sp_equal)($corelib$Dict$empty))($bOnly)))
                ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($aName)))($bothUnified))
                : (($sp$Compiler$TypeCheck$andThen)((($new) => {
                  const $sub = ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($new)))((($corelib$Dict$join)($bOnly))($a_attrs));
                  return (($sp$Compiler$TypeCheck$andThen)((() => {
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return ($sp$Compiler$TypeCheck$return)($sub);
                    })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("jj2"))($pos))($reason))($bName))($sub));
                  })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("jj1"))($pos))($reason))($aName))($sub));
                })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity)));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1778:4', (sp_toHuman)($$try0));
          })))((($sp$Compiler$TypeCheck$dict_map)((($k) => {
            return ((a$$) => {
              const $b = a$$.second;
              const $a = a$$.first;
              return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a))($b);
            });
          })))($both));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unify_ = (($env) => {
  return (($reason) => {
    return (($pos1) => {
      return (($t1) => {
        return (($t2) => {
          const $$try0 = ({
            first: $t1,
            second: $t2,
          });
          if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0.first)[0])) {
            const $aliased = ($$try0.first)[3];
            const $pos = ($$try0.first)[1];
            return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($aliased))($t2);
          }
          if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0.second)[0])) {
            const $aliased = ($$try0.second)[3];
            return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos1))($t1))($aliased);
          }
          if ((("$sp$Types$CanonicalAst$TypeConstant" === ($$try0.first)[0]) && ("$sp$Types$CanonicalAst$TypeConstant" === ($$try0.second)[0]))) {
            const $args2 = ($$try0.second)[3];
            const $ref2 = ($$try0.second)[2];
            const $args1 = ($$try0.first)[3];
            const $ref1 = ($$try0.first)[2];
            const $pos = ($$try0.first)[1];
            return (((sp_not_equal)($ref2))($ref1)
              ? (((($sp$Compiler$TypeCheck$unifyError)($pos1))($sp$Compiler$TypeCheck$IncompatibleTypes))($t1))($t2)
              : ((() => {
                const $fold = (($arg1) => {
                  return (($arg2) => {
                    return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($arg1))($arg2);
                  });
                });
                return (($sp$Compiler$TypeCheck$andThen)((($argTypes) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                    return ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($ref1))((($corelib$List$map)(($sp$Compiler$TypeCheck$replaceTypeVariables)($subs)))($argTypes)));
                  })))(($sp$Compiler$TypeCheck$get)((($x) => {
                    return $x.substitutions;
                  })));
                })))(((($sp$Compiler$TypeCheck$list_map2)(((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos)))($args1))($args2));
              }))());
          }
          if ((("$sp$Types$CanonicalAst$TypeVariable" === ($$try0.first)[0]) && ("$sp$Types$CanonicalAst$TypeVariable" === ($$try0.second)[0]))) {
            const $v2_name = ($$try0.second)[2];
            const $v1_name = ($$try0.first)[2];
            const $pos = ($$try0.first)[1];
            return (((sp_equal)($v2_name))($v1_name)
              ? ($sp$Compiler$TypeCheck$return)($t1)
              : (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                const $$try1 = ({
                  first: (($corelib$Dict$get)($v1_name))($subs),
                  second: (($corelib$Dict$get)($v2_name))($subs),
                });
                if ((("$corelib$Maybe$Just" === ($$try1.first)[0]) && ("$corelib$Maybe$Just" === ($$try1.second)[0]))) {
                  const $sub2 = ($$try1.second)[1];
                  const $sub1 = ($$try1.first)[1];
                  return (($sp$Compiler$TypeCheck$andThen)((($v) => {
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return (($sp$Compiler$TypeCheck$andThen)((($subbedTy) => {
                        return ($sp$Compiler$TypeCheck$return)($subbedTy);
                      })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv2"))($pos))($reason))($v2_name))($v));
                    })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv1"))($pos))($reason))($v1_name))($v));
                  })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos1))($sub1))($sub2));
                }
                if ((("$corelib$Maybe$Nothing" === ($$try1.first)[0]) && ("$corelib$Maybe$Just" === ($$try1.second)[0]))) {
                  const $sub2 = ($$try1.second)[1];
                  return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv3"))($pos))($reason))($v1_name))($t2);
                }
                if (true) {
                  return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv4"))($pos))($reason))($v2_name))($t1);
                }
                (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1700:16', (sp_toHuman)($$try1));
              })))(($sp$Compiler$TypeCheck$get)((($x) => {
                return $x.substitutions;
              }))));
          }
          if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0.first)[0])) {
            const $name1 = ($$try0.first)[2];
            const $pos = ($$try0.first)[1];
            return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vl"))($pos))($reason))($name1))($t2);
          }
          if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0.second)[0])) {
            const $name2 = ($$try0.second)[2];
            const $pos = ($$try0.second)[1];
            return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vr"))($pos))($reason))($name2))($t1);
          }
          if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try0.first)[0]) && ("$sp$Types$CanonicalAst$TypeFunction" === ($$try0.second)[0]))) {
            const $b_to = ($$try0.second)[4];
            const $b_fromIsMutable = ($$try0.second)[3];
            const $b_from = ($$try0.second)[2];
            const $a_to = ($$try0.first)[4];
            const $a_fromIsMutable = ($$try0.first)[3];
            const $a_from = ($$try0.first)[2];
            const $pos = ($$try0.first)[1];
            return (((sp_not_equal)($b_fromIsMutable))($a_fromIsMutable)
              ? (((($sp$Compiler$TypeCheck$unifyError)($pos))($sp$Compiler$TypeCheck$IncompatibleMutability))($t1))($t2)
              : (($sp$Compiler$TypeCheck$andThen)((($unified_from) => {
                return (($sp$Compiler$TypeCheck$andThen)((($subs_) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($unified_to) => {
                    return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                      return ($sp$Compiler$TypeCheck$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($unified_from)))($a_fromIsMutable))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($unified_to)));
                    })))(($sp$Compiler$TypeCheck$get)((($x) => {
                      return $x.substitutions;
                    })));
                  })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs_))($a_to)))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs_))($b_to)));
                })))(($sp$Compiler$TypeCheck$get)((($x) => {
                  return $x.substitutions;
                })));
              })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a_from))($b_from)));
          }
          if ((("$sp$Types$CanonicalAst$TypeRecord" === ($$try0.first)[0]) && ("$sp$Types$CanonicalAst$TypeRecord" === ($$try0.second)[0]))) {
            const $b_attrs = ($$try0.second)[3];
            const $b_ext = ($$try0.second)[2];
            const $a_attrs = ($$try0.first)[3];
            const $a_ext = ($$try0.first)[2];
            return ((((($sp$Compiler$TypeCheck$unifyRecords)($env))($reason))($pos1))(({
              first: $a_ext,
              second: $a_attrs,
            })))(({
              first: $b_ext,
              second: $b_attrs,
            }));
          }
          if (true) {
            return (((($sp$Compiler$TypeCheck$unifyError)($pos1))($sp$Compiler$TypeCheck$IncompatibleTypes))($t1))($t2);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1669:4', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$addSubstitution = (($env) => {
  return (($debugCode) => {
    return (($pos) => {
      return (($reason) => {
        return (($name) => {
          return (($rawTy) => {
            return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return (($sp$Compiler$TypeCheck$isAnnotation)($name)
                ? ((() => {
                  const $$try0 = $ty;
                  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
                    const $subName = ($$try0)[2];
                    return (((sp_equal)($name))($subName)
                      ? ($sp$Compiler$TypeCheck$return)($ty)
                      : (($sp$Compiler$TypeCheck$isAnnotation)($subName)
                        ? (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$SubstitutingAnnotation)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty)
                        : (((((($sp$Compiler$TypeCheck$addSubstitution)($env))(($debugCode + " SWITCH")))($pos))($reason))($subName))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name))));
                  }
                  if (true) {
                    return (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$SubstitutingAnnotation)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty);
                  }
                  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1858:8', (sp_toHuman)($$try0));
                }))()
                : ((($sp$Compiler$TypeCheck$typeHasTyvar)($name))($ty)
                  ? ((($sp$Compiler$TypeCheck$typeIsTyvar)($name))($ty)
                    ? ($sp$Compiler$TypeCheck$return)($ty)
                    : (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$Cycle)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty))
                  : (($sp$Compiler$TypeCheck$andThen)((($nonFunction) => {
                    const freeVarsToFlag$$ = $nonFunction;
                    const $freeVarsToFlag = freeVarsToFlag$$.freeVarsToFlag;
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                        const $$try0 = (($corelib$Dict$get)($name))($subs);
                        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
                          const $sub = ($$try0)[1];
                          return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($ty))($sub);
                        }
                        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
                          return (($state) => {
                            return ({
                              first: $ty,
                              second: (Object.assign)({}, $state, ({
                                substitutions: ((($corelib$Dict$insert)($name))($ty))((($corelib$Dict$map)((($k) => {
                                  return ($sp$Compiler$TypeCheck$replaceTypeVariables)((($corelib$Dict$singleton)($name))($ty));
                                })))($state.substitutions)),
                              })),
                            });
                          });
                        }
                        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1890:8', (sp_toHuman)($$try0));
                      })))(($sp$Compiler$TypeCheck$get)((($x) => {
                        return $x.substitutions;
                      })));
                    })))(($sp$Compiler$TypeCheck$flagFreeVars)($freeVarsToFlag));
                  })))(((($sp$Compiler$TypeCheck$checkNonFunction)($env))($name))($ty))));
            })))(($sp$Compiler$TypeCheck$applySubsToType)($rawTy));
          });
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unifyErrorToText = (($ue) => {
  const $$try0 = $ue;
  if (("$sp$Compiler$TypeCheck$IncompatibleTypes" === ($$try0)[0])) {
    return "The two types are incompatible.";
  }
  if (("$sp$Compiler$TypeCheck$IncompatibleMutability" === ($$try0)[0])) {
    return "The mutability does not match.";
  }
  if (("$sp$Compiler$TypeCheck$IncompatibleRecords" === ($$try0)[0])) {
    const $args = ($$try0)[1];
    return ("The record types are not compatible" + (sp_toHuman)($args));
  }
  if (("$sp$Compiler$TypeCheck$Cycle" === ($$try0)[0])) {
    const $name = ($$try0)[1];
    return ("There is a cyclic dependency on " + $name);
  }
  if (("$sp$Compiler$TypeCheck$NonFunctionContainsFunction" === ($$try0)[0])) {
    const $rejectFunctions = ($$try0)[1];
    return ("NonFunction can't contain functions: " + (sp_toHuman)($rejectFunctions));
  }
  if (("$sp$Compiler$TypeCheck$OkThisIsActuallyPossible" === ($$try0)[0])) {
    return "OkThisIsActuallyPossible?";
  }
  if (("$sp$Compiler$TypeCheck$NI" === ($$try0)[0])) {
    const $str = ($$try0)[1];
    return ("Not Implemented: " + $str);
  }
  if (("$sp$Compiler$TypeCheck$SubstitutingAnnotation" === ($$try0)[0])) {
    const $name = ($$try0)[1];
    return ("SubstitutingAnnotation: " + $name);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1607:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck$clashToTexts = (($env) => {
  return (($params) => {
    const $$try0 = $params.unifiedType;
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
      const $unifiedTypeName = ($$try0)[2];
      const $p = ($$try0)[1];
      return (($corelib$Text$join)("\n"))((($corelib$List$concatMap)(((clash$$) => {
        const $clash = clash$$.second;
        const $clashPlaceholderName = clash$$.first;
        return (($core$SPCore$Cons)($params.type1_is))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t1))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($params.type2_is))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t2))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck$unifyErrorToText)($clash.err)))($core$SPCore$Nil)))))))));
      })))(($corelib$Dict$toList)($params.clashes)));
    }
    if (true) {
      const $info = (($core$SPCore$Cons)($params.typeSeemsToBe))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($params.unifiedType)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("However I can't reconcile the following:"))($core$SPCore$Nil))));
      const $clashToError = ((clash$$) => {
        const $clash = clash$$.second;
        const $name = clash$$.first;
        return (($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("* `" + ($name + "`"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + $params.type1_is)))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t1))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + $params.type2_is)))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t2))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + ($sp$Compiler$TypeCheck$unifyErrorToText)($clash.err))))($core$SPCore$Nil))))))))));
      });
      const $clashErrors = (($corelib$List$concatMap)($clashToError))(($corelib$Dict$toList)($params.clashes));
      return (($corelib$Text$join)("\n"))(($corelib$List$concat)((($core$SPCore$Cons)($info))((($core$SPCore$Cons)($clashErrors))($core$SPCore$Nil))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2450:4', (sp_toHuman)($$try0));
  });
});

const $sp$Types$CanonicalAst$expressionPos = (($e) => {
  const $$try0 = $e;
  if (("$sp$Types$CanonicalAst$LiteralText" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$Variable" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$Constructor" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$Lambda" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$Record" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$Call" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$If" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  if (("$sp$Types$CanonicalAst$Try" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 241:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck$errorIncompatibleTypes = (($env) => {
  return (($reason) => {
    return (($pos_whatever) => {
      return (($unifiedType) => {
        return (($clashes) => {
          const $$try0 = $reason;
          if (("$sp$Compiler$TypeCheck$UnifyReason_CallArgument" === ($$try0)[0])) {
            const $pos = ($$try0)[1];
            const $makeError = (($eenv) => {
              const block$$ = (($sp$Compiler$Error$posToHuman)($eenv))($pos.reference);
              const $location = block$$.location;
              const $block = block$$.block;
              return (($core$SPCore$Cons)("This expression cannot be used as argument to this function:"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($block))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("the argument type seems to be: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                clashes: $clashes,
                type1_is: "The functon expects:",
                type2_is: "But the actual argument is:",
                typeSeemsToBe: "The argument type seems to be",
                unifiedType: $unifiedType,
              }))))($core$SPCore$Nil))))));
            });
            return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos.argument))($makeError);
            return null;
          }
          if (("$sp$Compiler$TypeCheck$UnifyReason_TryBlock" === ($$try0)[0])) {
            const $block = ($$try0)[1];
            const $makeError = (($eenv) => {
              return (($core$SPCore$Cons)("This try..as block produces a different type than the blocks preceding it."))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                clashes: $clashes,
                type1_is: "The previous block(s) produce:",
                type2_is: "But this block produces:",
                typeSeemsToBe: "The block type seems to be",
                unifiedType: $unifiedType,
              }))))($core$SPCore$Nil)));
            });
            return (($sp$Compiler$TypeCheck$addErrorWithEEnv)(($sp$Types$CanonicalAst$expressionPos)($block)))($makeError);
            return null;
          }
          if (("$sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock" === ($$try0)[0])) {
            const $body = ($$try0)[3];
            const $annotation = ($$try0)[2];
            const $pattern = ($$try0)[1];
            const $headerPos = ($sp$Types$CanonicalAst$patternPos)($pattern);
            const $lastStatementPos = ($sp$Types$CanonicalAst$expressionPos)(($sp$Types$CanonicalAst$skipLetIns)($body));
            const $name = (($corelib$Text$join)(", "))(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($pattern)));
            const $makeError = (($eenv) => {
              const block$$ = (($sp$Compiler$Error$posToHuman)($eenv))($headerPos);
              const $location = block$$.location;
              const $block = block$$.block;
              return (($core$SPCore$Cons)(("The definition of " + ($name + " does not match the annotation:"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($block))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                clashes: $clashes,
                type1_is: "The annotation says:",
                type2_is: "But this definition produces:",
                typeSeemsToBe: "The produced type seems to be",
                unifiedType: $unifiedType,
              }))))($core$SPCore$Nil)))));
            });
            return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($lastStatementPos))($makeError);
            return null;
          }
          if (("$sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction" === ($$try0)[0])) {
            const $referenceType = ($$try0)[2];
            const $pos = ($$try0)[1];
            return (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("This expression is being called as if it was a function, but its type is:"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil))));
          }
          if (true) {
            const $pos = $pos_whatever;
            const $title = ((() => {
              const $$try1 = $reason;
              if (("$sp$Compiler$TypeCheck$UnifyReason_AnnotationSimple" === ($$try1)[0])) {
                return "The type is not compatible with the annotation";
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern" === ($$try1)[0])) {
                return "The definition block cannot be unpacked into the pattern";
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_IfCondition" === ($$try1)[0])) {
                return "The expression inside `if ... :` should always be a Bool";
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_IfBranches" === ($$try1)[0])) {
                return "The branches of an `if` should produce the same type of value";
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_TryPattern" === ($$try1)[0])) {
                return "try..as patterns should have the same type";
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument" === ($$try1)[0])) {
                const $p = ($$try1)[1];
                return ("Argument " + ((text_fromNumber)($p.argIndex) + (" to type constructor " + ((sp_toHuman)($p.usr) + " does not match the constructor definition"))));
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_AttributeAccess" === ($$try1)[0])) {
                const $attrName = ($$try1)[1];
                return ("You are trying to access the ." + ($attrName + " attribute"));
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate" === ($$try1)[0])) {
                const $attrNames = ($$try1)[1];
                return ("You are trying to update the " + ((($corelib$Text$join)(", "))($attrNames) + " attributes"));
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_Override" === ($$try1)[0])) {
                return "this is addSubstitution running a UnifyReason_Override, I don't know what I'm doing";
              }
              if (("$sp$Compiler$TypeCheck$UnifyReason_IsLambda" === ($$try1)[0])) {
                return "this is a function, and its type should reflect that";
              }
              if (true) {
                return (sp_todo)(((sp_toHuman)($reason) + " should not even get here"));
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2391:16', (sp_toHuman)($$try1));
            }))();
            return (($sp$Compiler$TypeCheck$addError)($pos_whatever))((($core$SPCore$Cons)($title))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("The type seems to be something like"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
              clashes: $clashes,
              type1_is: "t1 is:",
              type2_is: "but t2 is:",
              typeSeemsToBe: "type seems to be",
              unifiedType: $unifiedType,
            }))))($core$SPCore$Nil)))));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2304:4', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $sp$StateMonad$update = (($f) => {
  return (($state) => {
    const $s = ($f)($state);
    return ({
      first: $s,
      second: $s,
    });
  });
});

const $sp$Compiler$TypeCheck$m_update = $sp$StateMonad$update;

const $sp$Compiler$TypeCheck$popClashingtypes = (($state) => {
  const $$try0 = $state.typeClashesByPlaceholderId;
  if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
    return (sp_todo)("popping a nothing!");
  }
  if (("$corelib$Maybe$Just" === ($$try0)[0])) {
    const $dict = ($$try0)[1];
    return ({
      first: $dict,
      second: (Object.assign)({}, $state, ({
        typeClashesByPlaceholderId: $corelib$Maybe$Nothing,
      })),
    });
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 317:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck$unify = (($env) => {
  return (($pos) => {
    return (($reason) => {
      return (($a) => {
        return (($b) => {
          return (($sp$Compiler$TypeCheck$andThen)((($tc) => {
            return (((sp_not_equal)($corelib$Maybe$Nothing))($tc)
              ? (sp_todo)("typeClashesByPlaceholderId NOT EMPTY!")
              : (($sp$Compiler$TypeCheck$andThen)((() => {
                return (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($typeClashes) => {
                    return (((sp_equal)($corelib$Dict$empty))($typeClashes)
                      ? ($sp$Compiler$TypeCheck$return)($unifiedType)
                      : (($sp$Compiler$TypeCheck$andThen)((() => {
                        return ($sp$Compiler$TypeCheck$return)($unifiedType);
                      })))(((((($sp$Compiler$TypeCheck$errorIncompatibleTypes)($env))($reason))($pos))($unifiedType))($typeClashes)));
                  })))($sp$Compiler$TypeCheck$popClashingtypes);
                })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a))($b));
              })))(($sp$Compiler$TypeCheck$m_update)((($s) => {
                return (Object.assign)({}, $s, ({
                  typeClashesByPlaceholderId: ($corelib$Maybe$Just)($corelib$Dict$empty),
                }));
              }))));
          })))(($sp$Compiler$TypeCheck$get)((($x) => {
            return $x.typeClashesByPlaceholderId;
          })));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$applyAttributePath = (($env) => {
  return (($pos) => {
    return (($attrPath) => {
      const $wrap = (($attributeName) => {
        return (($ty) => {
          const $maybeAttrType = ((() => {
            const $$try0 = $ty;
            if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
              const $attrs = ($$try0)[3];
              const $e = ($$try0)[2];
              return (($corelib$Dict$get)($attributeName))($attrs);
            }
            if (true) {
              return $corelib$Maybe$Nothing;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2008:12', (sp_toHuman)($$try0));
          }))();
          const $$try0 = $maybeAttrType;
          if (("$corelib$Maybe$Just" === ($$try0)[0])) {
            const $attrType = ($$try0)[1];
            return ($sp$Compiler$TypeCheck$return)($attrType);
          }
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            return (($sp$Compiler$TypeCheck$andThen)((($extName) => {
              return (($sp$Compiler$TypeCheck$andThen)((($attrType) => {
                const $re = ((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)($extName)))((($corelib$Dict$singleton)($attributeName))($attrType));
                return (($sp$Compiler$TypeCheck$andThen)((() => {
                  return ($sp$Compiler$TypeCheck$return)($attrType);
                })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_AttributeAccess)($attributeName)))($ty))($re));
              })))(($sp$Compiler$TypeCheck$newType)($pos));
            })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2014:8', (sp_toHuman)($$try0));
        });
      });
      return (($sp$Compiler$TypeCheck$list_for)($attrPath))($wrap);
    });
  });
});

const $sp$Compiler$TypeCheck$applySubsToNonFreeTyvars = (($env) => {
  return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
    const $meh = (($typeVarName) => {
      return (($constrainedVars) => {
        const $$try0 = (($corelib$Dict$get)($typeVarName))($subs);
        if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
          return $constrainedVars;
        }
        if (("$corelib$Maybe$Just" === ($$try0)[0])) {
          const $ty = ($$try0)[1];
          return ((($corelib$Dict$for)(($sp$Types$CanonicalAst$typeTyvars)($ty)))((($n) => {
            return (($p) => {
              return (($corelib$Dict$insert)($n))($p);
            });
          })))($constrainedVars);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2145:8', (sp_toHuman)($$try0));
      });
    });
    return ($sp$Compiler$TypeCheck$return)((Object.assign)({}, $env, ({
      nonFreeTyvars: ((($corelib$List$for)(($corelib$Dict$keys)($env.nonFreeTyvars)))($meh))($env.nonFreeTyvars),
    })));
  })))(($sp$Compiler$TypeCheck$get)((($x) => {
    return $x.substitutions;
  })));
});

const $sp$Compiler$TypeCheck$checkConstructorWithItsArgs = (($env) => {
  return (($pos) => {
    return (($index) => {
      return (($actualArgs) => {
        return (($expectedArgs) => {
          const $$try0 = ({
            first: $actualArgs,
            second: $expectedArgs,
          });
          if ((("$core$SPCore$Cons" === ($$try0.first)[0]) && ("$core$SPCore$Cons" === ($$try0.second)[0]))) {
            const $expectedTail = ($$try0.second)[2];
            const $expectedHead = ($$try0.second)[1];
            const $actualTail = ($$try0.first)[2];
            const $actualHead = ($$try0.first)[1];
            return (($sp$Compiler$TypeCheck$andThen)((($updatedEnv) => {
              return ((((($sp$Compiler$TypeCheck$checkConstructorWithItsArgs)($updatedEnv))($pos))(($index + 1)))($actualTail))($expectedTail);
            })))(((($sp$Compiler$TypeCheck$checkAndInsertPattern)($env))($expectedHead))($actualHead));
          }
          if ((("$core$SPCore$Nil" === ($$try0.first)[0]) && ("$core$SPCore$Cons" === ($$try0.second)[0]))) {
            const $expectedTail = ($$try0.second)[2];
            const $expectedHead = ($$try0.second)[1];
            const $given = $index;
            const $needed = ($index + ($corelib$List$length)($expectedArgs));
            return (($sp$Compiler$TypeCheck$andThen)((() => {
              return ($sp$Compiler$TypeCheck$return)($env);
            })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("Constructor needs " + ((text_fromNumber)($needed) + (" arguments but was given only " + (text_fromNumber)($given))))))($core$SPCore$Nil)));
            return null;
          }
          if ((("$core$SPCore$Cons" === ($$try0.first)[0]) && ("$core$SPCore$Nil" === ($$try0.second)[0]))) {
            const $actualTail = ($$try0.first)[2];
            const $actualHead = ($$try0.first)[1];
            return (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($actualArgs))((($core$SPCore$Cons)("more arguments than needed"))($core$SPCore$Nil));
          }
          if ((("$core$SPCore$Nil" === ($$try0.first)[0]) && ("$core$SPCore$Nil" === ($$try0.second)[0]))) {
            return ($sp$Compiler$TypeCheck$return)($env);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 759:4', (sp_toHuman)($$try0));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$dict_for = (($d) => {
  return (($f) => {
    return (($sp$StateMonad$dict_foldl)($f))($d);
  });
});

const $sp$Compiler$TypeCheck$expandAlias = (($type) => {
  const $$try0 = $type;
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
    const $t = ($$try0)[3];
    return ($sp$Compiler$TypeCheck$expandAlias)($t);
  }
  if (true) {
    return $type;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 265:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck$onlyBothOnly = (($da) => {
  return (($db) => {
    const $onAOnly = (($key) => {
      return (($a) => {
        return ((aOnly$$) => {
          const $bOnly = aOnly$$.third;
          const $both = aOnly$$.second;
          const $aOnly = aOnly$$.first;
          return ({
            first: ((($corelib$Dict$insert)($key))($a))($aOnly),
            second: $both,
            third: $bOnly,
          });
        });
      });
    });
    const $onBOnly = (($key) => {
      return (($b) => {
        return ((aOnly$$) => {
          const $bOnly = aOnly$$.third;
          const $both = aOnly$$.second;
          const $aOnly = aOnly$$.first;
          return ({
            first: $aOnly,
            second: $both,
            third: ((($corelib$Dict$insert)($key))($b))($bOnly),
          });
        });
      });
    });
    const $onBoth = (($key) => {
      return (($a) => {
        return (($b) => {
          return ((aOnly$$) => {
            const $bOnly = aOnly$$.third;
            const $both = aOnly$$.second;
            const $aOnly = aOnly$$.first;
            return ({
              first: $aOnly,
              second: ((($corelib$Dict$insert)($key))(({
                first: $a,
                second: $b,
              })))($both),
              third: $bOnly,
            });
          });
        });
      });
    });
    return (((((($corelib$Dict$merge)($onAOnly))($onBoth))($onBOnly))($da))($db))(({
      first: $corelib$Dict$empty,
      second: $corelib$Dict$empty,
      third: $corelib$Dict$empty,
    }));
  });
});

const $sp$Compiler$TypeCheck$isCompatibleWith = (($env) => {
  return (($expectedType) => {
    return (($pos) => {
      return (($actualType) => {
        const $$try0 = ({
          first: $expectedType,
          second: $actualType,
        });
        if ((("$sp$Types$CanonicalAst$TypeConstant" === ($$try0.first)[0]) && ("$sp$Types$CanonicalAst$TypeConstant" === ($$try0.second)[0]))) {
          const $actualArgs = ($$try0.second)[3];
          const $actualUsr = ($$try0.second)[2];
          const $expectedArgs = ($$try0.first)[3];
          const $expectedUsr = ($$try0.first)[2];
          return (((sp_not_equal)($actualUsr))($expectedUsr)
            ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("This expression should be of type"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))((($core$SPCore$Cons)("but instead is"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($actualType)))($core$SPCore$Nil)))))
            : ((($sp$Compiler$TypeCheck$list_for)(((($corelib$List$map2)($corelib$Tuple$pair))($expectedArgs))($actualArgs)))(((a$$) => {
              const $a = a$$.second;
              const $e = a$$.first;
              return (() => {
                return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($e))($pos))($a);
              });
            })))(null));
        }
        if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try0.first)[0]) && ("$sp$Types$CanonicalAst$TypeFunction" === ($$try0.second)[0]))) {
          const $aTo = ($$try0.second)[4];
          const $aIsMut = ($$try0.second)[3];
          const $aFrom = ($$try0.second)[2];
          const $eTo = ($$try0.first)[4];
          const $eIsMut = ($$try0.first)[3];
          const $eFrom = ($$try0.first)[2];
          return (((sp_not_equal)($aIsMut))($eIsMut)
            ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil))
            : (($sp$Compiler$TypeCheck$andThen)((() => {
              return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($eTo))($pos))($aTo);
            })))((((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($eFrom))($pos))($aFrom)));
        }
        if ((("$sp$Types$CanonicalAst$TypeRecord" === ($$try0.first)[0]) && ("$corelib$Maybe$Just" === (($$try0.first)[2])[0]))) {
          const $eAttrs = ($$try0.first)[3];
          const $e = (($$try0.first)[2])[1];
          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("Extensible record annotation is experimentally disabled [TODO link to why]"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("extension: " + (sp_toHuman)($e))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("attrs: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($eAttrs)))))($core$SPCore$Nil))))));
        }
        if ((("$sp$Types$CanonicalAst$TypeRecord" === ($$try0.first)[0]) && (("$corelib$Maybe$Nothing" === (($$try0.first)[2])[0]) && ("$sp$Types$CanonicalAst$TypeRecord" === ($$try0.second)[0])))) {
          const $aAttrs = ($$try0.second)[3];
          const $aExtension = ($$try0.second)[2];
          const $eAttrs = ($$try0.first)[3];
          const aOnly$$ = (($sp$Compiler$TypeCheck$onlyBothOnly)($eAttrs))($aAttrs);
          const $aOnly = aOnly$$.third;
          const $both = aOnly$$.second;
          const $eOnly = aOnly$$.first;
          return ((((sp_not_equal)($corelib$Dict$empty))($eOnly) && ((sp_equal)($corelib$Maybe$Nothing))($aExtension))
            ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("missing attributes: " + (sp_toHuman)(($corelib$Dict$keys)($eOnly)))))($core$SPCore$Nil))
            : (((sp_not_equal)($corelib$Dict$empty))($aOnly)
              ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("extra attributes: " + (sp_toHuman)(($corelib$Dict$keys)($aOnly)))))($core$SPCore$Nil))
              : ((($sp$Compiler$TypeCheck$dict_for)($both))((($attrName) => {
                return ((aType$$) => {
                  const $aType = aType$$.second;
                  const $eType = aType$$.first;
                  return (() => {
                    return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($eType))($pos))($aType);
                  });
                });
              })))(null)));
          return null;
        }
        if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0.first)[0])) {
          const $ty = ($$try0.first)[3];
          return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($ty))($pos))($actualType);
        }
        if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0.second)[0])) {
          const $ty = ($$try0.second)[3];
          return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($ty);
        }
        if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0.second)[0])) {
          const $actualName = ($$try0.second)[2];
          return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
            return ($sp$Compiler$TypeCheck$return)(null);
          })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_AnnotationSimple))($expectedType))($actualType));
        }
        if (true) {
          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("I was expecting"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))((($core$SPCore$Cons)("but the actual type is: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($actualType)))((($core$SPCore$Cons)("The two types are not compatible!"))($core$SPCore$Nil))))));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 550:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$checkAndInsertPattern = (($env) => {
  return (($expectedType_) => {
    return (($pattern) => {
      const $expectedType = ($sp$Compiler$TypeCheck$expandAlias)($expectedType_);
      const $$try0 = $pattern;
      if (("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0])) {
        const $maybeAnnotation = ($$try0)[3];
        const $maybeName = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $envWith = (($name) => {
          return (($type) => {
            return (Object.assign)({}, $env, ({
              instanceVariables: ((($corelib$Dict$insert)(($sp$Types$CanonicalAst$RefBlock)($name)))(({
                definedAt: $pos,
                freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($env.nonFreeTyvars))($corelib$Dict$empty))($type),
                isMutable: false,
                ty: $type,
              })))($env.instanceVariables),
            }));
          });
        });
        const $$try1 = ({
          first: $maybeName,
          second: $maybeAnnotation,
        });
        if ((("$corelib$Maybe$Just" === ($$try1.first)[0]) && ("$corelib$Maybe$Just" === ($$try1.second)[0]))) {
          const $annotation = ($$try1.second)[1];
          const $name = ($$try1.first)[1];
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)((($envWith)($name))($annotation));
          })))((((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($annotation));
        }
        if ((("$corelib$Maybe$Just" === ($$try1.first)[0]) && ("$corelib$Maybe$Nothing" === ($$try1.second)[0]))) {
          const $name = ($$try1.first)[1];
          return ($sp$Compiler$TypeCheck$return)((($envWith)($name))($expectedType));
        }
        if ((("$corelib$Maybe$Nothing" === ($$try1.first)[0]) && ("$corelib$Maybe$Just" === ($$try1.second)[0]))) {
          const $annotation = ($$try1.second)[1];
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)($env);
          })))((((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($annotation));
        }
        if ((("$corelib$Maybe$Nothing" === ($$try1.first)[0]) && ("$corelib$Maybe$Nothing" === ($$try1.second)[0]))) {
          return ($sp$Compiler$TypeCheck$return)($env);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 685:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
        const $literal = ($$try0)[2];
        const $pos = ($$try0)[1];
        (sp_todo)("TODO needs proper type comparison without `pos`");
        return (((sp_equal)($sp$Compiler$CoreTypes$number))($expectedType)
          ? ($sp$Compiler$TypeCheck$return)($env)
          : (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)($env);
          })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This pattern is a Number, but the annotation says it should be " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil))));
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
        const $literal = ($$try0)[2];
        const $pos = ($$try0)[1];
        (sp_todo)("TODO needs proper type comparison without `pos`");
        return (((sp_equal)($sp$Compiler$CoreTypes$text))($expectedType)
          ? ($sp$Compiler$TypeCheck$return)($env)
          : (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)($env);
          })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This pattern is a Text, but the annotation says it should be " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil))));
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
        const $args = ($$try0)[3];
        const $usr = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = (($corelib$Dict$get)($usr))($env.constructors);
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($args))((($core$SPCore$Cons)(("Unknown constructor: " + (sp_toHuman)($usr))))($core$SPCore$Nil));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $constructor = ($$try1)[1];
          const $$try2 = $expectedType;
          if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try2)[0])) {
            const $args_ = ($$try2)[3];
            const $expectedUsr = ($$try2)[2];
            return (((sp_not_equal)($constructor.typeUsr))($usr)
              ? (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($args))((($core$SPCore$Cons)(("Constructor produces " + ((sp_toHuman)($constructor.typeUsr) + (" but annotation requires " + (sp_toHuman)($expectedUsr))))))($core$SPCore$Nil))
              : ((((($sp$Compiler$TypeCheck$checkConstructorWithItsArgs)($env))($pos))(0))($args))($constructor.args));
          }
          if (true) {
            return (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($args))((($core$SPCore$Cons)(("This pattern is an union type, but the annotation expects a " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 725:20', (sp_toHuman)($$try2));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 720:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
        const $patternAttrs = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = $expectedType;
        if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try1)[0])) {
          const $expectedTypeAttrs = ($$try1)[3];
          return ((($sp$Compiler$TypeCheck$dict_for)($patternAttrs))((($attrName) => {
            return (($attrPattern) => {
              return (($envX) => {
                const $$try2 = (($corelib$Dict$get)($attrName))($expectedTypeAttrs);
                if (("$corelib$Maybe$Nothing" === ($$try2)[0])) {
                  return (($sp$Compiler$TypeCheck$andThen)((() => {
                    return ($sp$Compiler$TypeCheck$return)($envX);
                  })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record pattern has an attribute `" + ($attrName + "` but it is not avaiable in the annotation"))))($core$SPCore$Nil)));
                }
                if (("$corelib$Maybe$Just" === ($$try2)[0])) {
                  const $expectedAttrType = ($$try2)[1];
                  return ((($sp$Compiler$TypeCheck$checkAndInsertPattern)($envX))($expectedAttrType))($attrPattern);
                }
                (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 745:24', (sp_toHuman)($$try2));
              });
            });
          })))($env);
        }
        if (true) {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)($env);
          })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This pattern is a record, but the annotation says it should be " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 742:12', (sp_toHuman)($$try1));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 668:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$TypeCheck$errorUndefinedVariable = (($env) => {
  return (($pos) => {
    return (($ref) => {
      return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))((($errorEnv) => {
        const $onLocal = (($name) => {
          const $$try0 = (($corelib$Dict$get)($name))($env.nonAnnotatedRecursives);
          if (("$corelib$Maybe$Just" === ($$try0)[0])) {
            const $defPos = ($$try0)[1];
            return (($core$SPCore$Cons)(("To use function `" + ($name + "` recursively, you need to add a type annotation to its definition."))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("This is a limit of the compiler, not sure when I'll have the time to fix it."))($core$SPCore$Nil)));
          }
          if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
            return (($core$SPCore$Cons)(("Undefined value: " + $name)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("I can't see a definition for `" + ($name + "` anywhere, so I don't know what it is."))))($core$SPCore$Nil)));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2266:8', (sp_toHuman)($$try0));
        });
        const $$try0 = $ref;
        if (("$sp$Types$CanonicalAst$RefBlock" === ($$try0)[0])) {
          const $name = ($$try0)[1];
          return ($onLocal)($name);
        }
        if ((("$sp$Types$CanonicalAst$RefRoot" === ($$try0)[0]) && ("$sp$Types$Meta$USR" === (($$try0)[1])[0]))) {
          const $name = (($$try0)[1])[2];
          const $umr = (($$try0)[1])[1];
          return (((sp_equal)($env.currentModule))($umr)
            ? ($onLocal)($name)
            : ((() => {
              const path$$ = $env.currentModule;
              const $path = (path$$)[2];
              const $source = (path$$)[1];
              const $$try1 = (($corelib$Dict$get)($path))($errorEnv.moduleByName);
              if (("$corelib$Maybe$Just" === ($$try1)[0])) {
                const $mod = ($$try1)[1];
                return (($core$SPCore$Cons)(("Module `" + ($path + ("` from source `" + ((sp_toHuman)($source) + ("` does not seem to expose a variable called `" + ($name + "`."))))))))($core$SPCore$Nil);
              }
              if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
                return (($core$SPCore$Cons)(("The code references a `" + ($path + ("." + ($name + ("` with source `" + (sp_toHuman)($source))))))))((($core$SPCore$Cons)("However, I can't find any module with that path and source."))($core$SPCore$Nil));
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2290:16', (sp_toHuman)($$try1));
            }))());
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2279:4', (sp_toHuman)($$try0));
      }));
    });
  });
});

const $sp$Compiler$TypeCheck$checkFreeVariables = (($env) => {
  return (($pos) => {
    return (($patternType) => {
      return (($blockType) => {
        const $annotatedFreeVars = (($corelib$Dict$filter)((($name) => {
          return (() => {
            return ($sp$Compiler$TypeCheck$isAnnotation)($name);
          });
        })))(($sp$Types$CanonicalAst$typeTyvars)($patternType));
        const $actualFreeVars = ($sp$Types$CanonicalAst$typeTyvars)($blockType);
        return ((($corelib$Dict$size)($annotatedFreeVars) > ($corelib$Dict$size)($actualFreeVars))
          ? (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(null);
          })))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("The annotation is too general"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("The annotation uses: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($annotatedFreeVars)))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("But the actual type uses only: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($actualFreeVars)))))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($blockType)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("The annotation has " + ((text_fromNumber)((($corelib$Dict$size)($annotatedFreeVars) - ($corelib$Dict$size)($actualFreeVars))) + " type variables too many"))))($core$SPCore$Nil))))))))))
          : ($sp$Compiler$TypeCheck$return)(null));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$fromArgument = (($env) => {
  return (($argument) => {
    const $$try0 = $argument;
    if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try0)[0])) {
      const $expr = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
        return ($sp$Compiler$TypeCheck$return)(({
          first: false,
          second: $ty,
        }));
      })))((($sp$Compiler$TypeCheck$fromExpression)($env))($expr));
    }
    if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try0)[0])) {
      const $ref = ($$try0)[2].ref;
      const $attrPath = ($$try0)[2].attrPath;
      const $pos = ($$try0)[1];
      const $$try1 = (($corelib$Dict$get)($ref))($env.instanceVariables);
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
          return ($sp$Compiler$TypeCheck$return)(({
            first: true,
            second: $ty,
          }));
        })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref));
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $var = ($$try1)[1];
        return (($corelib$Basics$not)($var.isMutable)
          ? ((() => {
            const $ae = (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("You are trying to mutate variable `" + ((sp_toHuman)($ref) + "` but it was declared as not mutable!"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("TODO [link to wiki page that explains how to declare variables]"))($core$SPCore$Nil))));
            return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return ($sp$Compiler$TypeCheck$return)(({
                first: true,
                second: $ty,
              }));
            })))($ae);
          }))()
          : (($sp$Compiler$TypeCheck$typeContainsFunctions)($var.ty)
            ? (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return ($sp$Compiler$TypeCheck$return)(({
                first: true,
                second: $ty,
              }));
            })))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("mutable arguments can't allow functions"))($core$SPCore$Nil)))
            : (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return ($sp$Compiler$TypeCheck$return)(({
                first: true,
                second: $ty,
              }));
            })))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($var.ty))));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1308:12', (sp_toHuman)($$try1));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1302:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$setNonFn = (($name) => {
  return (($state) => {
    return ({
      first: null,
      second: (Object.assign)({}, $state, ({
        nonFnTyvars: ((($corelib$Dict$insert)($name))($core$SPCore$Nil))($state.nonFnTyvars),
      })),
    });
  });
});

const $sp$Compiler$TypeCheck$generateNewTypeVariables = (($tyvarByName) => {
  const $apply = (($name0) => {
    return (($arg) => {
      return (($subs) => {
        const nonFn$$ = $arg;
        const $nonFn = nonFn$$.nonFn;
        return (($sp$Compiler$TypeCheck$andThen)((($name1) => {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(((($corelib$Dict$insert)($name0))((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))($name1)))($subs));
          })))(($nonFn
            ? ($sp$Compiler$TypeCheck$setNonFn)($name1)
            : ($sp$Compiler$TypeCheck$return)(null)));
        })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
      });
    });
  });
  return ((($sp$Compiler$TypeCheck$dict_for)($tyvarByName))($apply))($corelib$Dict$empty);
});

const $sp$Compiler$TypeCheck$replaceTypeVariablesWithNew = (($freeTypeVariables) => {
  return (($type) => {
    return (((sp_equal)($corelib$Dict$empty))($freeTypeVariables)
      ? ($sp$Compiler$TypeCheck$return)($type)
      : (($sp$Compiler$TypeCheck$andThen)((($newTypeByOldType) => {
        return ($sp$Compiler$TypeCheck$return)((($sp$Compiler$TypeCheck$replaceTypeVariables)($newTypeByOldType))($type));
      })))(($sp$Compiler$TypeCheck$generateNewTypeVariables)($freeTypeVariables)));
  });
});

const $sp$Compiler$TypeCheck$unifyConstructorWithItsArgs = (($p) => {
  const $$try0 = ({
    first: $p.ty,
    second: $p.args,
  });
  if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try0.first)[0]) && ("$core$SPCore$Cons" === ($$try0.second)[0]))) {
    const $tail = ($$try0.second)[2];
    const $head = ($$try0.second)[1];
    const $to = ($$try0.first)[4];
    const $from = ($$try0.first)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($pa) => {
      const isFullyAnnotated$$ = $pa;
      const $vars = isFullyAnnotated$$.vars;
      const $ty = isFullyAnnotated$$.ty;
      const $pos = isFullyAnnotated$$.pos;
      const $isFullyAnnotated = isFullyAnnotated$$.isFullyAnnotated;
      return (($sp$Compiler$TypeCheck$andThen)((($unifiedFrom) => {
        return ($sp$Compiler$TypeCheck$unifyConstructorWithItsArgs)((Object.assign)({}, $p, ({
          argIndex: ($p.argIndex + 1),
          args: $tail,
          isFullyAnnotated: ($isFullyAnnotated && $p.isFullyAnnotated),
          ty: $to,
          vars: $vars,
        })));
      })))(((((($sp$Compiler$TypeCheck$unify)($p.env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument)($p)))($from))($ty));
    })))(((($sp$Compiler$TypeCheck$fromPattern)($p.env))($head))($p.vars));
  }
  if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try0.first)[0]) && ("$core$SPCore$Nil" === ($$try0.second)[0]))) {
    const $to = ($$try0.first)[4];
    const $from = ($$try0.first)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($ety) => {
      return ($sp$Compiler$TypeCheck$return)(({
        first: $p.vars,
        second: $ety,
        third: $p.isFullyAnnotated,
      }));
    })))((($sp$Compiler$TypeCheck$addError)($p.pos))((($core$SPCore$Cons)(("Type constructor " + ((sp_toHuman)($p.usr) + (" is missing argument #" + (text_fromNumber)($p.argIndex))))))($core$SPCore$Nil)));
  }
  if (("$core$SPCore$Nil" === ($$try0.second)[0])) {
    return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
      return ($sp$Compiler$TypeCheck$return)(({
        first: $p.vars,
        second: $p.ty,
        third: $p.isFullyAnnotated,
      }));
    })))(($sp$Compiler$TypeCheck$get)((($x) => {
      return $x.substitutions;
    })));
  }
  if (("$core$SPCore$Cons" === ($$try0.second)[0])) {
    const $tail = ($$try0.second)[2];
    const $head = ($$try0.second)[1];
    return (($sp$Compiler$TypeCheck$andThen)((($ety) => {
      return ($sp$Compiler$TypeCheck$return)(({
        first: $p.vars,
        second: $ety,
        third: $p.isFullyAnnotated,
      }));
    })))((($sp$Compiler$TypeCheck$addError)($p.pos))((($core$SPCore$Cons)(("Type constructor " + ((sp_toHuman)($p.usr) + " has too many args"))))($core$SPCore$Nil)));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1536:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck$fromPattern = (($env) => {
  return (($pattern) => {
    return (($vars_) => {
      const $vars = $vars_;
      const $$try0 = $pattern;
      if (("$sp$Types$CanonicalAst$PatternAny" === ($$try0)[0])) {
        const $maybeAnnotation = ($$try0)[3];
        const $maybeName = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $isAnnotated = ((sp_not_equal)($corelib$Maybe$Nothing))($maybeAnnotation);
        const $makeType = ((() => {
          const $$try1 = $maybeAnnotation;
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return ($sp$Compiler$TypeCheck$newType)($pos);
          }
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $type = ($$try1)[1];
            const $$try2 = (($sp$Compiler$ExpandTypes$expandAnnotation)($env.types))($type);
            if (("$corelib$Result$Err" === ($$try2)[0])) {
              const $e = ($$try2)[1];
              return (($sp$Compiler$TypeCheck$andThen)((() => {
                return ($sp$Compiler$TypeCheck$newType)($pos);
              })))(($sp$Compiler$TypeCheck$insertError)($e));
            }
            if (("$corelib$Result$Ok" === ($$try2)[0])) {
              const $t = ($$try2)[1];
              return ($sp$Compiler$TypeCheck$return)($t);
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1453:24', (sp_toHuman)($$try2));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1448:16', (sp_toHuman)($$try1));
        }))();
        return (($sp$Compiler$TypeCheck$andThen)((($type) => {
          const $newVars = ((() => {
            const $$try1 = $maybeName;
            if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
              return $vars;
            }
            if (("$corelib$Maybe$Just" === ($$try1)[0])) {
              const $name = ($$try1)[1];
              return ((($corelib$Dict$insert)($name))(({
                isAnnotated: $isAnnotated,
                pos: $pos,
                type: $type,
              })))($vars);
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1464:16', (sp_toHuman)($$try1));
          }))();
          return ($sp$Compiler$TypeCheck$return)(({
            isFullyAnnotated: $isAnnotated,
            pos: $pos,
            ty: $type,
            vars: $newVars,
          }));
        })))($makeType);
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try0)[0])) {
        const $literal = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ($sp$Compiler$TypeCheck$return)(({
          isFullyAnnotated: true,
          pos: $pos,
          ty: $sp$Compiler$CoreTypes$number,
          vars: $vars,
        }));
      }
      if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try0)[0])) {
        const $literal = ($$try0)[2];
        const $pos = ($$try0)[1];
        return ($sp$Compiler$TypeCheck$return)(({
          isFullyAnnotated: true,
          pos: $pos,
          ty: $sp$Compiler$CoreTypes$text,
          vars: $vars,
        }));
      }
      if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try0)[0])) {
        const $args = ($$try0)[3];
        const $usr = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $constructorTyM = ((() => {
          const $$try1 = (($corelib$Dict$get)($usr))($env.constructors);
          if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
            return ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr));
          }
          if (("$corelib$Maybe$Just" === ($$try1)[0])) {
            const $c = ($$try1)[1];
            return (($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1478:16', (sp_toHuman)($$try1));
        }))();
        return (($sp$Compiler$TypeCheck$andThen)((($constructorTy) => {
          const $p = ({
            argIndex: 0,
            args: $args,
            env: $env,
            isFullyAnnotated: true,
            pos: $pos,
            ty: $constructorTy,
            usr: $usr,
            vars: $vars,
          });
          return (($sp$Compiler$TypeCheck$andThen)(((isFullyAnnotated$$) => {
            const $isFullyAnnotated = isFullyAnnotated$$.third;
            const $patternTy = isFullyAnnotated$$.second;
            const $patternVars = isFullyAnnotated$$.first;
            return ($sp$Compiler$TypeCheck$return)(({
              isFullyAnnotated: $isFullyAnnotated,
              pos: $pos,
              ty: $patternTy,
              vars: $patternVars,
            }));
          })))(($sp$Compiler$TypeCheck$unifyConstructorWithItsArgs)($p));
        })))($constructorTyM);
        return null;
      }
      if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try0)[0])) {
        const $attrs = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $blah = (($name) => {
          return (($pa) => {
            return ((annotatedSoFar$$) => {
              const $annotatedSoFar = annotatedSoFar$$.third;
              const $attrTypes = annotatedSoFar$$.second;
              const $varsX = annotatedSoFar$$.first;
              return (($sp$Compiler$TypeCheck$andThen)((($paOut) => {
                return ($sp$Compiler$TypeCheck$return)(({
                  first: $paOut.vars,
                  second: ((($corelib$Dict$insert)($name))($paOut.ty))($attrTypes),
                  third: ($paOut.isFullyAnnotated && $annotatedSoFar),
                }));
              })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pa))($varsX));
            });
          });
        });
        return (($sp$Compiler$TypeCheck$andThen)(((attrTypes$$) => {
          const $isFullyAnnotated = attrTypes$$.third;
          const $attrTypes = attrTypes$$.second;
          const $vars1 = attrTypes$$.first;
          return ($sp$Compiler$TypeCheck$return)(({
            isFullyAnnotated: $isFullyAnnotated,
            pos: $pos,
            ty: ((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($attrTypes),
            vars: $vars1,
          }));
        })))(((($sp$Compiler$TypeCheck$dict_for)($attrs))($blah))(({
          first: $vars,
          second: $corelib$Dict$empty,
          third: true,
        })));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1441:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$TypeCheck$fromParameter = (($env) => {
  return (($param) => {
    const $$try0 = $param;
    if (("$sp$Types$CanonicalAst$ParameterPattern" === ($$try0)[0])) {
      const $pattern = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
        return ($sp$Compiler$TypeCheck$return)(({
          first: false,
          second: $patternOut,
        }));
      })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
    }
    if (("$sp$Types$CanonicalAst$ParameterMutable" === ($$try0)[0])) {
      const $paramName = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
        const $vars = (($corelib$Dict$singleton)($paramName))(({
          isAnnotated: false,
          pos: $pos,
          type: $ty,
        }));
        return ($sp$Compiler$TypeCheck$return)(({
          first: true,
          second: ({
            isFullyAnnotated: false,
            pos: $pos,
            ty: $ty,
            vars: $vars,
          }),
        }));
      })))(($sp$Compiler$TypeCheck$newType)($pos));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1336:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$insertPatternVar = (($pars) => {
  return (($name) => {
    return (($patternVar) => {
      return (($env) => {
        const $refinedTy = ($patternVar.isAnnotated
          ? $patternVar.type
          : (($sp$Compiler$TypeCheck$replaceTypeVariables)($pars.subs))($patternVar.type));
        const $ref = ($pars.isRoot
          ? ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($env.currentModule))($name))
          : ($sp$Types$CanonicalAst$RefBlock)($name));
        return ($sp$Compiler$TypeCheck$return)(({
          constructors: $env.constructors,
          currentModule: $env.currentModule,
          instanceVariables: ((($corelib$Dict$insert)($ref))(({
            definedAt: $patternVar.pos,
            freeTypeVariables: (($pars.isMutable || $pars.isParameter)
              ? $corelib$Dict$empty
              : ((($sp$Types$CanonicalAst$getFreeTypeVars)($env.nonFreeTyvars))($corelib$Dict$empty))($refinedTy)),
            isMutable: $pars.isMutable,
            ty: $refinedTy,
          })))($env.instanceVariables),
          meta: $env.meta,
          nonAnnotatedRecursives: ($patternVar.isAnnotated
            ? $env.nonAnnotatedRecursives
            : ((($corelib$Dict$insert)($name))($patternVar.pos))($env.nonAnnotatedRecursives)),
          nonFreeTyvars: ($pars.isParameter
            ? ((($corelib$Dict$for)(($sp$Types$CanonicalAst$typeTyvars)($refinedTy)))($corelib$Dict$insert))($env.nonFreeTyvars)
            : $env.nonFreeTyvars),
          types: $env.types,
        }));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$insertPatternVars = (($pars) => {
  return (($vars) => {
    return (($sp$Compiler$TypeCheck$dict_for)($vars))(($sp$Compiler$TypeCheck$insertPatternVar)($pars));
  });
});

const $sp$Compiler$TypeCheck$fromPatternAndBlock = (($env) => {
  return ((block$$) => {
    const $block = block$$.second;
    const $pattern = block$$.first;
    return ((blockTypeSoFar$$) => {
      const $blockTypeSoFar = blockTypeSoFar$$.second;
      const $patternTypeSoFar = blockTypeSoFar$$.first;
      return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
        return (($sp$Compiler$TypeCheck$andThen)((($unifiedPatternType) => {
          return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
            return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
              const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                isMutable: false,
                isParameter: false,
                isRoot: false,
                subs: $subs,
              })))($patternOut.vars))($env1);
              return (($sp$Compiler$TypeCheck$andThen)((($patternEnv) => {
                return (($sp$Compiler$TypeCheck$andThen)((($blockType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($unifiedBlockType) => {
                    return ($sp$Compiler$TypeCheck$return)(({
                      first: $unifiedPatternType,
                      second: $unifiedBlockType,
                    }));
                  })))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))(($sp$Compiler$TypeCheck$UnifyReason_TryBlock)($block)))($blockTypeSoFar))($blockType));
                })))((($sp$Compiler$TypeCheck$fromExpression)($patternEnv))($block));
              })))($ip);
            })))(($sp$Compiler$TypeCheck$get)((($x) => {
              return $x.substitutions;
            })));
          })))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env));
        })))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_TryPattern))($patternOut.ty))($patternTypeSoFar));
      })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
    });
  });
});

const $sp$Types$CanonicalAst$argumentPos = (($arg) => {
  const $$try0 = $arg;
  if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try0)[0])) {
    const $e = ($$try0)[1];
    return ($sp$Types$CanonicalAst$expressionPos)($e);
  }
  if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try0)[0])) {
    const $pos = ($$try0)[1];
    return $pos;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 234:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType = (($env) => {
  return (($reference) => {
    return (($referenceType) => {
      return (($callIsMutable) => {
        return (($argument) => {
          return (($callArgumentType) => {
            const $$try0 = $referenceType;
            if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
              const $refReturnType = ($$try0)[4];
              const $refIsMutable = ($$try0)[3];
              const $refArgumentType = ($$try0)[2];
              return (((sp_not_equal)($refIsMutable))($callIsMutable)
                ? (($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$expressionPos)($reference)))((($core$SPCore$Cons)("mutability clash 2"))($core$SPCore$Nil))
                : ((() => {
                  const $pos = ($sp$Types$CanonicalAst$expressionPos)($reference);
                  const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
                    argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
                    reference: $pos,
                  }));
                  return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                    return ($sp$Compiler$TypeCheck$applySubsToType)($refReturnType);
                  })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($refArgumentType))($callArgumentType));
                }))());
            }
            if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
              const $name = ($$try0)[2];
              const $pos = ($$try0)[1];
              return (($sp$Compiler$TypeCheck$andThen)((($returnType) => {
                const $ty = (((($sp$Types$CanonicalAst$TypeFunction)($pos))($callArgumentType))($callIsMutable))($returnType);
                return (($sp$Compiler$TypeCheck$andThen)((() => {
                  return ($sp$Compiler$TypeCheck$applySubsToType)($returnType);
                })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))((($sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction)($pos))($referenceType)))($referenceType))($ty));
              })))(($sp$Compiler$TypeCheck$newType)($pos));
            }
            if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
              const $ty = ($$try0)[3];
              const $pos = ($$try0)[1];
              return (((((($sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType)($env))($reference))($ty))($callIsMutable))($argument))($callArgumentType);
            }
            if (true) {
              return (($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$expressionPos)($reference)))((($core$SPCore$Cons)("This is being called like a function, but its type is"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil))));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1236:4', (sp_toHuman)($$try0));
          });
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$fromExpression = (($env) => {
  return (($expression) => {
    const $$try0 = $expression;
    if (("$sp$Types$CanonicalAst$LiteralText" === ($$try0)[0])) {
      const $l = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($sp$Compiler$TypeCheck$return)($sp$Compiler$CoreTypes$text);
    }
    if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try0)[0])) {
      const $l = ($$try0)[2];
      const $pos = ($$try0)[1];
      return ($sp$Compiler$TypeCheck$return)($sp$Compiler$CoreTypes$number);
    }
    if (("$sp$Types$CanonicalAst$Variable" === ($$try0)[0])) {
      const $ref = ($$try0)[2].ref;
      const $attrPath = ($$try0)[2].attrPath;
      const $pos = ($$try0)[1];
      const $$try1 = (($corelib$Dict$get)($ref))($env.instanceVariables);
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref);
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $var = ($$try1)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($varType) => {
          return (((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($varType);
        })))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)($var.freeTypeVariables))($var.ty));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1080:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$Constructor" === ($$try0)[0])) {
      const $usr = ($$try0)[2];
      const $pos = ($$try0)[1];
      const $$try1 = (($corelib$Dict$get)($usr))($env.constructors);
      if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
        return ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr));
      }
      if (("$corelib$Maybe$Just" === ($$try1)[0])) {
        const $c = ($$try1)[1];
        return (($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1154:12', (sp_toHuman)($$try1));
      return null;
    }
    if (("$sp$Types$CanonicalAst$Lambda" === ($$try0)[0])) {
      const $body = ($$try0)[3];
      const $param = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)(((isMutable$$) => {
        const $patternOut = isMutable$$.second;
        const $isMutable = isMutable$$.first;
        const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
          isMutable: $isMutable,
          isParameter: true,
          isRoot: false,
          subs: $corelib$Dict$empty,
        })))($patternOut.vars))($env);
        return (($sp$Compiler$TypeCheck$andThen)((($bodyEnv) => {
          return (($sp$Compiler$TypeCheck$andThen)((($bodyType) => {
            return (($sp$Compiler$TypeCheck$andThen)((($refinedPatternOutTy) => {
              return (($isMutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($refinedPatternOutTy))
                ? (($sp$Compiler$TypeCheck$errorTodo)($pos))("mutable args cannot be functions")
                : ($sp$Compiler$TypeCheck$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($refinedPatternOutTy))($isMutable))($bodyType)));
            })))(($sp$Compiler$TypeCheck$applySubsToType)($patternOut.ty));
          })))((($sp$Compiler$TypeCheck$fromExpression)($bodyEnv))($body));
        })))($ip);
      })))((($sp$Compiler$TypeCheck$fromParameter)($env))($param));
    }
    if (("$sp$Types$CanonicalAst$Call" === ($$try0)[0])) {
      const $argument = ($$try0)[3];
      const $reference = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($referenceType) => {
        return (($sp$Compiler$TypeCheck$andThen)(((argumentType$$) => {
          const $argumentType = argumentType$$.second;
          const $fromIsMutable = argumentType$$.first;
          return (((((($sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType)($env))($reference))($referenceType))($fromIsMutable))($argument))($argumentType);
        })))((($sp$Compiler$TypeCheck$fromArgument)($env))($argument));
      })))((($sp$Compiler$TypeCheck$fromExpression)($env))($reference));
    }
    if (("$sp$Types$CanonicalAst$If" === ($$try0)[0])) {
      const $ar = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((() => {
        return (($sp$Compiler$TypeCheck$andThen)((($s) => {
          return (($sp$Compiler$TypeCheck$andThen)((($trueType) => {
            return (($sp$Compiler$TypeCheck$andThen)((($falseType) => {
              return ((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_IfBranches))($trueType))($falseType);
            })))((($sp$Compiler$TypeCheck$fromExpression)($env))($ar.false));
          })))((($sp$Compiler$TypeCheck$fromExpression)($env))($ar.true));
        })))(($sp$Compiler$TypeCheck$get)((($x) => {
          return $x.substitutions;
        })));
      })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($sp$Compiler$CoreTypes$bool))($ar.condition));
    }
    if (("$sp$Types$CanonicalAst$Try" === ($$try0)[0])) {
      const $patternsAndBlocks = ($$try0)[3];
      const $value = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($tryType) => {
        return (($sp$Compiler$TypeCheck$andThen)((($newBlockType) => {
          return (($sp$Compiler$TypeCheck$andThen)(((inferredBlockType$$) => {
            const $inferredBlockType = inferredBlockType$$.second;
            const $patternType = inferredBlockType$$.first;
            return ($sp$Compiler$TypeCheck$return)($inferredBlockType);
          })))(((($sp$Compiler$TypeCheck$list_for)($patternsAndBlocks))(($sp$Compiler$TypeCheck$fromPatternAndBlock)($env)))(({
            first: $tryType,
            second: $newBlockType,
          })));
        })))(($sp$Compiler$TypeCheck$newType)($pos));
      })))((($sp$Compiler$TypeCheck$fromExpression)($env))($value));
    }
    if (("$sp$Types$CanonicalAst$Record" === ($$try0)[0])) {
      const $attrValues = ($$try0)[3];
      const $maybeExt = ($$try0)[2];
      const $pos = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($attrTypes) => {
        const $$try1 = $maybeExt;
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($attrTypes));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $variableArgs = ($$try1)[1];
          return (($sp$Compiler$TypeCheck$andThen)((($ty_) => {
            return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return (($sp$Compiler$TypeCheck$andThen)((($name) => {
                return (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => {
                  return ($sp$Compiler$TypeCheck$return)($unifiedType);
                })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate)(($corelib$Dict$keys)($attrTypes))))($ty))(((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($name)))($attrTypes)));
              })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
            })))(($sp$Compiler$TypeCheck$applySubsToType)($ty_));
          })))((($sp$Compiler$TypeCheck$fromExpression)($env))((($sp$Types$CanonicalAst$Variable)($pos))($variableArgs)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1210:12', (sp_toHuman)($$try1));
      })))((($sp$Compiler$TypeCheck$dict_map)((($k) => {
        return ($sp$Compiler$TypeCheck$fromExpression)($env);
      })))($attrValues));
    }
    if (("$sp$Types$CanonicalAst$LetIn" === ($$try0)[0])) {
      const $expression = ($$try0)[2];
      const $valueDef = ($$try0)[1];
      return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
        return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
          return (($valueDef.mutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($ty))
            ? (($sp$Compiler$TypeCheck$andThen)((() => {
              return ($sp$Compiler$TypeCheck$return)($ty);
            })))((($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$patternPos)($valueDef.pattern)))((($core$SPCore$Cons)("blocks that define mutables can't return functions"))($core$SPCore$Nil)))
            : ($sp$Compiler$TypeCheck$return)($ty));
        })))((($sp$Compiler$TypeCheck$fromExpression)($env1))($expression));
      })))(((($sp$Compiler$TypeCheck$fromDefinition)(false))($valueDef))($env));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1072:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$fromDefinition = (($isRoot) => {
  return (($def) => {
    return (($env) => {
      return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
        const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
          isMutable: $def.mutable,
          isParameter: false,
          isRoot: $isRoot,
          subs: $corelib$Dict$empty,
        })))($patternOut.vars))($env);
        return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
          return ($def.native
            ? ($sp$Compiler$TypeCheck$return)($env1)
            : ($patternOut.isFullyAnnotated
              ? (($sp$Compiler$TypeCheck$andThen)((() => {
                return ($sp$Compiler$TypeCheck$return)($env1);
              })))(((($sp$Compiler$TypeCheck$checkExpression)($env1))($patternOut.ty))($def.body))
              : (($sp$Compiler$TypeCheck$andThen)((($bodyType_) => {
                return (($sp$Compiler$TypeCheck$andThen)((($bodyType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => {
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return (($sp$Compiler$TypeCheck$andThen)((($env2) => {
                        return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                          return ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                            isMutable: $def.mutable,
                            isParameter: false,
                            isRoot: $isRoot,
                            subs: $subs,
                          })))($patternOut.vars))($env2);
                        })))(($sp$Compiler$TypeCheck$get)((($x) => {
                          return $x.substitutions;
                        })));
                      })))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env1));
                    })))((((($sp$Compiler$TypeCheck$checkFreeVariables)($env1))($patternOut.pos))($patternOut.ty))($bodyType));
                  })))(((((($sp$Compiler$TypeCheck$unify)($env1))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern))($bodyType))($patternOut.ty));
                })))(($sp$Compiler$TypeCheck$applySubsToType)($bodyType_));
              })))((($sp$Compiler$TypeCheck$fromExpression)($env1))($def.body))));
        })))($ip);
      })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($def.pattern))($corelib$Dict$empty));
    });
  });
});

const $sp$Compiler$TypeCheck$checkExpression = (($env) => {
  return (($expectedType_) => {
    return (($expression) => {
      const $expectedType = ($sp$Compiler$TypeCheck$expandAlias)($expectedType_);
      const $$try0 = $expression;
      if (("$sp$Types$CanonicalAst$LiteralText" === ($$try0)[0])) {
        const $l = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($sp$Compiler$CoreTypes$text);
      }
      if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try0)[0])) {
        const $l = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($sp$Compiler$CoreTypes$number);
      }
      if (("$sp$Types$CanonicalAst$Variable" === ($$try0)[0])) {
        const $ref = ($$try0)[2].ref;
        const $attrPath = ($$try0)[2].attrPath;
        const $pos = ($$try0)[1];
        const $$try1 = (($corelib$Dict$get)($ref))($env.instanceVariables);
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(null);
          })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $var = ($$try1)[1];
          return (($sp$Compiler$TypeCheck$andThen)((($instantiatedType) => {
            return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($ty);
            })))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($instantiatedType));
          })))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)($var.freeTypeVariables))($var.ty));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 799:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$CanonicalAst$Constructor" === ($$try0)[0])) {
        const $usr = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = (($corelib$Dict$get)($usr))($env.constructors);
        if (("$corelib$Maybe$Nothing" === ($$try1)[0])) {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(null);
          })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr)));
        }
        if (("$corelib$Maybe$Just" === ($$try1)[0])) {
          const $c = ($$try1)[1];
          return (($sp$Compiler$TypeCheck$andThen)((($instantiatedType) => {
            return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($instantiatedType);
          })))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 818:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$CanonicalAst$Lambda" === ($$try0)[0])) {
        const $body = ($$try0)[3];
        const $param = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = ({
          first: $expectedType,
          second: $param,
        });
        if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try1.first)[0]) && ((true === ($$try1.first)[3]) && ("$sp$Types$CanonicalAst$ParameterMutable" === ($$try1.second)[0])))) {
          const $parameterName = ($$try1.second)[2];
          const $parameterPos = ($$try1.second)[1];
          const $returnType = ($$try1.first)[4];
          const $parameterType = ($$try1.first)[2];
          const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
            isMutable: true,
            isParameter: true,
            isRoot: false,
            subs: $corelib$Dict$empty,
          })))((($corelib$Dict$singleton)($parameterName))(({
            isAnnotated: true,
            pos: $parameterPos,
            type: $parameterType,
          }))))($env);
          return (($sp$Compiler$TypeCheck$andThen)((($localEnv) => {
            return ((($sp$Compiler$TypeCheck$checkExpression)($localEnv))($returnType))($body);
          })))($ip);
          return null;
        }
        if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try1.first)[0]) && ((false === ($$try1.first)[3]) && ("$sp$Types$CanonicalAst$ParameterPattern" === ($$try1.second)[0])))) {
          const $pattern = ($$try1.second)[1];
          const $returnType = ($$try1.first)[4];
          const $parameterType = ($$try1.first)[2];
          return (($sp$Compiler$TypeCheck$andThen)((($localEnv) => {
            return ((($sp$Compiler$TypeCheck$checkExpression)($localEnv))($returnType))($body);
          })))(((($sp$Compiler$TypeCheck$checkAndInsertPattern)($env))($parameterType))($pattern));
        }
        if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try1.first)[0])) {
          const $isMutable = ($$try1.first)[3];
          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("the function and the annotation have different mutability"))($core$SPCore$Nil));
        }
        if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try1.first)[0])) {
          const $name = ($$try1.first)[2];
          const $pos = ($$try1.first)[1];
          return (($sp$Compiler$TypeCheck$isAnnotation)($name)
            ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This is a function, but the annotation says it should be of type variable `" + ($name + "` which implies that it could be of any type!"))))($core$SPCore$Nil))
            : (($sp$Compiler$TypeCheck$andThen)((($actualType) => {
              return (($sp$Compiler$TypeCheck$andThen)((() => {
                return ($sp$Compiler$TypeCheck$return)(null);
              })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_IsLambda))($expectedType))($actualType));
            })))((($sp$Compiler$TypeCheck$fromExpression)($env))($expression)));
        }
        if (true) {
          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("This is a function, but the annotation says it should be a: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))($core$SPCore$Nil)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 832:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$CanonicalAst$Call" === ($$try0)[0])) {
        const $argument = ($$try0)[3];
        const $reference = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($referenceType_) => {
          const $referenceType = ($sp$Compiler$TypeCheck$expandAlias)($referenceType_);
          const $$try1 = $referenceType;
          if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try1)[0])) {
            const $returnType = ($$try1)[4];
            const $isMutable = ($$try1)[3];
            const $parameterType = ($$try1)[2];
            const $$try2 = $argument;
            if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try2)[0])) {
              const $argumentExpression = ($$try2)[1];
              return (($sp$Compiler$TypeCheck$andThen)((($argumentType) => {
                const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
                  argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
                  reference: $pos,
                }));
                return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($actualReturnType) => {
                    return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($actualReturnType);
                  })))(($sp$Compiler$TypeCheck$applySubsToType)($returnType));
                })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($argumentType))($parameterType));
              })))((($sp$Compiler$TypeCheck$fromExpression)($env))($argumentExpression));
            }
            if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try2)[0])) {
              const $ref = ($$try2)[2].ref;
              const $attrPath = ($$try2)[2].attrPath;
              const $pos = ($$try2)[1];
              const $$try3 = (($corelib$Dict$get)($ref))($env.instanceVariables);
              if (("$corelib$Maybe$Nothing" === ($$try3)[0])) {
                return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                  return ($sp$Compiler$TypeCheck$return)(null);
                })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref));
              }
              if (("$corelib$Maybe$Just" === ($$try3)[0])) {
                const $var = ($$try3)[1];
                return (($corelib$Basics$not)($var.isMutable)
                  ? ((() => {
                    const $ae = (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("You are trying to mutate variable `" + ((sp_toHuman)($ref) + "` but it was declared as not mutable!"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("TODO [link to wiki page that explains how to declare variables]"))($core$SPCore$Nil))));
                    return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                      return ($sp$Compiler$TypeCheck$return)(null);
                    })))($ae);
                  }))()
                  : (($sp$Compiler$TypeCheck$typeContainsFunctions)($var.ty)
                    ? (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                      return ($sp$Compiler$TypeCheck$return)(null);
                    })))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("mutable arguments can't allow functions"))($core$SPCore$Nil)))
                    : (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                      const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
                        argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
                        reference: $pos,
                      }));
                      return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                        return (($sp$Compiler$TypeCheck$andThen)((($actualReturnType) => {
                          return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($actualReturnType);
                        })))(($sp$Compiler$TypeCheck$applySubsToType)($returnType));
                      })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($ty))($parameterType));
                    })))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($var.ty))));
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 912:28', (sp_toHuman)($$try3));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 882:20', (sp_toHuman)($$try2));
            return null;
          }
          if (true) {
            return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("The code is trying to call this as if it was a function, but its type is: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil)));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 879:12', (sp_toHuman)($$try1));
        })))((($sp$Compiler$TypeCheck$fromExpression)($env))($reference));
      }
      if (("$sp$Types$CanonicalAst$If" === ($$try0)[0])) {
        const $true = ($$try0)[2].true;
        const $false = ($$try0)[2].false;
        const $condition = ($$try0)[2].condition;
        const $pos = ($$try0)[1];
        return (($sp$Compiler$TypeCheck$andThen)((() => {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedType))($false);
          })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedType))($true));
        })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($sp$Compiler$CoreTypes$bool))($condition));
      }
      if (("$sp$Types$CanonicalAst$Try" === ($$try0)[0])) {
        const $patternsAndBlocks = ($$try0)[3];
        const $value = ($$try0)[2];
        const $pos = ($$try0)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($inferredValueType) => {
          const $xxx = ((($sp$Compiler$TypeCheck$list_for)($patternsAndBlocks))(((block$$) => {
            const $block = block$$.second;
            const $pattern = block$$.first;
            return (($patternTypeSoFar) => {
              return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
                return (($sp$Compiler$TypeCheck$andThen)((($unifiedPatternType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
                    return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                      const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                        isMutable: false,
                        isParameter: false,
                        isRoot: false,
                        subs: $subs,
                      })))($patternOut.vars))($env1);
                      return (($sp$Compiler$TypeCheck$andThen)((($patternEnv) => {
                        return (($sp$Compiler$TypeCheck$andThen)((() => {
                          return ($sp$Compiler$TypeCheck$return)($unifiedPatternType);
                        })))(((($sp$Compiler$TypeCheck$checkExpression)($patternEnv))($expectedType))($block));
                      })))($ip);
                    })))(($sp$Compiler$TypeCheck$get)((($x) => {
                      return $x.substitutions;
                    })));
                  })))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env));
                })))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_TryPattern))($patternOut.ty))($patternTypeSoFar));
              })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
            });
          })))($inferredValueType);
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(null);
          })))($xxx);
        })))((($sp$Compiler$TypeCheck$fromExpression)($env))($value));
      }
      if (("$sp$Types$CanonicalAst$Record" === ($$try0)[0])) {
        const $attrValueByName = ($$try0)[3];
        const $maybeExtending = ($$try0)[2];
        const $pos = ($$try0)[1];
        const $$try1 = $expectedType;
        if ((("$sp$Types$CanonicalAst$TypeRecord" === ($$try1)[0]) && ("$corelib$Maybe$Just" === (($$try1)[2])[0]))) {
          const $attrTypeByName = ($$try1)[3];
          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("Extensible record annotation is experimentally disabled [TODO link to why]"))($core$SPCore$Nil));
        }
        if ((("$sp$Types$CanonicalAst$TypeRecord" === ($$try1)[0]) && ("$corelib$Maybe$Nothing" === (($$try1)[2])[0]))) {
          const $attrTypeByName = ($$try1)[3];
          const $$try2 = $maybeExtending;
          if (("$corelib$Maybe$Nothing" === ($$try2)[0])) {
            const $xxx = ((($sp$Compiler$TypeCheck$dict_for)($attrValueByName))((($attrName) => {
              return (($attrValue) => {
                return (() => {
                  const $$try3 = (($corelib$Dict$get)($attrName))($attrTypeByName);
                  if (("$corelib$Maybe$Nothing" === ($$try3)[0])) {
                    return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record has an attribute `" + ($attrName + "` which is not in the annotation."))))($core$SPCore$Nil));
                  }
                  if (("$corelib$Maybe$Just" === ($$try3)[0])) {
                    const $expectedAttrType = ($$try3)[1];
                    return ((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedAttrType))($attrValue);
                  }
                  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1005:36', (sp_toHuman)($$try3));
                });
              });
            })))(null);
            return (($sp$Compiler$TypeCheck$andThen)((() => {
              return ((($sp$Compiler$TypeCheck$dict_for)($attrTypeByName))((($attrName) => {
                return (($attrType) => {
                  return (() => {
                    const $$try3 = (($corelib$Dict$get)($attrName))($attrTypeByName);
                    if (("$corelib$Maybe$Nothing" === ($$try3)[0])) {
                      return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record is missing the attribute `" + ($attrName + "`"))))($core$SPCore$Nil));
                    }
                    if (("$corelib$Maybe$Just" === ($$try3)[0])) {
                      return ($sp$Compiler$TypeCheck$return)(null);
                    }
                    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1017:36', (sp_toHuman)($$try3));
                  });
                });
              })))(null);
            })))($xxx);
            return null;
          }
          if (("$corelib$Maybe$Just" === ($$try2)[0])) {
            const $extending = ($$try2)[1];
            return (($sp$Compiler$TypeCheck$andThen)((() => {
              return ((($sp$Compiler$TypeCheck$dict_for)($attrValueByName))((($attrName) => {
                return (($attrValue) => {
                  return (() => {
                    const $$try3 = (($corelib$Dict$get)($attrName))($attrTypeByName);
                    if (("$corelib$Maybe$Nothing" === ($$try3)[0])) {
                      return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record has an attribute `" + ($attrName + "` which is not in the annotation"))))($core$SPCore$Nil));
                    }
                    if (("$corelib$Maybe$Just" === ($$try3)[0])) {
                      const $expectedAttrType = ($$try3)[1];
                      return ((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedAttrType))($attrValue);
                    }
                    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1033:32', (sp_toHuman)($$try3));
                  });
                });
              })))(null);
            })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedType))((($sp$Types$CanonicalAst$Variable)($pos))($extending)));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1001:20', (sp_toHuman)($$try2));
          return null;
        }
        if (true) {
          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("This is a record, but the annotation says that this should be a"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))($core$SPCore$Nil)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 994:12', (sp_toHuman)($$try1));
        return null;
      }
      if (("$sp$Types$CanonicalAst$LetIn" === ($$try0)[0])) {
        const $expression = ($$try0)[2];
        const $valueDef = ($$try0)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
          const $xxx = (($valueDef.mutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($expectedType))
            ? (($sp$Compiler$TypeCheck$addCheckError)(($sp$Types$CanonicalAst$patternPos)($valueDef.pattern)))((($core$SPCore$Cons)("blocks that define mutables can't return functions"))($core$SPCore$Nil))
            : ($sp$Compiler$TypeCheck$return)(null));
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ((($sp$Compiler$TypeCheck$checkExpression)($env1))($expectedType))($expression);
          })))($xxx);
        })))(((($sp$Compiler$TypeCheck$fromDefinition)(false))($valueDef))($env));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 791:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Compiler$TypeCheck$initState = ({
  errors: $core$SPCore$Nil,
  nextName: 0,
  nonFnTyvars: $corelib$Dict$empty,
  substitutions: $corelib$Dict$empty,
  typeClashesByPlaceholderId: $corelib$Maybe$Nothing,
});

const $sp$StateMonad$run = (($state) => {
  return (($m) => {
    return ($m)($state);
  });
});

const $sp$Compiler$TypeCheck$fromModule = (($env) => {
  return (($module) => {
    (sp_benchStart)(null);
    const $insert = (($pa) => {
      return (($def) => {
        return ((ann$$) => {
          const $nonAnn = ann$$.second;
          const $ann = ann$$.first;
          const $allAnnotated = (($corelib$List$all)(((maybeType$$) => {
            const $maybeType = maybeType$$.second;
            const $pos = maybeType$$.first;
            return ((sp_not_equal)($corelib$Maybe$Nothing))($maybeType);
          })))(($corelib$Dict$values)(($sp$Types$CanonicalAst$patternNamedTypes)($pa)));
          return ($allAnnotated
            ? ({
              first: ((sp_cons)($ann))($def),
              second: $nonAnn,
            })
            : ({
              first: $ann,
              second: ((sp_cons)($nonAnn))($def),
            }));
        });
      });
    });
    const annotated$$ = ((($corelib$Dict$for)($module.valueDefs))($insert))(({
      first: $core$SPCore$Nil,
      second: $core$SPCore$Nil,
    }));
    const $nonAnnotated = annotated$$.second;
    const $annotated = annotated$$.first;
    const $$try0 = $nonAnnotated;
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Cons" === (($$try0)[2])[0]))) {
      const $tail = (($$try0)[2])[2];
      const $second = (($$try0)[2])[1];
      const $first = ($$try0)[1];
      const $pos = ($sp$Types$CanonicalAst$patternPos)($first.pattern);
      const $names = (($corelib$List$concatMap)((($d) => {
        return ($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNamedTypes)($d.pattern));
      })))($nonAnnotated);
      return (($sp$Compiler$Error$res)(($sp$Types$CanonicalAst$patternPos)($first.pattern)))((($eenv) => {
        return ((($corelib$Basics$btw)(sp_benchStop))("type check"))((($core$SPCore$Cons)("Support for non-annotated root definitions is not yet implemented. =*("))((($core$SPCore$Cons)(("These definitions need an annotation: " + (($corelib$Text$join)(", "))($names))))($core$SPCore$Nil)));
      }));
      return null;
    }
    if (true) {
      const $orderedNonAnnotated = $nonAnnotated;
      const $allOrdered = ($corelib$List$concat)((($core$SPCore$Cons)($orderedNonAnnotated))((($core$SPCore$Cons)($annotated))($core$SPCore$Nil)));
      const envF$$ = (($sp$StateMonad$run)($sp$Compiler$TypeCheck$initState))(((($sp$Compiler$TypeCheck$list_for)($allOrdered))(($sp$Compiler$TypeCheck$fromDefinition)(true)))($env));
      const $stateF = envF$$.second;
      const $envF = envF$$.first;
      return (((sp_equal)($core$SPCore$Nil))($stateF.errors)
        ? ((($corelib$Basics$btw)(sp_benchStop))("type check"))(($corelib$Result$Ok)($envF))
        : ((($corelib$Basics$btw)(sp_benchStop))("type check"))(($corelib$Result$Err)(($sp$Compiler$Error$Nested)($stateF.errors))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 352:4', (sp_toHuman)($$try0));
  });
});

const $sp$Compiler$TypeCheck$splitName = (($s) => {
  const $$try0 = ((text_split)("."))($s);
  if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[2])[2])[0])))) {
    const $valueName = (($$try0)[2])[1];
    const $moduleName = ($$try0)[1];
    return ({
      first: ($corelib$Maybe$Just)($moduleName),
      second: $valueName,
    });
  }
  if (true) {
    return ({
      first: $corelib$Maybe$Nothing,
      second: $s,
    });
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2252:4', (sp_toHuman)($$try0));
});

const $sp$Compiler$TypeCheck_Test$outToHuman = (($out) => {
  const $freeVars = $out.freeTypeVariables;
  const $nf = (($corelib$Text$join)(", "))(($corelib$Dict$keys)((($corelib$Dict$filter)((($k) => {
    return (($v) => {
      return $v.nonFn;
    });
  })))($freeVars)));
  return (($corelib$Text$join)("\n"))((($core$SPCore$Cons)(("  freeTypeVariables = [ " + ((($corelib$Text$join)(", "))(($corelib$Dict$keys)($freeVars)) + " ]"))))((($core$SPCore$Cons)(("  (NonFunction = [" + ($nf + "])"))))((($core$SPCore$Cons)(("  isMutable = " + (sp_toHuman)($out.isMutable))))((($core$SPCore$Cons)(("  ty = " + ((($sp$Human$CanonicalAst$typeToText)($sp$Compiler$TestHelpers$moduleUmr))($sp$Compiler$TestHelpers$meta))($out.ty))))((($core$SPCore$Cons)(("  pos = " + (sp_toHuman)($out.ty))))($core$SPCore$Nil))))));
});

const $sp$Compiler$TypeCheck_Test$codeTest = ($sp$Test$codeTest)($sp$Compiler$TypeCheck_Test$outToHuman);

const $sp$Compiler$TypeCheck_Test$forall = (($vars) => {
  return ((($corelib$List$for)($vars))((($n) => {
    return (($corelib$Dict$insert)($n))(({
      nonFn: false,
    }));
  })))($corelib$Dict$empty);
});

const $sp$Compiler$TypeCheck_Test$ftv = (($n) => {
  return (($corelib$Dict$singleton)($n))(({
    nonFn: false,
  }));
});

const $sp$Compiler$TypeCheck_Test$function = (($from) => {
  return (($to) => {
    return (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$T))($from))(false))($to);
  });
});

const $sp$Compiler$TypeCheck_Test$tyNone = $sp$Compiler$TestHelpers$noneType;

const $sp$Compiler$TypeCheck_Test$tyNumber = $sp$Compiler$TestHelpers$numberType;

const $sp$Compiler$TypeCheck_Test$typeFunction = ($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$T);

const $sp$Human$CanonicalAst$initNstate = ({
  next: 0,
  replacements: $corelib$Dict$empty,
});

const $sp$Human$CanonicalAst$andThen = $sp$StateMonad$andThen;

const $sp$Human$CanonicalAst$get = $sp$StateMonad$get;

const $sp$Human$CanonicalAst$intToName = (($n) => {
  return (($acc) => {
    const $$try0 = $n;
    if ((0 === $$try0)) {
      return "a";
    }
    if ((1 === $$try0)) {
      return "b";
    }
    if ((2 === $$try0)) {
      return "c";
    }
    if ((3 === $$try0)) {
      return "d";
    }
    if ((4 === $$try0)) {
      return "e";
    }
    if ((5 === $$try0)) {
      return "f";
    }
    if (true) {
      return (sp_todo)("intToName");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 163:4', (sp_toHuman)($$try0));
  });
});

const $sp$Human$CanonicalAst$newName = (($state) => {
  return ({
    first: (($sp$Human$CanonicalAst$intToName)($state.next))($core$SPCore$Nil),
    second: (Object.assign)({}, $state, ({
      next: ($state.next + 1),
    })),
  });
});

const $sp$Human$CanonicalAst$return = $sp$StateMonad$return;

const $sp$Human$CanonicalAst$normName = (($name) => {
  return ((((text_length)($name) > 1) && ((sp_equal)($corelib$Maybe$Nothing))((text_toNumber)($name)))
    ? ($sp$Human$CanonicalAst$return)($name)
    : (($sp$Human$CanonicalAst$andThen)((($n2l) => {
      const $$try0 = (($corelib$Dict$get)($name))($n2l);
      if (("$corelib$Maybe$Just" === ($$try0)[0])) {
        const $replacement = ($$try0)[1];
        return ($sp$Human$CanonicalAst$return)($replacement);
      }
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return (($sp$Human$CanonicalAst$andThen)((($n) => {
          const $addReplacement = (($s) => {
            return (Object.assign)({}, $s, ({
              replacements: ((($corelib$Dict$insert)($name))($n))($s.replacements),
            }));
          });
          return (($sp$Human$CanonicalAst$andThen)((() => {
            return ($sp$Human$CanonicalAst$return)($n);
          })))(($sp$StateMonad$update)($addReplacement));
        })))($sp$Human$CanonicalAst$newName);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 274:8', (sp_toHuman)($$try0));
    })))(($sp$Human$CanonicalAst$get)((($x) => {
      return $x.replacements;
    }))));
});

const $sp$StateMonad$list_map = (($f) => {
  return (($la) => {
    const $apply = (($a) => {
      return (($accum) => {
        return (($sp$StateMonad$andThen)((($b) => {
          return ($sp$StateMonad$return)(((sp_cons)($accum))($b));
        })))(($f)($a));
      });
    });
    return (($sp$StateMonad$andThen)((($x) => {
      return ($sp$StateMonad$return)(($corelib$List$reverse)($x));
    })))(((($sp$StateMonad$list_foldl)($apply))($la))($core$SPCore$Nil));
  });
});

const $sp$StateMonad$maybe_map = (($f) => {
  return (($ma) => {
    const $$try0 = $ma;
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return ($sp$StateMonad$return)($corelib$Maybe$Nothing);
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return (($sp$StateMonad$andThen)((($b) => {
        return ($sp$StateMonad$return)(($corelib$Maybe$Just)($b));
      })))(($f)($a));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/StateMonad.sp 66:4', (sp_toHuman)($$try0));
  });
});

const $sp$Human$CanonicalAst$normType = (($ty) => {
  const $$try0 = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
    const $args = ($$try0)[3];
    const $name = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($sp$Human$CanonicalAst$andThen)((($args_n) => {
      return ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($name))($args_n));
    })))((($sp$StateMonad$list_map)($sp$Human$CanonicalAst$normType))($args));
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
    const $name = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($sp$Human$CanonicalAst$andThen)((($n) => {
      return ($sp$Human$CanonicalAst$return)((($sp$Types$CanonicalAst$TypeVariable)($pos))($n));
    })))(($sp$Human$CanonicalAst$normName)($name));
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
    const $to0 = ($$try0)[4];
    const $fromIsMut = ($$try0)[3];
    const $from0 = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($sp$Human$CanonicalAst$andThen)((($from1) => {
      return (($sp$Human$CanonicalAst$andThen)((($to1) => {
        return ($sp$Human$CanonicalAst$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($from1))($fromIsMut))($to1));
      })))(($sp$Human$CanonicalAst$normType)($to0));
    })))(($sp$Human$CanonicalAst$normType)($from0));
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
    const $attrs0 = ($$try0)[3];
    const $ext0 = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($sp$Human$CanonicalAst$andThen)((($ext1) => {
      return (($sp$Human$CanonicalAst$andThen)((($attrs1) => {
        return ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($ext1))($attrs1));
      })))((($sp$StateMonad$dict_map)((($k) => {
        return $sp$Human$CanonicalAst$normType;
      })))($attrs0));
    })))((($sp$StateMonad$maybe_map)($sp$Human$CanonicalAst$normName))($ext0));
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
    const $t = ($$try0)[3];
    const $path = ($$try0)[2];
    const $pos = ($$try0)[1];
    return (($sp$Human$CanonicalAst$andThen)((($t1) => {
      return ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeAlias)($pos))($path))($t1));
    })))(($sp$Human$CanonicalAst$normType)($t));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 242:4', (sp_toHuman)($$try0));
});

const $sp$Human$CanonicalAst$normalizeTypeAndTyvars = (($tyOld) => {
  return (($tyvarsOld) => {
    const state$$ = (($sp$StateMonad$run)($sp$Human$CanonicalAst$initNstate))(($sp$Human$CanonicalAst$normType)($tyOld));
    const $state = state$$.second;
    const $tyNew = state$$.first;
    const $replace = (($name) => {
      return ($corelib$Dict$insert)((($corelib$Maybe$withDefault)($name))((($corelib$Dict$get)($name))($state.replacements)));
    });
    const $tyvarsNew = ((($corelib$Dict$for)($tyvarsOld))($replace))($corelib$Dict$empty);
    return ({
      first: $tyNew,
      second: $tyvarsNew,
    });
  });
});

const $sp$Compiler$TypeCheck_Test$infer = (($name) => {
  return (($code) => {
    const $tcEnvResult = ((() => {
      const $params = ({
        meta: $sp$Compiler$TestHelpers$meta,
        name: $sp$Compiler$TestHelpers$moduleName,
        source: $sp$Compiler$TestHelpers$source,
        stripLocations: true,
      });
      return (($corelib$Result$onOk)((($module) => {
        return (($corelib$Result$onOk)((($expandedTypes) => {
          const constructors$$ = $expandedTypes;
          const $types = constructors$$.types;
          const $instanceVariables = constructors$$.instanceVariables;
          const $constructors = constructors$$.constructors;
          const $env = ({
            constructors: $constructors,
            currentModule: $sp$Compiler$TestHelpers$moduleUmr,
            instanceVariables: ((($corelib$Dict$insert)(($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))("reset"))))(({
              definedAt: $sp$Types$Pos$T,
              freeTypeVariables: $corelib$Dict$empty,
              isMutable: false,
              ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$TypeCheck_Test$tyNumber))(true))($sp$Compiler$TypeCheck_Test$tyNone),
            })))(((($corelib$Dict$insert)(($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))("add"))))(({
              definedAt: $sp$Types$Pos$T,
              freeTypeVariables: $corelib$Dict$empty,
              isMutable: false,
              ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))((($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber)),
            })))($instanceVariables)),
            meta: $sp$Compiler$TestHelpers$meta,
            nonAnnotatedRecursives: $corelib$Dict$empty,
            nonFreeTyvars: $corelib$Dict$empty,
            types: $types,
          });
          return (($sp$Compiler$TypeCheck$fromModule)($env))($module);
        })))(($sp$Compiler$Pipeline$globalExpandedTypes)((($corelib$Dict$singleton)($sp$Compiler$TestHelpers$moduleUmr))($module)));
      })))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($params))($code));
    }))();
    return (($corelib$Result$onOk)((($tcEnv) => {
      const $$try0 = (($corelib$Dict$get)(($sp$Compiler$TestHelpers$rootLocal)($name)))($tcEnv.instanceVariables);
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return ($corelib$Result$Err)("dict fail");
      }
      if (("$corelib$Maybe$Just" === ($$try0)[0])) {
        const $var = ($$try0)[1];
        const ty$$ = (($sp$Human$CanonicalAst$normalizeTypeAndTyvars)($var.ty))($var.freeTypeVariables);
        const $tyvars = ty$$.second;
        const $ty = ty$$.first;
        return ($corelib$Result$Ok)(({
          freeTypeVariables: $var.freeTypeVariables,
          isMutable: $var.isMutable,
          ty: $ty,
        }));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck_Test.sp 143:4', (sp_toHuman)($$try0));
    })))((($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))($tcEnvResult));
  });
});

const $sp$Compiler$TypeCheck_Test$typeVariable = ($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$T);

const $sp$Compiler$TypeCheck_Test$functions = (($sp$Test$Group)("functions"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Known function with correct params"))("a = add 3 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$TypeCheck_Test$tyNumber,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Known function with wrong params"))("a = add False"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Function inference 1"))("a = x: add x 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Function inference 2: same as 1, but with swapped args"))("a = x: add 1 x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] fn has type None"))("a = x: 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("1"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$TypeCheck_Test$typeVariable)("a")))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Multiple arguments are correctly inferred"))("a = x: y: z: x + y + z"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Annotation should be consistent with mutability"))("f as Number @: Number = a:\n  a"))(($sp$Compiler$TypeCheck_Test$infer)("f")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability"))($core$SPCore$Nil)))))($core$SPCore$Nil))))))));

const $sp$Compiler$TypeCheck_Test$higherOrderTypes = (($sp$Test$Group)("higher order types"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Parse precedence"))("union T a = T a\n\na as T a: T a =\n    l: l"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("0a"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("T")))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))($core$SPCore$Nil))))(false))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("T")))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))($core$SPCore$Nil))),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Union type constructors"))("union X a = L\nl = L"))(($sp$Compiler$TypeCheck_Test$infer)("l")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("1"),
  isMutable: false,
  ty: ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("X")))((($core$SPCore$Cons)((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a")))($core$SPCore$Nil)),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP [reg] type check mistakes a union type with free tyvars for a free tyvar?"))("union O r e o = O r e o\n\nrun as (r: O r e o): r: O r e o = rToOreo: r:\n    rToOreo r"))(($sp$Compiler$TypeCheck_Test$infer)("run")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Wrong should be Text"))("union O o = O Text o\n\nfun as Number: Text: O wrong = _: a:\n    O a a"))(($sp$Compiler$TypeCheck_Test$infer)("fun")))(($sp$Test$errorContains)((($core$SPCore$Cons)("wrong"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP [reg] Should complain about undefined type argument"))("union O a = O Text output\nx = 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("undefined"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$TypeCheck_Test$if_else = (($sp$Test$Group)("if..else"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("basic functionality"))("x = q:\n  if q then 1\n  else 2"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$CoreTypes$bool))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-bool conditions"))("x = q:\n  if 1 then 1\n  else 2"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks"))("x = q:\n  if q then 2\n  else False"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Number"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$TypeCheck_Test$mu = (($sp$Test$Group)("mutability"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks that define mutables can't return functions"))("a =\n  x @= 1\n  y: y"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("can't return functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks that define mutables can't return functions (with annotation)"))("a as y: y =\n  x @= 1\n  y: y"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("can't return functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Immutable variables can't be used as mutable"))("a = x:\n  @x := 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Detect mismatching annotations"))("a as Number: None =\n  reset"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utability"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Correctly unify annotation's mutability"))("a as Number @: None =\n  reset"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$TypeCheck_Test$tyNumber))(true))($sp$Compiler$TypeCheck_Test$tyNone),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 1"))("a @= x: x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 2"))("a = f@:\n    @f := (x: x)"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable args cannot be functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 3"))("a = f@:\n  f 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable args cannot be functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Lambda argument mutability is correctly inferred"))("a = x: reset x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("*Nested* lambda argument mutability is correctly inferred"))("a = x: (y: reset y) x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable (annotation)"))("a as Number: Number @=\n  add 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Mutables can contain functions via free tyvars"))("a = x:\n  s @= x\n  s\n\nz as x: x =\n  a (x: x)"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Mutable assignment as last stament yields None"))("a as None =\n    x @= 1\n    @x := 2"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))($core$SPCore$Nil))))))))))))));

const $sp$Compiler$TypeCheck_Test$nonFunction = (($sp$Test$Group)("NonFunction"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Basic functionality"))("blah as List a: List a =\n  with a NonFunction\n  a:\n  a\n\nmeh =\n  blah [x: x]"))(($sp$Compiler$TypeCheck_Test$infer)("meh")))(($sp$Test$errorContains)((($core$SPCore$Cons)("should not contain functions"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$TypeCheck_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("List unpacking"))("x = q:\n   [ first, second ] = q\n   first"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("2"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$CoreTypes$list)((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a"))))(false))((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Records are correctly unpacked"))("x = q:\n    { first } = q\n    first"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))($core$SPCore$Nil)),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: "first",
    second: ($sp$Compiler$TypeCheck_Test$typeVariable)("a"),
  })))($core$SPCore$Nil)))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Constructors should instantiate their variable types"))("each as [a]: (a: b): None =\n    ls: f:\n    try ls as\n        SPCore.Nil:\n            None\n\nresult =\n      1 :: SPCore.Nil = SPCore.Nil"))(($sp$Compiler$TypeCheck_Test$infer)("result")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Trying to check against an inferred value?"))("tuple as Text & Number =\n    \"\" & 1\n\nx =\n    (a as Text) & (b as Number) =\n        tuple"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))($core$SPCore$Nil)))));

const $sp$Compiler$TypeCheck_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Attribute access"))("a = b: b.meh.blah"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("4"))((($core$SPCore$Cons)("5"))($core$SPCore$Nil)))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("meh"))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("b")))((($corelib$Dict$singleton)("blah"))(($sp$Compiler$TypeCheck_Test$typeVariable)("c")))))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("c")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Attribute mutation"))("a = b@: @b.meh.blah += 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("4"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("meh"))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("b")))((($corelib$Dict$singleton)("blah"))($sp$Compiler$CoreTypes$number))))))(true))($sp$Compiler$CoreTypes$none),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Tuple3 direct item mutability"))("x =\n    a @= 3 & False & 2\n\n    @a.third += 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Tuple2 direct item mutability, annotated"))("x = y:\n   a as Number & Number @=\n     1 & 2\n\n   @a.first += 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("functional update"))("a = b: { b with x = 1 }"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))($core$SPCore$Nil)),
    isMutable: false,
    ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($re))(false))($re),
  });
}))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("x"))($sp$Compiler$CoreTypes$number)))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP instantiate and refine inferred records"))("a = t: { t with x = 1 }\nc = a"))(($sp$Compiler$TypeCheck_Test$infer)("c")))(($sp$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)),
    isMutable: false,
    ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($re))(false))($re),
  });
}))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("x"))($sp$Compiler$CoreTypes$number)))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] excessive forallness in records"))("x = q:\n a = q.first\n a"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("3"))((($core$SPCore$Cons)("4"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: "first",
    second: ($sp$Compiler$TypeCheck_Test$typeVariable)("b"),
  })))($core$SPCore$Nil)))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("b")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] refineType when the record has a non-extensible alias"))("alias A = { c as Number, d as Number }\n\nupd as A: A = a:\n  { a with c = .c + 1 }"))(($sp$Compiler$TypeCheck_Test$infer)("upd")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] infinite recursion on addSubstitution/unify_"))("alias B = { l as [Text] }\n\nreadOne as B: (Text & B) = b:\n    try b.l as\n        []: \"\" & b\n        h :: t: h & { b with l = t }"))(($sp$Compiler$TypeCheck_Test$infer)("readOne")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] unifyToNonExtensibleRecord correctly substitutes the record extension"))("alias R = { x as Number, y as Number }\n\nrec as R: R =\n    s:\n        if True then\n            { s with y = .y }\n        else\n            rec { s with y = .y }"))(($sp$Compiler$TypeCheck_Test$infer)("rec")))($sp$Test$isOk)))($core$SPCore$Nil)))))))))));

const $sp$Compiler$TypeCheck_Test$statements = (($sp$Test$Group)("statements"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks should return the last statement's type"))("a =\n  3\n  False"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$CoreTypes$bool,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Definition statement return type None"))("a =\n  f = x: 3"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$CoreTypes$none,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Definition statement with annotation return type None"))("a as None =\n  f = 3"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Local values can't shadow root values"))("a = 1\nb as Number =\n    a = 1\n    a"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("already"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Prevent local redeclarations"))("b =\n  a = 1\n  a = 1"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("declar"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Prevent root redeclarations"))("a = 1\na = 1"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("declar"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Annotated declarations are actually typechecked"))("x as None =\n    q = 1 + \"\""))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)($core$SPCore$Nil))))($core$SPCore$Nil))))))));

const $sp$Compiler$TypeCheck_Test$try_as = (($sp$Test$Group)("try..as"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("basic functionality"))("x = q:\n    try q as\n        True: 2\n        _: 3"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$CoreTypes$bool))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching patterns"))("x = q:\n    try q as\n        True: 2\n        []: 3"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("List"))((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks"))("x = q:\n try q as\n   True: 2\n   False: False"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Number"))((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] actually infers blocks"))("x as Number =\n  try \"\" as\n    \"\": y"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("y"))($core$SPCore$Nil)))))($core$SPCore$Nil)))));

const $sp$Compiler$TypeCheck_Test$variableTypes = (($sp$Test$Group)("Variable types"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Identity"))("id as a: a =\n  a: a"))(($sp$Compiler$TypeCheck_Test$infer)("id")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("0a"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Annotated vars are instantiated when referenced"))("q as [item] =\n  SPCore.Nil\n\nr as [Text] =\n      q"))(($sp$Compiler$TypeCheck_Test$infer)("r")))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$TypeCheck_Test$tests = (($sp$Test$Group)("TypeCheck"))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$functions))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$statements))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$variableTypes))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$mu))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$higherOrderTypes))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$records))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$try_as))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$if_else))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$nonFunction))($core$SPCore$Nil)))))))))));

const $sp$Human$CanonicalAst$normalizeType = (($t) => {
  return ($corelib$Tuple$first)((($sp$StateMonad$run)($sp$Human$CanonicalAst$initNstate))(($sp$Human$CanonicalAst$normType)($t)));
});

const $sp$RefHierarchy_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $sp$RefHierarchy_Test$canonicalJsTest = ((($sp$RefHierarchy_Test$valueTest)("[reg] THIS SHOULD BE IN CANONICALTOJS"))((() => {
  return ((basics_compare)(null))(null);
})))(($sp$Test$isOkAndEqualTo)(0));

const $sp$RefHierarchy_Test$graph1 = ((() => {
  const $x = (($k) => {
    return (($l) => {
      return ({
        first: $k,
        second: ({
          first: $k,
          second: ($corelib$Set$fromList)($l),
        }),
      });
    });
  });
  return ($corelib$Dict$fromList)((($core$SPCore$Cons)((($x)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("b"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("e"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("c"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("d"))($core$SPCore$Nil)))((($core$SPCore$Cons)((($x)("e"))($core$SPCore$Nil)))($core$SPCore$Nil))))));
}))();

const $sp$RefHierarchy_Test$graph2 = ((() => {
  const $x = (($k) => {
    return (($l) => {
      return ({
        first: $k,
        second: ({
          first: $k,
          second: ($corelib$Set$fromList)($l),
        }),
      });
    });
  });
  return ($corelib$Dict$fromList)((($core$SPCore$Cons)((($x)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("b"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("e"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("c"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("d"))((($core$SPCore$Cons)("b"))($core$SPCore$Nil))))((($core$SPCore$Cons)((($x)("e"))($core$SPCore$Nil)))($core$SPCore$Nil))))));
}))();

const $sp$RefHierarchy_Test$tests = (($sp$Test$Group)("RefHierarchy"))((($core$SPCore$Cons)($sp$RefHierarchy_Test$canonicalJsTest))((($core$SPCore$Cons)(((($sp$RefHierarchy_Test$valueTest)("Basic"))((() => {
  return (($sp$RefHierarchy$reorder)($corelib$Tuple$second))($sp$RefHierarchy_Test$graph1);
})))(($sp$Test$isOkAndEqualTo)(({
  first: $core$SPCore$Nil,
  second: (($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("a"))($core$SPCore$Nil))))),
})))))((($core$SPCore$Cons)(((($sp$RefHierarchy_Test$valueTest)("Circular"))((() => {
  return (($sp$RefHierarchy$reorder)($corelib$Tuple$second))($sp$RefHierarchy_Test$graph2);
})))(($sp$Test$isOkAndEqualTo)(({
  first: (($core$SPCore$Cons)((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)))))($core$SPCore$Nil),
  second: (($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("a"))($core$SPCore$Nil))))),
})))))($core$SPCore$Nil))));

const $sp$Main$allTests = (($core$SPCore$Cons)($sp$Compiler$Lexer_Test$tests))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$tests))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$tests))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$tests))((($core$SPCore$Cons)($corelib$Hash_Test$tests))((($core$SPCore$Cons)($corelib$Array_Test$tests))((($core$SPCore$Cons)($corelib$List_Test$tests))((($core$SPCore$Cons)($corelib$Dict_Test$tests))((($core$SPCore$Cons)($sp$RefHierarchy_Test$tests))($core$SPCore$Nil)))))))));

const $sp$Main$asModule = (($tuple) => {
  const isDirectory$$ = $tuple;
  const $name = isDirectory$$.second;
  const $isDirectory = isDirectory$$.first;
  return (($isDirectory || ((sp_not_equal)($name))(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$"))($name)))
    ? $corelib$Maybe$Nothing
    : ($corelib$Maybe$Just)(((($corelib$Text$replace)(".sp"))(""))($name)));
});

const $sp$Main$asModuleDirectory = (($tuple) => {
  const isDirectory$$ = $tuple;
  const $name = isDirectory$$.second;
  const $isDirectory = isDirectory$$.first;
  return (($isDirectory && ((sp_equal)($name))(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$"))($name)))
    ? ($corelib$Maybe$Just)($name)
    : $corelib$Maybe$Nothing);
});

const $sp$Main$color = (($code) => {
  return (($text) => {
    return ($code + ($text + "\x1b[0m"));
  });
});

const $sp$Main$blue = ($sp$Main$color)("\x1b[34m");

const $sp$Main$getTargetUsr = (($meta) => {
  return (($entryModule) => {
    return (($entryValue) => {
      return (($globals) => {
        const $asEntry = (($ref) => {
          const $$try0 = $ref;
          if (("$sp$Types$CanonicalAst$RefBlock" === ($$try0)[0])) {
            return $corelib$Maybe$Nothing;
          }
          if (("$sp$Types$CanonicalAst$RefRoot" === ($$try0)[0])) {
            const $usr = ($$try0)[1];
            const moduleName$$ = $usr;
            const $valueName = (moduleName$$)[2];
            const $moduleName = ((moduleName$$)[1])[2];
            const $source = ((moduleName$$)[1])[1];
            return ((((sp_equal)($entryModule))($moduleName) && ((sp_equal)($entryValue))($valueName))
              ? ($corelib$Maybe$Just)($usr)
              : $corelib$Maybe$Nothing);
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 292:8', (sp_toHuman)($$try0));
        });
        const $possibleTargets = (($corelib$List$filterMap)($asEntry))(($corelib$Dict$keys)($globals.instanceVariables));
        const $$try0 = $possibleTargets;
        if (("$core$SPCore$Nil" === ($$try0)[0])) {
          return (sp_todo)(("Can't find build target `" + ($entryModule + ("." + ($entryValue + "` anywhere.")))));
        }
        if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
          const $usr = ($$try0)[1];
          return ($corelib$Result$Ok)($usr);
        }
        if (true) {
          const $many = $$try0;
          const $x = (($corelib$Text$join)(", "))((($corelib$List$map)(sp_toHuman))($many));
          return (sp_todo)(("Multiple values match build target `" + ($entryModule + ("." + ($entryValue + ("`: " + $x))))));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 308:4', (sp_toHuman)($$try0));
      });
    });
  });
});

const $sp$Main$listSourceDir = (($sourceDirRoot) => {
  return (($modulePathWithTrailingSlash) => {
    const $path = ($sourceDirRoot + ("/" + $modulePathWithTrailingSlash));
    return (($posix$IO$onSuccess)((($dirContents) => {
      const $directChildren = (($corelib$List$map)((($fileName) => {
        return ($modulePathWithTrailingSlash + $fileName);
      })))((($corelib$List$filterMap)($sp$Main$asModule))($dirContents));
      const $getDescendants = (io_parallel)((($corelib$List$map)((($subDir) => {
        return (($sp$Main$listSourceDir)($sourceDirRoot))(($modulePathWithTrailingSlash + ($subDir + "/")));
      })))((($corelib$List$filterMap)($sp$Main$asModuleDirectory))($dirContents)));
      return (($posix$IO$onSuccess)((($descendants) => {
        return ($posix$IO$succeed)(($corelib$List$concat)((($core$SPCore$Cons)($directChildren))((($core$SPCore$Cons)(($corelib$List$concat)($descendants)))($core$SPCore$Nil))));
      })))($getDescendants);
    })))((io_readDir)($path));
  });
});

const $sp$Main$red = ($sp$Main$color)("\x1b[31m");

const $sp$Main$yellow = ($sp$Main$color)("\x1b[33m");

const $sp$Main$formattedToConsoleColoredText = (($formattedText) => {
  const $$try0 = $formattedText;
  if (("$sp$Compiler$Error$FormattedText_Default" === ($$try0)[0])) {
    const $t = ($$try0)[1];
    return $t;
  }
  if (("$sp$Compiler$Error$FormattedText_Emphasys" === ($$try0)[0])) {
    const $t = ($$try0)[1];
    return ($sp$Main$yellow)($t);
  }
  if (("$sp$Compiler$Error$FormattedText_Warning" === ($$try0)[0])) {
    const $t = ($$try0)[1];
    return ($sp$Main$red)($t);
  }
  if (("$sp$Compiler$Error$FormattedText_Decoration" === ($$try0)[0])) {
    const $t = ($$try0)[1];
    return ($sp$Main$blue)($t);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 69:4', (sp_toHuman)($$try0));
});

const $sp$Main$resToIo = (($errorEnv) => {
  return (($res) => {
    const $$try0 = $res;
    if (("$corelib$Result$Ok" === ($$try0)[0])) {
      const $a = ($$try0)[1];
      return ($posix$IO$succeed)($a);
    }
    if (("$corelib$Result$Err" === ($$try0)[0])) {
      const $e = ($$try0)[1];
      return ($posix$IO$fail)((($corelib$Text$join)(""))((($corelib$List$map)($sp$Main$formattedToConsoleColoredText))((($sp$Compiler$Error$toFormattedText)($errorEnv))($e))));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 91:4', (sp_toHuman)($$try0));
  });
});

const $sp$Main$loadModulesFile = ((() => {
  const $modulesFileName = "modules.sp";
  return (($posix$IO$onSuccess)((($modulesAsText) => {
    const $eenv = ({
      moduleByName: (($corelib$Dict$singleton)($modulesFileName))(({
        content: $modulesAsText,
        fsPath: $modulesFileName,
      })),
    });
    return (($sp$Main$resToIo)($eenv))((($sp$ModulesFile$textToModulesFile)($modulesFileName))($modulesAsText));
  })))((io_readFile)($modulesFileName));
}))();

const $sp$Main$updateSd = (($fileNames) => {
  const $insertModuleName = (($name) => {
    return (($sd) => {
      const $$try0 = (($corelib$List$find)((($m) => {
        return ((sp_equal)($name))($m.path);
      })))($sd.modules);
      if (("$corelib$Maybe$Just" === ($$try0)[0])) {
        return $sd;
      }
      if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
        return (Object.assign)({}, $sd, ({
          modules: ((sp_cons)($sd.modules))(({
            globalTypes: $core$SPCore$Nil,
            globalValues: $core$SPCore$Nil,
            path: $name,
            visibleAs: $name,
          })),
        }));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 236:8', (sp_toHuman)($$try0));
    });
  });
  return (($corelib$List$for)($fileNames))($insertModuleName);
});

const $sp$Main$loadMeta = (($env) => {
  return (($posix$IO$onSuccess)((($modulesFile) => {
    const $getAllSourceDirLists = (io_parallel)((($corelib$List$map)((($sd) => {
      return (($sp$Main$listSourceDir)($sd.path))("");
    })))($modulesFile.sourceDirs));
    return (($posix$IO$onSuccess)((($allSourceDirLists) => {
      const $updatedSourceDirs = ((($corelib$List$map2)($sp$Main$updateSd))($allSourceDirLists))($modulesFile.sourceDirs);
      return ($posix$IO$succeed)(($sp$ModulesFile$toMeta)((Object.assign)({}, $modulesFile, ({
        sourceDirs: $updatedSourceDirs,
      }))));
    })))($getAllSourceDirLists);
  })))($sp$Main$loadModulesFile);
});

const $sp$Main$loadModule = (($meta) => {
  return (($umr) => {
    return (($fileName) => {
      const moduleName$$ = $umr;
      const $moduleName = (moduleName$$)[2];
      const $source = (moduleName$$)[1];
      return (($posix$IO$onSuccess)((($moduleAsText) => {
        const $params = ({
          meta: $meta,
          name: $moduleName,
          source: $source,
          stripLocations: false,
        });
        const $eenv = ({
          moduleByName: (($corelib$Dict$singleton)($moduleName))(({
            content: $moduleAsText,
            fsPath: $fileName,
          })),
        });
        return (($sp$Main$resToIo)($eenv))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($params))($moduleAsText));
      })))((io_readFile)($fileName));
    });
  });
});

const $sp$Main$onResSuccess = (($errorEnv) => {
  return (($f) => {
    return (($res) => {
      return (($posix$IO$onSuccess)($f))((($sp$Main$resToIo)($errorEnv))($res));
    });
  });
});

const $sp$Main$typeCheckModule = (($meta) => {
  return (($globals) => {
    return (($module) => {
      const $env = ({
        constructors: $globals.constructors,
        currentModule: $module.umr,
        instanceVariables: $globals.instanceVariables,
        meta: $meta,
        nonAnnotatedRecursives: $corelib$Dict$empty,
        nonFreeTyvars: $corelib$Dict$empty,
        types: $globals.types,
      });
      return (($sp$Compiler$TypeCheck$fromModule)($env))($module);
    });
  });
});

const $sp$Main$umrToFileName = (($x) => {
  const name$$ = $x;
  const $name = (name$$)[2];
  const $source = (name$$)[1];
  const $$try0 = $source;
  if (("$sp$Types$Meta$SourceDir" === ($$try0)[0])) {
    const $d = ($$try0)[1];
    return ($corelib$Maybe$Just)(($d + ("/" + ($name + ".sp"))));
  }
  if (true) {
    return $corelib$Maybe$Nothing;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 185:4', (sp_toHuman)($$try0));
});

const $sp$Main$compile = (($env) => {
  return (($entryModule) => {
    return (($entryValue) => {
      return (($outputFile) => {
        ((sp_log)("Loading meta..."))("");
        return (($posix$IO$onSuccess)((($meta) => {
          ((sp_log)("Loading modules..."))("");
          const $loadAllModules = (io_parallel)((($corelib$List$filterMap)((($umr) => {
            return (($corelib$Maybe$map)((($sp$Main$loadModule)($meta))($umr)))(($sp$Main$umrToFileName)($umr));
          })))(($corelib$Dict$values)($meta.moduleVisibleAsToUmr)));
          return (($posix$IO$onSuccess)((($modules) => {
            const $eenv = ((() => {
              const $getName = (($n) => {
                const name$$ = $n.umr;
                const $name = (name$$)[2];
                const $source = (name$$)[1];
                return $name;
              });
              return ({
                moduleByName: ((($corelib$List$for)($modules))((($m) => {
                  return (($corelib$Dict$insert)(($getName)($m)))(({
                    content: $m.asText,
                    fsPath: (($corelib$Maybe$withDefault)("CORE"))(($sp$Main$umrToFileName)($m.umr)),
                  }));
                })))($corelib$Dict$empty),
              });
            }))();
            ((sp_log)("Solving globals..."))("");
            const $x = ($sp$Compiler$Pipeline$globalExpandedTypes)((($corelib$List$indexBy)((($m) => {
              return $m.umr;
            })))($modules));
            return ((($sp$Main$onResSuccess)($eenv))((($globals) => {
              return ((($sp$Main$onResSuccess)($eenv))((($targetUsr) => {
                ((sp_log)("Type checking..."))("");
                const $typeCheckModules = (io_parallel)((($corelib$List$map)((($m) => {
                  return (($sp$Main$resToIo)($eenv))(((($sp$Main$typeCheckModule)($meta))($globals))($m));
                })))($modules));
                return (($posix$IO$onSuccess)((($typeCheckEnvs) => {
                  ((sp_log)("Creating JS AST..."))("");
                  const $jaStatements = ((($sp$Compiler$CanonicalToJs$translateAll)($eenv))($globals))($modules);
                  ((sp_log)("Emitting JS..."))("");
                  const $callMain = ("\nconst out = " + (($sp$Compiler$CanonicalToJs$translateUsr)($targetUsr) + "({})(array_toList(process.argv.slice(1)))[1]('never');\n        if (out[1]) console.error(out[1]);\n        "));
                  const $statements = (($corelib$Text$join)("\n\n"))((($corelib$List$map)(($sp$Compiler$JsToText$emitStatement)(0)))($jaStatements));
                  const $js = ($sp$Compiler$CanonicalToJs$nativeDefinitions + ($statements + $callMain));
                  return ((io_writeFile)($outputFile))($js);
                })))($typeCheckModules);
              })))((((($sp$Main$getTargetUsr)($meta))($entryModule))($entryValue))($globals));
            })))($x);
          })))($loadAllModules);
        })))(($sp$Main$loadMeta)($env));
      });
    });
  });
});

const $sp$Main$green = ($sp$Main$color)("\x1b[32m");

const $sp$Main$indent = (($s) => {
  return (($corelib$Text$join)("\n"))((($corelib$List$map)((($l) => {
    return ("  " + $l);
  })))(((text_split)("\n"))($s)));
});

const $sp$Main$order = (($outcome) => {
  const $$try0 = $outcome;
  if (("$sp$Test$Success" === ($$try0)[0])) {
    return 0;
  }
  if (("$sp$Test$Skipped" === ($$try0)[0])) {
    return 1;
  }
  if (("$sp$Test$Error" === ($$try0)[0])) {
    return 2;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 78:4', (sp_toHuman)($$try0));
});

const $sp$Main$testOutcomeToText = (($name) => {
  return (($code) => {
    return (($outcome) => {
      const $$try0 = $outcome;
      if (("$sp$Test$Success" === ($$try0)[0])) {
        return ($sp$Main$green)(("* PASS: " + $name));
      }
      if (("$sp$Test$Skipped" === ($$try0)[0])) {
        return ($sp$Main$yellow)(("* skip: " + $name));
      }
      if (("$sp$Test$Error" === ($$try0)[0])) {
        const $error = ($$try0)[1];
        return (($sp$Main$red)(("FAIL ! " + $name)) + ("\n" + (($sp$Main$indent)($code) + ("\n" + ($sp$Main$indent)($error)))));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 56:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Test$getName = (($test) => {
  const $$try0 = $test;
  if (("$sp$Test$Single" === ($$try0)[0])) {
    const $f = ($$try0)[3];
    const $code = ($$try0)[2];
    const $n = ($$try0)[1];
    return $n;
  }
  if (("$sp$Test$Group" === ($$try0)[0])) {
    const $ls = ($$try0)[2];
    const $n = ($$try0)[1];
    return $n;
  }
  if (("$sp$Test$NotNow" === ($$try0)[0])) {
    const $t = ($$try0)[1];
    return ($sp$Test$getName)($t);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 145:4', (sp_toHuman)($$try0));
});

const $sp$Test$outcomesRec = (($path) => {
  return (($test) => {
    return (($accum) => {
      const $$try0 = $test;
      if (("$sp$Test$Single" === ($$try0)[0])) {
        const $f = ($$try0)[3];
        const $code = ($$try0)[2];
        const $name = ($$try0)[1];
        return (((text_startsWith)("SKIP"))($name)
          ? ((sp_cons)($accum))(({
            code: "",
            name: ($path + $name),
            outcome: $sp$Test$Skipped,
          }))
          : ((sp_cons)($accum))(({
            code: $code,
            name: ($path + $name),
            outcome: ($f)(null),
          })));
      }
      if (("$sp$Test$NotNow" === ($$try0)[0])) {
        const $t = ($$try0)[1];
        return ((sp_cons)($accum))(({
          code: "",
          name: ($path + ($sp$Test$getName)($t)),
          outcome: $sp$Test$Skipped,
        }));
      }
      if (("$sp$Test$Group" === ($$try0)[0])) {
        const $ts = ($$try0)[2];
        const $pathSegment = ($$try0)[1];
        return ((($corelib$List$for)($ts))(($sp$Test$outcomesRec)(($path + ($pathSegment + " / ")))))($accum);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 126:4', (sp_toHuman)($$try0));
    });
  });
});

const $sp$Test$flatten = (($tests) => {
  return ((($corelib$List$for)($tests))(($sp$Test$outcomesRec)("")))($core$SPCore$Nil);
});

const $sp$Main$main = (($env) => {
  return (($args) => {
    const $$try0 = $args;
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && ("$core$SPCore$Nil" === (($$try0)[2])[0]))) {
      const $self = ($$try0)[1];
      return (io_writeStdout)((($corelib$Text$join)("\n"))((($corelib$List$map)((($x) => {
        return ((($sp$Main$testOutcomeToText)($x.name))($x.code))($x.outcome);
      })))(((list_sortBy)((($x) => {
        return ({
          first: ($sp$Main$order)($x.outcome),
          second: $x.name,
        });
      })))(($sp$Test$flatten)($sp$Main$allTests)))));
    }
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && ("$core$SPCore$Nil" === ((($$try0)[2])[2])[0])))) {
      const $testFile = (($$try0)[2])[1];
      const $self = ($$try0)[1];
      const $umr = (($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("")))($testFile);
      return (($posix$IO$onSuccess)((($caModule) => {
        return ($posix$IO$succeed)(null);
      })))(((($sp$Main$loadModule)($sp$Compiler$TestHelpers$meta))($umr))($testFile));
      return null;
    }
    if ((("$core$SPCore$Cons" === ($$try0)[0]) && (("$core$SPCore$Cons" === (($$try0)[2])[0]) && (("$core$SPCore$Cons" === ((($$try0)[2])[2])[0]) && (("$core$SPCore$Cons" === (((($$try0)[2])[2])[2])[0]) && ("$core$SPCore$Nil" === ((((($$try0)[2])[2])[2])[2])[0])))))) {
      const $outputFile = (((($$try0)[2])[2])[2])[1];
      const $entryValue = ((($$try0)[2])[2])[1];
      const $entryModule = (($$try0)[2])[1];
      const $self = ($$try0)[1];
      return (((($sp$Main$compile)($env))($entryModule))($entryValue))($outputFile);
    }
    if (true) {
      return (io_writeStdout)("Usage\n\nspcc EntryModule entryFunction outputFile.js");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 398:4', (sp_toHuman)($$try0));
  });
});

const $sp$Main$sdItemToUMR = (($source) => {
  return (($fileName) => {
    return (($sp$Types$Meta$UMR)($source))(((($corelib$Text$replace)(".sp"))(""))($fileName));
  });
});

const $sp$SPLib$Buffer$readOne = (($b) => {
  return (($b.nextPos < $b.fullSize)
    ? ({
      first: (((text_slice)($b.nextPos))(($b.nextPos + 1)))($b.fullText),
      second: (Object.assign)({}, $b, ({
        nextPos: ($b.nextPos + 1),
      })),
    })
    : ({
      first: "",
      second: $b,
    }));
});

const $sp$SPLib$Parser$tuple3 = (($pa) => {
  return (($pb) => {
    return (($pc) => {
      return (($sp$SPLib$Parser$andThen)((($a) => {
        return (($sp$SPLib$Parser$andThen)((($b) => {
          return (($sp$SPLib$Parser$andThen)((($c) => {
            return ($sp$SPLib$Parser$accept)(({
              first: $a,
              second: $b,
              third: $c,
            }));
          })))($pc);
        })))($pb);
      })))($pa);
    });
  });
});

const $sp$SPON$logHead = (($statements) => {
  ((() => {
    const $$try0 = $statements;
    if (("$core$SPCore$Cons" === ($$try0)[0])) {
      const $tail = ($$try0)[2];
      const $head = ($$try0)[1];
      ((sp_log)("LOG"))($head);
      return null;
      return null;
    }
    if (("$core$SPCore$Nil" === ($$try0)[0])) {
      return ((sp_log)("LOG"))(null);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 68:4', (sp_toHuman)($$try0));
  }))();
  return (($sp$SPON$Accepted)($statements))(null);
});

const $sp$StateMonad$map = (($f) => {
  return (($m) => {
    return (($sp$StateMonad$andThen)((($x) => {
      return ($sp$StateMonad$return)(($f)($x));
    })))($m);
  });
});

const $sp$Test$errorsFirst = (($outcome) => {
  const $$try0 = $outcome;
  if (("$sp$Test$Error" === ($$try0)[0])) {
    const $e = ($$try0)[1];
    return (0 - 1);
  }
  if (("$sp$Test$Skipped" === ($$try0)[0])) {
    return 0;
  }
  if (("$sp$Test$Success" === ($$try0)[0])) {
    return 1;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 165:4', (sp_toHuman)($$try0));
});

const $sp$Types$CanonicalAst$typePos = (($ty) => {
  const $$try0 = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 190:4', (sp_toHuman)($$try0));
});

const $sp$Types$FormattableAst$patternNames = (($pattern) => {
  const $foldOver = (($pas) => {
    return ((($corelib$List$for)($pas))((($p) => {
      return ($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($p));
    })))($corelib$Dict$empty);
  });
  const $insertAttr = (($a) => {
    const maybePa$$ = $a;
    const $maybePa = maybePa$$.second;
    const $name = (maybePa$$.first)[2];
    const $pos = (maybePa$$.first)[1];
    const $$try0 = $maybePa;
    if (("$corelib$Maybe$Nothing" === ($$try0)[0])) {
      return (($corelib$Dict$insert)($name))($pos);
    }
    if (("$corelib$Maybe$Just" === ($$try0)[0])) {
      const $pat = ($$try0)[1];
      return ($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($pat));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 182:8', (sp_toHuman)($$try0));
  });
  const $$try0 = $pattern;
  if (("$sp$Types$FormattableAst$PatternAny" === ($$try0)[0])) {
    const $n = ($$try0)[3];
    const $pos = ($$try0)[1];
    return (($corelib$Dict$singleton)($n))($pos);
  }
  if (("$sp$Types$FormattableAst$PatternLiteralNumber" === ($$try0)[0])) {
    return $corelib$Dict$empty;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralText" === ($$try0)[0])) {
    return $corelib$Dict$empty;
  }
  if (("$sp$Types$FormattableAst$PatternConstructor" === ($$try0)[0])) {
    const $pas = ($$try0)[4];
    return ($foldOver)($pas);
  }
  if (("$sp$Types$FormattableAst$PatternList" === ($$try0)[0])) {
    const $pas = ($$try0)[2];
    return ($foldOver)($pas);
  }
  if (("$sp$Types$FormattableAst$PatternListCons" === ($$try0)[0])) {
    const $pas = ($$try0)[2];
    return ($foldOver)($pas);
  }
  if (("$sp$Types$FormattableAst$PatternRecord" === ($$try0)[0])) {
    const $ars = ($$try0)[2];
    const $pos = ($$try0)[1];
    return ((($corelib$List$for)($ars.attrs))($insertAttr))($corelib$Dict$empty);
  }
  if (("$sp$Types$FormattableAst$PatternTuple" === ($$try0)[0])) {
    const $pas = ($$try0)[2];
    return ($foldOver)($pas);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 186:4', (sp_toHuman)($$try0));
});

const $sp$Types$FormattableAst$sepList_mapItem = (($f) => {
  return (($aAndLa) => {
    const a$$ = $aAndLa;
    const $la = a$$.second;
    const $a = a$$.first;
    return ({
      first: ($f)($a),
      second: (($corelib$List$map)(($corelib$Tuple$mapSecond)($f)))($la),
    });
  });
});

const $sp$Types$FormattableAst$typePos = (($type) => {
  const $$try0 = $type;
  if (("$sp$Types$FormattableAst$TypeVariable" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$TypeConstant" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$TypeFunction" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$TypeTuple" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$TypeList" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  if (("$sp$Types$FormattableAst$TypeRecord" === ($$try0)[0])) {
    const $p = ($$try0)[1];
    return $p;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 130:4', (sp_toHuman)($$try0));
});

const $sp$Types$Pos$end = (($pos) => {
  const $$try0 = $pos;
  if (("$sp$Types$Pos$P" === ($$try0)[0])) {
    const $e = ($$try0)[3];
    const $s = ($$try0)[2];
    const $m = ($$try0)[1];
    return $e;
  }
  if (true) {
    return 0;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 36:4', (sp_toHuman)($$try0));
});

const $sp$Types$Pos$range = (($a) => {
  return (($b) => {
    const $$try0 = ({
      first: $a,
      second: $b,
    });
    if ((("$sp$Types$Pos$P" === ($$try0.first)[0]) && ("$sp$Types$Pos$P" === ($$try0.second)[0]))) {
      const $eb = ($$try0.second)[3];
      const $sb = ($$try0.second)[2];
      const $mb = ($$try0.second)[1];
      const $ea = ($$try0.first)[3];
      const $sa = ($$try0.first)[2];
      const $ma = ($$try0.first)[1];
      return (((sp_not_equal)($mb))($ma)
        ? (sp_todo)("trying to range across two different modules")
        : ((($sp$Types$Pos$P)($ma))((($corelib$Basics$min)($sa))($sb)))((($corelib$Basics$max)($ea))($eb)));
    }
    if (("$sp$Types$Pos$P" === ($$try0.first)[0])) {
      return $a;
    }
    if (true) {
      return $b;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 43:4', (sp_toHuman)($$try0));
  });
});
const out = $sp$Main$main({})(array_toList(process.argv.slice(1)))[1]('never');
        if (out[1]) console.error(out[1]);
        