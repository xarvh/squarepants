#!/usr/bin/env node

//Error.stackTraceLimit = 100;


const { performance } = require('perf_hooks');


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


/*  HACK

    TODO this is super brittle
    once we have a proper Platform system in place, the platform can probably
    use its internal Meta to figure out the proper constructor

*/
const maybe_nothing = [ "Nothing" ];
const maybe_just = (a) => [ "Just", a ];



//
// Basic ops
//


const sp_equal = (a) => (b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i])(b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k])(b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a) => (b) => {
  return !sp_equal(a)(b);
}


const sp_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = sp_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = sp_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (right) => (left) => {
  if (right === 0) return 0;
  return left / right;
}


const basics_modBy = (a) => (b) => b % a;

const basics_compare = (a) => (b) => sp_compare(a, b);


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message) => (thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.info("");
        console.info("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.info(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const sp_toHuman = (a) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a) || sp_toHumanAsUnion(a);

  if (typeof a === 'function') {
    return '<function>';
  }

  if (typeof a === 'object') {
    let x = [];
    for (let i in a) x.push(i + ' = ' + sp_toHuman(a[i]));
    return '{' + x.join(', ') + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a) => {
  return a[0] + ' ' + a.slice(1).map(arg => '(' + sp_toHuman(arg) + ')').join(' ');
}


const sp_toHumanAsList = (arrayAccum, list) => {
  if (list[0] === 'Cons') {
    arrayAccum.push(sp_toHuman(list[1]));
    return sp_toHumanAsList(arrayAccum, list[2]);
  }

  if (list[0] === 'Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ? maybe_nothing : maybe_just(n);
}

const text_split = (separator) => (target) => array_toList(target.split(separator));

const text_length = (s) => s.length;

const text_slice = (start) => (end) => (s) => s.slice(start, end);

const text_startsWith = (sub) => (s) => s.startsWith(sub);

const text_startsWithRegex = (regex) => {
  let re;
  try {
    re = new RegExp('^' + regex);
  } catch (e) {
    return () => ""
  }

  return (s) => {
    let m = s.match(re);
    return m ? m[0] : "";
  }
}

const text_replaceRegex = (regex) => {
  let re;
  try {
    re = new RegExp(regex, 'g');
  } catch (e) {
    return () => () => ""
  }

  return (replacer) => (s) => s.replace(re, replacer);
}

const text_trimLeft = (s) => {
  return s.trimLeft();
}

const text_dropLeft = (n) => (s) => {
  return s.slice(n);
}

const text_forEach = (s) => (f) => {
  for (let i of s) f(i);
  return null;
}


//
// Hashes
//

const hash_empty = {};


const hash_insert = (hash) => (key) => (value) => {
    const h = hash.obj[hash.attr];
    h[JSON.stringify(key)] = [key, value];
    return null;
}


const hash_remove = (hash) => (key) => {
    const h = hash.obj[hash.attr];
    delete h[JSON.stringify(key)];
    return null;
}


const hash_get = (hash) => (key) => {
    const r = hash[JSON.stringify(key)];
    return r === undefined ? maybe_nothing : maybe_just(r[1]);
}


const hash_for = (hash) => (f) => (acc) => {
    for (let k in hash) {
        const kv = hash[k];
        acc = f(kv[0])(kv[1])(acc);
    }
    return acc;
}


const hash_each = (hash) => (f) => {
    for (let k in hash) {
        const kv = hash[k];
        f(kv[0])(kv[1]);
    }
    return null;
}


//
// Arrays
//

const array_push = (array) => (item) => {
    array.obj[array.attr].push(item);
    return null;
}

const array_pop = (array) => {
    const a = array.obj[array.attr];
    return a.length ? maybe_just(a.pop()) : maybe_nothing;
}

const array_get = (array) => (index) => {
    const r = array[index];
    return r === undefined ? maybe_nothing : maybe_just(r);
}

const array_set = (array) => (index) => (item) => {
    if (index < 0) return false;
    const a = array.obj[array.attr];
    if (index >= a.length) return false;
    a[index] = item;
    return true;
}

const array_sortBy = (array) => (f) => {
    const arr = array.obj[array.attr];
    arr.sort((a, b) => sp_compare(f(a), f(b)));
    return null;
}

const array_toList = (array) => {
  let length = array.length;
  let list = [ 'Nil' ];
  for (let i = length - 1; i >= 0; i--) {
      list = [ 'Cons', array[i], list ];
  }
  return list;
}

const array_fromList = (list) => {
  const array = [];
  const rec = (ls) => {
    if (ls[0] === 'Nil')
      return array;

    array.push(ls[1]);
    return rec(ls[2]);
  };

  return rec(list);
}



//
// Lists
//


const sp_cons = (list) => (item) => {
  return [ 'Cons', item, list];
}

const list_sortBy = (f) => (list) => array_toList(array_fromList(list).sort((a, b) => sp_compare(f(a), f(b))));


//
// Platform: IO
//
const fs = require('fs');

const io_wrap = (f) => [ "IO.IO", f ];

const io_parallel = (iosAsList) => io_wrap((never) => {
    // as [IO a]: IO [a]

    const ios = array_fromList(iosAsList);

    // TODO actually run them in parallel!

    let arr = [];
    for (let io of ios) {
        const r = io[1](never);
        if (r[0] === "Ok")
            arr.push(r[1]);
        else
            return $corelib$Result$Err(r[1]);
    }

    return $corelib$Result$Ok(array_toList(arr));
});


const io_readDir = (dirPath) => io_wrap((never) => {
    // as Text: IO [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(array_toList(entries.map((dirent) => ({
        first: dirent.isDirectory(),
        second: dirent.name,
    }))));
});


const io_readFile = (path) => io_wrap((never) => {
    // as Text: IO Text

    var content;
    try {
        content = fs.readFileSync(path, 'utf8');
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(content);
});


const io_writeFile = (path) => (content) => io_wrap((never) => {
    // as Text: Text: IO None

    try {
        fs.writeFileSync(path, content);
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(null);
});


const io_writeStdout = (content) => io_wrap((never) => {
    // as Text: IO None

    console.info(content);
    return $corelib$Result$Ok(null);
});

    const $core$SPCore$Cons = (($1) => (($2) => ([
  "Cons",
  $1,
  $2,
])));

const $core$SPCore$False = ([
  "False",
]);

const $core$SPCore$Nil = ([
  "Nil",
]);

const $core$SPCore$None = ([
  "None",
]);

const $core$SPCore$True = ([
  "True",
]);

const $corelib$Array$Array__ = (($1) => ([
  "Array__",
  $1,
]));

const $corelib$Dict$Black = ([
  "Black",
]);

const $corelib$Dict$RBEmpty_elm_builtin = ([
  "RBEmpty_elm_builtin",
]);

const $corelib$Dict$RBNode_elm_builtin = (($1) => (($2) => (($3) => (($4) => (($5) => ([
  "RBNode_elm_builtin",
  $1,
  $2,
  $3,
  $4,
  $5,
]))))));

const $corelib$Dict$Red = ([
  "Red",
]);

const $corelib$Hash$Hash__ = (($1) => ([
  "Hash__",
  $1,
]));

const $corelib$Maybe$Just = (($1) => ([
  "Just",
  $1,
]));

const $corelib$Maybe$Nothing = ([
  "Nothing",
]);

const $corelib$Result$Err = (($1) => ([
  "Err",
  $1,
]));

const $corelib$Result$Ok = (($1) => ([
  "Ok",
  $1,
]));

const $platforms$posix$IO$IO = (($1) => ([
  "IO",
  $1,
]));

const $platforms$posix$IO$Never = (($1) => ([
  "Never",
  $1,
]));

const $sp$Compiler$EmittableToJs$Block = (($1) => ([
  "Block",
  $1,
]));

const $sp$Compiler$EmittableToJs$Inline = (($1) => ([
  "Inline",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Decoration = (($1) => ([
  "FormattedText_Decoration",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Default = (($1) => ([
  "FormattedText_Default",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Emphasys = (($1) => ([
  "FormattedText_Emphasys",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Warning = (($1) => ([
  "FormattedText_Warning",
  $1,
]));

const $sp$Compiler$Error$HighlightBlock = (($1) => ([
  "HighlightBlock",
  $1,
]));

const $sp$Compiler$Error$HighlightWord = (($1) => ([
  "HighlightWord",
  $1,
]));

const $sp$Compiler$Error$Nested = (($1) => ([
  "Nested",
  $1,
]));

const $sp$Compiler$Error$Simple = (($1) => (($2) => ([
  "Simple",
  $1,
  $2,
])));

const $sp$Compiler$Lexer$BlockComment = (($1) => ([
  "BlockComment",
  $1,
]));

const $sp$Compiler$Lexer$ContentOpeningBlockComment = ([
  "ContentOpeningBlockComment",
]);

const $sp$Compiler$Lexer$ContentOpeningQuotes_One = ([
  "ContentOpeningQuotes_One",
]);

const $sp$Compiler$Lexer$ContentOpeningQuotes_Two = ([
  "ContentOpeningQuotes_Two",
]);

const $sp$Compiler$Lexer$Default = ([
  "Default",
]);

const $sp$Compiler$Lexer$Dot = ([
  "Dot",
]);

const $sp$Compiler$Lexer$Indent = ([
  "Indent",
]);

const $sp$Compiler$Lexer$LineComment = ([
  "LineComment",
]);

const $sp$Compiler$Lexer$Mutable = ([
  "Mutable",
]);

const $sp$Compiler$Lexer$NoTabsOrSpacesYet = ([
  "NoTabsOrSpacesYet",
]);

const $sp$Compiler$Lexer$NumberLiteral = ([
  "NumberLiteral",
]);

const $sp$Compiler$Lexer$SingleQuote = (($1) => ([
  "SingleQuote",
  $1,
]));

const $sp$Compiler$Lexer$Spaces = ([
  "Spaces",
]);

const $sp$Compiler$Lexer$Squiggles = ([
  "Squiggles",
]);

const $sp$Compiler$Lexer$Tabs = ([
  "Tabs",
]);

const $sp$Compiler$Lexer$TripleQuote = (($1) => ([
  "TripleQuote",
  $1,
]));

const $sp$Compiler$Lexer$Word = (($1) => ([
  "Word",
  $1,
]));

const $sp$Compiler$MakeEmittable$DollarName = (($1) => ([
  "DollarName",
  $1,
]));

const $sp$Compiler$MakeEmittable$NoNamedVariables = ([
  "NoNamedVariables",
]);

const $sp$Compiler$MakeEmittable$SafeMainName = (($1) => ([
  "SafeMainName",
  $1,
]));

const $sp$Compiler$MakeEmittable$TrivialPattern = (($1) => ([
  "TrivialPattern",
  $1,
]));

const $sp$Compiler$TypeCheck$Cycle = (($1) => ([
  "Cycle",
  $1,
]));

const $sp$Compiler$TypeCheck$IncompatibleMutability = ([
  "IncompatibleMutability",
]);

const $sp$Compiler$TypeCheck$IncompatibleRecords = (($1) => ([
  "IncompatibleRecords",
  $1,
]));

const $sp$Compiler$TypeCheck$IncompatibleTypes = ([
  "IncompatibleTypes",
]);

const $sp$Compiler$TypeCheck$NI = (($1) => ([
  "NI",
  $1,
]));

const $sp$Compiler$TypeCheck$NonFunctionContainsFunction = (($1) => ([
  "NonFunctionContainsFunction",
  $1,
]));

const $sp$Compiler$TypeCheck$OkThisIsActuallyPossible = ([
  "OkThisIsActuallyPossible",
]);

const $sp$Compiler$TypeCheck$SubstitutingAnnotation = (($1) => ([
  "SubstitutingAnnotation",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AnnotationSimple = ([
  "UnifyReason_AnnotationSimple",
]);

const $sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock = (($1) => (($2) => (($3) => ([
  "UnifyReason_AnnotationVsBlock",
  $1,
  $2,
  $3,
]))));

const $sp$Compiler$TypeCheck$UnifyReason_AttributeAccess = (($1) => ([
  "UnifyReason_AttributeAccess",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate = (($1) => ([
  "UnifyReason_AttributeUpdate",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_CallArgument = (($1) => ([
  "UnifyReason_CallArgument",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument = (($1) => ([
  "UnifyReason_ConstructorArgument",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern = ([
  "UnifyReason_DefBlockVsPattern",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IfBranches = ([
  "UnifyReason_IfBranches",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IfCondition = ([
  "UnifyReason_IfCondition",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction = (($1) => (($2) => ([
  "UnifyReason_IsBeingCalledAsAFunction",
  $1,
  $2,
])));

const $sp$Compiler$TypeCheck$UnifyReason_IsLambda = ([
  "UnifyReason_IsLambda",
]);

const $sp$Compiler$TypeCheck$UnifyReason_Override = ([
  "UnifyReason_Override",
]);

const $sp$Compiler$TypeCheck$UnifyReason_TryBlock = (($1) => ([
  "UnifyReason_TryBlock",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_TryPattern = ([
  "UnifyReason_TryPattern",
]);

const $sp$ModulesFile$Dir = (($1) => ([
  "Dir",
  $1,
]));

const $sp$ModulesFile$Lib = (($1) => ([
  "Lib",
  $1,
]));

const $sp$SPLib$Parser$Aborted = (($1) => (($2) => ([
  "Aborted",
  $1,
  $2,
])));

const $sp$SPLib$Parser$Accepted = (($1) => (($2) => ([
  "Accepted",
  $1,
  $2,
])));

const $sp$SPLib$Parser$Rejected = ([
  "Rejected",
]);

const $sp$SPON$Accepted = (($1) => (($2) => ([
  "Accepted",
  $1,
  $2,
])));

const $sp$SPON$Failed = (($1) => ([
  "Failed",
  $1,
]));

const $sp$SPON$Rejected = (($1) => ([
  "Rejected",
  $1,
]));

const $sp$Test$CodeExpectation = (($1) => ([
  "CodeExpectation",
  $1,
]));

const $sp$Test$Error = (($1) => ([
  "Error",
  $1,
]));

const $sp$Test$Group = (($1) => (($2) => ([
  "Group",
  $1,
  $2,
])));

const $sp$Test$NotNow = (($1) => ([
  "NotNow",
  $1,
]));

const $sp$Test$Single = (($1) => (($2) => (($3) => ([
  "Single",
  $1,
  $2,
  $3,
]))));

const $sp$Test$Skipped = ([
  "Skipped",
]);

const $sp$Test$Success = ([
  "Success",
]);

const $sp$Types$CanonicalAst$ArgumentExpression = (($1) => ([
  "ArgumentExpression",
  $1,
]));

const $sp$Types$CanonicalAst$ArgumentMutable = (($1) => (($2) => ([
  "ArgumentMutable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Call = (($1) => (($2) => (($3) => ([
  "Call",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$Constructor = (($1) => (($2) => ([
  "Constructor",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$If = (($1) => (($2) => ([
  "If",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Lambda = (($1) => (($2) => (($3) => ([
  "Lambda",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$LetIn = (($1) => (($2) => ([
  "LetIn",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LiteralNumber = (($1) => (($2) => ([
  "LiteralNumber",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LiteralText = (($1) => (($2) => ([
  "LiteralText",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$ParameterMutable = (($1) => (($2) => ([
  "ParameterMutable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$ParameterPattern = (($1) => ([
  "ParameterPattern",
  $1,
]));

const $sp$Types$CanonicalAst$PatternAny = (($1) => (($2) => (($3) => ([
  "PatternAny",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$PatternConstructor = (($1) => (($2) => (($3) => ([
  "PatternConstructor",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$PatternLiteralNumber = (($1) => (($2) => ([
  "PatternLiteralNumber",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternLiteralText = (($1) => (($2) => ([
  "PatternLiteralText",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternRecord = (($1) => (($2) => ([
  "PatternRecord",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Record = (($1) => (($2) => (($3) => ([
  "Record",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$RefBlock = (($1) => ([
  "RefBlock",
  $1,
]));

const $sp$Types$CanonicalAst$RefRoot = (($1) => ([
  "RefRoot",
  $1,
]));

const $sp$Types$CanonicalAst$Try = (($1) => (($2) => (($3) => ([
  "Try",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeAlias = (($1) => (($2) => (($3) => ([
  "TypeAlias",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeConstant = (($1) => (($2) => (($3) => ([
  "TypeConstant",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeDefAlias = (($1) => ([
  "TypeDefAlias",
  $1,
]));

const $sp$Types$CanonicalAst$TypeDefUnion = (($1) => ([
  "TypeDefUnion",
  $1,
]));

const $sp$Types$CanonicalAst$TypeFunction = (($1) => (($2) => (($3) => (($4) => ([
  "TypeFunction",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$CanonicalAst$TypeRecord = (($1) => (($2) => (($3) => ([
  "TypeRecord",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeVariable = (($1) => (($2) => ([
  "TypeVariable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Variable = (($1) => (($2) => ([
  "Variable",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$And = (($1) => ([
  "And",
  $1,
]));

const $sp$Types$EmittableAst$ArrayAccess = (($1) => (($2) => ([
  "ArrayAccess",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$Call = (($1) => (($2) => ([
  "Call",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$Conditional = (($1) => (($2) => (($3) => ([
  "Conditional",
  $1,
  $2,
  $3,
]))));

const $sp$Types$EmittableAst$Constructor = (($1) => ([
  "Constructor",
  $1,
]));

const $sp$Types$EmittableAst$ConstructorAccess = (($1) => (($2) => ([
  "ConstructorAccess",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$Immutable = ([
  "Immutable",
]);

const $sp$Types$EmittableAst$IsConstructor = (($1) => (($2) => ([
  "IsConstructor",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$Lambda = (($1) => (($2) => ([
  "Lambda",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$LetIn = (($1) => ([
  "LetIn",
  $1,
]));

const $sp$Types$EmittableAst$LiteralArray = (($1) => ([
  "LiteralArray",
  $1,
]));

const $sp$Types$EmittableAst$LiteralNumber = (($1) => ([
  "LiteralNumber",
  $1,
]));

const $sp$Types$EmittableAst$LiteralRecord = (($1) => (($2) => ([
  "LiteralRecord",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$LiteralText = (($1) => ([
  "LiteralText",
  $1,
]));

const $sp$Types$EmittableAst$MissingPattern = (($1) => (($2) => ([
  "MissingPattern",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$Mutable = ([
  "Mutable",
]);

const $sp$Types$EmittableAst$RecordAccess = (($1) => (($2) => ([
  "RecordAccess",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$ShallowEqual = (($1) => (($2) => ([
  "ShallowEqual",
  $1,
  $2,
])));

const $sp$Types$EmittableAst$Variable = (($1) => (($2) => ([
  "Variable",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Binop = (($1) => (($2) => (($3) => ([
  "Binop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Constructor = (($1) => (($2) => (($3) => ([
  "Constructor",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Definition = (($1) => (($2) => ([
  "Definition",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Evaluation = (($1) => (($2) => ([
  "Evaluation",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$FunctionCall = (($1) => (($2) => (($3) => ([
  "FunctionCall",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$If = (($1) => (($2) => ([
  "If",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Lambda = (($1) => (($2) => (($3) => (($4) => ([
  "Lambda",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$List = (($1) => (($2) => ([
  "List",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$LiteralNumber = (($1) => (($2) => ([
  "LiteralNumber",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$LiteralText = (($1) => (($2) => ([
  "LiteralText",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Mutable = (($1) => (($2) => (($3) => ([
  "Mutable",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$PatternAny = (($1) => (($2) => (($3) => (($4) => ([
  "PatternAny",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$PatternConstructor = (($1) => (($2) => (($3) => (($4) => ([
  "PatternConstructor",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$PatternList = (($1) => (($2) => ([
  "PatternList",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternListCons = (($1) => (($2) => ([
  "PatternListCons",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternLiteralNumber = (($1) => (($2) => ([
  "PatternLiteralNumber",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternLiteralText = (($1) => (($2) => ([
  "PatternLiteralText",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternRecord = (($1) => (($2) => ([
  "PatternRecord",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternTuple = (($1) => (($2) => ([
  "PatternTuple",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PrefixBinop = (($1) => (($2) => ([
  "PrefixBinop",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Record = (($1) => (($2) => ([
  "Record",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$RecordShorthand = (($1) => (($2) => ([
  "RecordShorthand",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Try = (($1) => (($2) => ([
  "Try",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeAlias = (($1) => ([
  "TypeAlias",
  $1,
]));

const $sp$Types$FormattableAst$TypeConstant = (($1) => (($2) => (($3) => (($4) => ([
  "TypeConstant",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$TypeFunction = (($1) => (($2) => (($3) => (($4) => ([
  "TypeFunction",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$TypeList = (($1) => (($2) => ([
  "TypeList",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeRecord = (($1) => (($2) => ([
  "TypeRecord",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeTuple = (($1) => (($2) => ([
  "TypeTuple",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeVariable = (($1) => (($2) => ([
  "TypeVariable",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$UnionDef = (($1) => (($2) => ([
  "UnionDef",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Unop = (($1) => (($2) => (($3) => ([
  "Unop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Variable = (($1) => (($2) => (($3) => (($4) => ([
  "Variable",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$JavascriptAst$AccessWithBrackets = (($1) => (($2) => ([
  "AccessWithBrackets",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$AccessWithDot = (($1) => (($2) => ([
  "AccessWithDot",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Array = (($1) => ([
  "Array",
  $1,
]));

const $sp$Types$JavascriptAst$Binop = (($1) => (($2) => (($3) => ([
  "Binop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$JavascriptAst$BlockLambda = (($1) => (($2) => ([
  "BlockLambda",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Call = (($1) => (($2) => ([
  "Call",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Conditional = (($1) => (($2) => (($3) => ([
  "Conditional",
  $1,
  $2,
  $3,
]))));

const $sp$Types$JavascriptAst$Define = (($1) => (($2) => ([
  "Define",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Eval = (($1) => ([
  "Eval",
  $1,
]));

const $sp$Types$JavascriptAst$If = (($1) => (($2) => ([
  "If",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Literal = (($1) => ([
  "Literal",
  $1,
]));

const $sp$Types$JavascriptAst$Mutop = (($1) => (($2) => (($3) => (($4) => ([
  "Mutop",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$JavascriptAst$Record = (($1) => ([
  "Record",
  $1,
]));

const $sp$Types$JavascriptAst$Return = (($1) => ([
  "Return",
  $1,
]));

const $sp$Types$JavascriptAst$SimpleLambda = (($1) => (($2) => ([
  "SimpleLambda",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Unop = (($1) => (($2) => ([
  "Unop",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Var = (($1) => ([
  "Var",
  $1,
]));

const $sp$Types$Meta$Core = ([
  "Core",
]);

const $sp$Types$Meta$SourceDir = (($1) => ([
  "SourceDir",
  $1,
]));

const $sp$Types$Meta$UMR = (($1) => (($2) => ([
  "UMR",
  $1,
  $2,
])));

const $sp$Types$Meta$USR = (($1) => (($2) => ([
  "USR",
  $1,
  $2,
])));

const $sp$Types$Op$Addittive = ([
  "Addittive",
]);

const $sp$Types$Op$Comparison = ([
  "Comparison",
]);

const $sp$Types$Op$Cons = ([
  "Cons",
]);

const $sp$Types$Op$Exponential = ([
  "Exponential",
]);

const $sp$Types$Op$Left = ([
  "Left",
]);

const $sp$Types$Op$Logical = ([
  "Logical",
]);

const $sp$Types$Op$Multiplicative = ([
  "Multiplicative",
]);

const $sp$Types$Op$Mutop = ([
  "Mutop",
]);

const $sp$Types$Op$NonAssociative = ([
  "NonAssociative",
]);

const $sp$Types$Op$Pipe = ([
  "Pipe",
]);

const $sp$Types$Op$Right = ([
  "Right",
]);

const $sp$Types$Op$Tuple = ([
  "Tuple",
]);

const $sp$Types$Pos$At = (($1) => (($2) => ([
  "At",
  $1,
  $2,
])));

const $sp$Types$Pos$End = (($1) => ([
  "End",
  $1,
]));

const $sp$Types$Pos$G = ([
  "G",
]);

const $sp$Types$Pos$I = (($1) => ([
  "I",
  $1,
]));

const $sp$Types$Pos$N = ([
  "N",
]);

const $sp$Types$Pos$P = (($1) => (($2) => (($3) => ([
  "P",
  $1,
  $2,
  $3,
]))));

const $sp$Types$Pos$S = ([
  "S",
]);

const $sp$Types$Pos$T = ([
  "T",
]);

const $sp$Types$Token$As = ([
  "As",
]);

const $sp$Types$Token$BadIndent = ([
  "BadIndent",
]);

const $sp$Types$Token$Binop = (($1) => ([
  "Binop",
  $1,
]));

const $sp$Types$Token$BlockEnd = ([
  "BlockEnd",
]);

const $sp$Types$Token$BlockStart = ([
  "BlockStart",
]);

const $sp$Types$Token$Closed = ([
  "Closed",
]);

const $sp$Types$Token$Colon = ([
  "Colon",
]);

const $sp$Types$Token$Comma = ([
  "Comma",
]);

const $sp$Types$Token$Comment = ([
  "Comment",
]);

const $sp$Types$Token$CurlyBrace = (($1) => ([
  "CurlyBrace",
  $1,
]));

const $sp$Types$Token$DefMutable = ([
  "DefMutable",
]);

const $sp$Types$Token$DefNormal = ([
  "DefNormal",
]);

const $sp$Types$Token$Defop = (($1) => ([
  "Defop",
  $1,
]));

const $sp$Types$Token$Else = ([
  "Else",
]);

const $sp$Types$Token$ErrorBlock = (($1) => ([
  "ErrorBlock",
  $1,
]));

const $sp$Types$Token$ErrorUnknownOp = (($1) => ([
  "ErrorUnknownOp",
  $1,
]));

const $sp$Types$Token$ErrorUnterminated = (($1) => ([
  "ErrorUnterminated",
  $1,
]));

const $sp$Types$Token$If = ([
  "If",
]);

const $sp$Types$Token$LowerName = (($1) => (($2) => (($3) => (($4) => ([
  "LowerName",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$Token$MutableColon = ([
  "MutableColon",
]);

const $sp$Types$Token$NameMutable = ([
  "NameMutable",
]);

const $sp$Types$Token$NameNoModifier = ([
  "NameNoModifier",
]);

const $sp$Types$Token$NameStartsWithDot = ([
  "NameStartsWithDot",
]);

const $sp$Types$Token$NewSiblingLine = ([
  "NewSiblingLine",
]);

const $sp$Types$Token$NumberLiteral = (($1) => ([
  "NumberLiteral",
  $1,
]));

const $sp$Types$Token$Open = ([
  "Open",
]);

const $sp$Types$Token$RoundParen = (($1) => ([
  "RoundParen",
  $1,
]));

const $sp$Types$Token$SquareBracket = (($1) => ([
  "SquareBracket",
  $1,
]));

const $sp$Types$Token$TextLiteral = (($1) => ([
  "TextLiteral",
  $1,
]));

const $sp$Types$Token$Then = ([
  "Then",
]);

const $sp$Types$Token$Token = (($1) => (($2) => (($3) => ([
  "Token",
  $1,
  $2,
  $3,
]))));

const $sp$Types$Token$Try = ([
  "Try",
]);

const $sp$Types$Token$Unop = (($1) => ([
  "Unop",
  $1,
]));

const $sp$Types$Token$UpperName = (($1) => (($2) => ([
  "UpperName",
  $1,
  $2,
])));

const $sp$Types$Token$With = ([
  "With",
]);

const $core$SPCore$Tuple$pair = "pair";

const $core$SPCore$sendLeft = "sendLeft";

const $core$SPCore$sendRight = "sendRight";

const $sp$Test$maybeToOutcome = (($m) => {
  return ((($m)[0] === "Just")
    ? ((() => {
      const $e = ($m)[1];
      return ($sp$Test$Error)($e);
    }))()
    : ((($m)[0] === "Nothing")
      ? $sp$Test$Success
      : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 15:4', (sp_toHuman)($m))));
});

const $sp$Test$valueTest = (($toText) => {
  return (($title) => {
    return (($generateValue) => {
      return (($ce) => {
        const $$toMaybeError = $ce;
        const $toMaybeError = ($$toMaybeError)[1];
        return ((($sp$Test$Single)($title))(""))((() => {
          return ($sp$Test$maybeToOutcome)((($toMaybeError)($toText))(($corelib$Result$Ok)(($generateValue)(null))));
        }));
      });
    });
  });
});

const $corelib$Array_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$Text$join = (($sep) => {
  return (($listOfText) => {
    return ((($listOfText)[0] === "Nil")
      ? ""
      : ((($listOfText)[0] === "Cons")
        ? ((() => {
          const $head = ($listOfText)[1];
          const $tail = ($listOfText)[2];
          const $rec = (($ls) => {
            return (($acc) => {
              return ((($ls)[0] === "Nil")
                ? $acc
                : ((($ls)[0] === "Cons")
                  ? ((() => {
                    const $h = ($ls)[1];
                    const $t = ($ls)[2];
                    return (($rec)($t))(($acc + ($sep + $h)));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 135:12', (sp_toHuman)($ls))));
            });
          });
          return (($rec)($tail))($head);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 127:4', (sp_toHuman)($listOfText))));
  });
});

const $sp$Test$isOkAndEqualTo = (($expectedOk) => {
  return ($sp$Test$CodeExpectation)((($toText) => {
    return (($result) => {
      return ((($result)[0] === "Err")
        ? ((() => {
          const $e = ($result)[1];
          return ($corelib$Maybe$Just)($e);
        }))()
        : ((($result)[0] === "Ok")
          ? ((() => {
            const $actualOk = ($result)[1];
            return (((sp_equal)($expectedOk))($actualOk)
              ? $corelib$Maybe$Nothing
              : ($corelib$Maybe$Just)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("expected = "))((($core$SPCore$Cons)(($toText)($expectedOk)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("actual = "))((($core$SPCore$Cons)(($toText)($actualOk)))($core$SPCore$Nil))))))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 81:6', (sp_toHuman)($result))));
    });
  }));
});

const $corelib$Array_Test$tests = (($sp$Test$Group)("Array"))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("push"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)("a"))($core$SPCore$Nil))),
    }),
  });
  ((array_push)($a))("b");
  ((array_push)($a))("c");
  return (array_toList)((sp_clone)(($a.obj)[$a.attr]));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("pop 1"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)("x"))((($core$SPCore$Cons)("y"))((($core$SPCore$Cons)("z"))($core$SPCore$Nil))))),
    }),
  });
  const $b = (array_pop)($a);
  const $c = (array_pop)($a);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  b: ($corelib$Maybe$Just)("z"),
  c: ($corelib$Maybe$Just)("y"),
  l: (($core$SPCore$Cons)("x"))($core$SPCore$Nil),
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("pop empty"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)($core$SPCore$Nil)),
    }),
  });
  const $b = (array_pop)($a);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    b: $b,
    l: $l,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  b: $corelib$Maybe$Nothing,
  l: $core$SPCore$Nil,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("get Just"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)("p"))((($core$SPCore$Cons)("q"))($core$SPCore$Nil)))),
    }),
  });
  return ((array_get)((sp_clone)(($a.obj)[$a.attr])))(1);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)("q")))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("get Nothing"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)("p"))((($core$SPCore$Cons)("q"))($core$SPCore$Nil)))),
    }),
  });
  return ((array_get)((sp_clone)(($a.obj)[$a.attr])))(3);
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("set success"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil)))),
    }),
  });
  const $r = (((array_set)($a))(0))(10);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    l: $l,
    r: $r,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  l: (($core$SPCore$Cons)(10))((($core$SPCore$Cons)(9))($core$SPCore$Nil)),
  r: true,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("set fail"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil)))),
    }),
  });
  const $r = (((array_set)($a))(3))(10);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    l: $l,
    r: $r,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  l: (($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil)),
  r: false,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("sortBy"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)((($core$SPCore$Cons)(55))((($core$SPCore$Cons)(99))((($core$SPCore$Cons)(22))($core$SPCore$Nil))))),
    }),
  });
  ((array_sortBy)($a))((($x) => {
    return -($x);
  }));
  return (array_toList)((sp_clone)(($a.obj)[$a.attr]));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(99))((($core$SPCore$Cons)(55))((($core$SPCore$Cons)(22))($core$SPCore$Nil)))))))($core$SPCore$Nil)))))))));

const $corelib$Basics$btw = (($f) => {
  return (($a) => {
    return (($c) => {
      ($f)($a);
      return $c;
    });
  });
});

const $corelib$Basics$clamp = (($low) => {
  return (($high) => {
    return (($n) => {
      return (($n < $low)
        ? $low
        : (($n > $high)
          ? $high
          : $n));
    });
  });
});

const $corelib$Basics$identity = (($a) => {
  return $a;
});

const $corelib$Basics$max = (($a) => {
  return (($b) => {
    return (($a > $b)
      ? $a
      : $b);
  });
});

const $corelib$Basics$min = (($a) => {
  return (($b) => {
    return (($a < $b)
      ? $a
      : $b);
  });
});

const $corelib$Basics$not = (($b) => {
  return ($b
    ? false
    : true);
});

const $corelib$Dict$balance = (($color) => {
  return (($key) => {
    return (($value) => {
      return (($left) => {
        return (($right) => {
          return (((($right)[0] === "RBNode_elm_builtin") && ((($right)[1])[0] === "Red"))
            ? ((() => {
              const $rK = ($right)[2];
              const $rV = ($right)[3];
              const $rLeft = ($right)[4];
              const $rRight = ($right)[5];
              return (((($left)[0] === "RBNode_elm_builtin") && ((($left)[1])[0] === "Red"))
                ? ((() => {
                  const $lK = ($left)[2];
                  const $lV = ($left)[3];
                  const $lLeft = ($left)[4];
                  const $lRight = ($left)[5];
                  return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($rK))($rV))($rLeft))($rRight));
                }))()
                : (true
                  ? ((((($corelib$Dict$RBNode_elm_builtin)($color))($rK))($rV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($left))($rLeft)))($rRight)
                  : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 117:6', (sp_toHuman)($left))));
            }))()
            : (true
              ? (((($left)[0] === "RBNode_elm_builtin") && (((($left)[1])[0] === "Red") && (((($left)[4])[0] === "RBNode_elm_builtin") && (((($left)[4])[1])[0] === "Red"))))
                ? ((() => {
                  const $lK = ($left)[2];
                  const $lV = ($left)[3];
                  const $llK = (($left)[4])[2];
                  const $llV = (($left)[4])[3];
                  const $llLeft = (($left)[4])[4];
                  const $llRight = (($left)[4])[5];
                  const $lRight = ($left)[5];
                  return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($llK))($llV))($llLeft))($llRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($key))($value))($lRight))($right));
                }))()
                : (true
                  ? ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))($left))($right)
                  : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 130:6', (sp_toHuman)($left))))
              : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 115:2', (sp_toHuman)($right))));
        });
      });
    });
  });
});

const $corelib$Dict$for = (($dict) => {
  return (($func) => {
    return (($acc) => {
      return ((($dict)[0] === "RBEmpty_elm_builtin")
        ? $acc
        : ((($dict)[0] === "RBNode_elm_builtin")
          ? ((() => {
            const $key = ($dict)[2];
            const $value = ($dict)[3];
            const $left = ($dict)[4];
            const $right = ($dict)[5];
            return ((($corelib$Dict$for)($right))($func))(((($func)($key))($value))(((($corelib$Dict$for)($left))($func))($acc)));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 454:2', (sp_toHuman)($dict))));
    });
  });
});

const $corelib$Dict$moveRedLeft = (($dict) => {
  return (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && (((($dict)[5])[0] === "RBNode_elm_builtin") && ((((($dict)[5])[4])[0] === "RBNode_elm_builtin") && ((((($dict)[5])[4])[1])[0] === "Red")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $lLeft = (($dict)[4])[4];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rlK = ((($dict)[5])[4])[2];
      const $rlV = ((($dict)[5])[4])[3];
      const $rlL = ((($dict)[5])[4])[4];
      const $rlR = ((($dict)[5])[4])[5];
      const $rRight = (($dict)[5])[5];
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rlK))($rlV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))($rlL)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($rK))($rV))($rlR))($rRight));
    }))()
    : (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && ((($dict)[5])[0] === "RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "Black")
          ? ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight))
          : ((($clr)[0] === "Red")
            ? ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 285:6', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 275:2', (sp_toHuman)($dict)))));
});

const $corelib$Dict$getMin = (($dict) => {
  return ((($dict)[0] === "RBNode_elm_builtin")
    ? ((() => {
      const $left = ($dict)[4];
      return ((($left)[0] === "RBNode_elm_builtin")
        ? ($corelib$Dict$getMin)($left)
        : (true
          ? $dict
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 234:6', (sp_toHuman)($left))));
    }))()
    : (true
      ? $dict
      : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 232:2', (sp_toHuman)($dict))));
});

const $corelib$Dict$removeMin = (($dict) => {
  return ((($dict)[0] === "RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((($left)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $lColor = ($left)[1];
          const $lLeft = ($left)[4];
          return ((($lColor)[0] === "Black")
            ? (((($lLeft)[0] === "RBNode_elm_builtin") && ((($lLeft)[1])[0] === "Red"))
              ? ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))(($corelib$Dict$removeMin)($left)))($right)
              : (true
                ? ((() => {
                  const $$try1 = ($corelib$Dict$moveRedLeft)($dict);
                  return ((($$try1)[0] === "RBNode_elm_builtin")
                    ? ((() => {
                      const $nColor = ($$try1)[1];
                      const $nKey = ($$try1)[2];
                      const $nValue = ($$try1)[3];
                      const $nLeft = ($$try1)[4];
                      const $nRight = ($$try1)[5];
                      return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))(($corelib$Dict$removeMin)($nLeft)))($nRight);
                    }))()
                    : ((($$try1)[0] === "RBEmpty_elm_builtin")
                      ? $corelib$Dict$RBEmpty_elm_builtin
                      : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 257:18', (sp_toHuman)($$try1))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 252:14', (sp_toHuman)($lLeft))))
            : (true
              ? ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))(($corelib$Dict$removeMin)($left)))($right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 250:10', (sp_toHuman)($lColor))));
        }))()
        : (true
          ? $corelib$Dict$RBEmpty_elm_builtin
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 248:6', (sp_toHuman)($left))));
    }))()
    : (true
      ? $corelib$Dict$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 246:2', (sp_toHuman)($dict))));
});

const $corelib$Dict$removeHelpEQGT = (($targetKey) => {
  return (($dict) => {
    return ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (((sp_equal)($key))($targetKey)
          ? ((() => {
            const $$try1 = ($corelib$Dict$getMin)($right);
            return ((($$try1)[0] === "RBNode_elm_builtin")
              ? ((() => {
                const $minKey = ($$try1)[2];
                const $minValue = ($$try1)[3];
                return ((((($corelib$Dict$balance)($color))($minKey))($minValue))($left))(($corelib$Dict$removeMin)($right));
              }))()
              : ((($$try1)[0] === "RBEmpty_elm_builtin")
                ? $corelib$Dict$RBEmpty_elm_builtin
                : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 217:8', (sp_toHuman)($$try1))));
          }))()
          : ((((($corelib$Dict$balance)($color))($key))($value))($left))((($corelib$Dict$removeHelp)($targetKey))($right)));
      }))()
      : ((($dict)[0] === "RBEmpty_elm_builtin")
        ? $corelib$Dict$RBEmpty_elm_builtin
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 214:2', (sp_toHuman)($dict))));
  });
});

const $corelib$Dict$moveRedRight = (($dict) => {
  return (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && ((((($dict)[4])[4])[0] === "RBNode_elm_builtin") && (((((($dict)[4])[4])[1])[0] === "Red") && ((($dict)[5])[0] === "RBNode_elm_builtin")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $llK = ((($dict)[4])[4])[2];
      const $llV = ((($dict)[4])[4])[3];
      const $llLeft = ((($dict)[4])[4])[4];
      const $llRight = ((($dict)[4])[4])[5];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rLeft = (($dict)[5])[4];
      const $rRight = (($dict)[5])[5];
      return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($llK))($llV))($llLeft))($llRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($lRight))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight)));
    }))()
    : (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && ((($dict)[5])[0] === "RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "Black")
          ? ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight))
          : ((($clr)[0] === "Red")
            ? ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 318:6', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 308:2', (sp_toHuman)($dict)))));
});

const $corelib$Dict$removeHelpPrepEQGT = (($targetKey) => {
  return (($dict) => {
    return (($color) => {
      return (($key) => {
        return (($value) => {
          return (($left) => {
            return (($right) => {
              return (((($left)[0] === "RBNode_elm_builtin") && ((($left)[1])[0] === "Red"))
                ? ((() => {
                  const $lK = ($left)[2];
                  const $lV = ($left)[3];
                  const $lLeft = ($left)[4];
                  const $lRight = ($left)[5];
                  return ((((($corelib$Dict$RBNode_elm_builtin)($color))($lK))($lV))($lLeft))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($lRight))($right));
                }))()
                : (true
                  ? (((($right)[0] === "RBNode_elm_builtin") && (((($right)[1])[0] === "Black") && (((($right)[4])[0] === "RBNode_elm_builtin") && (((($right)[4])[1])[0] === "Black"))))
                    ? ($corelib$Dict$moveRedRight)($dict)
                    : (((($right)[0] === "RBNode_elm_builtin") && (((($right)[1])[0] === "Black") && ((($right)[4])[0] === "RBEmpty_elm_builtin")))
                      ? ($corelib$Dict$moveRedRight)($dict)
                      : (true
                        ? $dict
                        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 199:6', (sp_toHuman)($right)))))
                  : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 189:2', (sp_toHuman)($left))));
            });
          });
        });
      });
    });
  });
});

const $corelib$Dict$removeHelp = (($targetKey) => {
  return (($dict) => {
    return ((($dict)[0] === "RBEmpty_elm_builtin")
      ? $corelib$Dict$RBEmpty_elm_builtin
      : ((($dict)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $color = ($dict)[1];
          const $key = ($dict)[2];
          const $value = ($dict)[3];
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          return (((sp_equal)((0 - 1)))(((basics_compare)($targetKey))($key))
            ? (((($left)[0] === "RBNode_elm_builtin") && ((($left)[1])[0] === "Black"))
              ? ((() => {
                const $lLeft = ($left)[4];
                return (((($lLeft)[0] === "RBNode_elm_builtin") && ((($lLeft)[1])[0] === "Red"))
                  ? ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))((($corelib$Dict$removeHelp)($targetKey))($left)))($right)
                  : (true
                    ? ((() => {
                      const $$try1 = ($corelib$Dict$moveRedLeft)($dict);
                      return ((($$try1)[0] === "RBNode_elm_builtin")
                        ? ((() => {
                          const $nColor = ($$try1)[1];
                          const $nKey = ($$try1)[2];
                          const $nValue = ($$try1)[3];
                          const $nLeft = ($$try1)[4];
                          const $nRight = ($$try1)[5];
                          return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))((($corelib$Dict$removeHelp)($targetKey))($nLeft)))($nRight);
                        }))()
                        : ((($$try1)[0] === "RBEmpty_elm_builtin")
                          ? $corelib$Dict$RBEmpty_elm_builtin
                          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 173:16', (sp_toHuman)($$try1))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 168:12', (sp_toHuman)($lLeft))));
              }))()
              : (true
                ? ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))((($corelib$Dict$removeHelp)($targetKey))($left)))($right)
                : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 166:8', (sp_toHuman)($left))))
            : (($corelib$Dict$removeHelpEQGT)($targetKey))(((((((($corelib$Dict$removeHelpPrepEQGT)($targetKey))($dict))($color))($key))($value))($left))($right)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 160:2', (sp_toHuman)($dict))));
  });
});

const $corelib$Dict$remove = (($key) => {
  return (($dict) => {
    const $$try1 = (($corelib$Dict$removeHelp)($key))($dict);
    return (((($$try1)[0] === "RBNode_elm_builtin") && ((($$try1)[1])[0] === "Red"))
      ? ((() => {
        const $k = ($$try1)[2];
        const $v = ($$try1)[3];
        const $l = ($$try1)[4];
        const $r = ($$try1)[5];
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($l))($r);
      }))()
      : (true
        ? ((() => {
          const $x = $$try1;
          return $x;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 148:2', (sp_toHuman)($$try1))));
  });
});

const $corelib$Dict$diff = (($t1) => {
  return (($t2) => {
    return ((($corelib$Dict$for)($t2))((($k) => {
      return (($v) => {
        return (($t) => {
          return (($corelib$Dict$remove)($k))($t);
        });
      });
    })))($t1);
  });
});

const $corelib$Dict$empty = $corelib$Dict$RBEmpty_elm_builtin;

const $corelib$Dict$insertHelp = (($key) => {
  return (($value) => {
    return (($dict) => {
      return ((($dict)[0] === "RBEmpty_elm_builtin")
        ? ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($corelib$Dict$RBEmpty_elm_builtin))($corelib$Dict$RBEmpty_elm_builtin)
        : ((($dict)[0] === "RBNode_elm_builtin")
          ? ((() => {
            const $nColor = ($dict)[1];
            const $nKey = ($dict)[2];
            const $nValue = ($dict)[3];
            const $nLeft = ($dict)[4];
            const $nRight = ($dict)[5];
            const $$try1 = ((basics_compare)($key))($nKey);
            return ((1 === $$try1)
              ? ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))($nLeft))(((($corelib$Dict$insertHelp)($key))($value))($nRight))
              : ((0 === $$try1)
                ? ((((($corelib$Dict$RBNode_elm_builtin)($nColor))($nKey))($value))($nLeft))($nRight)
                : (true
                  ? ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))(((($corelib$Dict$insertHelp)($key))($value))($nLeft)))($nRight)
                  : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 101:6', (sp_toHuman)($$try1)))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 94:2', (sp_toHuman)($dict))));
    });
  });
});

const $corelib$Dict$insert = (($key) => {
  return (($value) => {
    return (($dict) => {
      const $$try1 = ((($corelib$Dict$insertHelp)($key))($value))($dict);
      return (((($$try1)[0] === "RBNode_elm_builtin") && ((($$try1)[1])[0] === "Red"))
        ? ((() => {
          const $k = ($$try1)[2];
          const $v = ($$try1)[3];
          const $l = ($$try1)[4];
          const $r = ($$try1)[5];
          return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($l))($r);
        }))()
        : (true
          ? ((() => {
            const $x = $$try1;
            return $x;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 83:2', (sp_toHuman)($$try1))));
    });
  });
});

const $corelib$Dict$filter = (($isGood) => {
  return (($dict) => {
    return ((($corelib$Dict$for)($dict))((($k) => {
      return (($v) => {
        return (($d) => {
          return ((($isGood)($k))($v)
            ? ((($corelib$Dict$insert)($k))($v))($d)
            : $d);
        });
      });
    })))($corelib$Dict$empty);
  });
});

const $corelib$Result$onOk = (($f) => {
  return (($result) => {
    return ((($result)[0] === "Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($corelib$Result$Err)($e);
      }))()
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $a = ($result)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 18:4', (sp_toHuman)($result))));
  });
});

const $corelib$Dict$forRes = (($dict) => {
  return (($func) => {
    return (($acc) => {
      return ((($dict)[0] === "RBEmpty_elm_builtin")
        ? ($corelib$Result$Ok)($acc)
        : ((($dict)[0] === "RBNode_elm_builtin")
          ? ((() => {
            const $key = ($dict)[2];
            const $value = ($dict)[3];
            const $left = ($dict)[4];
            const $right = ($dict)[5];
            return (($corelib$Result$onOk)((($l) => {
              return (($corelib$Result$onOk)((($f) => {
                return ((($corelib$Dict$forRes)($right))($func))($f);
              })))(((($func)($key))($value))($l));
            })))(((($corelib$Dict$forRes)($left))($func))($acc));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 464:4', (sp_toHuman)($dict))));
    });
  });
});

const $corelib$Dict$forReversed = (($t) => {
  return (($func) => {
    return (($acc) => {
      return ((($t)[0] === "RBEmpty_elm_builtin")
        ? $acc
        : ((($t)[0] === "RBNode_elm_builtin")
          ? ((() => {
            const $key = ($t)[2];
            const $value = ($t)[3];
            const $left = ($t)[4];
            const $right = ($t)[5];
            return ((($corelib$Dict$forReversed)($left))($func))(((($func)($key))($value))(((($corelib$Dict$forReversed)($right))($func))($acc)));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 476:2', (sp_toHuman)($t))));
    });
  });
});

const $corelib$List$for = (($aList) => {
  return (($function) => {
    return (($init) => {
      return ((($aList)[0] === "Nil")
        ? $init
        : ((($aList)[0] === "Cons")
          ? ((() => {
            const $h = ($aList)[1];
            const $tail = ($aList)[2];
            return ((($corelib$List$for)($tail))($function))((($function)($h))($init));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 65:4', (sp_toHuman)($aList))));
    });
  });
});

const $corelib$Dict$fromList = (($assocs) => {
  return ((($corelib$List$for)($assocs))((($keyAndValue) => {
    return (($dict) => {
      return ((($corelib$Dict$insert)($keyAndValue.first))($keyAndValue.second))($dict);
    });
  })))($corelib$Dict$empty);
});

const $corelib$Dict$get = (($targetKey) => {
  return (($dict) => {
    return ((($dict)[0] === "RBEmpty_elm_builtin")
      ? $corelib$Maybe$Nothing
      : ((($dict)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $key = ($dict)[2];
          const $value = ($dict)[3];
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          const $$try1 = ((basics_compare)($targetKey))($key);
          return ((1 === $$try1)
            ? (($corelib$Dict$get)($targetKey))($right)
            : ((0 === $$try1)
              ? ($corelib$Maybe$Just)($value)
              : (true
                ? (($corelib$Dict$get)($targetKey))($left)
                : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 25:6', (sp_toHuman)($$try1)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 20:2', (sp_toHuman)($dict))));
  });
});

const $corelib$Dict$member = (($key) => {
  return (($dict) => {
    const $$try1 = (($corelib$Dict$get)($key))($dict);
    return ((($$try1)[0] === "Just")
      ? true
      : ((($$try1)[0] === "Nothing")
        ? false
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 42:2', (sp_toHuman)($$try1))));
  });
});

const $corelib$Dict$intersect = (($t1) => {
  return (($t2) => {
    return (($corelib$Dict$filter)((($k) => {
      return (() => {
        return (($corelib$Dict$member)($k))($t2);
      });
    })))($t1);
  });
});

const $corelib$Dict$isEmpty = (($dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? true
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 70:2', (sp_toHuman)($dict))));
});

const $corelib$Dict$join = (($a) => {
  return (($corelib$Dict$for)($a))($corelib$Dict$insert);
});

const $corelib$Dict$keys = (($dict) => {
  return ((($corelib$Dict$forReversed)($dict))((($key) => {
    return (($value) => {
      return (($keyList) => {
        return ((sp_cons)($keyList))($key);
      });
    });
  })))($core$SPCore$Nil);
});

const $corelib$Dict$map = (($func) => {
  return (($dict) => {
    return ((($dict)[0] === "RBEmpty_elm_builtin")
      ? $corelib$Dict$RBEmpty_elm_builtin
      : ((($dict)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $color = ($dict)[1];
          const $key = ($dict)[2];
          const $value = ($dict)[3];
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))((($func)($key))($value)))((($corelib$Dict$map)($func))($left)))((($corelib$Dict$map)($func))($right));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 426:2', (sp_toHuman)($dict))));
  });
});

const $corelib$Dict$mapKeys = (($func) => {
  return (($dict) => {
    return ((($corelib$Dict$for)($dict))((($k) => {
      return ($corelib$Dict$insert)(($func)($k));
    })))($corelib$Dict$empty);
  });
});

const $corelib$Dict$mapRes = (($func) => {
  return (($dict) => {
    return ((($dict)[0] === "RBEmpty_elm_builtin")
      ? ($corelib$Result$Ok)($corelib$Dict$RBEmpty_elm_builtin)
      : ((($dict)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $color = ($dict)[1];
          const $key = ($dict)[2];
          const $value = ($dict)[3];
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          return (($corelib$Result$onOk)((($one) => {
            return (($corelib$Result$onOk)((($two) => {
              return (($corelib$Result$onOk)((($three) => {
                return ($corelib$Result$Ok)(((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($one))($two))($three));
              })))((($corelib$Dict$mapRes)($func))($right));
            })))((($corelib$Dict$mapRes)($func))($left));
          })))((($func)($key))($value));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 436:2', (sp_toHuman)($dict))));
  });
});

const $corelib$Dict$toList = (($dict) => {
  const $f = (($key) => {
    return (($value) => {
      return (($list) => {
        return ((sp_cons)($list))(({
          first: $key,
          second: $value,
        }));
      });
    });
  });
  return ((($corelib$Dict$forReversed)($dict))($f))($core$SPCore$Nil);
});

const $corelib$Dict$merge = (($leftStep) => {
  return (($bothStep) => {
    return (($rightStep) => {
      return (($leftDict) => {
        return (($rightDict) => {
          return (($initialResult) => {
            const $stepState = (($rKey) => {
              return (($rValue) => {
                return (($q) => {
                  const $$list = $q;
                  const $res = $$list.second;
                  const $list = $$list.first;
                  return ((($list)[0] === "Nil")
                    ? ({
                      first: $list,
                      second: ((($rightStep)($rKey))($rValue))($res),
                    })
                    : ((($list)[0] === "Cons")
                      ? ((() => {
                        const $lKey = ($list)[1].first;
                        const $lValue = ($list)[1].second;
                        const $rest = ($list)[2];
                        const $$try1 = ((basics_compare)($lKey))($rKey);
                        return ((1 === $$try1)
                          ? ({
                            first: $list,
                            second: ((($rightStep)($rKey))($rValue))($res),
                          })
                          : ((0 === $$try1)
                            ? ({
                              first: $rest,
                              second: (((($bothStep)($lKey))($lValue))($rValue))($res),
                            })
                            : (true
                              ? ((($stepState)($rKey))($rValue))(({
                                first: $rest,
                                second: ((($leftStep)($lKey))($lValue))($res),
                              }))
                              : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 395:10', (sp_toHuman)($$try1)))));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 390:4', (sp_toHuman)($list))));
                });
              });
            });
            const $$intermediateResult = ((($corelib$Dict$for)($rightDict))($stepState))(({
              first: ($corelib$Dict$toList)($leftDict),
              second: $initialResult,
            }));
            const $intermediateResult = $$intermediateResult.second;
            const $leftovers = $$intermediateResult.first;
            const $liftLeftStep = (($t) => {
              return (($res) => {
                const $$k = $t;
                const $v = $$k.second;
                const $k = $$k.first;
                return ((($leftStep)($k))($v))($res);
              });
            });
            return ((($corelib$List$for)($leftovers))($liftLeftStep))($intermediateResult);
          });
        });
      });
    });
  });
});

const $corelib$Dict$partition = (($isGood) => {
  return (($dict) => {
    const $add = (($key) => {
      return (($value) => {
        return (($t) => {
          const $$t1 = $t;
          const $t2 = $$t1.second;
          const $t1 = $$t1.first;
          return ((($isGood)($key))($value)
            ? ({
              first: ((($corelib$Dict$insert)($key))($value))($t1),
              second: $t2,
            })
            : ({
              first: $t1,
              second: ((($corelib$Dict$insert)($key))($value))($t2),
            }));
        });
      });
    });
    return ((($corelib$Dict$for)($dict))($add))(({
      first: $corelib$Dict$empty,
      second: $corelib$Dict$empty,
    }));
  });
});

const $corelib$Dict$singleton = (($key) => {
  return (($value) => {
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($key))($value))($corelib$Dict$RBEmpty_elm_builtin))($corelib$Dict$RBEmpty_elm_builtin);
  });
});

const $corelib$Dict$size = ((() => {
  const $sizeHelp = (($n) => {
    return (($dict) => {
      return ((($dict)[0] === "RBEmpty_elm_builtin")
        ? $n
        : ((($dict)[0] === "RBNode_elm_builtin")
          ? ((() => {
            const $left = ($dict)[4];
            const $right = ($dict)[5];
            return (($sizeHelp)((($sizeHelp)(($n + 1)))($right)))($left);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 57:4', (sp_toHuman)($dict))));
    });
  });
  return ($sizeHelp)(0);
}))();

const $corelib$Dict$update = (($targetKey) => {
  return (($alter) => {
    return (($dictionary) => {
      const $$try1 = ($alter)((($corelib$Dict$get)($targetKey))($dictionary));
      return ((($$try1)[0] === "Just")
        ? ((() => {
          const $value = ($$try1)[1];
          return ((($corelib$Dict$insert)($targetKey))($value))($dictionary);
        }))()
        : ((($$try1)[0] === "Nothing")
          ? (($corelib$Dict$remove)($targetKey))($dictionary)
          : (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 343:2', (sp_toHuman)($$try1))));
    });
  });
});

const $corelib$Dict$values = (($dict) => {
  return ((($corelib$Dict$forReversed)($dict))((($key) => {
    return (($value) => {
      return (($valueList) => {
        return ((sp_cons)($valueList))($value);
      });
    });
  })))($core$SPCore$Nil);
});

const $corelib$Dict_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$Dict_Test$insertAndGet = (($sp$Test$Group)("insertAndGet"))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("get, success"))((() => {
  return (($corelib$Dict$get)(($corelib$Maybe$Just)("a")))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty)));
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)(1)))))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("get, fail"))((() => {
  return (($corelib$Dict$get)(($corelib$Maybe$Just)("c")))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty)));
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))($core$SPCore$Nil)));

const $corelib$Dict_Test$lists = (($sp$Test$Group)("lists"))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("keys"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))(($corelib$Dict$keys)(((($corelib$Dict$insert)($corelib$Maybe$Nothing))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty)))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(($corelib$Maybe$Just)("a")))((($core$SPCore$Cons)(($corelib$Maybe$Just)("b")))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("values"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))(($corelib$Dict$values)(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(({
    a: 3,
  })))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(({
    a: 1,
  })))($corelib$Dict$empty))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  a: 1,
})))((($core$SPCore$Cons)(({
  a: 3,
})))($core$SPCore$Nil))))))($core$SPCore$Nil)));

const $corelib$Dict_Test$tests = (($sp$Test$Group)("SPCore/Dict"))((($core$SPCore$Cons)($corelib$Dict_Test$insertAndGet))((($core$SPCore$Cons)($corelib$Dict_Test$lists))($core$SPCore$Nil)));

const $corelib$List$each = (($ls) => {
  return (($f) => {
    return ((($ls)[0] === "Nil")
      ? null
      : ((($ls)[0] === "Cons")
        ? ((() => {
          const $h = ($ls)[1];
          const $tail = ($ls)[2];
          ($f)($h);
          return (($corelib$List$each)($tail))($f);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 322:4', (sp_toHuman)($ls))));
  });
});

const $corelib$Hash$fromList = (($l) => {
  const $h = ({
    attr: "$",
    obj: ({
      $: (sp_clone)(hash_empty),
    }),
  });
  (($corelib$List$each)($l))((($$k) => {
    const $k = $$k.first;
    const $v = $$k.second;
    return (((hash_insert)($h))($k))($v);
  }));
  return (sp_clone)(($h.obj)[$h.attr]);
});

const $corelib$Hash$toList = (($h) => {
  return (((hash_for)($h))((($k) => {
    return (($v) => {
      return (($l) => {
        return ((sp_cons)($l))(({
          first: $k,
          second: $v,
        }));
      });
    });
  })))($core$SPCore$Nil);
});

const $corelib$Hash_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$List$range = (($low) => {
  return (($high) => {
    const $rec = (($accum) => {
      return (($up) => {
        return (($up > $low)
          ? (($rec)(((sp_cons)($accum))($up)))(($up - 1))
          : (((sp_equal)($low))($up)
            ? ((sp_cons)($accum))($up)
            : $accum));
      });
    });
    return (($rec)($core$SPCore$Nil))($high);
  });
});

const $corelib$Tuple$first = (($t) => {
  return $t.first;
});

const $corelib$Hash_Test$tests = (($sp$Test$Group)("Hash"))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("insert"))((() => {
  const $h = ({
    attr: "$",
    obj: ({
      $: (sp_clone)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
        first: 1,
        second: 2,
      })))($core$SPCore$Nil))),
    }),
  });
  (((hash_insert)($h))(2))(3);
  return (sp_clone)(($h.obj)[$h.attr]);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 2,
  second: 3,
})))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("remove"))((() => {
  const $h = ({
    attr: "$",
    obj: ({
      $: (sp_clone)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
        first: 1,
        second: 2,
      })))((($core$SPCore$Cons)(({
        first: 3,
        second: 4,
      })))($core$SPCore$Nil)))),
    }),
  });
  ((hash_remove)($h))(1);
  return (sp_clone)(($h.obj)[$h.attr]);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: 3,
  second: 4,
})))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("get Just"))((() => {
  const $h = ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 3,
    second: 4,
  })))($core$SPCore$Nil)));
  return ((hash_get)($h))(1);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)(2)))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("get Nothing"))((() => {
  const $h = ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 3,
    second: 4,
  })))($core$SPCore$Nil)));
  return ((hash_get)($h))(66);
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("for"))((() => {
  return (((hash_for)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: ($corelib$Maybe$Just)(true),
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: $corelib$Maybe$Nothing,
    second: 4,
  })))($core$SPCore$Nil)))))((($k) => {
    return (($v) => {
      return (($a) => {
        return ((list_sortBy)($corelib$Tuple$first))(((sp_cons)($a))(({
          first: $v,
          second: $k,
        })));
      });
    });
  })))($core$SPCore$Nil);
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: 2,
  second: ($corelib$Maybe$Just)(true),
})))((($core$SPCore$Cons)(({
  first: 4,
  second: $corelib$Maybe$Nothing,
})))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("each"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (sp_clone)((array_fromList)($core$SPCore$Nil)),
    }),
  });
  ((hash_each)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: ($corelib$Maybe$Just)(true),
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: $corelib$Maybe$Nothing,
    second: 1,
  })))($core$SPCore$Nil)))))((($k) => {
    return (($v) => {
      return (($corelib$List$each)((($corelib$List$range)(1))($v)))((() => {
        return ((array_push)($a))($k);
      }));
    });
  }));
  ((array_sortBy)($a))($corelib$Basics$identity);
  return (sp_clone)(($a.obj)[$a.attr]);
})))(($sp$Test$isOkAndEqualTo)((array_fromList)((($core$SPCore$Cons)(($corelib$Maybe$Just)(true)))((($core$SPCore$Cons)(($corelib$Maybe$Just)(true)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil))))))))($core$SPCore$Nil)))))));

const $corelib$List$all = (($fun) => {
  return (($list) => {
    return ((($list)[0] === "Nil")
      ? true
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return (($fun)($h)
            ? (($corelib$List$all)($fun))($t)
            : false);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 13:4', (sp_toHuman)($list))));
  });
});

const $corelib$List$any = (($fun) => {
  return (($list) => {
    return ((($list)[0] === "Nil")
      ? false
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return (($fun)($h)
            ? true
            : (($corelib$List$any)($fun))($t));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 6:4', (sp_toHuman)($list))));
  });
});

const $corelib$List$reverse = (($aList) => {
  return ((($corelib$List$for)($aList))($core$SPCore$Cons))($core$SPCore$Nil);
});

const $corelib$List$forReversed = (($list) => {
  return (($f) => {
    return (($init) => {
      const $foldrHelper = (($acc) => {
        return (($ctr) => {
          return (($ls) => {
            return ((($ls)[0] === "Nil")
              ? $acc
              : ((($ls)[0] === "Cons")
                ? ((() => {
                  const $a = ($ls)[1];
                  const $r1 = ($ls)[2];
                  return ((($r1)[0] === "Nil")
                    ? (($f)($a))($acc)
                    : ((($r1)[0] === "Cons")
                      ? ((() => {
                        const $b = ($r1)[1];
                        const $r2 = ($r1)[2];
                        return ((($r2)[0] === "Nil")
                          ? (($f)($a))((($f)($b))($acc))
                          : ((($r2)[0] === "Cons")
                            ? ((() => {
                              const $c = ($r2)[1];
                              const $r3 = ($r2)[2];
                              return ((($r3)[0] === "Nil")
                                ? (($f)($a))((($f)($b))((($f)($c))($acc)))
                                : ((($r3)[0] === "Cons")
                                  ? ((() => {
                                    const $d = ($r3)[1];
                                    const $r4 = ($r3)[2];
                                    const $res = (($ctr > 500)
                                      ? ((($corelib$List$for)(($corelib$List$reverse)($r4)))($f))($acc)
                                      : ((($foldrHelper)($acc))(($ctr + 1)))($r4));
                                    return (($f)($a))((($f)($b))((($f)($c))((($f)($d))($res))));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 99:32', (sp_toHuman)($r3))));
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 94:24', (sp_toHuman)($r2))));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 89:16', (sp_toHuman)($r1))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 84:8', (sp_toHuman)($ls))));
          });
        });
      });
      return ((($foldrHelper)($init))(0))($list);
    });
  });
});

const $corelib$List$append = (($xs) => {
  return (($ys) => {
    return ((($ys)[0] === "Nil")
      ? $xs
      : (true
        ? ((($corelib$List$forReversed)($xs))($core$SPCore$Cons))($ys)
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 189:2', (sp_toHuman)($ys))));
  });
});

const $corelib$List$concat = (($lists) => {
  return ((($corelib$List$forReversed)($lists))($corelib$List$append))($core$SPCore$Nil);
});

const $corelib$List$map = (($f) => {
  return (($list) => {
    return ((($corelib$List$forReversed)($list))((($x) => {
      return (($acc) => {
        return ((sp_cons)($acc))(($f)($x));
      });
    })))($core$SPCore$Nil);
  });
});

const $corelib$List$concatMap = (($f) => {
  return (($list) => {
    return ($corelib$List$concat)((($corelib$List$map)($f))($list));
  });
});

const $corelib$List$drop = (($n) => {
  return (($ls) => {
    return (((sp_equal)(0))($n)
      ? $ls
      : ((($ls)[0] === "Nil")
        ? $core$SPCore$Nil
        : ((($ls)[0] === "Cons")
          ? ((() => {
            const $h = ($ls)[1];
            const $tail = ($ls)[2];
            return (($corelib$List$drop)(($n - 1)))($tail);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 352:6', (sp_toHuman)($ls)))));
  });
});

const $corelib$List$filter = (($f) => {
  return (($ls) => {
    return ((($corelib$List$forReversed)($ls))((($item) => {
      return (($acc) => {
        return (($f)($item)
          ? ((sp_cons)($acc))($item)
          : $acc);
      });
    })))($core$SPCore$Nil);
  });
});

const $corelib$List$filterMap = (($f) => {
  return (($la) => {
    const $update = (($a) => {
      return (($acc) => {
        const $$try1 = ($f)($a);
        return ((($$try1)[0] === "Just")
          ? ((() => {
            const $b = ($$try1)[1];
            return ((sp_cons)($acc))($b);
          }))()
          : ((($$try1)[0] === "Nothing")
            ? $acc
            : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 299:6', (sp_toHuman)($$try1))));
      });
    });
    return ((($corelib$List$forReversed)($la))($update))($core$SPCore$Nil);
  });
});

const $corelib$List$find = (($test) => {
  return (($list) => {
    return ((($list)[0] === "Nil")
      ? $corelib$Maybe$Nothing
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return (($test)($h)
            ? ($corelib$Maybe$Just)($h)
            : (($corelib$List$find)($test))($t));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 24:4', (sp_toHuman)($list))));
  });
});

const $corelib$List$foldlRes = (($f) => {
  return (($ls) => {
    return (($accum) => {
      return ((($ls)[0] === "Nil")
        ? ($corelib$Result$Ok)($accum)
        : ((($ls)[0] === "Cons")
          ? ((() => {
            const $h = ($ls)[1];
            const $t = ($ls)[2];
            const $$try1 = (($f)($h))($accum);
            return ((($$try1)[0] === "Err")
              ? ((() => {
                const $x = ($$try1)[1];
                return ($corelib$Result$Err)($x);
              }))()
              : ((($$try1)[0] === "Ok")
                ? ((() => {
                  const $newAccum = ($$try1)[1];
                  return ((($corelib$List$foldlRes)($f))($t))($newAccum);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 155:12', (sp_toHuman)($$try1))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 150:4', (sp_toHuman)($ls))));
    });
  });
});

const $corelib$List$head = (($list) => {
  return ((($list)[0] === "Nil")
    ? $corelib$Maybe$Nothing
    : ((($list)[0] === "Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ($corelib$Maybe$Just)($h);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 206:4', (sp_toHuman)($list))));
});

const $corelib$List$indexBy = (($getIndex) => {
  return (($list) => {
    return ((($corelib$List$for)($list))((($i) => {
      return (($corelib$Dict$insert)(($getIndex)($i)))($i);
    })))($corelib$Dict$empty);
  });
});

const $corelib$Tuple$second = (($t) => {
  return $t.second;
});

const $corelib$List$indexedFor = (($aList) => {
  return (($function) => {
    return (($init) => {
      return ($corelib$Tuple$second)(((($corelib$List$for)($aList))((($item) => {
        return (($$accum) => {
          const $index = $$accum.first;
          const $accum = $$accum.second;
          return ({
            first: ($index + 1),
            second: ((($function)($index))($item))($accum),
          });
        });
      })))(({
        first: 0,
        second: $init,
      })));
    });
  });
});

const $corelib$List$indexedMap = (($f) => {
  const $rec = (($accum) => {
    return (($n) => {
      return (($list) => {
        return ((($list)[0] === "Nil")
          ? ($corelib$List$reverse)($accum)
          : ((($list)[0] === "Cons")
            ? ((() => {
              const $h = ($list)[1];
              const $t = ($list)[2];
              return ((($rec)(((sp_cons)($accum))((($f)($n))($h))))(($n + 1)))($t);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 180:8', (sp_toHuman)($list))));
      });
    });
  });
  return (($rec)($core$SPCore$Nil))(0);
});

const $corelib$List$last = (($list) => {
  return ((($list)[0] === "Nil")
    ? $corelib$Maybe$Nothing
    : (((($list)[0] === "Cons") && ((($list)[2])[0] === "Nil"))
      ? ((() => {
        const $h = ($list)[1];
        return ($corelib$Maybe$Just)($h);
      }))()
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return ($corelib$List$last)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 213:4', (sp_toHuman)($list)))));
});

const $corelib$List$length = (($list) => {
  return ((($corelib$List$for)($list))((() => {
    return (($a) => {
      return ($a + 1);
    });
  })))(0);
});

const $corelib$List$map2 = (($f) => {
  const $rec = (($accum) => {
    return (($ax) => {
      return (($bx) => {
        const $$try1 = ({
          first: $ax,
          second: $bx,
        });
        return (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Cons"))
          ? ((() => {
            const $ahead = ($$try1.first)[1];
            const $atail = ($$try1.first)[2];
            const $bhead = ($$try1.second)[1];
            const $btail = ($$try1.second)[2];
            return ((($rec)(((sp_cons)($accum))((($f)($ahead))($bhead))))($atail))($btail);
          }))()
          : (true
            ? ($corelib$List$reverse)($accum)
            : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 130:6', (sp_toHuman)($$try1))));
      });
    });
  });
  return ($rec)($core$SPCore$Nil);
});

const $corelib$List$mapFirst = (($f) => {
  return (($ls) => {
    return ((($ls)[0] === "Nil")
      ? $corelib$Maybe$Nothing
      : ((($ls)[0] === "Cons")
        ? ((() => {
          const $h = ($ls)[1];
          const $tail = ($ls)[2];
          const $r = ($f)($h);
          return (((sp_equal)($corelib$Maybe$Nothing))($r)
            ? (($corelib$List$mapFirst)($f))($tail)
            : $r);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 308:4', (sp_toHuman)($ls))));
  });
});

const $corelib$Result$map = (($f) => {
  return (($result) => {
    return ((($result)[0] === "Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($corelib$Result$Err)($e);
      }))()
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $a = ($result)[1];
          return ($corelib$Result$Ok)(($f)($a));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 10:4', (sp_toHuman)($result))));
  });
});

const $corelib$List$mapRes = (($f) => {
  return (($list) => {
    const $fun = (($a) => {
      return (($acc) => {
        return (($corelib$Result$map)((($b) => {
          return ((sp_cons)($acc))($b);
        })))(($f)($a));
      });
    });
    return (($corelib$Result$map)($corelib$List$reverse))(((($corelib$List$foldlRes)($fun))($list))($core$SPCore$Nil));
  });
});

const $corelib$List$member = (($a) => {
  return (($list) => {
    return ((($list)[0] === "Nil")
      ? false
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return (((sp_equal)($h))($a)
            ? true
            : (($corelib$List$member)($a))($t));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 35:4', (sp_toHuman)($list))));
  });
});

const $corelib$List$minimum = (($list) => {
  return ((($list)[0] === "Cons")
    ? ((() => {
      const $x = ($list)[1];
      const $xs = ($list)[2];
      return ($corelib$Maybe$Just)(((($corelib$List$for)($xs))($corelib$Basics$min))($x));
    }))()
    : (true
      ? $corelib$Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 359:4', (sp_toHuman)($list))));
});

const $corelib$List$repeat = (($n) => {
  return (($a) => {
    const $rec = (($c) => {
      return (($acc) => {
        return (($c > 0)
          ? (($rec)(($c - 1)))(((sp_cons)($acc))($a))
          : $acc);
      });
    });
    return (($rec)($n))($core$SPCore$Nil);
  });
});

const $corelib$List$sort = (list_sortBy)($corelib$Basics$identity);

const $corelib$List$takeReverse = (($n) => {
  return (($list) => {
    return (($kept) => {
      return (($n < 1)
        ? $kept
        : ((($list)[0] === "Nil")
          ? $kept
          : ((($list)[0] === "Cons")
            ? ((() => {
              const $x = ($list)[1];
              const $xs = ($list)[2];
              return ((($corelib$List$takeReverse)(($n - 1)))($xs))((($core$SPCore$Cons)($x))($kept));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 263:4', (sp_toHuman)($list)))));
    });
  });
});

const $corelib$List$takeTailRec = (($n) => {
  return (($list) => {
    return ($corelib$List$reverse)(((($corelib$List$takeReverse)($n))($list))($core$SPCore$Nil));
  });
});

const $corelib$List$takeFast = (($ctr) => {
  return (($n) => {
    return (($list) => {
      return (($n < 1)
        ? $core$SPCore$Nil
        : ((() => {
          const $$try1 = ({
            first: $n,
            second: $list,
          });
          return ((($$try1.second)[0] === "Nil")
            ? $list
            : (((1 === $$try1.first) && (($$try1.second)[0] === "Cons"))
              ? ((() => {
                const $x = ($$try1.second)[1];
                return (($core$SPCore$Cons)($x))($core$SPCore$Nil);
              }))()
              : (((2 === $$try1.first) && ((($$try1.second)[0] === "Cons") && ((($$try1.second)[2])[0] === "Cons")))
                ? ((() => {
                  const $x = ($$try1.second)[1];
                  const $y = (($$try1.second)[2])[1];
                  return (($core$SPCore$Cons)($x))((($core$SPCore$Cons)($y))($core$SPCore$Nil));
                }))()
                : (((3 === $$try1.first) && ((($$try1.second)[0] === "Cons") && (((($$try1.second)[2])[0] === "Cons") && (((($$try1.second)[2])[2])[0] === "Cons"))))
                  ? ((() => {
                    const $x = ($$try1.second)[1];
                    const $y = (($$try1.second)[2])[1];
                    const $z = ((($$try1.second)[2])[2])[1];
                    return (($core$SPCore$Cons)($x))((($core$SPCore$Cons)($y))((($core$SPCore$Cons)($z))($core$SPCore$Nil)));
                  }))()
                  : (((($$try1.second)[0] === "Cons") && (((($$try1.second)[2])[0] === "Cons") && ((((($$try1.second)[2])[2])[0] === "Cons") && ((((($$try1.second)[2])[2])[2])[0] === "Cons"))))
                    ? ((() => {
                      const $x = ($$try1.second)[1];
                      const $y = (($$try1.second)[2])[1];
                      const $z = ((($$try1.second)[2])[2])[1];
                      const $w = (((($$try1.second)[2])[2])[2])[1];
                      const $tl = (((($$try1.second)[2])[2])[2])[2];
                      const $cons = $core$SPCore$Cons;
                      return (($ctr > 1000)
                        ? (($cons)($x))((($cons)($y))((($cons)($z))((($cons)($w))((($corelib$List$takeTailRec)(($n - 4)))($tl)))))
                        : (($cons)($x))((($cons)($y))((($cons)($z))((($cons)($w))(((($corelib$List$takeFast)(($ctr + 1)))(($n - 4)))($tl))))));
                    }))()
                    : (true
                      ? $list
                      : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 229:4', (sp_toHuman)($$try1))))))));
        }))());
    });
  });
});

const $corelib$List$take = ($corelib$List$takeFast)(0);

const $corelib$List$takeWhile = (($test) => {
  const $rec = (($accum) => {
    return (($list) => {
      return ((($list)[0] === "Nil")
        ? ($corelib$List$reverse)($accum)
        : ((($list)[0] === "Cons")
          ? ((() => {
            const $head = ($list)[1];
            const $tail = ($list)[2];
            return (($test)($head)
              ? (($rec)(((sp_cons)($accum))($head)))($tail)
              : ($corelib$List$reverse)($accum));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 276:6', (sp_toHuman)($list))));
    });
  });
  return ($rec)($core$SPCore$Nil);
});

const $corelib$List_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$List_Test$concat = (($sp$Test$Group)("concat"))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("concats two lists"))((() => {
  return ($corelib$List$concat)((($core$SPCore$Cons)((($core$SPCore$Cons)(1))((($core$SPCore$Cons)(2))($core$SPCore$Nil))))((($core$SPCore$Cons)((($core$SPCore$Cons)(3))((($core$SPCore$Cons)(4))($core$SPCore$Nil))))($core$SPCore$Nil)));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(1))((($core$SPCore$Cons)(2))((($core$SPCore$Cons)(3))((($core$SPCore$Cons)(4))($core$SPCore$Nil))))))))($core$SPCore$Nil));

const $corelib$List_Test$sortBy = (($sp$Test$Group)("sortBy"))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Can actually sort stuff"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(($corelib$Maybe$Just)(23)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))((($core$SPCore$Cons)(($corelib$Maybe$Just)(11)))($core$SPCore$Nil))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(($corelib$Maybe$Just)(11)))((($core$SPCore$Cons)(($corelib$Maybe$Just)(23)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Correctly orders tuple-2"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(({
    first: 23,
    second: 1,
  })))((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 11,
    second: 3,
  })))($core$SPCore$Nil))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 11,
  second: 3,
})))((($core$SPCore$Cons)(({
  first: 23,
  second: 1,
})))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Correctly orders tuple-3"))((() => {
  return ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(({
    first: "z",
    second: "a",
    third: "2",
  })))((($core$SPCore$Cons)(({
    first: "a",
    second: "b",
    third: "33",
  })))((($core$SPCore$Cons)(({
    first: "z",
    second: "a",
    third: "1",
  })))((($core$SPCore$Cons)(({
    first: "z",
    second: "b",
    third: "3",
  })))($core$SPCore$Nil)))));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: "a",
  second: "b",
  third: "33",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "1",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "2",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "b",
  third: "3",
})))($core$SPCore$Nil))))))))($core$SPCore$Nil))));

const $corelib$List_Test$tests = (($sp$Test$Group)("SPCore/List"))((($core$SPCore$Cons)($corelib$List_Test$sortBy))((($core$SPCore$Cons)($corelib$List_Test$concat))($core$SPCore$Nil)));

const $corelib$Maybe$andThen = (($f) => {
  return (($ma) => {
    return ((($ma)[0] === "Nothing")
      ? $corelib$Maybe$Nothing
      : ((($ma)[0] === "Just")
        ? ((() => {
          const $a = ($ma)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 9:4', (sp_toHuman)($ma))));
  });
});

const $corelib$Maybe$map = (($f) => {
  return (($m) => {
    return ((($m)[0] === "Nothing")
      ? $corelib$Maybe$Nothing
      : ((($m)[0] === "Just")
        ? ((() => {
          const $v = ($m)[1];
          return ($corelib$Maybe$Just)(($f)($v));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 16:2', (sp_toHuman)($m))));
  });
});

const $corelib$Maybe$map2 = (($f) => {
  return (($ma) => {
    return (($mb) => {
      return (($corelib$Maybe$andThen)((($a) => {
        return (($corelib$Maybe$andThen)((($b) => {
          return ($corelib$Maybe$Just)((($f)($a))($b));
        })))($mb);
      })))($ma);
    });
  });
});

const $corelib$Maybe$map3 = (($f) => {
  return (($ma) => {
    return (($mb) => {
      return (($mc) => {
        return (($corelib$Maybe$andThen)((($a) => {
          return (($corelib$Maybe$andThen)((($b) => {
            return (($corelib$Maybe$andThen)((($c) => {
              return ($corelib$Maybe$Just)(((($f)($a))($b))($c));
            })))($mc);
          })))($mb);
        })))($ma);
      });
    });
  });
});

const $corelib$Maybe$mapRes = (($f) => {
  return (($m) => {
    return ((($m)[0] === "Nothing")
      ? ($corelib$Result$Ok)($corelib$Maybe$Nothing)
      : ((($m)[0] === "Just")
        ? ((() => {
          const $a = ($m)[1];
          return (($corelib$Result$map)($corelib$Maybe$Just))(($f)($a));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 38:4', (sp_toHuman)($m))));
  });
});

const $corelib$Maybe$withDefault = (($default) => {
  return (($maybe) => {
    return ((($maybe)[0] === "Just")
      ? ((() => {
        const $v = ($maybe)[1];
        return $v;
      }))()
      : ((($maybe)[0] === "Nothing")
        ? $default
        : (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 48:2', (sp_toHuman)($maybe))));
  });
});

const $corelib$Result$fromMaybe = (($err) => {
  return (($maybe) => {
    return ((($maybe)[0] === "Nothing")
      ? ($corelib$Result$Err)($err)
      : ((($maybe)[0] === "Just")
        ? ((() => {
          const $a = ($maybe)[1];
          return ($corelib$Result$Ok)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 34:4', (sp_toHuman)($maybe))));
  });
});

const $corelib$Result$mapError = (($f) => {
  return (($result) => {
    return ((($result)[0] === "Ok")
      ? ((() => {
        const $a = ($result)[1];
        return ($corelib$Result$Ok)($a);
      }))()
      : ((($result)[0] === "Err")
        ? ((() => {
          const $e1 = ($result)[1];
          return ($corelib$Result$Err)(($f)($e1));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 26:4', (sp_toHuman)($result))));
  });
});

const $corelib$Result$withDefault = (($default) => {
  return (($result) => {
    return ((($result)[0] === "Ok")
      ? ((() => {
        const $a = ($result)[1];
        return $a;
      }))()
      : ((($result)[0] === "Err")
        ? $default
        : (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 42:4', (sp_toHuman)($result))));
  });
});

const $corelib$Set$diff = $corelib$Dict$diff;

const $corelib$Set$empty = $corelib$Dict$empty;

const $corelib$Set$insert = (($a) => {
  return (($corelib$Dict$insert)($a))(null);
});

const $corelib$Set$fromList = (($list) => {
  return ((($corelib$List$for)($list))($corelib$Set$insert))($corelib$Set$empty);
});

const $corelib$Set$intersect = $corelib$Dict$intersect;

const $corelib$Set$isEmpty = $corelib$Dict$isEmpty;

const $corelib$Set$join = $corelib$Dict$join;

const $corelib$Set$map = (($f) => {
  return (($set) => {
    return ((($corelib$Dict$for)($set))((($k) => {
      return (() => {
        return (($corelib$Dict$insert)(($f)($k)))(null);
      });
    })))($corelib$Dict$empty);
  });
});

const $corelib$Set$member = $corelib$Dict$member;

const $corelib$Set$remove = $corelib$Dict$remove;

const $corelib$Set$singleton = (($a) => {
  return (($corelib$Dict$singleton)($a))(null);
});

const $corelib$Set$size = $corelib$Dict$size;

const $corelib$Set$toList = $corelib$Dict$keys;

const $corelib$Text$contains = (($sub) => {
  return (($str) => {
    const $$try1 = ((text_split)($sub))($str);
    return (((($$try1)[0] === "Cons") && ((($$try1)[2])[0] === "Nil"))
      ? false
      : (true
        ? true
        : (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 115:4', (sp_toHuman)($$try1))));
  });
});

const $corelib$Text$dropRight = (($n) => {
  return (($s) => {
    return (($n > 0)
      ? (((text_slice)(0))((0 - $n)))($s)
      : $s);
  });
});

const $corelib$Text$repeat = (($n) => {
  return (($s) => {
    return (($corelib$Text$join)(""))((($corelib$List$repeat)($n))($s));
  });
});

const $corelib$Text$padLeft = (($minLength) => {
  return (($pad) => {
    return (($s) => {
      const $textLength = (text_length)($s);
      return (($textLength < $minLength)
        ? ((() => {
          const $times = ((sp_divide)((text_length)($pad)))(($textLength - $minLength));
          return ((($corelib$Text$repeat)($times))($pad) + $s);
        }))()
        : $s);
    });
  });
});

const $corelib$Text$padRight = (($minLength) => {
  return (($pad) => {
    return (($s) => {
      const $textLength = (text_length)($s);
      return (($textLength < $minLength)
        ? ((() => {
          const $times = ((sp_divide)((text_length)($pad)))(($textLength - $minLength));
          return ($s + (($corelib$Text$repeat)($times))($pad));
        }))()
        : $s);
    });
  });
});

const $corelib$Text$replace = (($toRemove) => {
  return (($toPut) => {
    return (($s) => {
      return (($corelib$Text$join)($toPut))(((text_split)($toRemove))($s));
    });
  });
});

const $corelib$Tuple$mapBoth = (($fa) => {
  return (($fb) => {
    return (($t) => {
      return ({
        first: ($fa)($t.first),
        second: ($fb)($t.second),
      });
    });
  });
});

const $corelib$Tuple$mapFirst = (($f) => {
  return (($t) => {
    return ({
      first: ($f)($t.first),
      second: $t.second,
    });
  });
});

const $corelib$Tuple$mapSecond = (($f) => {
  return (($t) => {
    return ({
      first: $t.first,
      second: ($f)($t.second),
    });
  });
});

const $corelib$Tuple$pair = (($a) => {
  return (($b) => {
    return ({
      first: $a,
      second: $b,
    });
  });
});

const $platforms$posix$IO$_run = (($never) => {
  return (($r) => {
    const $$neverToResult = $r;
    const $neverToResult = ($$neverToResult)[1];
    return ($neverToResult)($never);
  });
});

const $platforms$posix$IO$fail = (($message) => {
  return ($platforms$posix$IO$IO)((($never) => {
    return ($corelib$Result$Err)($message);
  }));
});

const $platforms$posix$IO$onResult = (($f) => {
  return (($m) => {
    return ($platforms$posix$IO$IO)((($never) => {
      return (($platforms$posix$IO$_run)($never))(($f)((($platforms$posix$IO$_run)($never))($m)));
    }));
  });
});

const $platforms$posix$IO$onSuccess = (($f) => {
  return (($m) => {
    return ($platforms$posix$IO$IO)((($never) => {
      const $$try1 = (($platforms$posix$IO$_run)($never))($m);
      return ((($$try1)[0] === "Ok")
        ? ((() => {
          const $a = ($$try1)[1];
          return (($platforms$posix$IO$_run)($never))(($f)($a));
        }))()
        : ((($$try1)[0] === "Err")
          ? ((() => {
            const $e = ($$try1)[1];
            return ($corelib$Result$Err)($e);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'platforms/posix/IO.sp 40:8', (sp_toHuman)($$try1))));
    }));
  });
});

const $platforms$posix$IO$succeed = (($a) => {
  return ($platforms$posix$IO$IO)((($never) => {
    return ($corelib$Result$Ok)($a);
  }));
});

const $sp$Compiler$CanonicalToJs$listCons = "Cons";

const $sp$Compiler$CanonicalToJs$listNil = "Nil";

const $sp$Compiler$CanonicalToJs$nativeDefinitions = ("#!/usr/bin/env node\n\n//Error.stackTraceLimit = 100;\n\n\nconst { performance } = require('perf_hooks');\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n/*  HACK\n\n    TODO this is super brittle\n    once we have a proper Platform system in place, the platform can probably\n    use its internal Meta to figure out the proper constructor\n\n*/\nconst maybe_nothing = [ \"Nothing\" ];\nconst maybe_just = (a) => [ \"Just\", a ];\n\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a) => (b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i])(b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k])(b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a) => (b) => {\n  return !sp_equal(a)(b);\n}\n\n\nconst sp_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = sp_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = sp_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (right) => (left) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\nconst basics_modBy = (a) => (b) => b % a;\n\nconst basics_compare = (a) => (b) => sp_compare(a, b);\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message) => (thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\nprocess.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.info(\"\");\n        console.info(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.info(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst sp_toHuman = (a) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a) || sp_toHumanAsUnion(a);\n\n  if (typeof a === 'function') {\n    return '<function>';\n  }\n\n  if (typeof a === 'object') {\n    let x = [];\n    for (let i in a) x.push(i + ' = ' + sp_toHuman(a[i]));\n    return '{' + x.join(', ') + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a) => {\n  return a[0] + ' ' + a.slice(1).map(arg => '(' + sp_toHuman(arg) + ')').join(' ');\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list) => {\n  if (list[0] === '" + ($sp$Compiler$CanonicalToJs$listCons + ("') {\n    arrayAccum.push(sp_toHuman(list[1]));\n    return sp_toHumanAsList(arrayAccum, list[2]);\n  }\n\n  if (list[0] === '" + ($sp$Compiler$CanonicalToJs$listNil + ("')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ? maybe_nothing : maybe_just(n);\n}\n\nconst text_split = (separator) => (target) => array_toList(target.split(separator));\n\nconst text_length = (s) => s.length;\n\nconst text_slice = (start) => (end) => (s) => s.slice(start, end);\n\nconst text_startsWith = (sub) => (s) => s.startsWith(sub);\n\nconst text_startsWithRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp('^' + regex);\n  } catch (e) {\n    return () => \"\"\n  }\n\n  return (s) => {\n    let m = s.match(re);\n    return m ? m[0] : \"\";\n  }\n}\n\nconst text_replaceRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp(regex, 'g');\n  } catch (e) {\n    return () => () => \"\"\n  }\n\n  return (replacer) => (s) => s.replace(re, replacer);\n}\n\nconst text_trimLeft = (s) => {\n  return s.trimLeft();\n}\n\nconst text_dropLeft = (n) => (s) => {\n  return s.slice(n);\n}\n\nconst text_forEach = (s) => (f) => {\n  for (let i of s) f(i);\n  return null;\n}\n\n\n//\n// Hashes\n//\n\nconst hash_empty = {};\n\n\nconst hash_insert = (hash) => (key) => (value) => {\n    const h = hash.obj[hash.attr];\n    h[JSON.stringify(key)] = [key, value];\n    return null;\n}\n\n\nconst hash_remove = (hash) => (key) => {\n    const h = hash.obj[hash.attr];\n    delete h[JSON.stringify(key)];\n    return null;\n}\n\n\nconst hash_get = (hash) => (key) => {\n    const r = hash[JSON.stringify(key)];\n    return r === undefined ? maybe_nothing : maybe_just(r[1]);\n}\n\n\nconst hash_for = (hash) => (f) => (acc) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        acc = f(kv[0])(kv[1])(acc);\n    }\n    return acc;\n}\n\n\nconst hash_each = (hash) => (f) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        f(kv[0])(kv[1]);\n    }\n    return null;\n}\n\n\n//\n// Arrays\n//\n\nconst array_push = (array) => (item) => {\n    array.obj[array.attr].push(item);\n    return null;\n}\n\nconst array_pop = (array) => {\n    const a = array.obj[array.attr];\n    return a.length ? maybe_just(a.pop()) : maybe_nothing;\n}\n\nconst array_get = (array) => (index) => {\n    const r = array[index];\n    return r === undefined ? maybe_nothing : maybe_just(r);\n}\n\nconst array_set = (array) => (index) => (item) => {\n    if (index < 0) return false;\n    const a = array.obj[array.attr];\n    if (index >= a.length) return false;\n    a[index] = item;\n    return true;\n}\n\nconst array_sortBy = (array) => (f) => {\n    const arr = array.obj[array.attr];\n    arr.sort((a, b) => sp_compare(f(a), f(b)));\n    return null;\n}\n\nconst array_toList = (array) => {\n  let length = array.length;\n  let list = [ '" + ($sp$Compiler$CanonicalToJs$listNil + ("' ];\n  for (let i = length - 1; i >= 0; i--) {\n      list = [ '" + ($sp$Compiler$CanonicalToJs$listCons + ("', array[i], list ];\n  }\n  return list;\n}\n\nconst array_fromList = (list) => {\n  const array = [];\n  const rec = (ls) => {\n    if (ls[0] === '" + ($sp$Compiler$CanonicalToJs$listNil + ("')\n      return array;\n\n    array.push(ls[1]);\n    return rec(ls[2]);\n  };\n\n  return rec(list);\n}\n\n\n\n//\n// Lists\n//\n\n\nconst sp_cons = (list) => (item) => {\n  return [ '" + ($sp$Compiler$CanonicalToJs$listCons + "', item, list];\n}\n\nconst list_sortBy = (f) => (list) => array_toList(array_fromList(list).sort((a, b) => sp_compare(f(a), f(b))));\n\n\n//\n// Platform: IO\n//\nconst fs = require('fs');\n\nconst io_wrap = (f) => [ \"IO.IO\", f ];\n\nconst io_parallel = (iosAsList) => io_wrap((never) => {\n    // as [IO a]: IO [a]\n\n    const ios = array_fromList(iosAsList);\n\n    // TODO actually run them in parallel!\n\n    let arr = [];\n    for (let io of ios) {\n        const r = io[1](never);\n        if (r[0] === \"Ok\")\n            arr.push(r[1]);\n        else\n            return $corelib$Result$Err(r[1]);\n    }\n\n    return $corelib$Result$Ok(array_toList(arr));\n});\n\n\nconst io_readDir = (dirPath) => io_wrap((never) => {\n    // as Text: IO [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(array_toList(entries.map((dirent) => ({\n        first: dirent.isDirectory(),\n        second: dirent.name,\n    }))));\n});\n\n\nconst io_readFile = (path) => io_wrap((never) => {\n    // as Text: IO Text\n\n    var content;\n    try {\n        content = fs.readFileSync(path, 'utf8');\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(content);\n});\n\n\nconst io_writeFile = (path) => (content) => io_wrap((never) => {\n    // as Text: Text: IO None\n\n    try {\n        fs.writeFileSync(path, content);\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(null);\n});\n\n\nconst io_writeStdout = (content) => io_wrap((never) => {\n    // as Text: IO None\n\n    console.info(content);\n    return $corelib$Result$Ok(null);\n});\n\n    "))))))))))));

const $sp$Compiler$EmittableToJs$constructorArgumentName = (($i) => {
  return ("$" + (text_fromNumber)($i));
});

const $sp$Compiler$EmittableToJs$literalString = (($str) => {
  const $escaped = ((($corelib$Text$replace)("\""))("\\\""))(((($corelib$Text$replace)("\n"))("\\n"))($str));
  return ($sp$Types$JavascriptAst$Literal)(("\"" + ($escaped + "\"")));
});

const $sp$Compiler$MakeEmittable$translateSource = (($src) => {
  return ((($src)[0] === "Core")
    ? "core"
    : ((($src)[0] === "SourceDir")
      ? ((() => {
        const $path = ($src)[1];
        return (((sp_equal)(""))(((text_startsWithRegex)("[a-zA-Z0-9_./]*$"))($path))
          ? (sp_todo)(("Invalid chars in source dir name: " + $path))
          : ((($corelib$Text$replace)("/"))("$"))(((($corelib$Text$replace)("."))("_"))($path)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 45:4', (sp_toHuman)($src))));
});

const $sp$Compiler$MakeEmittable$makeTextUsr = (($umr) => {
  return (($$name) => {
    const $name = ($$name)[1];
    const $$modulePath = $umr;
    const $modulePath = ($$modulePath)[2];
    const $source = ($$modulePath)[1];
    return ("$" + (($sp$Compiler$MakeEmittable$translateSource)($source) + ("$" + (((($corelib$Text$replace)("/"))("$"))($modulePath) + $name))));
  });
});

const $sp$Compiler$MakeEmittable$userSpecifiedName = (($name) => {
  return ($sp$Compiler$MakeEmittable$DollarName)(("$" + $name));
});

const $sp$Compiler$MakeEmittable$translateUsr = (($usr) => {
  const $$name = $usr;
  const $name = ($$name)[2];
  const $umr = ($$name)[1];
  return (($sp$Compiler$MakeEmittable$makeTextUsr)($umr))(($sp$Compiler$MakeEmittable$userSpecifiedName)($name));
});

const $sp$Compiler$EmittableToJs$translateConstructor = (($$caCons) => {
  const $usr = $$caCons.first;
  const $caCons = $$caCons.second;
  const $$slug = $usr;
  const $slug = ($$slug)[2];
  const $umr = ($$slug)[1];
  const $usrAsText = ($sp$Compiler$MakeEmittable$translateUsr)($usr);
  const $argNames = (($corelib$List$indexedMap)((($index) => {
    return (($name) => {
      return ($sp$Compiler$EmittableToJs$constructorArgumentName)(($index + 1));
    });
  })))($caCons.args);
  const $arrayHead = ($sp$Compiler$EmittableToJs$literalString)($slug);
  const $arrayTail = (($corelib$List$map)($sp$Types$JavascriptAst$Var))($argNames);
  const $array = ($sp$Types$JavascriptAst$Array)(((sp_cons)($arrayTail))($arrayHead));
  return (($sp$Types$JavascriptAst$Define)($usrAsText))(((($corelib$List$forReversed)($argNames))((($argName) => {
    return (($expr) => {
      return (($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)($argName))($core$SPCore$Nil)))($expr);
    });
  })))($array));
});

const $sp$Compiler$CoreTypes$umr = (($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore");

const $sp$Compiler$CoreTypes$makeUsr = ($sp$Types$Meta$USR)($sp$Compiler$CoreTypes$umr);

const $sp$Compiler$CoreTypes$false = ($sp$Compiler$CoreTypes$makeUsr)("False");

const $sp$Compiler$CoreTypes$noneName = "None";

const $sp$Compiler$CoreTypes$noneValue = ($sp$Compiler$CoreTypes$makeUsr)($sp$Compiler$CoreTypes$noneName);

const $sp$Compiler$CoreTypes$true = ($sp$Compiler$CoreTypes$makeUsr)("True");

const $sp$Compiler$EmittableToJs$accessAttrs = (($attrPath) => {
  return (($e) => {
    return ((($corelib$List$for)($attrPath))($sp$Types$JavascriptAst$AccessWithDot))($e);
  });
});

const $sp$Compiler$EmittableToJs$accessAttrsButTheLast = (($attrHead) => {
  return (($attrTail) => {
    return (($e) => {
      const $fold = (($attr) => {
        return (($$expr) => {
          const $expr = $$expr.first;
          const $last = $$expr.second;
          return ({
            first: (($sp$Types$JavascriptAst$AccessWithDot)($last))($expr),
            second: $attr,
          });
        });
      });
      return ((($corelib$List$for)($attrTail))($fold))(({
        first: $e,
        second: $attrHead,
      }));
    });
  });
});

const $sp$Compiler$EmittableToJs$accessArrayIndex = (($index) => {
  return ($sp$Types$JavascriptAst$AccessWithBrackets)(($sp$Types$JavascriptAst$Literal)((text_fromNumber)($index)));
});

const $sp$Compiler$EmittableToJs$clone = (($expr) => {
  return (($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Var)("sp_clone")))((($core$SPCore$Cons)($expr))($core$SPCore$Nil));
});

const $sp$Compiler$EmittableToJs$maybeCloneMutable = (($mutability) => {
  return (($expr) => {
    return ((($mutability)[0] === "Immutable")
      ? $expr
      : ((($mutability)[0] === "Mutable")
        ? ($sp$Compiler$EmittableToJs$clone)($expr)
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 332:4', (sp_toHuman)($mutability))));
  });
});

const $sp$Compiler$EmittableToJs$unwrapMutable = (($ja_x) => {
  return (($sp$Types$JavascriptAst$AccessWithBrackets)((($sp$Types$JavascriptAst$AccessWithDot)("attr"))($ja_x)))((($sp$Types$JavascriptAst$AccessWithDot)("obj"))($ja_x));
});

const $sp$Compiler$EmittableToJs$wrapCalls = (($env) => {
  return (($exprAndMutability) => {
    return (($baseExpr) => {
      return ((($corelib$List$for)($exprAndMutability))((($arg) => {
        return (($accum) => {
          return (($sp$Types$JavascriptAst$Call)($accum))((($core$SPCore$Cons)(((($sp$Compiler$EmittableToJs$translateArg)(({
            nativeBinop: false,
          })))($env))($arg)))($core$SPCore$Nil));
        });
      })))($baseExpr);
    });
  });
});

const $sp$Compiler$EmittableToJs$translateVariable = (($env) => {
  return (($valueName) => {
    return (($attrPath) => {
      return (($eaArgs) => {
        const $$try1 = (($corelib$Dict$get)($valueName))(($sp$Compiler$EmittableToJs$overrides)(null));
        return ((($$try1)[0] === "Just")
          ? ((() => {
            const $override = ($$try1)[1];
            return (($sp$Compiler$EmittableToJs$accessAttrs)($attrPath))((($override)($env))($eaArgs));
          }))()
          : ((($$try1)[0] === "Nothing")
            ? ((($corelib$Set$member)($valueName))($env.mutables)
              ? ($sp$Compiler$EmittableToJs$clone)((($sp$Compiler$EmittableToJs$accessAttrs)($attrPath))(($sp$Compiler$EmittableToJs$unwrapMutable)(($sp$Types$JavascriptAst$Var)($valueName))))
              : ((($sp$Compiler$EmittableToJs$wrapCalls)($env))($eaArgs))((($sp$Compiler$EmittableToJs$accessAttrs)($attrPath))(($sp$Types$JavascriptAst$Var)($valueName))))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 183:4', (sp_toHuman)($$try1))));
      });
    });
  });
});

const $sp$Compiler$EmittableToJs$wrapMutable = (($mutability) => {
  return (($expr) => {
    return ((($mutability)[0] === "Mutable")
      ? ($sp$Types$JavascriptAst$Record)(((($corelib$Dict$insert)("obj"))(($sp$Types$JavascriptAst$Record)((($corelib$Dict$singleton)("$"))($expr))))(((($corelib$Dict$insert)("attr"))(($sp$Compiler$EmittableToJs$literalString)("$")))($corelib$Dict$empty)))
      : ((($mutability)[0] === "Immutable")
        ? $expr
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 318:4', (sp_toHuman)($mutability))));
  });
});

const $sp$Compiler$Error$positionToLineAndColumn = (($s) => {
  return (($index) => {
    const $before = (((text_slice)(0))($index))($s);
    const $lines = ((text_split)("\n"))($before);
    const $lineNumber = ($corelib$List$length)($lines);
    const $colNumber = (($corelib$Maybe$withDefault)(0))((($corelib$Maybe$map)(text_length))(($corelib$List$last)($lines)));
    return ({
      col: $colNumber,
      line: $lineNumber,
    });
  });
});

const $sp$Compiler$Error$highlightSplit = (($h) => {
  return (($x) => {
    const $$lines = $x;
    const $lines = $$lines.second;
    const $words = $$lines.first;
    return ((($h)[0] === "HighlightWord")
      ? ((() => {
        const $colEnd = ($h)[1].colEnd;
        const $colStart = ($h)[1].colStart;
        const $line = ($h)[1].line;
        return ({
          first: ((($corelib$Dict$insert)($line))(({
            first: $colStart,
            second: $colEnd,
          })))($words),
          second: $lines,
        });
      }))()
      : ((($h)[0] === "HighlightBlock")
        ? ((() => {
          const $lineEnd = ($h)[1].lineEnd;
          const $lineStart = ($h)[1].lineStart;
          return ({
            first: $words,
            second: ((($corelib$List$for)((($corelib$List$range)($lineStart))($lineEnd)))($corelib$Set$insert))($lines),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 141:4', (sp_toHuman)($h))));
  });
});

const $sp$Compiler$Error$formatSeparator = "$|$|$";

const $sp$Compiler$Error$formatSuffix = "$`$`$";

const $sp$Compiler$Error$formatWrap = (($fmtName) => {
  return (($text) => {
    return ($sp$Compiler$Error$formatSeparator + ($fmtName + ($sp$Compiler$Error$formatSuffix + ($text + $sp$Compiler$Error$formatSeparator))));
  });
});

const $sp$Compiler$Error$warn = ($sp$Compiler$Error$formatWrap)("warning");

const $sp$Compiler$Error$fmtBlock = (($start) => {
  return (($highlights) => {
    return (($ls) => {
      const $$highlightedLines = ((($corelib$List$for)($highlights))($sp$Compiler$Error$highlightSplit))(({
        first: $corelib$Dict$empty,
        second: $corelib$Set$empty,
      }));
      const $highlightedLines = $$highlightedLines.second;
      const $highlightedWords = $$highlightedLines.first;
      const $pad = (text_length)((text_fromNumber)(($start + ($corelib$List$length)($ls))));
      const $wordHighlight = (($lineNumber) => {
        const $$try1 = (($corelib$Dict$get)($lineNumber))($highlightedWords);
        return ((($$try1)[0] === "Nothing")
          ? ""
          : ((($$try1)[0] === "Just")
            ? ((() => {
              const $s = ($$try1)[1].first;
              const $e = ($$try1)[1].second;
              return ("\n" + ((($corelib$Text$repeat)($pad))(" ") + ("   " + ((($corelib$Text$repeat)(($s - 1)))(" ") + ($sp$Compiler$Error$warn)((($corelib$Text$repeat)((($corelib$Basics$max)(1))(($e - $s))))("^"))))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 162:8', (sp_toHuman)($$try1))));
      });
      const $lineDem = (($lineIndex) => {
        return ((($corelib$Set$member)($lineIndex))($highlightedLines)
          ? ($sp$Compiler$Error$warn)(" > ")
          : " | ");
      });
      const $fmtLine = (($i) => {
        return (($line) => {
          const $index = ($i + $start);
          const $s = ((($corelib$Text$padLeft)($pad))(" "))((text_fromNumber)($index));
          return ($s + (($lineDem)($index) + ($line + ($wordHighlight)($index))));
        });
      });
      return ((($s) => {
        return ($s + "\n");
      }))((($corelib$Text$join)("\n"))((($corelib$List$indexedMap)($fmtLine))($ls)));
    });
  });
});

const $sp$Compiler$Error$showCodeBlock = (($code) => {
  return (($start) => {
    return (($end) => {
      return (($end.line < 0)
        ? ""
        : ((() => {
          const $highlight = (((sp_not_equal)($end.line))($start.line)
            ? ($sp$Compiler$Error$HighlightBlock)(({
              lineEnd: $end.line,
              lineStart: $start.line,
            }))
            : ($sp$Compiler$Error$HighlightWord)(({
              colEnd: $end.col,
              colStart: $start.col,
              line: $start.line,
            })));
          const $extraLines = 2;
          const $lines = ((text_split)("\n"))($code);
          const $maxLines = ($corelib$List$length)($lines);
          const $startLine = ((($corelib$Basics$clamp)(0))(($maxLines - 1)))(($start.line - ($extraLines - 1)));
          const $endLine = ((($corelib$Basics$clamp)(0))(($maxLines - 1)))(($end.line + $extraLines));
          const $size = (($corelib$Basics$max)(1))(($endLine - $startLine));
          return ((($sp$Compiler$Error$fmtBlock)(($startLine + 1)))((($core$SPCore$Cons)($highlight))($core$SPCore$Nil)))((($corelib$List$take)($size))((($corelib$List$drop)($startLine))($lines)));
        }))());
    });
  });
});

const $sp$Compiler$Error$posToHuman = (($eEnv) => {
  return (($pos) => {
    const $noBlock = (($loc) => {
      return ({
        block: "",
        location: $loc,
      });
    });
    return ((($pos)[0] === "P")
      ? ((() => {
        const $moduleName = ($pos)[1];
        const $startAsInt = ($pos)[2];
        const $endAsInt = ($pos)[3];
        const $$try2 = (($corelib$Dict$get)($moduleName))($eEnv.moduleByName);
        return ((($$try2)[0] === "Just")
          ? ((() => {
            const $mod = ($$try2)[1];
            const $start = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))($startAsInt);
            const $end = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))($endAsInt);
            return ({
              block: ((($sp$Compiler$Error$showCodeBlock)($mod.content))($start))($end),
              location: ($mod.fsPath + (" " + ((text_fromNumber)($start.line) + (":" + (text_fromNumber)($start.col))))),
            });
          }))()
          : ((($$try2)[0] === "Nothing")
            ? ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 252:12', (sp_toHuman)($$try2))));
      }))()
      : ((($pos)[0] === "End")
        ? ((() => {
          const $moduleName = ($pos)[1];
          const $$try1 = (($corelib$Dict$get)($moduleName))($eEnv.moduleByName);
          return ((($$try1)[0] === "Just")
            ? ((() => {
              const $mod = ($$try1)[1];
              const $end = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))(((text_length)($mod.content) - 1));
              const $start = ({
                col: 0,
                line: ($end.line - 8),
              });
              return ({
                block: ((($sp$Compiler$Error$showCodeBlock)($mod.content))($start))($end),
                location: ($mod.fsPath + (" " + ((text_fromNumber)($end.line) + ":0 (end of file)"))),
              });
            }))()
            : ((($$try1)[0] === "Nothing")
              ? ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")))
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 268:12', (sp_toHuman)($$try1))));
        }))()
        : ((($pos)[0] === "N")
          ? ($noBlock)("<native code>")
          : ((($pos)[0] === "S")
            ? ($noBlock)("<the location information has been stripped>")
            : ((($pos)[0] === "T")
              ? ($noBlock)("<defined in test modules>")
              : ((($pos)[0] === "I")
                ? ((() => {
                  const $n = ($pos)[1];
                  return ($noBlock)(("<inferred " + ((text_fromNumber)($n) + ">")));
                }))()
                : ((($pos)[0] === "G")
                  ? ($noBlock)("<generated>")
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 250:4', (sp_toHuman)($pos)))))))));
  });
});

const $sp$Compiler$EmittableToJs$translateExpression = (($env) => {
  return (($eaExpression) => {
    return (((($eaExpression)[0] === "Call") && (((($eaExpression)[1])[0] === "Call") && (((($eaExpression)[1])[1])[0] === "Variable")))
      ? ((() => {
        const $name = ((($eaExpression)[1])[1])[1];
        const $attrPath = ((($eaExpression)[1])[1])[2];
        const $argAndMut1 = (($eaExpression)[1])[2];
        const $argAndMut2 = ($eaExpression)[2];
        return ($sp$Compiler$EmittableToJs$Inline)((((($sp$Compiler$EmittableToJs$translateVariable)($env))($name))($attrPath))((($core$SPCore$Cons)($argAndMut1))((($core$SPCore$Cons)($argAndMut2))($core$SPCore$Nil))));
      }))()
      : (((($eaExpression)[0] === "Call") && ((($eaExpression)[1])[0] === "Variable"))
        ? ((() => {
          const $name = (($eaExpression)[1])[1];
          const $attrPath = (($eaExpression)[1])[2];
          const $argAndMut = ($eaExpression)[2];
          return ($sp$Compiler$EmittableToJs$Inline)((((($sp$Compiler$EmittableToJs$translateVariable)($env))($name))($attrPath))((($core$SPCore$Cons)($argAndMut))($core$SPCore$Nil)));
        }))()
        : ((($eaExpression)[0] === "Variable")
          ? ((() => {
            const $name = ($eaExpression)[1];
            const $attrPath = ($eaExpression)[2];
            return ($sp$Compiler$EmittableToJs$Inline)((((($sp$Compiler$EmittableToJs$translateVariable)($env))($name))($attrPath))($core$SPCore$Nil));
          }))()
          : ((($eaExpression)[0] === "Call")
            ? ((() => {
              const $ref = ($eaExpression)[1];
              const $arg = ($eaExpression)[2];
              return ($sp$Compiler$EmittableToJs$Inline)((($sp$Types$JavascriptAst$Call)((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($ref)))((($core$SPCore$Cons)(((($sp$Compiler$EmittableToJs$translateArg)(({
                nativeBinop: false,
              })))($env))($arg)))($core$SPCore$Nil)));
            }))()
            : ((($eaExpression)[0] === "LetIn")
              ? ((() => {
                const $inExpression = ($eaExpression)[1].inExpression;
                const $letExpression = ($eaExpression)[1].letExpression;
                const $maybeName = ($eaExpression)[1].maybeName;
                const $mutability = ($eaExpression)[1].mutability;
                const $localEnv = ((() => {
                  const $$try6 = ({
                    first: $maybeName,
                    second: $mutability,
                  });
                  return (((($$try6.first)[0] === "Just") && (($$try6.second)[0] === "Mutable"))
                    ? ((() => {
                      const $name = ($$try6.first)[1];
                      return (Object.assign)({}, $env, ({
                        mutables: (($corelib$Set$insert)($name))($env.mutables),
                      }));
                    }))()
                    : (true
                      ? $env
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 461:16', (sp_toHuman)($$try6))));
                }))();
                const $inStatements = ((() => {
                  const $$try5 = (($sp$Compiler$EmittableToJs$translateExpression)($localEnv))($inExpression);
                  return ((($$try5)[0] === "Block")
                    ? ((() => {
                      const $stats = ($$try5)[1];
                      return $stats;
                    }))()
                    : ((($$try5)[0] === "Inline")
                      ? ((() => {
                        const $jaExpression = ($$try5)[1];
                        return (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)($jaExpression)))($core$SPCore$Nil);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 468:16', (sp_toHuman)($$try5))));
                }))();
                return ((($maybeName)[0] === "Nothing")
                  ? ((() => {
                    const $$try4 = (($sp$Compiler$EmittableToJs$translateExpression)($env))($letExpression);
                    return ((($$try4)[0] === "Inline")
                      ? ((() => {
                        const $expr = ($$try4)[1];
                        return ($sp$Compiler$EmittableToJs$Block)(((sp_cons)($inStatements))(($sp$Types$JavascriptAst$Eval)($expr)));
                      }))()
                      : ((($$try4)[0] === "Block")
                        ? ((() => {
                          const $stats = ($$try4)[1];
                          return ($sp$Compiler$EmittableToJs$Block)(($corelib$List$concat)((($core$SPCore$Cons)($stats))((($core$SPCore$Cons)($inStatements))($core$SPCore$Nil))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 474:20', (sp_toHuman)($$try4))));
                  }))()
                  : ((($maybeName)[0] === "Just")
                    ? ((() => {
                      const $name = ($maybeName)[1];
                      const $letStatement = (($sp$Types$JavascriptAst$Define)($name))((($sp$Compiler$EmittableToJs$wrapMutable)($mutability))((($sp$Compiler$EmittableToJs$maybeCloneMutable)($mutability))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($letExpression))));
                      return ($sp$Compiler$EmittableToJs$Block)(((sp_cons)($inStatements))($letStatement));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 472:12', (sp_toHuman)($maybeName))));
              }))()
              : ((($eaExpression)[0] === "Lambda")
                ? ((() => {
                  const $maybeName = ($eaExpression)[1].first;
                  const $mutability = ($eaExpression)[1].second;
                  const $body = ($eaExpression)[2];
                  const $args = ((($maybeName)[0] === "Just")
                    ? ((() => {
                      const $name = ($maybeName)[1];
                      return (($core$SPCore$Cons)($name))($core$SPCore$Nil);
                    }))()
                    : ((($maybeName)[0] === "Nothing")
                      ? $core$SPCore$Nil
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 495:16', (sp_toHuman)($maybeName))));
                  const $localEnv = ((() => {
                    const $$try3 = ({
                      first: $maybeName,
                      second: $mutability,
                    });
                    return (((($$try3.first)[0] === "Just") && (($$try3.second)[0] === "Mutable"))
                      ? ((() => {
                        const $name = ($$try3.first)[1];
                        return (Object.assign)({}, $env, ({
                          mutables: (($corelib$Set$insert)($name))($env.mutables),
                        }));
                      }))()
                      : (true
                        ? $env
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 501:16', (sp_toHuman)($$try3))));
                  }))();
                  const $statements = ((() => {
                    const $$try2 = (($sp$Compiler$EmittableToJs$translateExpression)($localEnv))($body);
                    return ((($$try2)[0] === "Inline")
                      ? ((() => {
                        const $expr = ($$try2)[1];
                        return (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)($expr)))($core$SPCore$Nil);
                      }))()
                      : ((($$try2)[0] === "Block")
                        ? ((() => {
                          const $block = ($$try2)[1];
                          return $block;
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 508:16', (sp_toHuman)($$try2))));
                  }))();
                  return ($sp$Compiler$EmittableToJs$Inline)((($sp$Types$JavascriptAst$BlockLambda)($args))($statements));
                }))()
                : ((($eaExpression)[0] === "LiteralText")
                  ? ((() => {
                    const $string = ($eaExpression)[1];
                    return ($sp$Compiler$EmittableToJs$Inline)(($sp$Compiler$EmittableToJs$literalString)($string));
                  }))()
                  : ((($eaExpression)[0] === "LiteralNumber")
                    ? ((() => {
                      const $num = ($eaExpression)[1];
                      return ($sp$Compiler$EmittableToJs$Inline)(($sp$Types$JavascriptAst$Literal)((text_fromNumber)($num)));
                    }))()
                    : ((($eaExpression)[0] === "Conditional")
                      ? ((() => {
                        const $test = ($eaExpression)[1];
                        const $true = ($eaExpression)[2];
                        const $false = ($eaExpression)[3];
                        return ($sp$Compiler$EmittableToJs$Inline)(((($sp$Types$JavascriptAst$Conditional)((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($test)))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($true)))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($false)));
                      }))()
                      : ((($eaExpression)[0] === "And")
                        ? ((() => {
                          const $eaTests = ($eaExpression)[1];
                          const $jaTests = (($corelib$List$map)(($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env)))($eaTests);
                          const $$try1 = ($corelib$List$reverse)($jaTests);
                          return ((($$try1)[0] === "Nil")
                            ? ($sp$Compiler$EmittableToJs$Inline)(($sp$Types$JavascriptAst$Literal)("true"))
                            : ((($$try1)[0] === "Cons")
                              ? ((() => {
                                const $head = ($$try1)[1];
                                const $tail = ($$try1)[2];
                                return ($sp$Compiler$EmittableToJs$Inline)(((($corelib$List$for)($tail))((($test) => {
                                  return (($expr) => {
                                    return ((($sp$Types$JavascriptAst$Binop)("&&"))($test))($expr);
                                  });
                                })))($head));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 535:12', (sp_toHuman)($$try1))));
                        }))()
                        : ((($eaExpression)[0] === "ShallowEqual")
                          ? ((() => {
                            const $a = ($eaExpression)[1];
                            const $b = ($eaExpression)[2];
                            return ($sp$Compiler$EmittableToJs$Inline)(((($sp$Types$JavascriptAst$Binop)("==="))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($a)))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($b)));
                          }))()
                          : ((($eaExpression)[0] === "LiteralArray")
                            ? ((() => {
                              const $items = ($eaExpression)[1];
                              return ($sp$Compiler$EmittableToJs$Inline)(($sp$Types$JavascriptAst$Array)((($corelib$List$map)(($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env)))($items)));
                            }))()
                            : ((($eaExpression)[0] === "ArrayAccess")
                              ? ((() => {
                                const $index = ($eaExpression)[1];
                                const $array = ($eaExpression)[2];
                                return ($sp$Compiler$EmittableToJs$Inline)((($sp$Compiler$EmittableToJs$accessArrayIndex)($index))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($array)));
                              }))()
                              : ((($eaExpression)[0] === "Constructor")
                                ? ((() => {
                                  const $name = ($eaExpression)[1];
                                  return ($sp$Compiler$EmittableToJs$Inline)((((($sp$Compiler$EmittableToJs$translateVariable)($env))($name))($core$SPCore$Nil))($core$SPCore$Nil));
                                }))()
                                : ((($eaExpression)[0] === "ConstructorAccess")
                                  ? ((() => {
                                    const $argIndex = ($eaExpression)[1];
                                    const $value = ($eaExpression)[2];
                                    return ($sp$Compiler$EmittableToJs$Inline)((($sp$Compiler$EmittableToJs$accessArrayIndex)(($argIndex + 1)))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($value)));
                                  }))()
                                  : ((($eaExpression)[0] === "IsConstructor")
                                    ? ((() => {
                                      const $name = ($eaExpression)[1];
                                      const $eaValue = ($eaExpression)[2];
                                      const $jaValue = (($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($eaValue);
                                      const $jaExpr = (("True" === $name)
                                        ? $jaValue
                                        : (("False" === $name)
                                          ? (($sp$Types$JavascriptAst$Unop)("!"))($jaValue)
                                          : (true
                                            ? ((($sp$Types$JavascriptAst$Binop)("==="))((($sp$Compiler$EmittableToJs$accessArrayIndex)(0))($jaValue)))(($sp$Compiler$EmittableToJs$literalString)($name))
                                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 577:16', (sp_toHuman)($name)))));
                                      return ($sp$Compiler$EmittableToJs$Inline)($jaExpr);
                                    }))()
                                    : ((($eaExpression)[0] === "LiteralRecord")
                                      ? ((() => {
                                        const $maybeExtend = ($eaExpression)[1];
                                        const $attrNamesAndValues = ($eaExpression)[2];
                                        const $obj = ($sp$Types$JavascriptAst$Record)(((($corelib$List$for)($attrNamesAndValues))((($$name) => {
                                          const $name = $$name.first;
                                          const $value = $$name.second;
                                          return (($corelib$Dict$insert)($name))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($value));
                                        })))($corelib$Dict$empty));
                                        return ((($maybeExtend)[0] === "Nothing")
                                          ? ($sp$Compiler$EmittableToJs$Inline)($obj)
                                          : ((($maybeExtend)[0] === "Just")
                                            ? ((() => {
                                              const $extend = ($maybeExtend)[1];
                                              return ($sp$Compiler$EmittableToJs$Inline)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Var)("Object.assign")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Record)($corelib$Dict$empty)))((($core$SPCore$Cons)((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($extend)))((($core$SPCore$Cons)($obj))($core$SPCore$Nil)))));
                                            }))()
                                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 597:12', (sp_toHuman)($maybeExtend))));
                                      }))()
                                      : ((($eaExpression)[0] === "RecordAccess")
                                        ? ((() => {
                                          const $attrName = ($eaExpression)[1];
                                          const $value = ($eaExpression)[2];
                                          return ($sp$Compiler$EmittableToJs$Inline)((($sp$Types$JavascriptAst$AccessWithDot)($attrName))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($value)));
                                        }))()
                                        : ((($eaExpression)[0] === "MissingPattern")
                                          ? ((() => {
                                            const $pos = ($eaExpression)[1];
                                            const $value = ($eaExpression)[2];
                                            const $human = (($sp$Compiler$Error$posToHuman)($env.errorEnv))($pos);
                                            return ($sp$Compiler$EmittableToJs$Inline)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Literal)("sp_throw")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Literal)("'Missing pattern in try..as'")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Literal)(("'" + ($human.location + "'")))))((($core$SPCore$Cons)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Literal)("sp_toHuman")))((($core$SPCore$Cons)((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($value)))($core$SPCore$Nil))))($core$SPCore$Nil)))));
                                          }))()
                                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 440:4', (sp_toHuman)($eaExpression)))))))))))))))))))));
  });
});

const $sp$Compiler$EmittableToJs$translateExpressionToExpression = (($env) => {
  return (($expr) => {
    const $$try1 = (($sp$Compiler$EmittableToJs$translateExpression)($env))($expr);
    return ((($$try1)[0] === "Inline")
      ? ((() => {
        const $e = ($$try1)[1];
        return $e;
      }))()
      : ((($$try1)[0] === "Block")
        ? ((() => {
          const $block = ($$try1)[1];
          return (($sp$Types$JavascriptAst$Call)((($sp$Types$JavascriptAst$BlockLambda)($core$SPCore$Nil))($block)))($core$SPCore$Nil);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 429:4', (sp_toHuman)($$try1))));
  });
});

const $sp$Compiler$EmittableToJs$translateArg = (($stuff) => {
  return (($env) => {
    return (($$eaExpression) => {
      const $eaExpression = $$eaExpression.first;
      const $mutability = $$eaExpression.second;
      return ((($mutability)[0] === "Immutable")
        ? (($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($eaExpression)
        : ((($mutability)[0] === "Mutable")
          ? ((($eaExpression)[0] === "Variable")
            ? ((() => {
              const $name = ($eaExpression)[1];
              const $attrPath = ($eaExpression)[2];
              return ($stuff.nativeBinop
                ? (($sp$Compiler$EmittableToJs$accessAttrs)($attrPath))(($sp$Compiler$EmittableToJs$unwrapMutable)(($sp$Types$JavascriptAst$Var)($name)))
                : ((($attrPath)[0] === "Nil")
                  ? ($sp$Types$JavascriptAst$Var)($name)
                  : ((($attrPath)[0] === "Cons")
                    ? ((() => {
                      const $head = ($attrPath)[1];
                      const $tail = ($attrPath)[2];
                      return ((($$lastAttrName) => {
                        const $wrappedExpr = $$lastAttrName.first;
                        const $lastAttrName = $$lastAttrName.second;
                        return ($sp$Types$JavascriptAst$Record)(((($corelib$Dict$insert)("attr"))(($sp$Compiler$EmittableToJs$literalString)($lastAttrName)))(((($corelib$Dict$insert)("obj"))($wrappedExpr))($corelib$Dict$empty)));
                      }))(((($sp$Compiler$EmittableToJs$accessAttrsButTheLast)($head))($tail))(($sp$Compiler$EmittableToJs$unwrapMutable)(($sp$Types$JavascriptAst$Var)($name))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 248:24', (sp_toHuman)($attrPath)))));
            }))()
            : (true
              ? (sp_todo)("translateArg: this should not happen!")
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 238:12', (sp_toHuman)($eaExpression))))
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 233:4', (sp_toHuman)($mutability))));
    });
  });
});

const $sp$Compiler$EmittableToJs$binop = (($jsOp) => {
  return (($env) => {
    return (($arguments) => {
      return (((($arguments)[0] === "Cons") && (((($arguments)[2])[0] === "Cons") && (((($arguments)[2])[2])[0] === "Nil")))
        ? ((() => {
          const $right = ($arguments)[1];
          const $left = (($arguments)[2])[1];
          return ((($sp$Types$JavascriptAst$Binop)($jsOp))(((($sp$Compiler$EmittableToJs$translateArg)(({
            nativeBinop: true,
          })))($env))($left)))(((($sp$Compiler$EmittableToJs$translateArg)(({
            nativeBinop: true,
          })))($env))($right));
        }))()
        : (((($arguments)[0] === "Cons") && ((($arguments)[2])[0] === "Nil"))
          ? ((() => {
            const $right = ($arguments)[1];
            return (($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)))(((($sp$Types$JavascriptAst$Binop)($jsOp))(($sp$Types$JavascriptAst$Var)("a")))(((($sp$Compiler$EmittableToJs$translateArg)(({
              nativeBinop: true,
            })))($env))($right)));
          }))()
          : ((($arguments)[0] === "Nil")
            ? (($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)("b"))($core$SPCore$Nil)))((($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)))(((($sp$Types$JavascriptAst$Binop)($jsOp))(($sp$Types$JavascriptAst$Var)("a")))(($sp$Types$JavascriptAst$Var)("b"))))
            : (true
              ? (sp_todo)("compiler bug: wrong number of arguments for binop")
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 143:4', (sp_toHuman)($arguments))))));
    });
  });
});

const $sp$Compiler$EmittableToJs$constructor = (($jsValue) => {
  return (($env) => {
    return (($arguments) => {
      return ($sp$Types$JavascriptAst$Var)($jsValue);
    });
  });
});

const $sp$Compiler$EmittableToJs$function = (($jaName) => {
  return (($env) => {
    return (($arguments) => {
      return ((($sp$Compiler$EmittableToJs$wrapCalls)($env))($arguments))(($sp$Types$JavascriptAst$Var)($jaName));
    });
  });
});

const $sp$Compiler$EmittableToJs$unaryMinus = (($env) => {
  return (($arguments) => {
    return (((($arguments)[0] === "Cons") && ((($arguments)[2])[0] === "Nil"))
      ? ((() => {
        const $arg = ($arguments)[1];
        return (($sp$Types$JavascriptAst$Unop)("-"))(((($sp$Compiler$EmittableToJs$translateArg)(({
          nativeBinop: false,
        })))($env))($arg));
      }))()
      : ((($arguments)[0] === "Nil")
        ? (($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)("v"))($core$SPCore$Nil)))((($sp$Types$JavascriptAst$Unop)("-"))(($sp$Types$JavascriptAst$Var)("v")))
        : (true
          ? (sp_todo)("compiler bug: wrong number of arguments for binop")
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 125:4', (sp_toHuman)($arguments)))));
  });
});

const $sp$Compiler$EmittableToJs$unaryPlus = (($env) => {
  return (($arguments) => {
    return (((($arguments)[0] === "Cons") && ((($arguments)[2])[0] === "Nil"))
      ? ((() => {
        const $arg = ($arguments)[1];
        return ((($sp$Compiler$EmittableToJs$translateArg)(({
          nativeBinop: false,
        })))($env))($arg);
      }))()
      : ((($arguments)[0] === "Nil")
        ? (($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)))(($sp$Types$JavascriptAst$Var)("a"))
        : (true
          ? (sp_todo)("compiler bug: wrong number of arguments for binop")
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 109:4', (sp_toHuman)($arguments)))));
  });
});

const $sp$Compiler$CoreTypes$p = $sp$Types$Pos$N;

const $sp$Compiler$CoreTypes$defToType = (($def) => {
  return (($sp$Types$CanonicalAst$TypeConstant)($sp$Compiler$CoreTypes$p))($def.usr);
});

const $sp$Compiler$CoreTypes$numberDef = ({
  args: $core$SPCore$Nil,
  constructors: $corelib$Dict$empty,
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Number"),
});

const $sp$Compiler$CoreTypes$number = (($sp$Compiler$CoreTypes$defToType)($sp$Compiler$CoreTypes$numberDef))($core$SPCore$Nil);

const $sp$Prelude$numberUsr = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore/Number"));

const $sp$Prelude$tyFun = ($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N);

const $sp$Prelude$typeBinop = (($mutates) => {
  return (($left) => {
    return (($right) => {
      return (($return) => {
        return ((($sp$Prelude$tyFun)($right))(false))(((($sp$Prelude$tyFun)($left))($mutates))($return));
      });
    });
  });
});

const $sp$Prelude$typeBinopUniform = (($ty) => {
  return (((($sp$Prelude$typeBinop)(false))($ty))($ty))($ty);
});

const $sp$Prelude$add = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "+",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
  usr: ($sp$Prelude$numberUsr)("add"),
});

const $sp$Compiler$CoreTypes$nameToType = (($name) => {
  return (($sp$Types$CanonicalAst$TypeConstant)($sp$Compiler$CoreTypes$p))(($sp$Compiler$CoreTypes$makeUsr)($name));
});

const $sp$Compiler$CoreTypes$bool = (($sp$Compiler$CoreTypes$nameToType)("Bool"))($core$SPCore$Nil);

const $sp$Prelude$coreUsr = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore"));

const $sp$Prelude$and_ = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Logical,
  symbol: "and",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("and_"),
});

const $sp$Prelude$tyVar = ($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N);

const $sp$Prelude$compare = ({
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  type: ((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))($sp$Compiler$CoreTypes$number)),
  usr: ($sp$Prelude$coreUsr)("compare"),
});

const $sp$Compiler$CoreTypes$none = (($sp$Compiler$CoreTypes$nameToType)($sp$Compiler$CoreTypes$noneName))($core$SPCore$Nil);

const $sp$Prelude$debugUsr = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore"));

const $sp$Prelude$debugBenchStart = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$none))(false))($sp$Compiler$CoreTypes$none),
  usr: ($sp$Prelude$debugUsr)("benchStart"),
});

const $sp$Compiler$CoreTypes$textDef = ({
  args: $core$SPCore$Nil,
  constructors: $corelib$Dict$empty,
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Text"),
});

const $sp$Compiler$CoreTypes$text = (($sp$Compiler$CoreTypes$defToType)($sp$Compiler$CoreTypes$textDef))($core$SPCore$Nil);

const $sp$Prelude$debugBenchStop = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))($sp$Compiler$CoreTypes$none),
  usr: ($sp$Prelude$debugUsr)("benchStop"),
});

const $sp$Prelude$debugLog = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("a"))),
  usr: ($sp$Prelude$debugUsr)("log"),
});

const $sp$Prelude$debugToHuman = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))($sp$Compiler$CoreTypes$text),
  usr: ($sp$Prelude$debugUsr)("toHuman"),
});

const $sp$Prelude$debugTodo = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))(($sp$Prelude$tyVar)("a")),
  usr: ($sp$Prelude$debugUsr)("todo"),
});

const $sp$Prelude$divide = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Multiplicative,
  symbol: "/",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
  usr: ($sp$Prelude$numberUsr)("divide"),
});

const $sp$Prelude$equal = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "==",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("equal"),
});

const $sp$Prelude$greaterOrEqualThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: ">=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("greaterOrEqualThan"),
});

const $sp$Prelude$greaterThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: ">",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("greaterThan"),
});

const $sp$Prelude$lesserOrEqualThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "<=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("lesserOrEqualThan"),
});

const $sp$Prelude$lesserThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "<",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("lesserThan"),
});

const $sp$Compiler$CoreTypes$list = (($item) => {
  return (($sp$Compiler$CoreTypes$nameToType)("List"))((($core$SPCore$Cons)($item))($core$SPCore$Nil));
});

const $sp$Prelude$listUsr = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore/List"));

const $sp$Prelude$listCons = ((() => {
  const $item = ($sp$Prelude$tyVar)("item");
  return ({
    associativity: $sp$Types$Op$Right,
    nonFn: $core$SPCore$Nil,
    precedence: $sp$Types$Op$Cons,
    symbol: "::",
    type: (((($sp$Prelude$typeBinop)(false))($item))(($sp$Compiler$CoreTypes$list)($item)))(($sp$Compiler$CoreTypes$list)($item)),
    usr: ($sp$Prelude$listUsr)("stack"),
  });
}))();

const $sp$Prelude$multiply = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Multiplicative,
  symbol: "*",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
  usr: ($sp$Prelude$numberUsr)("multiply"),
});

const $sp$Prelude$mutableAdd = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: "+=",
  type: (((($sp$Prelude$typeBinop)(true))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$none),
  usr: ($sp$Prelude$numberUsr)("mutableAdd"),
});

const $sp$Prelude$mutableAssign = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: ":=",
  type: (((($sp$Prelude$typeBinop)(true))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$none),
  usr: ($sp$Prelude$coreUsr)("mutableAssign"),
});

const $sp$Prelude$mutableSubtract = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: "-=",
  type: (((($sp$Prelude$typeBinop)(true))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$none),
  usr: ($sp$Prelude$numberUsr)("mutableSubtract"),
});

const $sp$Prelude$notEqual = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "/=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("notEqual"),
});

const $sp$Prelude$or_ = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Logical,
  symbol: "or",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$bool),
  usr: ($sp$Prelude$coreUsr)("or_"),
});

const $sp$Prelude$subtract = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "-",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
  usr: ($sp$Prelude$numberUsr)("subtract"),
});

const $sp$Prelude$textUsr = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore/Text"));

const $sp$Prelude$textConcat = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "..",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$text),
  usr: ($sp$Prelude$textUsr)("concat"),
});

const $sp$Prelude$typeUnopUniform = (($type) => {
  return ((($sp$Prelude$tyFun)($type))(false))($type);
});

const $sp$Prelude$unaryMinus = ({
  symbol: "0 -",
  type: ($sp$Prelude$typeUnopUniform)($sp$Compiler$CoreTypes$number),
  usr: ($sp$Prelude$numberUsr)("unaryMinus"),
});

const $sp$Prelude$unaryPlus = ({
  symbol: "0 +",
  type: ($sp$Prelude$typeUnopUniform)($sp$Compiler$CoreTypes$number),
  usr: ($sp$Prelude$numberUsr)("unaryPlus"),
});

const $sp$Compiler$EmittableToJs$overrides = (() => {
  const $corelib = (($m) => {
    return (($n) => {
      return (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("corelib")))($m)))($n);
    });
  });
  const $ioModule = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("platforms/posix")))("IO"));
  return (($corelib$Dict$mapKeys)($sp$Compiler$MakeEmittable$translateUsr))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: $sp$Prelude$unaryPlus.usr,
    second: $sp$Compiler$EmittableToJs$unaryPlus,
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$unaryMinus.usr,
    second: $sp$Compiler$EmittableToJs$unaryMinus,
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$add.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("+"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$multiply.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("*"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$subtract.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("-"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$mutableAssign.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("="),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$mutableAdd.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("+="),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$mutableSubtract.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("-="),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$textConcat.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("+"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$greaterThan.usr,
    second: ($sp$Compiler$EmittableToJs$binop)(">"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$lesserThan.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("<"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$greaterOrEqualThan.usr,
    second: ($sp$Compiler$EmittableToJs$binop)(">="),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$lesserOrEqualThan.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("<="),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$or_.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("||"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$and_.usr,
    second: ($sp$Compiler$EmittableToJs$binop)("&&"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Compiler$CoreTypes$true,
    second: ($sp$Compiler$EmittableToJs$constructor)("true"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Compiler$CoreTypes$false,
    second: ($sp$Compiler$EmittableToJs$constructor)("false"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Compiler$CoreTypes$noneValue,
    second: ($sp$Compiler$EmittableToJs$constructor)("null"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$divide.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_divide"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$listCons.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_cons"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$equal.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_equal"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$notEqual.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_not_equal"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Basics"))("modBy"),
    second: ($sp$Compiler$EmittableToJs$function)("basics_modBy"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$debugLog.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_log"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$debugTodo.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_todo"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$debugToHuman.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_toHuman"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$debugBenchStart.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_benchStart"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$debugBenchStop.usr,
    second: ($sp$Compiler$EmittableToJs$function)("sp_benchStop"),
  })))((($core$SPCore$Cons)(({
    first: $sp$Prelude$compare.usr,
    second: ($sp$Compiler$EmittableToJs$function)("basics_compare"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("fromNumber"),
    second: ($sp$Compiler$EmittableToJs$function)("text_fromNumber"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("toNumber"),
    second: ($sp$Compiler$EmittableToJs$function)("text_toNumber"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("split"),
    second: ($sp$Compiler$EmittableToJs$function)("text_split"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("length"),
    second: ($sp$Compiler$EmittableToJs$function)("text_length"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("slice"),
    second: ($sp$Compiler$EmittableToJs$function)("text_slice"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("startsWith"),
    second: ($sp$Compiler$EmittableToJs$function)("text_startsWith"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("startsWithRegex"),
    second: ($sp$Compiler$EmittableToJs$function)("text_startsWithRegex"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("replaceRegex"),
    second: ($sp$Compiler$EmittableToJs$function)("text_replaceRegex"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("trimLeft"),
    second: ($sp$Compiler$EmittableToJs$function)("text_trimLeft"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("dropLeft"),
    second: ($sp$Compiler$EmittableToJs$function)("text_dropLeft"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Text"))("forEach"),
    second: ($sp$Compiler$EmittableToJs$function)("text_forEach"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Hash"))("empty"),
    second: ($sp$Compiler$EmittableToJs$function)("hash_empty"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Hash"))("insert"),
    second: ($sp$Compiler$EmittableToJs$function)("hash_insert"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Hash"))("remove"),
    second: ($sp$Compiler$EmittableToJs$function)("hash_remove"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Hash"))("get"),
    second: ($sp$Compiler$EmittableToJs$function)("hash_get"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Hash"))("for"),
    second: ($sp$Compiler$EmittableToJs$function)("hash_for"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Hash"))("each"),
    second: ($sp$Compiler$EmittableToJs$function)("hash_each"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("push"),
    second: ($sp$Compiler$EmittableToJs$function)("array_push"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("pop"),
    second: ($sp$Compiler$EmittableToJs$function)("array_pop"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("get"),
    second: ($sp$Compiler$EmittableToJs$function)("array_get"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("set"),
    second: ($sp$Compiler$EmittableToJs$function)("array_set"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("sortBy"),
    second: ($sp$Compiler$EmittableToJs$function)("array_sortBy"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("fromList"),
    second: ($sp$Compiler$EmittableToJs$function)("array_fromList"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("Array"))("toList"),
    second: ($sp$Compiler$EmittableToJs$function)("array_toList"),
  })))((($core$SPCore$Cons)(({
    first: (($corelib)("List"))("sortBy"),
    second: ($sp$Compiler$EmittableToJs$function)("list_sortBy"),
  })))((($core$SPCore$Cons)(({
    first: ($ioModule)("parallel"),
    second: ($sp$Compiler$EmittableToJs$function)("io_parallel"),
  })))((($core$SPCore$Cons)(({
    first: ($ioModule)("readDir"),
    second: ($sp$Compiler$EmittableToJs$function)("io_readDir"),
  })))((($core$SPCore$Cons)(({
    first: ($ioModule)("readFile"),
    second: ($sp$Compiler$EmittableToJs$function)("io_readFile"),
  })))((($core$SPCore$Cons)(({
    first: ($ioModule)("writeFile"),
    second: ($sp$Compiler$EmittableToJs$function)("io_writeFile"),
  })))((($core$SPCore$Cons)(({
    first: ($ioModule)("writeStdout"),
    second: ($sp$Compiler$EmittableToJs$function)("io_writeStdout"),
  })))($core$SPCore$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
});

const $sp$Compiler$EmittableToJs$translateDef = (($env) => {
  return (($def) => {
    const $$try1 = (($corelib$Dict$get)($def.name))(($sp$Compiler$EmittableToJs$overrides)(null));
    return ((($$try1)[0] === "Just")
      ? $corelib$Maybe$Nothing
      : ((($$try1)[0] === "Nothing")
        ? ($corelib$Maybe$Just)((($sp$Types$JavascriptAst$Define)($def.name))((($sp$Compiler$EmittableToJs$translateExpressionToExpression)($env))($def.expr)))
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/EmittableToJs.sp 658:4', (sp_toHuman)($$try1))));
  });
});

const $sp$Compiler$EmittableToJs$translateAll = (($errorEnv) => {
  return (($caConstructors) => {
    return (($eaDefs) => {
      const $jaConstructors = (($corelib$List$map)($sp$Compiler$EmittableToJs$translateConstructor))($caConstructors);
      const $env = ({
        errorEnv: $errorEnv,
        mutables: $corelib$Set$empty,
        tryCounter: 0,
      });
      const $jaStatements = (($corelib$List$filterMap)(($sp$Compiler$EmittableToJs$translateDef)($env)))($eaDefs);
      return ($corelib$List$concat)((($core$SPCore$Cons)($jaConstructors))((($core$SPCore$Cons)($jaStatements))($core$SPCore$Nil)));
    });
  });
});

const $sp$Compiler$JsToText$id = (($level) => {
  return (($corelib$Text$repeat)($level))("  ");
});

const $sp$Compiler$JsToText$emitBlock = (($l) => {
  return (($block) => {
    const $lines = (($corelib$Text$join)("\n"))((($corelib$List$map)(($sp$Compiler$JsToText$emitStatement)(($l + 1))))($block));
    return ("{\n" + ($lines + ("\n" + (($sp$Compiler$JsToText$id)($l) + "}"))));
  });
});

const $sp$Compiler$JsToText$emitExpr = (($l) => {
  return (($expression) => {
    return ((($expression)[0] === "Literal")
      ? ((() => {
        const $s = ($expression)[1];
        return $s;
      }))()
      : ((($expression)[0] === "Var")
        ? ((() => {
          const $n = ($expression)[1];
          return $n;
        }))()
        : ((($expression)[0] === "Call")
          ? ((() => {
            const $ref = ($expression)[1];
            const $args = ($expression)[2];
            return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($ref) + (")(" + ((($corelib$Text$join)(", "))((($corelib$List$map)(($sp$Compiler$JsToText$emitExpr)($l)))($args)) + ")"))));
          }))()
          : ((($expression)[0] === "Unop")
            ? ((() => {
              const $op = ($expression)[1];
              const $left = ($expression)[2];
              return ($op + ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + ")")));
            }))()
            : ((($expression)[0] === "Binop")
              ? ((() => {
                const $op = ($expression)[1];
                const $left = ($expression)[2];
                const $right = ($expression)[3];
                return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + (" " + ($op + (" " + ((($sp$Compiler$JsToText$emitExpr)($l))($right) + ")"))))));
              }))()
              : ((($expression)[0] === "Mutop")
                ? ((() => {
                  const $op = ($expression)[1];
                  const $yield = ($expression)[2];
                  const $left = ($expression)[3];
                  const $right = ($expression)[4];
                  return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + (" " + ($op + (" " + ((($sp$Compiler$JsToText$emitExpr)($l))($right) + (", " + ($yield + ")"))))))));
                }))()
                : ((($expression)[0] === "SimpleLambda")
                  ? ((() => {
                    const $params = ($expression)[1];
                    const $expr = ($expression)[2];
                    return ("((" + ((($corelib$Text$join)(", "))($params) + (") => " + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + ")"))));
                  }))()
                  : ((($expression)[0] === "BlockLambda")
                    ? ((() => {
                      const $params = ($expression)[1];
                      const $stats = ($expression)[2];
                      return ("((" + ((($corelib$Text$join)(", "))($params) + (") => " + ((($sp$Compiler$JsToText$emitBlock)($l))($stats) + ")"))));
                    }))()
                    : ((($expression)[0] === "Record")
                      ? ((() => {
                        const $attrs = ($expression)[1];
                        return (((sp_equal)($corelib$Dict$empty))($attrs)
                          ? "{}"
                          : ((($a) => {
                            return ("({\n" + ((($corelib$Text$join)("\n"))($a) + ("\n" + (($sp$Compiler$JsToText$id)($l) + "})"))));
                          }))((($corelib$List$map)((($$key) => {
                            const $key = $$key.first;
                            const $value = $$key.second;
                            return (($sp$Compiler$JsToText$id)(($l + 1)) + ($key + (": " + ((($sp$Compiler$JsToText$emitExpr)(($l + 1)))($value) + ","))));
                          })))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs)))));
                      }))()
                      : ((($expression)[0] === "AccessWithDot")
                        ? ((() => {
                          const $name = ($expression)[1];
                          const $e = ($expression)[2];
                          return ((($sp$Compiler$JsToText$emitExpr)($l))($e) + ("." + $name));
                        }))()
                        : ((($expression)[0] === "AccessWithBrackets")
                          ? ((() => {
                            const $i = ($expression)[1];
                            const $expr = ($expression)[2];
                            return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + (")[" + ((($sp$Compiler$JsToText$emitExpr)($l))($i) + "]"))));
                          }))()
                          : ((($expression)[0] === "Conditional")
                            ? ((() => {
                              const $p = ($expression)[1];
                              const $true = ($expression)[2];
                              const $false = ($expression)[3];
                              return (("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($p) + "\n")) + ((($sp$Compiler$JsToText$id)(($l + 1)) + ("? " + (($sp$Compiler$JsToText$emitExpr)(($l + 1)))($true))) + ("\n" + ((($sp$Compiler$JsToText$id)(($l + 1)) + (": " + (($sp$Compiler$JsToText$emitExpr)(($l + 1)))($false))) + ")"))));
                            }))()
                            : ((($expression)[0] === "Array")
                              ? ((() => {
                                const $items = ($expression)[1];
                                return (((sp_equal)($core$SPCore$Nil))($items)
                                  ? "[]"
                                  : ((($a) => {
                                    return ("([\n" + ((($corelib$Text$join)("\n"))($a) + ("\n" + (($sp$Compiler$JsToText$id)($l) + "])"))));
                                  }))((($corelib$List$map)((($i) => {
                                    return (($sp$Compiler$JsToText$id)(($l + 1)) + ((($sp$Compiler$JsToText$emitExpr)(($l + 1)))($i) + ","));
                                  })))($items)));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/JsToText.sp 41:4', (sp_toHuman)($expression)))))))))))))));
  });
});

const $sp$Compiler$JsToText$emitStatement = (($l) => {
  return (($stat) => {
    const $std = (($mid) => {
      return (($expr) => {
        return (($sp$Compiler$JsToText$id)($l) + ($mid + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + ";")));
      });
    });
    return ((($stat)[0] === "Eval")
      ? ((() => {
        const $e = ($stat)[1];
        return (($std)(""))($e);
      }))()
      : ((($stat)[0] === "Return")
        ? ((() => {
          const $e = ($stat)[1];
          return (($std)("return "))($e);
        }))()
        : ((($stat)[0] === "Define")
          ? ((() => {
            const $name = ($stat)[1];
            const $e = ($stat)[2];
            return (($std)(("const " + ($name + " = "))))($e);
          }))()
          : ((($stat)[0] === "If")
            ? ((() => {
              const $condition = ($stat)[1];
              const $block = ($stat)[2];
              return (($sp$Compiler$JsToText$id)($l) + ("if (" + ((($sp$Compiler$JsToText$emitExpr)($l))($condition) + (") " + (($sp$Compiler$JsToText$emitBlock)($l))($block)))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/JsToText.sp 14:4', (sp_toHuman)($stat))))));
  });
});

const $platforms$posix$PlatformDefinition$compile = (($getRidOfMe) => {
  return (($targetUsr) => {
    return (($emittableStatements) => {
      const $$constructors = $getRidOfMe;
      const $eenv = $$constructors.errorEnv;
      const $constructors = $$constructors.constructors;
      ((sp_log)("Creating JS AST..."))("");
      const $jaStatements = ((($sp$Compiler$EmittableToJs$translateAll)($eenv))($constructors))($emittableStatements);
      ((sp_log)("Emitting JS..."))("");
      const $callMain = ("\nconst out = " + (($sp$Compiler$MakeEmittable$translateUsr)($targetUsr) + "({})(array_toList(process.argv.slice(1)))[1]('never');\n        if (out[1]) console.error(out[1]);\n        "));
      const $statements = (($corelib$Text$join)("\n\n"))((($corelib$List$map)(($sp$Compiler$JsToText$emitStatement)(0)))($jaStatements));
      return ($sp$Compiler$CanonicalToJs$nativeDefinitions + ($statements + $callMain));
    });
  });
});

const $platforms$posix$PlatformDefinition$defaultModulesFile = ({
  libraries: $core$SPCore$Nil,
  sourceDirs: $core$SPCore$Nil,
});

const $platforms$posix$PlatformDefinition$platform = ({
  compile: $platforms$posix$PlatformDefinition$compile,
  defaultModulesFile: $platforms$posix$PlatformDefinition$defaultModulesFile,
  name: "posix",
  quickstart: "TODO",
});

const $sp$Test$codeTest = (($toText) => {
  return (($title) => {
    return (($code) => {
      return (($functionToTest) => {
        return (($ce) => {
          const $$toMaybeError = $ce;
          const $toMaybeError = ($$toMaybeError)[1];
          return ((($sp$Test$Single)($title))($code))((() => {
            return ($sp$Test$maybeToOutcome)((($toMaybeError)($toText))(($functionToTest)($code)));
          }));
        });
      });
    });
  });
});

const $sp$Compiler$CanonicalToJs_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$CanonicalToJs_Test$eval = (($value) => {
  return (($code) => {
    return ($corelib$Result$Ok)("CanonicalToJS.eval not implemented");
  });
});

const $sp$Compiler$CanonicalToJs_Test$ifs = (($sp$Test$Group)("ifs"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("a =\n  if True:\n    1\n  else\n    2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("1"))))($core$SPCore$Nil));

const $sp$Compiler$CanonicalToJs_Test$misc = (($sp$Test$Group)("misc"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("definitions and mutations return None"))("x =\n  m @= 0\n\ny =\n  m @= 0\n  @m += 1\n\na =\n  { x, y }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("{\"x\":null,\"y\":null}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("Cons"))("a = 1 :: []"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("[\"SPCore.Cons\",1,[\"SPCore.Nil\"]]"))))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs_Test$mutation = (($sp$Test$Group)("mutation"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("a =\n  m @= 0\n  @m += 1\n  x = m\n  @m := 10\n  y = m\n  @m += 1\n  z = m\n  { x, y, z, m }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("{\"m\":11,\"x\":1,\"y\":10,\"z\":11}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("nested record"))("record = { x = { y = { z = 4 } } }\n\nresult =\n   m @= record\n   @m.x.y :=  { z = 1 }\n   @m.x.y.z += 1\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"x\":{\"y\":{\"z\":2}}}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("pass mutable to function"))("fun @m =\n  @m += 55\n\nresult =\n   m @= 2\n   fun @m\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("57"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("pass nested mutable value to function"))("fun @m =\n  @m += 55\n\nrecord = { x = { y = { z = 4 } } }\n\nresult =\n   m @= record\n   fun @m.x.y.z\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"x\":{\"y\":{\"z\":59}}}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("[reg] mut args should be dereferenced and cloned"))("result =\n    l @= 3\n    f @l\n\nf @a =\n    as Number @: Number\n    a"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("3"))))($core$SPCore$Nil))))));

const $sp$Test$errorContains = (($snippets) => {
  return ($sp$Test$CodeExpectation)((($toText) => {
    return (($result) => {
      return ((($result)[0] === "Ok")
        ? ((() => {
          const $ok = ($result)[1];
          return ($corelib$Maybe$Just)(("I was expecting an error, but got: Ok " + ($toText)($ok)));
        }))()
        : ((($result)[0] === "Err")
          ? ((() => {
            const $e = ($result)[1];
            const $missing = (($corelib$List$filter)((($sn) => {
              return ($corelib$Basics$not)((($corelib$Text$contains)($sn))($e));
            })))($snippets);
            return (((sp_equal)($core$SPCore$Nil))($missing)
              ? $corelib$Maybe$Nothing
              : ((() => {
                const $indentedError = (($corelib$Text$join)("\n"))((($corelib$List$map)((($l) => {
                  return ("    " + $l);
                })))(((text_split)("\n"))($e)));
                return ($corelib$Maybe$Just)(("Error message:\n\n" + ($indentedError + ("\n\nis missing snippets: " + (($corelib$Text$join)(", "))($missing)))));
              }))());
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 102:6', (sp_toHuman)($result))));
    });
  }));
});

const $sp$Compiler$CanonicalToJs_Test$natives = (($sp$Test$Group)("natives"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.log"))("result = log \"this is produced by a test\" True"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("true"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.log, partially applied"))("result = log \"if this gets actually logged, we have a problem\""))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("undefined"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.todo"))("a = todo \"blah\"\nresult = 1"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("Text concat (..)"))("result = \"a\" .. \"b\" .. \"c\""))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("\"abc\""))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("add"))("result = 1 + 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("3"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("subtract"))("result = 5 - 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("2"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("multiply"))("result = 3 * 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("6"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("divide"))("result = 3 / 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("1.5"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("divide by zero"))("result = 3 / 0"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("0"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("lesser than (<)"))("result = 3 < 2 & 2 < 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"first\":false,\"second\":true}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("greater than (>)"))("result = 3 > 2 & 2 > 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"first\":true,\"second\":false}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("partial application"))("result = (-) 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("undefined"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("mutable partial application"))("f = (+=) 3\n\nresult =\n   m @= 1\n   f @m\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("4"))))($core$SPCore$Nil))))))))))))));

const $sp$Compiler$CanonicalToJs_Test$try_ = (($sp$Test$Group)("try"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("union A = A Number, B, C Bool\n\na x =\n  try x as\n    A 1: 11\n    A n: n\n    B: 3\n    C False: 5\n    C _: 6\n\nresult =\n { x = a (A 2)\n , y = a (A 1)\n , z = a B\n , w = a (C False)\n , k = a (C True)\n }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"k\":6,\"w\":6,\"x\":2,\"y\":11,\"z\":3}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("[reg]: pattern any"))("result =\n   try 2 as\n     x: x"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("2"))))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs_Test$tests = (($sp$Test$Group)("CanonicalToJS"))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$misc))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$mutation))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$ifs))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$try_))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$natives))($core$SPCore$Nil))))));

const $sp$Compiler$CoreTypes$boolDef = ((() => {
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)("Bool");
  return ({
    args: $core$SPCore$Nil,
    constructors: ((($corelib$Dict$insert)("False"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: $sp$Compiler$CoreTypes$bool,
      typeUsr: $usr,
    })))(((($corelib$Dict$insert)("True"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: $sp$Compiler$CoreTypes$bool,
      typeUsr: $usr,
    })))($corelib$Dict$empty)),
    directTypeDeps: $corelib$Set$empty,
    usr: $usr,
  });
}))();

const $sp$Compiler$CoreTypes$listDef = ((() => {
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)("List");
  const $item = (($sp$Types$CanonicalAst$TypeVariable)($sp$Compiler$CoreTypes$p))("item");
  const $consDef = ({
    args: (($core$SPCore$Cons)($item))((($core$SPCore$Cons)(($sp$Compiler$CoreTypes$list)($item)))($core$SPCore$Nil)),
    pos: $sp$Compiler$CoreTypes$p,
    type: ((($corelib$List$forReversed)((($core$SPCore$Cons)($item))((($core$SPCore$Cons)(($sp$Compiler$CoreTypes$list)($item)))($core$SPCore$Nil))))((($ar) => {
      return (($ty) => {
        return (((($sp$Types$CanonicalAst$TypeFunction)($sp$Compiler$CoreTypes$p))($ar))(false))($ty);
      });
    })))(($sp$Compiler$CoreTypes$list)($item)),
    typeUsr: $usr,
  });
  return ({
    args: (($core$SPCore$Cons)("item"))($core$SPCore$Nil),
    constructors: ((($corelib$Dict$insert)("Cons"))($consDef))(((($corelib$Dict$insert)("Nil"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: ($sp$Compiler$CoreTypes$list)($item),
      typeUsr: $usr,
    })))($corelib$Dict$empty)),
    directTypeDeps: $corelib$Set$empty,
    usr: $usr,
  });
}))();

const $sp$Compiler$CoreTypes$noneDef = ((() => {
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)($sp$Compiler$CoreTypes$noneName);
  return ({
    args: $core$SPCore$Nil,
    constructors: (($corelib$Dict$singleton)($sp$Compiler$CoreTypes$noneName))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: $sp$Compiler$CoreTypes$none,
      typeUsr: $usr,
    })),
    directTypeDeps: $corelib$Set$empty,
    usr: $usr,
  });
}))();

const $sp$Compiler$CoreTypes$allDefs = (($core$SPCore$Cons)($sp$Compiler$CoreTypes$noneDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$boolDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$listDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$textDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$numberDef))($core$SPCore$Nil)))));

const $sp$Compiler$CoreTypes$cons = ($sp$Compiler$CoreTypes$makeUsr)("Cons");

const $sp$Compiler$CoreTypes$nil = ($sp$Compiler$CoreTypes$makeUsr)("Nil");

const $sp$Compiler$CoreTypes$usrToVariable = (($u) => {
  return (($sp$Types$CanonicalAst$Variable)($sp$Compiler$CoreTypes$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Types$CanonicalAst$RefRoot)($u),
  }));
});

const $sp$Compiler$Error$breakDownText = (($text) => {
  const $formatSnippet = (($index) => {
    return (($snippet) => {
      return (((sp_equal)(0))(((basics_modBy)(2))($index))
        ? ($sp$Compiler$Error$FormattedText_Default)($snippet)
        : ((() => {
          const $$try1 = ((text_split)($sp$Compiler$Error$formatSuffix))($snippet);
          return (((($$try1)[0] === "Cons") && (("emphasys" === ($$try1)[1]) && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil"))))
            ? ((() => {
              const $s = (($$try1)[2])[1];
              return ($sp$Compiler$Error$FormattedText_Emphasys)($s);
            }))()
            : (((($$try1)[0] === "Cons") && (("warning" === ($$try1)[1]) && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil"))))
              ? ((() => {
                const $s = (($$try1)[2])[1];
                return ($sp$Compiler$Error$FormattedText_Warning)($s);
              }))()
              : (((($$try1)[0] === "Cons") && (("decoration" === ($$try1)[1]) && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil"))))
                ? ((() => {
                  const $s = (($$try1)[2])[1];
                  return ($sp$Compiler$Error$FormattedText_Decoration)($s);
                }))()
                : (true
                  ? ($sp$Compiler$Error$FormattedText_Default)($snippet)
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 69:10', (sp_toHuman)($$try1))))));
        }))());
    });
  });
  return (($corelib$List$indexedMap)($formatSnippet))(((text_split)($sp$Compiler$Error$formatSeparator))($text));
});

const $sp$Compiler$Error$deco = ($sp$Compiler$Error$formatWrap)("decoration");

const $sp$Compiler$Error$emph = ($sp$Compiler$Error$formatWrap)("emphasys");

const $sp$Compiler$Error$flatten = (($e) => {
  return (($accum) => {
    return ((($e)[0] === "Simple")
      ? ((() => {
        const $pos = ($e)[1];
        const $descr = ($e)[2];
        return ((sp_cons)($accum))(({
          first: $pos,
          second: $descr,
        }));
      }))()
      : ((($e)[0] === "Nested")
        ? ((() => {
          const $ls = ($e)[1];
          return ((($corelib$List$for)($ls))($sp$Compiler$Error$flatten))($accum);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 104:4', (sp_toHuman)($e))));
  });
});

const $sp$Compiler$Error$res = (($pos) => {
  return (($desc) => {
    return ($corelib$Result$Err)((($sp$Compiler$Error$Simple)($pos))($desc));
  });
});

const $sp$Compiler$Error$toText = (($env) => {
  return (($pos) => {
    return (($desc) => {
      const $$block = (($sp$Compiler$Error$posToHuman)($env))($pos);
      const $location = $$block.location;
      const $block = $$block.block;
      const $description = (($corelib$Text$join)("\n"))((($corelib$List$map)((($s) => {
        return ("  " + $s);
      })))((($corelib$List$concatMap)((text_split)("\n")))(((($d) => {
        return ((sp_cons)($d))($block);
      }))(($desc)($env)))));
      return ($sp$Compiler$Error$breakDownText)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(($sp$Compiler$Error$deco)(((($corelib$Text$padRight)(50))("-"))(($location + " ")))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($description))((($core$SPCore$Cons)(""))($core$SPCore$Nil))))))));
    });
  });
});

const $sp$Compiler$Error$toFormattedText = (($eenv) => {
  return (($e) => {
    const $newline = ($sp$Compiler$Error$FormattedText_Default)("");
    const $tupleToFormattedText = (($x) => {
      const $$descr = $x;
      const $descr = $$descr.second;
      const $pos = $$descr.first;
      return ((($sp$Compiler$Error$toText)($eenv))($pos))($descr);
    });
    return (($corelib$List$concatMap)($tupleToFormattedText))((($sp$Compiler$Error$flatten)($e))($core$SPCore$Nil));
  });
});

const $sp$Compiler$ExpandTypes$error = (($pos) => {
  return (($description) => {
    return (($sp$Compiler$Error$res)($pos))((() => {
      return $description;
    }));
  });
});

const $sp$Compiler$ExpandTypes$expandAliasVariables = (($typeByArgName) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeVariable")
      ? ((() => {
        const $pos = ($ty)[1];
        const $name = ($ty)[2];
        const $$try1 = (($corelib$Dict$get)($name))($typeByArgName);
        return ((($$try1)[0] === "Nothing")
          ? $ty
          : ((($$try1)[0] === "Just")
            ? ((() => {
              const $t = ($$try1)[1];
              return $t;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 185:12', (sp_toHuman)($$try1))));
      }))()
      : ((($ty)[0] === "TypeFunction")
        ? ((() => {
          const $pos = ($ty)[1];
          const $from = ($ty)[2];
          const $fromIsMutable = ($ty)[3];
          const $to = ($ty)[4];
          return (((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($from)))($fromIsMutable))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($to));
        }))()
        : ((($ty)[0] === "TypeRecord")
          ? ((() => {
            const $pos = ($ty)[1];
            const $extensible = ($ty)[2];
            const $attrs = ($ty)[3];
            return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible))((($corelib$Dict$map)((($k) => {
              return ($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName);
            })))($attrs));
          }))()
          : ((($ty)[0] === "TypeConstant")
            ? ((() => {
              const $pos = ($ty)[1];
              const $usr = ($ty)[2];
              const $args = ($ty)[3];
              return ((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))((($corelib$List$map)(($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName)))($args));
            }))()
            : ((($ty)[0] === "TypeAlias")
              ? ((() => {
                const $pos = ($ty)[1];
                const $usr = ($ty)[2];
                const $t = ($ty)[3];
                return ((($sp$Types$CanonicalAst$TypeAlias)($pos))($usr))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($t));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 183:4', (sp_toHuman)($ty)))))));
  });
});

const $sp$Compiler$ExpandTypes$expandInType = (($ga) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeVariable")
      ? ((() => {
        const $pos = ($ty)[1];
        const $name = ($ty)[2];
        return ($corelib$Result$Ok)($ty);
      }))()
      : ((($ty)[0] === "TypeFunction")
        ? ((() => {
          const $pos = ($ty)[1];
          const $from = ($ty)[2];
          const $fromIsMutable = ($ty)[3];
          const $to = ($ty)[4];
          return (($corelib$Result$onOk)((($f) => {
            return (($corelib$Result$onOk)((($t) => {
              return ($corelib$Result$Ok)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($f))($fromIsMutable))($t));
            })))((($sp$Compiler$ExpandTypes$expandInType)($ga))($to));
          })))((($sp$Compiler$ExpandTypes$expandInType)($ga))($from));
        }))()
        : ((($ty)[0] === "TypeRecord")
          ? ((() => {
            const $pos = ($ty)[1];
            const $extensible = ($ty)[2];
            const $attrs = ($ty)[3];
            return (($corelib$Result$map)((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible)))((($corelib$Dict$mapRes)((($k) => {
              return ($sp$Compiler$ExpandTypes$expandInType)($ga);
            })))($attrs));
          }))()
          : ((($ty)[0] === "TypeAlias")
            ? ((() => {
              const $pos = ($ty)[1];
              const $path = ($ty)[2];
              const $t = ($ty)[3];
              return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)("Did we apply aliases twice?"))($core$SPCore$Nil));
            }))()
            : ((($ty)[0] === "TypeConstant")
              ? ((() => {
                const $pos = ($ty)[1];
                const $usr = ($ty)[2];
                const $args = ($ty)[3];
                return (($corelib$Result$onOk)((($replacedArgs) => {
                  const $$try1 = (($ga)($pos))($usr);
                  return ((($$try1)[0] === "Err")
                    ? ((() => {
                      const $e = ($$try1)[1];
                      return ($corelib$Result$Err)($e);
                    }))()
                    : (((($$try1)[0] === "Ok") && ((($$try1)[1])[0] === "TypeDefUnion"))
                      ? ((() => {
                        const $un = (($$try1)[1])[1];
                        return (((sp_not_equal)(($corelib$List$length)($un.args)))(($corelib$List$length)($replacedArgs))
                          ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("union " + ((sp_toHuman)($un.usr) + (" needs " + ((text_fromNumber)(($corelib$List$length)($un.args)) + " args,"))))))((($core$SPCore$Cons)(("but was used with " + (text_fromNumber)(($corelib$List$length)($replacedArgs)))))($core$SPCore$Nil)))
                          : ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))($replacedArgs)));
                      }))()
                      : (((($$try1)[0] === "Ok") && ((($$try1)[1])[0] === "TypeDefAlias"))
                        ? ((() => {
                          const $al = (($$try1)[1])[1];
                          return (((sp_not_equal)(($corelib$List$length)($replacedArgs)))(($corelib$List$length)($al.args))
                            ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("alias " + ((sp_toHuman)($al.usr) + (" needs " + ((text_fromNumber)(($corelib$List$length)($al.args)) + (" args, but was used with " + (text_fromNumber)(($corelib$List$length)($replacedArgs)))))))))($core$SPCore$Nil))
                            : ((() => {
                              const $typeByArgName = ($corelib$Dict$fromList)(((($corelib$List$map2)((($$name) => {
                                const $name = ($$name)[2];
                                return (($r) => {
                                  return ({
                                    first: $name,
                                    second: $r,
                                  });
                                });
                              })))($al.args))($replacedArgs));
                              return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeAlias)($pos))($usr))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($al.type)));
                            }))());
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 39:12', (sp_toHuman)($$try1)))));
                })))((($corelib$List$mapRes)(($sp$Compiler$ExpandTypes$expandInType)($ga)))($args));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 19:4', (sp_toHuman)($ty)))))));
  });
});

const $sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions = (($nonFunctionPos) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeConstant")
      ? $core$SPCore$Nil
      : ((($ty)[0] === "TypeVariable")
        ? ((() => {
          const $name = ($ty)[2];
          return $core$SPCore$Nil;
        }))()
        : ((($ty)[0] === "TypeAlias")
          ? ((() => {
            const $path = ($ty)[2];
            const $t = ($ty)[3];
            return (($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos))($t);
          }))()
          : ((($ty)[0] === "TypeFunction")
            ? ((() => {
              const $functionPos = ($ty)[1];
              const $from = ($ty)[2];
              const $fromIsMutable = ($ty)[3];
              const $to = ($ty)[4];
              return ($corelib$List$concat)((($core$SPCore$Cons)(((($nonFunctionPos)[0] === "Just")
                ? ((() => {
                  const $constraintPos = ($nonFunctionPos)[1];
                  return (($core$SPCore$Cons)(({
                    first: $constraintPos,
                    second: $functionPos,
                  })))($core$SPCore$Nil);
                }))()
                : ((($nonFunctionPos)[0] === "Nothing")
                  ? $core$SPCore$Nil
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 104:14', (sp_toHuman)($nonFunctionPos))))))((($core$SPCore$Cons)((($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)(($fromIsMutable
                ? ($corelib$Maybe$Just)($functionPos)
                : $corelib$Maybe$Nothing)))($from)))((($core$SPCore$Cons)((($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos))($to)))($core$SPCore$Nil))));
            }))()
            : ((($ty)[0] === "TypeRecord")
              ? ((() => {
                const $ext = ($ty)[2];
                const $attrs = ($ty)[3];
                return (($corelib$List$concatMap)(($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos)))(($corelib$Dict$values)($attrs));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 85:4', (sp_toHuman)($ty)))))));
  });
});

const $sp$Compiler$ExpandTypes$expandAndValidateType = (($ga) => {
  return (($rawTy) => {
    return (($corelib$Result$onOk)((($expandedTy) => {
      const $$try1 = (($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($corelib$Maybe$Nothing))($expandedTy);
      return ((($$try1)[0] === "Nil")
        ? ($corelib$Result$Ok)($expandedTy)
        : (true
          ? ((() => {
            const $errors = $$try1;
            return (($sp$Compiler$ExpandTypes$error)(($sp$Types$Pos$I)(567)))((($core$SPCore$Cons)("Mutable arguments can't be or contain functions!"))((($core$SPCore$Cons)((($corelib$Text$join)("\n"))((($corelib$List$map)(sp_toHuman))($errors))))($core$SPCore$Nil)));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 71:4', (sp_toHuman)($$try1))));
    })))((($sp$Compiler$ExpandTypes$expandInType)($ga))($rawTy));
  });
});

const $sp$Compiler$ExpandTypes$expandAndInsertAlias = (($allTypes) => {
  return (($al) => {
    return (($expandedTypes) => {
      const $getAlias = (($pos) => {
        return (($usr) => {
          const $$try1 = (($corelib$Dict$get)($usr))($expandedTypes);
          return ((($$try1)[0] === "Just")
            ? ((() => {
              const $type = ($$try1)[1];
              return ($corelib$Result$Ok)($type);
            }))()
            : ((($$try1)[0] === "Nothing")
              ? ((() => {
                const $$try2 = (($corelib$Dict$get)($usr))($allTypes);
                return ((($$try2)[0] === "Nothing")
                  ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil))
                  : (((($$try2)[0] === "Just") && ((($$try2)[1])[0] === "TypeDefAlias"))
                    ? ((() => {
                      const $a = (($$try2)[1])[1];
                      return (sp_todo)(("expandAndInsertAlias should-not-happen: " + (sp_toHuman)($usr)));
                    }))()
                    : (((($$try2)[0] === "Just") && ((($$try2)[1])[0] === "TypeDefUnion"))
                      ? ((() => {
                        const $u = (($$try2)[1])[1];
                        return ($corelib$Result$Ok)(($sp$Types$CanonicalAst$TypeDefUnion)($u));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 166:16', (sp_toHuman)($$try2)))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 161:8', (sp_toHuman)($$try1))));
        });
      });
      return (($corelib$Result$onOk)((($type) => {
        return ($corelib$Result$Ok)(((($corelib$Dict$insert)($al.usr))(($sp$Types$CanonicalAst$TypeDefAlias)((Object.assign)({}, $al, ({
          type: $type,
        })))))($expandedTypes));
      })))((($sp$Compiler$ExpandTypes$expandAndValidateType)($getAlias))($al.type));
    });
  });
});

const $sp$Compiler$ExpandTypes$getTypeForUnion = (($allTypes) => {
  return (($expandedTypes) => {
    return (($pos) => {
      return (($usr) => {
        const $$try1 = (($corelib$Dict$get)($usr))($expandedTypes);
        return ((($$try1)[0] === "Just")
          ? ((() => {
            const $t = ($$try1)[1];
            return ($corelib$Result$Ok)($t);
          }))()
          : ((($$try1)[0] === "Nothing")
            ? ((() => {
              const $$try2 = (($corelib$Dict$get)($usr))($allTypes);
              return ((($$try2)[0] === "Just")
                ? ((() => {
                  const $t = ($$try2)[1];
                  return ($corelib$Result$Ok)($t);
                }))()
                : ((($$try2)[0] === "Nothing")
                  ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type usr: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil))
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 230:12', (sp_toHuman)($$try2))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 223:4', (sp_toHuman)($$try1))));
      });
    });
  });
});

const $sp$Compiler$ExpandTypes$expandAndInsertUnion = (($allTypes) => {
  return (($usr) => {
    return (($typeDef) => {
      return (($expandedTypes) => {
        return ((($typeDef)[0] === "TypeDefAlias")
          ? ($corelib$Result$Ok)($expandedTypes)
          : ((($typeDef)[0] === "TypeDefUnion")
            ? ((() => {
              const $u = ($typeDef)[1];
              const $gt = (($sp$Compiler$ExpandTypes$getTypeForUnion)($allTypes))($expandedTypes);
              const $mapConstructor = (($name) => {
                return (($c) => {
                  return (($corelib$Result$onOk)((($type) => {
                    return (($corelib$Result$onOk)((($args) => {
                      return ($corelib$Result$Ok)((Object.assign)({}, $c, ({
                        args: $args,
                        type: $type,
                      })));
                    })))((($corelib$List$mapRes)(($sp$Compiler$ExpandTypes$expandAndValidateType)($gt)))($c.args));
                  })))((($sp$Compiler$ExpandTypes$expandAndValidateType)($gt))($c.type));
                });
              });
              return (($corelib$Result$onOk)((($cs) => {
                return ($corelib$Result$Ok)(((($corelib$Dict$insert)($usr))(($sp$Types$CanonicalAst$TypeDefUnion)((Object.assign)({}, $u, ({
                  constructors: $cs,
                })))))($expandedTypes));
              })))((($corelib$Dict$mapRes)($mapConstructor))($u.constructors));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 242:4', (sp_toHuman)($typeDef))));
      });
    });
  });
});

const $sp$Compiler$ExpandTypes$referencedAliases = (($allAliases) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeConstant")
      ? ((() => {
        const $pos = ($ty)[1];
        const $usr = ($ty)[2];
        const $args = ($ty)[3];
        const $init = ((($corelib$Dict$member)($usr))($allAliases)
          ? ($corelib$Set$singleton)($usr)
          : $corelib$Set$empty);
        return ((($corelib$List$for)($args))((($ar) => {
          return ($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($ar));
        })))(($corelib$Set$singleton)($usr));
      }))()
      : ((($ty)[0] === "TypeVariable")
        ? ((() => {
          const $pos = ($ty)[1];
          const $name = ($ty)[2];
          return $corelib$Dict$empty;
        }))()
        : ((($ty)[0] === "TypeFunction")
          ? ((() => {
            const $pos = ($ty)[1];
            const $from = ($ty)[2];
            const $maybeMut = ($ty)[3];
            const $to = ($ty)[4];
            return (($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($from)))((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($to));
          }))()
          : ((($ty)[0] === "TypeRecord")
            ? ((() => {
              const $pos = ($ty)[1];
              const $extensible = ($ty)[2];
              const $attrs = ($ty)[3];
              return ((($corelib$Dict$for)($attrs))((($name) => {
                return (($t) => {
                  return ($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($t));
                });
              })))($corelib$Dict$empty);
            }))()
            : ((($ty)[0] === "TypeAlias")
              ? ((() => {
                const $pos = ($ty)[1];
                const $path = ($ty)[2];
                const $t = ($ty)[3];
                return (($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($t);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 131:4', (sp_toHuman)($ty)))))));
  });
});

const $sp$RefHierarchy$resolve = (($getEdges) => {
  return (($target) => {
    return (($path) => {
      return (($state0) => {
        return ((($corelib$List$member)($target))($state0.resolved)
          ? $state0
          : ((($corelib$List$member)($target))($path)
            ? ((() => {
              const $circ = ((sp_cons)((($corelib$List$takeWhile)((($key) => {
                return ((sp_not_equal)($target))($key);
              })))($path)))($target);
              return (Object.assign)({}, $state0, ({
                circular: ((($corelib$Dict$insert)(($corelib$Set$fromList)($circ)))($circ))($state0.circular),
              }));
            }))()
            : ((() => {
              const $s = ((($corelib$Dict$for)(($getEdges)($target)))((($a) => {
                return (() => {
                  return ((($sp$RefHierarchy$resolve)($getEdges))($a))(((sp_cons)($path))($target));
                });
              })))($state0);
              return (Object.assign)({}, $s, ({
                resolved: ((sp_cons)($s.resolved))($target),
              }));
            }))()));
      });
    });
  });
});

const $sp$RefHierarchy$reorder = (($nodeToEdges) => {
  return (($nodesById) => {
    const $keyToEdges = (($id) => {
      const $$try1 = (($corelib$Dict$get)($id))($nodesById);
      return ((($$try1)[0] === "Nothing")
        ? $corelib$Set$empty
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $node = ($$try1)[1];
            return ($nodeToEdges)($node);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/RefHierarchy.sp 44:8', (sp_toHuman)($$try1))));
    });
    const $state0 = ({
      circular: $corelib$Dict$empty,
      resolved: $core$SPCore$Nil,
    });
    const $stateF = ((($corelib$Dict$for)($nodesById))((($k) => {
      return (($v) => {
        return ((($sp$RefHierarchy$resolve)($keyToEdges))($k))($core$SPCore$Nil);
      });
    })))($state0);
    return ({
      first: ($corelib$Dict$values)($stateF.circular),
      second: ($corelib$List$reverse)($stateF.resolved),
    });
  });
});

const $sp$Compiler$ExpandTypes$expandAllTypes = (($allTypes) => {
  const $allAliases = ((() => {
    const $insertAlias = (($usr) => {
      return (($typeDef) => {
        return (($acc) => {
          return ((($typeDef)[0] === "TypeDefAlias")
            ? ((() => {
              const $a = ($typeDef)[1];
              return ((($corelib$Dict$insert)($usr))($a))($acc);
            }))()
            : (true
              ? $acc
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 280:12', (sp_toHuman)($typeDef))));
        });
      });
    });
    return ((($corelib$Dict$for)($allTypes))($insertAlias))($corelib$Dict$empty);
  }))();
  const $$circulars = (($sp$RefHierarchy$reorder)((($al) => {
    return (($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($al.type);
  })))($allAliases);
  const $orderedAliasRefs = $$circulars.second;
  const $circulars = $$circulars.first;
  return (((sp_not_equal)($core$SPCore$Nil))($circulars)
    ? ((() => {
      const $circularToError = (($circular) => {
        return (($sp$Compiler$Error$Simple)(($sp$Types$Pos$I)(121)))((() => {
          return (($core$SPCore$Cons)("circular alias: "))((($core$SPCore$Cons)((($corelib$Text$join)(" <- "))((($corelib$List$map)(sp_toHuman))($circular))))($core$SPCore$Nil));
        }));
      });
      return ($corelib$Result$Err)(($sp$Compiler$Error$Nested)((($corelib$List$map)($circularToError))($circulars)));
    }))()
    : ((() => {
      const $oa = (($corelib$List$filterMap)((($ref) => {
        return (($corelib$Dict$get)($ref))($allAliases);
      })))($orderedAliasRefs);
      return (($corelib$Result$onOk)((($corelib$Dict$forRes)($allTypes))(($sp$Compiler$ExpandTypes$expandAndInsertUnion)($allTypes))))(((($corelib$List$foldlRes)(($sp$Compiler$ExpandTypes$expandAndInsertAlias)($allTypes)))($oa))($corelib$Dict$empty));
    }))());
});

const $sp$Compiler$ExpandTypes$expandAnnotation = (($allExpandedTypes) => {
  return (($type) => {
    const $gt = (($pos) => {
      return (($usr) => {
        const $$try1 = (($corelib$Dict$get)($usr))($allExpandedTypes);
        return ((($$try1)[0] === "Just")
          ? ((() => {
            const $t = ($$try1)[1];
            return ($corelib$Result$Ok)($t);
          }))()
          : ((($$try1)[0] === "Nothing")
            ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type usr: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 324:8', (sp_toHuman)($$try1))));
      });
    });
    return (($sp$Compiler$ExpandTypes$expandAndValidateType)($gt))($type);
  });
});

const $sp$Compiler$ExpandTypes$insertModuleTypes = (($module) => {
  return (($allTypes) => {
    return ((($corelib$Dict$for)($module.unionDefs))((($name) => {
      return (($def) => {
        return (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefUnion)($def));
      });
    })))(((($corelib$Dict$for)($module.aliasDefs))((($name) => {
      return (($def) => {
        return (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefAlias)($def));
      });
    })))($allTypes));
  });
});

const $sp$Compiler$Lexer$addIndentToken = (($pos) => {
  return (($kind) => {
    return (($state) => {
      return ((array_push)(({
        attr: "tokens",
        obj: ($state.obj)[$state.attr],
      })))(((($sp$Types$Token$Token)($pos))($pos))($kind));
    });
  });
});

const $sp$Compiler$Lexer$updateIndent = (($start) => {
  return (($end) => {
    return (($kind) => {
      return (($state) => {
        const $manageIndent = (($head) => {
          return (((sp_clone)(($state.obj)[$state.attr].lineIndent) > $head.indent)
            ? ((() => {
              const $newIndent = ({
                indent: (sp_clone)(($state.obj)[$state.attr].lineIndent),
                isBlock: (sp_clone)(($state.obj)[$state.attr].indentStartsABlock),
              });
              (($state.obj)[$state.attr].indentStack = ((sp_cons)((sp_clone)(($state.obj)[$state.attr].indentStack)))($newIndent));
              return ((sp_clone)(($state.obj)[$state.attr].indentStartsABlock)
                ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$BlockStart))($state)
                : null);
            }))()
            : (($head.isBlock && ((sp_not_equal)($sp$Types$Token$Comment))($kind))
              ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$NewSiblingLine))($state)
              : null));
        });
        const $$try1 = (sp_clone)(($state.obj)[$state.attr].indentStack);
        return ((($$try1)[0] === "Cons")
          ? ((() => {
            const $head = ($$try1)[1];
            const $tail = ($$try1)[2];
            return (((sp_clone)(($state.obj)[$state.attr].lineIndent) < $head.indent)
              ? ((() => {
                (($state.obj)[$state.attr].indentStack = $tail);
                ($head.isBlock
                  ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$BlockEnd))($state)
                  : null);
                return (((($sp$Compiler$Lexer$updateIndent)($start))($end))($kind))($state);
              }))()
              : ($manageIndent)($head));
          }))()
          : ((($$try1)[0] === "Nil")
            ? ($manageIndent)(({
              indent: 0,
              isBlock: true,
            }))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 145:4', (sp_toHuman)($$try1))));
      });
    });
  });
});

const $sp$Compiler$Lexer$absAddToken = (($start) => {
  return (($end) => {
    return (($kind) => {
      return (($state) => {
        ((sp_clone)(($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine)
          ? ((() => {
            (($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine = false);
            return (((($sp$Compiler$Lexer$updateIndent)($start))($end))($kind))($state);
          }))()
          : null);
        const $indentStartsABlock = ((($kind)[0] === "Then")
          ? true
          : ((($kind)[0] === "Else")
            ? true
            : ((($kind)[0] === "As")
              ? true
              : ((($kind)[0] === "Colon")
                ? true
                : ((($kind)[0] === "MutableColon")
                  ? true
                  : ((($kind)[0] === "Defop")
                    ? true
                    : ((($kind)[0] === "Comment")
                      ? (sp_clone)(($state.obj)[$state.attr].indentStartsABlock)
                      : (true
                        ? false
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 174:8', (sp_toHuman)($kind))))))))));
        (($state.obj)[$state.attr].indentStartsABlock = $indentStartsABlock);
        ((array_push)(({
          attr: "tokens",
          obj: ($state.obj)[$state.attr],
        })))(((($sp$Types$Token$Token)($start))($end))($kind));
        return (($state.obj)[$state.attr].tokenStart = $end);
      });
    });
  });
});

const $sp$Compiler$Lexer$getPos = (($state) => {
  return (sp_clone)(($state.obj)[$state.attr].buffer.nextPos);
});

const $sp$Compiler$Lexer$addError = (($message) => {
  return (($state) => {
    const $end = ($sp$Compiler$Lexer$getPos)($state);
    const $error = (($sp$Compiler$Error$Simple)(((($sp$Types$Pos$P)((sp_clone)(($state.obj)[$state.attr].moduleName)))((sp_clone)(($state.obj)[$state.attr].tokenStart)))($end)))((() => {
      return (($core$SPCore$Cons)($message))($core$SPCore$Nil);
    }));
    (($state.obj)[$state.attr].errors = ((sp_cons)((sp_clone)(($state.obj)[$state.attr].errors)))($error));
    return (($state.obj)[$state.attr].tokenStart = $end);
  });
});

const $sp$Compiler$Lexer$startsWithUpperChar = (($s) => {
  const $$try1 = ((text_startsWithRegex)("[A-Z]"))($s);
  return (("" === $$try1)
    ? false
    : (true
      ? true
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 264:4', (sp_toHuman)($$try1))));
});

const $sp$Compiler$Lexer$addLowerOrUpperWord = (($start) => {
  return (($end) => {
    return (($modifier) => {
      return (($chunk) => {
        return (($state) => {
          const $upperName = (($maybeModule) => {
            return (($name) => {
              return ((($modifier)[0] === "NameNoModifier")
                ? (((($sp$Compiler$Lexer$absAddToken)($start))($end))((($sp$Types$Token$UpperName)($maybeModule))($name)))($state)
                : ((($modifier)[0] === "NameStartsWithDot")
                  ? (($sp$Compiler$Lexer$addError)("Types or constructors can't start with `.` and attribute names can't start with an uppercase letter. =|"))($state)
                  : ((($modifier)[0] === "NameMutable")
                    ? (($sp$Compiler$Lexer$addError)("Types or constructors can't be mutable on their own, only variables can!"))($state)
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 274:8', (sp_toHuman)($modifier)))));
            });
          });
          const $lowerName = (($maybeModule) => {
            return (($name) => {
              return (($attrs) => {
                return ((($corelib$List$any)($sp$Compiler$Lexer$startsWithUpperChar))($attrs)
                  ? (($sp$Compiler$Lexer$addError)("attribute names must start with a lowercase letter"))($state)
                  : ((((sp_not_equal)($corelib$Maybe$Nothing))($maybeModule) && ((sp_not_equal)($sp$Types$Token$NameNoModifier))($modifier))
                    ? (($sp$Compiler$Lexer$addError)("can't use . or @ modifier on an imported value"))($state)
                    : (((($sp$Compiler$Lexer$absAddToken)($start))($end))((((($sp$Types$Token$LowerName)($modifier))($maybeModule))($name))($attrs)))($state)));
              });
            });
          });
          const $snips = ((text_split)("."))($chunk);
          return ((($corelib$List$any)((($s) => {
            return ((sp_equal)(""))($s);
          })))($snips)
            ? (($sp$Compiler$Lexer$addError)("use spaces around `..` to concatenate Text"))($state)
            : ((($snips)[0] === "Nil")
              ? (sp_todo)("should not happen")
              : (((($snips)[0] === "Cons") && ((($snips)[2])[0] === "Nil"))
                ? ((() => {
                  const $one = ($snips)[1];
                  return (($sp$Compiler$Lexer$startsWithUpperChar)($one)
                    ? (($upperName)($corelib$Maybe$Nothing))($one)
                    : ((($lowerName)($corelib$Maybe$Nothing))($one))($core$SPCore$Nil));
                }))()
                : (((($snips)[0] === "Cons") && ((($snips)[2])[0] === "Cons"))
                  ? ((() => {
                    const $first = ($snips)[1];
                    const $second = (($snips)[2])[1];
                    const $more = (($snips)[2])[2];
                    const $$try1 = ({
                      first: ($sp$Compiler$Lexer$startsWithUpperChar)($first),
                      second: ($sp$Compiler$Lexer$startsWithUpperChar)($second),
                    });
                    return ((!($$try1.first) && !($$try1.second))
                      ? ((($lowerName)($corelib$Maybe$Nothing))($first))(((sp_cons)($more))($second))
                      : (($$try1.first && !($$try1.second))
                        ? ((($lowerName)(($corelib$Maybe$Just)($first)))($second))($more)
                        : (($$try1.first && $$try1.second)
                          ? (((sp_not_equal)($core$SPCore$Nil))($more)
                            ? (($sp$Compiler$Lexer$addError)("Types and constructors can't have .attributes"))($state)
                            : (($upperName)(($corelib$Maybe$Just)($first)))($second))
                          : ((!($$try1.first) && $$try1.second)
                            ? (($sp$Compiler$Lexer$addError)("Something wrong with uppercases?"))($state)
                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 319:12', (sp_toHuman)($$try1))))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 300:6', (sp_toHuman)($snips))))));
        });
      });
    });
  });
});

const $sp$SPLib$Buffer$slice = (($start) => {
  return (($end) => {
    return (($b) => {
      return (((text_slice)($start))($end))($b.fullText);
    });
  });
});

const $sp$Compiler$Lexer$getChunk = (($state) => {
  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
  const $end = ($sp$Compiler$Lexer$getPos)($state);
  return ({
    first: $start,
    second: $end,
    third: ((($sp$SPLib$Buffer$slice)((sp_clone)(($state.obj)[$state.attr].tokenStart)))($end))((sp_clone)(($state.obj)[$state.attr].buffer)),
  });
});

const $sp$Compiler$Lexer$addNumberToken = (($state) => {
  const $$chunk = ($sp$Compiler$Lexer$getChunk)($state);
  const $chunk = $$chunk.third;
  const $end = $$chunk.second;
  const $start = $$chunk.first;
  return (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$NumberLiteral)($chunk)))($state);
});

const $sp$Compiler$Lexer$addOneIndentToken = (($kind) => {
  return (($state) => {
    const $pos = ($sp$Compiler$Lexer$getPos)($state);
    return ((array_push)(({
      attr: "tokens",
      obj: ($state.obj)[$state.attr],
    })))(((($sp$Types$Token$Token)($pos))($pos))($kind));
  });
});

const $sp$Compiler$Lexer$relAddToken = (($ds) => {
  return (($de) => {
    return (($kind) => {
      return (($state) => {
        const $pos = ($sp$Compiler$Lexer$getPos)($state);
        return (((($sp$Compiler$Lexer$absAddToken)(($pos + $ds)))(($pos + $de)))($kind))($state);
      });
    });
  });
});

const $sp$Compiler$Lexer$addParenOrCommaToken = (($char) => {
  return (($state) => {
    const $add = (($kind) => {
      return (((($sp$Compiler$Lexer$relAddToken)(0))(1))($kind))($state);
    });
    return (("(" === $char)
      ? ($add)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open))
      : ((")" === $char)
        ? ($add)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed))
        : (("[" === $char)
          ? ($add)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))
          : (("]" === $char)
            ? ($add)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))
            : (("{" === $char)
              ? ($add)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Open))
              : (("}" === $char)
                ? ($add)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Closed))
                : (("," === $char)
                  ? ($add)($sp$Types$Token$Comma)
                  : (true
                    ? (($sp$Compiler$Lexer$addError)(("I can't make sense of this piece of text: `" + ($char + "`"))))($state)
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 456:4', (sp_toHuman)($char))))))))));
  });
});

const $sp$Prelude$sendLeft = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: "<<",
  type: (((($sp$Prelude$typeBinop)(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("b"))))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("b")),
  usr: ($sp$Prelude$coreUsr)("sendLeft"),
});

const $sp$Prelude$sendRight = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("b"))))(($sp$Prelude$tyVar)("b")),
  usr: ($sp$Prelude$coreUsr)("sendRight"),
});

const $sp$Prelude$tupleUsr = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore/Tuple"));

const $sp$Prelude$tuple = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Tuple,
  symbol: "&",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("b")))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$N))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))(($sp$Prelude$tyVar)("b")))(((($corelib$Dict$insert)("first"))(($sp$Prelude$tyVar)("a")))($corelib$Dict$empty)))),
  usr: ($sp$Prelude$tupleUsr)("pair"),
});

const $sp$Prelude$binops = (($core$SPCore$Cons)($sp$Prelude$and_))((($core$SPCore$Cons)($sp$Prelude$or_))((($core$SPCore$Cons)($sp$Prelude$textConcat))((($core$SPCore$Cons)($sp$Prelude$listCons))((($core$SPCore$Cons)($sp$Prelude$tuple))((($core$SPCore$Cons)($sp$Prelude$add))((($core$SPCore$Cons)($sp$Prelude$subtract))((($core$SPCore$Cons)($sp$Prelude$multiply))((($core$SPCore$Cons)($sp$Prelude$divide))((($core$SPCore$Cons)($sp$Prelude$mutableAssign))((($core$SPCore$Cons)($sp$Prelude$mutableAdd))((($core$SPCore$Cons)($sp$Prelude$mutableSubtract))((($core$SPCore$Cons)($sp$Prelude$equal))((($core$SPCore$Cons)($sp$Prelude$notEqual))((($core$SPCore$Cons)($sp$Prelude$lesserThan))((($core$SPCore$Cons)($sp$Prelude$greaterThan))((($core$SPCore$Cons)($sp$Prelude$lesserOrEqualThan))((($core$SPCore$Cons)($sp$Prelude$greaterOrEqualThan))((($core$SPCore$Cons)($sp$Prelude$sendRight))((($core$SPCore$Cons)($sp$Prelude$sendLeft))($core$SPCore$Nil))))))))))))))))))));

const $sp$Prelude$binopsBySymbol = ((($corelib$List$for)($sp$Prelude$binops))((($bop) => {
  return (($corelib$Dict$insert)($bop.symbol))($bop);
})))($corelib$Dict$empty);

const $sp$Compiler$Lexer$addSquiggleToken = (($nextIsSpace) => {
  return (($state) => {
    const $$chunk = ($sp$Compiler$Lexer$getChunk)($state);
    const $chunk = $$chunk.third;
    const $end = $$chunk.second;
    const $start = $$chunk.first;
    const $add = (($kind) => {
      return (((($sp$Compiler$Lexer$absAddToken)($start))($end))($kind))($state);
    });
    return ((":" === $chunk)
      ? ($add)($sp$Types$Token$Colon)
      : (("@:" === $chunk)
        ? ($add)($sp$Types$Token$MutableColon)
        : (("=" === $chunk)
          ? ($add)(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))
          : (("@=" === $chunk)
            ? ($add)(($sp$Types$Token$Defop)($sp$Types$Token$DefMutable))
            : (("-" === $chunk)
              ? ($add)(($nextIsSpace
                ? ($sp$Types$Token$Binop)($sp$Prelude$subtract)
                : ($sp$Types$Token$Unop)($sp$Prelude$unaryMinus)))
              : (("+" === $chunk)
                ? ($add)(($nextIsSpace
                  ? ($sp$Types$Token$Binop)($sp$Prelude$add)
                  : ($sp$Types$Token$Unop)($sp$Prelude$unaryPlus)))
                : (true
                  ? ((() => {
                    const $op = $chunk;
                    const $$try1 = (($corelib$Dict$get)($chunk))($sp$Prelude$binopsBySymbol);
                    return ((($$try1)[0] === "Just")
                      ? ((() => {
                        const $binop = ($$try1)[1];
                        return ($add)(($sp$Types$Token$Binop)($binop));
                      }))()
                      : ((($$try1)[0] === "Nothing")
                        ? (($sp$Compiler$Lexer$addError)(("Invalid operator: `" + ($chunk + "`"))))($state)
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 440:12', (sp_toHuman)($$try1))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 432:4', (sp_toHuman)($chunk)))))))));
  });
});

const $sp$Compiler$Lexer$addWordToken = (($modifier) => {
  return (($state) => {
    const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
    const $end = ($sp$Compiler$Lexer$getPos)($state);
    const $ds = (((sp_equal)($sp$Types$Token$NameNoModifier))($modifier)
      ? 0
      : 1);
    const $chunk = ((($sp$SPLib$Buffer$slice)(((sp_clone)(($state.obj)[$state.attr].tokenStart) + $ds)))($end))((sp_clone)(($state.obj)[$state.attr].buffer));
    const $maybeKeywordKind = (("if" === $chunk)
      ? ($corelib$Maybe$Just)($sp$Types$Token$If)
      : (("then" === $chunk)
        ? ($corelib$Maybe$Just)($sp$Types$Token$Then)
        : (("else" === $chunk)
          ? ($corelib$Maybe$Just)($sp$Types$Token$Else)
          : (("try" === $chunk)
            ? ($corelib$Maybe$Just)($sp$Types$Token$Try)
            : (("as" === $chunk)
              ? ($corelib$Maybe$Just)($sp$Types$Token$As)
              : (("with" === $chunk)
                ? ($corelib$Maybe$Just)($sp$Types$Token$With)
                : (("and" === $chunk)
                  ? ($corelib$Maybe$Just)(($sp$Types$Token$Binop)($sp$Prelude$and_))
                  : (("or" === $chunk)
                    ? ($corelib$Maybe$Just)(($sp$Types$Token$Binop)($sp$Prelude$or_))
                    : (true
                      ? $corelib$Maybe$Nothing
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 356:8', (sp_toHuman)($chunk)))))))))));
    const $$try1 = ({
      first: $maybeKeywordKind,
      second: $modifier,
    });
    return (((($$try1.first)[0] === "Just") && (($$try1.second)[0] === "NameNoModifier"))
      ? ((() => {
        const $kind = ($$try1.first)[1];
        return (((($sp$Compiler$Lexer$absAddToken)($start))($end))($kind))($state);
      }))()
      : ((($$try1.first)[0] === "Just")
        ? ((() => {
          const $kind = ($$try1.first)[1];
          return (($sp$Compiler$Lexer$addError)(($chunk + " as a keyword, you can't really use it this way")))($state);
        }))()
        : (true
          ? ((((($sp$Compiler$Lexer$addLowerOrUpperWord)($start))($end))($modifier))($chunk))($state)
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 367:4', (sp_toHuman)($$try1)))));
  });
});

const $sp$Compiler$Lexer$closeOpenBlocks = (($state) => {
  const $pos = ($sp$Compiler$Lexer$getPos)($state);
  return (($corelib$List$each)((sp_clone)(($state.obj)[$state.attr].indentStack)))((() => {
    return ((array_push)(({
      attr: "tokens",
      obj: ($state.obj)[$state.attr],
    })))(((($sp$Types$Token$Token)($pos))($pos))($sp$Types$Token$BlockEnd));
  }));
});

const $sp$Compiler$Lexer$isNumber = (($char) => {
  return ((sp_not_equal)(""))(((text_startsWithRegex)("[0-9_.]"))($char));
});

const $sp$Compiler$Lexer$isSquiggle = (($char) => {
  return (("=" === $char)
    ? true
    : ((":" === $char)
      ? true
      : (("*" === $char)
        ? true
        : (("+" === $char)
          ? true
          : (("-" === $char)
            ? true
            : (("/" === $char)
              ? true
              : ((">" === $char)
                ? true
                : (("<" === $char)
                  ? true
                  : (("!" === $char)
                    ? true
                    : (("&" === $char)
                      ? true
                      : (("^" === $char)
                        ? true
                        : (true
                          ? false
                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 408:4', (sp_toHuman)($char))))))))))))));
});

const $sp$Compiler$Lexer$isWordBody = (($char) => {
  return ((sp_not_equal)(""))(((text_startsWithRegex)("[a-zA-Z./_0-9]"))($char));
});

const $sp$Compiler$Lexer$isWordStart = (($char) => {
  return ((sp_not_equal)(""))(((text_startsWithRegex)("[a-zA-Z._]"))($char));
});

const $sp$Compiler$Lexer$setMode = (($mode) => {
  return (($state) => {
    return (($state.obj)[$state.attr].mode = $mode);
  });
});

const $sp$Compiler$Lexer$tryIndent = (($indentChar) => {
  return (($char) => {
    return (($state) => {
      return ((((sp_equal)($indentChar))($char) || ((sp_equal)(""))($char))
        ? null
        : ((((sp_equal)(" "))($char) || ((sp_equal)("\t"))($char))
          ? (($sp$Compiler$Lexer$addError)("mixing tabs and spaces!"))($state)
          : (((sp_equal)("\n"))($char)
            ? ((() => {
              (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1));
              return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Indent))($state);
            }))()
            : (((sp_equal)("#"))($char)
              ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$LineComment))($state)
              : ((() => {
                (($state.obj)[$state.attr].lineIndent = (sp_clone)(($state.obj)[$state.attr].column));
                (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                return (($sp$Compiler$Lexer$lexOne)($char))($state);
              }))()))));
    });
  });
});

const $sp$Compiler$Lexer$unindent = (($raw) => {
  return (($corelib$Basics$not)(((text_startsWith)("\n"))($raw))
    ? $raw
    : ((() => {
      const $multilineText = ((text_dropLeft)(1))($raw);
      const $lines = ((text_split)("\n"))($multilineText);
      const $countLeadingSpaces = (($line) => {
        return (text_length)(((text_startsWithRegex)("[ ]*"))($line));
      });
      const $minLead = (($corelib$Maybe$withDefault)(0))(($corelib$List$minimum)((($corelib$List$map)($countLeadingSpaces))((($corelib$List$filter)((($s) => {
        return ((sp_not_equal)(""))((text_trimLeft)($s));
      })))($lines))));
      return (((text_replaceRegex)("\n[ ]*$"))(""))((($corelib$Text$join)("\n"))((($corelib$List$map)((text_dropLeft)($minLead)))($lines)));
    }))());
});

const $sp$Compiler$Lexer$lexOne = (($char) => {
  return (($state) => {
    const $pos = ($sp$Compiler$Lexer$getPos)($state);
    const $$try1 = (sp_clone)(($state.obj)[$state.attr].mode);
    return ((($$try1)[0] === "Indent")
      ? ((() => {
        const $$try3 = (sp_clone)(($state.obj)[$state.attr].tabsOrSpaces);
        return ((($$try3)[0] === "Tabs")
          ? ((($sp$Compiler$Lexer$tryIndent)("\t"))($char))($state)
          : ((($$try3)[0] === "Spaces")
            ? ((($sp$Compiler$Lexer$tryIndent)(" "))($char))($state)
            : ((($$try3)[0] === "NoTabsOrSpacesYet")
              ? ((" " === $char)
                ? ((() => {
                  (($state.obj)[$state.attr].tabsOrSpaces = $sp$Compiler$Lexer$Spaces);
                  return (($sp$Compiler$Lexer$lexOne)($char))($state);
                }))()
                : (("\t" === $char)
                  ? ((() => {
                    (($state.obj)[$state.attr].tabsOrSpaces = $sp$Compiler$Lexer$Tabs);
                    return (($sp$Compiler$Lexer$lexOne)($char))($state);
                  }))()
                  : (true
                    ? ((($sp$Compiler$Lexer$tryIndent)(" "))($char))($state)
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 492:14', (sp_toHuman)($char)))))
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 484:10', (sp_toHuman)($$try3)))));
      }))()
      : ((($$try1)[0] === "Default")
        ? (("" === $char)
          ? null
          : (("." === $char)
            ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Dot))($state)
            : (("@" === $char)
              ? ((() => {
                (($state.obj)[$state.attr].tokenStart = ($sp$Compiler$Lexer$getPos)($state));
                return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Mutable))($state);
              }))()
              : (("#" === $char)
                ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$LineComment))($state)
                : (("[" === $char)
                  ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningBlockComment))($state)
                  : (("\"" === $char)
                    ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningQuotes_One))($state)
                    : (("\n" === $char)
                      ? ((() => {
                        (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1));
                        (($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine = true);
                        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Indent))($state);
                      }))()
                      : ((" " === $char)
                        ? (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1))
                        : (true
                          ? ((() => {
                            (($state.obj)[$state.attr].tokenStart = ($sp$Compiler$Lexer$getPos)($state));
                            return (($sp$Compiler$Lexer$isWordStart)($char)
                              ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameNoModifier)))($state)
                              : (($sp$Compiler$Lexer$isNumber)($char)
                                ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$NumberLiteral))($state)
                                : (($sp$Compiler$Lexer$isSquiggle)($char)
                                  ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Squiggles))($state)
                                  : (($sp$Compiler$Lexer$addParenOrCommaToken)($char))($state))));
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 503:10', (sp_toHuman)($char)))))))))))
        : ((($$try1)[0] === "Dot")
          ? (((sp_equal)("."))($char)
            ? ((() => {
              (((($sp$Compiler$Lexer$relAddToken)((0 - 1)))(1))(($sp$Types$Token$Binop)($sp$Prelude$textConcat)))($state);
              return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
            }))()
            : (($sp$Compiler$Lexer$isWordStart)($char)
              ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameStartsWithDot)))($state)
              : (($sp$Compiler$Lexer$isNumber)($char)
                ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$NumberLiteral))($state)
                : (($sp$Compiler$Lexer$addError)("no idea what this is"))($state))))
          : ((($$try1)[0] === "Mutable")
            ? (($sp$Compiler$Lexer$isWordStart)($char)
              ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameMutable)))($state)
              : (($sp$Compiler$Lexer$isSquiggle)($char)
                ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Squiggles))($state)
                : (($sp$Compiler$Lexer$addError)("no idea what this is"))($state)))
            : ((($$try1)[0] === "Word")
              ? ((() => {
                const $modifier = ($$try1)[1];
                return (($sp$Compiler$Lexer$isWordBody)($char)
                  ? null
                  : ((() => {
                    (($sp$Compiler$Lexer$addWordToken)($modifier))($state);
                    (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                    return (($sp$Compiler$Lexer$lexOne)($char))($state);
                  }))());
              }))()
              : ((($$try1)[0] === "NumberLiteral")
                ? (($sp$Compiler$Lexer$isNumber)($char)
                  ? null
                  : ((() => {
                    ($sp$Compiler$Lexer$addNumberToken)($state);
                    (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                    return (($sp$Compiler$Lexer$lexOne)($char))($state);
                  }))())
                : ((($$try1)[0] === "Squiggles")
                  ? (($sp$Compiler$Lexer$isSquiggle)($char)
                    ? null
                    : ((() => {
                      (($sp$Compiler$Lexer$addSquiggleToken)(((sp_equal)(" "))($char)))($state);
                      (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                      return (($sp$Compiler$Lexer$lexOne)($char))($state);
                    }))())
                  : ((($$try1)[0] === "ContentOpeningQuotes_One")
                    ? (((sp_equal)("\""))($char)
                      ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningQuotes_Two))($state)
                      : (((sp_equal)(""))($char)
                        ? (($sp$Compiler$Lexer$addError)("there's no closing quotes"))($state)
                        : ((() => {
                          (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) - 1));
                          (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
                            lastEscape: -(1),
                          }))))($state);
                          return (($sp$Compiler$Lexer$lexOne)($char))($state);
                        }))()))
                    : ((($$try1)[0] === "ContentOpeningQuotes_Two")
                      ? (((sp_equal)("\""))($char)
                        ? ((() => {
                          (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) - 2));
                          return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                            closingQuotes: 0,
                            lastEscape: -(1),
                          }))))($state);
                        }))()
                        : ((() => {
                          (((($sp$Compiler$Lexer$relAddToken)((0 - 2)))(0))(($sp$Types$Token$TextLiteral)("")))($state);
                          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                          return (($sp$Compiler$Lexer$lexOne)($char))($state);
                        }))())
                      : ((($$try1)[0] === "SingleQuote")
                        ? ((() => {
                          const $lastEscape = ($$try1)[1].lastEscape;
                          const $previousIsEscape = ((sp_equal)(($lastEscape + 1)))($pos);
                          return (((sp_equal)(""))($char)
                            ? (($sp$Compiler$Lexer$addError)("there's no closing quotes"))($state)
                            : ($previousIsEscape
                              ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
                                lastEscape: $lastEscape,
                              }))))($state)
                              : (("\"" === $char)
                                ? ((() => {
                                  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
                                  const $end = ($pos + 1);
                                  const $value = ((($corelib$Text$replace)("\\\""))("\""))(((($sp$SPLib$Buffer$slice)(($start + 1)))(($end - 1)))((sp_clone)(($state.obj)[$state.attr].buffer)));
                                  (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$TextLiteral)($value)))($state);
                                  return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                                }))()
                                : (("\\" === $char)
                                  ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
                                    lastEscape: $pos,
                                  }))))($state)
                                  : (true
                                    ? null
                                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 629:12', (sp_toHuman)($char)))))));
                        }))()
                        : ((($$try1)[0] === "TripleQuote")
                          ? ((() => {
                            const $closingQuotes = ($$try1)[1].closingQuotes;
                            const $lastEscape = ($$try1)[1].lastEscape;
                            const $previousIsEscape = ((sp_equal)(($lastEscape + 1)))($pos);
                            return (((sp_equal)(""))($char)
                              ? (($sp$Compiler$Lexer$addError)("unterminated triple quotes"))($state)
                              : ($previousIsEscape
                                ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                                  closingQuotes: 0,
                                  lastEscape: $lastEscape,
                                }))))($state)
                                : (("\"" === $char)
                                  ? (((sp_equal)(2))($closingQuotes)
                                    ? ((() => {
                                      const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
                                      const $end = ($pos + 1);
                                      const $value = ($sp$Compiler$Lexer$unindent)(((($sp$SPLib$Buffer$slice)(($start + 3)))(($end - 3)))((sp_clone)(($state.obj)[$state.attr].buffer)));
                                      (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$TextLiteral)($value)))($state);
                                      return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                                    }))()
                                    : (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                                      closingQuotes: ($closingQuotes + 1),
                                      lastEscape: $lastEscape,
                                    }))))($state))
                                  : (("\\" === $char)
                                    ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                                      closingQuotes: 0,
                                      lastEscape: $pos,
                                    }))))($state)
                                    : (true
                                      ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                                        closingQuotes: 0,
                                        lastEscape: $lastEscape,
                                      }))))($state)
                                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 669:13', (sp_toHuman)($char)))))));
                          }))()
                          : ((($$try1)[0] === "LineComment")
                            ? ((((sp_equal)("\n"))($char) || ((sp_equal)(""))($char))
                              ? ((() => {
                                (((($sp$Compiler$Lexer$absAddToken)((sp_clone)(($state.obj)[$state.attr].tokenStart)))(($sp$Compiler$Lexer$getPos)($state)))($sp$Types$Token$Comment))($state);
                                (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                                return (($sp$Compiler$Lexer$lexOne)($char))($state);
                              }))()
                              : null)
                            : ((($$try1)[0] === "ContentOpeningBlockComment")
                              ? (((sp_equal)("#"))($char)
                                ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$BlockComment)(({
                                  nesting: 1,
                                  previous: "",
                                }))))($state)
                                : ((() => {
                                  (((($sp$Compiler$Lexer$relAddToken)((0 - 1)))(0))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))($state);
                                  (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                                  return (($sp$Compiler$Lexer$lexOne)($char))($state);
                                }))())
                              : ((($$try1)[0] === "BlockComment")
                                ? ((() => {
                                  const $nesting = ($$try1)[1].nesting;
                                  const $previous = ($$try1)[1].previous;
                                  const $continueWithDeltaNesting = (($dn) => {
                                    return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$BlockComment)(({
                                      nesting: ($nesting + $dn),
                                      previous: $char,
                                    }))))($state);
                                  });
                                  const $$try2 = ({
                                    first: $previous,
                                    second: $char,
                                  });
                                  return ((("[" === $$try2.first) && ("#" === $$try2.second))
                                    ? ($continueWithDeltaNesting)(1)
                                    : ((("#" === $$try2.first) && ("]" === $$try2.second))
                                      ? (($nesting > 1)
                                        ? ($continueWithDeltaNesting)((0 - 1))
                                        : ((() => {
                                          (((($sp$Compiler$Lexer$absAddToken)((sp_clone)(($state.obj)[$state.attr].tokenStart)))(($sp$Compiler$Lexer$getPos)($state)))($sp$Types$Token$Comment))($state);
                                          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                                        }))())
                                      : (("" === $$try2.second)
                                        ? (($sp$Compiler$Lexer$addError)("unterminated block comment"))($state)
                                        : (true
                                          ? ($continueWithDeltaNesting)(0)
                                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 713:10', (sp_toHuman)($$try2))))));
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 481:4', (sp_toHuman)($$try1))))))))))))))));
  });
});

const $sp$SPLib$Buffer$init = (($s) => {
  return ({
    fullSize: (text_length)($s),
    fullText: $s,
    nextPos: 0,
  });
});

const $sp$Compiler$Lexer$readStateInit = (($moduleName) => {
  return (($moduleCode) => {
    return ({
      buffer: ($sp$SPLib$Buffer$init)($moduleCode),
      column: 0,
      errors: $core$SPCore$Nil,
      indentStack: $core$SPCore$Nil,
      indentStartsABlock: true,
      line: 0,
      lineIndent: 0,
      mode: $sp$Compiler$Lexer$Indent,
      moduleName: $moduleName,
      soFarThereAreNoTokensInThisLine: true,
      tabsOrSpaces: $sp$Compiler$Lexer$NoTabsOrSpacesYet,
      tokenStart: 0,
      tokens: (array_fromList)($core$SPCore$Nil),
    });
  });
});

const $sp$Compiler$Lexer$lexer = (($moduleName) => {
  return (($moduleCode) => {
    (sp_benchStart)(null);
    const $state = ({
      attr: "$",
      obj: ({
        $: (sp_clone)((($sp$Compiler$Lexer$readStateInit)($moduleName))($moduleCode)),
      }),
    });
    ((text_forEach)($moduleCode))((($char) => {
      (($sp$Compiler$Lexer$lexOne)($char))($state);
      (($state.obj)[$state.attr].buffer.nextPos += 1);
      return (((sp_equal)("\n"))($char)
        ? ((() => {
          (($state.obj)[$state.attr].line += 1);
          return (($state.obj)[$state.attr].column = 0);
        }))()
        : (($state.obj)[$state.attr].column += 1));
    }));
    (($sp$Compiler$Lexer$lexOne)(""))($state);
    return (((sp_equal)($core$SPCore$Nil))((sp_clone)(($state.obj)[$state.attr].errors))
      ? ((() => {
        ($sp$Compiler$Lexer$closeOpenBlocks)($state);
        return ((($corelib$Basics$btw)(sp_benchStop))("lexer"))(($corelib$Result$Ok)((array_toList)((sp_clone)(($state.obj)[$state.attr].tokens))));
      }))()
      : ((($corelib$Basics$btw)(sp_benchStop))("lexer"))(($corelib$Result$Err)(($sp$Compiler$Error$Nested)((sp_clone)(($state.obj)[$state.attr].errors)))));
  });
});

const $sp$Compiler$Lexer_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$TestHelpers$moduleName = "(test)";

const $sp$Compiler$TestHelpers$dummyErrorEnv = (($code) => {
  return ({
    moduleByName: (($corelib$Dict$singleton)($sp$Compiler$TestHelpers$moduleName))(({
      content: $code,
      fsPath: "<TestPath>",
    })),
  });
});

const $sp$Compiler$TestHelpers$formattedToStrippedText = (($formatted) => {
  const $strip = (($fmt) => {
    return ((($fmt)[0] === "FormattedText_Default")
      ? ((() => {
        const $t = ($fmt)[1];
        return $t;
      }))()
      : ((($fmt)[0] === "FormattedText_Emphasys")
        ? ((() => {
          const $t = ($fmt)[1];
          return $t;
        }))()
        : ((($fmt)[0] === "FormattedText_Warning")
          ? ((() => {
            const $t = ($fmt)[1];
            return $t;
          }))()
          : ((($fmt)[0] === "FormattedText_Decoration")
            ? ((() => {
              const $t = ($fmt)[1];
              return $t;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TestHelpers.sp 62:8', (sp_toHuman)($fmt))))));
  });
  return (($corelib$Text$join)(""))((($corelib$List$map)($strip))($formatted));
});

const $sp$Compiler$TestHelpers$resErrorToStrippedText = (($code) => {
  return ($corelib$Result$mapError)((($e) => {
    return ($sp$Compiler$TestHelpers$formattedToStrippedText)((($sp$Compiler$Error$toFormattedText)(($sp$Compiler$TestHelpers$dummyErrorEnv)($code)))($e));
  }));
});

const $sp$Compiler$Lexer_Test$lexTokens = (($s) => {
  return (($sp$Compiler$TestHelpers$resErrorToStrippedText)($s))((($sp$Compiler$Lexer$lexer)($sp$Compiler$TestHelpers$moduleName))($s));
});

const $sp$Compiler$Lexer_Test$non_mut_name = (($n) => {
  return (((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))($n))($core$SPCore$Nil);
});

const $sp$Compiler$Lexer_Test$comments = (($sp$Test$Group)("Comments"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] statement after comment"))("\n#\na = 1\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(3))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(5))(6))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] nested comments allow a spurious newline?"))("\n[#[##]#]\na = 1\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(8))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(10))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(11))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(14))(15))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Single line"))("# hello"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(7))($sp$Types$Token$Comment)))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Multi line"))("[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(16))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(19))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(20))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(32))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(34))(35))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(36))(37))(($sp$Types$Token$NumberLiteral)("1"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(58))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(61))(78))($sp$Types$Token$Comment)))($core$SPCore$Nil))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("brackets"))("[]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] Inline comments should not break a block"))("allTests = [\n    , a\n#\n    ]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(8))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("allTests"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(9))(10))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(11))(12))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(17))(18))($sp$Types$Token$Comma)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(20))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("a"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(22))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(27))(28))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(28))(28))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil)))))))))))))($core$SPCore$Nil)))))));

const $sp$Compiler$Lexer_Test$indentation = (($sp$Test$Group)("Blocks, sibling lines, indentation"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("1"))("\na =\n 1\nb = 1"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(1))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(6))(6))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(6))(7))(($sp$Types$Token$NumberLiteral)("1"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(8))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(8))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(9))(($sp$Compiler$Lexer_Test$non_mut_name)("b"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(11))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil))))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] spurious spaces in front of field name"))("module =\n   importAs =\n      SPCore\n   globalTypes =\n      None"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("module"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(12))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(20))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("importAs"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(22))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(29))(29))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(29))(35))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("SPCore"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(39))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(39))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(50))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("globalTypes"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(51))(52))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(59))(59))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(59))(63))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("None"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(63))(63))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(63))(63))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil))))))))))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Blocks and not"))((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("module ="))((($core$SPCore$Cons)("   i ="))((($core$SPCore$Cons)("        j"))((($core$SPCore$Cons)("            >> k"))((($core$SPCore$Cons)("            >> s"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   importAs ="))((($core$SPCore$Cons)("      SPCore"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   globalTypes ="))((($core$SPCore$Cons)("      None"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   a +     # no block start!"))((($core$SPCore$Cons)("        b   # no sibling"))((($core$SPCore$Cons)("        c"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   d =     # block start"))((($core$SPCore$Cons)("        e   # sibling!"))((($core$SPCore$Cons)("        f"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   g = h"))($core$SPCore$Nil))))))))))))))))))))))))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("module"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(12))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("i"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(14))(15))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(24))(24))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(24))(25))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("j"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(38))(40))(($sp$Types$Token$Binop)($sp$Prelude$sendRight))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(41))(42))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("k"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(55))(57))(($sp$Types$Token$Binop)($sp$Prelude$sendRight))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(58))(59))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("s"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(64))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(64))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(72))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("importAs"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(73))(74))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(81))(81))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(81))(87))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("SPCore"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(92))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(92))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(103))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("globalTypes"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(104))(105))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(112))(112))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(112))(116))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("None"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(121))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(121))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(122))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("a"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(123))(124))(($sp$Types$Token$Binop)($sp$Prelude$add))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(129))(146))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(155))(156))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(159))(171))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(180))(181))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(186))(186))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(186))(187))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("d"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(188))(189))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(194))(207))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(216))(216))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(216))(217))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("e"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(220))(230))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(239))(239))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(239))(240))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("f"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(245))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(245))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(246))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("g"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(247))(248))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(249))(250))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("h"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(250))(250))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))($core$SPCore$Nil))));

const $sp$Compiler$Lexer_Test$keywords = (($sp$Test$Group)("keywords"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] can't @ keywords"))("@with"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("keyword"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$lexTokensAndDrop = (($n) => {
  return (($s) => {
    return (($corelib$Result$map)(($corelib$List$drop)($n)))(($sp$Compiler$Lexer_Test$lexTokens)($s));
  });
});

const $sp$Compiler$Lexer_Test$ops = (($sp$Test$Group)("Operators"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] .. set Default"))(".. []"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$Binop)($sp$Prelude$textConcat))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(4))(5))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))($core$SPCore$Nil))))))))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$position = (($sp$Test$Group)("Position"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] ops position"))("blah <>"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah <>"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] ops position, with newline"))("blah <>\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah <>"))($core$SPCore$Nil)))))($core$SPCore$Nil)));

const $sp$Compiler$Lexer_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $sp$Compiler$Lexer_Test$textLiterals = (($sp$Test$Group)("Text literals"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Empty Text"))("\"\""))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$TextLiteral)(""))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Followed by colon"))("\"n\":\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(3))(($sp$Types$Token$TextLiteral)("n"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))($sp$Types$Token$Colon)))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] should not add the indent!"))("try char as\n    \"\":\n        None\n\n    \"@\""))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(11)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(38))(41))(($sp$Types$Token$TextLiteral)("@"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(41))(41))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($sp$Compiler$Lexer_Test$valueTest)("Unindent function"))((() => {
  return ($sp$Compiler$Lexer$unindent)((($corelib$Text$join)(""))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("  a\n"))((($core$SPCore$Cons)("      \n"))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("  b\n"))((($core$SPCore$Cons)("  "))($core$SPCore$Nil))))))));
})))(($sp$Test$isOkAndEqualTo)((($corelib$Text$join)(""))((($core$SPCore$Cons)("a\n"))((($core$SPCore$Cons)("    \n"))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("b"))($core$SPCore$Nil)))))))))($core$SPCore$Nil)))));

const $sp$Compiler$Lexer_Test$unaryAddittiveOps = (($sp$Test$Group)("Unary addittive ops"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("-a"))("-a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("a - -a"))("a - -a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(2))(3))(($sp$Types$Token$Binop)($sp$Prelude$subtract))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(4))(5))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(5))(6))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("a-a"))("a-a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(2))(3))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Mutable colon:"))("@:"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))($sp$Types$Token$MutableColon)))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("-="))("-="))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$Binop)($sp$Prelude$mutableSubtract))))($core$SPCore$Nil))))))($core$SPCore$Nil))))));

const $sp$Compiler$Lexer_Test$underscores = (($sp$Test$Group)("Underscores"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'_' as a Name"))("_"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("_"))($core$SPCore$Nil))))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'_10_20' as a Name"))("_10_20"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("_10_20"))($core$SPCore$Nil))))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'10_20' as a Number"))("10_20"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(5))(($sp$Types$Token$NumberLiteral)("10_20"))))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$Lexer_Test$tests = (($sp$Test$Group)("Lexer"))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$keywords))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$ops))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$unaryAddittiveOps))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$indentation))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$comments))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$underscores))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$position))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$textLiterals))($core$SPCore$Nil)))))))));

const $sp$Compiler$MakeCanonical$makeError = (($pos) => {
  return (($msg) => {
    return (($sp$Compiler$Error$res)($pos))((($errorEnv) => {
      return $msg;
    }));
  });
});

const $sp$Compiler$MakeCanonical$maybeForeignUsr = (($getter) => {
  return (($ro) => {
    return (($maybeModule) => {
      return (($name) => {
        return ((($maybeModule)[0] === "Just")
          ? ((() => {
            const $moduleName = ($maybeModule)[1];
            const $$try1 = (($corelib$Dict$get)($moduleName))($ro.meta.moduleVisibleAsToUmr);
            return ((($$try1)[0] === "Just")
              ? ((() => {
                const $umr = ($$try1)[1];
                return ($corelib$Maybe$Just)((($sp$Types$Meta$USR)($umr))($name));
              }))()
              : ((($$try1)[0] === "Nothing")
                ? (sp_todo)(("!!resolveToUsr can't find the module: " + ($moduleName + (" (for: " + ($name + ")")))))
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 105:12', (sp_toHuman)($$try1))));
          }))()
          : ((($maybeModule)[0] === "Nothing")
            ? (($corelib$Dict$get)($name))(($getter)($ro.meta))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 103:4', (sp_toHuman)($maybeModule))));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToUsr = (($getter) => {
  return (($ro) => {
    return (($maybeModule) => {
      return (($name) => {
        return (($corelib$Maybe$withDefault)((($sp$Types$Meta$USR)($ro.currentModule))($name)))((((($sp$Compiler$MakeCanonical$maybeForeignUsr)($getter))($ro))($maybeModule))($name));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToTypeUsr = ($sp$Compiler$MakeCanonical$resolveToUsr)((($m) => {
  return $m.globalTypes;
}));

const $sp$Compiler$MakeCanonical$translateType = (($mrf) => {
  return (($ro) => {
    return (($faType) => {
      return ((($faType)[0] === "TypeVariable")
        ? ((() => {
          const $pos = ($faType)[1];
          const $name = ($faType)[2];
          return ((($mrf)[0] === "Nothing")
            ? ($corelib$Result$Ok)((($sp$Types$CanonicalAst$TypeVariable)($pos))($name))
            : ((($mrf)[0] === "Just")
              ? ((() => {
                const $renameFunction = ($mrf)[1];
                return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$TypeVariable)($pos))((($renameFunction)($pos))($name)));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 916:12', (sp_toHuman)($mrf))));
        }))()
        : ((($faType)[0] === "TypeConstant")
          ? ((() => {
            const $pos = ($faType)[1];
            const $maybeModule = ($faType)[2];
            const $name = ($faType)[3];
            const $args = ($faType)[4];
            return (($corelib$Result$onOk)((($caArgs) => {
              return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeConstant)($pos))(((($sp$Compiler$MakeCanonical$resolveToTypeUsr)($ro))($maybeModule))($name)))($caArgs));
            })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro)))($args));
          }))()
          : ((($faType)[0] === "TypeFunction")
            ? ((() => {
              const $pos = ($faType)[1];
              const $fa_from = ($faType)[2];
              const $fromIsMut = ($faType)[3];
              const $fa_to = ($faType)[4];
              return (($corelib$Result$onOk)((($ca_from) => {
                return (($corelib$Result$onOk)((($ca_to) => {
                  return ($corelib$Result$Ok)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($ca_from))($fromIsMut))($ca_to));
                })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($fa_to));
              })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($fa_from));
            }))()
            : ((($faType)[0] === "TypeTuple")
              ? ((() => {
                const $pos = ($faType)[1];
                const $types = ($faType)[2];
                return (((($types)[0] === "Cons") && (((($types)[2])[0] === "Cons") && (((($types)[2])[2])[0] === "Nil")))
                  ? ((() => {
                    const $faFirst = ($types)[1];
                    const $faSecond = (($types)[2])[1];
                    return (($corelib$Result$onOk)((($caFirst) => {
                      return (($corelib$Result$onOk)((($caSecond) => {
                        return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($caSecond))(((($corelib$Dict$insert)("first"))($caFirst))($corelib$Dict$empty))));
                      })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faSecond));
                    })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faFirst));
                  }))()
                  : (((($types)[0] === "Cons") && (((($types)[2])[0] === "Cons") && ((((($types)[2])[2])[0] === "Cons") && ((((($types)[2])[2])[2])[0] === "Nil"))))
                    ? ((() => {
                      const $faFirst = ($types)[1];
                      const $faSecond = (($types)[2])[1];
                      const $faThird = ((($types)[2])[2])[1];
                      return (($corelib$Result$onOk)((($caFirst) => {
                        return (($corelib$Result$onOk)((($caSecond) => {
                          return (($corelib$Result$onOk)((($caThird) => {
                            return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("third"))($caThird))(((($corelib$Dict$insert)("second"))($caSecond))(((($corelib$Dict$insert)("first"))($caFirst))($corelib$Dict$empty)))));
                          })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faThird));
                        })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faSecond));
                      })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faFirst));
                    }))()
                    : (true
                      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Tuples can only have size 2 or 3. Use a record."))($core$SPCore$Nil))
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 935:12', (sp_toHuman)($types)))));
              }))()
              : ((($faType)[0] === "TypeList")
                ? ((() => {
                  const $pos = ($faType)[1];
                  const $faItem = ($faType)[2];
                  return (($corelib$Result$onOk)((($caItem) => {
                    return ($corelib$Result$Ok)(($sp$Compiler$CoreTypes$list)($caItem));
                  })))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faItem));
                }))()
                : ((($faType)[0] === "TypeRecord")
                  ? ((() => {
                    const $p = ($faType)[1];
                    const $recordArgs = ($faType)[2];
                    return (((sp_not_equal)($corelib$Maybe$Nothing))($recordArgs.extends)
                      ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)("For now extensible types are disabled, I want to see if it's good to do without them"))($core$SPCore$Nil))
                      : (((($sp$Compiler$MakeCanonical$addAttributes)($ro))($p))($recordArgs.attrs))($corelib$Dict$empty));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 914:4', (sp_toHuman)($faType))))))));
    });
  });
});

const $sp$Compiler$MakeCanonical$addAttributes = (($ro) => {
  return (($pos) => {
    return (($faAttrs) => {
      return (($caAttrsAccum) => {
        return ((($faAttrs)[0] === "Nil")
          ? ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($caAttrsAccum))
          : (((($faAttrs)[0] === "Cons") && ((($faAttrs)[1].first)[0] === "At"))
            ? ((() => {
              const $p = (($faAttrs)[1].first)[1];
              const $name = (($faAttrs)[1].first)[2];
              const $maybeFaType = ($faAttrs)[1].second;
              const $faTail = ($faAttrs)[2];
              return ((($maybeFaType)[0] === "Nothing")
                ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)(("Attribute `" + ($name + "` must have a type"))))($core$SPCore$Nil))
                : ((($maybeFaType)[0] === "Just")
                  ? ((() => {
                    const $faType = ($maybeFaType)[1];
                    return (($corelib$Result$onOk)((($caType) => {
                      return (((($sp$Compiler$MakeCanonical$addAttributes)($ro))($p))($faTail))(((($corelib$Dict$insert)($name))($caType))($caAttrsAccum));
                    })))(((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro))($faType));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 899:12', (sp_toHuman)($maybeFaType))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 893:4', (sp_toHuman)($faAttrs))));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$deps_init = ({
  cons: $corelib$Set$empty,
  types: $corelib$Set$empty,
  values: $corelib$Set$empty,
});

const $sp$Compiler$MakeCanonical$typeDeps = (($type) => {
  return (($acc) => {
    return ((($type)[0] === "TypeConstant")
      ? ((() => {
        const $usr = ($type)[2];
        const $args = ($type)[3];
        return ((($corelib$List$for)($args))($sp$Compiler$MakeCanonical$typeDeps))((($corelib$Set$insert)($usr))($acc));
      }))()
      : ((($type)[0] === "TypeVariable")
        ? $acc
        : ((($type)[0] === "TypeFunction")
          ? ((() => {
            const $from = ($type)[2];
            const $to = ($type)[4];
            return (($sp$Compiler$MakeCanonical$typeDeps)($to))((($sp$Compiler$MakeCanonical$typeDeps)($from))($acc));
          }))()
          : ((($type)[0] === "TypeRecord")
            ? ((() => {
              const $attrs = ($type)[3];
              return ((($corelib$Dict$for)($attrs))((($k) => {
                return $sp$Compiler$MakeCanonical$typeDeps;
              })))($acc);
            }))()
            : ((($type)[0] === "TypeAlias")
              ? (sp_todo)("typeDeps: Should not happen")
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 158:4', (sp_toHuman)($type)))))));
  });
});

const $sp$Compiler$MakeCanonical$patternDeps = (($pattern) => {
  return (($deps) => {
    return ((($pattern)[0] === "PatternConstructor")
      ? ((() => {
        const $usr = ($pattern)[2];
        const $ps = ($pattern)[3];
        return ((($corelib$List$for)($ps))($sp$Compiler$MakeCanonical$patternDeps))((Object.assign)({}, $deps, ({
          cons: (($corelib$Set$insert)($usr))($deps.cons),
        })));
      }))()
      : ((($pattern)[0] === "PatternRecord")
        ? ((() => {
          const $ps = ($pattern)[2];
          return ((($corelib$Dict$for)($ps))((($k) => {
            return $sp$Compiler$MakeCanonical$patternDeps;
          })))($deps);
        }))()
        : (((($pattern)[0] === "PatternAny") && ((($pattern)[3])[0] === "Just"))
          ? ((() => {
            const $type = (($pattern)[3])[1];
            return (Object.assign)({}, $deps, ({
              types: (($sp$Compiler$MakeCanonical$typeDeps)($type))($deps.types),
            }));
          }))()
          : (((($pattern)[0] === "PatternAny") && ((($pattern)[3])[0] === "Nothing"))
            ? $deps
            : ((($pattern)[0] === "PatternLiteralNumber")
              ? $deps
              : ((($pattern)[0] === "PatternLiteralText")
                ? $deps
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 182:4', (sp_toHuman)($pattern))))))));
  });
});

const $sp$Compiler$MakeCanonical$expressionDeps = (($expr) => {
  return (($deps) => {
    return ((($expr)[0] === "LiteralNumber")
      ? $deps
      : ((($expr)[0] === "LiteralText")
        ? $deps
        : (((($expr)[0] === "Variable") && ((($expr)[2].ref)[0] === "RefRoot"))
          ? ((() => {
            const $attrPath = ($expr)[2].attrPath;
            const $usr = (($expr)[2].ref)[1];
            return (Object.assign)({}, $deps, ({
              values: (($corelib$Set$insert)($usr))($deps.values),
            }));
          }))()
          : ((($expr)[0] === "Variable")
            ? $deps
            : ((($expr)[0] === "Constructor")
              ? ((() => {
                const $usr = ($expr)[2];
                return (Object.assign)({}, $deps, ({
                  cons: (($corelib$Set$insert)($usr))($deps.cons),
                }));
              }))()
              : (((($expr)[0] === "Lambda") && ((($expr)[2])[0] === "ParameterPattern"))
                ? ((() => {
                  const $pa = (($expr)[2])[1];
                  const $body = ($expr)[3];
                  return (($sp$Compiler$MakeCanonical$expressionDeps)($body))((($sp$Compiler$MakeCanonical$patternDeps)($pa))($deps));
                }))()
                : (((($expr)[0] === "Lambda") && ((($expr)[2])[0] === "ParameterMutable"))
                  ? ((() => {
                    const $body = ($expr)[3];
                    return (($sp$Compiler$MakeCanonical$expressionDeps)($body))($deps);
                  }))()
                  : (((($expr)[0] === "Record") && ((($expr)[2])[0] === "Nothing"))
                    ? ((() => {
                      const $exprByName = ($expr)[3];
                      return ((($corelib$Dict$for)($exprByName))((($name) => {
                        return $sp$Compiler$MakeCanonical$expressionDeps;
                      })))($deps);
                    }))()
                    : (((($expr)[0] === "Record") && (((($expr)[2])[0] === "Just") && (((($expr)[2])[1].ref)[0] === "RefRoot")))
                      ? ((() => {
                        const $attrPath = (($expr)[2])[1].attrPath;
                        const $usr = ((($expr)[2])[1].ref)[1];
                        const $exprByName = ($expr)[3];
                        return ((($corelib$Dict$for)($exprByName))((($name) => {
                          return $sp$Compiler$MakeCanonical$expressionDeps;
                        })))((Object.assign)({}, $deps, ({
                          values: (($corelib$Set$insert)($usr))($deps.values),
                        })));
                      }))()
                      : ((($expr)[0] === "Record")
                        ? ((() => {
                          const $exprByName = ($expr)[3];
                          return ((($corelib$Dict$for)($exprByName))((($name) => {
                            return $sp$Compiler$MakeCanonical$expressionDeps;
                          })))($deps);
                        }))()
                        : (((($expr)[0] === "Call") && ((($expr)[3])[0] === "ArgumentExpression"))
                          ? ((() => {
                            const $e0 = ($expr)[2];
                            const $e1 = (($expr)[3])[1];
                            return (($sp$Compiler$MakeCanonical$expressionDeps)($e1))((($sp$Compiler$MakeCanonical$expressionDeps)($e0))($deps));
                          }))()
                          : (((($expr)[0] === "Call") && ((($expr)[3])[0] === "ArgumentMutable"))
                            ? ((() => {
                              const $e0 = ($expr)[2];
                              return (($sp$Compiler$MakeCanonical$expressionDeps)($e0))($deps);
                            }))()
                            : ((($expr)[0] === "If")
                              ? ((() => {
                                const $args = ($expr)[2];
                                return (($sp$Compiler$MakeCanonical$expressionDeps)($args.false))((($sp$Compiler$MakeCanonical$expressionDeps)($args.true))((($sp$Compiler$MakeCanonical$expressionDeps)($args.condition))($deps)));
                              }))()
                              : ((($expr)[0] === "Try")
                                ? ((() => {
                                  const $e = ($expr)[2];
                                  const $patternsAndBodies = ($expr)[3];
                                  return ((($corelib$List$for)($patternsAndBodies))((($$b) => {
                                    const $p = $$b.first;
                                    const $b = $$b.second;
                                    return (($d) => {
                                      return (($sp$Compiler$MakeCanonical$expressionDeps)($b))((($sp$Compiler$MakeCanonical$patternDeps)($p))($d));
                                    });
                                  })))((($sp$Compiler$MakeCanonical$expressionDeps)($e))($deps));
                                }))()
                                : ((($expr)[0] === "LetIn")
                                  ? ((() => {
                                    const $valueDef = ($expr)[1];
                                    const $e = ($expr)[2];
                                    return (($sp$Compiler$MakeCanonical$expressionDeps)($e))((($sp$Compiler$MakeCanonical$expressionDeps)($valueDef.body))((($sp$Compiler$MakeCanonical$patternDeps)($valueDef.pattern))($deps)));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 193:4', (sp_toHuman)($expr)))))))))))))))));
  });
});

const $sp$Compiler$MakeCanonical$initEnv = (($ro) => {
  return ({
    defsPath: $core$SPCore$Nil,
    maybeShorthandTarget: $corelib$Maybe$Nothing,
    nonRootValues: $corelib$Dict$empty,
    ro: $ro,
    tyvarRenames: $corelib$Dict$empty,
  });
});

const $sp$Types$CanonicalAst$patternNames = (($p) => {
  return (((($p)[0] === "PatternAny") && ((($p)[2])[0] === "Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return $corelib$Dict$empty;
    }))()
    : (((($p)[0] === "PatternAny") && ((($p)[2])[0] === "Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $n = (($p)[2])[1];
        return (($corelib$Dict$singleton)($n))($pos);
      }))()
      : ((($p)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return $corelib$Dict$empty;
        }))()
        : ((($p)[0] === "PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return $corelib$Dict$empty;
          }))()
          : ((($p)[0] === "PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $path = ($p)[2];
              const $ps = ($p)[3];
              return ((($corelib$List$for)($ps))((($x) => {
                return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($x));
              })))($corelib$Dict$empty);
            }))()
            : ((($p)[0] === "PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[2];
                return ((($corelib$Dict$for)($ps))((($k) => {
                  return (($v) => {
                    return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($v));
                  });
                })))($corelib$Dict$empty);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 212:4', (sp_toHuman)($p))))))));
});

const $sp$Compiler$MakeCanonical$insertParamNames = (($param) => {
  return ((($param)[0] === "ParameterMutable")
    ? ((() => {
      const $pos = ($param)[1];
      const $n = ($param)[2];
      return (($corelib$Dict$insert)($n))($pos);
    }))()
    : ((($param)[0] === "ParameterPattern")
      ? ((() => {
        const $pa = ($param)[1];
        return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($pa));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 264:4', (sp_toHuman)($param))));
});

const $sp$Compiler$MakeCanonical$translateConstructor = (($ro) => {
  return (($unionType) => {
    return (($unionUsr) => {
      return (($$faArgs) => {
        const $pos = ($$faArgs.first)[1];
        const $name = ($$faArgs.first)[2];
        const $faArgs = $$faArgs.second;
        return (($constructors) => {
          return ((($corelib$Dict$member)($name))($constructors)
            ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(("constructor " + ($name + " is duplicate"))))($core$SPCore$Nil))
            : (($corelib$Result$onOk)((($caArgs) => {
              const $c = ({
                args: $caArgs,
                pos: $pos,
                type: ((($corelib$List$forReversed)($caArgs))((($ar) => {
                  return (($ty) => {
                    return (((($sp$Types$CanonicalAst$TypeFunction)($pos))($ar))(false))($ty);
                  });
                })))($unionType),
                typeUsr: $unionUsr,
              });
              return ($corelib$Result$Ok)(((($corelib$Dict$insert)($name))($c))($constructors));
            })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro)))($faArgs)));
        });
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToConstructorUsr = ($sp$Compiler$MakeCanonical$resolveToUsr)((($m) => {
  return $m.globalValues;
}));

const $sp$Compiler$MakeCanonical$translateNumber = (($constructor) => {
  return (($pos) => {
    return (($numberAsText) => {
      const $$try1 = (text_toNumber)($numberAsText);
      return ((($$try1)[0] === "Nothing")
        ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(("invalid number: `" + ($numberAsText + "`"))))((($core$SPCore$Cons)("TODO link to documentation on valid number formats"))($core$SPCore$Nil)))
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $n = ($$try1)[1];
            return ($corelib$Result$Ok)((($constructor)($pos))($n));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 629:4', (sp_toHuman)($$try1))));
    });
  });
});

const $sp$Types$FormattableAst$patternPos = (($pa) => {
  return ((($pa)[0] === "PatternAny")
    ? ((() => {
      const $p = ($pa)[1];
      return $p;
    }))()
    : ((($pa)[0] === "PatternLiteralNumber")
      ? ((() => {
        const $p = ($pa)[1];
        return $p;
      }))()
      : ((($pa)[0] === "PatternLiteralText")
        ? ((() => {
          const $p = ($pa)[1];
          return $p;
        }))()
        : ((($pa)[0] === "PatternConstructor")
          ? ((() => {
            const $p = ($pa)[1];
            return $p;
          }))()
          : ((($pa)[0] === "PatternList")
            ? ((() => {
              const $p = ($pa)[1];
              return $p;
            }))()
            : ((($pa)[0] === "PatternListCons")
              ? ((() => {
                const $p = ($pa)[1];
                return $p;
              }))()
              : ((($pa)[0] === "PatternRecord")
                ? ((() => {
                  const $p = ($pa)[1];
                  return $p;
                }))()
                : ((($pa)[0] === "PatternTuple")
                  ? ((() => {
                    const $p = ($pa)[1];
                    return $p;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 156:4', (sp_toHuman)($pa))))))))));
});

const $sp$Compiler$MakeCanonical$translatePattern = (($ann) => {
  return (($env) => {
    return (($fa) => {
      return (((($fa)[0] === "PatternAny") && ($fa)[2])
        ? ((() => {
          const $pos = ($fa)[1];
          const $s = ($fa)[3];
          return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("This is the wrong place to use `@`"))($core$SPCore$Nil));
        }))()
        : (((($fa)[0] === "PatternAny") && !(($fa)[2]))
          ? ((() => {
            const $pos = ($fa)[1];
            const $name = ($fa)[3];
            const $maybeFaType = ($fa)[4];
            return ((((sp_equal)($corelib$Maybe$Nothing))($ann) && ((sp_not_equal)($corelib$Maybe$Nothing))($maybeFaType))
              ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Can't use annotations here"))($core$SPCore$Nil))
              : (($corelib$Result$onOk)((($maybeCaType) => {
                const $n = (((sp_equal)("_"))($name)
                  ? $corelib$Maybe$Nothing
                  : ($corelib$Maybe$Just)($name));
                return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$PatternAny)($pos))($n))($maybeCaType));
              })))((($corelib$Maybe$mapRes)((($sp$Compiler$MakeCanonical$translateType)($ann))($env.ro)))($maybeFaType)));
          }))()
          : ((($fa)[0] === "PatternLiteralNumber")
            ? ((() => {
              const $pos = ($fa)[1];
              const $l = ($fa)[2];
              return ((($sp$Compiler$MakeCanonical$translateNumber)($sp$Types$CanonicalAst$PatternLiteralNumber))($pos))($l);
            }))()
            : ((($fa)[0] === "PatternLiteralText")
              ? ((() => {
                const $pos = ($fa)[1];
                const $l = ($fa)[2];
                return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$PatternLiteralText)($pos))($l));
              }))()
              : ((($fa)[0] === "PatternConstructor")
                ? ((() => {
                  const $pos = ($fa)[1];
                  const $maybeModule = ($fa)[2];
                  const $name = ($fa)[3];
                  const $faArgs = ($fa)[4];
                  return (($corelib$Result$onOk)((($caArgs) => {
                    return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$PatternConstructor)($pos))(((($sp$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro))($maybeModule))($name)))($caArgs));
                  })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($faArgs));
                }))()
                : ((($fa)[0] === "PatternList")
                  ? ((() => {
                    const $pos = ($fa)[1];
                    const $fas = ($fa)[2];
                    const $fold = (($pattern) => {
                      return (($last) => {
                        return ((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$cons))((($core$SPCore$Cons)($pattern))((($core$SPCore$Cons)($last))($core$SPCore$Nil)));
                      });
                    });
                    return (($corelib$Result$onOk)((($cas) => {
                      return ($corelib$Result$Ok)(((($corelib$List$forReversed)($cas))($fold))(((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$nil))($core$SPCore$Nil)));
                    })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($fas));
                  }))()
                  : ((($fa)[0] === "PatternRecord")
                    ? ((() => {
                      const $pos = ($fa)[1];
                      const $recordArgs = ($fa)[2];
                      return (((sp_not_equal)($corelib$Maybe$Nothing))($recordArgs.extends)
                        ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("can't use `with` inside patterns"))($core$SPCore$Nil))
                        : ((() => {
                          const $fold = (($$maybePattern) => {
                            const $p = ($$maybePattern.first)[1];
                            const $name = ($$maybePattern.first)[2];
                            const $maybePattern = $$maybePattern.second;
                            return (($dict) => {
                              return ((($corelib$Dict$member)($name))($dict)
                                ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)(("duplicate attribute name in pattern: " + $name)))($core$SPCore$Nil))
                                : ((($maybePattern)[0] === "Nothing")
                                  ? ($corelib$Result$Ok)(((($corelib$Dict$insert)($name))(((($sp$Types$CanonicalAst$PatternAny)($p))(($corelib$Maybe$Just)($name)))($corelib$Maybe$Nothing)))($dict))
                                  : ((($maybePattern)[0] === "Just")
                                    ? ((() => {
                                      const $faPattern = ($maybePattern)[1];
                                      return (($corelib$Result$map)((($caPattern) => {
                                        return ((($corelib$Dict$insert)($name))($caPattern))($dict);
                                      })))(((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))($faPattern));
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 394:24', (sp_toHuman)($maybePattern)))));
                            });
                          });
                          return (($corelib$Result$map)((($x) => {
                            return (($sp$Types$CanonicalAst$PatternRecord)($pos))($x);
                          })))(((($corelib$List$foldlRes)($fold))($recordArgs.attrs))($corelib$Dict$empty));
                        }))());
                    }))()
                    : ((($fa)[0] === "PatternListCons")
                      ? ((() => {
                        const $pos = ($fa)[1];
                        const $pas = ($fa)[2];
                        return (($corelib$Result$onOk)((($caPas) => {
                          const $$try1 = ($corelib$List$reverse)($caPas);
                          return ((($$try1)[0] === "Cons")
                            ? ((() => {
                              const $last = ($$try1)[1];
                              const $rest = ($$try1)[2];
                              return ($corelib$Result$Ok)(((($corelib$List$for)($rest))((($item) => {
                                return (($list) => {
                                  return ((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$cons))((($core$SPCore$Cons)($item))((($core$SPCore$Cons)($list))($core$SPCore$Nil)));
                                });
                              })))($last));
                            }))()
                            : ((($$try1)[0] === "Nil")
                              ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("should not happen: empty cons pattern"))($core$SPCore$Nil))
                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 408:12', (sp_toHuman)($$try1))));
                        })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($pas));
                      }))()
                      : ((($fa)[0] === "PatternTuple")
                        ? ((() => {
                          const $pos = ($fa)[1];
                          const $fas = ($fa)[2];
                          return (((($fas)[0] === "Cons") && (((($fas)[2])[0] === "Cons") && (((($fas)[2])[2])[0] === "Nil")))
                            ? ((() => {
                              const $fa1 = ($fas)[1];
                              const $fa2 = (($fas)[2])[1];
                              return ((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))((($sp$Types$FormattableAst$PatternRecord)($pos))(({
                                attrs: (($core$SPCore$Cons)(({
                                  first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa1)))("first"),
                                  second: ($corelib$Maybe$Just)($fa1),
                                })))((($core$SPCore$Cons)(({
                                  first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa2)))("second"),
                                  second: ($corelib$Maybe$Just)($fa2),
                                })))($core$SPCore$Nil)),
                                extends: $corelib$Maybe$Nothing,
                              })));
                            }))()
                            : (((($fas)[0] === "Cons") && (((($fas)[2])[0] === "Cons") && ((((($fas)[2])[2])[0] === "Cons") && ((((($fas)[2])[2])[2])[0] === "Nil"))))
                              ? ((() => {
                                const $fa1 = ($fas)[1];
                                const $fa2 = (($fas)[2])[1];
                                const $fa3 = ((($fas)[2])[2])[1];
                                return ((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))((($sp$Types$FormattableAst$PatternRecord)($pos))(({
                                  attrs: (($core$SPCore$Cons)(({
                                    first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa1)))("first"),
                                    second: ($corelib$Maybe$Just)($fa1),
                                  })))((($core$SPCore$Cons)(({
                                    first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa2)))("second"),
                                    second: ($corelib$Maybe$Just)($fa2),
                                  })))((($core$SPCore$Cons)(({
                                    first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa3)))("third"),
                                    second: ($corelib$Maybe$Just)($fa3),
                                  })))($core$SPCore$Nil))),
                                  extends: $corelib$Maybe$Nothing,
                                })));
                              }))()
                              : (true
                                ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("tuples can be only of size 2 or 3"))($core$SPCore$Nil))
                                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 418:12', (sp_toHuman)($fas)))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 352:4', (sp_toHuman)($fa)))))))))));
    });
  });
});

const $sp$Compiler$MakeCanonical$makeUpdateTarget = (($pos) => {
  return (($env) => {
    return (($maybeShorthandTarget) => {
      const $$try1 = (($corelib$Maybe$map)(($sp$Compiler$MakeCanonical$translateExpression)((Object.assign)({}, $env, ({
        maybeShorthandTarget: $corelib$Maybe$Nothing,
      })))))($maybeShorthandTarget);
      return ((($$try1)[0] === "Nothing")
        ? ($corelib$Result$Ok)(({
          maybeName: $corelib$Maybe$Nothing,
          wrapper: $corelib$Basics$identity,
        }))
        : (((($$try1)[0] === "Just") && ((($$try1)[1])[0] === "Err"))
          ? ((() => {
            const $e = (($$try1)[1])[1];
            return ($corelib$Result$Err)($e);
          }))()
          : (((($$try1)[0] === "Just") && (((($$try1)[1])[0] === "Ok") && (((($$try1)[1])[1])[0] === "Variable")))
            ? ((() => {
              const $args = ((($$try1)[1])[1])[2];
              return ($corelib$Result$Ok)(({
                maybeName: ($corelib$Maybe$Just)($args),
                wrapper: $corelib$Basics$identity,
              }));
            }))()
            : (((($$try1)[0] === "Just") && ((($$try1)[1])[0] === "Ok"))
              ? ((() => {
                const $expr = (($$try1)[1])[1];
                return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("NI { (expr) with ...} not yet implemented =("))($core$SPCore$Nil));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 642:4', (sp_toHuman)($$try1))))));
    });
  });
});

const $sp$Compiler$MakeCanonical$resolveToValueRef = (($ro) => {
  return (($declaredInsideFunction) => {
    return (($maybeModule) => {
      return (($name) => {
        const $$try1 = (((($sp$Compiler$MakeCanonical$maybeForeignUsr)((($m) => {
          return $m.globalValues;
        })))($ro))($maybeModule))($name);
        return ((($$try1)[0] === "Just")
          ? ((() => {
            const $usr = ($$try1)[1];
            return ($sp$Types$CanonicalAst$RefRoot)($usr);
          }))()
          : ((($$try1)[0] === "Nothing")
            ? ($declaredInsideFunction
              ? ($sp$Types$CanonicalAst$RefBlock)($name)
              : ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($ro.currentModule))($name)))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 131:4', (sp_toHuman)($$try1))));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateArgument = (($env) => {
  return (($faExpr) => {
    return ((($faExpr)[0] === "Mutable")
      ? ((() => {
        const $pos = ($faExpr)[1];
        const $name = ($faExpr)[2];
        const $attrPath = ($faExpr)[3];
        return ((($corelib$Dict$member)($name))($env.nonRootValues)
          ? ($corelib$Result$Ok)((($sp$Types$CanonicalAst$ArgumentMutable)($pos))(({
            attrPath: $attrPath,
            ref: ($sp$Types$CanonicalAst$RefBlock)($name),
          })))
          : (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("only values declared inside a function scope can be mutated!"))($core$SPCore$Nil)));
      }))()
      : (true
        ? (($corelib$Result$map)($sp$Types$CanonicalAst$ArgumentExpression))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr))
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 686:4', (sp_toHuman)($faExpr))));
  });
});

const $sp$Compiler$MakeCanonical$translateAttrsRec = (($env) => {
  return (($faAttrs) => {
    return (($caAttrsAccum) => {
      return ((($faAttrs)[0] === "Nil")
        ? ($corelib$Result$Ok)($caAttrsAccum)
        : (((($faAttrs)[0] === "Cons") && ((($faAttrs)[1].first)[0] === "At"))
          ? ((() => {
            const $pos = (($faAttrs)[1].first)[1];
            const $attrName = (($faAttrs)[1].first)[2];
            const $maybeAttrExpression = ($faAttrs)[1].second;
            const $faTail = ($faAttrs)[2];
            const $exprRes = ((($maybeAttrExpression)[0] === "Just")
              ? ((() => {
                const $faExpr = ($maybeAttrExpression)[1];
                return (($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr);
              }))()
              : ((($maybeAttrExpression)[0] === "Nothing")
                ? ((() => {
                  const $declaredInsideFunction = (($corelib$Dict$member)($attrName))($env.nonRootValues);
                  return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
                    attrPath: $core$SPCore$Nil,
                    ref: (((($sp$Compiler$MakeCanonical$resolveToValueRef)($env.ro))($declaredInsideFunction))($corelib$Maybe$Nothing))($attrName),
                  })));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 666:16', (sp_toHuman)($maybeAttrExpression))));
            return (($corelib$Result$onOk)((($expr) => {
              return ((($sp$Compiler$MakeCanonical$translateAttrsRec)($env))($faTail))(((($corelib$Dict$insert)($attrName))($expr))($caAttrsAccum));
            })))($exprRes);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 660:4', (sp_toHuman)($faAttrs))));
    });
  });
});

const $sp$Compiler$MakeCanonical$notAllSeparators = (($f) => {
  return (($ls) => {
    return ((($ls)[0] === "Nil")
      ? false
      : ((($ls)[0] === "Cons")
        ? ((() => {
          const $sep = ($ls)[1].first;
          const $item = ($ls)[1].second;
          const $tail = ($ls)[2];
          return (($f)($sep)
            ? (($sp$Compiler$MakeCanonical$notAllSeparators)($f))($tail)
            : true);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 784:4', (sp_toHuman)($ls))));
  });
});

const $sp$Compiler$MakeCanonical$sameDirectionAs = (($a) => {
  return (($b) => {
    return (((sp_equal)($b.symbol))($a.symbol)
      ? true
      : ((() => {
        const $$try1 = $a.symbol;
        return ((">" === $$try1)
          ? ((sp_equal)(">="))($b.symbol)
          : ((">=" === $$try1)
            ? ((sp_equal)(">"))($b.symbol)
            : (("<" === $$try1)
              ? ((sp_equal)("<="))($b.symbol)
              : (("<=" === $$try1)
                ? ((sp_equal)("<"))($b.symbol)
                : (true
                  ? false
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 802:8', (sp_toHuman)($$try1)))))));
      }))());
  });
});

const $sp$Compiler$MakeCanonical$makeBinop = (($pos) => {
  return (($left) => {
    return (($op) => {
      return (($right) => {
        const $$try1 = ({
          first: $left,
          second: $op.symbol,
          third: $right,
        });
        return (((">>" === $$try1.second) && (($$try1.third)[0] === "ArgumentExpression"))
          ? ((() => {
            const $rightExpr = ($$try1.third)[1];
            return ((($sp$Types$CanonicalAst$Call)($pos))($rightExpr))($left);
          }))()
          : (((($$try1.first)[0] === "ArgumentExpression") && ("<<" === $$try1.second))
            ? ((() => {
              const $leftExpr = ($$try1.first)[1];
              return ((($sp$Types$CanonicalAst$Call)($pos))($leftExpr))($right);
            }))()
            : (true
              ? ((($sp$Types$CanonicalAst$Call)($pos))(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Variable)($pos))(({
                attrPath: $core$SPCore$Nil,
                ref: ($sp$Types$CanonicalAst$RefRoot)($op.usr),
              }))))($right)))($left)
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 856:4', (sp_toHuman)($$try1)))));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinopSepListRec = (($env) => {
  return (($pos) => {
    return (($leftAccum) => {
      return (($opsAndRight) => {
        return ((($opsAndRight)[0] === "Nil")
          ? ($corelib$Result$Ok)($leftAccum)
          : ((($opsAndRight)[0] === "Cons")
            ? ((() => {
              const $op = ($opsAndRight)[1].first;
              const $faRight = ($opsAndRight)[1].second;
              const $tail = ($opsAndRight)[2];
              return (($corelib$Result$onOk)((($caRight) => {
                return (((($sp$Compiler$MakeCanonical$translateBinopSepListRec)($env))($pos))((((($sp$Compiler$MakeCanonical$makeBinop)($pos))(($sp$Types$CanonicalAst$ArgumentExpression)($leftAccum)))($op))($caRight)))($tail);
              })))((($sp$Compiler$MakeCanonical$translateArgument)($env))($faRight));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 840:4', (sp_toHuman)($opsAndRight))));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinopSepList_leftAssociative = (($env) => {
  return (($pos) => {
    return (($leftAccum) => {
      return (($opsAndRight) => {
        return (($corelib$Result$onOk)((($caLeftAccum) => {
          return (((($sp$Compiler$MakeCanonical$translateBinopSepListRec)($env))($pos))($caLeftAccum))($opsAndRight);
        })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($leftAccum));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative = (($env) => {
  return (($pos) => {
    return (($left) => {
      return (($opsAndRight) => {
        return (($corelib$Result$onOk)((($caLeft) => {
          return ((($opsAndRight)[0] === "Nil")
            ? ($corelib$Result$Ok)($caLeft)
            : ((($opsAndRight)[0] === "Cons")
              ? ((() => {
                const $op = ($opsAndRight)[1].first;
                const $right = ($opsAndRight)[1].second;
                const $tail = ($opsAndRight)[2];
                return (($corelib$Result$onOk)((($caRight) => {
                  return ($corelib$Result$Ok)((((($sp$Compiler$MakeCanonical$makeBinop)($pos))(($sp$Types$CanonicalAst$ArgumentExpression)($caLeft)))($op))(($sp$Types$CanonicalAst$ArgumentExpression)($caRight)));
                })))((((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($right))($tail));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 822:4', (sp_toHuman)($opsAndRight))));
        })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($left));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateSimpleBinop = (($env) => {
  return (($pos) => {
    return (($left) => {
      return (($op) => {
        return (($right) => {
          return (($corelib$Result$onOk)((($l) => {
            return (($corelib$Result$onOk)((($r) => {
              return ($corelib$Result$Ok)((((($sp$Compiler$MakeCanonical$makeBinop)($pos))($l))($op))($r));
            })))((($sp$Compiler$MakeCanonical$translateArgument)($env))($right));
          })))((($sp$Compiler$MakeCanonical$translateArgument)($env))($left));
        });
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateBinops = (($env) => {
  return (($pos) => {
    return (($group) => {
      return (($$firstItem) => {
        const $firstItem = $$firstItem.first;
        const $firstTail = $$firstItem.second;
        return ((($firstTail)[0] === "Nil")
          ? (($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem)
          : (((($firstTail)[0] === "Cons") && ((($firstTail)[2])[0] === "Nil"))
            ? ((() => {
              const $firstSep = ($firstTail)[1].first;
              const $secondItem = ($firstTail)[1].second;
              return ((($group)[0] === "Tuple")
                ? (($corelib$Result$onOk)((($first) => {
                  return (($corelib$Result$onOk)((($second) => {
                    return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Record)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($second))(((($corelib$Dict$insert)("first"))($first))($corelib$Dict$empty))));
                  })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($secondItem));
                })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem))
                : (true
                  ? ((((($sp$Compiler$MakeCanonical$translateSimpleBinop)($env))($pos))($firstItem))($firstSep))($secondItem)
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 715:12', (sp_toHuman)($group))));
            }))()
            : (((($firstTail)[0] === "Cons") && ((($firstTail)[2])[0] === "Cons"))
              ? ((() => {
                const $firstSep = ($firstTail)[1].first;
                const $secondItem = ($firstTail)[1].second;
                const $secondSep = (($firstTail)[2])[1].first;
                const $thirdItem = (($firstTail)[2])[1].second;
                const $thirdTail = (($firstTail)[2])[2];
                const $secondTail = ((sp_cons)($thirdTail))(({
                  first: $secondSep,
                  second: $thirdItem,
                }));
                return ((($group)[0] === "Comparison")
                  ? ((($sp$Compiler$MakeCanonical$notAllSeparators)(($sp$Compiler$MakeCanonical$sameDirectionAs)($firstSep)))($secondTail)
                    ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("can't mix comparison ops with different direction"))($core$SPCore$Nil))
                    : (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("NI compops expansion"))($core$SPCore$Nil)))
                  : ((($group)[0] === "Logical")
                    ? ((($sp$Compiler$MakeCanonical$notAllSeparators)((($x) => {
                      return ((sp_equal)($firstSep))($x);
                    })))($secondTail)
                      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Mixing `and` and `or` is ambiguous. Use parens!"))($core$SPCore$Nil))
                      : (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail))
                    : ((($group)[0] === "Tuple")
                      ? (((sp_not_equal)($core$SPCore$Nil))($thirdTail)
                        ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Tuples can't have more than 3 items, use a record instead."))($core$SPCore$Nil))
                        : (($corelib$Result$onOk)((($first) => {
                          return (($corelib$Result$onOk)((($second) => {
                            return (($corelib$Result$onOk)((($third) => {
                              return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Record)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("third"))($third))(((($corelib$Dict$insert)("second"))($second))(((($corelib$Dict$insert)("first"))($first))($corelib$Dict$empty)))));
                            })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($thirdItem));
                          })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($secondItem));
                        })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem)))
                      : ((($group)[0] === "Pipe")
                        ? ((($sp$Compiler$MakeCanonical$notAllSeparators)((($x) => {
                          return ((sp_equal)($firstSep))($x);
                        })))($secondTail)
                          ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Mixing pipes is ambigous. Use parens."))($core$SPCore$Nil))
                          : (((sp_equal)($sp$Types$Op$Right))($firstSep.associativity)
                            ? (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail)
                            : (((($sp$Compiler$MakeCanonical$translateBinopSepList_leftAssociative)($env))($pos))($firstItem))($firstTail)))
                        : ((($group)[0] === "Mutop")
                          ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("mutops can't be chained"))($core$SPCore$Nil))
                          : (true
                            ? (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail)
                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 733:12', (sp_toHuman)($group))))))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 710:4', (sp_toHuman)($firstTail)))));
      });
    });
  });
});

const $sp$Compiler$MakeCanonical$translateParameter = (($env) => {
  return (($mutable) => {
    return (($faParam) => {
      const $$try1 = ({
        first: $faParam,
        second: $mutable,
      });
      return (((($$try1.first)[0] === "PatternAny") && (!(($$try1.first)[2]) && (((($$try1.first)[4])[0] === "Nothing") && $$try1.second)))
        ? ((() => {
          const $pos = ($$try1.first)[1];
          const $name = ($$try1.first)[3];
          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$ParameterMutable)($pos))($name));
        }))()
        : (((($$try1.first)[0] === "PatternAny") && ($$try1.first)[2])
          ? ((() => {
            const $pos = ($$try1.first)[1];
            const $name = ($$try1.first)[3];
            return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Can't annotate this. =("))((($core$SPCore$Cons)("TODO link to rationale for forbidding annotations"))($core$SPCore$Nil)));
          }))()
          : (true
            ? (($corelib$Result$onOk)((($caPattern) => {
              return ($corelib$Result$Ok)(($sp$Types$CanonicalAst$ParameterPattern)($caPattern));
            })))(((($sp$Compiler$MakeCanonical$translatePattern)($corelib$Maybe$Nothing))($env))($faParam))
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 446:4', (sp_toHuman)($$try1)))));
    });
  });
});

const $sp$Compiler$MakeCanonical$translateExpression = (($env) => {
  return (($faExpr) => {
    return ((($faExpr)[0] === "LiteralNumber")
      ? ((() => {
        const $pos = ($faExpr)[1];
        const $str = ($faExpr)[2];
        return ((($sp$Compiler$MakeCanonical$translateNumber)($sp$Types$CanonicalAst$LiteralNumber))($pos))($str);
      }))()
      : ((($faExpr)[0] === "LiteralText")
        ? ((() => {
          const $pos = ($faExpr)[1];
          const $v = ($faExpr)[2];
          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LiteralText)($pos))($v));
        }))()
        : ((($faExpr)[0] === "PrefixBinop")
          ? ((() => {
            const $pos = ($faExpr)[1];
            const $symbol = ($faExpr)[2];
            return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
              attrPath: $core$SPCore$Nil,
              ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)($symbol)),
            })));
          }))()
          : ((($faExpr)[0] === "Variable")
            ? ((() => {
              const $pos = ($faExpr)[1];
              const $maybeModule = ($faExpr)[2];
              const $name = ($faExpr)[3];
              const $attrs = ($faExpr)[4];
              const $declaredInsideFunction = (($corelib$Dict$member)($name))($env.nonRootValues);
              return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
                attrPath: $attrs,
                ref: (((($sp$Compiler$MakeCanonical$resolveToValueRef)($env.ro))($declaredInsideFunction))($maybeModule))($name),
              })));
            }))()
            : ((($faExpr)[0] === "Constructor")
              ? ((() => {
                const $pos = ($faExpr)[1];
                const $maybeModule = ($faExpr)[2];
                const $name = ($faExpr)[3];
                return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Constructor)($pos))(((($sp$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro))($maybeModule))($name)));
              }))()
              : ((($faExpr)[0] === "Mutable")
                ? ((() => {
                  const $pos = ($faExpr)[1];
                  const $name = ($faExpr)[2];
                  return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($name + ": mutable values can be used only as arguments for function or mutation operators")))($core$SPCore$Nil));
                }))()
                : ((($faExpr)[0] === "RecordShorthand")
                  ? ((() => {
                    const $pos = ($faExpr)[1];
                    const $attrPath = ($faExpr)[2];
                    const $$try1 = $env.maybeShorthandTarget;
                    return ((($$try1)[0] === "Nothing")
                      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Record update shorthands must be used inside a record update such as"))((($core$SPCore$Cons)(("    { aRecord with anAttribute = doSomethingWith ." + ((($corelib$Text$join)("."))($attrPath) + " }"))))((($core$SPCore$Cons)("but we are not inside a record update!"))($core$SPCore$Nil))))
                      : ((($$try1)[0] === "Just")
                        ? ((() => {
                          const $shorthandTarget = ($$try1)[1];
                          return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))((Object.assign)({}, $shorthandTarget, ({
                            attrPath: ($corelib$List$concat)((($core$SPCore$Cons)($shorthandTarget.attrPath))((($core$SPCore$Cons)($attrPath))($core$SPCore$Nil))),
                          }))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 540:12', (sp_toHuman)($$try1))));
                  }))()
                  : ((($faExpr)[0] === "Lambda")
                    ? ((() => {
                      const $pos = ($faExpr)[1];
                      const $faParam = ($faExpr)[2];
                      const $mutable = ($faExpr)[3];
                      const $faBody = ($faExpr)[4];
                      return (($corelib$Result$onOk)((($caParam) => {
                        const $localEnv = (Object.assign)({}, $env, ({
                          nonRootValues: (($sp$Compiler$MakeCanonical$insertParamNames)($caParam))($env.nonRootValues),
                        }));
                        return (($corelib$Result$onOk)((($caBody) => {
                          return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Lambda)($pos))($caParam))($caBody));
                        })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($localEnv))($faBody));
                      })))(((($sp$Compiler$MakeCanonical$translateParameter)($env))($mutable))($faParam));
                    }))()
                    : ((($faExpr)[0] === "FunctionCall")
                      ? ((() => {
                        const $pos = ($faExpr)[1];
                        const $reference = ($faExpr)[2];
                        const $arguments = ($faExpr)[3];
                        const $fold = (($argument) => {
                          return (($refAccum) => {
                            return ((($sp$Types$CanonicalAst$Call)($pos))($refAccum))($argument);
                          });
                        });
                        return (($corelib$Result$onOk)((($ref) => {
                          return (($corelib$Result$onOk)((($args) => {
                            return ($corelib$Result$Ok)(((($corelib$List$for)($args))($fold))($ref));
                          })))((($corelib$List$mapRes)(($sp$Compiler$MakeCanonical$translateArgument)($env)))($arguments));
                        })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($reference));
                      }))()
                      : ((($faExpr)[0] === "If")
                        ? ((() => {
                          const $pos = ($faExpr)[1];
                          const $condition = ($faExpr)[2].condition;
                          const $false = ($faExpr)[2].false;
                          const $isCompact = ($faExpr)[2].isCompact;
                          const $true = ($faExpr)[2].true;
                          return (($corelib$Result$onOk)((($c) => {
                            return (($corelib$Result$onOk)((($t) => {
                              return (($corelib$Result$onOk)((($f) => {
                                return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$If)($pos))(({
                                  condition: $c,
                                  false: $f,
                                  true: $t,
                                })));
                              })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($false));
                            })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($true));
                          })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($condition));
                        }))()
                        : ((($faExpr)[0] === "Unop")
                          ? ((() => {
                            const $pos = ($faExpr)[1];
                            const $op = ($faExpr)[2];
                            const $faOperand = ($faExpr)[3];
                            return (($corelib$Result$onOk)((($caOperand) => {
                              return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Variable)($pos))(({
                                attrPath: $core$SPCore$Nil,
                                ref: ($sp$Types$CanonicalAst$RefRoot)($op.usr),
                              }))))(($sp$Types$CanonicalAst$ArgumentExpression)($caOperand)));
                            })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faOperand));
                          }))()
                          : ((($faExpr)[0] === "Binop")
                            ? ((() => {
                              const $pos = ($faExpr)[1];
                              const $group = ($faExpr)[2];
                              const $sepList = ($faExpr)[3];
                              return (((($sp$Compiler$MakeCanonical$translateBinops)($env))($pos))($group))($sepList);
                            }))()
                            : ((($faExpr)[0] === "Record")
                              ? ((() => {
                                const $pos = ($faExpr)[1];
                                const $faArgs = ($faExpr)[2];
                                return (($corelib$Result$onOk)((($caUpdateTarget) => {
                                  return (($corelib$Result$onOk)((($caAttrs) => {
                                    return ($corelib$Result$Ok)(($caUpdateTarget.wrapper)(((($sp$Types$CanonicalAst$Record)($pos))($caUpdateTarget.maybeName))($caAttrs)));
                                  })))(((($sp$Compiler$MakeCanonical$translateAttrsRec)((Object.assign)({}, $env, ({
                                    maybeShorthandTarget: $caUpdateTarget.maybeName,
                                  }))))($faArgs.attrs))($corelib$Dict$empty));
                                })))(((($sp$Compiler$MakeCanonical$makeUpdateTarget)($pos))($env))($faArgs.extends));
                              }))()
                              : ((($faExpr)[0] === "List")
                                ? ((() => {
                                  const $pos = ($faExpr)[1];
                                  const $faItems = ($faExpr)[2];
                                  const $cons = (($item) => {
                                    return (($list) => {
                                      return ((($sp$Types$CanonicalAst$Call)($pos))(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Constructor)($pos))($sp$Compiler$CoreTypes$cons)))(($sp$Types$CanonicalAst$ArgumentExpression)($item))))(($sp$Types$CanonicalAst$ArgumentExpression)($list));
                                    });
                                  });
                                  return (($corelib$Result$onOk)((($es) => {
                                    return ($corelib$Result$Ok)(((($corelib$List$forReversed)($es))($cons))((($sp$Types$CanonicalAst$Constructor)($pos))($sp$Compiler$CoreTypes$nil)));
                                  })))((($corelib$List$mapRes)(($sp$Compiler$MakeCanonical$translateExpression)($env)))($faItems));
                                }))()
                                : ((($faExpr)[0] === "Try")
                                  ? ((() => {
                                    const $pos = ($faExpr)[1];
                                    const $fa = ($faExpr)[2];
                                    const $translatePatternAndStatements = (($$faPattern) => {
                                      const $faPattern = $$faPattern.first;
                                      const $faStatements = $$faPattern.second;
                                      return (($corelib$Result$onOk)((($caPattern) => {
                                        return (($corelib$Result$onOk)((($block) => {
                                          return ($corelib$Result$Ok)(({
                                            first: $caPattern,
                                            second: $block,
                                          }));
                                        })))((($sp$Compiler$MakeCanonical$translateStatementBlock)((Object.assign)({}, $env, ({
                                          nonRootValues: (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($caPattern)))($env.nonRootValues),
                                        }))))($faStatements));
                                      })))(((($sp$Compiler$MakeCanonical$translatePattern)($corelib$Maybe$Nothing))($env))($faPattern));
                                    });
                                    return (($corelib$Result$onOk)((($caValue) => {
                                      return (($corelib$Result$onOk)((($caPatternsAndStatements) => {
                                        return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Try)($pos))($caValue))($caPatternsAndStatements));
                                      })))((($corelib$List$mapRes)($translatePatternAndStatements))($fa.patterns));
                                    })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($fa.value));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 507:4', (sp_toHuman)($faExpr)))))))))))))))));
  });
});

const $sp$Compiler$MakeCanonical$translateStatementBlock = (($env) => {
  return (($stats) => {
    return (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "TypeAlias"))
      ? ((() => {
        const $fa = (($stats)[1])[1];
        const $$pos = $fa.name;
        const $pos = ($$pos)[1];
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Aliases can be declared only in the root scope"))($core$SPCore$Nil));
      }))()
      : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "UnionDef"))
        ? ((() => {
          const $pos = (($stats)[1])[1];
          const $fa = (($stats)[1])[2];
          return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Types can be declared only in the root scope"))($core$SPCore$Nil));
        }))()
        : ((($stats)[0] === "Nil")
          ? ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Constructor)($sp$Types$Pos$G))($sp$Compiler$CoreTypes$noneValue))
          : (((($stats)[0] === "Cons") && (((($stats)[1])[0] === "Evaluation") && ((($stats)[2])[0] === "Nil")))
            ? ((() => {
              const $pos = (($stats)[1])[1];
              const $faExpr = (($stats)[1])[2];
              return (($corelib$Result$onOk)((($e) => {
                return ($corelib$Result$Ok)($e);
              })))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr));
            }))()
            : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "Evaluation"))
              ? ((() => {
                const $pos = (($stats)[1])[1];
                const $faExpr = (($stats)[1])[2];
                const $tail = ($stats)[2];
                const $valueDef = ({
                  body: (($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($pos))($faExpr)))($core$SPCore$Nil),
                  modifier: $sp$Types$Token$DefNormal,
                  nonFn: $core$SPCore$Nil,
                  pattern: (((($sp$Types$FormattableAst$PatternAny)($sp$Types$Pos$G))(false))("_"))($corelib$Maybe$Nothing),
                });
                return (($corelib$Result$onOk)((($d) => {
                  return (($corelib$Result$onOk)((($tailBlockExpression) => {
                    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LetIn)($d))($tailBlockExpression));
                  })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($tail));
                })))(((($sp$Compiler$MakeCanonical$translateDefinition)(false))($env))($valueDef));
              }))()
              : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "Definition"))
                ? ((() => {
                  const $pos = (($stats)[1])[1];
                  const $fa = (($stats)[1])[2];
                  const $tail = ($stats)[2];
                  return (($corelib$Result$onOk)((($d) => {
                    return (($corelib$Result$onOk)((($tailBlockExpression) => {
                      return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LetIn)($d))($tailBlockExpression));
                    })))((($sp$Compiler$MakeCanonical$translateStatementBlock)((Object.assign)({}, $env, ({
                      nonRootValues: (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($d.pattern)))($env.nonRootValues),
                    }))))($tail));
                  })))(((($sp$Compiler$MakeCanonical$translateDefinition)(false))($env))($fa));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 465:4', (sp_toHuman)($stats))))))));
  });
});

const $sp$Types$CanonicalAst$patternPos = (($pa) => {
  return ((($pa)[0] === "PatternAny")
    ? ((() => {
      const $p = ($pa)[1];
      const $n = ($pa)[2];
      return $p;
    }))()
    : ((($pa)[0] === "PatternLiteralText")
      ? ((() => {
        const $p = ($pa)[1];
        return $p;
      }))()
      : ((($pa)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $p = ($pa)[1];
          return $p;
        }))()
        : ((($pa)[0] === "PatternConstructor")
          ? ((() => {
            const $p = ($pa)[1];
            const $path = ($pa)[2];
            const $ps = ($pa)[3];
            return $p;
          }))()
          : ((($pa)[0] === "PatternRecord")
            ? ((() => {
              const $p = ($pa)[1];
              const $ps = ($pa)[2];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 202:4', (sp_toHuman)($pa)))))));
});

const $sp$Types$Pos$start = (($pos) => {
  return ((($pos)[0] === "P")
    ? ((() => {
      const $m = ($pos)[1];
      const $s = ($pos)[2];
      const $e = ($pos)[3];
      return $s;
    }))()
    : (true
      ? 0
      : (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 29:4', (sp_toHuman)($pos))));
});

const $sp$Compiler$MakeCanonical$translateDefinition = (($isRoot) => {
  return (($env) => {
    return (($fa) => {
      const $dict = ({
        attr: "$",
        obj: ({
          $: (sp_clone)($env.tyvarRenames),
        }),
      });
      const $renameTyvar = (($pos) => {
        return (($faName) => {
          const $$try2 = (($corelib$Dict$get)($faName))((sp_clone)(($dict.obj)[$dict.attr]));
          return ((($$try2)[0] === "Just")
            ? ((() => {
              const $n = ($$try2)[1];
              return $n;
            }))()
            : ((($$try2)[0] === "Nothing")
              ? ((() => {
                const $n = ((text_fromNumber)(($sp$Types$Pos$start)($pos)) + $faName);
                (($dict.obj)[$dict.attr] = ((($corelib$Dict$insert)($faName))($n))((sp_clone)(($dict.obj)[$dict.attr])));
                return $n;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 287:8', (sp_toHuman)($$try2))));
        });
      });
      return (($corelib$Result$onOk)((($pattern) => {
        const $nonRootValues1 = ($isRoot
          ? $env.nonRootValues
          : (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($pattern)))($env.nonRootValues));
        const $localEnv0 = (Object.assign)({}, $env, ({
          defsPath: ((sp_cons)($env.defsPath))($pattern),
          nonRootValues: $nonRootValues1,
          tyvarRenames: (sp_clone)(($dict.obj)[$dict.attr]),
        }));
        const $updNonFn = (($tyvarName) => {
          return (($nonFn) => {
            const $$try1 = (($corelib$Dict$get)($tyvarName))($localEnv0.tyvarRenames);
            return ((($$try1)[0] === "Nothing")
              ? (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$CanonicalAst$patternPos)($pattern)))((($core$SPCore$Cons)("non fn on variable that's not in the annotation"))($core$SPCore$Nil))
              : ((($$try1)[0] === "Just")
                ? ((() => {
                  const $tr = ($$try1)[1];
                  return ($corelib$Result$Ok)(((($corelib$Dict$insert)($tr))(null))($nonFn));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 311:8', (sp_toHuman)($$try1))));
          });
        });
        return (($corelib$Result$onOk)((($nonFn) => {
          return (($corelib$Result$onOk)((($body) => {
            const $deps = ($isRoot
              ? (($sp$Compiler$MakeCanonical$expressionDeps)($body))((($sp$Compiler$MakeCanonical$patternDeps)($pattern))($sp$Compiler$MakeCanonical$deps_init))
              : $sp$Compiler$MakeCanonical$deps_init);
            return ($corelib$Result$Ok)(({
              body: $body,
              directConsDeps: $deps.cons,
              directTypeDeps: $deps.types,
              directValueDeps: $deps.values,
              mutable: ((sp_equal)($sp$Types$Token$DefMutable))($fa.modifier),
              native: false,
              nonFn: $nonFn,
              parentDefinitions: $env.defsPath,
              pattern: $pattern,
            }));
          })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($localEnv0))($fa.body));
        })))(((($corelib$List$foldlRes)($updNonFn))($fa.nonFn))($corelib$Dict$empty));
      })))(((($sp$Compiler$MakeCanonical$translatePattern)(($corelib$Maybe$Just)($renameTyvar)))($env))($fa.pattern));
    });
  });
});

const $sp$Types$FormattableAst$expressionPos = (($expr) => {
  return ((($expr)[0] === "LiteralText")
    ? ((() => {
      const $p = ($expr)[1];
      return $p;
    }))()
    : ((($expr)[0] === "LiteralNumber")
      ? ((() => {
        const $p = ($expr)[1];
        return $p;
      }))()
      : ((($expr)[0] === "Variable")
        ? ((() => {
          const $p = ($expr)[1];
          return $p;
        }))()
        : ((($expr)[0] === "Constructor")
          ? ((() => {
            const $p = ($expr)[1];
            return $p;
          }))()
          : ((($expr)[0] === "Mutable")
            ? ((() => {
              const $p = ($expr)[1];
              return $p;
            }))()
            : ((($expr)[0] === "PrefixBinop")
              ? ((() => {
                const $p = ($expr)[1];
                return $p;
              }))()
              : ((($expr)[0] === "Lambda")
                ? ((() => {
                  const $p = ($expr)[1];
                  return $p;
                }))()
                : ((($expr)[0] === "FunctionCall")
                  ? ((() => {
                    const $p = ($expr)[1];
                    return $p;
                  }))()
                  : ((($expr)[0] === "Binop")
                    ? ((() => {
                      const $p = ($expr)[1];
                      return $p;
                    }))()
                    : ((($expr)[0] === "Unop")
                      ? ((() => {
                        const $p = ($expr)[1];
                        return $p;
                      }))()
                      : ((($expr)[0] === "If")
                        ? ((() => {
                          const $p = ($expr)[1];
                          return $p;
                        }))()
                        : ((($expr)[0] === "Try")
                          ? ((() => {
                            const $p = ($expr)[1];
                            return $p;
                          }))()
                          : ((($expr)[0] === "Record")
                            ? ((() => {
                              const $p = ($expr)[1];
                              return $p;
                            }))()
                            : ((($expr)[0] === "RecordShorthand")
                              ? ((() => {
                                const $p = ($expr)[1];
                                return $p;
                              }))()
                              : ((($expr)[0] === "List")
                                ? ((() => {
                                  const $p = ($expr)[1];
                                  return $p;
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 136:4', (sp_toHuman)($expr)))))))))))))))));
});

const $sp$Types$Pos$drop = (($x) => {
  const $$a = $x;
  const $a = ($$a)[2];
  const $pos = ($$a)[1];
  return $a;
});

const $sp$Compiler$MakeCanonical$insertRootStatement = (($ro) => {
  return (($faStatement) => {
    return (($caModule) => {
      return ((($faStatement)[0] === "Evaluation")
        ? ((() => {
          const $pos = ($faStatement)[1];
          const $expr = ($faStatement)[2];
          return (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$FormattableAst$expressionPos)($expr)))((($core$SPCore$Cons)("Root Evaluations don't really do much =|"))($core$SPCore$Nil));
        }))()
        : ((($faStatement)[0] === "Definition")
          ? ((() => {
            const $pos = ($faStatement)[1];
            const $fa = ($faStatement)[2];
            return (($corelib$Result$onOk)((($def) => {
              return ($def.mutable
                ? (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$CanonicalAst$patternPos)($def.pattern)))((($core$SPCore$Cons)("Mutable values can be declared only inside functions."))($core$SPCore$Nil))
                : ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
                  valueDefs: ((($corelib$Dict$insert)($def.pattern))($def))($caModule.valueDefs),
                }))));
            })))(((($sp$Compiler$MakeCanonical$translateDefinition)(true))(($sp$Compiler$MakeCanonical$initEnv)($ro)))($fa));
          }))()
          : ((($faStatement)[0] === "TypeAlias")
            ? ((() => {
              const $fa = ($faStatement)[1];
              const $$name = $fa.name;
              const $name = ($$name)[2];
              const $pos = ($$name)[1];
              return (((($corelib$Dict$member)($name))($caModule.aliasDefs) || (($corelib$Dict$member)($name))($caModule.unionDefs))
                ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($name + " declared twice!")))($core$SPCore$Nil))
                : (($corelib$Result$onOk)((($type) => {
                  const $aliasDef = ({
                    args: $fa.args,
                    directTypeDeps: (($sp$Compiler$MakeCanonical$typeDeps)($type))($corelib$Set$empty),
                    type: $type,
                    usr: (($sp$Types$Meta$USR)($ro.currentModule))(($sp$Types$Pos$drop)($fa.name)),
                  });
                  return ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
                    aliasDefs: ((($corelib$Dict$insert)($name))($aliasDef))($caModule.aliasDefs),
                  })));
                })))(((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro))($fa.ty)));
            }))()
            : ((($faStatement)[0] === "UnionDef")
              ? ((() => {
                const $pos = ($faStatement)[1];
                const $fa = ($faStatement)[2];
                return (((($corelib$Dict$member)($fa.name))($caModule.aliasDefs) || (($corelib$Dict$member)($fa.name))($caModule.unionDefs))
                  ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($fa.name + " declared twice!")))($core$SPCore$Nil))
                  : ((() => {
                    const $usr = (($sp$Types$Meta$USR)($ro.currentModule))($fa.name);
                    const $type = ((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))((($corelib$List$map)(($sp$Types$CanonicalAst$TypeVariable)($pos)))($fa.args));
                    return (($corelib$Result$onOk)((($constructors) => {
                      const $unionDef = ({
                        args: $fa.args,
                        constructors: $constructors,
                        directTypeDeps: ((($corelib$Dict$for)($constructors))((($k) => {
                          return (($c) => {
                            return (($corelib$List$for)($c.args))($sp$Compiler$MakeCanonical$typeDeps);
                          });
                        })))($corelib$Set$empty),
                        usr: $usr,
                      });
                      return ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
                        unionDefs: ((($corelib$Dict$insert)($fa.name))($unionDef))($caModule.unionDefs),
                      })));
                    })))(((($corelib$List$foldlRes)(((($sp$Compiler$MakeCanonical$translateConstructor)($ro))($type))($usr)))($fa.constructors))($corelib$Dict$empty));
                  }))());
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 1003:4', (sp_toHuman)($faStatement))))));
    });
  });
});

const $sp$Types$CanonicalAst$initModule = (($asText) => {
  return (($umr) => {
    return ({
      aliasDefs: $corelib$Dict$empty,
      asText: $asText,
      umr: $umr,
      unionDefs: $corelib$Dict$empty,
      valueDefs: $corelib$Dict$empty,
    });
  });
});

const $sp$Compiler$MakeCanonical$translateModule = (($ro) => {
  return (($asText) => {
    return (($umr) => {
      return (($faModule) => {
        (sp_benchStart)(null);
        const $module = (($sp$Types$CanonicalAst$initModule)($asText))($umr);
        return ((($corelib$Basics$btw)(sp_benchStop))("translateModule"))(((($corelib$List$foldlRes)(($sp$Compiler$MakeCanonical$insertRootStatement)($ro)))($faModule))($module));
      });
    });
  });
});

const $sp$SPLib$Parser$andThen = (($chainedParser) => {
  return (($firstParser) => {
    return (($re0) => {
      return (($readState) => {
        const $$try1 = (($firstParser)($re0))($readState);
        return ((($$try1.second)[0] === "Accepted")
          ? ((() => {
            const $re1 = $$try1.first;
            const $nextReadState = ($$try1.second)[1];
            const $a = ($$try1.second)[2];
            return ((($chainedParser)($a))($re1))($nextReadState);
          }))()
          : ((($$try1.second)[0] === "Rejected")
            ? ((() => {
              const $re1 = $$try1.first;
              return ({
                first: $re1,
                second: $sp$SPLib$Parser$Rejected,
              });
            }))()
            : ((($$try1.second)[0] === "Aborted")
              ? ((() => {
                const $re1 = $$try1.first;
                const $rs = ($$try1.second)[1];
                const $e = ($$try1.second)[2];
                return ({
                  first: $re1,
                  second: (($sp$SPLib$Parser$Aborted)($rs))($e),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 85:4', (sp_toHuman)($$try1)))));
      });
    });
  });
});

const $sp$Compiler$Parser$andThen = $sp$SPLib$Parser$andThen;

const $sp$SPLib$Parser$consumeOne = (($rejections) => {
  return (($readState) => {
    return ((($readState)[0] === "Nil")
      ? ({
        first: ((sp_cons)($rejections))($readState),
        second: $sp$SPLib$Parser$Rejected,
      })
      : ((($readState)[0] === "Cons")
        ? ((() => {
          const $token = ($readState)[1];
          const $nextState = ($readState)[2];
          return ({
            first: $rejections,
            second: (($sp$SPLib$Parser$Accepted)($nextState))($token),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 69:4', (sp_toHuman)($readState))));
  });
});

const $sp$Compiler$Parser$oneToken = $sp$SPLib$Parser$consumeOne;

const $sp$SPLib$Parser$accept = (($a) => {
  return (($rejections) => {
    return (($readState) => {
      return ({
        first: $rejections,
        second: (($sp$SPLib$Parser$Accepted)($readState))($a),
      });
    });
  });
});

const $sp$SPLib$Parser$reject = (($rejections) => {
  return (($readState) => {
    return ({
      first: ((sp_cons)($rejections))($readState),
      second: $sp$SPLib$Parser$Rejected,
    });
  });
});

const $sp$Compiler$Parser$kind = (($targetKind) => {
  return (($sp$Compiler$Parser$andThen)((($token) => {
    const $$k = $token;
    const $k = ($$k)[3];
    return (((sp_equal)($k))($targetKind)
      ? ($sp$SPLib$Parser$accept)($token)
      : $sp$SPLib$Parser$reject);
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$discardFirst = (($a) => {
  return (($b) => {
    return (($sp$Compiler$Parser$andThen)((() => {
      return $b;
    })))($a);
  });
});

const $sp$SPLib$Parser$thenWithDefault = (($fallbackParser) => {
  return (($chainedParser) => {
    return (($firstParser) => {
      return (($re0) => {
        return (($readState) => {
          const $$try1 = (($firstParser)($re0))($readState);
          return ((($$try1.second)[0] === "Aborted")
            ? ((() => {
              const $re1 = $$try1.first;
              const $rs = ($$try1.second)[1];
              const $reason = ($$try1.second)[2];
              return ({
                first: $re1,
                second: (($sp$SPLib$Parser$Aborted)($rs))($reason),
              });
            }))()
            : ((($$try1.second)[0] === "Rejected")
              ? ((() => {
                const $re1 = $$try1.first;
                return (($fallbackParser)($re1))($readState);
              }))()
              : ((($$try1.second)[0] === "Accepted")
                ? ((() => {
                  const $re1 = $$try1.first;
                  const $nextReadState = ($$try1.second)[1];
                  const $a = ($$try1.second)[2];
                  return ((($chainedParser)($a))($re1))($nextReadState);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 100:4', (sp_toHuman)($$try1)))));
        });
      });
    });
  });
});

const $sp$SPLib$Parser$zeroOrMore = (($p) => {
  return ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)($core$SPCore$Nil)))((($head) => {
    return (($sp$SPLib$Parser$andThen)((($tail) => {
      return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))($head));
    })))(($sp$SPLib$Parser$zeroOrMore)($p));
  })))($p);
});

const $sp$Compiler$Parser$oomSeparatedBy = (($sep) => {
  return (($pa) => {
    return (($sp$Compiler$Parser$andThen)((($head) => {
      return (($sp$Compiler$Parser$andThen)((($tail) => {
        return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))($head));
      })))(($sp$SPLib$Parser$zeroOrMore)((($sp$Compiler$Parser$discardFirst)($sep))($pa)));
    })))($pa);
  });
});

const $sp$Compiler$Parser$defop = (($sp$Compiler$Parser$andThen)((($token) => {
  return (((($token)[0] === "Token") && ((($token)[3])[0] === "Defop"))
    ? ((() => {
      const $mod = (($token)[3])[1];
      return ($sp$SPLib$Parser$accept)($mod);
    }))()
    : (true
      ? $sp$SPLib$Parser$reject
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 194:4', (sp_toHuman)($token))));
})))($sp$Compiler$Parser$oneToken);

const $sp$SPLib$Parser$here = (($rejections) => {
  return (($readState) => {
    return ({
      first: $rejections,
      second: (($sp$SPLib$Parser$Accepted)($readState))($readState),
    });
  });
});

const $sp$Compiler$Parser$here = (($sp$Compiler$Parser$andThen)((($tokens) => {
  return ($sp$SPLib$Parser$accept)((((($tokens)[0] === "Cons") && ((($tokens)[1])[0] === "Token"))
    ? ((() => {
      const $mod = (($tokens)[1])[1];
      const $start = (($tokens)[1])[2];
      const $end = (($tokens)[1])[3];
      const $rest = ($tokens)[2];
      return $start;
    }))()
    : ((($tokens)[0] === "Nil")
      ? 0
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 47:9', (sp_toHuman)($tokens)))));
})))($sp$SPLib$Parser$here);

const $sp$SPLib$Parser$surroundWith = (($left) => {
  return (($right) => {
    return (($parser) => {
      return (($sp$SPLib$Parser$andThen)((() => {
        return (($sp$SPLib$Parser$andThen)((($p) => {
          return (($sp$SPLib$Parser$andThen)((() => {
            return ($sp$SPLib$Parser$accept)($p);
          })))($right);
        })))($parser);
      })))($left);
    });
  });
});

const $sp$Compiler$Parser$surroundStrict = (($left) => {
  return (($right) => {
    return (($sp$SPLib$Parser$surroundWith)(($sp$Compiler$Parser$kind)($left)))(($sp$Compiler$Parser$kind)($right));
  });
});

const $sp$Compiler$Parser$block = (($sp$Compiler$Parser$surroundStrict)($sp$Types$Token$BlockStart))($sp$Types$Token$BlockEnd);

const $sp$Compiler$Parser$sib = ($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine));

const $sp$SPLib$Parser$oneOf = (($ps) => {
  return (($rejections) => {
    return (($readState) => {
      return ((($ps)[0] === "Nil")
        ? ({
          first: $rejections,
          second: $sp$SPLib$Parser$Rejected,
        })
        : ((($ps)[0] === "Cons")
          ? ((() => {
            const $headParser = ($ps)[1];
            const $tailParsers = ($ps)[2];
            const $$try1 = (($headParser)($rejections))($readState);
            return ((($$try1.second)[0] === "Rejected")
              ? ((() => {
                const $re1 = $$try1.first;
                return ((($sp$SPLib$Parser$oneOf)($tailParsers))($re1))($readState);
              }))()
              : (true
                ? ((() => {
                  const $acceptedOrAborted = $$try1;
                  return $acceptedOrAborted;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 147:12', (sp_toHuman)($$try1))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 142:4', (sp_toHuman)($ps))));
    });
  });
});

const $sp$Compiler$Parser$inlineOrBelowOrIndented = (($p) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)($p)))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)($p)))((($core$SPCore$Cons)($p))($core$SPCore$Nil))));
});

const $sp$Compiler$Parser$binaryOperators = (($group) => {
  return (($sp$Compiler$Parser$andThen)((($$e) => {
    const $s = ($$e)[1];
    const $e = ($$e)[2];
    const $k = ($$e)[3];
    return ((($k)[0] === "Binop")
      ? ((() => {
        const $op = ($k)[1];
        return (((sp_equal)($group))($op.precedence)
          ? ($sp$SPLib$Parser$accept)($op)
          : $sp$SPLib$Parser$reject);
      }))()
      : (true
        ? $sp$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1228:4', (sp_toHuman)($k))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$pos = (($env) => {
  return (($start) => {
    return (($end) => {
      return ($env.stripLocations
        ? $sp$Types$Pos$T
        : ((($sp$Types$Pos$P)($env.moduleName))($start))($end));
    });
  });
});

const $sp$Compiler$Parser$sepListAtSep = (($sep) => {
  return (($item) => {
    return (($sp$Compiler$Parser$andThen)((($sep0) => {
      const $theParserStillSucks = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$sepListAtItem)($sep))($item))))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)((($sp$Compiler$Parser$sepListAtItem)($sep))($item))))((($core$SPCore$Cons)((($sp$Compiler$Parser$sepListAtItem)($sep))($item)))($core$SPCore$Nil))));
      return (($sp$Compiler$Parser$andThen)((($$item0) => {
        const $item0 = $$item0.first;
        const $tail = $$item0.second;
        return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))(({
          first: $sep0,
          second: $item0,
        })));
      })))($theParserStillSucks);
    })))($sep);
  });
});

const $sp$Compiler$Parser$sepListAtItem = (($sep) => {
  return (($item) => {
    return (($sp$Compiler$Parser$andThen)((($item0) => {
      const $theParserStillSucks = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$sepListAtSep)($sep))($item))))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)((($sp$Compiler$Parser$sepListAtSep)($sep))($item))))((($core$SPCore$Cons)((($sp$Compiler$Parser$sepListAtSep)($sep))($item)))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($core$SPCore$Nil)))($core$SPCore$Nil)))));
      return (($sp$Compiler$Parser$andThen)((($sepsAndItems) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $item0,
          second: $sepsAndItems,
        }));
      })))($theParserStillSucks);
    })))($item);
  });
});

const $sp$Compiler$Parser$sepList = $sp$Compiler$Parser$sepListAtItem;

const $sp$Compiler$Parser$binopsOr = (($env) => {
  return (($group) => {
    return (($higher) => {
      return (($sp$Compiler$Parser$andThen)((($start) => {
        return (($sp$Compiler$Parser$andThen)((($$head) => {
          const $head = $$head.first;
          const $sepTail = $$head.second;
          return (($sp$Compiler$Parser$andThen)((($end) => {
            return (((sp_equal)($core$SPCore$Nil))($sepTail)
              ? ($sp$SPLib$Parser$accept)($head)
              : ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Binop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($group))(({
                first: $head,
                second: $sepTail,
              }))));
          })))($sp$Compiler$Parser$here);
        })))((($sp$Compiler$Parser$sepList)(($sp$Compiler$Parser$binaryOperators)($group)))($higher));
      })))($sp$Compiler$Parser$here);
    });
  });
});

const $sp$Compiler$Parser$discardSecond = (($a) => {
  return (($b) => {
    return (($sp$Compiler$Parser$andThen)((($aa) => {
      return (($sp$Compiler$Parser$andThen)((() => {
        return ($sp$SPLib$Parser$accept)($aa);
      })))($b);
    })))($a);
  });
});

const $sp$SPLib$Parser$tuple2 = (($pa) => {
  return (($pb) => {
    return (($sp$SPLib$Parser$andThen)((($a) => {
      return (($sp$SPLib$Parser$andThen)((($b) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $a,
          second: $b,
        }));
      })))($pb);
    })))($pa);
  });
});

const $sp$SPLib$Parser$oneOrMore = (($p) => {
  return (($sp$SPLib$Parser$tuple2)($p))(($sp$SPLib$Parser$zeroOrMore)($p));
});

const $sp$Compiler$Parser$lambdaBody = (($env) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($$h) => {
    const $h = $$h.first;
    const $t = $$h.second;
    return ($sp$SPLib$Parser$accept)(((sp_cons)($t))($h));
  })))(($sp$SPLib$Parser$oneOrMore)(($sp$Compiler$Parser$sib)(($sp$Compiler$Parser$statement)($env))))))((($core$SPCore$Cons)(($sp$Compiler$Parser$inlineStatementOrBlock)($env)))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$lambdaParser = (($env) => {
  return (($mutable) => {
    return (($pa) => {
      return (($sp$Compiler$Parser$andThen)((($body) => {
        return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$Lambda)(($sp$Types$FormattableAst$patternPos)($pa)))($pa))($mutable))($body));
      })))(($sp$Compiler$Parser$lambdaBody)($env));
    });
  });
});

const $sp$SPLib$Parser$maybe = (($p) => {
  return ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)($corelib$Maybe$Nothing)))((($x) => {
    return ($sp$SPLib$Parser$accept)(($corelib$Maybe$Just)($x));
  })))($p);
});

const $sp$Compiler$Parser$rawList = (($item) => {
  const $sibsep = ($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)($sp$Types$Token$Comma));
  return (($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)($sibsep)))((($sp$Compiler$Parser$oomSeparatedBy)($sibsep))($item));
});

const $sp$Compiler$Parser$surroundMultiline = (($left) => {
  return (($right) => {
    return (($content) => {
      return (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($left)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)((($sp$Compiler$Parser$discardSecond)($content))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)($right)))));
    });
  });
});

const $sp$Compiler$Parser$list = (($env) => {
  return (($constructor) => {
    return (($main) => {
      return (($sp$Compiler$Parser$andThen)((($start) => {
        return (($sp$Compiler$Parser$andThen)((($maybeLs) => {
          return (($sp$Compiler$Parser$andThen)((($end) => {
            const $theParserStillSucks = ((($maybeLs)[0] === "Just")
              ? ((() => {
                const $ls = ($maybeLs)[1];
                return $ls;
              }))()
              : ((($maybeLs)[0] === "Nothing")
                ? $core$SPCore$Nil
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 629:8', (sp_toHuman)($maybeLs))));
            return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($theParserStillSucks));
          })))($sp$Compiler$Parser$here);
        })))(((($sp$Compiler$Parser$surroundMultiline)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed)))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$rawList)($main))));
      })))($sp$Compiler$Parser$here);
    });
  });
});

const $sp$Compiler$Parser$parens = (($sp$SPLib$Parser$surroundWith)(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed))));

const $sp$Compiler$Parser$lowerNameBare = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($token) => {
    return (((($token)[0] === "Token") && (((($token)[3])[0] === "LowerName") && ((((($token)[3])[1])[0] === "NameNoModifier") && ((((($token)[3])[2])[0] === "Nothing") && (((($token)[3])[4])[0] === "Nil")))))
      ? ((() => {
        const $start = ($token)[1];
        const $end = ($token)[2];
        const $name = (($token)[3])[3];
        return ($sp$SPLib$Parser$accept)((($sp$Types$Pos$At)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
      }))()
      : (true
        ? $sp$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 184:4', (sp_toHuman)($token))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$record = (($env) => {
  return (($assign) => {
    return (($constructor) => {
      return (($main) => {
        const $attrAssignment = (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($assign)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)($main));
        const $attr = (($sp$Compiler$Parser$andThen)((($name) => {
          return (($sp$Compiler$Parser$andThen)((($maybeAssignment) => {
            return ($sp$SPLib$Parser$accept)(({
              first: $name,
              second: $maybeAssignment,
            }));
          })))(($sp$SPLib$Parser$maybe)($attrAssignment));
        })))(($sp$Compiler$Parser$lowerNameBare)($env));
        const $updateTarget = (($sp$Compiler$Parser$andThen)((($h) => {
          return (($sp$Compiler$Parser$andThen)((() => {
            return ($sp$SPLib$Parser$accept)($h);
          })))(($sp$Compiler$Parser$kind)($sp$Types$Token$With));
        })))($main);
        const $content = (($start) => {
          return (($sp$Compiler$Parser$andThen)((($maybeUpdateTarget) => {
            return (($sp$Compiler$Parser$andThen)((($attrs) => {
              return (($sp$Compiler$Parser$andThen)((($end) => {
                return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
                  attrs: $attrs,
                  extends: $maybeUpdateTarget,
                })));
              })))($sp$Compiler$Parser$here);
            })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$rawList)($attr)));
          })))(($sp$SPLib$Parser$maybe)($updateTarget));
        });
        return (($sp$Compiler$Parser$andThen)((($s) => {
          return (($sp$Compiler$Parser$andThen)((($maybeRecord) => {
            return (($sp$Compiler$Parser$andThen)((($e) => {
              return ((($maybeRecord)[0] === "Just")
                ? ((() => {
                  const $re = ($maybeRecord)[1];
                  return ($sp$SPLib$Parser$accept)($re);
                }))()
                : ((($maybeRecord)[0] === "Nothing")
                  ? ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($s))($e)))(({
                    attrs: $core$SPCore$Nil,
                    extends: $corelib$Maybe$Nothing,
                  })))
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 676:4', (sp_toHuman)($maybeRecord))));
            })))($sp$Compiler$Parser$here);
          })))(((($sp$Compiler$Parser$surroundMultiline)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Open)))(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Closed)))(($sp$SPLib$Parser$maybe)(($content)($s))));
        })))($sp$Compiler$Parser$here);
      });
    });
  });
});

const $sp$Compiler$Parser$typeConstructorAppOr = (($env) => {
  return (($higher) => {
    return (($sp$Compiler$Parser$andThen)((($ty) => {
      return (((($ty)[0] === "TypeConstant") && ((($ty)[4])[0] === "Nil"))
        ? ((() => {
          const $p1 = ($ty)[1];
          const $maybeModule = ($ty)[2];
          const $name = ($ty)[3];
          return (($sp$Compiler$Parser$andThen)((($args) => {
            return (($sp$Compiler$Parser$andThen)((($end2) => {
              return (((sp_equal)($core$SPCore$Nil))($args)
                ? ($sp$SPLib$Parser$accept)($ty)
                : ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$TypeConstant)($p1))($maybeModule))($name))($args)));
            })))($sp$Compiler$Parser$here);
          })))(($sp$SPLib$Parser$zeroOrMore)($higher));
        }))()
        : (true
          ? ($sp$SPLib$Parser$accept)($ty)
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 962:4', (sp_toHuman)($ty))));
    })))($higher);
  });
});

const $sp$Compiler$Parser$arrow = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($$end) => {
    const $start = ($$end)[1];
    const $end = ($$end)[2];
    const $k = ($$end)[3];
    return ((($k)[0] === "Colon")
      ? ($sp$SPLib$Parser$accept)(({
        first: false,
        second: ((($sp$Compiler$Parser$pos)($env))($start))($end),
      }))
      : ((($k)[0] === "MutableColon")
        ? ($sp$SPLib$Parser$accept)(({
          first: true,
          second: ((($sp$Compiler$Parser$pos)($env))($start))($end),
        }))
        : (true
          ? $sp$SPLib$Parser$reject
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 947:4', (sp_toHuman)($k)))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$typeFunctionOr = (($env) => {
  return (($higher) => {
    const $arrowAndHigher = (($sp$Compiler$Parser$andThen)((($$mutable) => {
      const $mutable = $$mutable.first;
      const $p = $$mutable.second;
      return (($sp$Compiler$Parser$andThen)((($h) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $mutable,
          second: $p,
          third: $h,
        }));
      })))($higher);
    })))(($sp$Compiler$Parser$arrow)($env));
    const $fold = (($$nextIsMutable) => {
      const $nextIsMutable = $$nextIsMutable.first;
      const $p = $$nextIsMutable.second;
      const $ty = $$nextIsMutable.third;
      return (($$accum) => {
        const $thisIsMutable = $$accum.first;
        const $accum = $$accum.second;
        return ({
          first: $nextIsMutable,
          second: (((($sp$Types$FormattableAst$TypeFunction)($p))($ty))($thisIsMutable))($accum),
        });
      });
    });
    return (($sp$Compiler$Parser$andThen)((($fs) => {
      return (($sp$Compiler$Parser$andThen)((($e) => {
        return (($sp$Compiler$Parser$andThen)((($fe) => {
          return (($sp$Compiler$Parser$andThen)((($es) => {
            const $firstPos = ((($sp$Compiler$Parser$pos)($env))($fs))($fe);
            const $reverseRec = (($a) => {
              return (($ls) => {
                return (($accum) => {
                  return ((($ls)[0] === "Nil")
                    ? ({
                      first: $a,
                      second: $accum,
                    })
                    : ((($ls)[0] === "Cons")
                      ? ((() => {
                        const $head = ($ls)[1];
                        const $tail = ($ls)[2];
                        return ((($reverseRec)($head))($tail))(((sp_cons)($accum))($a));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 926:8', (sp_toHuman)($ls))));
                });
              });
            });
            const $$p = ((($reverseRec)(({
              first: false,
              second: $firstPos,
              third: $e,
            })))($es))($core$SPCore$Nil);
            const $reversedArgs = $$p.second;
            const $return = $$p.first.third;
            const $p = $$p.first.second;
            const $thisIsMutable = $$p.first.first;
            return ((($x) => {
              return ($sp$SPLib$Parser$accept)($x.second);
            }))(((($corelib$List$for)($reversedArgs))($fold))(({
              first: $thisIsMutable,
              second: $return,
            })));
          })))(($sp$SPLib$Parser$zeroOrMore)($arrowAndHigher));
        })))($sp$Compiler$Parser$here);
      })))($higher);
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$Compiler$Parser$typeList = (($env) => {
  return (($main) => {
    return (($sp$Compiler$Parser$andThen)((($start) => {
      return (($sp$Compiler$Parser$andThen)((($t) => {
        return (($sp$Compiler$Parser$andThen)((($end) => {
          return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeList)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($t));
        })))($sp$Compiler$Parser$here);
      })))(((($sp$Compiler$Parser$surroundStrict)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed)))($main));
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$Compiler$Parser$typeParens = (($main) => {
  return ((($sp$Compiler$Parser$surroundStrict)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open)))(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)))($main);
});

const $sp$Compiler$Parser$typeTerm = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($$end) => {
    const $start = ($$end)[1];
    const $end = ($$end)[2];
    const $k = ($$end)[3];
    return ((($k)[0] === "UpperName")
      ? ((() => {
        const $maybeModule = ($k)[1];
        const $name = ($k)[2];
        return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$TypeConstant)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($maybeModule))($name))($core$SPCore$Nil));
      }))()
      : (((($k)[0] === "LowerName") && (((($k)[1])[0] === "NameNoModifier") && (((($k)[2])[0] === "Nothing") && ((($k)[4])[0] === "Nil"))))
        ? ((() => {
          const $name = ($k)[3];
          return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeVariable)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
        }))()
        : (true
          ? $sp$SPLib$Parser$reject
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 833:4', (sp_toHuman)($k)))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$typeTupleOr = (($env) => {
  return (($higher) => {
    const $binopAndPrev = (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$binaryOperators)($sp$Types$Op$Tuple)))($higher);
    return (($sp$Compiler$Parser$andThen)((($start) => {
      return (($sp$Compiler$Parser$andThen)((($head) => {
        return (($sp$Compiler$Parser$andThen)((($tail) => {
          return (($sp$Compiler$Parser$andThen)((($end) => {
            return (((sp_equal)($core$SPCore$Nil))($tail)
              ? ($sp$SPLib$Parser$accept)($head)
              : ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeTuple)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(((sp_cons)($tail))($head))));
          })))($sp$Compiler$Parser$here);
        })))(($sp$SPLib$Parser$zeroOrMore)($binopAndPrev));
      })))($higher);
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$SPLib$Parser$breakCircularDefinition = (($a) => {
  return (($sp$SPLib$Parser$andThen)($a))(($sp$SPLib$Parser$accept)(null));
});

const $sp$SPLib$Parser$expression = (($term) => {
  return (($ops) => {
    return ((($ops)[0] === "Nil")
      ? $term
      : ((($ops)[0] === "Cons")
        ? ((() => {
          const $op = ($ops)[1];
          const $rest = ($ops)[2];
          return (($sp$SPLib$Parser$expression)(($op)($term)))($rest);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 230:4', (sp_toHuman)($ops))));
  });
});

const $sp$SPLib$Parser$higherOr = (($parser) => {
  return (($higher) => {
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($higher))((($core$SPCore$Cons)($parser))($core$SPCore$Nil)));
  });
});

const $sp$Compiler$Parser$typeExpr = (($env) => {
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$typeExpr)($env);
  }));
  const $higherOr = $sp$SPLib$Parser$higherOr;
  return (($sp$SPLib$Parser$expression)(($sp$Compiler$Parser$typeTerm)($env)))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$typeParens)($nest))))((($core$SPCore$Cons)(($higherOr)((($sp$Compiler$Parser$typeList)($env))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))($sp$Types$Token$As))($sp$Types$FormattableAst$TypeRecord))($nest))))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeConstructorAppOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeTupleOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeFunctionOr)($env)))($core$SPCore$Nil)))))));
});

const $sp$Compiler$Parser$typeAnnotation = (($env) => {
  return (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($sp$Types$Token$As)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeExpr)($env)));
});

const $sp$Compiler$Parser$patternApplication = (($env) => {
  return (($param) => {
    return (($sp$Compiler$Parser$andThen)((($$end) => {
      const $start = ($$end)[1];
      const $end = ($$end)[2];
      const $k = ($$end)[3];
      const $p = ((($sp$Compiler$Parser$pos)($env))($start))($end);
      return ((($k)[0] === "NumberLiteral")
        ? ((() => {
          const $s = ($k)[1];
          return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PatternLiteralNumber)($p))($s));
        }))()
        : ((($k)[0] === "TextLiteral")
          ? ((() => {
            const $s = ($k)[1];
            return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PatternLiteralText)($p))($s));
          }))()
          : (((($k)[0] === "LowerName") && (((($k)[2])[0] === "Nothing") && ((($k)[4])[0] === "Nil")))
            ? ((() => {
              const $modifier = ($k)[1];
              const $name = ($k)[3];
              const $thingy = (($mutable) => {
                return (($sp$Compiler$Parser$andThen)((($maybeTy) => {
                  return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$PatternAny)($p))($mutable))($name))($maybeTy));
                })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeAnnotation)($env))));
              });
              return ((($modifier)[0] === "NameNoModifier")
                ? ($thingy)(false)
                : ((($modifier)[0] === "NameMutable")
                  ? ($thingy)(true)
                  : ((($modifier)[0] === "NameStartsWithDot")
                    ? $sp$SPLib$Parser$reject
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1080:12', (sp_toHuman)($modifier)))));
            }))()
            : ((($k)[0] === "UpperName")
              ? ((() => {
                const $maybeModule = ($k)[1];
                const $name = ($k)[2];
                return (($sp$Compiler$Parser$andThen)((($params) => {
                  return (($sp$Compiler$Parser$andThen)((($end1) => {
                    return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$PatternConstructor)(((($sp$Compiler$Parser$pos)($env))($start))($end1)))($maybeModule))($name))($params));
                  })))($sp$Compiler$Parser$here);
                })))(($sp$SPLib$Parser$zeroOrMore)($param));
              }))()
              : (true
                ? $sp$SPLib$Parser$reject
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1063:4', (sp_toHuman)($k)))))));
    })))($sp$Compiler$Parser$oneToken);
  });
});

const $sp$Compiler$Parser$functionParameter = (($env) => {
  return (($nest) => {
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$patternApplication)($env))($sp$SPLib$Parser$reject)))((($core$SPCore$Cons)(($sp$Compiler$Parser$parens)($nest)))((($core$SPCore$Cons)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$PatternList))($nest)))((($core$SPCore$Cons)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal)))($sp$Types$FormattableAst$PatternRecord))($nest)))($core$SPCore$Nil)))));
  });
});

const $sp$Compiler$Parser$patternBinopOr = (($env) => {
  return (($precedenceGroup) => {
    return (($constructor) => {
      return (($higher) => {
        return (($sp$Compiler$Parser$andThen)((($start) => {
          return (($sp$Compiler$Parser$andThen)((($$head) => {
            const $head = $$head.first;
            const $sepTail = $$head.second;
            return (($sp$Compiler$Parser$andThen)((($end) => {
              return (((sp_equal)($core$SPCore$Nil))($sepTail)
                ? ($sp$SPLib$Parser$accept)($head)
                : ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(((sp_cons)((($corelib$List$map)((($x) => {
                  return $x.second;
                })))($sepTail)))($head))));
            })))($sp$Compiler$Parser$here);
          })))((($sp$Compiler$Parser$sepList)(($sp$Compiler$Parser$binaryOperators)($precedenceGroup)))($higher));
        })))($sp$Compiler$Parser$here);
      });
    });
  });
});

const $sp$Compiler$Parser$pattern = (($env) => {
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$pattern)($env);
  }));
  const $higherOr = $sp$SPLib$Parser$higherOr;
  return (($sp$SPLib$Parser$expression)((($sp$Compiler$Parser$patternApplication)($env))((($sp$Compiler$Parser$functionParameter)($env))($nest))))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$parens)($nest))))((($core$SPCore$Cons)(($higherOr)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$PatternList))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal)))($sp$Types$FormattableAst$PatternRecord))($nest))))((($core$SPCore$Cons)(((($sp$Compiler$Parser$patternBinopOr)($env))($sp$Types$Op$Cons))($sp$Types$FormattableAst$PatternListCons)))((($core$SPCore$Cons)(((($sp$Compiler$Parser$patternBinopOr)($env))($sp$Types$Op$Tuple))($sp$Types$FormattableAst$PatternTuple)))($core$SPCore$Nil))))));
});

const $sp$SPLib$Parser$map = (($f) => {
  return (($p) => {
    return (($sp$SPLib$Parser$andThen)((($b) => {
      return ($sp$SPLib$Parser$accept)(($f)($b));
    })))($p);
  });
});

const $sp$Compiler$Parser$exprWithLeftDelimiter = (($env) => {
  const $colon = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => {
    return false;
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$Colon))))((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => {
    return true;
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$MutableColon))))($core$SPCore$Nil)));
  const $maybeColon = ($sp$SPLib$Parser$maybe)($colon);
  return (($sp$Compiler$Parser$andThen)((($$end) => {
    const $start = ($$end)[1];
    const $end = ($$end)[2];
    const $k = ($$end)[3];
    const $p = ((($sp$Compiler$Parser$pos)($env))($start))($end);
    return ((($k)[0] === "NumberLiteral")
      ? ((() => {
        const $s = ($k)[1];
        return (($sp$Compiler$Parser$andThen)((($mc) => {
          return ((($mc)[0] === "Nothing")
            ? ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$LiteralNumber)($p))($s))
            : ((($mc)[0] === "Just")
              ? ((() => {
                const $mutable = ($mc)[1];
                return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((($sp$Types$FormattableAst$PatternLiteralNumber)($p))($s));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 478:20', (sp_toHuman)($mc))));
        })))($maybeColon);
      }))()
      : ((($k)[0] === "TextLiteral")
        ? ((() => {
          const $s = ($k)[1];
          return (($sp$Compiler$Parser$andThen)((($mc) => {
            return ((($mc)[0] === "Nothing")
              ? ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$LiteralText)($p))($s))
              : ((($mc)[0] === "Just")
                ? ((() => {
                  const $mutable = ($mc)[1];
                  return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((($sp$Types$FormattableAst$PatternLiteralText)($p))($s));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 485:20', (sp_toHuman)($mc))));
          })))($maybeColon);
        }))()
        : ((($k)[0] === "LowerName")
          ? ((() => {
            const $modifier = ($k)[1];
            const $maybeModule = ($k)[2];
            const $name = ($k)[3];
            const $attrs = ($k)[4];
            return ((($modifier)[0] === "NameMutable")
              ? ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Mutable)($p))($name))($attrs))
              : ((($modifier)[0] === "NameStartsWithDot")
                ? ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$RecordShorthand)($p))(((sp_cons)($attrs))($name)))
                : ((($modifier)[0] === "NameNoModifier")
                  ? (($sp$Compiler$Parser$andThen)((($mc) => {
                    return ((($mc)[0] === "Nothing")
                      ? ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$Variable)($p))($maybeModule))($name))($attrs))
                      : ((($mc)[0] === "Just")
                        ? ((() => {
                          const $mutable = ($mc)[1];
                          return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((((($sp$Types$FormattableAst$PatternAny)($p))(false))($name))($corelib$Maybe$Nothing));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 499:28', (sp_toHuman)($mc))));
                  })))($maybeColon)
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 490:16', (sp_toHuman)($modifier)))));
          }))()
          : ((($k)[0] === "UpperName")
            ? ((() => {
              const $maybeModule = ($k)[1];
              const $name = ($k)[2];
              return (($sp$Compiler$Parser$andThen)((($mc) => {
                return ((($mc)[0] === "Nothing")
                  ? ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Constructor)($p))($maybeModule))($name))
                  : ((($mc)[0] === "Just")
                    ? ((() => {
                      const $mutable = ($mc)[1];
                      return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((((($sp$Types$FormattableAst$PatternConstructor)($p))($maybeModule))($name))($core$SPCore$Nil));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 506:20', (sp_toHuman)($mc))));
              })))($maybeColon);
            }))()
            : (((($k)[0] === "RoundParen") && ((($k)[1])[0] === "Open"))
              ? ((() => {
                const $paParser = (($sp$Compiler$Parser$andThen)((($pa) => {
                  return (($sp$Compiler$Parser$andThen)((() => {
                    return (($sp$Compiler$Parser$andThen)((($mutable) => {
                      return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))($pa);
                    })))($colon);
                  })))(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)));
                })))(($sp$Compiler$Parser$pattern)($env));
                const $exprParser = (($sp$Compiler$Parser$discardSecond)(($sp$Compiler$Parser$expr)($env)))(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)));
                return ($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($paParser))((($core$SPCore$Cons)($exprParser))($core$SPCore$Nil))));
              }))()
              : (true
                ? $sp$SPLib$Parser$reject
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 475:8', (sp_toHuman)($k))))))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$maybeWithDefault = (($a) => {
  return (($p) => {
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($p))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($a)))($core$SPCore$Nil)));
  });
});

const $sp$Compiler$Parser$recInlineOrIndentedOrBelow = (($higher) => {
  return (($accum) => {
    return (($sp$Compiler$Parser$andThen)((($h) => {
      const $r = ((sp_cons)($accum))($h);
      return (($sp$Compiler$Parser$maybeWithDefault)($r))(($sp$Compiler$Parser$inlineOrBelowOrIndented)((($sp$Compiler$Parser$recInlineOrIndentedOrBelow)($higher))($r)));
    })))($higher);
  });
});

const $sp$Compiler$Parser$functionApplicationOr = (($env) => {
  return (($higher) => {
    const $recInlineOrIndented = (($accum) => {
      return (($sp$Compiler$Parser$andThen)((($h) => {
        const $r = ((sp_cons)($accum))($h);
        return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$recInlineOrIndentedOrBelow)($higher))($r))))((($core$SPCore$Cons)(($recInlineOrIndented)($r)))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($r)))($core$SPCore$Nil))));
      })))($higher);
    });
    return (($sp$Compiler$Parser$andThen)((($start) => {
      return (($sp$Compiler$Parser$andThen)((($reversedArgs) => {
        return (($sp$Compiler$Parser$andThen)((($end) => {
          const $$try1 = ($corelib$List$reverse)($reversedArgs);
          return ((($$try1)[0] === "Nil")
            ? $sp$SPLib$Parser$reject
            : (((($$try1)[0] === "Cons") && ((($$try1)[2])[0] === "Nil"))
              ? ((() => {
                const $fnExpression = ($$try1)[1];
                return ($sp$SPLib$Parser$accept)($fnExpression);
              }))()
              : ((($$try1)[0] === "Cons")
                ? ((() => {
                  const $fnExpression = ($$try1)[1];
                  const $args = ($$try1)[2];
                  return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$FunctionCall)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($fnExpression))($args));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1152:4', (sp_toHuman)($$try1)))));
        })))($sp$Compiler$Parser$here);
      })))(($recInlineOrIndented)($core$SPCore$Nil));
    })))($sp$Compiler$Parser$here);
  });
});

const $sp$SPLib$Parser$abort = (($error) => {
  return (($rejections) => {
    return (($readState) => {
      return ({
        first: $rejections,
        second: (($sp$SPLib$Parser$Aborted)($readState))($error),
      });
    });
  });
});

const $sp$Compiler$Parser$if_ = (($env) => {
  const $maybeNewLine = (($k) => {
    return (($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine))))(($sp$Compiler$Parser$kind)($k));
  });
  return (($sp$Compiler$Parser$andThen)((($$start) => {
    const $start = ($$start)[1];
    return (($sp$Compiler$Parser$andThen)((($condition) => {
      return (($sp$Compiler$Parser$andThen)((($maybeThen) => {
        return (((sp_equal)($corelib$Maybe$Nothing))($maybeThen)
          ? ($sp$SPLib$Parser$abort)("`if` should be followed by a `then` but I can't find it")
          : (($sp$Compiler$Parser$andThen)((($true) => {
            return (($sp$Compiler$Parser$andThen)((() => {
              return (($sp$Compiler$Parser$andThen)((() => {
                return (($sp$Compiler$Parser$andThen)((($false) => {
                  return (($sp$Compiler$Parser$andThen)((($end) => {
                    return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$If)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
                      condition: $condition,
                      false: $false,
                      isCompact: false,
                      true: $true,
                    })));
                  })))($sp$Compiler$Parser$here);
                })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env));
              })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$Colon)));
            })))(($maybeNewLine)($sp$Types$Token$Else));
          })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env)));
      })))(($sp$SPLib$Parser$maybe)(($maybeNewLine)($sp$Types$Token$Then)));
    })))(($sp$Compiler$Parser$expr)($env));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$If));
});

const $sp$Compiler$Parser$try_ = (($env) => {
  const $maybeNewLine = ($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)));
  const $maybeNewLineKind = (($k) => {
    return ($maybeNewLine)(($sp$Compiler$Parser$kind)($k));
  });
  const $patternAndAccept = (($sp$Compiler$Parser$andThen)((($p) => {
    return (($sp$Compiler$Parser$andThen)((() => {
      return (($sp$Compiler$Parser$andThen)((($accept) => {
        return ($sp$SPLib$Parser$accept)(({
          first: $p,
          second: $accept,
        }));
      })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env));
    })))(($maybeNewLineKind)($sp$Types$Token$Colon));
  })))(($sp$Compiler$Parser$pattern)($env));
  return (($sp$Compiler$Parser$andThen)((($$start) => {
    const $start = ($$start)[1];
    return (($sp$Compiler$Parser$andThen)((($value) => {
      return (($sp$Compiler$Parser$andThen)((() => {
        return (($sp$Compiler$Parser$andThen)((($patterns) => {
          return (($sp$Compiler$Parser$andThen)((($end) => {
            return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Try)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
              isCompact: false,
              patterns: $patterns,
              value: $value,
            })));
          })))($sp$Compiler$Parser$here);
        })))(($sp$Compiler$Parser$block)(($sp$SPLib$Parser$zeroOrMore)(($maybeNewLine)($patternAndAccept))));
      })))(($maybeNewLineKind)($sp$Types$Token$As));
    })))(($sp$Compiler$Parser$expr)($env));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$Try));
});

const $sp$Compiler$Parser$unaryOperator = (($sp$Compiler$Parser$andThen)((($token) => {
  return (((($token)[0] === "Token") && ((($token)[3])[0] === "Unop"))
    ? ((() => {
      const $s = ($token)[1];
      const $e = ($token)[2];
      const $op = (($token)[3])[1];
      return ($sp$SPLib$Parser$accept)(({
        first: $op,
        second: $token,
      }));
    }))()
    : (true
      ? $sp$SPLib$Parser$reject
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1186:4', (sp_toHuman)($token))));
})))($sp$Compiler$Parser$oneToken);

const $sp$Compiler$Parser$unopsOr = (($env) => {
  return (($higher) => {
    return (($sp$Compiler$Parser$andThen)((($maybeUnary) => {
      return (($sp$Compiler$Parser$andThen)((($right) => {
        return (($sp$Compiler$Parser$andThen)((($end) => {
          return (((($maybeUnary)[0] === "Just") && ((($maybeUnary)[1].second)[0] === "Token"))
            ? ((() => {
              const $op = ($maybeUnary)[1].first;
              const $start = (($maybeUnary)[1].second)[1];
              return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Unop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($op))($right));
            }))()
            : ((($maybeUnary)[0] === "Nothing")
              ? ($sp$SPLib$Parser$accept)($right)
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1175:4', (sp_toHuman)($maybeUnary))));
        })))($sp$Compiler$Parser$here);
      })))($higher);
    })))(($sp$SPLib$Parser$maybe)($sp$Compiler$Parser$unaryOperator));
  });
});

const $sp$Compiler$Parser$expr = (($env) => {
  const $higherOr = $sp$SPLib$Parser$higherOr;
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$expr)($env);
  }));
  return (($sp$SPLib$Parser$expression)(($sp$Compiler$Parser$exprWithLeftDelimiter)($env)))((($core$SPCore$Cons)(($higherOr)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$List))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)($sp$Types$Token$DefNormal)))($sp$Types$FormattableAst$Record))($nest))))((($core$SPCore$Cons)(($sp$Compiler$Parser$unopsOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$functionApplicationOr)($env)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Exponential)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Multiplicative)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Addittive)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Comparison)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Logical)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Tuple)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Cons)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Pipe)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Mutop)))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$if_)($env))))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$try_)($env))))($core$SPCore$Nil))))))))))))))));
});

const $sp$Compiler$Parser$inlineStatementOrBlock = (($env) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($e) => {
    return ($sp$SPLib$Parser$accept)((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)(($sp$Types$FormattableAst$expressionPos)($e)))($e)))($core$SPCore$Nil));
  })))(($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return ($sp$Compiler$Parser$expr)($env);
  })))))((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$oomSeparatedBy)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))(($sp$Compiler$Parser$statement)($env)))))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$upperNameBare = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($token) => {
    return (((($token)[0] === "Token") && (((($token)[3])[0] === "UpperName") && (((($token)[3])[1])[0] === "Nothing")))
      ? ((() => {
        const $start = ($token)[1];
        const $end = ($token)[2];
        const $name = (($token)[3])[2];
        return ($sp$SPLib$Parser$accept)((($sp$Types$Pos$At)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
      }))()
      : (true
        ? $sp$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 174:4', (sp_toHuman)($token))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$nonFunction = (($env) => {
  return (($sp$Compiler$Parser$andThen)((() => {
    return (($sp$Compiler$Parser$andThen)((($nf) => {
      return (($sp$Compiler$Parser$andThen)((($$n) => {
        const $n = ($$n)[2];
        return (((sp_equal)("NonFunction"))($n)
          ? ($sp$SPLib$Parser$accept)((($corelib$List$map)($sp$Types$Pos$drop))($nf))
          : ($sp$SPLib$Parser$abort)("Only NonFunction is supported for now"));
      })))(($sp$Compiler$Parser$upperNameBare)($env));
    })))(($sp$Compiler$Parser$rawList)(($sp$Compiler$Parser$lowerNameBare)($env)));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$With));
});

const $sp$Compiler$Parser$definition = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($start) => {
    return (($sp$Compiler$Parser$andThen)((($p) => {
      return (($sp$Compiler$Parser$andThen)((($nf) => {
        return (($sp$Compiler$Parser$andThen)((($defModifier) => {
          return (($sp$Compiler$Parser$andThen)((($body) => {
            return (($sp$Compiler$Parser$andThen)((($end) => {
              return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Definition)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
                body: $body,
                modifier: $defModifier,
                nonFn: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($nf),
                pattern: $p,
              })));
            })))($sp$Compiler$Parser$here);
          })))(($sp$Compiler$Parser$inlineStatementOrBlock)($env));
        })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)($sp$Compiler$Parser$defop));
      })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$nonFunction)($env))));
    })))(($sp$Compiler$Parser$pattern)($env));
  })))($sp$Compiler$Parser$here);
});

const $sp$Compiler$Parser$errorShouldUseDefNormalHere = "You should use a normal `=` here.";

const $sp$Compiler$Parser$typeAlias = (($env) => {
  return (($sp$Compiler$Parser$andThen)((() => {
    return (($sp$Compiler$Parser$andThen)((($name) => {
      return (($sp$Compiler$Parser$andThen)((($args) => {
        return (($sp$Compiler$Parser$andThen)((($defModifier) => {
          return (($sp$Compiler$Parser$andThen)((($ty) => {
            return (((sp_not_equal)($sp$Types$Token$DefNormal))($defModifier)
              ? ($sp$SPLib$Parser$abort)($sp$Compiler$Parser$errorShouldUseDefNormalHere)
              : ($sp$SPLib$Parser$accept)(($sp$Types$FormattableAst$TypeAlias)(({
                args: $args,
                name: $name,
                ty: $ty,
              }))));
          })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeExpr)($env)));
        })))($sp$Compiler$Parser$defop);
      })))(($sp$SPLib$Parser$zeroOrMore)(($sp$Compiler$Parser$lowerNameBare)($env)));
    })))(($sp$Compiler$Parser$upperNameBare)($env));
  })))(($sp$Compiler$Parser$kind)((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("alias"))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$unionConstructor = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($type) => {
    return (((($type)[0] === "TypeConstant") && ((($type)[2])[0] === "Nothing"))
      ? ((() => {
        const $p = ($type)[1];
        const $name = ($type)[3];
        const $args = ($type)[4];
        return ($sp$SPLib$Parser$accept)(({
          first: (($sp$Types$Pos$At)($p))($name),
          second: $args,
        }));
      }))()
      : (true
        ? $sp$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 403:4', (sp_toHuman)($type))));
  })))(($sp$Compiler$Parser$typeExpr)($env));
});

const $sp$Compiler$Parser$unionDef = (($env) => {
  return (($sp$Compiler$Parser$andThen)((() => {
    return (($sp$Compiler$Parser$andThen)((($$name) => {
      const $p = ($$name)[1];
      const $name = ($$name)[2];
      return (($sp$Compiler$Parser$andThen)((($args) => {
        return (($sp$Compiler$Parser$andThen)((($defModifier) => {
          return (($sp$Compiler$Parser$andThen)((($cons) => {
            return (((sp_not_equal)($sp$Types$Token$DefNormal))($defModifier)
              ? ($sp$SPLib$Parser$abort)($sp$Compiler$Parser$errorShouldUseDefNormalHere)
              : ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$UnionDef)($p))(({
                args: (($corelib$List$map)($sp$Types$Pos$drop))($args),
                constructors: $cons,
                name: $name,
              }))));
          })))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$rawList)(($sp$Compiler$Parser$unionConstructor)($env))));
        })))($sp$Compiler$Parser$defop);
      })))(($sp$SPLib$Parser$zeroOrMore)(($sp$Compiler$Parser$lowerNameBare)($env)));
    })))(($sp$Compiler$Parser$upperNameBare)($env));
  })))(($sp$Compiler$Parser$kind)((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("union"))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$statement = (($env) => {
  return ($sp$SPLib$Parser$breakCircularDefinition)((() => {
    return (($sp$Compiler$Parser$andThen)((() => {
      return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$typeAlias)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$unionDef)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$definition)($env)))((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($e) => {
        return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Evaluation)(($sp$Types$FormattableAst$expressionPos)($e)))($e));
      })))(($sp$Compiler$Parser$expr)($env))))($core$SPCore$Nil)))));
    })))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)));
  }));
});

const $sp$SPLib$Parser$without = (($p) => {
  return ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)(null)))((() => {
    return $sp$SPLib$Parser$reject;
  })))($p);
});

const $sp$SPLib$Parser$end = ($sp$SPLib$Parser$without)($sp$SPLib$Parser$consumeOne);

const $sp$Compiler$Parser$module_ = (($env) => {
  const $start = ($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine));
  const $e = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$kind)($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))($core$SPCore$Nil)));
  const $zzz = (($sp$Compiler$Parser$andThen)((() => {
    return $sp$SPLib$Parser$end;
  })))(($sp$SPLib$Parser$zeroOrMore)($e));
  const $statements = (($sp$Compiler$Parser$oomSeparatedBy)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))(($sp$Compiler$Parser$statement)($env));
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => {
    return $core$SPCore$Nil;
  })))($sp$SPLib$Parser$end)))((($core$SPCore$Cons)(((($sp$SPLib$Parser$surroundWith)($start))($zzz))($statements)))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$makeError = (($moduleName) => {
  return (($readState) => {
    return (($message) => {
      const $p = ((($readState)[0] === "Nil")
        ? ((($sp$Types$Pos$P)($moduleName))(0))(1)
        : (((($readState)[0] === "Cons") && ((($readState)[1])[0] === "Token"))
          ? ((() => {
            const $start = (($readState)[1])[1];
            const $end = (($readState)[1])[2];
            const $k = (($readState)[1])[3];
            const $rest = ($readState)[2];
            return ((($sp$Types$Pos$P)($moduleName))($start))($end);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 69:8', (sp_toHuman)($readState))));
      return (($sp$Compiler$Error$res)($p))((($eenv) => {
        return (($core$SPCore$Cons)($message))($core$SPCore$Nil);
      }));
    });
  });
});

const $sp$SPLib$Parser$runParser = (($parser) => {
  return (($readState) => {
    return (($parser)((($core$SPCore$Cons)($readState))($core$SPCore$Nil)))($readState);
  });
});

const $sp$Compiler$Parser$runParser = (($moduleName) => {
  return (($parser) => {
    return (($tokens) => {
      const $$failureStates = (($sp$SPLib$Parser$runParser)($parser))((($corelib$List$filter)((($$e) => {
        const $s = ($$e)[1];
        const $e = ($$e)[2];
        const $k = ($$e)[3];
        return ((sp_not_equal)($sp$Types$Token$Comment))($k);
      })))($tokens));
      const $outcome = $$failureStates.second;
      const $failureStates = $$failureStates.first;
      return ((($outcome)[0] === "Accepted")
        ? ((() => {
          const $readState = ($outcome)[1];
          const $output = ($outcome)[2];
          return ($corelib$Result$Ok)($output);
        }))()
        : ((($outcome)[0] === "Aborted")
          ? ((() => {
            const $readState = ($outcome)[1];
            const $message = ($outcome)[2];
            return ((($sp$Compiler$Parser$makeError)($moduleName))($readState))($message);
          }))()
          : ((($outcome)[0] === "Rejected")
            ? ((() => {
              const $findMin = (($readState) => {
                return (($best) => {
                  return ((($corelib$List$length)($readState) < ($corelib$List$length)($best))
                    ? $readState
                    : $best);
                });
              });
              const $readState = ((($corelib$List$for)($failureStates))($findMin))($tokens);
              const $message = ((($readState)[0] === "Nil")
                ? "I got to the end of file and I can't make sense of it. =("
                : (true
                  ? "I got stuck parsing here. =("
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 118:16', (sp_toHuman)($readState))));
              return ((($sp$Compiler$Parser$makeError)($moduleName))($readState))($message);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 103:4', (sp_toHuman)($outcome)))));
    });
  });
});

const $sp$Compiler$Parser$parse = (($stripLocations) => {
  return (($moduleName) => {
    return (($tokens) => {
      const $parser = ($sp$Compiler$Parser$module_)(({
        moduleName: $moduleName,
        stripLocations: $stripLocations,
      }));
      return ((($sp$Compiler$Parser$runParser)($moduleName))($parser))($tokens);
    });
  });
});

const $sp$Compiler$Parser$textToFormattableModule = (($pars) => {
  return (($code) => {
    const $tokensResult = (($sp$Compiler$Lexer$lexer)($pars.name))($code);
    const $tokensToStatsResult = (($tokens) => {
      (sp_benchStart)(null);
      return ((($corelib$Basics$btw)(sp_benchStop))("parse"))(((($sp$Compiler$Parser$parse)($pars.stripLocations))($pars.name))($tokens));
    });
    return (($corelib$Result$onOk)($tokensToStatsResult))($tokensResult);
  });
});

const $sp$Compiler$MakeCanonical$textToCanonicalModule = (($pars) => {
  return (($code) => {
    const $ro = ({
      currentModule: (($sp$Types$Meta$UMR)($pars.source))($pars.name),
      meta: $pars.meta,
    });
    const $umr = (($sp$Types$Meta$UMR)($pars.source))($pars.name);
    return (($corelib$Result$onOk)(((($sp$Compiler$MakeCanonical$translateModule)($ro))($code))($umr)))((($sp$Compiler$Parser$textToFormattableModule)(({
      name: $pars.name,
      stripLocations: $pars.stripLocations,
    })))($code));
  });
});

const $sp$Compiler$MakeCanonical_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$DefaultModules$asText = "library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\"\n\n    module =\n       path = SPCore\n       importAs = SPCore\n       globalTypes =\n          None\n          Bool\n          Text\n          Number\n       globalValues =\n          None\n          True\n          False\n\n    module =\n       path = SPCore/List\n       importAs = List\n\n    module =\n       path = SPCore/Maybe\n       importAs = Maybe\n       globalTypes =\n          Maybe\n       globalValues =\n          Just\n          Nothing\n\n    module =\n       path = SPCore/Text\n       importAs = Text\n\n    module =\n       path = SPCore/Tuple\n       importAs = Tuple\n\n    module =\n       path = SPCore/Debug\n       importAs = Debug\n       globalValues =\n          log\n          todo\n\n    module =\n       path = SPCore/Basics\n       globalValues =\n            assert\n            clamp\n            identity\n            modBy\n            min\n            max\n\n    module =\n       path = SPCore/Dict\n       importAs = Dict\n       globalTypes = Dict\n\n    module =\n       path = SPCore/Set\n       importAs = Set\n       globalTypes = Set\n\n    module =\n       path = SPCore/Result\n       importAs = Result\n       globalTypes = Result\n       globalValues =\n          Ok\n          Err";

const $sp$ModulesFile$initModulesFile = ({
  libraries: $core$SPCore$Nil,
  sourceDirs: $core$SPCore$Nil,
});

const $sp$SPON$posEnd = ($sp$Types$Pos$End)("");

const $sp$Types$FormattableAst$statementPos = (($statement) => {
  return ((($statement)[0] === "Evaluation")
    ? ((() => {
      const $pos = ($statement)[1];
      return $pos;
    }))()
    : ((($statement)[0] === "Definition")
      ? ((() => {
        const $pos = ($statement)[1];
        return $pos;
      }))()
      : (((($statement)[0] === "TypeAlias") && ((($statement)[1].name)[0] === "At"))
        ? ((() => {
          const $args = ($statement)[1].args;
          const $pos = (($statement)[1].name)[1];
          const $ty = ($statement)[1].ty;
          return $pos;
        }))()
        : ((($statement)[0] === "UnionDef")
          ? ((() => {
            const $pos = ($statement)[1];
            return $pos;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 116:4', (sp_toHuman)($statement))))));
});

const $sp$SPON$field = (($fieldName) => {
  return (($fieldReader) => {
    return (($statements) => {
      return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Definition") && ((((($statements)[1])[2].pattern)[0] === "PatternAny") && (!(((($statements)[1])[2].pattern)[2]) && ((((($statements)[1])[2].pattern)[4])[0] === "Nothing")))))
        ? ((() => {
          const $pos = (($statements)[1])[1];
          const $body = (($statements)[1])[2].body;
          const $modifier = (($statements)[1])[2].modifier;
          const $nonFn = (($statements)[1])[2].nonFn;
          const $name = ((($statements)[1])[2].pattern)[3];
          const $tail = ($statements)[2];
          return (((sp_equal)($fieldName))($name)
            ? ((() => {
              const $$try1 = ($fieldReader)($body);
              return ((($$try1)[0] === "Accepted")
                ? ((() => {
                  const $unreadStatements = ($$try1)[1];
                  const $a = ($$try1)[2];
                  return ((($unreadStatements)[0] === "Nil")
                    ? (($sp$SPON$Accepted)($tail))($a)
                    : ((($unreadStatements)[0] === "Cons")
                      ? ((() => {
                        const $head = ($unreadStatements)[1];
                        return ($sp$SPON$Failed)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($head)))(("Could not make sense of all the statements in field `" + ($fieldName + "`."))));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 202:24', (sp_toHuman)($unreadStatements))));
                }))()
                : (true
                  ? ((() => {
                    const $otherwise = $$try1;
                    return $otherwise;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 200:16', (sp_toHuman)($$try1))));
            }))()
            : ($sp$SPON$Rejected)((($sp$Types$Pos$At)($pos))(("expecting `" + ($fieldName + " =`")))));
        }))()
        : ((($statements)[0] === "Cons")
          ? ((() => {
            const $head = ($statements)[1];
            const $tail = ($statements)[2];
            return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($head)))("missing a simple assignment (ie `something = `)"));
          }))()
          : ((($statements)[0] === "Nil")
            ? ($sp$SPON$Rejected)((($sp$Types$Pos$At)($sp$SPON$posEnd))("unexpected end of file"))
            : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 197:4', (sp_toHuman)($statements)))));
    });
  });
});

const $sp$SPON$lowerOrUpperName = (($statements) => {
  return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Evaluation") && ((((($statements)[1])[2])[0] === "Variable") && (((((($statements)[1])[2])[2])[0] === "Nothing") && ((((($statements)[1])[2])[4])[0] === "Nil")))))
    ? ((() => {
      const $pos = ((($statements)[1])[2])[1];
      const $name = ((($statements)[1])[2])[3];
      const $tail = ($statements)[2];
      return (($sp$SPON$Accepted)($tail))($name);
    }))()
    : (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Evaluation") && ((((($statements)[1])[2])[0] === "Constructor") && ((((($statements)[1])[2])[2])[0] === "Nothing"))))
      ? ((() => {
        const $pos = ((($statements)[1])[2])[1];
        const $name = ((($statements)[1])[2])[3];
        const $tail = ($statements)[2];
        return (($sp$SPON$Accepted)($tail))($name);
      }))()
      : (((($statements)[0] === "Cons") && ((($statements)[2])[0] === "Nil"))
        ? ((() => {
          const $s = ($statements)[1];
          return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting an Uppercase or lowercase name"));
        }))()
        : (true
          ? ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a single statement"))
          : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 111:4', (sp_toHuman)($statements))))));
});

const $sp$SPON$many = (($readerA) => {
  const $rec = (($accum) => {
    return (($statements) => {
      return (((sp_equal)($core$SPCore$Nil))($statements)
        ? (($sp$SPON$Accepted)($core$SPCore$Nil))(($corelib$List$reverse)($accum))
        : ((() => {
          const $$try1 = ($readerA)($statements);
          return ((($$try1)[0] === "Accepted")
            ? ((() => {
              const $tail = ($$try1)[1];
              const $a = ($$try1)[2];
              return (($rec)(((sp_cons)($accum))($a)))($tail);
            }))()
            : ((($$try1)[0] === "Rejected")
              ? ((() => {
                const $e = ($$try1)[1];
                return ($sp$SPON$Rejected)($e);
              }))()
              : ((($$try1)[0] === "Failed")
                ? ((() => {
                  const $e = ($$try1)[1];
                  return ($sp$SPON$Failed)($e);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 168:12', (sp_toHuman)($$try1)))));
        }))());
    });
  });
  return ($rec)($core$SPCore$Nil);
});

const $sp$SPON$maybe = (($readerA) => {
  return (($statements) => {
    const $$try1 = ($readerA)($statements);
    return ((($$try1)[0] === "Accepted")
      ? ((() => {
        const $tail = ($$try1)[1];
        const $a = ($$try1)[2];
        return (($sp$SPON$Accepted)($tail))(($corelib$Maybe$Just)($a));
      }))()
      : ((($$try1)[0] === "Rejected")
        ? (($sp$SPON$Accepted)($statements))($corelib$Maybe$Nothing)
        : ((($$try1)[0] === "Failed")
          ? ((() => {
            const $r = ($$try1)[1];
            return ($sp$SPON$Failed)($r);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 183:4', (sp_toHuman)($$try1)))));
  });
});

const $sp$SPON$onAcc = (($chainedReaderB) => {
  return (($readerA) => {
    return (($statements) => {
      const $$try1 = ($readerA)($statements);
      return ((($$try1)[0] === "Accepted")
        ? ((() => {
          const $newStatements = ($$try1)[1];
          const $a = ($$try1)[2];
          return (($chainedReaderB)($a))($newStatements);
        }))()
        : ((($$try1)[0] === "Rejected")
          ? ((() => {
            const $reason = ($$try1)[1];
            return ($sp$SPON$Rejected)($reason);
          }))()
          : ((($$try1)[0] === "Failed")
            ? ((() => {
              const $reason = ($$try1)[1];
              return ($sp$SPON$Failed)($reason);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 14:4', (sp_toHuman)($$try1)))));
    });
  });
});

const $sp$SPON$return = (($a) => {
  return (($statements) => {
    return (($sp$SPON$Accepted)($statements))($a);
  });
});

const $sp$SPON$upperName = (($statements) => {
  return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Evaluation") && ((((($statements)[1])[2])[0] === "Constructor") && ((((($statements)[1])[2])[2])[0] === "Nothing"))))
    ? ((() => {
      const $pos = ((($statements)[1])[2])[1];
      const $name = ((($statements)[1])[2])[3];
      const $tail = ($statements)[2];
      return (($sp$SPON$Accepted)($tail))($name);
    }))()
    : (((($statements)[0] === "Cons") && ((($statements)[2])[0] === "Nil"))
      ? ((() => {
        const $s = ($statements)[1];
        return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting an Uppercase name"));
      }))()
      : (true
        ? ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a statement"))
        : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 98:4', (sp_toHuman)($statements)))));
});

const $sp$ModulesFile$moduleReader = (($sp$SPON$onAcc)((($path) => {
  return (($sp$SPON$onAcc)((($visibleAs) => {
    return (($sp$SPON$onAcc)((($globalTypes) => {
      return (($sp$SPON$onAcc)((($globalValues) => {
        return ($sp$SPON$return)(({
          globalTypes: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($globalTypes),
          globalValues: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($globalValues),
          path: $path,
          visibleAs: (($corelib$Maybe$withDefault)($path))($visibleAs),
        }));
      })))(($sp$SPON$maybe)((($sp$SPON$field)("globalValues"))(($sp$SPON$many)($sp$SPON$lowerOrUpperName))));
    })))(($sp$SPON$maybe)((($sp$SPON$field)("globalTypes"))(($sp$SPON$many)($sp$SPON$upperName))));
  })))(($sp$SPON$maybe)((($sp$SPON$field)("importAs"))($sp$SPON$upperName)));
})))((($sp$SPON$field)("path"))($sp$SPON$upperName));

const $sp$SPON$text = (($statements) => {
  return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Evaluation") && ((((($statements)[1])[2])[0] === "LiteralText") && ((($statements)[2])[0] === "Nil"))))
    ? ((() => {
      const $pos = ((($statements)[1])[2])[1];
      const $t = ((($statements)[1])[2])[2];
      return (($sp$SPON$Accepted)($core$SPCore$Nil))($t);
    }))()
    : (((($statements)[0] === "Cons") && ((($statements)[2])[0] === "Nil"))
      ? ((() => {
        const $s = ($statements)[1];
        return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting a text literal"));
      }))()
      : (true
        ? ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a single statement"))
        : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 85:4', (sp_toHuman)($statements)))));
});

const $sp$ModulesFile$libraryReader = (($sp$SPON$onAcc)((($source) => {
  return (($sp$SPON$onAcc)((($modules) => {
    return ($sp$SPON$return)(({
      modules: $modules,
      source: $source,
    }));
  })))(($sp$SPON$many)((($sp$SPON$field)("module"))($sp$ModulesFile$moduleReader)));
})))((($sp$SPON$field)("source"))($sp$SPON$text));

const $sp$ModulesFile$sourceDirectoryReader = (($sp$SPON$onAcc)((($path) => {
  return (($sp$SPON$onAcc)((($modules) => {
    return ($sp$SPON$return)(({
      modules: $modules,
      path: $path,
    }));
  })))(($sp$SPON$many)((($sp$SPON$field)("module"))($sp$ModulesFile$moduleReader)));
})))((($sp$SPON$field)("path"))($sp$SPON$text));

const $sp$SPON$oneOf = (($readers) => {
  return (($statements) => {
    return ((($readers)[0] === "Nil")
      ? ((() => {
        const $pos = ((($statements)[0] === "Cons")
          ? ((() => {
            const $head = ($statements)[1];
            return ($sp$Types$FormattableAst$statementPos)($head);
          }))()
          : (true
            ? $sp$SPON$posEnd
            : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 136:16', (sp_toHuman)($statements))));
        return ($sp$SPON$Rejected)((($sp$Types$Pos$At)($pos))("options exhausted"));
      }))()
      : ((($readers)[0] === "Cons")
        ? ((() => {
          const $headReader = ($readers)[1];
          const $tail = ($readers)[2];
          const $$try1 = ($headReader)($statements);
          return ((($$try1)[0] === "Rejected")
            ? (($sp$SPON$oneOf)($tail))($statements)
            : (true
              ? ((() => {
                const $otherwise = $$try1;
                return $otherwise;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 143:12', (sp_toHuman)($$try1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 133:4', (sp_toHuman)($readers))));
  });
});

const $sp$ModulesFile$modulesFileReader = ($sp$SPON$many)(($sp$SPON$oneOf)((($core$SPCore$Cons)((($sp$SPON$onAcc)((($lib) => {
  return ($sp$SPON$return)(($sp$ModulesFile$Lib)($lib));
})))((($sp$SPON$field)("library"))($sp$ModulesFile$libraryReader))))((($core$SPCore$Cons)((($sp$SPON$onAcc)((($dir) => {
  return ($sp$SPON$return)(($sp$ModulesFile$Dir)($dir));
})))((($sp$SPON$field)("sourceDir"))($sp$ModulesFile$sourceDirectoryReader))))($core$SPCore$Nil))));

const $sp$SPON$unhackPosEnd = (($moduleName) => {
  return (($pos) => {
    return ((($pos)[0] === "End")
      ? ($sp$Types$Pos$End)($moduleName)
      : (true
        ? $pos
        : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 37:4', (sp_toHuman)($pos))));
  });
});

const $sp$SPON$run = (($readerA) => {
  return (($sponName) => {
    return (($statements) => {
      const $$try1 = ($readerA)($statements);
      return (((($$try1)[0] === "Accepted") && ((($$try1)[1])[0] === "Nil"))
        ? ((() => {
          const $a = ($$try1)[2];
          return ($corelib$Result$Ok)($a);
        }))()
        : (((($$try1)[0] === "Accepted") && ((($$try1)[1])[0] === "Cons"))
          ? ((() => {
            const $head = (($$try1)[1])[1];
            const $tail = (($$try1)[1])[2];
            const $a = ($$try1)[2];
            return (($sp$Compiler$Error$res)(($sp$Types$FormattableAst$statementPos)($head)))((() => {
              return (($core$SPCore$Cons)("unread statements"))($core$SPCore$Nil);
            }));
          }))()
          : (((($$try1)[0] === "Rejected") && ((($$try1)[1])[0] === "At"))
            ? ((() => {
              const $pos = (($$try1)[1])[1];
              const $r = (($$try1)[1])[2];
              return (($sp$Compiler$Error$res)((($sp$SPON$unhackPosEnd)($sponName))($pos)))((() => {
                return (($core$SPCore$Cons)($r))($core$SPCore$Nil);
              }));
            }))()
            : (((($$try1)[0] === "Failed") && ((($$try1)[1])[0] === "At"))
              ? ((() => {
                const $pos = (($$try1)[1])[1];
                const $r = (($$try1)[1])[2];
                return (($sp$Compiler$Error$res)((($sp$SPON$unhackPosEnd)($sponName))($pos)))((() => {
                  return (($core$SPCore$Cons)($r))($core$SPCore$Nil);
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 44:4', (sp_toHuman)($$try1))))));
    });
  });
});

const $sp$SPON$read = (($reader) => {
  return (($sponName) => {
    return (($sponContent) => {
      return (($corelib$Result$onOk)((($sp$SPON$run)($reader))($sponName)))((($corelib$Result$onOk)((($sp$Compiler$Parser$parse)(false))($sponName)))((($sp$Compiler$Lexer$lexer)($sponName))($sponContent)));
    });
  });
});

const $sp$ModulesFile$textToModulesFile = (($sponName) => {
  return (($sponContent) => {
    const $insert = (($rootEntry) => {
      return (($mf) => {
        return ((($rootEntry)[0] === "Lib")
          ? ((() => {
            const $lib = ($rootEntry)[1];
            return (Object.assign)({}, $mf, ({
              libraries: ((sp_cons)($mf.libraries))($lib),
            }));
          }))()
          : ((($rootEntry)[0] === "Dir")
            ? ((() => {
              const $dir = ($rootEntry)[1];
              return (Object.assign)({}, $mf, ({
                sourceDirs: ((sp_cons)($mf.sourceDirs))($dir),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/ModulesFile.sp 149:8', (sp_toHuman)($rootEntry))));
      });
    });
    return (($corelib$Result$map)((($rootEntries) => {
      return ((($corelib$List$for)($rootEntries))($insert))($sp$ModulesFile$initModulesFile);
    })))(((($sp$SPON$read)($sp$ModulesFile$modulesFileReader))($sponName))($sponContent));
  });
});

const $sp$ModulesFile$insertModule = (($source) => {
  return (($mod) => {
    return (($meta) => {
      const $visibleAs = $mod.visibleAs;
      const $umr = (($sp$Types$Meta$UMR)($source))($mod.path);
      const $insertGlobal = (($varName) => {
        return (($corelib$Dict$insert)($varName))((($sp$Types$Meta$USR)($umr))($varName));
      });
      return ({
        globalTypes: ((($corelib$List$for)($mod.globalTypes))($insertGlobal))($meta.globalTypes),
        globalValues: ((($corelib$List$for)($mod.globalValues))($insertGlobal))($meta.globalValues),
        moduleVisibleAsToUmr: ((($corelib$Dict$insert)($visibleAs))($umr))($meta.moduleVisibleAsToUmr),
        umrToModuleVisibleAs: ((($corelib$Dict$insert)($umr))($visibleAs))($meta.umrToModuleVisibleAs),
      });
    });
  });
});

const $sp$ModulesFile$insertLibrary = (($lib) => {
  return (($meta) => {
    return (((sp_not_equal)("spcore"))($lib.source)
      ? (sp_todo)(("Library source `" + ($lib.source + "` is not supported.")))
      : ((($corelib$List$for)($lib.modules))(($sp$ModulesFile$insertModule)($sp$Types$Meta$Core)))($meta));
  });
});

const $sp$ModulesFile$insertModules = (($sd) => {
  return (($corelib$List$for)($sd.modules))(($sp$ModulesFile$insertModule)(($sp$Types$Meta$SourceDir)($sd.path)));
});

const $sp$Types$Meta$init = ({
  globalTypes: $corelib$Dict$empty,
  globalValues: $corelib$Dict$empty,
  moduleVisibleAsToUmr: $corelib$Dict$empty,
  umrToModuleVisibleAs: $corelib$Dict$empty,
});

const $sp$ModulesFile$toMeta = (($mf) => {
  return ((($corelib$List$for)($mf.sourceDirs))($sp$ModulesFile$insertModules))(((($corelib$List$for)($mf.libraries))($sp$ModulesFile$insertLibrary))($sp$Types$Meta$init));
});

const $sp$ModulesFile$textToMeta = (($sponName) => {
  return (($sponContent) => {
    return (($corelib$Result$map)($sp$ModulesFile$toMeta))((($sp$ModulesFile$textToModulesFile)($sponName))($sponContent));
  });
});

const $sp$Compiler$TestHelpers$meta = ((() => {
  const $eenv = ({
    moduleByName: (($corelib$Dict$singleton)("DefaultModules"))(({
      content: $sp$DefaultModules$asText,
      fsPath: "<DefaultModules>",
    })),
  });
  const $metaResult = (($corelib$Result$mapError)((($e) => {
    return ($sp$Compiler$TestHelpers$formattedToStrippedText)((($sp$Compiler$Error$toFormattedText)($eenv))($e));
  })))((($sp$ModulesFile$textToMeta)("DefaultModules"))($sp$DefaultModules$asText));
  return ((($metaResult)[0] === "Err")
    ? ((() => {
      const $e = ($metaResult)[1];
      ((sp_log)(("Error in DefaultModules.sp: " + $e)))(null);
      return (sp_todo)("error loading DefaultModules.sp");
    }))()
    : ((($metaResult)[0] === "Ok")
      ? ((() => {
        const $m = ($metaResult)[1];
        return $m;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TestHelpers.sp 46:4', (sp_toHuman)($metaResult))));
}))();

const $sp$Compiler$TestHelpers$source = ($sp$Types$Meta$SourceDir)("<Test>");

const $sp$Compiler$MakeCanonical_Test$params = ({
  meta: $sp$Compiler$TestHelpers$meta,
  name: $sp$Compiler$TestHelpers$moduleName,
  source: $sp$Compiler$TestHelpers$source,
  stripLocations: true,
});

const $sp$Compiler$MakeCanonical_Test$textToModule = (($code) => {
  return (($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($sp$Compiler$MakeCanonical_Test$params))($code));
});

const $sp$Compiler$MakeCanonical_Test$firstDefinition = (($code) => {
  return (($corelib$Result$onOk)((($mod) => {
    return (($corelib$Result$fromMaybe)("firstDefinition fail"))(($corelib$List$head)(($corelib$Dict$values)($mod.valueDefs)));
  })))(($sp$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sp$Compiler$MakeCanonical_Test$firstEvaluation = (($name) => {
  return (($code) => {
    return (($corelib$Result$onOk)((($def) => {
      return ($corelib$Result$Ok)($def.body);
    })))(($sp$Compiler$MakeCanonical_Test$firstDefinition)($code));
  });
});

const $sp$Test$isOk = ($sp$Test$CodeExpectation)((($toText) => {
  return (($result) => {
    return ((($result)[0] === "Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($corelib$Maybe$Just)($e);
      }))()
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return $corelib$Maybe$Nothing;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 69:8', (sp_toHuman)($result))));
  });
}));

const $sp$Compiler$MakeCanonical_Test$annotations = (($sp$Test$Group)("Annotations"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation on mutable value"))("x =\n  a as Number @=\n    3\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation on immutable value"))("b as Number =\n  3"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("b")))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$MakeCanonical_Test$p = $sp$Types$Pos$T;

const $sp$Test$freeform = (($test) => {
  return ($sp$Test$CodeExpectation)((($toText) => {
    return (($result) => {
      return ((($result)[0] === "Err")
        ? ((() => {
          const $e = ($result)[1];
          return ($corelib$Maybe$Just)($e);
        }))()
        : ((($result)[0] === "Ok")
          ? ((() => {
            const $actualOk = ($result)[1];
            return ($test)($actualOk);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 62:4', (sp_toHuman)($result))));
    });
  }));
});

const $sp$Compiler$MakeCanonical_Test$shouldHaveSameAB = (($getter) => {
  return ($sp$Test$freeform)((($$a) => {
    const $a = $$a.first;
    const $b = $$a.second;
    return (((sp_equal)(($getter)($b)))(($getter)($a))
      ? $corelib$Maybe$Nothing
      : ($corelib$Maybe$Just)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("The two don't match:"))((($core$SPCore$Cons)((sp_toHuman)(($getter)($a))))((($core$SPCore$Cons)((sp_toHuman)(($getter)($b))))($core$SPCore$Nil))))));
  }));
});

const $sp$Compiler$MakeCanonical_Test$transformAB = (($code) => {
  const $findAB = (($mod) => {
    const $$try1 = ((list_sortBy)((($def) => {
      return $def.pattern;
    })))(($corelib$Dict$values)($mod.valueDefs));
    return (((($$try1)[0] === "Cons") && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil")))
      ? ((() => {
        const $a = ($$try1)[1];
        const $b = (($$try1)[2])[1];
        return ($corelib$Maybe$Just)(({
          first: $a,
          second: $b,
        }));
      }))()
      : (true
        ? $corelib$Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical_Test.sp 48:8', (sp_toHuman)($$try1))));
  });
  return (($corelib$Result$onOk)((($x) => {
    return (($corelib$Result$fromMaybe)("findAB fail"))(($findAB)($x));
  })))(($sp$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sp$Compiler$MakeCanonical_Test$binops = (($sp$Test$Group)("Binops"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("left associativity"))("a = v >> f >> g\nb = (v >> f) >> g"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("right associativity"))("a = v :: f :: g\nb = v :: (f :: g)"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("precedence"))("a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP functional notation"))("a = (-)"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)("-")),
}))))))($core$SPCore$Nil)))));

const $sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps = (($code) => {
  return (($corelib$Result$map)((($v) => {
    return (Object.assign)({}, $v, ({
      directConsDeps: $corelib$Dict$empty,
      directTypeDeps: $corelib$Dict$empty,
      directValueDeps: $corelib$Dict$empty,
    }));
  })))(($sp$Compiler$MakeCanonical_Test$firstDefinition)($code));
});

const $sp$Compiler$MakeCanonical_Test$functions = (($sp$Test$Group)("Functions"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("[rec] lambda with two arguments"))("f =\n  a: b: 1"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("f")))($sp$Test$isOk)))($core$SPCore$Nil));

const $sp$Types$Meta$spCorePath = "SPCore";

const $sp$Types$Meta$spCoreUmr = (($sp$Types$Meta$UMR)($sp$Types$Meta$Core))($sp$Types$Meta$spCorePath);

const $sp$Types$Meta$spCoreUSR = ($sp$Types$Meta$USR)($sp$Types$Meta$spCoreUmr);

const $sp$Compiler$TestHelpers$boolType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("Bool")))($core$SPCore$Nil);

const $sp$Compiler$TestHelpers$moduleUmr = (($sp$Types$Meta$UMR)($sp$Compiler$TestHelpers$source))($sp$Compiler$TestHelpers$moduleName);

const $sp$Compiler$TestHelpers$rootLocal = (($name) => {
  return ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))($name));
});

const $sp$Compiler$MakeCanonical_Test$lists = (($sp$Test$Group)("Lists"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("list type sugar"))("l as [ Bool ] =\n  l"))($sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps))(($sp$Test$isOkAndEqualTo)(({
  body: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("l"),
  })),
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
  mutable: false,
  native: false,
  nonFn: $corelib$Dict$empty,
  parentDefinitions: $core$SPCore$Nil,
  pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)("l")))(($corelib$Maybe$Just)(($sp$Compiler$CoreTypes$list)($sp$Compiler$TestHelpers$boolType))),
})))))($core$SPCore$Nil));

const $sp$Compiler$MakeCanonical_Test$moduleAndAttributePaths = ((() => {
  const $accept = (($s) => {
    return (((($sp$Compiler$MakeCanonical_Test$codeTest)($s))(("a = " + $s)))($sp$Compiler$MakeCanonical_Test$firstDefinition))($sp$Test$isOk);
  });
  const $reject = (($s) => {
    return (($m) => {
      return (((($sp$Compiler$MakeCanonical_Test$codeTest)($s))(("a = " + $s)))($sp$Compiler$MakeCanonical_Test$firstDefinition))(($sp$Test$errorContains)((($core$SPCore$Cons)($m))($core$SPCore$Nil)));
    });
  });
  return (($sp$Test$Group)("Module and Attribute Paths"))((($core$SPCore$Cons)(($accept)("blah.blah.blah")))((($core$SPCore$Cons)((($reject)("Blah.Blah.blah"))("constructor")))((($core$SPCore$Cons)((($reject)("blah.Blah.blah"))("case")))((($core$SPCore$Cons)((($reject)("List.blah.Blah"))("lower")))((($core$SPCore$Cons)((($reject)("List..blah"))("space")))((($core$SPCore$Cons)((($reject)(".Blah"))("upper")))((($core$SPCore$Cons)((($reject)(".blah.blah"))("shorthand")))((($core$SPCore$Cons)((($reject)(".blah"))("shorthand")))((($core$SPCore$Cons)((($reject)("..."))("")))((($core$SPCore$Cons)(($accept)("x .. y")))($core$SPCore$Nil)))))))))));
}))();

const $sp$Compiler$MakeCanonical_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("[reg] record patterns are NOT extensible"))("a =\n  { b with c } = d"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("with"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$MakeCanonical_Test$pipes = (($sp$Test$Group)("Pipes"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("sendLeft is inlined"))("a = thing >> function"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Call)($sp$Compiler$MakeCanonical_Test$p))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("function"),
}))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("thing"),
}))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("sendRight is inlined"))("a = function << thing"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Call)($sp$Compiler$MakeCanonical_Test$p))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("function"),
}))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("thing"),
}))))))))($core$SPCore$Nil)));

const $sp$Compiler$MakeCanonical_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("functional update"))("a = { m with b, c = 1 }"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("m"),
}))))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "c",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "b",
  second: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("b"),
  })),
})))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("update shorthand"))("b = { a.k with y = .x }"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("b")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)(({
  attrPath: (($core$SPCore$Cons)("k"))($core$SPCore$Nil),
  ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
}))))((($corelib$Dict$singleton)("y"))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: (($core$SPCore$Cons)("k"))((($core$SPCore$Cons)("x"))($core$SPCore$Nil)),
  ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
}))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation, extensible"))("a as { b with x as Bool } =\n  a"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("disabled"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$TestHelpers$numberType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("Number")))($core$SPCore$Nil);

const $sp$Compiler$MakeCanonical_Test$tuples = (($sp$Test$Group)("Tuples"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple2"))("a = 1 & 2"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "first",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "second",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(2),
})))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple3"))("a = 1 & 2 & 3"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "first",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "second",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(2),
})))((($core$SPCore$Cons)(({
  first: "third",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(3),
})))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple4"))("a = 1 & 2 & 3 & 4"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("use a record"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple2 type"))("a as Number & Number =\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps))(($sp$Test$isOkAndEqualTo)(({
  body: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
  })),
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
  mutable: false,
  native: false,
  nonFn: $corelib$Dict$empty,
  parentDefinitions: $core$SPCore$Nil,
  pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)("a")))(($corelib$Maybe$Just)(((($sp$Types$CanonicalAst$TypeRecord)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($sp$Compiler$TestHelpers$numberType))(((($corelib$Dict$insert)("first"))($sp$Compiler$TestHelpers$numberType))($corelib$Dict$empty))))),
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple4, type"))("a as Blah & Blah & Blah & Blah =\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinition))(($sp$Test$errorContains)((($core$SPCore$Cons)("Use a record"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$MakeCanonical_Test$unionTypes = (($sp$Test$Group)("Union types"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP tuples op precedence"))("union A = X Bool & Bool"))($sp$Compiler$MakeCanonical_Test$textToModule))(($sp$Test$errorContains)((($core$SPCore$Cons)("operators"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("Tuples op precedence works with parens"))("union A = X (Bool & Bool)"))($sp$Compiler$MakeCanonical_Test$textToModule))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP [reg] Should reject uppercase arg name"))("union Outcome Token output = A"))($sp$Compiler$MakeCanonical_Test$textToModule))(($sp$Test$errorContains)((($core$SPCore$Cons)("Token"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$MakeCanonical_Test$tests = (($sp$Test$Group)("MakeCanonical"))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$unionTypes))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$binops))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$tuples))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$lists))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$moduleAndAttributePaths))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$records))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$annotations))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$pipes))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$functions))($core$SPCore$Nil)))))))))));

const $sp$Compiler$MakeEmittable$circularIsError = (($globalDefsByName) => {
  return (($names) => {
    return (($corelib$List$any)((($name) => {
      const $$try1 = (($corelib$Dict$get)($name))($globalDefsByName);
      return ((($$try1)[0] === "Nothing")
        ? false
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $globalDef = ($$try1)[1];
            const $$try2 = $globalDef.expr;
            return ((($$try2)[0] === "Lambda")
              ? false
              : (true
                ? true
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 388:14', (sp_toHuman)($$try2))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 382:6', (sp_toHuman)($$try1))));
    })))($names);
  });
});

const $sp$Compiler$MakeEmittable$generatedName = (($base) => {
  return ($sp$Compiler$MakeEmittable$DollarName)(("$$" + $base));
});

const $sp$Compiler$MakeEmittable$generateTryName = (($counter) => {
  (($counter.obj)[$counter.attr] += 1);
  return ($sp$Compiler$MakeEmittable$generatedName)(("try" + (text_fromNumber)((sp_clone)(($counter.obj)[$counter.attr]))));
});

const $sp$Compiler$MakeEmittable$pickMainName = (($pattern) => {
  return (((($pattern)[0] === "PatternAny") && ((($pattern)[2])[0] === "Just"))
    ? ((() => {
      const $name = (($pattern)[2])[1];
      return ($sp$Compiler$MakeEmittable$TrivialPattern)(($sp$Compiler$MakeEmittable$userSpecifiedName)($name));
    }))()
    : (true
      ? ((() => {
        const $$try1 = ($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($pattern));
        return ((($$try1)[0] === "Cons")
          ? ((() => {
            const $head = ($$try1)[1];
            const $tail = ($$try1)[2];
            return ($sp$Compiler$MakeEmittable$SafeMainName)(($sp$Compiler$MakeEmittable$generatedName)($head));
          }))()
          : ((($$try1)[0] === "Nil")
            ? $sp$Compiler$MakeEmittable$NoNamedVariables
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 91:12', (sp_toHuman)($$try1))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 86:4', (sp_toHuman)($pattern))));
});

const $sp$Compiler$MakeEmittable$testPattern = (($pattern) => {
  return (($valueToTest) => {
    return (($accum) => {
      return ((($pattern)[0] === "PatternAny")
        ? $accum
        : ((($pattern)[0] === "PatternLiteralText")
          ? ((() => {
            const $text = ($pattern)[2];
            return ((sp_cons)($accum))((($sp$Types$EmittableAst$ShallowEqual)(($sp$Types$EmittableAst$LiteralText)($text)))($valueToTest));
          }))()
          : ((($pattern)[0] === "PatternLiteralNumber")
            ? ((() => {
              const $num = ($pattern)[2];
              return ((sp_cons)($accum))((($sp$Types$EmittableAst$ShallowEqual)(($sp$Types$EmittableAst$LiteralNumber)($num)))($valueToTest));
            }))()
            : (((($pattern)[0] === "PatternConstructor") && ((($pattern)[2])[0] === "USR"))
              ? ((() => {
                const $umr = (($pattern)[2])[1];
                const $name = (($pattern)[2])[2];
                const $pas = ($pattern)[3];
                return ((($corelib$List$indexedFor)($pas))((($index) => {
                  return (($argPattern) => {
                    return (($sp$Compiler$MakeEmittable$testPattern)($argPattern))((($sp$Types$EmittableAst$ConstructorAccess)($index))($valueToTest));
                  });
                })))(((sp_cons)($accum))((($sp$Types$EmittableAst$IsConstructor)($name))($valueToTest)));
              }))()
              : ((($pattern)[0] === "PatternRecord")
                ? ((() => {
                  const $attrs = ($pattern)[2];
                  return ((($corelib$Dict$for)($attrs))((($name) => {
                    return (($pa) => {
                      return (($sp$Compiler$MakeEmittable$testPattern)($pa))((($sp$Types$EmittableAst$RecordAccess)($name))($valueToTest));
                    });
                  })))($accum);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 153:4', (sp_toHuman)($pattern)))))));
    });
  });
});

const $sp$Compiler$MakeEmittable$translatePatternRec = (($pattern) => {
  return (($accessExpr) => {
    return (($accum) => {
      return (((($pattern)[0] === "PatternAny") && ((($pattern)[2])[0] === "Nothing"))
        ? $accum
        : (((($pattern)[0] === "PatternAny") && ((($pattern)[2])[0] === "Just"))
          ? ((() => {
            const $name = (($pattern)[2])[1];
            return ((sp_cons)($accum))(({
              first: ($sp$Compiler$MakeEmittable$userSpecifiedName)($name),
              second: $accessExpr,
            }));
          }))()
          : ((($pattern)[0] === "PatternLiteralNumber")
            ? $accum
            : ((($pattern)[0] === "PatternLiteralText")
              ? $accum
              : ((($pattern)[0] === "PatternConstructor")
                ? ((() => {
                  const $path = ($pattern)[2];
                  const $pas = ($pattern)[3];
                  return ((($corelib$List$indexedFor)($pas))((($index) => {
                    return (($pa) => {
                      return (($sp$Compiler$MakeEmittable$translatePatternRec)($pa))((($sp$Types$EmittableAst$ConstructorAccess)($index))($accessExpr));
                    });
                  })))($accum);
                }))()
                : ((($pattern)[0] === "PatternRecord")
                  ? ((() => {
                    const $attrs = ($pattern)[2];
                    return ((($corelib$Dict$for)($attrs))((($name) => {
                      return (($pa) => {
                        return (($sp$Compiler$MakeEmittable$translatePatternRec)($pa))((($sp$Types$EmittableAst$RecordAccess)($name))($accessExpr));
                      });
                    })))($accum);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 111:4', (sp_toHuman)($pattern))))))));
    });
  });
});

const $sp$Compiler$MakeEmittable$translatePattern = (($pattern) => {
  return (($accessExpr) => {
    return ((($sp$Compiler$MakeEmittable$translatePatternRec)($pattern))($accessExpr))($core$SPCore$Nil);
  });
});

const $sp$Compiler$MakeEmittable$translateVariableArgs = (($$attrPath) => {
  const $attrPath = $$attrPath.attrPath;
  const $ref = $$attrPath.ref;
  const $variableName = ((($ref)[0] === "RefBlock")
    ? ((() => {
      const $name = ($ref)[1];
      const $$n = ($sp$Compiler$MakeEmittable$userSpecifiedName)($name);
      const $n = ($$n)[1];
      return $n;
    }))()
    : ((($ref)[0] === "RefRoot")
      ? ((() => {
        const $usr = ($ref)[1];
        return ($sp$Compiler$MakeEmittable$translateUsr)($usr);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 137:8', (sp_toHuman)($ref))));
  return (($sp$Types$EmittableAst$Variable)($variableName))($attrPath);
});

const $sp$Compiler$MakeEmittable$translateExpression = (($counter) => {
  return (($expression) => {
    return ((($expression)[0] === "LiteralNumber")
      ? ((() => {
        const $num = ($expression)[2];
        return ($sp$Types$EmittableAst$LiteralNumber)($num);
      }))()
      : ((($expression)[0] === "LiteralText")
        ? ((() => {
          const $text = ($expression)[2];
          return ($sp$Types$EmittableAst$LiteralText)($text);
        }))()
        : ((($expression)[0] === "Variable")
          ? ((() => {
            const $var = ($expression)[2];
            return ($sp$Compiler$MakeEmittable$translateVariableArgs)($var);
          }))()
          : ((($expression)[0] === "Constructor")
            ? ((() => {
              const $usr = ($expression)[2];
              return ($sp$Types$EmittableAst$Constructor)(($sp$Compiler$MakeEmittable$translateUsr)($usr));
            }))()
            : (((($expression)[0] === "Lambda") && ((($expression)[2])[0] === "ParameterMutable"))
              ? ((() => {
                const $pos = ($expression)[1];
                const $name = (($expression)[2])[2];
                const $body = ($expression)[3];
                const $$n = ($sp$Compiler$MakeEmittable$userSpecifiedName)($name);
                const $n = ($$n)[1];
                return (($sp$Types$EmittableAst$Lambda)(({
                  first: ($corelib$Maybe$Just)($n),
                  second: $sp$Types$EmittableAst$Mutable,
                })))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($body));
              }))()
              : (((($expression)[0] === "Lambda") && ((($expression)[2])[0] === "ParameterPattern"))
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $pattern = (($expression)[2])[1];
                  const $body = ($expression)[3];
                  const $$try2 = ($sp$Compiler$MakeEmittable$pickMainName)($pattern);
                  return ((($$try2)[0] === "NoNamedVariables")
                    ? (($sp$Types$EmittableAst$Lambda)(({
                      first: $corelib$Maybe$Nothing,
                      second: $sp$Types$EmittableAst$Immutable,
                    })))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($body))
                    : (((($$try2)[0] === "TrivialPattern") && ((($$try2)[1])[0] === "DollarName"))
                      ? ((() => {
                        const $argName = (($$try2)[1])[1];
                        return (($sp$Types$EmittableAst$Lambda)(({
                          first: ($corelib$Maybe$Just)($argName),
                          second: $sp$Types$EmittableAst$Immutable,
                        })))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($body));
                      }))()
                      : (((($$try2)[0] === "SafeMainName") && ((($$try2)[1])[0] === "DollarName"))
                        ? ((() => {
                          const $mainName = (($$try2)[1])[1];
                          const $namesAndExpressions = (($sp$Compiler$MakeEmittable$translatePattern)($pattern))((($sp$Types$EmittableAst$Variable)($mainName))($core$SPCore$Nil));
                          const $wrapWithArgumentLetIn = (($$letExpression) => {
                            const $varName = ($$letExpression.first)[1];
                            const $letExpression = $$letExpression.second;
                            return (($inExpression) => {
                              return ($sp$Types$EmittableAst$LetIn)(({
                                inExpression: $inExpression,
                                letExpression: $letExpression,
                                maybeName: ($corelib$Maybe$Just)($varName),
                                mutability: $sp$Types$EmittableAst$Immutable,
                              }));
                            });
                          });
                          return (($sp$Types$EmittableAst$Lambda)(({
                            first: ($corelib$Maybe$Just)($mainName),
                            second: $sp$Types$EmittableAst$Immutable,
                          })))(((($corelib$List$for)($namesAndExpressions))($wrapWithArgumentLetIn))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($body)));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 194:12', (sp_toHuman)($$try2)))));
                }))()
                : ((($expression)[0] === "Record")
                  ? ((() => {
                    const $extends = ($expression)[2];
                    const $attrs = ($expression)[3];
                    return (($sp$Types$EmittableAst$LiteralRecord)((($corelib$Maybe$map)($sp$Compiler$MakeEmittable$translateVariableArgs))($extends)))((($corelib$List$map)(($corelib$Tuple$mapSecond)(($sp$Compiler$MakeEmittable$translateExpression)($counter))))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs))));
                  }))()
                  : (((($expression)[0] === "Call") && ((($expression)[3])[0] === "ArgumentMutable"))
                    ? ((() => {
                      const $ref = ($expression)[2];
                      const $var = (($expression)[3])[2];
                      return (($sp$Types$EmittableAst$Call)((($sp$Compiler$MakeEmittable$translateExpression)($counter))($ref)))(({
                        first: ($sp$Compiler$MakeEmittable$translateVariableArgs)($var),
                        second: $sp$Types$EmittableAst$Mutable,
                      }));
                    }))()
                    : (((($expression)[0] === "Call") && ((($expression)[3])[0] === "ArgumentExpression"))
                      ? ((() => {
                        const $ref = ($expression)[2];
                        const $expr = (($expression)[3])[1];
                        return (($sp$Types$EmittableAst$Call)((($sp$Compiler$MakeEmittable$translateExpression)($counter))($ref)))(({
                          first: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($expr),
                          second: $sp$Types$EmittableAst$Immutable,
                        }));
                      }))()
                      : ((($expression)[0] === "If")
                        ? ((() => {
                          const $ar = ($expression)[2];
                          return ((($sp$Types$EmittableAst$Conditional)((($sp$Compiler$MakeEmittable$translateExpression)($counter))($ar.condition)))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($ar.true)))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($ar.false));
                        }))()
                        : ((($expression)[0] === "Try")
                          ? ((() => {
                            const $pos = ($expression)[1];
                            const $value = ($expression)[2];
                            const $tries = ($expression)[3];
                            const $$valueExpression = (((($value)[0] === "Variable") && ((($value)[2].attrPath)[0] === "Nil"))
                              ? ((() => {
                                const $ref = ($value)[2].ref;
                                return ({
                                  first: ($sp$Compiler$MakeEmittable$translateVariableArgs)(({
                                    attrPath: $core$SPCore$Nil,
                                    ref: $ref,
                                  })),
                                  second: $corelib$Basics$identity,
                                });
                              }))()
                              : (true
                                ? ((() => {
                                  const $$tryName = ($sp$Compiler$MakeEmittable$generateTryName)($counter);
                                  const $tryName = ($$tryName)[1];
                                  const $wrap = (($tryExpression) => {
                                    return ($sp$Types$EmittableAst$LetIn)(({
                                      inExpression: $tryExpression,
                                      letExpression: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($value),
                                      maybeName: ($corelib$Maybe$Just)($tryName),
                                      mutability: $sp$Types$EmittableAst$Immutable,
                                    }));
                                  });
                                  return ({
                                    first: (($sp$Types$EmittableAst$Variable)($tryName))($core$SPCore$Nil),
                                    second: $wrap,
                                  });
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 242:16', (sp_toHuman)($value))));
                            const $wrapWithLetIn = $$valueExpression.second;
                            const $valueExpression = $$valueExpression.first;
                            const $addTryPatternAndBlock = (($$block) => {
                              const $pattern = $$block.first;
                              const $block = $$block.second;
                              return (($nextTryExpression) => {
                                const $testIfPatternMatches = ($sp$Types$EmittableAst$And)(($corelib$List$reverse)(((($sp$Compiler$MakeEmittable$testPattern)($pattern))($valueExpression))($core$SPCore$Nil)));
                                const $namesAndExpressions = (($sp$Compiler$MakeEmittable$translatePattern)($pattern))($valueExpression);
                                const $whenConditionMatches = ((($corelib$List$for)($namesAndExpressions))((($$letExpression) => {
                                  const $name = ($$letExpression.first)[1];
                                  const $letExpression = $$letExpression.second;
                                  return (($inExpression) => {
                                    return ($sp$Types$EmittableAst$LetIn)(({
                                      inExpression: $inExpression,
                                      letExpression: $letExpression,
                                      maybeName: ($corelib$Maybe$Just)($name),
                                      mutability: $sp$Types$EmittableAst$Immutable,
                                    }));
                                  });
                                })))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($block));
                                return ((($sp$Types$EmittableAst$Conditional)($testIfPatternMatches))($whenConditionMatches))($nextTryExpression);
                              });
                            });
                            const $default = (($sp$Types$EmittableAst$MissingPattern)($pos))($valueExpression);
                            return ($wrapWithLetIn)(((($corelib$List$forReversed)($tries))($addTryPatternAndBlock))($default));
                          }))()
                          : ((($expression)[0] === "LetIn")
                            ? ((() => {
                              const $valueDef = ($expression)[1];
                              const $e = ($expression)[2];
                              const $$try1 = ($sp$Compiler$MakeEmittable$pickMainName)($valueDef.pattern);
                              return ((($$try1)[0] === "NoNamedVariables")
                                ? ($sp$Types$EmittableAst$LetIn)(({
                                  inExpression: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($e),
                                  letExpression: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($valueDef.body),
                                  maybeName: $corelib$Maybe$Nothing,
                                  mutability: $sp$Types$EmittableAst$Immutable,
                                }))
                                : (((($$try1)[0] === "TrivialPattern") && ((($$try1)[1])[0] === "DollarName"))
                                  ? ((() => {
                                    const $defName = (($$try1)[1])[1];
                                    return ($sp$Types$EmittableAst$LetIn)(({
                                      inExpression: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($e),
                                      letExpression: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($valueDef.body),
                                      maybeName: ($corelib$Maybe$Just)($defName),
                                      mutability: ($valueDef.mutable
                                        ? $sp$Types$EmittableAst$Mutable
                                        : $sp$Types$EmittableAst$Immutable),
                                    }));
                                  }))()
                                  : (((($$try1)[0] === "SafeMainName") && ((($$try1)[1])[0] === "DollarName"))
                                    ? ((() => {
                                      const $mainName = (($$try1)[1])[1];
                                      const $namesAndExpressions = (($sp$Compiler$MakeEmittable$translatePattern)($valueDef.pattern))((($sp$Types$EmittableAst$Variable)($mainName))($core$SPCore$Nil));
                                      const $wrapWithUnpackedPatternVar = (($$letExpression) => {
                                        const $name = ($$letExpression.first)[1];
                                        const $letExpression = $$letExpression.second;
                                        return (($inExpression) => {
                                          return ($sp$Types$EmittableAst$LetIn)(({
                                            inExpression: $inExpression,
                                            letExpression: $letExpression,
                                            maybeName: ($corelib$Maybe$Just)($name),
                                            mutability: $sp$Types$EmittableAst$Immutable,
                                          }));
                                        });
                                      });
                                      const $wrapWithActualLetIn = (($inExpression) => {
                                        return ($sp$Types$EmittableAst$LetIn)(({
                                          inExpression: $inExpression,
                                          letExpression: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($valueDef.body),
                                          maybeName: ($corelib$Maybe$Just)($mainName),
                                          mutability: $sp$Types$EmittableAst$Immutable,
                                        }));
                                      });
                                      return ($wrapWithActualLetIn)(((($corelib$List$forReversed)($namesAndExpressions))($wrapWithUnpackedPatternVar))((($sp$Compiler$MakeEmittable$translateExpression)($counter))($e)));
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 289:12', (sp_toHuman)($$try1)))));
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 176:4', (sp_toHuman)($expression))))))))))))));
  });
});

const $sp$Compiler$MakeEmittable$translateRootValueDef = (($umr) => {
  return (($def) => {
    return (($accum) => {
      const $counter = ({
        attr: "$",
        obj: ({
          $: (sp_clone)(0),
        }),
      });
      const $deps = (($corelib$Set$map)($sp$Compiler$MakeEmittable$translateUsr))($def.directValueDeps);
      const $$try1 = ($sp$Compiler$MakeEmittable$pickMainName)($def.pattern);
      return ((($$try1)[0] === "NoNamedVariables")
        ? $accum
        : ((($$try1)[0] === "TrivialPattern")
          ? ((() => {
            const $name = ($$try1)[1];
            const $usrAsText = (($sp$Compiler$MakeEmittable$makeTextUsr)($umr))($name);
            return ((($corelib$Dict$insert)($usrAsText))(({
              deps: $deps,
              expr: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($def.body),
              name: $usrAsText,
            })))($accum);
          }))()
          : ((($$try1)[0] === "SafeMainName")
            ? ((() => {
              const $mainName = ($$try1)[1];
              const $mainUsrAsText = (($sp$Compiler$MakeEmittable$makeTextUsr)($umr))($mainName);
              const $mainDef = ({
                deps: $deps,
                expr: (($sp$Compiler$MakeEmittable$translateExpression)($counter))($def.body),
                name: $mainUsrAsText,
              });
              return ((($corelib$List$for)((($sp$Compiler$MakeEmittable$translatePattern)($def.pattern))((($sp$Types$EmittableAst$Variable)($mainUsrAsText))($core$SPCore$Nil))))((($$expr) => {
                const $name = $$expr.first;
                const $expr = $$expr.second;
                const $textUsr = (($sp$Compiler$MakeEmittable$makeTextUsr)($umr))($name);
                return (($corelib$Dict$insert)($textUsr))(({
                  deps: ($corelib$Set$singleton)($mainUsrAsText),
                  expr: $expr,
                  name: $textUsr,
                }));
              })))(((($corelib$Dict$insert)($mainUsrAsText))($mainDef))($accum));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeEmittable.sp 341:4', (sp_toHuman)($$try1)))));
    });
  });
});

const $sp$Prelude$functions = (($core$SPCore$Cons)($sp$Prelude$compare))((($core$SPCore$Cons)($sp$Prelude$debugTodo))((($core$SPCore$Cons)($sp$Prelude$debugLog))((($core$SPCore$Cons)($sp$Prelude$debugToHuman))((($core$SPCore$Cons)($sp$Prelude$debugBenchStart))((($core$SPCore$Cons)($sp$Prelude$debugBenchStop))($core$SPCore$Nil))))));

const $sp$Prelude$insertInModule = (($usr) => {
  return (($type) => {
    return (($nonFn) => {
      const $$name = $usr;
      const $name = ($$name)[2];
      const $umr = ($$name)[1];
      const $def = ({
        body: (($sp$Types$CanonicalAst$LiteralText)($sp$Types$Pos$N))($name),
        directConsDeps: $corelib$Dict$empty,
        directTypeDeps: $corelib$Dict$empty,
        directValueDeps: $corelib$Dict$empty,
        mutable: false,
        native: true,
        nonFn: ($corelib$Set$fromList)($nonFn),
        parentDefinitions: $core$SPCore$Nil,
        pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Types$Pos$N))(($corelib$Maybe$Just)($name)))(($corelib$Maybe$Just)($type)),
      });
      const $update = (($maybeModule) => {
        return ((($module) => {
          return ($corelib$Maybe$Just)((Object.assign)({}, $module, ({
            valueDefs: ((($corelib$Dict$insert)($def.pattern))($def))($module.valueDefs),
          })));
        }))((($corelib$Maybe$withDefault)(({
          aliasDefs: $corelib$Dict$empty,
          asText: "",
          umr: $umr,
          unionDefs: $corelib$Dict$empty,
          valueDefs: $corelib$Dict$empty,
        })))($maybeModule));
      });
      return (($corelib$Dict$update)($umr))($update);
    });
  });
});

const $sp$Prelude$insertBinop = (($binop) => {
  return ((($sp$Prelude$insertInModule)($binop.usr))($binop.type))($binop.nonFn);
});

const $sp$Prelude$insertFunction = (($function) => {
  return ((($sp$Prelude$insertInModule)($function.usr))($function.type))($function.nonFn);
});

const $sp$Prelude$insertUnop = (($unop) => {
  return ((($sp$Prelude$insertInModule)($unop.usr))($unop.type))($core$SPCore$Nil);
});

const $sp$Prelude$coreModulesByUmr = ((($corelib$List$for)($sp$Prelude$functions))($sp$Prelude$insertFunction))(((($corelib$List$for)($sp$Prelude$binops))($sp$Prelude$insertBinop))((($sp$Prelude$insertUnop)($sp$Prelude$unaryMinus))((($sp$Prelude$insertUnop)($sp$Prelude$unaryPlus))($corelib$Dict$empty))));

const $sp$Prelude$coreModules = ($corelib$Dict$values)($sp$Prelude$coreModulesByUmr);

const $sp$Compiler$MakeEmittable$translateAll = (($userModules) => {
  (sp_benchStart)(null);
  const $modules = ($corelib$List$concat)((($core$SPCore$Cons)($userModules))((($core$SPCore$Cons)($sp$Prelude$coreModules))($core$SPCore$Nil)));
  const $globalDefsByName = ((($corelib$List$for)($modules))((($module) => {
    return (($corelib$Dict$for)($module.valueDefs))((() => {
      return (($def) => {
        return (($sp$Compiler$MakeEmittable$translateRootValueDef)($module.umr))($def);
      });
    }));
  })))($corelib$Dict$empty);
  const $$circulars = (($sp$RefHierarchy$reorder)((($globalDef) => {
    return $globalDef.deps;
  })))($globalDefsByName);
  const $reorderedNames = $$circulars.second;
  const $circulars = $$circulars.first;
  (sp_benchStop)("makeEmittable");
  const $errors = (($corelib$List$filter)(($sp$Compiler$MakeEmittable$circularIsError)($globalDefsByName)))($circulars);
  return (((sp_not_equal)($core$SPCore$Nil))($errors)
    ? ($corelib$Result$Err)($errors)
    : ($corelib$Result$Ok)((($corelib$List$filterMap)((($name) => {
      return (($corelib$Dict$get)($name))($globalDefsByName);
    })))($reorderedNames)));
});

const $sp$Compiler$Parser$binopInsideParens = (($env) => {
  return (($sp$Compiler$Parser$andThen)((($$end) => {
    const $start = ($$end)[1];
    const $end = ($$end)[2];
    const $k = ($$end)[3];
    return ((($k)[0] === "Binop")
      ? ((() => {
        const $binop = ($k)[1];
        return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PrefixBinop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($binop.symbol));
      }))()
      : (true
        ? $sp$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1204:4', (sp_toHuman)($k))));
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$inlineOrIndented = (($p) => {
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)($p)))((($core$SPCore$Cons)($p))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$Parser_Test$asDefinition = (($s) => {
  return ((($s)[0] === "Definition")
    ? ((() => {
      const $a = ($s)[2];
      return ($corelib$Result$Ok)($a);
    }))()
    : (true
      ? ($corelib$Result$Err)("Test says: no def")
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 29:4', (sp_toHuman)($s))));
});

const $sp$Compiler$Parser_Test$firstStatement = (($code) => {
  const $grabFirst = (($stats) => {
    return ((($stats)[0] === "Nil")
      ? ($corelib$Result$Err)("Test says: no statements")
      : ((($stats)[0] === "Cons")
        ? ((() => {
          const $head = ($stats)[1];
          const $tail = ($stats)[2];
          return ($corelib$Result$Ok)($head);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 52:8', (sp_toHuman)($stats))));
  });
  return (($corelib$Result$onOk)($grabFirst))((($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))((($sp$Compiler$Parser$textToFormattableModule)(({
    name: "Test",
    stripLocations: true,
  })))($code)));
});

const $sp$Compiler$Parser_Test$firstAnnotation = (($code) => {
  const $grabAnnotation = (($def) => {
    const $$try1 = $def.pattern;
    return (((($$try1)[0] === "PatternAny") && ((($$try1)[4])[0] === "Just"))
      ? ((() => {
        const $pos = ($$try1)[1];
        const $name = ($$try1)[2];
        const $mutable = ($$try1)[3];
        const $ty = (($$try1)[4])[1];
        return ($corelib$Result$Ok)($ty);
      }))()
      : (true
        ? ($corelib$Result$Err)("no annotation")
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 94:8', (sp_toHuman)($$try1))));
  });
  return (($corelib$Result$onOk)($grabAnnotation))((($corelib$Result$onOk)($sp$Compiler$Parser_Test$asDefinition))(($sp$Compiler$Parser_Test$firstStatement)($code)));
});

const $sp$Compiler$Parser_Test$p = $sp$Types$Pos$T;

const $sp$Compiler$Parser_Test$typeConstant = (($name) => {
  return (((($sp$Types$FormattableAst$TypeConstant)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))($name))($core$SPCore$Nil);
});

const $sp$Compiler$Parser_Test$annotations = (($sp$Test$Group)("Annotations"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Mutability 1"))("a as Number @: Int: None =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Number")))(true))((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int")))(false))(($sp$Compiler$Parser_Test$typeConstant)("None")))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Mutability 2"))("a as Number: Int @: None =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Number")))(false))((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int")))(true))(($sp$Compiler$Parser_Test$typeConstant)("None")))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Tuple precedence"))("a as Int & Int: Bool =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$TypeTuple)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)(($sp$Compiler$Parser_Test$typeConstant)("Int")))((($core$SPCore$Cons)(($sp$Compiler$Parser_Test$typeConstant)("Int")))($core$SPCore$Nil)))))(false))(($sp$Compiler$Parser_Test$typeConstant)("Bool"))))))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$asEvaluation = (($s) => {
  return ((($s)[0] === "Evaluation")
    ? ((() => {
      const $a = ($s)[2];
      return ($corelib$Result$Ok)($a);
    }))()
    : (true
      ? ($corelib$Result$Err)("Test says: no eval")
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 39:4', (sp_toHuman)($s))));
});

const $sp$Compiler$Parser_Test$firstDefinition = (($code) => {
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asDefinition))(($sp$Compiler$Parser_Test$firstStatement)($code));
});

const $sp$Compiler$Parser_Test$firstEvaluationOfDefinition = (($code) => {
  const $grabFirst = (($def) => {
    const $$try1 = $def.body;
    return ((($$try1)[0] === "Nil")
      ? ($corelib$Result$Err)("Test says: empty def body")
      : ((($$try1)[0] === "Cons")
        ? ((() => {
          const $head = ($$try1)[1];
          const $tail = ($$try1)[2];
          return ($corelib$Result$Ok)($head);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 79:8', (sp_toHuman)($$try1))));
  });
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asEvaluation))((($corelib$Result$onOk)($grabFirst))(($sp$Compiler$Parser_Test$firstDefinition)($code)));
});

const $sp$Compiler$Parser_Test$binops = ((() => {
  const $sendBtoC = (($b) => {
    return (($c) => {
      return ((($sp$Types$FormattableAst$Binop)($sp$Compiler$Parser_Test$p))($sp$Types$Op$Pipe))(({
        first: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil),
        second: (($core$SPCore$Cons)(({
          first: $sp$Prelude$sendRight,
          second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil),
        })))($core$SPCore$Nil),
      }));
    });
  });
  const $sendBtoCtoD = (($b) => {
    return (($c) => {
      return (($d) => {
        return ((($sp$Types$FormattableAst$Binop)($sp$Compiler$Parser_Test$p))($sp$Types$Op$Pipe))(({
          first: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil),
          second: (($core$SPCore$Cons)(({
            first: $sp$Prelude$sendRight,
            second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil),
          })))((($core$SPCore$Cons)(({
            first: $sp$Prelude$sendRight,
            second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("d"))($core$SPCore$Nil),
          })))($core$SPCore$Nil)),
        }));
      });
    });
  });
  return (($sp$Test$Group)("Binops"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("no indent"))("a = b >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(5))(10)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("assignment indent"))("a =\n    b >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(9))(14)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pipe indent"))("a =\n    b\n      >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(9))(20)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pipe indent"))("a =\n    b\n      >> c\n      >> d"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)(((($sendBtoCtoD)(9))(20))(31)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pyramid indent"))("a =\n    b\n      >> c\n        >> d"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)(((($sendBtoCtoD)(9))(20))(33)))))($core$SPCore$Nil))))));
}))();

const $sp$Compiler$Parser_Test$firstEvaluation = (($code) => {
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asEvaluation))(($sp$Compiler$Parser_Test$firstStatement)($code));
});

const $sp$Compiler$Parser_Test$ifs = (($sp$Test$Group)("Ifs"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("inline"))("a = if a then b else c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP multiline, formatted"))("x =\n    if a then\n        b\n    else\n        c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, compact"))("x =\n  if a then b\n  else c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$lambdas = (($sp$Test$Group)("lambdas"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Inline nesting"))("a: b: 3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Block nesting"))("a:\n  b:\n    3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Sibling nesting"))("a:\nb:\n3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Tuple has precedence over lambda"))("x =\n  a & b: a"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] pass to function without parens"))("i =\n  x @= 1\n  xxx y: y"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil))))));

const $sp$Compiler$Parser_Test$lists = (($sp$Test$Group)("Lists"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Inline"))("[1, 2]"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Multiline canonical"))("a =\n  [\n  , 1\n  , 2\n  ]"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Multiline compact"))("a = [\n  , 1\n  , 2\n  ]"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$parens = (($sp$Test$Group)("Parens"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Can exist on multiple lines even when useless"))("tests =\n    (Ok\n    )"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Can exist on multiple lines"))("tests =\n    blah\n        (Ok\n        )"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list unpacking"))("[a, b] = x"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$PatternList)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))((($core$SPCore$Cons)((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list unpacking, inner block"))("x =\n   [ a, b ] = c"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("record unpacking"))("{ a, b } = x"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$PatternRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("a"),
    second: $corelib$Maybe$Nothing,
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("b"),
    second: $corelib$Maybe$Nothing,
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("record unpacking, inner block"))("x =\n  { a, b } = c"))((($x) => {
  return (($corelib$Result$map)((($y) => {
    return $y.pattern;
  })))(($sp$Compiler$Parser_Test$firstDefinition)($x));
})))($sp$Test$isOk)))($core$SPCore$Nil)))));

const $sp$Compiler$Parser_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("inline"))("a = { x = 1 }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline"))("a =\n  {\n  , x = 1\n  , y = 2\n  }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("y"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")),
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline compact"))("a = {\n  , x = 1\n  , y = 2\n  }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("y"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")),
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Annotation, inline"))("a as { x as Bool } =\n  a"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Annotation, own line"))("a as\n   { x as Bool }\n   =\n   1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Annotation, multiline"))("a as {\n   , x as Bool\n   }\n      =\n      a"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, inline"))("a = { b with c }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, as block"))("a =\n  { b with c }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, as block"))("a =\n  { b with c = 1 }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] real-world use"))("a =\n  { state with\n      , pos = endPos\n      , code = rest\n      , accum =\n          { kind = Token.Comment\n          , start = startPos\n          , end = endPos\n          }\n              :: state.accum\n  }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)))))))))));

const $sp$Compiler$Parser_Test$tries = (($sp$Test$Group)("Try"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, formatted"))("x =\n  try a as\n    b:\n      c\n    d:\n      e"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, compact"))("x =\n  try a as\n    b: c\n    d: e"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$unionDefs = ((() => {
  const $asTypeDef = (($s) => {
    return ((($s)[0] === "UnionDef")
      ? ((() => {
        const $a = ($s)[2];
        return ($corelib$Result$Ok)($a);
      }))()
      : (true
        ? ($corelib$Result$Err)("no type def")
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 322:8', (sp_toHuman)($s))));
  });
  const $firstTypeDef = (($x) => {
    return (($corelib$Result$onOk)($asTypeDef))(($sp$Compiler$Parser_Test$firstStatement)($x));
  });
  return (($sp$Test$Group)("Type Definitions"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Parse inline def"))("union A b c = V1 b, V2 c, V3, V4 b c"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: (($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)),
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V1"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("b")))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V2"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("c")))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V3"),
      second: $core$SPCore$Nil,
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V4"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("b")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("c")))($core$SPCore$Nil)),
    })))($core$SPCore$Nil)))),
    name: "A",
  })))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Parse multiline def"))("union A =\n   , V1\n   , V2"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: $core$SPCore$Nil,
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V1"),
      second: $core$SPCore$Nil,
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V2"),
      second: $core$SPCore$Nil,
    })))($core$SPCore$Nil)),
    name: "A",
  })))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list argument"))("union A = A [Int]"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: $core$SPCore$Nil,
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("A"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeList)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int"))))($core$SPCore$Nil),
    })))($core$SPCore$Nil),
    name: "A",
  })))))($core$SPCore$Nil))));
}))();

const $sp$Compiler$Parser_Test$values = (($sp$Test$Group)("Values"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] Unop"))("a = f -n"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] deal with spurious NewSiblingLine introduced by inline comments"))("library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\""))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$tests = (($sp$Test$Group)("Parser"))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$values))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$parens))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$lambdas))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$annotations))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$unionDefs))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$lists))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$records))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$ifs))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$tries))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$binops))($core$SPCore$Nil))))))))))));

const $sp$Compiler$Pipeline$insertUnionConstructors = (($typeDef) => {
  return (($constructors) => {
    return ((($typeDef)[0] === "TypeDefAlias")
      ? $constructors
      : ((($typeDef)[0] === "TypeDefUnion")
        ? ((() => {
          const $def = ($typeDef)[1];
          const $$umr = $def.usr;
          const $umr = ($$umr)[1];
          return ((($corelib$Dict$for)($def.constructors))((($name) => {
            return ($corelib$Dict$insert)((($sp$Types$Meta$USR)($umr))($name));
          })))($constructors);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Pipeline.sp 35:4', (sp_toHuman)($typeDef))));
  });
});

const $sp$Compiler$Pipeline$coreConstructors = ((($corelib$List$for)($sp$Compiler$CoreTypes$allDefs))((($u) => {
  return ($sp$Compiler$Pipeline$insertUnionConstructors)(($sp$Types$CanonicalAst$TypeDefUnion)($u));
})))($corelib$Dict$empty);

const $sp$Compiler$Pipeline$coreTypes = ((($corelib$List$for)($sp$Compiler$CoreTypes$allDefs))((($def) => {
  return (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefUnion)($def));
})))($corelib$Dict$empty);

const $sp$Compiler$TypeCheck$typeTyvars = (($ty) => {
  return ((($ty)[0] === "TypeVariable")
    ? ((() => {
      const $pos = ($ty)[1];
      const $name = ($ty)[2];
      return (($corelib$Dict$singleton)($name))($pos);
    }))()
    : ((($ty)[0] === "TypeFunction")
      ? ((() => {
        const $from = ($ty)[2];
        const $fromIsMutable = ($ty)[3];
        const $to = ($ty)[4];
        return (($corelib$Dict$join)(($sp$Compiler$TypeCheck$typeTyvars)($from)))(($sp$Compiler$TypeCheck$typeTyvars)($to));
      }))()
      : ((($ty)[0] === "TypeConstant")
        ? ((() => {
          const $pos = ($ty)[1];
          const $ref = ($ty)[2];
          const $args = ($ty)[3];
          return ((($corelib$List$for)($args))((($a) => {
            return ($corelib$Dict$join)(($sp$Compiler$TypeCheck$typeTyvars)($a));
          })))($corelib$Dict$empty);
        }))()
        : ((($ty)[0] === "TypeAlias")
          ? ((() => {
            const $path = ($ty)[2];
            const $t = ($ty)[3];
            return ($sp$Compiler$TypeCheck$typeTyvars)($t);
          }))()
          : ((($ty)[0] === "TypeRecord")
            ? ((() => {
              const $pos = ($ty)[1];
              const $extensible = ($ty)[2];
              const $attrs = ($ty)[3];
              const $init = ((($extensible)[0] === "Nothing")
                ? $corelib$Dict$empty
                : ((($extensible)[0] === "Just")
                  ? ((() => {
                    const $name = ($extensible)[1];
                    return (($corelib$Dict$singleton)($name))($pos);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 351:16', (sp_toHuman)($extensible))));
              return ((($corelib$Dict$for)($attrs))((($n) => {
                return (($t) => {
                  return ($corelib$Dict$join)(($sp$Compiler$TypeCheck$typeTyvars)($t));
                });
              })))($init);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 335:4', (sp_toHuman)($ty)))))));
});

const $sp$Compiler$TypeCheck$getFreeTypeVars = (($nonFreeTyvars) => {
  return (($nonFn) => {
    return (($ty) => {
      const $posToTyvar = (($name) => {
        return (($pos) => {
          return ({
            nonFn: (($corelib$Dict$member)($name))($nonFn),
          });
        });
      });
      return (($corelib$Dict$map)($posToTyvar))((($corelib$Dict$diff)(($sp$Compiler$TypeCheck$typeTyvars)($ty)))($nonFreeTyvars));
    });
  });
});

const $sp$Compiler$Pipeline$getFreeTypeVars = $sp$Compiler$TypeCheck$getFreeTypeVars;

const $sp$Compiler$Pipeline$coreVariables = ((() => {
  const $insertUnop = (($unop) => {
    const $usr = ($sp$Types$Meta$spCoreUSR)($unop.symbol);
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: $corelib$Dict$empty,
      isMutable: false,
      ty: $unop.type,
    });
    return (($corelib$Dict$insert)($usr))($iv);
  });
  const $insertBinop = (($symbol) => {
    return (($binop) => {
      const $usr = ($sp$Types$Meta$spCoreUSR)($symbol);
      const $iv = ({
        definedAt: $sp$Types$Pos$N,
        freeTypeVariables: ((($sp$Compiler$Pipeline$getFreeTypeVars)($corelib$Dict$empty))(($corelib$Set$fromList)($binop.nonFn)))($binop.type),
        isMutable: false,
        ty: $binop.type,
      });
      return (($corelib$Dict$insert)($usr))($iv);
    });
  });
  const $insertCoreFunction = (($coreFn) => {
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: ((($sp$Compiler$Pipeline$getFreeTypeVars)($corelib$Dict$empty))(($corelib$Set$fromList)($coreFn.nonFn)))($coreFn.type),
      isMutable: false,
      ty: $coreFn.type,
    });
    return (($corelib$Dict$insert)($coreFn.usr))($iv);
  });
  return ((($corelib$List$for)($sp$Prelude$functions))($insertCoreFunction))(((($corelib$Dict$for)($sp$Prelude$binopsBySymbol))($insertBinop))((($insertUnop)($sp$Prelude$unaryMinus))((($insertUnop)($sp$Prelude$unaryPlus))($corelib$Dict$empty))));
}))();

const $sp$Types$CanonicalAst$patternNamedTypes = (($p) => {
  return (((($p)[0] === "PatternAny") && ((($p)[2])[0] === "Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return $corelib$Dict$empty;
    }))()
    : (((($p)[0] === "PatternAny") && ((($p)[2])[0] === "Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $n = (($p)[2])[1];
        const $maybeType = ($p)[3];
        return (($corelib$Dict$singleton)($n))(({
          first: $pos,
          second: $maybeType,
        }));
      }))()
      : ((($p)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return $corelib$Dict$empty;
        }))()
        : ((($p)[0] === "PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return $corelib$Dict$empty;
          }))()
          : ((($p)[0] === "PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $path = ($p)[2];
              const $ps = ($p)[3];
              return ((($corelib$List$for)($ps))((($x) => {
                return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNamedTypes)($x));
              })))($corelib$Dict$empty);
            }))()
            : ((($p)[0] === "PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[2];
                return ((($corelib$Dict$for)($ps))((($k) => {
                  return (($v) => {
                    return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNamedTypes)($v));
                  });
                })))($corelib$Dict$empty);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 223:4', (sp_toHuman)($p))))))));
});

const $sp$Compiler$Pipeline$expandAndInsertModuleAnnotations = (($types) => {
  return (($module) => {
    const $insertName = (($def) => {
      return (($name) => {
        return (($$maybeType) => {
          const $pos = $$maybeType.first;
          const $maybeType = $$maybeType.second;
          return (($d) => {
            return ((($maybeType)[0] === "Nothing")
              ? ($corelib$Result$Ok)($d)
              : ((($maybeType)[0] === "Just")
                ? ((() => {
                  const $rawType = ($maybeType)[1];
                  return (($corelib$Result$onOk)((($type) => {
                    const $usr = (($sp$Types$Meta$USR)($module.umr))($name);
                    const $iv = ({
                      definedAt: $pos,
                      freeTypeVariables: ((($sp$Compiler$Pipeline$getFreeTypeVars)($corelib$Dict$empty))($def.nonFn))($type),
                      isMutable: false,
                      ty: $type,
                    });
                    return ($corelib$Result$Ok)(((($corelib$Dict$insert)($usr))($iv))($d));
                  })))((($sp$Compiler$ExpandTypes$expandAnnotation)($types))($rawType));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Pipeline.sp 58:8', (sp_toHuman)($maybeType))));
          });
        });
      });
    });
    const $insertValueDef = (($def) => {
      return (($corelib$Dict$forRes)(($sp$Types$CanonicalAst$patternNamedTypes)($def.pattern)))(($insertName)($def));
    });
    return (($corelib$Dict$forRes)($module.valueDefs))((() => {
      return $insertValueDef;
    }));
  });
});

const $sp$Compiler$Pipeline$globalExpandedTypes = (($allModules) => {
  return (($corelib$Result$onOk)((($types) => {
    const $constructors = ((($corelib$Dict$for)($types))((() => {
      return $sp$Compiler$Pipeline$insertUnionConstructors;
    })))($sp$Compiler$Pipeline$coreConstructors);
    return (($corelib$Result$onOk)((($instanceVariables) => {
      return ($corelib$Result$Ok)(({
        constructors: $constructors,
        instanceVariables: $instanceVariables,
        types: $types,
      }));
    })))(((($corelib$Dict$forRes)($allModules))((() => {
      return ($sp$Compiler$Pipeline$expandAndInsertModuleAnnotations)($types);
    })))($sp$Compiler$Pipeline$coreVariables));
  })))(($sp$Compiler$ExpandTypes$expandAllTypes)(((($corelib$Dict$for)($allModules))((() => {
    return $sp$Compiler$ExpandTypes$insertModuleTypes;
  })))($sp$Compiler$Pipeline$coreTypes)));
});

const $sp$Compiler$TestHelpers$listType = (($itemType) => {
  return ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("List")))((($core$SPCore$Cons)($itemType))($core$SPCore$Nil));
});

const $sp$Compiler$TestHelpers$localType = (($name) => {
  return (($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))($name);
});

const $sp$Compiler$TestHelpers$noneType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("None")))($core$SPCore$Nil);

const $sp$Compiler$TypeCheck$insertError = (($e) => {
  return (($state) => {
    return ({
      first: null,
      second: (Object.assign)({}, $state, ({
        errors: ((sp_cons)($state.errors))($e),
      })),
    });
  });
});

const $sp$Compiler$TypeCheck$addCheckError = (($pos) => {
  return (($message) => {
    return ($sp$Compiler$TypeCheck$insertError)((($sp$Compiler$Error$Simple)($pos))((() => {
      return $message;
    })));
  });
});

const $sp$StateMonad$andThen = (($f) => {
  return (($m) => {
    return (($state0) => {
      const $$a = ($m)($state0);
      const $state1 = $$a.second;
      const $a = $$a.first;
      return (($f)($a))($state1);
    });
  });
});

const $sp$Compiler$TypeCheck$andThen = $sp$StateMonad$andThen;

const $sp$StateMonad$return = (($a) => {
  return (($state) => {
    return ({
      first: $a,
      second: $state,
    });
  });
});

const $sp$StateMonad$list_foldl = (($f) => {
  return (($items) => {
    return (($accum) => {
      return ((($items)[0] === "Nil")
        ? ($sp$StateMonad$return)($accum)
        : ((($items)[0] === "Cons")
          ? ((() => {
            const $head = ($items)[1];
            const $tail = ($items)[2];
            return (($sp$StateMonad$andThen)((($sp$StateMonad$list_foldl)($f))($tail)))((($f)($head))($accum));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/StateMonad.sp 81:4', (sp_toHuman)($items))));
    });
  });
});

const $sp$Compiler$TypeCheck$list_for = (($l) => {
  return (($f) => {
    return (($sp$StateMonad$list_foldl)($f))($l);
  });
});

const $sp$Compiler$TypeCheck$return = $sp$StateMonad$return;

const $sp$Compiler$TypeCheck$addCheckConstructorError = (($pos) => {
  return (($env) => {
    return (($remainingArgs) => {
      return (($message) => {
        return (($sp$Compiler$TypeCheck$andThen)((() => {
          return ((($sp$Compiler$TypeCheck$list_for)($remainingArgs))((($argPattern) => {
            return (($envX) => {
              return ($sp$Compiler$TypeCheck$return)($envX);
            });
          })))($env);
        })))((($sp$Compiler$TypeCheck$addCheckError)($pos))($message));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$newName = (($f) => {
  return (($state) => {
    return ({
      first: ($f)((text_fromNumber)($state.nextName)),
      second: (Object.assign)({}, $state, ({
        nextName: ($state.nextName + 1),
      })),
    });
  });
});

const $sp$Compiler$TypeCheck$newType = (($pos) => {
  return ($sp$Compiler$TypeCheck$newName)(($sp$Types$CanonicalAst$TypeVariable)($pos));
});

const $sp$Compiler$TypeCheck$addErrorWithEEnv = (($pos) => {
  return (($messageConstructor) => {
    return (($sp$Compiler$TypeCheck$andThen)((() => {
      return ($sp$Compiler$TypeCheck$newType)($pos);
    })))(($sp$Compiler$TypeCheck$insertError)((($sp$Compiler$Error$Simple)($pos))($messageConstructor)));
  });
});

const $sp$Compiler$TypeCheck$addError = (($pos) => {
  return (($message) => {
    return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))((() => {
      return $message;
    }));
  });
});

const $sp$StateMonad$get = (($getter) => {
  return (($state) => {
    return ({
      first: ($getter)($state),
      second: $state,
    });
  });
});

const $sp$Compiler$TypeCheck$get = $sp$StateMonad$get;

const $sp$Compiler$TypeCheck$replaceTypeVariables = (($subs) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeConstant")
      ? ((() => {
        const $pos = ($ty)[1];
        const $ref = ($ty)[2];
        const $args = ($ty)[3];
        return ((($sp$Types$CanonicalAst$TypeConstant)($pos))($ref))((($corelib$List$map)(($sp$Compiler$TypeCheck$replaceTypeVariables)($subs)))($args));
      }))()
      : ((($ty)[0] === "TypeVariable")
        ? ((() => {
          const $name = ($ty)[2];
          const $$try2 = (($corelib$Dict$get)($name))($subs);
          return ((($$try2)[0] === "Just")
            ? ((() => {
              const $substitutionType = ($$try2)[1];
              return $substitutionType;
            }))()
            : ((($$try2)[0] === "Nothing")
              ? $ty
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2224:12', (sp_toHuman)($$try2))));
        }))()
        : ((($ty)[0] === "TypeFunction")
          ? ((() => {
            const $pos = ($ty)[1];
            const $from = ($ty)[2];
            const $fromIsMutable = ($ty)[3];
            const $to = ($ty)[4];
            return (((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($from)))($fromIsMutable))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($to));
          }))()
          : ((($ty)[0] === "TypeAlias")
            ? ((() => {
              const $pos = ($ty)[1];
              const $path = ($ty)[2];
              const $t = ($ty)[3];
              return ((($sp$Types$CanonicalAst$TypeAlias)($pos))($path))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($t));
            }))()
            : ((($ty)[0] === "TypeRecord")
              ? ((() => {
                const $pos = ($ty)[1];
                const $extensible = ($ty)[2];
                const $attrs = ($ty)[3];
                const $$try1 = (($corelib$Maybe$andThen)((($name) => {
                  return (($corelib$Dict$get)($name))($subs);
                })))($extensible);
                return ((($$try1)[0] === "Nothing")
                  ? ((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible))((($corelib$Dict$map)((($name) => {
                    return ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs);
                  })))($attrs))
                  : (((($$try1)[0] === "Just") && ((($$try1)[1])[0] === "TypeVariable"))
                    ? ((() => {
                      const $p = (($$try1)[1])[1];
                      const $n = (($$try1)[1])[2];
                      return ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($n)))((($corelib$Dict$map)((($name) => {
                        return ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs);
                      })))($attrs));
                    }))()
                    : (((($$try1)[0] === "Just") && ((($$try1)[1])[0] === "TypeRecord"))
                      ? ((() => {
                        const $ext2 = (($$try1)[1])[2];
                        const $attrs2 = (($$try1)[1])[3];
                        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($ext2))((($corelib$Dict$map)((($name) => {
                          return ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs);
                        })))((($corelib$Dict$join)($attrs2))($attrs)));
                      }))()
                      : ((($$try1)[0] === "Just")
                        ? ((() => {
                          const $what = ($$try1)[1];
                          ((sp_log)("what"))((sp_toHuman)($what));
                          return (sp_todo)("replacing record extension with non-var");
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2243:12', (sp_toHuman)($$try1))))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2219:4', (sp_toHuman)($ty)))))));
  });
});

const $sp$Compiler$TypeCheck$applySubsToType = (($ty) => {
  return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
    return ($sp$Compiler$TypeCheck$return)((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($ty));
  })))(($sp$Compiler$TypeCheck$get)((($x) => {
    return $x.substitutions;
  })));
});

const $sp$Compiler$TypeCheck$errorTodo = (($pos) => {
  return (($message) => {
    return (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)($message))($core$SPCore$Nil));
  });
});

const $sp$Compiler$TypeCheck$typeContainsFunctions = (($ty) => {
  return ((($ty)[0] === "TypeConstant")
    ? ((() => {
      const $args = ($ty)[3];
      return (($corelib$List$any)($sp$Compiler$TypeCheck$typeContainsFunctions))($args);
    }))()
    : ((($ty)[0] === "TypeVariable")
      ? false
      : ((($ty)[0] === "TypeFunction")
        ? ((() => {
          const $from = ($ty)[2];
          const $fromIsMutable = ($ty)[3];
          const $to = ($ty)[4];
          return true;
        }))()
        : ((($ty)[0] === "TypeAlias")
          ? ((() => {
            const $path = ($ty)[2];
            const $t = ($ty)[3];
            return ($sp$Compiler$TypeCheck$typeContainsFunctions)($t);
          }))()
          : ((($ty)[0] === "TypeRecord")
            ? ((() => {
              const $extensible = ($ty)[2];
              const $attrs = ($ty)[3];
              return (($corelib$List$any)($sp$Compiler$TypeCheck$typeContainsFunctions))(($corelib$Dict$values)($attrs));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1997:4', (sp_toHuman)($ty)))))));
});

const $sp$Human$CanonicalAst$parensIf = (($test) => {
  return (($s) => {
    return ($test
      ? ("(" + ($s + ")"))
      : $s);
  });
});

const $sp$Human$CanonicalAst$usrToText = (($currentUmr) => {
  return (($meta) => {
    return (($usr) => {
      const $$moduleUmr = $usr;
      const $name = ($$moduleUmr)[2];
      const $moduleUmr = ($$moduleUmr)[1];
      return (((sp_equal)($moduleUmr))($currentUmr)
        ? $name
        : ((() => {
          const $maybeGlobal = (($corelib$List$find)((($$k) => {
            const $k = $$k.first;
            const $v = $$k.second;
            return ((sp_equal)($usr))($v);
          })))(($corelib$Dict$toList)($meta.globalTypes));
          return ((($maybeGlobal)[0] === "Just")
            ? ((() => {
              const $k = ($maybeGlobal)[1].first;
              const $v = ($maybeGlobal)[1].second;
              return $k;
            }))()
            : ((($maybeGlobal)[0] === "Nothing")
              ? ((() => {
                const $$try1 = (($corelib$Dict$get)($moduleUmr))($meta.umrToModuleVisibleAs);
                return ((($$try1)[0] === "Just")
                  ? ((() => {
                    const $moduleAlias = ($$try1)[1];
                    return ($moduleAlias + ("." + $name));
                  }))()
                  : ((($$try1)[0] === "Nothing")
                    ? ((() => {
                      const $$modulePath = $moduleUmr;
                      const $modulePath = ($$modulePath)[2];
                      const $souece = ($$modulePath)[1];
                      return ($modulePath + ("." + $name));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 52:16', (sp_toHuman)($$try1))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 47:8', (sp_toHuman)($maybeGlobal))));
        }))());
    });
  });
});

const $sp$Human$CanonicalAst$typeToPriorityAndText = (($currentUmr) => {
  return (($meta) => {
    return (($type) => {
      const $parensIfGreaterThan = (($threshold) => {
        return (($ty) => {
          const $$pri = ((($sp$Human$CanonicalAst$typeToPriorityAndText)($currentUmr))($meta))($ty);
          const $str = $$pri.second;
          const $pri = $$pri.first;
          return (($sp$Human$CanonicalAst$parensIf)(($pri > $threshold)))($str);
        });
      });
      return ((($type)[0] === "TypeConstant")
        ? ((() => {
          const $pos = ($type)[1];
          const $usr = ($type)[2];
          const $args = ($type)[3];
          return ({
            first: (((sp_equal)($core$SPCore$Nil))($args)
              ? 0
              : 1),
            second: (($corelib$Text$join)(" "))(((sp_cons)((($corelib$List$map)(($parensIfGreaterThan)(0)))($args)))(((($sp$Human$CanonicalAst$usrToText)($currentUmr))($meta))($usr))),
          });
        }))()
        : ((($type)[0] === "TypeVariable")
          ? ((() => {
            const $pos = ($type)[1];
            const $name = ($type)[2];
            return ({
              first: 0,
              second: $name,
            });
          }))()
          : ((($type)[0] === "TypeFunction")
            ? ((() => {
              const $pos = ($type)[1];
              const $from = ($type)[2];
              const $fromIsMut = ($type)[3];
              const $to = ($type)[4];
              const $arrow = ($fromIsMut
                ? " @: "
                : ": ");
              return ({
                first: 2,
                second: (($corelib$Text$join)(""))((($core$SPCore$Cons)((($parensIfGreaterThan)(1))($from)))((($core$SPCore$Cons)($arrow))((($core$SPCore$Cons)((($parensIfGreaterThan)(2))($to)))($core$SPCore$Nil)))),
              });
            }))()
            : ((($type)[0] === "TypeRecord")
              ? ((() => {
                const $pos = ($type)[1];
                const $extend = ($type)[2];
                const $attrs = ($type)[3];
                const $attrsString = (($corelib$Text$join)(", "))((($corelib$List$map)((($$name) => {
                  const $name = $$name.first;
                  const $ty = $$name.second;
                  return ($name + (" as " + ((($sp$Human$CanonicalAst$typeToText)($currentUmr))($meta))($ty)));
                })))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs))));
                const $l = (($core$SPCore$Cons)("{"))((($core$SPCore$Cons)(((($extend)[0] === "Nothing")
                  ? ""
                  : ((($extend)[0] === "Just")
                    ? ((() => {
                      const $n = ($extend)[1];
                      return ($n + " with");
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 109:16', (sp_toHuman)($extend))))))((($core$SPCore$Cons)($attrsString))((($core$SPCore$Cons)("}"))($core$SPCore$Nil))));
                return ({
                  first: 0,
                  second: (($corelib$Text$join)(" "))($l),
                });
              }))()
              : ((($type)[0] === "TypeAlias")
                ? ((() => {
                  const $pos = ($type)[1];
                  const $usr = ($type)[2];
                  const $ty2 = ($type)[3];
                  return ({
                    first: 0,
                    second: ((($sp$Human$CanonicalAst$usrToText)($currentUmr))($meta))($usr),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 83:4', (sp_toHuman)($type)))))));
    });
  });
});

const $sp$Human$CanonicalAst$typeToText = (($currentUmr) => {
  return (($meta) => {
    return (($t) => {
      return ($corelib$Tuple$second)(((($sp$Human$CanonicalAst$typeToPriorityAndText)($currentUmr))($meta))($t));
    });
  });
});

const $sp$Compiler$TypeCheck$typeToText = (($env) => {
  return (($sp$Human$CanonicalAst$typeToText)($env.currentModule))($env.meta);
});

const $sp$Compiler$TypeCheck$checkNonFunction = (($env) => {
  return (($name) => {
    return (($ty) => {
      const $nope = ({
        freeVarsToFlag: $core$SPCore$Nil,
      });
      return (($sp$Compiler$TypeCheck$andThen)((($nonFnTyvars) => {
        const $$try1 = (($corelib$Dict$get)($name))($nonFnTyvars);
        return ((($$try1)[0] === "Nothing")
          ? ($sp$Compiler$TypeCheck$return)($nope)
          : ((($$try1)[0] === "Just")
            ? ((() => {
              const $rejectReasons = ($$try1)[1];
              return (($sp$Compiler$TypeCheck$typeContainsFunctions)($ty)
                ? (($sp$Compiler$TypeCheck$andThen)((() => {
                  return ($sp$Compiler$TypeCheck$return)($nope);
                })))((($sp$Compiler$TypeCheck$errorTodo)(($sp$Types$Pos$I)(26)))(("type `" + ($name + ("` should not contain functions, but is " + (($sp$Compiler$TypeCheck$typeToText)($env))($ty))))))
                : ($sp$Compiler$TypeCheck$return)($nope));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1961:4', (sp_toHuman)($$try1))));
      })))(($sp$Compiler$TypeCheck$get)((($x) => {
        return $x.nonFnTyvars;
      })));
    });
  });
});

const $sp$Compiler$TypeCheck$flagFreeVars = (($names) => {
  return ($sp$Compiler$TypeCheck$return)(null);
});

const $sp$Compiler$TypeCheck$isAnnotation = (($n) => {
  return ((sp_equal)($corelib$Maybe$Nothing))((text_toNumber)($n));
});

const $sp$Compiler$TypeCheck$typeHasTyvar = (($n) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeVariable")
      ? ((() => {
        const $pos = ($ty)[1];
        const $name = ($ty)[2];
        return ((sp_equal)($name))($n);
      }))()
      : ((($ty)[0] === "TypeFunction")
        ? ((() => {
          const $from = ($ty)[2];
          const $fromIsMutable = ($ty)[3];
          const $to = ($ty)[4];
          return ((($sp$Compiler$TypeCheck$typeHasTyvar)($n))($from) || (($sp$Compiler$TypeCheck$typeHasTyvar)($n))($to));
        }))()
        : ((($ty)[0] === "TypeConstant")
          ? ((() => {
            const $pos = ($ty)[1];
            const $ref = ($ty)[2];
            const $args = ($ty)[3];
            return (($corelib$List$any)(($sp$Compiler$TypeCheck$typeHasTyvar)($n)))($args);
          }))()
          : ((($ty)[0] === "TypeAlias")
            ? ((() => {
              const $path = ($ty)[2];
              const $t = ($ty)[3];
              return (($sp$Compiler$TypeCheck$typeHasTyvar)($n))($t);
            }))()
            : ((($ty)[0] === "TypeRecord")
              ? ((() => {
                const $pos = ($ty)[1];
                const $extensible = ($ty)[2];
                const $attrs = ($ty)[3];
                return (((sp_equal)($extensible))(($corelib$Maybe$Just)($n)) || (($corelib$List$any)(($sp$Compiler$TypeCheck$typeHasTyvar)($n)))(($corelib$Dict$values)($attrs)));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2018:4', (sp_toHuman)($ty)))))));
  });
});

const $sp$Compiler$TypeCheck$typeIsTyvar = (($name) => {
  return (($ty) => {
    return ((($ty)[0] === "TypeVariable")
      ? ((() => {
        const $n = ($ty)[2];
        return ((sp_equal)($name))($n);
      }))()
      : (true
        ? false
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1946:4', (sp_toHuman)($ty))));
  });
});

const $sp$Compiler$TypeCheck$insertTypeClash = (($id) => {
  return (($t1) => {
    return (($t2) => {
      return (($err) => {
        return (($state) => {
          const $$try1 = $state.typeClashesByPlaceholderId;
          return ((($$try1)[0] === "Nothing")
            ? ((($x) => {
              return (sp_todo)(("Inserting type clash outside of unify" + $x));
            }))((sp_toHuman)(({
              err: $err,
              id: $id,
              t1: $t1,
              t2: $t2,
            })))
            : ((($$try1)[0] === "Just")
              ? ((() => {
                const $dict = ($$try1)[1];
                const $x = ($corelib$Maybe$Just)(((($corelib$Dict$insert)($id))(({
                  err: $err,
                  t1: $t1,
                  t2: $t2,
                })))($dict));
                return ({
                  first: null,
                  second: (Object.assign)({}, $state, ({
                    typeClashesByPlaceholderId: $x,
                  })),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 291:4', (sp_toHuman)($$try1))));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unifyError = (($pos) => {
  return (($error) => {
    return (($t1) => {
      return (($t2) => {
        return (($sp$Compiler$TypeCheck$andThen)((($name) => {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)((($sp$Types$CanonicalAst$TypeVariable)($pos))($name));
          })))((((($sp$Compiler$TypeCheck$insertTypeClash)($name))($t1))($t2))($error));
        })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
      });
    });
  });
});

const $sp$StateMonad$list_map2 = (($f) => {
  return (($la) => {
    return (($lb) => {
      const $apply = (($$a) => {
        const $a = $$a.first;
        const $b = $$a.second;
        return (($accum) => {
          return (($sp$StateMonad$andThen)((($c) => {
            return ($sp$StateMonad$return)(((sp_cons)($accum))($c));
          })))((($f)($a))($b));
        });
      });
      return (($sp$StateMonad$andThen)((($x) => {
        return ($sp$StateMonad$return)(($corelib$List$reverse)($x));
      })))(((($sp$StateMonad$list_foldl)($apply))(((($corelib$List$map2)($corelib$Tuple$pair))($la))($lb)))($core$SPCore$Nil));
    });
  });
});

const $sp$Compiler$TypeCheck$list_map2 = $sp$StateMonad$list_map2;

const $sp$StateMonad$dict_foldl = (($f) => {
  return (($x) => {
    return (($sp$StateMonad$list_foldl)((($$k) => {
      const $k = $$k.first;
      const $v = $$k.second;
      return (($f)($k))($v);
    })))(($corelib$Dict$toList)($x));
  });
});

const $sp$StateMonad$dict_map = (($f) => {
  return (($dict) => {
    const $insert = (($c) => {
      return (($a) => {
        return (($d) => {
          return (($sp$StateMonad$andThen)((($b) => {
            return ($sp$StateMonad$return)(((($corelib$Dict$insert)($c))($b))($d));
          })))((($f)($c))($a));
        });
      });
    });
    return ((($sp$StateMonad$dict_foldl)($insert))($dict))($corelib$Dict$empty);
  });
});

const $sp$Compiler$TypeCheck$dict_map = $sp$StateMonad$dict_map;

const $sp$Compiler$TypeCheck$unifyToNonExtensibleRecord = (($env) => {
  return (($pos) => {
    return (($reason) => {
      return (($aName) => {
        return (($aOnly) => {
          return (($bOnly) => {
            return (($bothUnified) => {
              return (((sp_not_equal)($corelib$Dict$empty))($aOnly)
                ? (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("record is missing attrs: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($aOnly)))))((($core$SPCore$Cons)((sp_toHuman)($reason)))($core$SPCore$Nil)))
                : (($sp$Compiler$TypeCheck$andThen)((($ext) => {
                  return (($sp$Compiler$TypeCheck$andThen)((() => {
                    return ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))((($corelib$Dict$join)($bothUnified))($bOnly)));
                  })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("ne"))($pos))($reason))($aName))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(5)))($ext))($bOnly)));
                })))(($sp$Compiler$TypeCheck$newName)($corelib$Maybe$Just)));
            });
          });
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unifyRecords = (($env) => {
  return (($reason) => {
    return (($pos) => {
      return (($$a_attrs) => {
        const $a_ext = $$a_attrs.first;
        const $a_attrs = $$a_attrs.second;
        return (($$b_attrs) => {
          const $b_ext = $$b_attrs.first;
          const $b_attrs = $$b_attrs.second;
          const $init = ({
            aOnly: $corelib$Dict$empty,
            bOnly: $corelib$Dict$empty,
            both: $corelib$Dict$empty,
          });
          const $onA = (($name) => {
            return (($type_) => {
              return (($state) => {
                return (Object.assign)({}, $state, ({
                  aOnly: ((($corelib$Dict$insert)($name))($type_))($state.aOnly),
                }));
              });
            });
          });
          const $onB = (($name) => {
            return (($type_) => {
              return (($state) => {
                return (Object.assign)({}, $state, ({
                  bOnly: ((($corelib$Dict$insert)($name))($type_))($state.bOnly),
                }));
              });
            });
          });
          const $onBoth = (($name) => {
            return (($aType) => {
              return (($bType) => {
                return (($state) => {
                  return (Object.assign)({}, $state, ({
                    both: ((($corelib$Dict$insert)($name))(({
                      first: $aType,
                      second: $bType,
                    })))($state.both),
                  }));
                });
              });
            });
          });
          const $$aOnly = (((((($corelib$Dict$merge)($onA))($onBoth))($onB))($a_attrs))($b_attrs))($init);
          const $both = $$aOnly.both;
          const $bOnly = $$aOnly.bOnly;
          const $aOnly = $$aOnly.aOnly;
          return (($sp$Compiler$TypeCheck$andThen)((($bothUnified) => {
            const $$try1 = ({
              first: $a_ext,
              second: $b_ext,
            });
            return (((($$try1.first)[0] === "Just") && (($$try1.second)[0] === "Nothing"))
              ? ((() => {
                const $aName = ($$try1.first)[1];
                return ((((((($sp$Compiler$TypeCheck$unifyToNonExtensibleRecord)($env))($pos))($reason))($aName))($aOnly))($bOnly))($bothUnified);
              }))()
              : (((($$try1.first)[0] === "Nothing") && (($$try1.second)[0] === "Just"))
                ? ((() => {
                  const $bName = ($$try1.second)[1];
                  return ((((((($sp$Compiler$TypeCheck$unifyToNonExtensibleRecord)($env))($pos))($reason))($bName))($bOnly))($aOnly))($bothUnified);
                }))()
                : (((($$try1.first)[0] === "Nothing") && (($$try1.second)[0] === "Nothing"))
                  ? ((((sp_equal)($corelib$Dict$empty))($bOnly) && ((sp_equal)($corelib$Dict$empty))($aOnly))
                    ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(4)))($corelib$Maybe$Nothing))($bothUnified))
                    : ((() => {
                      const $e = ($sp$Compiler$TypeCheck$IncompatibleRecords)(({
                        aOnly: ($corelib$Dict$keys)($aOnly),
                        bOnly: ($corelib$Dict$keys)($bOnly),
                        bothUnified: ($corelib$Dict$keys)($bothUnified),
                      }));
                      return (((($sp$Compiler$TypeCheck$unifyError)($pos))($e))(((($sp$Types$CanonicalAst$TypeRecord)($pos))($a_ext))($a_attrs)))(((($sp$Types$CanonicalAst$TypeRecord)($pos))($b_ext))($b_attrs));
                    }))())
                  : (((($$try1.first)[0] === "Just") && (($$try1.second)[0] === "Just"))
                    ? ((() => {
                      const $aName = ($$try1.first)[1];
                      const $bName = ($$try1.second)[1];
                      return ((((sp_equal)($bName))($aName) && (((sp_equal)($corelib$Dict$empty))($aOnly) && ((sp_equal)($corelib$Dict$empty))($bOnly)))
                        ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($aName)))($bothUnified))
                        : (($sp$Compiler$TypeCheck$andThen)((($new) => {
                          const $sub = ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($new)))((($corelib$Dict$join)($bOnly))($a_attrs));
                          return (($sp$Compiler$TypeCheck$andThen)((() => {
                            return (($sp$Compiler$TypeCheck$andThen)((() => {
                              return ($sp$Compiler$TypeCheck$return)($sub);
                            })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("jj2"))($pos))($reason))($bName))($sub));
                          })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("jj1"))($pos))($reason))($aName))($sub));
                        })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity)));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1812:4', (sp_toHuman)($$try1))))));
          })))((($sp$Compiler$TypeCheck$dict_map)((($k) => {
            return (($$a) => {
              const $a = $$a.first;
              const $b = $$a.second;
              return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a))($b);
            });
          })))($both));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unify_ = (($env) => {
  return (($reason) => {
    return (($pos1) => {
      return (($t1) => {
        return (($t2) => {
          const $$try1 = ({
            first: $t1,
            second: $t2,
          });
          return ((($$try1.first)[0] === "TypeAlias")
            ? ((() => {
              const $pos = ($$try1.first)[1];
              const $aliased = ($$try1.first)[3];
              return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($aliased))($t2);
            }))()
            : ((($$try1.second)[0] === "TypeAlias")
              ? ((() => {
                const $aliased = ($$try1.second)[3];
                return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos1))($t1))($aliased);
              }))()
              : (((($$try1.first)[0] === "TypeConstant") && (($$try1.second)[0] === "TypeConstant"))
                ? ((() => {
                  const $pos = ($$try1.first)[1];
                  const $ref1 = ($$try1.first)[2];
                  const $args1 = ($$try1.first)[3];
                  const $ref2 = ($$try1.second)[2];
                  const $args2 = ($$try1.second)[3];
                  return (((sp_not_equal)($ref2))($ref1)
                    ? (((($sp$Compiler$TypeCheck$unifyError)($pos1))($sp$Compiler$TypeCheck$IncompatibleTypes))($t1))($t2)
                    : ((() => {
                      const $fold = (($arg1) => {
                        return (($arg2) => {
                          return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($arg1))($arg2);
                        });
                      });
                      return (($sp$Compiler$TypeCheck$andThen)((($argTypes) => {
                        return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                          return ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($ref1))((($corelib$List$map)(($sp$Compiler$TypeCheck$replaceTypeVariables)($subs)))($argTypes)));
                        })))(($sp$Compiler$TypeCheck$get)((($x) => {
                          return $x.substitutions;
                        })));
                      })))(((($sp$Compiler$TypeCheck$list_map2)(((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos)))($args1))($args2));
                    }))());
                }))()
                : (((($$try1.first)[0] === "TypeVariable") && (($$try1.second)[0] === "TypeVariable"))
                  ? ((() => {
                    const $pos = ($$try1.first)[1];
                    const $v1_name = ($$try1.first)[2];
                    const $v2_name = ($$try1.second)[2];
                    return (((sp_equal)($v2_name))($v1_name)
                      ? ($sp$Compiler$TypeCheck$return)($t1)
                      : (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                        const $$try2 = ({
                          first: (($corelib$Dict$get)($v1_name))($subs),
                          second: (($corelib$Dict$get)($v2_name))($subs),
                        });
                        return (((($$try2.first)[0] === "Just") && (($$try2.second)[0] === "Just"))
                          ? ((() => {
                            const $sub1 = ($$try2.first)[1];
                            const $sub2 = ($$try2.second)[1];
                            return (($sp$Compiler$TypeCheck$andThen)((($v) => {
                              return (($sp$Compiler$TypeCheck$andThen)((() => {
                                return (($sp$Compiler$TypeCheck$andThen)((($subbedTy) => {
                                  return ($sp$Compiler$TypeCheck$return)($subbedTy);
                                })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv2"))($pos))($reason))($v2_name))($v));
                              })))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv1"))($pos))($reason))($v1_name))($v));
                            })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos1))($sub1))($sub2));
                          }))()
                          : (((($$try2.first)[0] === "Nothing") && (($$try2.second)[0] === "Just"))
                            ? ((() => {
                              const $sub2 = ($$try2.second)[1];
                              return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv3"))($pos))($reason))($v1_name))($t2);
                            }))()
                            : (true
                              ? (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv4"))($pos))($reason))($v2_name))($t1)
                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1734:16', (sp_toHuman)($$try2)))));
                      })))(($sp$Compiler$TypeCheck$get)((($x) => {
                        return $x.substitutions;
                      }))));
                  }))()
                  : ((($$try1.first)[0] === "TypeVariable")
                    ? ((() => {
                      const $pos = ($$try1.first)[1];
                      const $name1 = ($$try1.first)[2];
                      return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vl"))($pos))($reason))($name1))($t2);
                    }))()
                    : ((($$try1.second)[0] === "TypeVariable")
                      ? ((() => {
                        const $pos = ($$try1.second)[1];
                        const $name2 = ($$try1.second)[2];
                        return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vr"))($pos))($reason))($name2))($t1);
                      }))()
                      : (((($$try1.first)[0] === "TypeFunction") && (($$try1.second)[0] === "TypeFunction"))
                        ? ((() => {
                          const $pos = ($$try1.first)[1];
                          const $a_from = ($$try1.first)[2];
                          const $a_fromIsMutable = ($$try1.first)[3];
                          const $a_to = ($$try1.first)[4];
                          const $b_from = ($$try1.second)[2];
                          const $b_fromIsMutable = ($$try1.second)[3];
                          const $b_to = ($$try1.second)[4];
                          return (((sp_not_equal)($b_fromIsMutable))($a_fromIsMutable)
                            ? (((($sp$Compiler$TypeCheck$unifyError)($pos))($sp$Compiler$TypeCheck$IncompatibleMutability))($t1))($t2)
                            : (($sp$Compiler$TypeCheck$andThen)((($unified_from) => {
                              return (($sp$Compiler$TypeCheck$andThen)((($subs_) => {
                                return (($sp$Compiler$TypeCheck$andThen)((($unified_to) => {
                                  return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                                    return ($sp$Compiler$TypeCheck$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($unified_from)))($a_fromIsMutable))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($unified_to)));
                                  })))(($sp$Compiler$TypeCheck$get)((($x) => {
                                    return $x.substitutions;
                                  })));
                                })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs_))($a_to)))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs_))($b_to)));
                              })))(($sp$Compiler$TypeCheck$get)((($x) => {
                                return $x.substitutions;
                              })));
                            })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a_from))($b_from)));
                        }))()
                        : (((($$try1.first)[0] === "TypeRecord") && (($$try1.second)[0] === "TypeRecord"))
                          ? ((() => {
                            const $a_ext = ($$try1.first)[2];
                            const $a_attrs = ($$try1.first)[3];
                            const $b_ext = ($$try1.second)[2];
                            const $b_attrs = ($$try1.second)[3];
                            return ((((($sp$Compiler$TypeCheck$unifyRecords)($env))($reason))($pos1))(({
                              first: $a_ext,
                              second: $a_attrs,
                            })))(({
                              first: $b_ext,
                              second: $b_attrs,
                            }));
                          }))()
                          : (true
                            ? (((($sp$Compiler$TypeCheck$unifyError)($pos1))($sp$Compiler$TypeCheck$IncompatibleTypes))($t1))($t2)
                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1703:4', (sp_toHuman)($$try1)))))))))));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$addSubstitution = (($env) => {
  return (($debugCode) => {
    return (($pos) => {
      return (($reason) => {
        return (($name) => {
          return (($rawTy) => {
            return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return (($sp$Compiler$TypeCheck$isAnnotation)($name)
                ? ((($ty)[0] === "TypeVariable")
                  ? ((() => {
                    const $subName = ($ty)[2];
                    return (((sp_equal)($name))($subName)
                      ? ($sp$Compiler$TypeCheck$return)($ty)
                      : (($sp$Compiler$TypeCheck$isAnnotation)($subName)
                        ? (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$SubstitutingAnnotation)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty)
                        : (((((($sp$Compiler$TypeCheck$addSubstitution)($env))(($debugCode + " SWITCH")))($pos))($reason))($subName))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name))));
                  }))()
                  : (true
                    ? (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$SubstitutingAnnotation)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty)
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1892:8', (sp_toHuman)($ty))))
                : ((($sp$Compiler$TypeCheck$typeHasTyvar)($name))($ty)
                  ? ((($sp$Compiler$TypeCheck$typeIsTyvar)($name))($ty)
                    ? ($sp$Compiler$TypeCheck$return)($ty)
                    : (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$Cycle)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty))
                  : (($sp$Compiler$TypeCheck$andThen)((($nonFunction) => {
                    const $$freeVarsToFlag = $nonFunction;
                    const $freeVarsToFlag = $$freeVarsToFlag.freeVarsToFlag;
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                        const $$try1 = (($corelib$Dict$get)($name))($subs);
                        return ((($$try1)[0] === "Just")
                          ? ((() => {
                            const $sub = ($$try1)[1];
                            return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($ty))($sub);
                          }))()
                          : ((($$try1)[0] === "Nothing")
                            ? (($state) => {
                              return ({
                                first: $ty,
                                second: (Object.assign)({}, $state, ({
                                  substitutions: ((($corelib$Dict$insert)($name))($ty))((($corelib$Dict$map)((($k) => {
                                    return ($sp$Compiler$TypeCheck$replaceTypeVariables)((($corelib$Dict$singleton)($name))($ty));
                                  })))($state.substitutions)),
                                })),
                              });
                            })
                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1924:8', (sp_toHuman)($$try1))));
                      })))(($sp$Compiler$TypeCheck$get)((($x) => {
                        return $x.substitutions;
                      })));
                    })))(($sp$Compiler$TypeCheck$flagFreeVars)($freeVarsToFlag));
                  })))(((($sp$Compiler$TypeCheck$checkNonFunction)($env))($name))($ty))));
            })))(($sp$Compiler$TypeCheck$applySubsToType)($rawTy));
          });
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$unifyErrorToText = (($ue) => {
  return ((($ue)[0] === "IncompatibleTypes")
    ? "The two types are incompatible."
    : ((($ue)[0] === "IncompatibleMutability")
      ? "The mutability does not match."
      : ((($ue)[0] === "IncompatibleRecords")
        ? ((() => {
          const $args = ($ue)[1];
          return ("The record types are not compatible" + (sp_toHuman)($args));
        }))()
        : ((($ue)[0] === "Cycle")
          ? ((() => {
            const $name = ($ue)[1];
            return ("There is a cyclic dependency on " + $name);
          }))()
          : ((($ue)[0] === "NonFunctionContainsFunction")
            ? ((() => {
              const $rejectFunctions = ($ue)[1];
              return ("NonFunction can't contain functions: " + (sp_toHuman)($rejectFunctions));
            }))()
            : ((($ue)[0] === "OkThisIsActuallyPossible")
              ? "OkThisIsActuallyPossible?"
              : ((($ue)[0] === "NI")
                ? ((() => {
                  const $str = ($ue)[1];
                  return ("Not Implemented: " + $str);
                }))()
                : ((($ue)[0] === "SubstitutingAnnotation")
                  ? ((() => {
                    const $name = ($ue)[1];
                    return ("SubstitutingAnnotation: " + $name);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1641:4', (sp_toHuman)($ue))))))))));
});

const $sp$Compiler$TypeCheck$clashToTexts = (($env) => {
  return (($params) => {
    const $$try1 = $params.unifiedType;
    return ((($$try1)[0] === "TypeVariable")
      ? ((() => {
        const $p = ($$try1)[1];
        const $unifiedTypeName = ($$try1)[2];
        return (($corelib$Text$join)("\n"))((($corelib$List$concatMap)((($$clash) => {
          const $clashPlaceholderName = $$clash.first;
          const $clash = $$clash.second;
          return (($core$SPCore$Cons)($params.type1_is))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t1))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($params.type2_is))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t2))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck$unifyErrorToText)($clash.err)))($core$SPCore$Nil)))))))));
        })))(($corelib$Dict$toList)($params.clashes)));
      }))()
      : (true
        ? ((() => {
          const $info = (($core$SPCore$Cons)($params.typeSeemsToBe))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($params.unifiedType)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("However I can't reconcile the following:"))($core$SPCore$Nil))));
          const $clashToError = (($$clash) => {
            const $name = $$clash.first;
            const $clash = $$clash.second;
            return (($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("* `" + ($name + "`"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + $params.type1_is)))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t1))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + $params.type2_is)))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t2))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + ($sp$Compiler$TypeCheck$unifyErrorToText)($clash.err))))($core$SPCore$Nil))))))))));
          });
          const $clashErrors = (($corelib$List$concatMap)($clashToError))(($corelib$Dict$toList)($params.clashes));
          return (($corelib$Text$join)("\n"))(($corelib$List$concat)((($core$SPCore$Cons)($info))((($core$SPCore$Cons)($clashErrors))($core$SPCore$Nil))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2487:4', (sp_toHuman)($$try1))));
  });
});

const $sp$Types$CanonicalAst$expressionPos = (($e) => {
  return ((($e)[0] === "LiteralText")
    ? ((() => {
      const $pos = ($e)[1];
      return $pos;
    }))()
    : ((($e)[0] === "LiteralNumber")
      ? ((() => {
        const $pos = ($e)[1];
        return $pos;
      }))()
      : ((($e)[0] === "Variable")
        ? ((() => {
          const $pos = ($e)[1];
          return $pos;
        }))()
        : ((($e)[0] === "Constructor")
          ? ((() => {
            const $pos = ($e)[1];
            return $pos;
          }))()
          : ((($e)[0] === "Lambda")
            ? ((() => {
              const $pos = ($e)[1];
              return $pos;
            }))()
            : ((($e)[0] === "Record")
              ? ((() => {
                const $pos = ($e)[1];
                return $pos;
              }))()
              : ((($e)[0] === "Call")
                ? ((() => {
                  const $pos = ($e)[1];
                  return $pos;
                }))()
                : ((($e)[0] === "If")
                  ? ((() => {
                    const $pos = ($e)[1];
                    return $pos;
                  }))()
                  : ((($e)[0] === "Try")
                    ? ((() => {
                      const $pos = ($e)[1];
                      return $pos;
                    }))()
                    : ((($e)[0] === "LetIn")
                      ? ((() => {
                        const $valueDef = ($e)[1];
                        return ($sp$Types$CanonicalAst$patternPos)($valueDef.pattern);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 241:4', (sp_toHuman)($e))))))))))));
});

const $sp$Types$CanonicalAst$skipLetIns = (($expr) => {
  return ((($expr)[0] === "LetIn")
    ? ((() => {
      const $def = ($expr)[1];
      const $e = ($expr)[2];
      return ($sp$Types$CanonicalAst$skipLetIns)($e);
    }))()
    : (true
      ? $expr
      : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 175:4', (sp_toHuman)($expr))));
});

const $sp$Compiler$TypeCheck$errorIncompatibleTypes = (($env) => {
  return (($reason) => {
    return (($pos_whatever) => {
      return (($unifiedType) => {
        return (($clashes) => {
          return ((($reason)[0] === "UnifyReason_CallArgument")
            ? ((() => {
              const $pos = ($reason)[1];
              const $makeError = (($eenv) => {
                const $$block = (($sp$Compiler$Error$posToHuman)($eenv))($pos.reference);
                const $location = $$block.location;
                const $block = $$block.block;
                return (($core$SPCore$Cons)("This expression cannot be used as argument to this function:"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($block))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("the argument type seems to be: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                  clashes: $clashes,
                  type1_is: "The functon expects:",
                  type2_is: "But the actual argument is:",
                  typeSeemsToBe: "The argument type seems to be",
                  unifiedType: $unifiedType,
                }))))($core$SPCore$Nil))))));
              });
              return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos.argument))($makeError);
            }))()
            : ((($reason)[0] === "UnifyReason_TryBlock")
              ? ((() => {
                const $block = ($reason)[1];
                const $makeError = (($eenv) => {
                  return (($core$SPCore$Cons)("This try..as block produces a different type than the blocks preceding it."))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                    clashes: $clashes,
                    type1_is: "The previous block(s) produce:",
                    type2_is: "But this block produces:",
                    typeSeemsToBe: "The block type seems to be",
                    unifiedType: $unifiedType,
                  }))))($core$SPCore$Nil)));
                });
                return (($sp$Compiler$TypeCheck$addErrorWithEEnv)(($sp$Types$CanonicalAst$expressionPos)($block)))($makeError);
              }))()
              : ((($reason)[0] === "UnifyReason_AnnotationVsBlock")
                ? ((() => {
                  const $pattern = ($reason)[1];
                  const $annotation = ($reason)[2];
                  const $body = ($reason)[3];
                  const $headerPos = ($sp$Types$CanonicalAst$patternPos)($pattern);
                  const $lastStatementPos = ($sp$Types$CanonicalAst$expressionPos)(($sp$Types$CanonicalAst$skipLetIns)($body));
                  const $name = (($corelib$Text$join)(", "))(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($pattern)));
                  const $makeError = (($eenv) => {
                    const $$block = (($sp$Compiler$Error$posToHuman)($eenv))($headerPos);
                    const $location = $$block.location;
                    const $block = $$block.block;
                    return (($core$SPCore$Cons)(("The definition of " + ($name + " does not match the annotation:"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($block))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                      clashes: $clashes,
                      type1_is: "The annotation says:",
                      type2_is: "But this definition produces:",
                      typeSeemsToBe: "The produced type seems to be",
                      unifiedType: $unifiedType,
                    }))))($core$SPCore$Nil)))));
                  });
                  return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($lastStatementPos))($makeError);
                }))()
                : ((($reason)[0] === "UnifyReason_IsBeingCalledAsAFunction")
                  ? ((() => {
                    const $pos = ($reason)[1];
                    const $referenceType = ($reason)[2];
                    return (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("This expression is being called as if it was a function, but its type is:"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil))));
                  }))()
                  : (true
                    ? ((() => {
                      const $pos = $pos_whatever;
                      const $title = ((($reason)[0] === "UnifyReason_AnnotationSimple")
                        ? "The type is not compatible with the annotation"
                        : ((($reason)[0] === "UnifyReason_DefBlockVsPattern")
                          ? "The definition block cannot be unpacked into the pattern"
                          : ((($reason)[0] === "UnifyReason_IfCondition")
                            ? "The expression inside `if ... :` should always be a Bool"
                            : ((($reason)[0] === "UnifyReason_IfBranches")
                              ? "The branches of an `if` should produce the same type of value"
                              : ((($reason)[0] === "UnifyReason_TryPattern")
                                ? "try..as patterns should have the same type"
                                : ((($reason)[0] === "UnifyReason_ConstructorArgument")
                                  ? ((() => {
                                    const $p = ($reason)[1];
                                    return ("Argument " + ((text_fromNumber)($p.argIndex) + (" to type constructor " + ((sp_toHuman)($p.usr) + " does not match the constructor definition"))));
                                  }))()
                                  : ((($reason)[0] === "UnifyReason_AttributeAccess")
                                    ? ((() => {
                                      const $attrName = ($reason)[1];
                                      return ("You are trying to access the ." + ($attrName + " attribute"));
                                    }))()
                                    : ((($reason)[0] === "UnifyReason_AttributeUpdate")
                                      ? ((() => {
                                        const $attrNames = ($reason)[1];
                                        return ("You are trying to update the " + ((($corelib$Text$join)(", "))($attrNames) + " attributes"));
                                      }))()
                                      : ((($reason)[0] === "UnifyReason_Override")
                                        ? "this is addSubstitution running a UnifyReason_Override, I don't know what I'm doing"
                                        : ((($reason)[0] === "UnifyReason_IsLambda")
                                          ? "this is a function, and its type should reflect that"
                                          : (true
                                            ? (sp_todo)(((sp_toHuman)($reason) + " should not even get here"))
                                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2428:16', (sp_toHuman)($reason)))))))))))));
                      return (($sp$Compiler$TypeCheck$addError)($pos_whatever))((($core$SPCore$Cons)($title))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("The type seems to be something like"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
                        clashes: $clashes,
                        type1_is: "t1 is:",
                        type2_is: "but t2 is:",
                        typeSeemsToBe: "type seems to be",
                        unifiedType: $unifiedType,
                      }))))($core$SPCore$Nil)))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2341:4', (sp_toHuman)($reason)))))));
        });
      });
    });
  });
});

const $sp$StateMonad$update = (($f) => {
  return (($state) => {
    const $s = ($f)($state);
    return ({
      first: $s,
      second: $s,
    });
  });
});

const $sp$Compiler$TypeCheck$m_update = $sp$StateMonad$update;

const $sp$Compiler$TypeCheck$popClashingtypes = (($state) => {
  const $$try1 = $state.typeClashesByPlaceholderId;
  return ((($$try1)[0] === "Nothing")
    ? (sp_todo)("popping a nothing!")
    : ((($$try1)[0] === "Just")
      ? ((() => {
        const $dict = ($$try1)[1];
        return ({
          first: $dict,
          second: (Object.assign)({}, $state, ({
            typeClashesByPlaceholderId: $corelib$Maybe$Nothing,
          })),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 313:4', (sp_toHuman)($$try1))));
});

const $sp$Compiler$TypeCheck$unify = (($env) => {
  return (($pos) => {
    return (($reason) => {
      return (($a) => {
        return (($b) => {
          return (($sp$Compiler$TypeCheck$andThen)((($tc) => {
            return (((sp_not_equal)($corelib$Maybe$Nothing))($tc)
              ? (sp_todo)("typeClashesByPlaceholderId NOT EMPTY!")
              : (($sp$Compiler$TypeCheck$andThen)((() => {
                return (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($typeClashes) => {
                    return (((sp_equal)($corelib$Dict$empty))($typeClashes)
                      ? ($sp$Compiler$TypeCheck$return)($unifiedType)
                      : (($sp$Compiler$TypeCheck$andThen)((() => {
                        return ($sp$Compiler$TypeCheck$return)($unifiedType);
                      })))(((((($sp$Compiler$TypeCheck$errorIncompatibleTypes)($env))($reason))($pos))($unifiedType))($typeClashes)));
                  })))($sp$Compiler$TypeCheck$popClashingtypes);
                })))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a))($b));
              })))(($sp$Compiler$TypeCheck$m_update)((($s) => {
                return (Object.assign)({}, $s, ({
                  typeClashesByPlaceholderId: ($corelib$Maybe$Just)($corelib$Dict$empty),
                }));
              }))));
          })))(($sp$Compiler$TypeCheck$get)((($x) => {
            return $x.typeClashesByPlaceholderId;
          })));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$applyAttributePath = (($env) => {
  return (($pos) => {
    return (($attrPath) => {
      const $wrap = (($attributeName) => {
        return (($ty) => {
          const $maybeAttrType = ((($ty)[0] === "TypeRecord")
            ? ((() => {
              const $e = ($ty)[2];
              const $attrs = ($ty)[3];
              return (($corelib$Dict$get)($attributeName))($attrs);
            }))()
            : (true
              ? $corelib$Maybe$Nothing
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2042:12', (sp_toHuman)($ty))));
          return ((($maybeAttrType)[0] === "Just")
            ? ((() => {
              const $attrType = ($maybeAttrType)[1];
              return ($sp$Compiler$TypeCheck$return)($attrType);
            }))()
            : ((($maybeAttrType)[0] === "Nothing")
              ? (($sp$Compiler$TypeCheck$andThen)((($extName) => {
                return (($sp$Compiler$TypeCheck$andThen)((($attrType) => {
                  const $re = ((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)($extName)))((($corelib$Dict$singleton)($attributeName))($attrType));
                  return (($sp$Compiler$TypeCheck$andThen)((() => {
                    return ($sp$Compiler$TypeCheck$return)($attrType);
                  })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_AttributeAccess)($attributeName)))($ty))($re));
                })))(($sp$Compiler$TypeCheck$newType)($pos));
              })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity))
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2048:8', (sp_toHuman)($maybeAttrType))));
        });
      });
      return (($sp$Compiler$TypeCheck$list_for)($attrPath))($wrap);
    });
  });
});

const $sp$Compiler$TypeCheck$applySubsToNonFreeTyvars = (($env) => {
  return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
    const $meh = (($typeVarName) => {
      return (($constrainedVars) => {
        const $$try1 = (($corelib$Dict$get)($typeVarName))($subs);
        return ((($$try1)[0] === "Nothing")
          ? $constrainedVars
          : ((($$try1)[0] === "Just")
            ? ((() => {
              const $ty = ($$try1)[1];
              return ((($corelib$Dict$for)(($sp$Compiler$TypeCheck$typeTyvars)($ty)))((($n) => {
                return (($p) => {
                  return (($corelib$Dict$insert)($n))($p);
                });
              })))($constrainedVars);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2179:8', (sp_toHuman)($$try1))));
      });
    });
    return ($sp$Compiler$TypeCheck$return)((Object.assign)({}, $env, ({
      nonFreeTyvars: ((($corelib$List$for)(($corelib$Dict$keys)($env.nonFreeTyvars)))($meh))($env.nonFreeTyvars),
    })));
  })))(($sp$Compiler$TypeCheck$get)((($x) => {
    return $x.substitutions;
  })));
});

const $sp$Compiler$TypeCheck$checkConstructorWithItsArgs = (($env) => {
  return (($pos) => {
    return (($index) => {
      return (($actualArgs) => {
        return (($expectedArgs) => {
          const $$try1 = ({
            first: $actualArgs,
            second: $expectedArgs,
          });
          return (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Cons"))
            ? ((() => {
              const $actualHead = ($$try1.first)[1];
              const $actualTail = ($$try1.first)[2];
              const $expectedHead = ($$try1.second)[1];
              const $expectedTail = ($$try1.second)[2];
              return (($sp$Compiler$TypeCheck$andThen)((($updatedEnv) => {
                return ((((($sp$Compiler$TypeCheck$checkConstructorWithItsArgs)($updatedEnv))($pos))(($index + 1)))($actualTail))($expectedTail);
              })))(((($sp$Compiler$TypeCheck$checkAndInsertPattern)($env))($expectedHead))($actualHead));
            }))()
            : (((($$try1.first)[0] === "Nil") && (($$try1.second)[0] === "Cons"))
              ? ((() => {
                const $expectedHead = ($$try1.second)[1];
                const $expectedTail = ($$try1.second)[2];
                const $given = $index;
                const $needed = ($index + ($corelib$List$length)($expectedArgs));
                return (($sp$Compiler$TypeCheck$andThen)((() => {
                  return ($sp$Compiler$TypeCheck$return)($env);
                })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("Constructor needs " + ((text_fromNumber)($needed) + (" arguments but was given only " + (text_fromNumber)($given))))))($core$SPCore$Nil)));
              }))()
              : (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Nil"))
                ? ((() => {
                  const $actualHead = ($$try1.first)[1];
                  const $actualTail = ($$try1.first)[2];
                  return (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($actualArgs))((($core$SPCore$Cons)("more arguments than needed"))($core$SPCore$Nil));
                }))()
                : (((($$try1.first)[0] === "Nil") && (($$try1.second)[0] === "Nil"))
                  ? ($sp$Compiler$TypeCheck$return)($env)
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 793:4', (sp_toHuman)($$try1))))));
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$dict_for = (($d) => {
  return (($f) => {
    return (($sp$StateMonad$dict_foldl)($f))($d);
  });
});

const $sp$Compiler$TypeCheck$expandAlias = (($type) => {
  return ((($type)[0] === "TypeAlias")
    ? ((() => {
      const $t = ($type)[3];
      return ($sp$Compiler$TypeCheck$expandAlias)($t);
    }))()
    : (true
      ? $type
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 261:4', (sp_toHuman)($type))));
});

const $sp$Compiler$TypeCheck$onlyBothOnly = (($da) => {
  return (($db) => {
    const $onAOnly = (($key) => {
      return (($a) => {
        return (($$aOnly) => {
          const $aOnly = $$aOnly.first;
          const $both = $$aOnly.second;
          const $bOnly = $$aOnly.third;
          return ({
            first: ((($corelib$Dict$insert)($key))($a))($aOnly),
            second: $both,
            third: $bOnly,
          });
        });
      });
    });
    const $onBOnly = (($key) => {
      return (($b) => {
        return (($$aOnly) => {
          const $aOnly = $$aOnly.first;
          const $both = $$aOnly.second;
          const $bOnly = $$aOnly.third;
          return ({
            first: $aOnly,
            second: $both,
            third: ((($corelib$Dict$insert)($key))($b))($bOnly),
          });
        });
      });
    });
    const $onBoth = (($key) => {
      return (($a) => {
        return (($b) => {
          return (($$aOnly) => {
            const $aOnly = $$aOnly.first;
            const $both = $$aOnly.second;
            const $bOnly = $$aOnly.third;
            return ({
              first: $aOnly,
              second: ((($corelib$Dict$insert)($key))(({
                first: $a,
                second: $b,
              })))($both),
              third: $bOnly,
            });
          });
        });
      });
    });
    return (((((($corelib$Dict$merge)($onAOnly))($onBoth))($onBOnly))($da))($db))(({
      first: $corelib$Dict$empty,
      second: $corelib$Dict$empty,
      third: $corelib$Dict$empty,
    }));
  });
});

const $sp$Compiler$TypeCheck$isCompatibleWith = (($env) => {
  return (($expectedType) => {
    return (($pos) => {
      return (($actualType) => {
        const $$try1 = ({
          first: $expectedType,
          second: $actualType,
        });
        return (((($$try1.first)[0] === "TypeConstant") && (($$try1.second)[0] === "TypeConstant"))
          ? ((() => {
            const $expectedUsr = ($$try1.first)[2];
            const $expectedArgs = ($$try1.first)[3];
            const $actualUsr = ($$try1.second)[2];
            const $actualArgs = ($$try1.second)[3];
            return (((sp_not_equal)($actualUsr))($expectedUsr)
              ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("This expression should be of type"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))((($core$SPCore$Cons)("but instead is"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($actualType)))($core$SPCore$Nil)))))
              : ((($sp$Compiler$TypeCheck$list_for)(((($corelib$List$map2)($corelib$Tuple$pair))($expectedArgs))($actualArgs)))((($$a) => {
                const $e = $$a.first;
                const $a = $$a.second;
                return (() => {
                  return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($e))($pos))($a);
                });
              })))(null));
          }))()
          : (((($$try1.first)[0] === "TypeFunction") && (($$try1.second)[0] === "TypeFunction"))
            ? ((() => {
              const $eFrom = ($$try1.first)[2];
              const $eIsMut = ($$try1.first)[3];
              const $eTo = ($$try1.first)[4];
              const $aFrom = ($$try1.second)[2];
              const $aIsMut = ($$try1.second)[3];
              const $aTo = ($$try1.second)[4];
              return (((sp_not_equal)($aIsMut))($eIsMut)
                ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil))
                : (($sp$Compiler$TypeCheck$andThen)((() => {
                  return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($eTo))($pos))($aTo);
                })))((((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($eFrom))($pos))($aFrom)));
            }))()
            : (((($$try1.first)[0] === "TypeRecord") && ((($$try1.first)[2])[0] === "Just"))
              ? ((() => {
                const $e = (($$try1.first)[2])[1];
                const $eAttrs = ($$try1.first)[3];
                return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("Extensible record annotation is experimentally disabled [TODO link to why]"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("extension: " + (sp_toHuman)($e))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("attrs: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($eAttrs)))))($core$SPCore$Nil))))));
              }))()
              : (((($$try1.first)[0] === "TypeRecord") && (((($$try1.first)[2])[0] === "Nothing") && (($$try1.second)[0] === "TypeRecord")))
                ? ((() => {
                  const $eAttrs = ($$try1.first)[3];
                  const $aExtension = ($$try1.second)[2];
                  const $aAttrs = ($$try1.second)[3];
                  const $$aOnly = (($sp$Compiler$TypeCheck$onlyBothOnly)($eAttrs))($aAttrs);
                  const $aOnly = $$aOnly.third;
                  const $both = $$aOnly.second;
                  const $eOnly = $$aOnly.first;
                  return ((((sp_not_equal)($corelib$Dict$empty))($eOnly) && ((sp_equal)($corelib$Maybe$Nothing))($aExtension))
                    ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("missing attributes: " + (sp_toHuman)(($corelib$Dict$keys)($eOnly)))))($core$SPCore$Nil))
                    : (((sp_not_equal)($corelib$Dict$empty))($aOnly)
                      ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("extra attributes: " + (sp_toHuman)(($corelib$Dict$keys)($aOnly)))))($core$SPCore$Nil))
                      : ((($sp$Compiler$TypeCheck$dict_for)($both))((($attrName) => {
                        return (($$aType) => {
                          const $eType = $$aType.first;
                          const $aType = $$aType.second;
                          return (() => {
                            return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($eType))($pos))($aType);
                          });
                        });
                      })))(null)));
                }))()
                : ((($$try1.first)[0] === "TypeAlias")
                  ? ((() => {
                    const $ty = ($$try1.first)[3];
                    return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($ty))($pos))($actualType);
                  }))()
                  : ((($$try1.second)[0] === "TypeAlias")
                    ? ((() => {
                      const $ty = ($$try1.second)[3];
                      return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($ty);
                    }))()
                    : ((($$try1.second)[0] === "TypeVariable")
                      ? ((() => {
                        const $actualName = ($$try1.second)[2];
                        return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                          return ($sp$Compiler$TypeCheck$return)(null);
                        })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_AnnotationSimple))($expectedType))($actualType));
                      }))()
                      : (true
                        ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("I was expecting"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))((($core$SPCore$Cons)("but the actual type is: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($actualType)))((($core$SPCore$Cons)("The two types are not compatible!"))($core$SPCore$Nil))))))
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 584:4', (sp_toHuman)($$try1))))))))));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$checkAndInsertPattern = (($env) => {
  return (($expectedType_) => {
    return (($pattern) => {
      const $expectedType = ($sp$Compiler$TypeCheck$expandAlias)($expectedType_);
      return ((($pattern)[0] === "PatternAny")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $maybeName = ($pattern)[2];
          const $maybeAnnotation = ($pattern)[3];
          const $envWith = (($name) => {
            return (($type) => {
              return (Object.assign)({}, $env, ({
                instanceVariables: ((($corelib$Dict$insert)(($sp$Types$CanonicalAst$RefBlock)($name)))(({
                  definedAt: $pos,
                  freeTypeVariables: ((($sp$Compiler$TypeCheck$getFreeTypeVars)($env.nonFreeTyvars))($corelib$Dict$empty))($type),
                  isMutable: false,
                  ty: $type,
                })))($env.instanceVariables),
              }));
            });
          });
          const $$try3 = ({
            first: $maybeName,
            second: $maybeAnnotation,
          });
          return (((($$try3.first)[0] === "Just") && (($$try3.second)[0] === "Just"))
            ? ((() => {
              const $name = ($$try3.first)[1];
              const $annotation = ($$try3.second)[1];
              return (($sp$Compiler$TypeCheck$andThen)((() => {
                return ($sp$Compiler$TypeCheck$return)((($envWith)($name))($annotation));
              })))((((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($annotation));
            }))()
            : (((($$try3.first)[0] === "Just") && (($$try3.second)[0] === "Nothing"))
              ? ((() => {
                const $name = ($$try3.first)[1];
                return ($sp$Compiler$TypeCheck$return)((($envWith)($name))($expectedType));
              }))()
              : (((($$try3.first)[0] === "Nothing") && (($$try3.second)[0] === "Just"))
                ? ((() => {
                  const $annotation = ($$try3.second)[1];
                  return (($sp$Compiler$TypeCheck$andThen)((() => {
                    return ($sp$Compiler$TypeCheck$return)($env);
                  })))((((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($annotation));
                }))()
                : (((($$try3.first)[0] === "Nothing") && (($$try3.second)[0] === "Nothing"))
                  ? ($sp$Compiler$TypeCheck$return)($env)
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 719:12', (sp_toHuman)($$try3))))));
        }))()
        : ((($pattern)[0] === "PatternLiteralNumber")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $literal = ($pattern)[2];
            (sp_todo)("TODO needs proper type comparison without `pos`");
            return (((sp_equal)($sp$Compiler$CoreTypes$number))($expectedType)
              ? ($sp$Compiler$TypeCheck$return)($env)
              : (($sp$Compiler$TypeCheck$andThen)((() => {
                return ($sp$Compiler$TypeCheck$return)($env);
              })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This pattern is a Number, but the annotation says it should be " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil))));
          }))()
          : ((($pattern)[0] === "PatternLiteralText")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $literal = ($pattern)[2];
              (sp_todo)("TODO needs proper type comparison without `pos`");
              return (((sp_equal)($sp$Compiler$CoreTypes$text))($expectedType)
                ? ($sp$Compiler$TypeCheck$return)($env)
                : (($sp$Compiler$TypeCheck$andThen)((() => {
                  return ($sp$Compiler$TypeCheck$return)($env);
                })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This pattern is a Text, but the annotation says it should be " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil))));
            }))()
            : ((($pattern)[0] === "PatternConstructor")
              ? ((() => {
                const $pos = ($pattern)[1];
                const $usr = ($pattern)[2];
                const $args = ($pattern)[3];
                const $$try2 = (($corelib$Dict$get)($usr))($env.constructors);
                return ((($$try2)[0] === "Nothing")
                  ? (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($args))((($core$SPCore$Cons)(("Unknown constructor: " + (sp_toHuman)($usr))))($core$SPCore$Nil))
                  : ((($$try2)[0] === "Just")
                    ? ((() => {
                      const $constructor = ($$try2)[1];
                      return ((($expectedType)[0] === "TypeConstant")
                        ? ((() => {
                          const $expectedUsr = ($expectedType)[2];
                          const $args_ = ($expectedType)[3];
                          return (((sp_not_equal)($constructor.typeUsr))($usr)
                            ? (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($args))((($core$SPCore$Cons)(("Constructor produces " + ((sp_toHuman)($constructor.typeUsr) + (" but annotation requires " + (sp_toHuman)($expectedUsr))))))($core$SPCore$Nil))
                            : ((((($sp$Compiler$TypeCheck$checkConstructorWithItsArgs)($env))($pos))(0))($args))($constructor.args));
                        }))()
                        : (true
                          ? (((($sp$Compiler$TypeCheck$addCheckConstructorError)($pos))($env))($args))((($core$SPCore$Cons)(("This pattern is an union type, but the annotation expects a " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil))
                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 759:20', (sp_toHuman)($expectedType))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 754:12', (sp_toHuman)($$try2))));
              }))()
              : ((($pattern)[0] === "PatternRecord")
                ? ((() => {
                  const $pos = ($pattern)[1];
                  const $patternAttrs = ($pattern)[2];
                  return ((($expectedType)[0] === "TypeRecord")
                    ? ((() => {
                      const $expectedTypeAttrs = ($expectedType)[3];
                      return ((($sp$Compiler$TypeCheck$dict_for)($patternAttrs))((($attrName) => {
                        return (($attrPattern) => {
                          return (($envX) => {
                            const $$try1 = (($corelib$Dict$get)($attrName))($expectedTypeAttrs);
                            return ((($$try1)[0] === "Nothing")
                              ? (($sp$Compiler$TypeCheck$andThen)((() => {
                                return ($sp$Compiler$TypeCheck$return)($envX);
                              })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record pattern has an attribute `" + ($attrName + "` but it is not avaiable in the annotation"))))($core$SPCore$Nil)))
                              : ((($$try1)[0] === "Just")
                                ? ((() => {
                                  const $expectedAttrType = ($$try1)[1];
                                  return ((($sp$Compiler$TypeCheck$checkAndInsertPattern)($envX))($expectedAttrType))($attrPattern);
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 779:24', (sp_toHuman)($$try1))));
                          });
                        });
                      })))($env);
                    }))()
                    : (true
                      ? (($sp$Compiler$TypeCheck$andThen)((() => {
                        return ($sp$Compiler$TypeCheck$return)($env);
                      })))((($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This pattern is a record, but the annotation says it should be " + (($sp$Compiler$TypeCheck$typeToText)($env))($expectedType))))($core$SPCore$Nil)))
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 776:12', (sp_toHuman)($expectedType))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 702:4', (sp_toHuman)($pattern)))))));
    });
  });
});

const $sp$Compiler$TypeCheck$errorUndefinedVariable = (($env) => {
  return (($pos) => {
    return (($ref) => {
      return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))((($errorEnv) => {
        const $onLocal = (($name) => {
          const $$try2 = (($corelib$Dict$get)($name))($env.nonAnnotatedRecursives);
          return ((($$try2)[0] === "Just")
            ? ((() => {
              const $defPos = ($$try2)[1];
              return (($core$SPCore$Cons)(("To use function `" + ($name + "` recursively, you need to add a type annotation to its definition."))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("This is a limit of the compiler, not sure when I'll have the time to fix it."))($core$SPCore$Nil)));
            }))()
            : ((($$try2)[0] === "Nothing")
              ? (($core$SPCore$Cons)(("Undefined value: " + $name)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("I can't see a definition for `" + ($name + "` anywhere, so I don't know what it is."))))($core$SPCore$Nil)))
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2300:8', (sp_toHuman)($$try2))));
        });
        return ((($ref)[0] === "RefBlock")
          ? ((() => {
            const $name = ($ref)[1];
            return ($onLocal)($name);
          }))()
          : (((($ref)[0] === "RefRoot") && ((($ref)[1])[0] === "USR"))
            ? ((() => {
              const $umr = (($ref)[1])[1];
              const $name = (($ref)[1])[2];
              return (((sp_equal)($env.currentModule))($umr)
                ? ($onLocal)($name)
                : ((() => {
                  const $$path = $umr;
                  const $path = ($$path)[2];
                  const $source = ($$path)[1];
                  const $$try1 = (($corelib$Dict$get)($path))($errorEnv.moduleByName);
                  return ((($$try1)[0] === "Just")
                    ? ((() => {
                      const $mod = ($$try1)[1];
                      return (($core$SPCore$Cons)(("Module `" + ($path + ("` from source `" + ((sp_toHuman)($source) + ("` does not seem to expose a variable called `" + ($name + "`."))))))))($core$SPCore$Nil);
                    }))()
                    : ((($$try1)[0] === "Nothing")
                      ? (($core$SPCore$Cons)(("The code references a `" + ($path + ("." + ($name + ("` with source `" + (sp_toHuman)($source))))))))((($core$SPCore$Cons)("However, I can't find any module with that path and source."))($core$SPCore$Nil))
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2327:16', (sp_toHuman)($$try1))));
                }))());
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2313:4', (sp_toHuman)($ref))));
      }));
    });
  });
});

const $sp$Compiler$TypeCheck$checkFreeVariables = (($env) => {
  return (($pos) => {
    return (($patternType) => {
      return (($blockType) => {
        const $annotatedFreeVars = (($corelib$Dict$filter)((($name) => {
          return (() => {
            return ($sp$Compiler$TypeCheck$isAnnotation)($name);
          });
        })))(($sp$Compiler$TypeCheck$typeTyvars)($patternType));
        const $actualFreeVars = ($sp$Compiler$TypeCheck$typeTyvars)($blockType);
        return ((($corelib$Dict$size)($annotatedFreeVars) > ($corelib$Dict$size)($actualFreeVars))
          ? (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(null);
          })))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("The annotation is too general"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("The annotation uses: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($annotatedFreeVars)))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("But the actual type uses only: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($actualFreeVars)))))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($blockType)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("The annotation has " + ((text_fromNumber)((($corelib$Dict$size)($annotatedFreeVars) - ($corelib$Dict$size)($actualFreeVars))) + " type variables too many"))))($core$SPCore$Nil))))))))))
          : ($sp$Compiler$TypeCheck$return)(null));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$fromArgument = (($env) => {
  return (($argument) => {
    return ((($argument)[0] === "ArgumentExpression")
      ? ((() => {
        const $expr = ($argument)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
          return ($sp$Compiler$TypeCheck$return)(({
            first: false,
            second: $ty,
          }));
        })))((($sp$Compiler$TypeCheck$fromExpression)($env))($expr));
      }))()
      : ((($argument)[0] === "ArgumentMutable")
        ? ((() => {
          const $pos = ($argument)[1];
          const $attrPath = ($argument)[2].attrPath;
          const $ref = ($argument)[2].ref;
          const $$try1 = (($corelib$Dict$get)($ref))($env.instanceVariables);
          return ((($$try1)[0] === "Nothing")
            ? (($sp$Compiler$TypeCheck$andThen)((($ty) => {
              return ($sp$Compiler$TypeCheck$return)(({
                first: true,
                second: $ty,
              }));
            })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref))
            : ((($$try1)[0] === "Just")
              ? ((() => {
                const $var = ($$try1)[1];
                return (($corelib$Basics$not)($var.isMutable)
                  ? ((() => {
                    const $ae = (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("You are trying to mutate variable `" + ((sp_toHuman)($ref) + "` but it was declared as not mutable!"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("TODO [link to wiki page that explains how to declare variables]"))($core$SPCore$Nil))));
                    return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                      return ($sp$Compiler$TypeCheck$return)(({
                        first: true,
                        second: $ty,
                      }));
                    })))($ae);
                  }))()
                  : (($sp$Compiler$TypeCheck$typeContainsFunctions)($var.ty)
                    ? (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                      return ($sp$Compiler$TypeCheck$return)(({
                        first: true,
                        second: $ty,
                      }));
                    })))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("mutable arguments can't allow functions"))($core$SPCore$Nil)))
                    : (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                      return ($sp$Compiler$TypeCheck$return)(({
                        first: true,
                        second: $ty,
                      }));
                    })))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($var.ty))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1342:12', (sp_toHuman)($$try1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1336:4', (sp_toHuman)($argument))));
  });
});

const $sp$Compiler$TypeCheck$setNonFn = (($name) => {
  return (($state) => {
    return ({
      first: null,
      second: (Object.assign)({}, $state, ({
        nonFnTyvars: ((($corelib$Dict$insert)($name))($core$SPCore$Nil))($state.nonFnTyvars),
      })),
    });
  });
});

const $sp$Compiler$TypeCheck$generateNewTypeVariables = (($tyvarByName) => {
  const $apply = (($name0) => {
    return (($arg) => {
      return (($subs) => {
        const $$nonFn = $arg;
        const $nonFn = $$nonFn.nonFn;
        return (($sp$Compiler$TypeCheck$andThen)((($name1) => {
          return (($sp$Compiler$TypeCheck$andThen)((() => {
            return ($sp$Compiler$TypeCheck$return)(((($corelib$Dict$insert)($name0))((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))($name1)))($subs));
          })))(($nonFn
            ? ($sp$Compiler$TypeCheck$setNonFn)($name1)
            : ($sp$Compiler$TypeCheck$return)(null)));
        })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
      });
    });
  });
  return ((($sp$Compiler$TypeCheck$dict_for)($tyvarByName))($apply))($corelib$Dict$empty);
});

const $sp$Compiler$TypeCheck$replaceTypeVariablesWithNew = (($freeTypeVariables) => {
  return (($type) => {
    return (((sp_equal)($corelib$Dict$empty))($freeTypeVariables)
      ? ($sp$Compiler$TypeCheck$return)($type)
      : (($sp$Compiler$TypeCheck$andThen)((($newTypeByOldType) => {
        return ($sp$Compiler$TypeCheck$return)((($sp$Compiler$TypeCheck$replaceTypeVariables)($newTypeByOldType))($type));
      })))(($sp$Compiler$TypeCheck$generateNewTypeVariables)($freeTypeVariables)));
  });
});

const $sp$Compiler$TypeCheck$unifyConstructorWithItsArgs = (($p) => {
  const $$try1 = ({
    first: $p.ty,
    second: $p.args,
  });
  return (((($$try1.first)[0] === "TypeFunction") && (($$try1.second)[0] === "Cons"))
    ? ((() => {
      const $from = ($$try1.first)[2];
      const $to = ($$try1.first)[4];
      const $head = ($$try1.second)[1];
      const $tail = ($$try1.second)[2];
      return (($sp$Compiler$TypeCheck$andThen)((($pa) => {
        const $$isFullyAnnotated = $pa;
        const $vars = $$isFullyAnnotated.vars;
        const $ty = $$isFullyAnnotated.ty;
        const $pos = $$isFullyAnnotated.pos;
        const $isFullyAnnotated = $$isFullyAnnotated.isFullyAnnotated;
        return (($sp$Compiler$TypeCheck$andThen)((($unifiedFrom) => {
          return ($sp$Compiler$TypeCheck$unifyConstructorWithItsArgs)((Object.assign)({}, $p, ({
            argIndex: ($p.argIndex + 1),
            args: $tail,
            isFullyAnnotated: ($isFullyAnnotated && $p.isFullyAnnotated),
            ty: $to,
            vars: $vars,
          })));
        })))(((((($sp$Compiler$TypeCheck$unify)($p.env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument)($p)))($from))($ty));
      })))(((($sp$Compiler$TypeCheck$fromPattern)($p.env))($head))($p.vars));
    }))()
    : (((($$try1.first)[0] === "TypeFunction") && (($$try1.second)[0] === "Nil"))
      ? ((() => {
        const $from = ($$try1.first)[2];
        const $to = ($$try1.first)[4];
        return (($sp$Compiler$TypeCheck$andThen)((($ety) => {
          return ($sp$Compiler$TypeCheck$return)(({
            first: $p.vars,
            second: $ety,
            third: $p.isFullyAnnotated,
          }));
        })))((($sp$Compiler$TypeCheck$addError)($p.pos))((($core$SPCore$Cons)(("Type constructor " + ((sp_toHuman)($p.usr) + (" is missing argument #" + (text_fromNumber)($p.argIndex))))))($core$SPCore$Nil)));
      }))()
      : ((($$try1.second)[0] === "Nil")
        ? (($sp$Compiler$TypeCheck$andThen)((($subs) => {
          return ($sp$Compiler$TypeCheck$return)(({
            first: $p.vars,
            second: $p.ty,
            third: $p.isFullyAnnotated,
          }));
        })))(($sp$Compiler$TypeCheck$get)((($x) => {
          return $x.substitutions;
        })))
        : ((($$try1.second)[0] === "Cons")
          ? ((() => {
            const $head = ($$try1.second)[1];
            const $tail = ($$try1.second)[2];
            return (($sp$Compiler$TypeCheck$andThen)((($ety) => {
              return ($sp$Compiler$TypeCheck$return)(({
                first: $p.vars,
                second: $ety,
                third: $p.isFullyAnnotated,
              }));
            })))((($sp$Compiler$TypeCheck$addError)($p.pos))((($core$SPCore$Cons)(("Type constructor " + ((sp_toHuman)($p.usr) + " has too many args"))))($core$SPCore$Nil)));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1570:4', (sp_toHuman)($$try1))))));
});

const $sp$Compiler$TypeCheck$fromPattern = (($env) => {
  return (($pattern) => {
    return (($vars_) => {
      const $vars = $vars_;
      return ((($pattern)[0] === "PatternAny")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $maybeName = ($pattern)[2];
          const $maybeAnnotation = ($pattern)[3];
          const $isAnnotated = ((sp_not_equal)($corelib$Maybe$Nothing))($maybeAnnotation);
          const $makeType = ((($maybeAnnotation)[0] === "Nothing")
            ? ($sp$Compiler$TypeCheck$newType)($pos)
            : ((($maybeAnnotation)[0] === "Just")
              ? ((() => {
                const $type = ($maybeAnnotation)[1];
                const $$try2 = (($sp$Compiler$ExpandTypes$expandAnnotation)($env.types))($type);
                return ((($$try2)[0] === "Err")
                  ? ((() => {
                    const $e = ($$try2)[1];
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return ($sp$Compiler$TypeCheck$newType)($pos);
                    })))(($sp$Compiler$TypeCheck$insertError)($e));
                  }))()
                  : ((($$try2)[0] === "Ok")
                    ? ((() => {
                      const $t = ($$try2)[1];
                      return ($sp$Compiler$TypeCheck$return)($t);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1487:24', (sp_toHuman)($$try2))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1482:16', (sp_toHuman)($maybeAnnotation))));
          return (($sp$Compiler$TypeCheck$andThen)((($type) => {
            const $newVars = ((($maybeName)[0] === "Nothing")
              ? $vars
              : ((($maybeName)[0] === "Just")
                ? ((() => {
                  const $name = ($maybeName)[1];
                  return ((($corelib$Dict$insert)($name))(({
                    isAnnotated: $isAnnotated,
                    pos: $pos,
                    type: $type,
                  })))($vars);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1498:16', (sp_toHuman)($maybeName))));
            return ($sp$Compiler$TypeCheck$return)(({
              isFullyAnnotated: $isAnnotated,
              pos: $pos,
              ty: $type,
              vars: $newVars,
            }));
          })))($makeType);
        }))()
        : ((($pattern)[0] === "PatternLiteralNumber")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $literal = ($pattern)[2];
            return ($sp$Compiler$TypeCheck$return)(({
              isFullyAnnotated: true,
              pos: $pos,
              ty: $sp$Compiler$CoreTypes$number,
              vars: $vars,
            }));
          }))()
          : ((($pattern)[0] === "PatternLiteralText")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $literal = ($pattern)[2];
              return ($sp$Compiler$TypeCheck$return)(({
                isFullyAnnotated: true,
                pos: $pos,
                ty: $sp$Compiler$CoreTypes$text,
                vars: $vars,
              }));
            }))()
            : ((($pattern)[0] === "PatternConstructor")
              ? ((() => {
                const $pos = ($pattern)[1];
                const $usr = ($pattern)[2];
                const $args = ($pattern)[3];
                const $constructorTyM = ((() => {
                  const $$try1 = (($corelib$Dict$get)($usr))($env.constructors);
                  return ((($$try1)[0] === "Nothing")
                    ? ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr))
                    : ((($$try1)[0] === "Just")
                      ? ((() => {
                        const $c = ($$try1)[1];
                        return (($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Compiler$TypeCheck$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1512:16', (sp_toHuman)($$try1))));
                }))();
                return (($sp$Compiler$TypeCheck$andThen)((($constructorTy) => {
                  const $p = ({
                    argIndex: 0,
                    args: $args,
                    env: $env,
                    isFullyAnnotated: true,
                    pos: $pos,
                    ty: $constructorTy,
                    usr: $usr,
                    vars: $vars,
                  });
                  return (($sp$Compiler$TypeCheck$andThen)((($$isFullyAnnotated) => {
                    const $patternVars = $$isFullyAnnotated.first;
                    const $patternTy = $$isFullyAnnotated.second;
                    const $isFullyAnnotated = $$isFullyAnnotated.third;
                    return ($sp$Compiler$TypeCheck$return)(({
                      isFullyAnnotated: $isFullyAnnotated,
                      pos: $pos,
                      ty: $patternTy,
                      vars: $patternVars,
                    }));
                  })))(($sp$Compiler$TypeCheck$unifyConstructorWithItsArgs)($p));
                })))($constructorTyM);
              }))()
              : ((($pattern)[0] === "PatternRecord")
                ? ((() => {
                  const $pos = ($pattern)[1];
                  const $attrs = ($pattern)[2];
                  const $blah = (($name) => {
                    return (($pa) => {
                      return (($$annotatedSoFar) => {
                        const $varsX = $$annotatedSoFar.first;
                        const $attrTypes = $$annotatedSoFar.second;
                        const $annotatedSoFar = $$annotatedSoFar.third;
                        return (($sp$Compiler$TypeCheck$andThen)((($paOut) => {
                          return ($sp$Compiler$TypeCheck$return)(({
                            first: $paOut.vars,
                            second: ((($corelib$Dict$insert)($name))($paOut.ty))($attrTypes),
                            third: ($paOut.isFullyAnnotated && $annotatedSoFar),
                          }));
                        })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pa))($varsX));
                      });
                    });
                  });
                  return (($sp$Compiler$TypeCheck$andThen)((($$attrTypes) => {
                    const $vars1 = $$attrTypes.first;
                    const $attrTypes = $$attrTypes.second;
                    const $isFullyAnnotated = $$attrTypes.third;
                    return ($sp$Compiler$TypeCheck$return)(({
                      isFullyAnnotated: $isFullyAnnotated,
                      pos: $pos,
                      ty: ((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($attrTypes),
                      vars: $vars1,
                    }));
                  })))(((($sp$Compiler$TypeCheck$dict_for)($attrs))($blah))(({
                    first: $vars,
                    second: $corelib$Dict$empty,
                    third: true,
                  })));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1475:4', (sp_toHuman)($pattern)))))));
    });
  });
});

const $sp$Compiler$TypeCheck$fromParameter = (($env) => {
  return (($param) => {
    return ((($param)[0] === "ParameterPattern")
      ? ((() => {
        const $pattern = ($param)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
          return ($sp$Compiler$TypeCheck$return)(({
            first: false,
            second: $patternOut,
          }));
        })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
      }))()
      : ((($param)[0] === "ParameterMutable")
        ? ((() => {
          const $pos = ($param)[1];
          const $paramName = ($param)[2];
          return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
            const $vars = (($corelib$Dict$singleton)($paramName))(({
              isAnnotated: false,
              pos: $pos,
              type: $ty,
            }));
            return ($sp$Compiler$TypeCheck$return)(({
              first: true,
              second: ({
                isFullyAnnotated: false,
                pos: $pos,
                ty: $ty,
                vars: $vars,
              }),
            }));
          })))(($sp$Compiler$TypeCheck$newType)($pos));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1370:4', (sp_toHuman)($param))));
  });
});

const $sp$Compiler$TypeCheck$insertPatternVar = (($pars) => {
  return (($name) => {
    return (($patternVar) => {
      return (($env) => {
        const $refinedTy = ($patternVar.isAnnotated
          ? $patternVar.type
          : (($sp$Compiler$TypeCheck$replaceTypeVariables)($pars.subs))($patternVar.type));
        const $ref = ($pars.isRoot
          ? ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($env.currentModule))($name))
          : ($sp$Types$CanonicalAst$RefBlock)($name));
        return ($sp$Compiler$TypeCheck$return)(({
          constructors: $env.constructors,
          currentModule: $env.currentModule,
          instanceVariables: ((($corelib$Dict$insert)($ref))(({
            definedAt: $patternVar.pos,
            freeTypeVariables: (($pars.isMutable || $pars.isParameter)
              ? $corelib$Dict$empty
              : ((($sp$Compiler$TypeCheck$getFreeTypeVars)($env.nonFreeTyvars))($corelib$Dict$empty))($refinedTy)),
            isMutable: $pars.isMutable,
            ty: $refinedTy,
          })))($env.instanceVariables),
          meta: $env.meta,
          nonAnnotatedRecursives: ($patternVar.isAnnotated
            ? $env.nonAnnotatedRecursives
            : ((($corelib$Dict$insert)($name))($patternVar.pos))($env.nonAnnotatedRecursives)),
          nonFreeTyvars: ($pars.isParameter
            ? ((($corelib$Dict$for)(($sp$Compiler$TypeCheck$typeTyvars)($refinedTy)))($corelib$Dict$insert))($env.nonFreeTyvars)
            : $env.nonFreeTyvars),
          types: $env.types,
        }));
      });
    });
  });
});

const $sp$Compiler$TypeCheck$insertPatternVars = (($pars) => {
  return (($vars) => {
    return (($sp$Compiler$TypeCheck$dict_for)($vars))(($sp$Compiler$TypeCheck$insertPatternVar)($pars));
  });
});

const $sp$Compiler$TypeCheck$fromPatternAndBlock = (($env) => {
  return (($$block) => {
    const $pattern = $$block.first;
    const $block = $$block.second;
    return (($$blockTypeSoFar) => {
      const $patternTypeSoFar = $$blockTypeSoFar.first;
      const $blockTypeSoFar = $$blockTypeSoFar.second;
      return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
        return (($sp$Compiler$TypeCheck$andThen)((($unifiedPatternType) => {
          return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
            return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
              const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                isMutable: false,
                isParameter: false,
                isRoot: false,
                subs: $subs,
              })))($patternOut.vars))($env1);
              return (($sp$Compiler$TypeCheck$andThen)((($patternEnv) => {
                return (($sp$Compiler$TypeCheck$andThen)((($blockType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($unifiedBlockType) => {
                    return ($sp$Compiler$TypeCheck$return)(({
                      first: $unifiedPatternType,
                      second: $unifiedBlockType,
                    }));
                  })))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))(($sp$Compiler$TypeCheck$UnifyReason_TryBlock)($block)))($blockTypeSoFar))($blockType));
                })))((($sp$Compiler$TypeCheck$fromExpression)($patternEnv))($block));
              })))($ip);
            })))(($sp$Compiler$TypeCheck$get)((($x) => {
              return $x.substitutions;
            })));
          })))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env));
        })))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_TryPattern))($patternOut.ty))($patternTypeSoFar));
      })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
    });
  });
});

const $sp$Types$CanonicalAst$argumentPos = (($arg) => {
  return ((($arg)[0] === "ArgumentExpression")
    ? ((() => {
      const $e = ($arg)[1];
      return ($sp$Types$CanonicalAst$expressionPos)($e);
    }))()
    : ((($arg)[0] === "ArgumentMutable")
      ? ((() => {
        const $pos = ($arg)[1];
        return $pos;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 234:4', (sp_toHuman)($arg))));
});

const $sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType = (($env) => {
  return (($reference) => {
    return (($referenceType) => {
      return (($callIsMutable) => {
        return (($argument) => {
          return (($callArgumentType) => {
            return ((($referenceType)[0] === "TypeFunction")
              ? ((() => {
                const $refArgumentType = ($referenceType)[2];
                const $refIsMutable = ($referenceType)[3];
                const $refReturnType = ($referenceType)[4];
                return (((sp_not_equal)($refIsMutable))($callIsMutable)
                  ? (($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$expressionPos)($reference)))((($core$SPCore$Cons)("mutability clash 2"))($core$SPCore$Nil))
                  : ((() => {
                    const $pos = ($sp$Types$CanonicalAst$expressionPos)($reference);
                    const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
                      argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
                      reference: $pos,
                    }));
                    return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                      return ($sp$Compiler$TypeCheck$applySubsToType)($refReturnType);
                    })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($refArgumentType))($callArgumentType));
                  }))());
              }))()
              : ((($referenceType)[0] === "TypeVariable")
                ? ((() => {
                  const $pos = ($referenceType)[1];
                  const $name = ($referenceType)[2];
                  return (($sp$Compiler$TypeCheck$andThen)((($returnType) => {
                    const $ty = (((($sp$Types$CanonicalAst$TypeFunction)($pos))($callArgumentType))($callIsMutable))($returnType);
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return ($sp$Compiler$TypeCheck$applySubsToType)($returnType);
                    })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))((($sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction)($pos))($referenceType)))($referenceType))($ty));
                  })))(($sp$Compiler$TypeCheck$newType)($pos));
                }))()
                : ((($referenceType)[0] === "TypeAlias")
                  ? ((() => {
                    const $pos = ($referenceType)[1];
                    const $ty = ($referenceType)[3];
                    return (((((($sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType)($env))($reference))($ty))($callIsMutable))($argument))($callArgumentType);
                  }))()
                  : (true
                    ? (($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$expressionPos)($reference)))((($core$SPCore$Cons)("This is being called like a function, but its type is"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil))))
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1270:4', (sp_toHuman)($referenceType))))));
          });
        });
      });
    });
  });
});

const $sp$Compiler$TypeCheck$fromExpression = (($env) => {
  return (($expression) => {
    return ((($expression)[0] === "LiteralText")
      ? ((() => {
        const $pos = ($expression)[1];
        const $l = ($expression)[2];
        return ($sp$Compiler$TypeCheck$return)($sp$Compiler$CoreTypes$text);
      }))()
      : ((($expression)[0] === "LiteralNumber")
        ? ((() => {
          const $pos = ($expression)[1];
          const $l = ($expression)[2];
          return ($sp$Compiler$TypeCheck$return)($sp$Compiler$CoreTypes$number);
        }))()
        : ((($expression)[0] === "Variable")
          ? ((() => {
            const $pos = ($expression)[1];
            const $attrPath = ($expression)[2].attrPath;
            const $ref = ($expression)[2].ref;
            const $$try2 = (($corelib$Dict$get)($ref))($env.instanceVariables);
            return ((($$try2)[0] === "Nothing")
              ? ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref)
              : ((($$try2)[0] === "Just")
                ? ((() => {
                  const $var = ($$try2)[1];
                  return (($sp$Compiler$TypeCheck$andThen)((($varType) => {
                    return (((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($varType);
                  })))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)($var.freeTypeVariables))($var.ty));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1114:12', (sp_toHuman)($$try2))));
          }))()
          : ((($expression)[0] === "Constructor")
            ? ((() => {
              const $pos = ($expression)[1];
              const $usr = ($expression)[2];
              const $$try1 = (($corelib$Dict$get)($usr))($env.constructors);
              return ((($$try1)[0] === "Nothing")
                ? ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr))
                : ((($$try1)[0] === "Just")
                  ? ((() => {
                    const $c = ($$try1)[1];
                    return (($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Compiler$TypeCheck$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1188:12', (sp_toHuman)($$try1))));
            }))()
            : ((($expression)[0] === "Lambda")
              ? ((() => {
                const $pos = ($expression)[1];
                const $param = ($expression)[2];
                const $body = ($expression)[3];
                return (($sp$Compiler$TypeCheck$andThen)((($$isMutable) => {
                  const $isMutable = $$isMutable.first;
                  const $patternOut = $$isMutable.second;
                  const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                    isMutable: $isMutable,
                    isParameter: true,
                    isRoot: false,
                    subs: $corelib$Dict$empty,
                  })))($patternOut.vars))($env);
                  return (($sp$Compiler$TypeCheck$andThen)((($bodyEnv) => {
                    return (($sp$Compiler$TypeCheck$andThen)((($bodyType) => {
                      return (($sp$Compiler$TypeCheck$andThen)((($refinedPatternOutTy) => {
                        return (($isMutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($refinedPatternOutTy))
                          ? (($sp$Compiler$TypeCheck$errorTodo)($pos))("mutable args cannot be functions")
                          : ($sp$Compiler$TypeCheck$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($refinedPatternOutTy))($isMutable))($bodyType)));
                      })))(($sp$Compiler$TypeCheck$applySubsToType)($patternOut.ty));
                    })))((($sp$Compiler$TypeCheck$fromExpression)($bodyEnv))($body));
                  })))($ip);
                })))((($sp$Compiler$TypeCheck$fromParameter)($env))($param));
              }))()
              : ((($expression)[0] === "Call")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $reference = ($expression)[2];
                  const $argument = ($expression)[3];
                  return (($sp$Compiler$TypeCheck$andThen)((($referenceType) => {
                    return (($sp$Compiler$TypeCheck$andThen)((($$argumentType) => {
                      const $fromIsMutable = $$argumentType.first;
                      const $argumentType = $$argumentType.second;
                      return (((((($sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType)($env))($reference))($referenceType))($fromIsMutable))($argument))($argumentType);
                    })))((($sp$Compiler$TypeCheck$fromArgument)($env))($argument));
                  })))((($sp$Compiler$TypeCheck$fromExpression)($env))($reference));
                }))()
                : ((($expression)[0] === "If")
                  ? ((() => {
                    const $pos = ($expression)[1];
                    const $ar = ($expression)[2];
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return (($sp$Compiler$TypeCheck$andThen)((($s) => {
                        return (($sp$Compiler$TypeCheck$andThen)((($trueType) => {
                          return (($sp$Compiler$TypeCheck$andThen)((($falseType) => {
                            return ((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_IfBranches))($trueType))($falseType);
                          })))((($sp$Compiler$TypeCheck$fromExpression)($env))($ar.false));
                        })))((($sp$Compiler$TypeCheck$fromExpression)($env))($ar.true));
                      })))(($sp$Compiler$TypeCheck$get)((($x) => {
                        return $x.substitutions;
                      })));
                    })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($sp$Compiler$CoreTypes$bool))($ar.condition));
                  }))()
                  : ((($expression)[0] === "Try")
                    ? ((() => {
                      const $pos = ($expression)[1];
                      const $value = ($expression)[2];
                      const $patternsAndBlocks = ($expression)[3];
                      return (($sp$Compiler$TypeCheck$andThen)((($tryType) => {
                        return (($sp$Compiler$TypeCheck$andThen)((($newBlockType) => {
                          return (($sp$Compiler$TypeCheck$andThen)((($$inferredBlockType) => {
                            const $patternType = $$inferredBlockType.first;
                            const $inferredBlockType = $$inferredBlockType.second;
                            return ($sp$Compiler$TypeCheck$return)($inferredBlockType);
                          })))(((($sp$Compiler$TypeCheck$list_for)($patternsAndBlocks))(($sp$Compiler$TypeCheck$fromPatternAndBlock)($env)))(({
                            first: $tryType,
                            second: $newBlockType,
                          })));
                        })))(($sp$Compiler$TypeCheck$newType)($pos));
                      })))((($sp$Compiler$TypeCheck$fromExpression)($env))($value));
                    }))()
                    : ((($expression)[0] === "Record")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $maybeExt = ($expression)[2];
                        const $attrValues = ($expression)[3];
                        return (($sp$Compiler$TypeCheck$andThen)((($attrTypes) => {
                          return ((($maybeExt)[0] === "Nothing")
                            ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($attrTypes))
                            : ((($maybeExt)[0] === "Just")
                              ? ((() => {
                                const $variableArgs = ($maybeExt)[1];
                                return (($sp$Compiler$TypeCheck$andThen)((($ty_) => {
                                  return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                                    return (($sp$Compiler$TypeCheck$andThen)((($name) => {
                                      return (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => {
                                        return ($sp$Compiler$TypeCheck$return)($unifiedType);
                                      })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate)(($corelib$Dict$keys)($attrTypes))))($ty))(((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($name)))($attrTypes)));
                                    })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
                                  })))(($sp$Compiler$TypeCheck$applySubsToType)($ty_));
                                })))((($sp$Compiler$TypeCheck$fromExpression)($env))((($sp$Types$CanonicalAst$Variable)($pos))($variableArgs)));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1244:12', (sp_toHuman)($maybeExt))));
                        })))((($sp$Compiler$TypeCheck$dict_map)((($k) => {
                          return ($sp$Compiler$TypeCheck$fromExpression)($env);
                        })))($attrValues));
                      }))()
                      : ((($expression)[0] === "LetIn")
                        ? ((() => {
                          const $valueDef = ($expression)[1];
                          const $e = ($expression)[2];
                          return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
                            return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                              return (($valueDef.mutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($ty))
                                ? (($sp$Compiler$TypeCheck$andThen)((() => {
                                  return ($sp$Compiler$TypeCheck$return)($ty);
                                })))((($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$patternPos)($valueDef.pattern)))((($core$SPCore$Cons)("blocks that define mutables can't return functions"))($core$SPCore$Nil)))
                                : ($sp$Compiler$TypeCheck$return)($ty));
                            })))((($sp$Compiler$TypeCheck$fromExpression)($env1))($e));
                          })))(((($sp$Compiler$TypeCheck$fromDefinition)(false))($valueDef))($env));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1106:4', (sp_toHuman)($expression))))))))))));
  });
});

const $sp$Compiler$TypeCheck$fromDefinition = (($isRoot) => {
  return (($def) => {
    return (($env) => {
      return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
        const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
          isMutable: $def.mutable,
          isParameter: false,
          isRoot: $isRoot,
          subs: $corelib$Dict$empty,
        })))($patternOut.vars))($env);
        return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
          return ($def.native
            ? ($sp$Compiler$TypeCheck$return)($env1)
            : ($patternOut.isFullyAnnotated
              ? (($sp$Compiler$TypeCheck$andThen)((() => {
                return ($sp$Compiler$TypeCheck$return)($env1);
              })))(((($sp$Compiler$TypeCheck$checkExpression)($env1))($patternOut.ty))($def.body))
              : (($sp$Compiler$TypeCheck$andThen)((($bodyType_) => {
                return (($sp$Compiler$TypeCheck$andThen)((($bodyType) => {
                  return (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => {
                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                      return (($sp$Compiler$TypeCheck$andThen)((($env2) => {
                        return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                          return ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                            isMutable: $def.mutable,
                            isParameter: false,
                            isRoot: $isRoot,
                            subs: $subs,
                          })))($patternOut.vars))($env2);
                        })))(($sp$Compiler$TypeCheck$get)((($x) => {
                          return $x.substitutions;
                        })));
                      })))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env1));
                    })))((((($sp$Compiler$TypeCheck$checkFreeVariables)($env1))($patternOut.pos))($patternOut.ty))($bodyType));
                  })))(((((($sp$Compiler$TypeCheck$unify)($env1))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern))($bodyType))($patternOut.ty));
                })))(($sp$Compiler$TypeCheck$applySubsToType)($bodyType_));
              })))((($sp$Compiler$TypeCheck$fromExpression)($env1))($def.body))));
        })))($ip);
      })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($def.pattern))($corelib$Dict$empty));
    });
  });
});

const $sp$Compiler$TypeCheck$checkExpression = (($env) => {
  return (($expectedType_) => {
    return (($expression) => {
      const $expectedType = ($sp$Compiler$TypeCheck$expandAlias)($expectedType_);
      return ((($expression)[0] === "LiteralText")
        ? ((() => {
          const $pos = ($expression)[1];
          const $l = ($expression)[2];
          return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($sp$Compiler$CoreTypes$text);
        }))()
        : ((($expression)[0] === "LiteralNumber")
          ? ((() => {
            const $pos = ($expression)[1];
            const $l = ($expression)[2];
            return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($sp$Compiler$CoreTypes$number);
          }))()
          : ((($expression)[0] === "Variable")
            ? ((() => {
              const $pos = ($expression)[1];
              const $attrPath = ($expression)[2].attrPath;
              const $ref = ($expression)[2].ref;
              const $$try7 = (($corelib$Dict$get)($ref))($env.instanceVariables);
              return ((($$try7)[0] === "Nothing")
                ? (($sp$Compiler$TypeCheck$andThen)((() => {
                  return ($sp$Compiler$TypeCheck$return)(null);
                })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref))
                : ((($$try7)[0] === "Just")
                  ? ((() => {
                    const $var = ($$try7)[1];
                    return (($sp$Compiler$TypeCheck$andThen)((($instantiatedType) => {
                      return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                        return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($ty);
                      })))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($instantiatedType));
                    })))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)($var.freeTypeVariables))($var.ty));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 833:12', (sp_toHuman)($$try7))));
            }))()
            : ((($expression)[0] === "Constructor")
              ? ((() => {
                const $pos = ($expression)[1];
                const $usr = ($expression)[2];
                const $$try6 = (($corelib$Dict$get)($usr))($env.constructors);
                return ((($$try6)[0] === "Nothing")
                  ? (($sp$Compiler$TypeCheck$andThen)((() => {
                    return ($sp$Compiler$TypeCheck$return)(null);
                  })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr)))
                  : ((($$try6)[0] === "Just")
                    ? ((() => {
                      const $c = ($$try6)[1];
                      return (($sp$Compiler$TypeCheck$andThen)((($instantiatedType) => {
                        return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($instantiatedType);
                      })))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Compiler$TypeCheck$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 852:12', (sp_toHuman)($$try6))));
              }))()
              : ((($expression)[0] === "Lambda")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $param = ($expression)[2];
                  const $body = ($expression)[3];
                  const $$try5 = ({
                    first: $expectedType,
                    second: $param,
                  });
                  return (((($$try5.first)[0] === "TypeFunction") && (($$try5.first)[3] && (($$try5.second)[0] === "ParameterMutable")))
                    ? ((() => {
                      const $parameterType = ($$try5.first)[2];
                      const $returnType = ($$try5.first)[4];
                      const $parameterPos = ($$try5.second)[1];
                      const $parameterName = ($$try5.second)[2];
                      const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                        isMutable: true,
                        isParameter: true,
                        isRoot: false,
                        subs: $corelib$Dict$empty,
                      })))((($corelib$Dict$singleton)($parameterName))(({
                        isAnnotated: true,
                        pos: $parameterPos,
                        type: $parameterType,
                      }))))($env);
                      return (($sp$Compiler$TypeCheck$andThen)((($localEnv) => {
                        return ((($sp$Compiler$TypeCheck$checkExpression)($localEnv))($returnType))($body);
                      })))($ip);
                    }))()
                    : (((($$try5.first)[0] === "TypeFunction") && (!(($$try5.first)[3]) && (($$try5.second)[0] === "ParameterPattern")))
                      ? ((() => {
                        const $parameterType = ($$try5.first)[2];
                        const $returnType = ($$try5.first)[4];
                        const $pattern = ($$try5.second)[1];
                        return (($sp$Compiler$TypeCheck$andThen)((($localEnv) => {
                          return ((($sp$Compiler$TypeCheck$checkExpression)($localEnv))($returnType))($body);
                        })))(((($sp$Compiler$TypeCheck$checkAndInsertPattern)($env))($parameterType))($pattern));
                      }))()
                      : ((($$try5.first)[0] === "TypeFunction")
                        ? ((() => {
                          const $isMutable = ($$try5.first)[3];
                          return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("the function and the annotation have different mutability"))($core$SPCore$Nil));
                        }))()
                        : ((($$try5.first)[0] === "TypeVariable")
                          ? ((() => {
                            const $pos = ($$try5.first)[1];
                            const $name = ($$try5.first)[2];
                            return (($sp$Compiler$TypeCheck$isAnnotation)($name)
                              ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This is a function, but the annotation says it should be of type variable `" + ($name + "` which implies that it could be of any type!"))))($core$SPCore$Nil))
                              : (($sp$Compiler$TypeCheck$andThen)((($actualType) => {
                                return (($sp$Compiler$TypeCheck$andThen)((() => {
                                  return ($sp$Compiler$TypeCheck$return)(null);
                                })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_IsLambda))($expectedType))($actualType));
                              })))((($sp$Compiler$TypeCheck$fromExpression)($env))($expression)));
                          }))()
                          : (true
                            ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("This is a function, but the annotation says it should be a: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))($core$SPCore$Nil)))
                            : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 866:12', (sp_toHuman)($$try5)))))));
                }))()
                : ((($expression)[0] === "Call")
                  ? ((() => {
                    const $pos = ($expression)[1];
                    const $reference = ($expression)[2];
                    const $argument = ($expression)[3];
                    return (($sp$Compiler$TypeCheck$andThen)((($referenceType_) => {
                      const $referenceType = ($sp$Compiler$TypeCheck$expandAlias)($referenceType_);
                      return ((($referenceType)[0] === "TypeFunction")
                        ? ((() => {
                          const $parameterType = ($referenceType)[2];
                          const $isMutable = ($referenceType)[3];
                          const $returnType = ($referenceType)[4];
                          return ((($argument)[0] === "ArgumentExpression")
                            ? ((() => {
                              const $argumentExpression = ($argument)[1];
                              return (($sp$Compiler$TypeCheck$andThen)((($argumentType) => {
                                const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
                                  argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
                                  reference: $pos,
                                }));
                                return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                                  return (($sp$Compiler$TypeCheck$andThen)((($actualReturnType) => {
                                    return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($actualReturnType);
                                  })))(($sp$Compiler$TypeCheck$applySubsToType)($returnType));
                                })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($argumentType))($parameterType));
                              })))((($sp$Compiler$TypeCheck$fromExpression)($env))($argumentExpression));
                            }))()
                            : ((($argument)[0] === "ArgumentMutable")
                              ? ((() => {
                                const $pos = ($argument)[1];
                                const $attrPath = ($argument)[2].attrPath;
                                const $ref = ($argument)[2].ref;
                                const $$try4 = (($corelib$Dict$get)($ref))($env.instanceVariables);
                                return ((($$try4)[0] === "Nothing")
                                  ? (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                                    return ($sp$Compiler$TypeCheck$return)(null);
                                  })))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref))
                                  : ((($$try4)[0] === "Just")
                                    ? ((() => {
                                      const $var = ($$try4)[1];
                                      return (($corelib$Basics$not)($var.isMutable)
                                        ? ((() => {
                                          const $ae = (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("You are trying to mutate variable `" + ((sp_toHuman)($ref) + "` but it was declared as not mutable!"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("TODO [link to wiki page that explains how to declare variables]"))($core$SPCore$Nil))));
                                          return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                                            return ($sp$Compiler$TypeCheck$return)(null);
                                          })))($ae);
                                        }))()
                                        : (($sp$Compiler$TypeCheck$typeContainsFunctions)($var.ty)
                                          ? (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                                            return ($sp$Compiler$TypeCheck$return)(null);
                                          })))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("mutable arguments can't allow functions"))($core$SPCore$Nil)))
                                          : (($sp$Compiler$TypeCheck$andThen)((($ty) => {
                                            const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
                                              argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
                                              reference: $pos,
                                            }));
                                            return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => {
                                              return (($sp$Compiler$TypeCheck$andThen)((($actualReturnType) => {
                                                return (((($sp$Compiler$TypeCheck$isCompatibleWith)($env))($expectedType))($pos))($actualReturnType);
                                              })))(($sp$Compiler$TypeCheck$applySubsToType)($returnType));
                                            })))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($ty))($parameterType));
                                          })))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($var.ty))));
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 946:28', (sp_toHuman)($$try4))));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 916:20', (sp_toHuman)($argument))));
                        }))()
                        : (true
                          ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("The code is trying to call this as if it was a function, but its type is: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil)))
                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 913:12', (sp_toHuman)($referenceType))));
                    })))((($sp$Compiler$TypeCheck$fromExpression)($env))($reference));
                  }))()
                  : ((($expression)[0] === "If")
                    ? ((() => {
                      const $pos = ($expression)[1];
                      const $condition = ($expression)[2].condition;
                      const $false = ($expression)[2].false;
                      const $true = ($expression)[2].true;
                      return (($sp$Compiler$TypeCheck$andThen)((() => {
                        return (($sp$Compiler$TypeCheck$andThen)((() => {
                          return ((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedType))($false);
                        })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedType))($true));
                      })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($sp$Compiler$CoreTypes$bool))($condition));
                    }))()
                    : ((($expression)[0] === "Try")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $value = ($expression)[2];
                        const $patternsAndBlocks = ($expression)[3];
                        return (($sp$Compiler$TypeCheck$andThen)((($inferredValueType) => {
                          const $xxx = ((($sp$Compiler$TypeCheck$list_for)($patternsAndBlocks))((($$block) => {
                            const $pattern = $$block.first;
                            const $block = $$block.second;
                            return (($patternTypeSoFar) => {
                              return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
                                return (($sp$Compiler$TypeCheck$andThen)((($unifiedPatternType) => {
                                  return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
                                    return (($sp$Compiler$TypeCheck$andThen)((($subs) => {
                                      const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
                                        isMutable: false,
                                        isParameter: false,
                                        isRoot: false,
                                        subs: $subs,
                                      })))($patternOut.vars))($env1);
                                      return (($sp$Compiler$TypeCheck$andThen)((($patternEnv) => {
                                        return (($sp$Compiler$TypeCheck$andThen)((() => {
                                          return ($sp$Compiler$TypeCheck$return)($unifiedPatternType);
                                        })))(((($sp$Compiler$TypeCheck$checkExpression)($patternEnv))($expectedType))($block));
                                      })))($ip);
                                    })))(($sp$Compiler$TypeCheck$get)((($x) => {
                                      return $x.substitutions;
                                    })));
                                  })))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env));
                                })))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_TryPattern))($patternOut.ty))($patternTypeSoFar));
                              })))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
                            });
                          })))($inferredValueType);
                          return (($sp$Compiler$TypeCheck$andThen)((() => {
                            return ($sp$Compiler$TypeCheck$return)(null);
                          })))($xxx);
                        })))((($sp$Compiler$TypeCheck$fromExpression)($env))($value));
                      }))()
                      : ((($expression)[0] === "Record")
                        ? ((() => {
                          const $pos = ($expression)[1];
                          const $maybeExtending = ($expression)[2];
                          const $attrValueByName = ($expression)[3];
                          return (((($expectedType)[0] === "TypeRecord") && ((($expectedType)[2])[0] === "Just"))
                            ? ((() => {
                              const $attrTypeByName = ($expectedType)[3];
                              return (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("Extensible record annotation is experimentally disabled [TODO link to why]"))($core$SPCore$Nil));
                            }))()
                            : (((($expectedType)[0] === "TypeRecord") && ((($expectedType)[2])[0] === "Nothing"))
                              ? ((() => {
                                const $attrTypeByName = ($expectedType)[3];
                                return ((($maybeExtending)[0] === "Nothing")
                                  ? ((() => {
                                    const $xxx = ((($sp$Compiler$TypeCheck$dict_for)($attrValueByName))((($attrName) => {
                                      return (($attrValue) => {
                                        return (() => {
                                          const $$try3 = (($corelib$Dict$get)($attrName))($attrTypeByName);
                                          return ((($$try3)[0] === "Nothing")
                                            ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record has an attribute `" + ($attrName + "` which is not in the annotation."))))($core$SPCore$Nil))
                                            : ((($$try3)[0] === "Just")
                                              ? ((() => {
                                                const $expectedAttrType = ($$try3)[1];
                                                return ((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedAttrType))($attrValue);
                                              }))()
                                              : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1039:36', (sp_toHuman)($$try3))));
                                        });
                                      });
                                    })))(null);
                                    return (($sp$Compiler$TypeCheck$andThen)((() => {
                                      return ((($sp$Compiler$TypeCheck$dict_for)($attrTypeByName))((($attrName) => {
                                        return (($attrType) => {
                                          return (() => {
                                            const $$try2 = (($corelib$Dict$get)($attrName))($attrTypeByName);
                                            return ((($$try2)[0] === "Nothing")
                                              ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record is missing the attribute `" + ($attrName + "`"))))($core$SPCore$Nil))
                                              : ((($$try2)[0] === "Just")
                                                ? ($sp$Compiler$TypeCheck$return)(null)
                                                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1051:36', (sp_toHuman)($$try2))));
                                          });
                                        });
                                      })))(null);
                                    })))($xxx);
                                  }))()
                                  : ((($maybeExtending)[0] === "Just")
                                    ? ((() => {
                                      const $extending = ($maybeExtending)[1];
                                      return (($sp$Compiler$TypeCheck$andThen)((() => {
                                        return ((($sp$Compiler$TypeCheck$dict_for)($attrValueByName))((($attrName) => {
                                          return (($attrValue) => {
                                            return (() => {
                                              const $$try1 = (($corelib$Dict$get)($attrName))($attrTypeByName);
                                              return ((($$try1)[0] === "Nothing")
                                                ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)(("This record has an attribute `" + ($attrName + "` which is not in the annotation"))))($core$SPCore$Nil))
                                                : ((($$try1)[0] === "Just")
                                                  ? ((() => {
                                                    const $expectedAttrType = ($$try1)[1];
                                                    return ((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedAttrType))($attrValue);
                                                  }))()
                                                  : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1067:32', (sp_toHuman)($$try1))));
                                            });
                                          });
                                        })))(null);
                                      })))(((($sp$Compiler$TypeCheck$checkExpression)($env))($expectedType))((($sp$Types$CanonicalAst$Variable)($pos))($extending)));
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1035:20', (sp_toHuman)($maybeExtending))));
                              }))()
                              : (true
                                ? (($sp$Compiler$TypeCheck$addCheckError)($pos))((($core$SPCore$Cons)("This is a record, but the annotation says that this should be a"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($expectedType)))($core$SPCore$Nil)))
                                : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1028:12', (sp_toHuman)($expectedType)))));
                        }))()
                        : ((($expression)[0] === "LetIn")
                          ? ((() => {
                            const $valueDef = ($expression)[1];
                            const $e = ($expression)[2];
                            return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
                              const $xxx = (($valueDef.mutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($expectedType))
                                ? (($sp$Compiler$TypeCheck$addCheckError)(($sp$Types$CanonicalAst$patternPos)($valueDef.pattern)))((($core$SPCore$Cons)("blocks that define mutables can't return functions"))($core$SPCore$Nil))
                                : ($sp$Compiler$TypeCheck$return)(null));
                              return (($sp$Compiler$TypeCheck$andThen)((() => {
                                return ((($sp$Compiler$TypeCheck$checkExpression)($env1))($expectedType))($e);
                              })))($xxx);
                            })))(((($sp$Compiler$TypeCheck$fromDefinition)(false))($valueDef))($env));
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 825:4', (sp_toHuman)($expression))))))))))));
    });
  });
});

const $sp$Compiler$TypeCheck$initState = ({
  errors: $core$SPCore$Nil,
  nextName: 0,
  nonFnTyvars: $corelib$Dict$empty,
  substitutions: $corelib$Dict$empty,
  typeClashesByPlaceholderId: $corelib$Maybe$Nothing,
});

const $sp$StateMonad$run = (($state) => {
  return (($m) => {
    return ($m)($state);
  });
});

const $sp$Compiler$TypeCheck$fromModule = (($env) => {
  return (($module) => {
    (sp_benchStart)(null);
    const $insert = (($pa) => {
      return (($def) => {
        return (($$ann) => {
          const $ann = $$ann.first;
          const $nonAnn = $$ann.second;
          const $allAnnotated = (($corelib$List$all)((($$maybeType) => {
            const $pos = $$maybeType.first;
            const $maybeType = $$maybeType.second;
            return ((sp_not_equal)($corelib$Maybe$Nothing))($maybeType);
          })))(($corelib$Dict$values)(($sp$Types$CanonicalAst$patternNamedTypes)($pa)));
          return ($allAnnotated
            ? ({
              first: ((sp_cons)($ann))($def),
              second: $nonAnn,
            })
            : ({
              first: $ann,
              second: ((sp_cons)($nonAnn))($def),
            }));
        });
      });
    });
    const $$annotated = ((($corelib$Dict$for)($module.valueDefs))($insert))(({
      first: $core$SPCore$Nil,
      second: $core$SPCore$Nil,
    }));
    const $nonAnnotated = $$annotated.second;
    const $annotated = $$annotated.first;
    return (((($nonAnnotated)[0] === "Cons") && ((($nonAnnotated)[2])[0] === "Cons"))
      ? ((() => {
        const $first = ($nonAnnotated)[1];
        const $second = (($nonAnnotated)[2])[1];
        const $tail = (($nonAnnotated)[2])[2];
        const $pos = ($sp$Types$CanonicalAst$patternPos)($first.pattern);
        const $names = (($corelib$List$concatMap)((($d) => {
          return ($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNamedTypes)($d.pattern));
        })))($nonAnnotated);
        return (($sp$Compiler$Error$res)(($sp$Types$CanonicalAst$patternPos)($first.pattern)))((($eenv) => {
          return ((($corelib$Basics$btw)(sp_benchStop))("type check"))((($core$SPCore$Cons)("Support for non-annotated root definitions is not yet implemented. =*("))((($core$SPCore$Cons)(("These definitions need an annotation: " + (($corelib$Text$join)(", "))($names))))($core$SPCore$Nil)));
        }));
      }))()
      : (true
        ? ((() => {
          const $orderedNonAnnotated = $nonAnnotated;
          const $allOrdered = ($corelib$List$concat)((($core$SPCore$Cons)($orderedNonAnnotated))((($core$SPCore$Cons)($annotated))($core$SPCore$Nil)));
          const $$envF = (($sp$StateMonad$run)($sp$Compiler$TypeCheck$initState))(((($sp$Compiler$TypeCheck$list_for)($allOrdered))(($sp$Compiler$TypeCheck$fromDefinition)(true)))($env));
          const $stateF = $$envF.second;
          const $envF = $$envF.first;
          return (((sp_equal)($core$SPCore$Nil))($stateF.errors)
            ? ((($corelib$Basics$btw)(sp_benchStop))("type check"))(($corelib$Result$Ok)($envF))
            : ((($corelib$Basics$btw)(sp_benchStop))("type check"))(($corelib$Result$Err)(($sp$Compiler$Error$Nested)($stateF.errors))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 386:4', (sp_toHuman)($nonAnnotated))));
  });
});

const $sp$Compiler$TypeCheck$splitName = (($s) => {
  const $$try1 = ((text_split)("."))($s);
  return (((($$try1)[0] === "Cons") && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil")))
    ? ((() => {
      const $moduleName = ($$try1)[1];
      const $valueName = (($$try1)[2])[1];
      return ({
        first: ($corelib$Maybe$Just)($moduleName),
        second: $valueName,
      });
    }))()
    : (true
      ? ({
        first: $corelib$Maybe$Nothing,
        second: $s,
      })
      : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 2286:4', (sp_toHuman)($$try1))));
});

const $sp$Compiler$TypeCheck_Test$outToHuman = (($out) => {
  const $freeVars = $out.freeTypeVariables;
  const $nf = (($corelib$Text$join)(", "))(($corelib$Dict$keys)((($corelib$Dict$filter)((($k) => {
    return (($v) => {
      return $v.nonFn;
    });
  })))($freeVars)));
  return (($corelib$Text$join)("\n"))((($core$SPCore$Cons)(("  freeTypeVariables = [ " + ((($corelib$Text$join)(", "))(($corelib$Dict$keys)($freeVars)) + " ]"))))((($core$SPCore$Cons)(("  (NonFunction = [" + ($nf + "])"))))((($core$SPCore$Cons)(("  isMutable = " + (sp_toHuman)($out.isMutable))))((($core$SPCore$Cons)(("  ty = " + ((($sp$Human$CanonicalAst$typeToText)($sp$Compiler$TestHelpers$moduleUmr))($sp$Compiler$TestHelpers$meta))($out.ty))))((($core$SPCore$Cons)(("  pos = " + (sp_toHuman)($out.ty))))($core$SPCore$Nil))))));
});

const $sp$Compiler$TypeCheck_Test$codeTest = ($sp$Test$codeTest)($sp$Compiler$TypeCheck_Test$outToHuman);

const $sp$Compiler$TypeCheck_Test$forall = (($vars) => {
  return ((($corelib$List$for)($vars))((($n) => {
    return (($corelib$Dict$insert)($n))(({
      nonFn: false,
    }));
  })))($corelib$Dict$empty);
});

const $sp$Compiler$TypeCheck_Test$ftv = (($n) => {
  return (($corelib$Dict$singleton)($n))(({
    nonFn: false,
  }));
});

const $sp$Compiler$TypeCheck_Test$function = (($from) => {
  return (($to) => {
    return (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$T))($from))(false))($to);
  });
});

const $sp$Compiler$TypeCheck_Test$tyNone = $sp$Compiler$TestHelpers$noneType;

const $sp$Compiler$TypeCheck_Test$tyNumber = $sp$Compiler$TestHelpers$numberType;

const $sp$Compiler$TypeCheck_Test$typeFunction = ($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$T);

const $sp$Human$CanonicalAst$initNstate = ({
  next: 0,
  replacements: $corelib$Dict$empty,
});

const $sp$Human$CanonicalAst$andThen = $sp$StateMonad$andThen;

const $sp$Human$CanonicalAst$get = $sp$StateMonad$get;

const $sp$Human$CanonicalAst$intToName = (($n) => {
  return (($acc) => {
    return ((0 === $n)
      ? "a"
      : ((1 === $n)
        ? "b"
        : ((2 === $n)
          ? "c"
          : ((3 === $n)
            ? "d"
            : ((4 === $n)
              ? "e"
              : ((5 === $n)
                ? "f"
                : (true
                  ? (sp_todo)("intToName")
                  : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 163:4', (sp_toHuman)($n)))))))));
  });
});

const $sp$Human$CanonicalAst$newName = (($state) => {
  return ({
    first: (($sp$Human$CanonicalAst$intToName)($state.next))($core$SPCore$Nil),
    second: (Object.assign)({}, $state, ({
      next: ($state.next + 1),
    })),
  });
});

const $sp$Human$CanonicalAst$return = $sp$StateMonad$return;

const $sp$Human$CanonicalAst$normName = (($name) => {
  return ((((text_length)($name) > 1) && ((sp_equal)($corelib$Maybe$Nothing))((text_toNumber)($name)))
    ? ($sp$Human$CanonicalAst$return)($name)
    : (($sp$Human$CanonicalAst$andThen)((($n2l) => {
      const $$try1 = (($corelib$Dict$get)($name))($n2l);
      return ((($$try1)[0] === "Just")
        ? ((() => {
          const $replacement = ($$try1)[1];
          return ($sp$Human$CanonicalAst$return)($replacement);
        }))()
        : ((($$try1)[0] === "Nothing")
          ? (($sp$Human$CanonicalAst$andThen)((($n) => {
            const $addReplacement = (($s) => {
              return (Object.assign)({}, $s, ({
                replacements: ((($corelib$Dict$insert)($name))($n))($s.replacements),
              }));
            });
            return (($sp$Human$CanonicalAst$andThen)((() => {
              return ($sp$Human$CanonicalAst$return)($n);
            })))(($sp$StateMonad$update)($addReplacement));
          })))($sp$Human$CanonicalAst$newName)
          : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 274:8', (sp_toHuman)($$try1))));
    })))(($sp$Human$CanonicalAst$get)((($x) => {
      return $x.replacements;
    }))));
});

const $sp$StateMonad$list_map = (($f) => {
  return (($la) => {
    const $apply = (($a) => {
      return (($accum) => {
        return (($sp$StateMonad$andThen)((($b) => {
          return ($sp$StateMonad$return)(((sp_cons)($accum))($b));
        })))(($f)($a));
      });
    });
    return (($sp$StateMonad$andThen)((($x) => {
      return ($sp$StateMonad$return)(($corelib$List$reverse)($x));
    })))(((($sp$StateMonad$list_foldl)($apply))($la))($core$SPCore$Nil));
  });
});

const $sp$StateMonad$maybe_map = (($f) => {
  return (($ma) => {
    return ((($ma)[0] === "Nothing")
      ? ($sp$StateMonad$return)($corelib$Maybe$Nothing)
      : ((($ma)[0] === "Just")
        ? ((() => {
          const $a = ($ma)[1];
          return (($sp$StateMonad$andThen)((($b) => {
            return ($sp$StateMonad$return)(($corelib$Maybe$Just)($b));
          })))(($f)($a));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/StateMonad.sp 66:4', (sp_toHuman)($ma))));
  });
});

const $sp$Human$CanonicalAst$normType = (($ty) => {
  return ((($ty)[0] === "TypeConstant")
    ? ((() => {
      const $pos = ($ty)[1];
      const $name = ($ty)[2];
      const $args = ($ty)[3];
      return (($sp$Human$CanonicalAst$andThen)((($args_n) => {
        return ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($name))($args_n));
      })))((($sp$StateMonad$list_map)($sp$Human$CanonicalAst$normType))($args));
    }))()
    : ((($ty)[0] === "TypeVariable")
      ? ((() => {
        const $pos = ($ty)[1];
        const $name = ($ty)[2];
        return (($sp$Human$CanonicalAst$andThen)((($n) => {
          return ($sp$Human$CanonicalAst$return)((($sp$Types$CanonicalAst$TypeVariable)($pos))($n));
        })))(($sp$Human$CanonicalAst$normName)($name));
      }))()
      : ((($ty)[0] === "TypeFunction")
        ? ((() => {
          const $pos = ($ty)[1];
          const $from0 = ($ty)[2];
          const $fromIsMut = ($ty)[3];
          const $to0 = ($ty)[4];
          return (($sp$Human$CanonicalAst$andThen)((($from1) => {
            return (($sp$Human$CanonicalAst$andThen)((($to1) => {
              return ($sp$Human$CanonicalAst$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($from1))($fromIsMut))($to1));
            })))(($sp$Human$CanonicalAst$normType)($to0));
          })))(($sp$Human$CanonicalAst$normType)($from0));
        }))()
        : ((($ty)[0] === "TypeRecord")
          ? ((() => {
            const $pos = ($ty)[1];
            const $ext0 = ($ty)[2];
            const $attrs0 = ($ty)[3];
            return (($sp$Human$CanonicalAst$andThen)((($ext1) => {
              return (($sp$Human$CanonicalAst$andThen)((($attrs1) => {
                return ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($ext1))($attrs1));
              })))((($sp$StateMonad$dict_map)((($k) => {
                return $sp$Human$CanonicalAst$normType;
              })))($attrs0));
            })))((($sp$StateMonad$maybe_map)($sp$Human$CanonicalAst$normName))($ext0));
          }))()
          : ((($ty)[0] === "TypeAlias")
            ? ((() => {
              const $pos = ($ty)[1];
              const $path = ($ty)[2];
              const $t = ($ty)[3];
              return (($sp$Human$CanonicalAst$andThen)((($t1) => {
                return ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeAlias)($pos))($path))($t1));
              })))(($sp$Human$CanonicalAst$normType)($t));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 242:4', (sp_toHuman)($ty)))))));
});

const $sp$Human$CanonicalAst$normalizeTypeAndTyvars = (($tyOld) => {
  return (($tyvarsOld) => {
    const $$state = (($sp$StateMonad$run)($sp$Human$CanonicalAst$initNstate))(($sp$Human$CanonicalAst$normType)($tyOld));
    const $state = $$state.second;
    const $tyNew = $$state.first;
    const $replace = (($name) => {
      return ($corelib$Dict$insert)((($corelib$Maybe$withDefault)($name))((($corelib$Dict$get)($name))($state.replacements)));
    });
    const $tyvarsNew = ((($corelib$Dict$for)($tyvarsOld))($replace))($corelib$Dict$empty);
    return ({
      first: $tyNew,
      second: $tyvarsNew,
    });
  });
});

const $sp$Compiler$TypeCheck_Test$infer = (($name) => {
  return (($code) => {
    const $tcEnvResult = ((() => {
      const $params = ({
        meta: $sp$Compiler$TestHelpers$meta,
        name: $sp$Compiler$TestHelpers$moduleName,
        source: $sp$Compiler$TestHelpers$source,
        stripLocations: true,
      });
      return (($corelib$Result$onOk)((($module) => {
        const $modules = ((($corelib$Dict$insert)($sp$Compiler$TestHelpers$moduleUmr))($module))($sp$Prelude$coreModulesByUmr);
        return (($corelib$Result$onOk)((($expandedTypes) => {
          const $$constructors = $expandedTypes;
          const $types = $$constructors.types;
          const $instanceVariables = $$constructors.instanceVariables;
          const $constructors = $$constructors.constructors;
          const $env = ({
            constructors: $constructors,
            currentModule: $sp$Compiler$TestHelpers$moduleUmr,
            instanceVariables: (($corelib$Dict$mapKeys)($sp$Types$CanonicalAst$RefRoot))(((($corelib$Dict$insert)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))("reset")))(({
              definedAt: $sp$Types$Pos$T,
              freeTypeVariables: $corelib$Dict$empty,
              isMutable: false,
              ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$TypeCheck_Test$tyNumber))(true))($sp$Compiler$TypeCheck_Test$tyNone),
            })))(((($corelib$Dict$insert)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))("add")))(({
              definedAt: $sp$Types$Pos$T,
              freeTypeVariables: $corelib$Dict$empty,
              isMutable: false,
              ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))((($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber)),
            })))($instanceVariables))),
            meta: $sp$Compiler$TestHelpers$meta,
            nonAnnotatedRecursives: $corelib$Dict$empty,
            nonFreeTyvars: $corelib$Dict$empty,
            types: $types,
          });
          return (($sp$Compiler$TypeCheck$fromModule)($env))($module);
        })))(($sp$Compiler$Pipeline$globalExpandedTypes)($modules));
      })))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($params))($code));
    }))();
    return (($corelib$Result$onOk)((($tcEnv) => {
      const $$try1 = (($corelib$Dict$get)(($sp$Compiler$TestHelpers$rootLocal)($name)))($tcEnv.instanceVariables);
      return ((($$try1)[0] === "Nothing")
        ? ($corelib$Result$Err)("dict fail")
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $var = ($$try1)[1];
            const $$ty = (($sp$Human$CanonicalAst$normalizeTypeAndTyvars)($var.ty))($var.freeTypeVariables);
            const $tyvars = $$ty.second;
            const $ty = $$ty.first;
            return ($corelib$Result$Ok)(({
              freeTypeVariables: $var.freeTypeVariables,
              isMutable: $var.isMutable,
              ty: $ty,
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck_Test.sp 151:4', (sp_toHuman)($$try1))));
    })))((($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))($tcEnvResult));
  });
});

const $sp$Compiler$TypeCheck_Test$typeVariable = ($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$T);

const $sp$Compiler$TypeCheck_Test$functions = (($sp$Test$Group)("functions"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Known function with correct params"))("a = add 3 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$TypeCheck_Test$tyNumber,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Known function with wrong params"))("a = add False"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Function inference 1"))("a = x: add x 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Function inference 2: same as 1, but with swapped args"))("a = x: add 1 x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] fn has type None"))("a = x: 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("1"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$TypeCheck_Test$typeVariable)("a")))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Multiple arguments are correctly inferred"))("a = x: y: z: x + y + z"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Annotation should be consistent with mutability"))("f as Number @: Number = a:\n  a"))(($sp$Compiler$TypeCheck_Test$infer)("f")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability"))($core$SPCore$Nil)))))($core$SPCore$Nil))))))));

const $sp$Compiler$TypeCheck_Test$higherOrderTypes = (($sp$Test$Group)("higher order types"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Parse precedence"))("union T a = T a\n\na as T a: T a =\n    l: l"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("0a"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("T")))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))($core$SPCore$Nil))))(false))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("T")))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))($core$SPCore$Nil))),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Union type constructors"))("union X a = L\nl = L"))(($sp$Compiler$TypeCheck_Test$infer)("l")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("1"),
  isMutable: false,
  ty: ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("X")))((($core$SPCore$Cons)((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a")))($core$SPCore$Nil)),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP [reg] type check mistakes a union type with free tyvars for a free tyvar?"))("union O r e o = O r e o\n\nrun as (r: O r e o): r: O r e o = rToOreo: r:\n    rToOreo r"))(($sp$Compiler$TypeCheck_Test$infer)("run")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Wrong should be Text"))("union O o = O Text o\n\nfun as Number: Text: O wrong = _: a:\n    O a a"))(($sp$Compiler$TypeCheck_Test$infer)("fun")))(($sp$Test$errorContains)((($core$SPCore$Cons)("wrong"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP [reg] Should complain about undefined type argument"))("union O a = O Text output\nx = 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("undefined"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$TypeCheck_Test$if_else = (($sp$Test$Group)("if..else"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("basic functionality"))("x = q:\n  if q then 1\n  else 2"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$CoreTypes$bool))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-bool conditions"))("x = q:\n  if 1 then 1\n  else 2"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks"))("x = q:\n  if q then 2\n  else False"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Number"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$TypeCheck_Test$mu = (($sp$Test$Group)("mutability"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks that define mutables can't return functions"))("a =\n  x @= 1\n  y: y"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("can't return functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks that define mutables can't return functions (with annotation)"))("a as y: y =\n  x @= 1\n  y: y"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("can't return functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Immutable variables can't be used as mutable"))("a = x:\n  @x := 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Detect mismatching annotations"))("a as Number: None =\n  reset"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utability"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Correctly unify annotation's mutability"))("a as Number @: None =\n  reset"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$TypeCheck_Test$tyNumber))(true))($sp$Compiler$TypeCheck_Test$tyNone),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 1"))("a @= x: x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 2"))("a = f@:\n    @f := (x: x)"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable args cannot be functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 3"))("a = f@:\n  f 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable args cannot be functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Lambda argument mutability is correctly inferred"))("a = x: reset x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("*Nested* lambda argument mutability is correctly inferred"))("a = x: (y: reset y) x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable (annotation)"))("a as Number: Number @=\n  add 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Mutables can contain functions via free tyvars"))("a = x:\n  s @= x\n  s\n\nz as x: x =\n  a (x: x)"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Mutable assignment as last stament yields None"))("a as None =\n    x @= 1\n    @x := 2"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))($core$SPCore$Nil))))))))))))));

const $sp$Compiler$TypeCheck_Test$nonFunction = (($sp$Test$Group)("NonFunction"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Basic functionality"))("blah as List a: List a =\n  with a NonFunction\n  a:\n  a\n\nmeh =\n  blah [x: x]"))(($sp$Compiler$TypeCheck_Test$infer)("meh")))(($sp$Test$errorContains)((($core$SPCore$Cons)("should not contain functions"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$TypeCheck_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("List unpacking"))("x = q:\n   [ first, second ] = q\n   first"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("2"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$CoreTypes$list)((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a"))))(false))((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Records are correctly unpacked"))("x = q:\n    { first } = q\n    first"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))($core$SPCore$Nil)),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: "first",
    second: ($sp$Compiler$TypeCheck_Test$typeVariable)("a"),
  })))($core$SPCore$Nil)))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Constructors should instantiate their variable types"))("each as [a]: (a: b): None =\n    ls: f:\n    try ls as\n        SPCore.Nil:\n            None\n\nresult =\n      1 :: SPCore.Nil = SPCore.Nil"))(($sp$Compiler$TypeCheck_Test$infer)("result")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Trying to check against an inferred value?"))("tuple as Text & Number =\n    \"\" & 1\n\nx =\n    (a as Text) & (b as Number) =\n        tuple"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))($core$SPCore$Nil)))));

const $sp$Compiler$TypeCheck_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Attribute access"))("a = b: b.meh.blah"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("4"))((($core$SPCore$Cons)("5"))($core$SPCore$Nil)))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("meh"))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("b")))((($corelib$Dict$singleton)("blah"))(($sp$Compiler$TypeCheck_Test$typeVariable)("c")))))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("c")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Attribute mutation"))("a = b@: @b.meh.blah += 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("4"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("meh"))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("b")))((($corelib$Dict$singleton)("blah"))($sp$Compiler$CoreTypes$number))))))(true))($sp$Compiler$CoreTypes$none),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Tuple3 direct item mutability"))("x =\n    a @= 3 & False & 2\n\n    @a.third += 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Tuple2 direct item mutability, annotated"))("x = y:\n   a as Number & Number @=\n     1 & 2\n\n   @a.first += 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("functional update"))("a = b: { b with x = 1 }"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))($core$SPCore$Nil)),
    isMutable: false,
    ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($re))(false))($re),
  });
}))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("x"))($sp$Compiler$CoreTypes$number)))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP instantiate and refine inferred records"))("a = t: { t with x = 1 }\nc = a"))(($sp$Compiler$TypeCheck_Test$infer)("c")))(($sp$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)),
    isMutable: false,
    ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($re))(false))($re),
  });
}))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("x"))($sp$Compiler$CoreTypes$number)))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] excessive forallness in records"))("x = q:\n a = q.first\n a"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("3"))((($core$SPCore$Cons)("4"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: "first",
    second: ($sp$Compiler$TypeCheck_Test$typeVariable)("b"),
  })))($core$SPCore$Nil)))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("b")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] refineType when the record has a non-extensible alias"))("alias A = { c as Number, d as Number }\n\nupd as A: A = a:\n  { a with c = .c + 1 }"))(($sp$Compiler$TypeCheck_Test$infer)("upd")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] infinite recursion on addSubstitution/unify_"))("alias B = { l as [Text] }\n\nreadOne as B: (Text & B) = b:\n    try b.l as\n        []: \"\" & b\n        h :: t: h & { b with l = t }"))(($sp$Compiler$TypeCheck_Test$infer)("readOne")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] unifyToNonExtensibleRecord correctly substitutes the record extension"))("alias R = { x as Number, y as Number }\n\nrec as R: R =\n    s:\n        if True then\n            { s with y = .y }\n        else\n            rec { s with y = .y }"))(($sp$Compiler$TypeCheck_Test$infer)("rec")))($sp$Test$isOk)))($core$SPCore$Nil)))))))))));

const $sp$Compiler$TypeCheck_Test$statements = (($sp$Test$Group)("statements"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks should return the last statement's type"))("a =\n  3\n  False"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$CoreTypes$bool,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Definition statement return type None"))("a =\n  f = x: 3"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$CoreTypes$none,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Definition statement with annotation return type None"))("a as None =\n  f = 3"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Local values can't shadow root values"))("a = 1\nb as Number =\n    a = 1\n    a"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("already"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Prevent local redeclarations"))("b =\n  a = 1\n  a = 1"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("declar"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Prevent root redeclarations"))("a = 1\na = 1"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("declar"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Annotated declarations are actually typechecked"))("x as None =\n    q = 1 + \"\""))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)($core$SPCore$Nil))))($core$SPCore$Nil))))))));

const $sp$Compiler$TypeCheck_Test$try_as = (($sp$Test$Group)("try..as"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("basic functionality"))("x = q:\n    try q as\n        True: 2\n        _: 3"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$CoreTypes$bool))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching patterns"))("x = q:\n    try q as\n        True: 2\n        []: 3"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("List"))((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks"))("x = q:\n try q as\n   True: 2\n   False: False"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Number"))((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] actually infers blocks"))("x as Number =\n  try \"\" as\n    \"\": y"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("y"))($core$SPCore$Nil)))))($core$SPCore$Nil)))));

const $sp$Compiler$TypeCheck_Test$variableTypes = (($sp$Test$Group)("Variable types"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Identity"))("id as a: a =\n  a: a"))(($sp$Compiler$TypeCheck_Test$infer)("id")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("0a"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Annotated vars are instantiated when referenced"))("q as [item] =\n  SPCore.Nil\n\nr as [Text] =\n      q"))(($sp$Compiler$TypeCheck_Test$infer)("r")))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$TypeCheck_Test$tests = (($sp$Test$Group)("TypeCheck"))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$functions))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$statements))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$variableTypes))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$mu))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$higherOrderTypes))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$records))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$try_as))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$if_else))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$nonFunction))($core$SPCore$Nil)))))))))));

const $sp$Human$CanonicalAst$normalizeType = (($t) => {
  return ($corelib$Tuple$first)((($sp$StateMonad$run)($sp$Human$CanonicalAst$initNstate))(($sp$Human$CanonicalAst$normType)($t)));
});

const $sp$RefHierarchy_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $sp$RefHierarchy_Test$canonicalJsTest = ((($sp$RefHierarchy_Test$valueTest)("[reg] THIS SHOULD BE IN CANONICALTOJS"))((() => {
  return ((basics_compare)(null))(null);
})))(($sp$Test$isOkAndEqualTo)(0));

const $sp$RefHierarchy_Test$graph1 = ((() => {
  const $x = (($k) => {
    return (($l) => {
      return ({
        first: $k,
        second: ({
          first: $k,
          second: ($corelib$Set$fromList)($l),
        }),
      });
    });
  });
  return ($corelib$Dict$fromList)((($core$SPCore$Cons)((($x)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("b"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("e"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("c"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("d"))($core$SPCore$Nil)))((($core$SPCore$Cons)((($x)("e"))($core$SPCore$Nil)))($core$SPCore$Nil))))));
}))();

const $sp$RefHierarchy_Test$graph2 = ((() => {
  const $x = (($k) => {
    return (($l) => {
      return ({
        first: $k,
        second: ({
          first: $k,
          second: ($corelib$Set$fromList)($l),
        }),
      });
    });
  });
  return ($corelib$Dict$fromList)((($core$SPCore$Cons)((($x)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("b"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("e"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("c"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("d"))((($core$SPCore$Cons)("b"))($core$SPCore$Nil))))((($core$SPCore$Cons)((($x)("e"))($core$SPCore$Nil)))($core$SPCore$Nil))))));
}))();

const $sp$RefHierarchy_Test$tests = (($sp$Test$Group)("RefHierarchy"))((($core$SPCore$Cons)($sp$RefHierarchy_Test$canonicalJsTest))((($core$SPCore$Cons)(((($sp$RefHierarchy_Test$valueTest)("Basic"))((() => {
  return (($sp$RefHierarchy$reorder)($corelib$Tuple$second))($sp$RefHierarchy_Test$graph1);
})))(($sp$Test$isOkAndEqualTo)(({
  first: $core$SPCore$Nil,
  second: (($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("a"))($core$SPCore$Nil))))),
})))))((($core$SPCore$Cons)(((($sp$RefHierarchy_Test$valueTest)("Circular"))((() => {
  return (($sp$RefHierarchy$reorder)($corelib$Tuple$second))($sp$RefHierarchy_Test$graph2);
})))(($sp$Test$isOkAndEqualTo)(({
  first: (($core$SPCore$Cons)((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)))))($core$SPCore$Nil),
  second: (($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("a"))($core$SPCore$Nil))))),
})))))($core$SPCore$Nil))));

const $sp$Main$allTests = (($core$SPCore$Cons)($sp$Compiler$Lexer_Test$tests))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$tests))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$tests))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$tests))((($core$SPCore$Cons)($corelib$Hash_Test$tests))((($core$SPCore$Cons)($corelib$Array_Test$tests))((($core$SPCore$Cons)($corelib$List_Test$tests))((($core$SPCore$Cons)($corelib$Dict_Test$tests))((($core$SPCore$Cons)($sp$RefHierarchy_Test$tests))($core$SPCore$Nil)))))))));

const $sp$Main$asModule = (($tuple) => {
  const $$isDirectory = $tuple;
  const $name = $$isDirectory.second;
  const $isDirectory = $$isDirectory.first;
  return (($isDirectory || ((sp_not_equal)($name))(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$"))($name)))
    ? $corelib$Maybe$Nothing
    : ($corelib$Maybe$Just)(((($corelib$Text$replace)(".sp"))(""))($name)));
});

const $sp$Main$asModuleDirectory = (($tuple) => {
  const $$isDirectory = $tuple;
  const $name = $$isDirectory.second;
  const $isDirectory = $$isDirectory.first;
  return (($isDirectory && ((sp_equal)($name))(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$"))($name)))
    ? ($corelib$Maybe$Just)($name)
    : $corelib$Maybe$Nothing);
});

const $sp$Main$color = (($code) => {
  return (($text) => {
    return ($code + ($text + "\x1b[0m"));
  });
});

const $sp$Main$blue = ($sp$Main$color)("\x1b[34m");

const $sp$Main$getTargetUsr = (($meta) => {
  return (($entryModule) => {
    return (($entryValue) => {
      return (($globals) => {
        const $asEntry = (($usr) => {
          const $$moduleName = $usr;
          const $valueName = ($$moduleName)[2];
          const $moduleName = (($$moduleName)[1])[2];
          const $source = (($$moduleName)[1])[1];
          return ((((sp_equal)($entryModule))($moduleName) && ((sp_equal)($entryValue))($valueName))
            ? ($corelib$Maybe$Just)($usr)
            : $corelib$Maybe$Nothing);
        });
        const $possibleTargets = (($corelib$List$filterMap)($asEntry))(($corelib$Dict$keys)($globals.instanceVariables));
        return ((($possibleTargets)[0] === "Nil")
          ? (sp_todo)(("Can't find build target `" + ($entryModule + ("." + ($entryValue + "` anywhere.")))))
          : (((($possibleTargets)[0] === "Cons") && ((($possibleTargets)[2])[0] === "Nil"))
            ? ((() => {
              const $usr = ($possibleTargets)[1];
              return ($corelib$Result$Ok)($usr);
            }))()
            : (true
              ? ((() => {
                const $many = $possibleTargets;
                const $x = (($corelib$Text$join)(", "))((($corelib$List$map)(sp_toHuman))($many));
                return (sp_todo)(("Multiple values match build target `" + ($entryModule + ("." + ($entryValue + ("`: " + $x))))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 305:4', (sp_toHuman)($possibleTargets)))));
      });
    });
  });
});

const $sp$Main$listSourceDir = (($sourceDirRoot) => {
  return (($modulePathWithTrailingSlash) => {
    const $path = ($sourceDirRoot + ("/" + $modulePathWithTrailingSlash));
    return (($platforms$posix$IO$onSuccess)((($dirContents) => {
      const $directChildren = (($corelib$List$map)((($fileName) => {
        return ($modulePathWithTrailingSlash + $fileName);
      })))((($corelib$List$filterMap)($sp$Main$asModule))($dirContents));
      const $getDescendants = (io_parallel)((($corelib$List$map)((($subDir) => {
        return (($sp$Main$listSourceDir)($sourceDirRoot))(($modulePathWithTrailingSlash + ($subDir + "/")));
      })))((($corelib$List$filterMap)($sp$Main$asModuleDirectory))($dirContents)));
      return (($platforms$posix$IO$onSuccess)((($descendants) => {
        return ($platforms$posix$IO$succeed)(($corelib$List$concat)((($core$SPCore$Cons)($directChildren))((($core$SPCore$Cons)(($corelib$List$concat)($descendants)))($core$SPCore$Nil))));
      })))($getDescendants);
    })))((io_readDir)($path));
  });
});

const $sp$Main$red = ($sp$Main$color)("\x1b[31m");

const $sp$Main$yellow = ($sp$Main$color)("\x1b[33m");

const $sp$Main$formattedToConsoleColoredText = (($formattedText) => {
  return ((($formattedText)[0] === "FormattedText_Default")
    ? ((() => {
      const $t = ($formattedText)[1];
      return $t;
    }))()
    : ((($formattedText)[0] === "FormattedText_Emphasys")
      ? ((() => {
        const $t = ($formattedText)[1];
        return ($sp$Main$yellow)($t);
      }))()
      : ((($formattedText)[0] === "FormattedText_Warning")
        ? ((() => {
          const $t = ($formattedText)[1];
          return ($sp$Main$red)($t);
        }))()
        : ((($formattedText)[0] === "FormattedText_Decoration")
          ? ((() => {
            const $t = ($formattedText)[1];
            return ($sp$Main$blue)($t);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 69:4', (sp_toHuman)($formattedText))))));
});

const $sp$Main$resToIo = (($errorEnv) => {
  return (($res) => {
    return ((($res)[0] === "Ok")
      ? ((() => {
        const $a = ($res)[1];
        return ($platforms$posix$IO$succeed)($a);
      }))()
      : ((($res)[0] === "Err")
        ? ((() => {
          const $e = ($res)[1];
          return ($platforms$posix$IO$fail)((($corelib$Text$join)(""))((($corelib$List$map)($sp$Main$formattedToConsoleColoredText))((($sp$Compiler$Error$toFormattedText)($errorEnv))($e))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 91:4', (sp_toHuman)($res))));
  });
});

const $sp$Main$loadModulesFile = ((() => {
  const $modulesFileName = "modules.sp";
  return (($platforms$posix$IO$onSuccess)((($modulesAsText) => {
    const $eenv = ({
      moduleByName: (($corelib$Dict$singleton)($modulesFileName))(({
        content: $modulesAsText,
        fsPath: $modulesFileName,
      })),
    });
    return (($sp$Main$resToIo)($eenv))((($sp$ModulesFile$textToModulesFile)($modulesFileName))($modulesAsText));
  })))((io_readFile)($modulesFileName));
}))();

const $sp$Main$updateSd = (($fileNames) => {
  const $insertModuleName = (($name) => {
    return (($sd) => {
      const $$try1 = (($corelib$List$find)((($m) => {
        return ((sp_equal)($name))($m.path);
      })))($sd.modules);
      return ((($$try1)[0] === "Just")
        ? $sd
        : ((($$try1)[0] === "Nothing")
          ? (Object.assign)({}, $sd, ({
            modules: ((sp_cons)($sd.modules))(({
              globalTypes: $core$SPCore$Nil,
              globalValues: $core$SPCore$Nil,
              path: $name,
              visibleAs: $name,
            })),
          }))
          : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 236:8', (sp_toHuman)($$try1))));
    });
  });
  return (($corelib$List$for)($fileNames))($insertModuleName);
});

const $sp$Main$loadMeta = (($env) => {
  return (($platforms$posix$IO$onSuccess)((($modulesFile) => {
    const $getAllSourceDirLists = (io_parallel)((($corelib$List$map)((($sd) => {
      return (($sp$Main$listSourceDir)($sd.path))("");
    })))($modulesFile.sourceDirs));
    return (($platforms$posix$IO$onSuccess)((($allSourceDirLists) => {
      const $updatedSourceDirs = ((($corelib$List$map2)($sp$Main$updateSd))($allSourceDirLists))($modulesFile.sourceDirs);
      return ($platforms$posix$IO$succeed)(($sp$ModulesFile$toMeta)((Object.assign)({}, $modulesFile, ({
        sourceDirs: $updatedSourceDirs,
      }))));
    })))($getAllSourceDirLists);
  })))($sp$Main$loadModulesFile);
});

const $sp$Main$loadModule = (($meta) => {
  return (($umr) => {
    return (($fileName) => {
      const $$moduleName = $umr;
      const $moduleName = ($$moduleName)[2];
      const $source = ($$moduleName)[1];
      return (($platforms$posix$IO$onSuccess)((($moduleAsText) => {
        const $params = ({
          meta: $meta,
          name: $moduleName,
          source: $source,
          stripLocations: false,
        });
        const $eenv = ({
          moduleByName: (($corelib$Dict$singleton)($moduleName))(({
            content: $moduleAsText,
            fsPath: $fileName,
          })),
        });
        return (($sp$Main$resToIo)($eenv))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($params))($moduleAsText));
      })))((io_readFile)($fileName));
    });
  });
});

const $sp$Main$onResSuccess = (($errorEnv) => {
  return (($f) => {
    return (($res) => {
      return (($platforms$posix$IO$onSuccess)($f))((($sp$Main$resToIo)($errorEnv))($res));
    });
  });
});

const $sp$Main$typeCheckModule = (($meta) => {
  return (($globals) => {
    return (($module) => {
      const $env = ({
        constructors: $globals.constructors,
        currentModule: $module.umr,
        instanceVariables: (($corelib$Dict$mapKeys)($sp$Types$CanonicalAst$RefRoot))($globals.instanceVariables),
        meta: $meta,
        nonAnnotatedRecursives: $corelib$Dict$empty,
        nonFreeTyvars: $corelib$Dict$empty,
        types: $globals.types,
      });
      return (($sp$Compiler$TypeCheck$fromModule)($env))($module);
    });
  });
});

const $sp$Main$umrToFileName = (($x) => {
  const $$name = $x;
  const $name = ($$name)[2];
  const $source = ($$name)[1];
  return ((($source)[0] === "SourceDir")
    ? ((() => {
      const $d = ($source)[1];
      return ($corelib$Maybe$Just)(($d + ("/" + ($name + ".sp"))));
    }))()
    : (true
      ? $corelib$Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 185:4', (sp_toHuman)($source))));
});

const $sp$Main$compile = (($env) => {
  return (($entryModule) => {
    return (($entryValue) => {
      return (($outputFile) => {
        ((sp_log)("Loading meta..."))("");
        return (($platforms$posix$IO$onSuccess)((($meta) => {
          ((sp_log)("Loading modules..."))("");
          const $loadAllModules = (io_parallel)((($corelib$List$filterMap)((($umr) => {
            return (($corelib$Maybe$map)((($sp$Main$loadModule)($meta))($umr)))(($sp$Main$umrToFileName)($umr));
          })))(($corelib$Dict$values)($meta.moduleVisibleAsToUmr)));
          return (($platforms$posix$IO$onSuccess)((($userModules) => {
            const $modules = ((($corelib$List$for)($userModules))((($module) => {
              return (($corelib$Dict$insert)($module.umr))($module);
            })))($sp$Prelude$coreModulesByUmr);
            const $eenv = ((() => {
              const $getName = (($n) => {
                const $$name = $n.umr;
                const $name = ($$name)[2];
                const $source = ($$name)[1];
                return $name;
              });
              return ({
                moduleByName: ((($corelib$List$for)(($corelib$Dict$values)($modules)))((($m) => {
                  return (($corelib$Dict$insert)(($getName)($m)))(({
                    content: $m.asText,
                    fsPath: (($corelib$Maybe$withDefault)("CORE"))(($sp$Main$umrToFileName)($m.umr)),
                  }));
                })))($corelib$Dict$empty),
              });
            }))();
            ((sp_log)("Solving globals..."))("");
            const $x = ($sp$Compiler$Pipeline$globalExpandedTypes)($modules);
            return ((($sp$Main$onResSuccess)($eenv))((($globals) => {
              return ((($sp$Main$onResSuccess)($eenv))((($targetUsr) => {
                ((sp_log)("Type checking..."))("");
                const $typeCheckModules = (io_parallel)((($corelib$List$map)((($m) => {
                  return (($sp$Main$resToIo)($eenv))(((($sp$Main$typeCheckModule)($meta))($globals))($m));
                })))(($corelib$Dict$values)($modules)));
                return (($platforms$posix$IO$onSuccess)((($typeCheckEnvs) => {
                  ((sp_log)("Emittable AST..."))("");
                  return ((($sp$Main$onResSuccess)($eenv))((($emittableStatements) => {
                    (sp_log)("= Platform specific stuff =");
                    const $js = ((($platforms$posix$PlatformDefinition$compile)(({
                      constructors: ($corelib$Dict$toList)($globals.constructors),
                      errorEnv: $eenv,
                    })))($targetUsr))($emittableStatements);
                    return ((io_writeFile)($outputFile))($js);
                  })))((($corelib$Result$mapError)((($e) => {
                    return (sp_todo)("MakeEmittable.translateAll returned Err");
                  })))(($sp$Compiler$MakeEmittable$translateAll)(($corelib$Dict$values)($modules))));
                })))($typeCheckModules);
              })))((((($sp$Main$getTargetUsr)($meta))($entryModule))($entryValue))($globals));
            })))($x);
          })))($loadAllModules);
        })))(($sp$Main$loadMeta)($env));
      });
    });
  });
});

const $sp$Main$green = ($sp$Main$color)("\x1b[32m");

const $sp$Main$indent = (($s) => {
  return (($corelib$Text$join)("\n"))((($corelib$List$map)((($l) => {
    return ("  " + $l);
  })))(((text_split)("\n"))($s)));
});

const $sp$Main$order = (($outcome) => {
  return ((($outcome)[0] === "Success")
    ? 0
    : ((($outcome)[0] === "Skipped")
      ? 1
      : ((($outcome)[0] === "Error")
        ? 2
        : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 78:4', (sp_toHuman)($outcome)))));
});

const $sp$Main$testOutcomeToText = (($name) => {
  return (($code) => {
    return (($outcome) => {
      return ((($outcome)[0] === "Success")
        ? ($sp$Main$green)(("* PASS: " + $name))
        : ((($outcome)[0] === "Skipped")
          ? ($sp$Main$yellow)(("* skip: " + $name))
          : ((($outcome)[0] === "Error")
            ? ((() => {
              const $error = ($outcome)[1];
              return (($sp$Main$red)(("FAIL ! " + $name)) + ("\n" + (($sp$Main$indent)($code) + ("\n" + ($sp$Main$indent)($error)))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 56:4', (sp_toHuman)($outcome)))));
    });
  });
});

const $sp$Test$getName = (($test) => {
  return ((($test)[0] === "Single")
    ? ((() => {
      const $n = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return $n;
    }))()
    : ((($test)[0] === "Group")
      ? ((() => {
        const $n = ($test)[1];
        const $ls = ($test)[2];
        return $n;
      }))()
      : ((($test)[0] === "NotNow")
        ? ((() => {
          const $t = ($test)[1];
          return ($sp$Test$getName)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 145:4', (sp_toHuman)($test)))));
});

const $sp$Test$outcomesRec = (($path) => {
  return (($test) => {
    return (($accum) => {
      return ((($test)[0] === "Single")
        ? ((() => {
          const $name = ($test)[1];
          const $code = ($test)[2];
          const $f = ($test)[3];
          return (((text_startsWith)("SKIP"))($name)
            ? ((sp_cons)($accum))(({
              code: "",
              name: ($path + $name),
              outcome: $sp$Test$Skipped,
            }))
            : ((sp_cons)($accum))(({
              code: $code,
              name: ($path + $name),
              outcome: ($f)(null),
            })));
        }))()
        : ((($test)[0] === "NotNow")
          ? ((() => {
            const $t = ($test)[1];
            return ((sp_cons)($accum))(({
              code: "",
              name: ($path + ($sp$Test$getName)($t)),
              outcome: $sp$Test$Skipped,
            }));
          }))()
          : ((($test)[0] === "Group")
            ? ((() => {
              const $pathSegment = ($test)[1];
              const $ts = ($test)[2];
              return ((($corelib$List$for)($ts))(($sp$Test$outcomesRec)(($path + ($pathSegment + " / ")))))($accum);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 126:4', (sp_toHuman)($test)))));
    });
  });
});

const $sp$Test$flatten = (($tests) => {
  return ((($corelib$List$for)($tests))(($sp$Test$outcomesRec)("")))($core$SPCore$Nil);
});

const $sp$Main$main = (($env) => {
  return (($args) => {
    return (((($args)[0] === "Cons") && ((($args)[2])[0] === "Nil"))
      ? ((() => {
        const $self = ($args)[1];
        return (io_writeStdout)((($corelib$Text$join)("\n"))((($corelib$List$map)((($x) => {
          return ((($sp$Main$testOutcomeToText)($x.name))($x.code))($x.outcome);
        })))(((list_sortBy)((($x) => {
          return ({
            first: ($sp$Main$order)($x.outcome),
            second: $x.name,
          });
        })))(($sp$Test$flatten)($sp$Main$allTests)))));
      }))()
      : (((($args)[0] === "Cons") && (((($args)[2])[0] === "Cons") && (((($args)[2])[2])[0] === "Nil")))
        ? ((() => {
          const $self = ($args)[1];
          const $testFile = (($args)[2])[1];
          const $umr = (($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("")))($testFile);
          return (($platforms$posix$IO$onSuccess)((($caModule) => {
            return ($platforms$posix$IO$succeed)(null);
          })))(((($sp$Main$loadModule)($sp$Compiler$TestHelpers$meta))($umr))($testFile));
        }))()
        : (((($args)[0] === "Cons") && (((($args)[2])[0] === "Cons") && ((((($args)[2])[2])[0] === "Cons") && (((((($args)[2])[2])[2])[0] === "Cons") && (((((($args)[2])[2])[2])[2])[0] === "Nil")))))
          ? ((() => {
            const $self = ($args)[1];
            const $entryModule = (($args)[2])[1];
            const $entryValue = ((($args)[2])[2])[1];
            const $outputFile = (((($args)[2])[2])[2])[1];
            return (((($sp$Main$compile)($env))($entryModule))($entryValue))($outputFile);
          }))()
          : (true
            ? (io_writeStdout)("Usage\n\nspcc EntryModule entryFunction outputFile.js")
            : (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 395:4', (sp_toHuman)($args))))));
  });
});

const $sp$Main$sdItemToUMR = (($source) => {
  return (($fileName) => {
    return (($sp$Types$Meta$UMR)($source))(((($corelib$Text$replace)(".sp"))(""))($fileName));
  });
});

const $sp$SPLib$Buffer$readOne = (($b) => {
  return (($b.nextPos < $b.fullSize)
    ? ({
      first: (((text_slice)($b.nextPos))(($b.nextPos + 1)))($b.fullText),
      second: (Object.assign)({}, $b, ({
        nextPos: ($b.nextPos + 1),
      })),
    })
    : ({
      first: "",
      second: $b,
    }));
});

const $sp$SPLib$Parser$tuple3 = (($pa) => {
  return (($pb) => {
    return (($pc) => {
      return (($sp$SPLib$Parser$andThen)((($a) => {
        return (($sp$SPLib$Parser$andThen)((($b) => {
          return (($sp$SPLib$Parser$andThen)((($c) => {
            return ($sp$SPLib$Parser$accept)(({
              first: $a,
              second: $b,
              third: $c,
            }));
          })))($pc);
        })))($pb);
      })))($pa);
    });
  });
});

const $sp$SPON$logHead = (($statements) => {
  ((($statements)[0] === "Cons")
    ? ((() => {
      const $head = ($statements)[1];
      const $tail = ($statements)[2];
      ((sp_log)("LOG"))($head);
      return null;
    }))()
    : ((($statements)[0] === "Nil")
      ? ((sp_log)("LOG"))(null)
      : (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 68:4', (sp_toHuman)($statements))));
  return (($sp$SPON$Accepted)($statements))(null);
});

const $sp$StateMonad$map = (($f) => {
  return (($m) => {
    return (($sp$StateMonad$andThen)((($x) => {
      return ($sp$StateMonad$return)(($f)($x));
    })))($m);
  });
});

const $sp$Test$errorsFirst = (($outcome) => {
  return ((($outcome)[0] === "Error")
    ? ((() => {
      const $e = ($outcome)[1];
      return (0 - 1);
    }))()
    : ((($outcome)[0] === "Skipped")
      ? 0
      : ((($outcome)[0] === "Success")
        ? 1
        : (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 165:4', (sp_toHuman)($outcome)))));
});

const $sp$Types$CanonicalAst$typePos = (($ty) => {
  return ((($ty)[0] === "TypeConstant")
    ? ((() => {
      const $p = ($ty)[1];
      return $p;
    }))()
    : ((($ty)[0] === "TypeVariable")
      ? ((() => {
        const $p = ($ty)[1];
        return $p;
      }))()
      : ((($ty)[0] === "TypeFunction")
        ? ((() => {
          const $p = ($ty)[1];
          return $p;
        }))()
        : ((($ty)[0] === "TypeRecord")
          ? ((() => {
            const $p = ($ty)[1];
            return $p;
          }))()
          : ((($ty)[0] === "TypeAlias")
            ? ((() => {
              const $p = ($ty)[1];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 190:4', (sp_toHuman)($ty)))))));
});

const $sp$Types$FormattableAst$patternNames = (($pattern) => {
  const $foldOver = (($pas) => {
    return ((($corelib$List$for)($pas))((($p) => {
      return ($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($p));
    })))($corelib$Dict$empty);
  });
  const $insertAttr = (($a) => {
    const $$maybePa = $a;
    const $maybePa = $$maybePa.second;
    const $name = ($$maybePa.first)[2];
    const $pos = ($$maybePa.first)[1];
    return ((($maybePa)[0] === "Nothing")
      ? (($corelib$Dict$insert)($name))($pos)
      : ((($maybePa)[0] === "Just")
        ? ((() => {
          const $pat = ($maybePa)[1];
          return ($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($pat));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 177:8', (sp_toHuman)($maybePa))));
  });
  return ((($pattern)[0] === "PatternAny")
    ? ((() => {
      const $pos = ($pattern)[1];
      const $n = ($pattern)[3];
      return (($corelib$Dict$singleton)($n))($pos);
    }))()
    : ((($pattern)[0] === "PatternLiteralNumber")
      ? $corelib$Dict$empty
      : ((($pattern)[0] === "PatternLiteralText")
        ? $corelib$Dict$empty
        : ((($pattern)[0] === "PatternConstructor")
          ? ((() => {
            const $pas = ($pattern)[4];
            return ($foldOver)($pas);
          }))()
          : ((($pattern)[0] === "PatternList")
            ? ((() => {
              const $pas = ($pattern)[2];
              return ($foldOver)($pas);
            }))()
            : ((($pattern)[0] === "PatternListCons")
              ? ((() => {
                const $pas = ($pattern)[2];
                return ($foldOver)($pas);
              }))()
              : ((($pattern)[0] === "PatternRecord")
                ? ((() => {
                  const $pos = ($pattern)[1];
                  const $ars = ($pattern)[2];
                  return ((($corelib$List$for)($ars.attrs))($insertAttr))($corelib$Dict$empty);
                }))()
                : ((($pattern)[0] === "PatternTuple")
                  ? ((() => {
                    const $pas = ($pattern)[2];
                    return ($foldOver)($pas);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 181:4', (sp_toHuman)($pattern))))))))));
});

const $sp$Types$FormattableAst$sepList_mapItem = (($f) => {
  return (($aAndLa) => {
    const $$a = $aAndLa;
    const $la = $$a.second;
    const $a = $$a.first;
    return ({
      first: ($f)($a),
      second: (($corelib$List$map)(($corelib$Tuple$mapSecond)($f)))($la),
    });
  });
});

const $sp$Types$FormattableAst$typePos = (($type) => {
  return ((($type)[0] === "TypeVariable")
    ? ((() => {
      const $p = ($type)[1];
      return $p;
    }))()
    : ((($type)[0] === "TypeConstant")
      ? ((() => {
        const $p = ($type)[1];
        return $p;
      }))()
      : ((($type)[0] === "TypeFunction")
        ? ((() => {
          const $p = ($type)[1];
          return $p;
        }))()
        : ((($type)[0] === "TypeTuple")
          ? ((() => {
            const $p = ($type)[1];
            return $p;
          }))()
          : ((($type)[0] === "TypeList")
            ? ((() => {
              const $p = ($type)[1];
              return $p;
            }))()
            : ((($type)[0] === "TypeRecord")
              ? ((() => {
                const $p = ($type)[1];
                return $p;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 125:4', (sp_toHuman)($type))))))));
});

const $sp$Types$Pos$end = (($pos) => {
  return ((($pos)[0] === "P")
    ? ((() => {
      const $m = ($pos)[1];
      const $s = ($pos)[2];
      const $e = ($pos)[3];
      return $e;
    }))()
    : (true
      ? 0
      : (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 36:4', (sp_toHuman)($pos))));
});

const $sp$Types$Pos$range = (($a) => {
  return (($b) => {
    const $$try1 = ({
      first: $a,
      second: $b,
    });
    return (((($$try1.first)[0] === "P") && (($$try1.second)[0] === "P"))
      ? ((() => {
        const $ma = ($$try1.first)[1];
        const $sa = ($$try1.first)[2];
        const $ea = ($$try1.first)[3];
        const $mb = ($$try1.second)[1];
        const $sb = ($$try1.second)[2];
        const $eb = ($$try1.second)[3];
        return (((sp_not_equal)($mb))($ma)
          ? (sp_todo)("trying to range across two different modules")
          : ((($sp$Types$Pos$P)($ma))((($corelib$Basics$min)($sa))($sb)))((($corelib$Basics$max)($ea))($eb)));
      }))()
      : ((($$try1.first)[0] === "P")
        ? $a
        : (true
          ? $b
          : (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 43:4', (sp_toHuman)($$try1)))));
  });
});
const out = $sp$Main$main({})(array_toList(process.argv.slice(1)))[1]('never');
        if (out[1]) console.error(out[1]);
        