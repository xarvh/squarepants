#!/usr/bin/env node

//Error.stackTraceLimit = 100;


const { performance } = require('perf_hooks');


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


/*  HACK

    TODO this is super brittle
    once we have a proper Platform system in place, the platform can probably
    use its internal Meta to figure out the proper constructor

*/
const maybe_nothing = [ "$corelib$Maybe$Nothing" ];
const maybe_just = (a) => [ "$corelib$Maybe$Just", a ];



//
// Basic ops
//


const sp_equal = (a) => (b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i])(b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k])(b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a) => (b) => {
  return !sp_equal(a)(b);
}


const sp_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = sp_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = sp_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (right) => (left) => {
  if (right === 0) return 0;
  return left / right;
}


const basics_modBy = (a) => (b) => b % a;

const basics_compare = (a) => (b) => sp_compare(a, b);


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message) => (thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.info("");
        console.info("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.info(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const sp_toHuman = (a) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a) || sp_toHumanAsUnion(a);

  if (typeof a === 'function') {
    return '<function>';
  }

  if (typeof a === 'object') {
    let x = [];
    for (let i in a) x.push(i + ' = ' + sp_toHuman(a[i]));
    return '{' + x.join(', ') + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a) => {
  return a[0] + ' ' + a.slice(1).map(arg => '(' + sp_toHuman(arg) + ')').join(' ');
}


const sp_toHumanAsList = (arrayAccum, list) => {
  if (list[0] === '$core$SPCore$Cons') {
    arrayAccum.push(sp_toHuman(list[1]));
    return sp_toHumanAsList(arrayAccum, list[2]);
  }

  if (list[0] === '$core$SPCore$Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ? maybe_nothing : maybe_just(n);
}

const text_split = (separator) => (target) => array_toList(target.split(separator));

const text_length = (s) => s.length;

const text_slice = (start) => (end) => (s) => s.slice(start, end);

const text_startsWith = (sub) => (s) => s.startsWith(sub);

const text_startsWithRegex = (regex) => {
  let re;
  try {
    re = new RegExp('^' + regex);
  } catch (e) {
    return () => ""
  }

  return (s) => {
    let m = s.match(re);
    return m ? m[0] : "";
  }
}

const text_replaceRegex = (regex) => {
  let re;
  try {
    re = new RegExp(regex, 'g');
  } catch (e) {
    return () => () => ""
  }

  return (replacer) => (s) => s.replace(re, replacer);
}

const text_trimLeft = (s) => {
  return s.trimLeft();
}

const text_dropLeft = (n) => (s) => {
  return s.slice(n);
}

const text_forEach = (s) => (f) => {
  for (let i of s) f(i);
  return null;
}


//
// Hashes
//

const hash_empty = {};


const hash_insert = (hash) => (key) => (value) => {
    const h = hash.obj[hash.attr];
    h[JSON.stringify(key)] = [key, value];
    return null;
}


const hash_remove = (hash) => (key) => {
    const h = hash.obj[hash.attr];
    delete h[JSON.stringify(key)];
    return null;
}


const hash_get = (hash) => (key) => {
    const r = hash[JSON.stringify(key)];
    return r === undefined ? maybe_nothing : maybe_just(r[1]);
}


const hash_for = (hash) => (f) => (acc) => {
    for (let k in hash) {
        const kv = hash[k];
        acc = f(kv[0])(kv[1])(acc);
    }
    return acc;
}


const hash_each = (hash) => (f) => {
    for (let k in hash) {
        const kv = hash[k];
        f(kv[0])(kv[1]);
    }
    return null;
}


//
// Arrays
//

const array_push = (array) => (item) => {
    array.obj[array.attr].push(item);
    return null;
}

const array_pop = (array) => {
    const a = array.obj[array.attr];
    return a.length ? maybe_just(a.pop()) : maybe_nothing;
}

const array_get = (array) => (index) => {
    const r = array[index];
    return r === undefined ? maybe_nothing : maybe_just(r);
}

const array_set = (array) => (index) => (item) => {
    if (index < 0) return false;
    const a = array.obj[array.attr];
    if (index >= a.length) return false;
    a[index] = item;
    return true;
}

const array_sortBy = (array) => (f) => {
    const arr = array.obj[array.attr];
    arr.sort((a, b) => sp_compare(f(a), f(b)));
    return null;
}

const array_toList = (array) => {
  let length = array.length;
  let list = [ '$core$SPCore$Nil' ];
  for (let i = length - 1; i >= 0; i--) {
      list = [ '$core$SPCore$Cons', array[i], list ];
  }
  return list;
}

const array_fromList = (list) => {
  const array = [];
  const rec = (ls) => {
    if (ls[0] === '$core$SPCore$Nil')
      return array;

    array.push(ls[1]);
    return rec(ls[2]);
  };

  return rec(list);
}



//
// Lists
//


const sp_cons = (list) => (item) => {
  return [ '$core$SPCore$Cons', item, list];
}

const list_sortBy = (f) => (list) => array_toList(array_fromList(list).sort((a, b) => sp_compare(f(a), f(b))));


//
// Platform: IO
//
const fs = require('fs');

const io_wrap = (f) => [ "IO.IO", f ];

const io_parallel = (iosAsList) => io_wrap((never) => {
    // as [IO a]: IO [a]

    const ios = array_fromList(iosAsList);

    // TODO actually run them in parallel!

    let arr = [];
    for (let io of ios) {
        const r = io[1](never);
        if (r[0] === "$corelib$Result$Ok")
            arr.push(r[1]);
        else
            return $corelib$Result$Err(r[1]);
    }

    return $corelib$Result$Ok(array_toList(arr));
});


const io_readDir = (dirPath) => io_wrap((never) => {
    // as Text: IO [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(array_toList(entries.map((dirent) => ({
        first: dirent.isDirectory(),
        second: dirent.name,
    }))));
});


const io_readFile = (path) => io_wrap((never) => {
    // as Text: IO Text

    var content;
    try {
        content = fs.readFileSync(path, 'utf8');
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(content);
});


const io_writeFile = (path) => (content) => io_wrap((never) => {
    // as Text: Text: IO None

    try {
        fs.writeFileSync(path, content);
    } catch (e) {
        return $corelib$Result$Err(e.message);
    }

    return $corelib$Result$Ok(null);
});


const io_writeStdout = (content) => io_wrap((never) => {
    // as Text: IO None

    console.info(content);
    return $corelib$Result$Ok(null);
});

    const or = (($a) => (($b) => ($b || $a)));

const and = (($a) => (($b) => ($b && $a)));

const greaterOrEqual = (($a) => (($b) => ($b >= $a)));

const greaterThan = (($a) => (($b) => ($b > $a)));

const lesserOrEqual = (($a) => (($b) => ($b <= $a)));

const lesserThan = (($a) => (($b) => ($b < $a)));

const mutass = (($a) => (($b) => (($b.obj)[$b.attr] = $a, null)));

const strcon = (($a) => (($b) => ($b + $a)));

const sub = (($a) => (($b) => ($b - $a)));

const mutadd = (($a) => (($b) => (($b.obj)[$b.attr] += $a, null)));

const add = (($a) => (($b) => ($b + $a)));

const mul = (($a) => (($b) => ($b * $a)));

const $sp$Types$Token$With = ([
  "$sp$Types$Token$With",
]);

const $sp$Types$Token$UpperName = (($1) => (($2) => ([
  "$sp$Types$Token$UpperName",
  $1,
  $2,
])));

const $sp$Types$Token$Unop = (($1) => ([
  "$sp$Types$Token$Unop",
  $1,
]));

const $sp$Types$Token$Try = ([
  "$sp$Types$Token$Try",
]);

const $sp$Types$Token$Token = (($1) => (($2) => (($3) => ([
  "$sp$Types$Token$Token",
  $1,
  $2,
  $3,
]))));

const $sp$Types$Token$Then = ([
  "$sp$Types$Token$Then",
]);

const $sp$Types$Token$TextLiteral = (($1) => ([
  "$sp$Types$Token$TextLiteral",
  $1,
]));

const $sp$Types$Token$SquareBracket = (($1) => ([
  "$sp$Types$Token$SquareBracket",
  $1,
]));

const $sp$Types$Token$RoundParen = (($1) => ([
  "$sp$Types$Token$RoundParen",
  $1,
]));

const $sp$Types$Token$Open = ([
  "$sp$Types$Token$Open",
]);

const $sp$Types$Token$NumberLiteral = (($1) => ([
  "$sp$Types$Token$NumberLiteral",
  $1,
]));

const $sp$Types$Token$NewSiblingLine = ([
  "$sp$Types$Token$NewSiblingLine",
]);

const $sp$Types$Token$NameStartsWithDot = ([
  "$sp$Types$Token$NameStartsWithDot",
]);

const $sp$Types$Token$NameNoModifier = ([
  "$sp$Types$Token$NameNoModifier",
]);

const $sp$Types$Token$NameMutable = ([
  "$sp$Types$Token$NameMutable",
]);

const $sp$Types$Token$MutableColon = ([
  "$sp$Types$Token$MutableColon",
]);

const $sp$Types$Token$LowerName = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$Token$LowerName",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$Token$If = ([
  "$sp$Types$Token$If",
]);

const $sp$Types$Token$ErrorUnterminated = (($1) => ([
  "$sp$Types$Token$ErrorUnterminated",
  $1,
]));

const $sp$Types$Token$ErrorUnknownOp = (($1) => ([
  "$sp$Types$Token$ErrorUnknownOp",
  $1,
]));

const $sp$Types$Token$ErrorBlock = (($1) => ([
  "$sp$Types$Token$ErrorBlock",
  $1,
]));

const $sp$Types$Token$Else = ([
  "$sp$Types$Token$Else",
]);

const $sp$Types$Token$Defop = (($1) => ([
  "$sp$Types$Token$Defop",
  $1,
]));

const $sp$Types$Token$CurlyBrace = (($1) => ([
  "$sp$Types$Token$CurlyBrace",
  $1,
]));

const $sp$Types$Token$Comment = ([
  "$sp$Types$Token$Comment",
]);

const $sp$Types$Token$Comma = ([
  "$sp$Types$Token$Comma",
]);

const $sp$Types$Token$Colon = ([
  "$sp$Types$Token$Colon",
]);

const $sp$Types$Token$Closed = ([
  "$sp$Types$Token$Closed",
]);

const $sp$Types$Token$BlockStart = ([
  "$sp$Types$Token$BlockStart",
]);

const $sp$Types$Token$BlockEnd = ([
  "$sp$Types$Token$BlockEnd",
]);

const $sp$Types$Token$Binop = (($1) => ([
  "$sp$Types$Token$Binop",
  $1,
]));

const $sp$Types$Token$BadIndent = ([
  "$sp$Types$Token$BadIndent",
]);

const $sp$Types$Token$As = ([
  "$sp$Types$Token$As",
]);

const $sp$Types$Pos$T = ([
  "$sp$Types$Pos$T",
]);

const $sp$Types$Pos$S = ([
  "$sp$Types$Pos$S",
]);

const $sp$Types$Pos$P = (($1) => (($2) => (($3) => ([
  "$sp$Types$Pos$P",
  $1,
  $2,
  $3,
]))));

const $sp$Types$Pos$N = ([
  "$sp$Types$Pos$N",
]);

const $sp$Types$Pos$I = (($1) => ([
  "$sp$Types$Pos$I",
  $1,
]));

const $sp$Types$Pos$End = (($1) => ([
  "$sp$Types$Pos$End",
  $1,
]));

const $sp$Types$Pos$At = (($1) => (($2) => ([
  "$sp$Types$Pos$At",
  $1,
  $2,
])));

const $sp$Types$Op$Tuple = ([
  "$sp$Types$Op$Tuple",
]);

const $sp$Types$Op$Right = ([
  "$sp$Types$Op$Right",
]);

const $sp$Types$Op$Pipe = ([
  "$sp$Types$Op$Pipe",
]);

const $sp$Types$Op$NonAssociative = ([
  "$sp$Types$Op$NonAssociative",
]);

const $sp$Types$Op$Mutop = ([
  "$sp$Types$Op$Mutop",
]);

const $sp$Types$Op$Multiplicative = ([
  "$sp$Types$Op$Multiplicative",
]);

const $sp$Types$Op$Logical = ([
  "$sp$Types$Op$Logical",
]);

const $sp$Types$Op$Left = ([
  "$sp$Types$Op$Left",
]);

const $sp$Types$Op$Exponential = ([
  "$sp$Types$Op$Exponential",
]);

const $sp$Types$Op$Cons = ([
  "$sp$Types$Op$Cons",
]);

const $sp$Types$Op$Comparison = ([
  "$sp$Types$Op$Comparison",
]);

const $sp$Types$Op$Addittive = ([
  "$sp$Types$Op$Addittive",
]);

const $sp$Types$Meta$USR = (($1) => (($2) => ([
  "$sp$Types$Meta$USR",
  $1,
  $2,
])));

const $sp$Types$Meta$UMR = (($1) => (($2) => ([
  "$sp$Types$Meta$UMR",
  $1,
  $2,
])));

const $sp$Types$Meta$SourceDir = (($1) => ([
  "$sp$Types$Meta$SourceDir",
  $1,
]));

const $sp$Types$Meta$Core = ([
  "$sp$Types$Meta$Core",
]);

const $sp$Types$JavascriptAst$Var = (($1) => ([
  "$sp$Types$JavascriptAst$Var",
  $1,
]));

const $sp$Types$JavascriptAst$Unop = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$Unop",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$SimpleLambda = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$SimpleLambda",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Return = (($1) => ([
  "$sp$Types$JavascriptAst$Return",
  $1,
]));

const $sp$Types$JavascriptAst$Record = (($1) => ([
  "$sp$Types$JavascriptAst$Record",
  $1,
]));

const $sp$Types$JavascriptAst$Mutop = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$JavascriptAst$Mutop",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$JavascriptAst$Literal = (($1) => ([
  "$sp$Types$JavascriptAst$Literal",
  $1,
]));

const $sp$Types$JavascriptAst$If = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$If",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Eval = (($1) => ([
  "$sp$Types$JavascriptAst$Eval",
  $1,
]));

const $sp$Types$JavascriptAst$Define = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$Define",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Conditional = (($1) => (($2) => (($3) => ([
  "$sp$Types$JavascriptAst$Conditional",
  $1,
  $2,
  $3,
]))));

const $sp$Types$JavascriptAst$Call = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$Call",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$BlockLambda = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$BlockLambda",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$Binop = (($1) => (($2) => (($3) => ([
  "$sp$Types$JavascriptAst$Binop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$JavascriptAst$Array = (($1) => ([
  "$sp$Types$JavascriptAst$Array",
  $1,
]));

const $sp$Types$JavascriptAst$AccessWithDot = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$AccessWithDot",
  $1,
  $2,
])));

const $sp$Types$JavascriptAst$AccessWithBrackets = (($1) => (($2) => ([
  "$sp$Types$JavascriptAst$AccessWithBrackets",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Variable = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$Variable",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$Unop = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Unop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$UnionDef = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$UnionDef",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeVariable = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeVariable",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeTuple = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeTuple",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeRecord = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeRecord",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeList = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$TypeList",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$TypeFunction = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$TypeFunction",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$TypeConstant = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$TypeConstant",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$TypeAlias = (($1) => ([
  "$sp$Types$FormattableAst$TypeAlias",
  $1,
]));

const $sp$Types$FormattableAst$Try = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Try",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$RecordShorthand = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$RecordShorthand",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Record = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Record",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PrefixBinop = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PrefixBinop",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternTuple = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternTuple",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternRecord = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternRecord",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternLiteralText = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternLiteralText",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternLiteralNumber = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternLiteralNumber",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternListCons = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternListCons",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternList = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$PatternList",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$PatternConstructor = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$PatternConstructor",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$PatternAny = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$PatternAny",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$Mutable = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Mutable",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$LiteralText = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$LiteralText",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$LiteralNumber = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$LiteralNumber",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$List = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$List",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Lambda = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$FormattableAst$Lambda",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$FormattableAst$If = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$If",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$FunctionCall = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$FunctionCall",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Evaluation = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Evaluation",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Definition = (($1) => (($2) => ([
  "$sp$Types$FormattableAst$Definition",
  $1,
  $2,
])));

const $sp$Types$FormattableAst$Constructor = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Constructor",
  $1,
  $2,
  $3,
]))));

const $sp$Types$FormattableAst$Binop = (($1) => (($2) => (($3) => ([
  "$sp$Types$FormattableAst$Binop",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$Variable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$Variable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$TypeVariable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$TypeVariable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$TypeRecord = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$TypeRecord",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeFunction = (($1) => (($2) => (($3) => (($4) => ([
  "$sp$Types$CanonicalAst$TypeFunction",
  $1,
  $2,
  $3,
  $4,
])))));

const $sp$Types$CanonicalAst$TypeDefUnion = (($1) => ([
  "$sp$Types$CanonicalAst$TypeDefUnion",
  $1,
]));

const $sp$Types$CanonicalAst$TypeDefAlias = (($1) => ([
  "$sp$Types$CanonicalAst$TypeDefAlias",
  $1,
]));

const $sp$Types$CanonicalAst$TypeConstant = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$TypeConstant",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$TypeAlias = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$TypeAlias",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$Try = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Try",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$RefRoot = (($1) => ([
  "$sp$Types$CanonicalAst$RefRoot",
  $1,
]));

const $sp$Types$CanonicalAst$RefBlock = (($1) => ([
  "$sp$Types$CanonicalAst$RefBlock",
  $1,
]));

const $sp$Types$CanonicalAst$Record = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Record",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$PatternRecord = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$PatternRecord",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternLiteralText = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$PatternLiteralText",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternLiteralNumber = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$PatternLiteralNumber",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$PatternConstructor = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$PatternConstructor",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$PatternAny = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$PatternAny",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$ParameterPattern = (($1) => ([
  "$sp$Types$CanonicalAst$ParameterPattern",
  $1,
]));

const $sp$Types$CanonicalAst$ParameterMutable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$ParameterMutable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LiteralText = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$LiteralText",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$LiteralNumber = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$LiteralNumber",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Lambda = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Lambda",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$If = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$If",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Evaluation = (($1) => ([
  "$sp$Types$CanonicalAst$Evaluation",
  $1,
]));

const $sp$Types$CanonicalAst$Definition = (($1) => ([
  "$sp$Types$CanonicalAst$Definition",
  $1,
]));

const $sp$Types$CanonicalAst$Constructor = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$Constructor",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$Call = (($1) => (($2) => (($3) => ([
  "$sp$Types$CanonicalAst$Call",
  $1,
  $2,
  $3,
]))));

const $sp$Types$CanonicalAst$ArgumentMutable = (($1) => (($2) => ([
  "$sp$Types$CanonicalAst$ArgumentMutable",
  $1,
  $2,
])));

const $sp$Types$CanonicalAst$ArgumentExpression = (($1) => ([
  "$sp$Types$CanonicalAst$ArgumentExpression",
  $1,
]));

const $sp$Test$Success = ([
  "$sp$Test$Success",
]);

const $sp$Test$Skipped = ([
  "$sp$Test$Skipped",
]);

const $sp$Test$Single = (($1) => (($2) => (($3) => ([
  "$sp$Test$Single",
  $1,
  $2,
  $3,
]))));

const $sp$Test$NotNow = (($1) => ([
  "$sp$Test$NotNow",
  $1,
]));

const $sp$Test$Group = (($1) => (($2) => ([
  "$sp$Test$Group",
  $1,
  $2,
])));

const $sp$Test$Error = (($1) => ([
  "$sp$Test$Error",
  $1,
]));

const $sp$Test$CodeExpectation = (($1) => ([
  "$sp$Test$CodeExpectation",
  $1,
]));

const $sp$SPON$Rejected = (($1) => ([
  "$sp$SPON$Rejected",
  $1,
]));

const $sp$SPON$Failed = (($1) => ([
  "$sp$SPON$Failed",
  $1,
]));

const $sp$SPON$Accepted = (($1) => (($2) => ([
  "$sp$SPON$Accepted",
  $1,
  $2,
])));

const $sp$SPLib$Parser$Rejected = ([
  "$sp$SPLib$Parser$Rejected",
]);

const $sp$SPLib$Parser$Accepted = (($1) => (($2) => ([
  "$sp$SPLib$Parser$Accepted",
  $1,
  $2,
])));

const $sp$SPLib$Parser$Aborted = (($1) => (($2) => ([
  "$sp$SPLib$Parser$Aborted",
  $1,
  $2,
])));

const $sp$ModulesFile$Lib = (($1) => ([
  "$sp$ModulesFile$Lib",
  $1,
]));

const $sp$ModulesFile$Dir = (($1) => ([
  "$sp$ModulesFile$Dir",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_TryPattern = ([
  "$sp$Compiler$TypeCheck$UnifyReason_TryPattern",
]);

const $sp$Compiler$TypeCheck$UnifyReason_TryBlock = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_TryBlock",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_Override = ([
  "$sp$Compiler$TypeCheck$UnifyReason_Override",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction = (($1) => (($2) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction",
  $1,
  $2,
])));

const $sp$Compiler$TypeCheck$UnifyReason_IfCondition = ([
  "$sp$Compiler$TypeCheck$UnifyReason_IfCondition",
]);

const $sp$Compiler$TypeCheck$UnifyReason_IfBranches = ([
  "$sp$Compiler$TypeCheck$UnifyReason_IfBranches",
]);

const $sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern = ([
  "$sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern",
]);

const $sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_CallArgument = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_CallArgument",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AttributeAccess = (($1) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_AttributeAccess",
  $1,
]));

const $sp$Compiler$TypeCheck$UnifyReason_AnnotationVsPattern = ([
  "$sp$Compiler$TypeCheck$UnifyReason_AnnotationVsPattern",
]);

const $sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock = (($1) => (($2) => (($3) => ([
  "$sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock",
  $1,
  $2,
  $3,
]))));

const $sp$Compiler$TypeCheck$SubstitutingAnnotation = (($1) => ([
  "$sp$Compiler$TypeCheck$SubstitutingAnnotation",
  $1,
]));

const $sp$Compiler$TypeCheck$OkThisIsActuallyPossible = ([
  "$sp$Compiler$TypeCheck$OkThisIsActuallyPossible",
]);

const $sp$Compiler$TypeCheck$NonFunctionContainsFunction = (($1) => ([
  "$sp$Compiler$TypeCheck$NonFunctionContainsFunction",
  $1,
]));

const $sp$Compiler$TypeCheck$NI = (($1) => ([
  "$sp$Compiler$TypeCheck$NI",
  $1,
]));

const $sp$Compiler$TypeCheck$IncompatibleTypes = ([
  "$sp$Compiler$TypeCheck$IncompatibleTypes",
]);

const $sp$Compiler$TypeCheck$IncompatibleRecords = (($1) => ([
  "$sp$Compiler$TypeCheck$IncompatibleRecords",
  $1,
]));

const $sp$Compiler$TypeCheck$IncompatibleMutability = ([
  "$sp$Compiler$TypeCheck$IncompatibleMutability",
]);

const $sp$Compiler$TypeCheck$Cycle = (($1) => ([
  "$sp$Compiler$TypeCheck$Cycle",
  $1,
]));

const $sp$Compiler$Lexer$Word = (($1) => ([
  "$sp$Compiler$Lexer$Word",
  $1,
]));

const $sp$Compiler$Lexer$TripleQuote = (($1) => ([
  "$sp$Compiler$Lexer$TripleQuote",
  $1,
]));

const $sp$Compiler$Lexer$Tabs = ([
  "$sp$Compiler$Lexer$Tabs",
]);

const $sp$Compiler$Lexer$Squiggles = ([
  "$sp$Compiler$Lexer$Squiggles",
]);

const $sp$Compiler$Lexer$Spaces = ([
  "$sp$Compiler$Lexer$Spaces",
]);

const $sp$Compiler$Lexer$SingleQuote = (($1) => ([
  "$sp$Compiler$Lexer$SingleQuote",
  $1,
]));

const $sp$Compiler$Lexer$NumberLiteral = ([
  "$sp$Compiler$Lexer$NumberLiteral",
]);

const $sp$Compiler$Lexer$NoTabsOrSpacesYet = ([
  "$sp$Compiler$Lexer$NoTabsOrSpacesYet",
]);

const $sp$Compiler$Lexer$Mutable = ([
  "$sp$Compiler$Lexer$Mutable",
]);

const $sp$Compiler$Lexer$LineComment = ([
  "$sp$Compiler$Lexer$LineComment",
]);

const $sp$Compiler$Lexer$Indent = ([
  "$sp$Compiler$Lexer$Indent",
]);

const $sp$Compiler$Lexer$Dot = ([
  "$sp$Compiler$Lexer$Dot",
]);

const $sp$Compiler$Lexer$Default = ([
  "$sp$Compiler$Lexer$Default",
]);

const $sp$Compiler$Lexer$ContentOpeningQuotes_Two = ([
  "$sp$Compiler$Lexer$ContentOpeningQuotes_Two",
]);

const $sp$Compiler$Lexer$ContentOpeningQuotes_One = ([
  "$sp$Compiler$Lexer$ContentOpeningQuotes_One",
]);

const $sp$Compiler$Lexer$ContentOpeningBlockComment = ([
  "$sp$Compiler$Lexer$ContentOpeningBlockComment",
]);

const $sp$Compiler$Lexer$BlockComment = (($1) => ([
  "$sp$Compiler$Lexer$BlockComment",
  $1,
]));

const $sp$Compiler$Error$Simple = (($1) => (($2) => ([
  "$sp$Compiler$Error$Simple",
  $1,
  $2,
])));

const $sp$Compiler$Error$Nested = (($1) => ([
  "$sp$Compiler$Error$Nested",
  $1,
]));

const $sp$Compiler$Error$HighlightWord = (($1) => ([
  "$sp$Compiler$Error$HighlightWord",
  $1,
]));

const $sp$Compiler$Error$HighlightBlock = (($1) => ([
  "$sp$Compiler$Error$HighlightBlock",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Warning = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Warning",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Emphasys = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Emphasys",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Default = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Default",
  $1,
]));

const $sp$Compiler$Error$FormattedText_Decoration = (($1) => ([
  "$sp$Compiler$Error$FormattedText_Decoration",
  $1,
]));

const $sp$Compiler$CanonicalToJs$Right = (($1) => ([
  "$sp$Compiler$CanonicalToJs$Right",
  $1,
]));

const $sp$Compiler$CanonicalToJs$NodeName = (($1) => (($2) => ([
  "$sp$Compiler$CanonicalToJs$NodeName",
  $1,
  $2,
])));

const $sp$Compiler$CanonicalToJs$NodeDef = (($1) => (($2) => ([
  "$sp$Compiler$CanonicalToJs$NodeDef",
  $1,
  $2,
])));

const $sp$Compiler$CanonicalToJs$Left = (($1) => ([
  "$sp$Compiler$CanonicalToJs$Left",
  $1,
]));

const $posix$IO$Never = (($1) => ([
  "$posix$IO$Never",
  $1,
]));

const $posix$IO$IO = (($1) => ([
  "$posix$IO$IO",
  $1,
]));

const $corelib$Result$Ok = (($1) => ([
  "$corelib$Result$Ok",
  $1,
]));

const $corelib$Result$Err = (($1) => ([
  "$corelib$Result$Err",
  $1,
]));

const $corelib$Maybe$Nothing = ([
  "$corelib$Maybe$Nothing",
]);

const $corelib$Maybe$Just = (($1) => ([
  "$corelib$Maybe$Just",
  $1,
]));

const $corelib$Hash$Hash__ = (($1) => ([
  "$corelib$Hash$Hash__",
  $1,
]));

const $corelib$Dict$Red = ([
  "$corelib$Dict$Red",
]);

const $corelib$Dict$RBNode_elm_builtin = (($1) => (($2) => (($3) => (($4) => (($5) => ([
  "$corelib$Dict$RBNode_elm_builtin",
  $1,
  $2,
  $3,
  $4,
  $5,
]))))));

const $corelib$Dict$RBEmpty_elm_builtin = ([
  "$corelib$Dict$RBEmpty_elm_builtin",
]);

const $corelib$Dict$Black = ([
  "$corelib$Dict$Black",
]);

const $corelib$Array$Array__ = (($1) => ([
  "$corelib$Array$Array__",
  $1,
]));

const $core$SPCore$Nil = ([
  "$core$SPCore$Nil",
]);

const $core$SPCore$Cons = (($1) => (($2) => ([
  "$core$SPCore$Cons",
  $1,
  $2,
])));

const $sp$Test$maybeToOutcome = (($m) => ((() => {
  const $$try = $m;
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($sp$Test$Error)($e);
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return $sp$Test$Success;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 15:4', (sp_toHuman)($$try));
}))());

const $sp$Test$valueTest = (($toText) => (($title) => (($generateValue) => (($ce) => {
  const toMaybeError$$ = $ce;
  const $toMaybeError = (toMaybeError$$)[1];
  return ((($sp$Test$Single)($title))(""))((() => ($sp$Test$maybeToOutcome)((($toMaybeError)($toText))(($corelib$Result$Ok)(($generateValue)(null))))));
}))));

const $corelib$Array_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$Text$join = (($sep) => (($listOfText) => ((() => {
  const $$try = $listOfText;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return "";
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $head = ($$try)[1];
    const $tail = ($$try)[2];
    const $rec = (($ls) => (($acc) => ((() => {
      const $$try = $ls;
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return $acc;
      }
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $h = ($$try)[1];
        const $t = ($$try)[2];
        return (($rec)($t))(($acc + ($sep + $h)));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 135:12', (sp_toHuman)($$try));
    }))()));
    return (($rec)($tail))($head);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 127:4', (sp_toHuman)($$try));
}))()));

const $sp$Test$isOkAndEqualTo = (($expectedOk) => ($sp$Test$CodeExpectation)((($toText) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($corelib$Maybe$Just)($e);
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $actualOk = ($$try)[1];
    return (((sp_equal)($expectedOk))($actualOk)
      ? $corelib$Maybe$Nothing
      : ($corelib$Maybe$Just)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("expected = "))((($core$SPCore$Cons)(($toText)($expectedOk)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("actual = "))((($core$SPCore$Cons)(($toText)($actualOk)))($core$SPCore$Nil))))))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 81:6', (sp_toHuman)($$try));
}))()))));

const $corelib$Array_Test$tests = (($sp$Test$Group)("Array"))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("push"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)),
    }),
  });
  ((array_push)($a))("b");
  ((array_push)($a))("c");
  return (array_toList)((sp_clone)(($a.obj)[$a.attr]));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("pop 1"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("x"))((($core$SPCore$Cons)("y"))((($core$SPCore$Cons)("z"))($core$SPCore$Nil)))),
    }),
  });
  const $b = (array_pop)($a);
  const $c = (array_pop)($a);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  b: ($corelib$Maybe$Just)("z"),
  c: ($corelib$Maybe$Just)("y"),
  l: (($core$SPCore$Cons)("x"))($core$SPCore$Nil),
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("pop empty"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)($core$SPCore$Nil),
    }),
  });
  const $b = (array_pop)($a);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    b: $b,
    l: $l,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  b: $corelib$Maybe$Nothing,
  l: $core$SPCore$Nil,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("get Just"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("p"))((($core$SPCore$Cons)("q"))($core$SPCore$Nil))),
    }),
  });
  return ((array_get)((sp_clone)(($a.obj)[$a.attr])))(1);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)("q")))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("get Nothing"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)("p"))((($core$SPCore$Cons)("q"))($core$SPCore$Nil))),
    }),
  });
  return ((array_get)((sp_clone)(($a.obj)[$a.attr])))(3);
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("set success"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil))),
    }),
  });
  const $r = (((array_set)($a))(0))(10);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    l: $l,
    r: $r,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  l: (($core$SPCore$Cons)(10))((($core$SPCore$Cons)(9))($core$SPCore$Nil)),
  r: true,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("set fail"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil))),
    }),
  });
  const $r = (((array_set)($a))(3))(10);
  const $l = (array_toList)((sp_clone)(($a.obj)[$a.attr]));
  return ({
    l: $l,
    r: $r,
  });
})))(($sp$Test$isOkAndEqualTo)(({
  l: (($core$SPCore$Cons)(8))((($core$SPCore$Cons)(9))($core$SPCore$Nil)),
  r: false,
})))))((($core$SPCore$Cons)(((($corelib$Array_Test$valueTest)("sortBy"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)((($core$SPCore$Cons)(55))((($core$SPCore$Cons)(99))((($core$SPCore$Cons)(22))($core$SPCore$Nil)))),
    }),
  });
  ((array_sortBy)($a))((($x) => -($x)));
  return (array_toList)((sp_clone)(($a.obj)[$a.attr]));
})))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(99))((($core$SPCore$Cons)(55))((($core$SPCore$Cons)(22))($core$SPCore$Nil)))))))($core$SPCore$Nil)))))))));

const $corelib$Basics$btw = (($f) => (($a) => (($c) => {
  ($f)($a);
  return $c;
})));

const $corelib$Basics$clamp = (($low) => (($high) => (($n) => (($n < $low)
  ? $low
  : (($n > $high)
    ? $high
    : $n)))));

const $corelib$Basics$identity = (($a) => $a);

const $corelib$Basics$max = (($a) => (($b) => (($a > $b)
  ? $a
  : $b)));

const $corelib$Basics$min = (($a) => (($b) => (($a < $b)
  ? $a
  : $b)));

const $corelib$Basics$not = (($b) => ($b
  ? false
  : true));

const $corelib$Dict$balance = (($color) => (($key) => (($value) => (($left) => (($right) => ((() => {
  const $$try = $right;
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
    const $rK = ($$try)[2];
    const $rV = ($$try)[3];
    const $rLeft = ($$try)[4];
    const $rRight = ($$try)[5];
    return ((() => {
      const $$try = $left;
      if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
        const $lK = ($$try)[2];
        const $lV = ($$try)[3];
        const $lLeft = ($$try)[4];
        const $lRight = ($$try)[5];
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($rK))($rV))($rLeft))($rRight));
        return null;
      }
      if (true) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($color))($rK))($rV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($left))($rLeft)))($rRight);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 117:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return ((() => {
      const $$try = $left;
      if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$Red" === (($$try)[1])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[4])[0]) && ("$corelib$Dict$Red" === ((($$try)[4])[1])[0]))))) {
        const $lK = ($$try)[2];
        const $lV = ($$try)[3];
        const $llK = (($$try)[4])[2];
        const $llV = (($$try)[4])[3];
        const $llLeft = (($$try)[4])[4];
        const $llRight = (($$try)[4])[5];
        const $lRight = ($$try)[5];
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($llK))($llV))($llLeft))($llRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($key))($value))($lRight))($right));
        return null;
      }
      if (true) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))($left))($right);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 130:6', (sp_toHuman)($$try));
    }))();
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 115:2', (sp_toHuman)($$try));
}))())))));

const $corelib$Dict$foldl = (($func) => (($dict) => (($acc) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return $acc;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return ((($corelib$Dict$foldl)($func))($right))(((($func)($key))($value))(((($corelib$Dict$foldl)($func))($left))($acc)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 453:2', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$moveRedLeft = (($dict) => ((() => {
  const $$try = $dict;
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[4])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[5])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === ((($$try)[5])[4])[0]) && ("$corelib$Dict$Red" === (((($$try)[5])[4])[1])[0])))))) {
    const $clr = ($$try)[1];
    const $k = ($$try)[2];
    const $v = ($$try)[3];
    const $lClr = (($$try)[4])[1];
    const $lK = (($$try)[4])[2];
    const $lV = (($$try)[4])[3];
    const $lLeft = (($$try)[4])[4];
    const $lRight = (($$try)[4])[5];
    const $rClr = (($$try)[5])[1];
    const $rK = (($$try)[5])[2];
    const $rV = (($$try)[5])[3];
    const $rlK = ((($$try)[5])[4])[2];
    const $rlV = ((($$try)[5])[4])[3];
    const $rlL = ((($$try)[5])[4])[4];
    const $rlR = ((($$try)[5])[4])[5];
    const $rRight = (($$try)[5])[5];
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rlK))($rlV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))($rlL)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($rK))($rV))($rlR))($rRight));
    return null;
  }
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[4])[0]) && ("$corelib$Dict$RBNode_elm_builtin" === (($$try)[5])[0])))) {
    const $clr = ($$try)[1];
    const $k = ($$try)[2];
    const $v = ($$try)[3];
    const $lClr = (($$try)[4])[1];
    const $lK = (($$try)[4])[2];
    const $lV = (($$try)[4])[3];
    const $lLeft = (($$try)[4])[4];
    const $lRight = (($$try)[4])[5];
    const $rClr = (($$try)[5])[1];
    const $rK = (($$try)[5])[2];
    const $rV = (($$try)[5])[3];
    const $rLeft = (($$try)[5])[4];
    const $rRight = (($$try)[5])[5];
    return ((() => {
      const $$try = $clr;
      if (("$corelib$Dict$Black" === ($$try)[0])) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
      }
      if (("$corelib$Dict$Red" === ($$try)[0])) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 285:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return $dict;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 275:2', (sp_toHuman)($$try));
}))());

const $corelib$Dict$getMin = (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $left = ($$try)[4];
    return ((() => {
      const $$try = $left;
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
        return ($corelib$Dict$getMin)($left);
      }
      if (true) {
        return $dict;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 234:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return $dict;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 232:2', (sp_toHuman)($$try));
}))());

const $corelib$Dict$removeMin = (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $color = ($$try)[1];
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return ((() => {
      const $$try = $left;
      if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
        const $lColor = ($$try)[1];
        const $lLeft = ($$try)[4];
        return ((() => {
          const $$try = $lColor;
          if (("$corelib$Dict$Black" === ($$try)[0])) {
            return ((() => {
              const $$try = $lLeft;
              if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
                return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))(($corelib$Dict$removeMin)($left)))($right);
              }
              if (true) {
                return ((() => {
                  const $$try = ($corelib$Dict$moveRedLeft)($dict);
                  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
                    const $nColor = ($$try)[1];
                    const $nKey = ($$try)[2];
                    const $nValue = ($$try)[3];
                    const $nLeft = ($$try)[4];
                    const $nRight = ($$try)[5];
                    return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))(($corelib$Dict$removeMin)($nLeft)))($nRight);
                    return null;
                  }
                  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
                    return $corelib$Dict$RBEmpty_elm_builtin;
                  }
                  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 257:18', (sp_toHuman)($$try));
                }))();
              }
              (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 252:14', (sp_toHuman)($$try));
            }))();
          }
          if (true) {
            return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))(($corelib$Dict$removeMin)($left)))($right);
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 250:10', (sp_toHuman)($$try));
        }))();
        return null;
      }
      if (true) {
        return $corelib$Dict$RBEmpty_elm_builtin;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 248:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return $corelib$Dict$RBEmpty_elm_builtin;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 246:2', (sp_toHuman)($$try));
}))());

const $corelib$Dict$removeHelpEQGT = (($targetKey) => (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $color = ($$try)[1];
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return (((sp_equal)($key))($targetKey)
      ? ((() => {
        const $$try = ($corelib$Dict$getMin)($right);
        if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
          const $minKey = ($$try)[2];
          const $minValue = ($$try)[3];
          return ((((($corelib$Dict$balance)($color))($minKey))($minValue))($left))(($corelib$Dict$removeMin)($right));
          return null;
        }
        if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
          return $corelib$Dict$RBEmpty_elm_builtin;
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 217:8', (sp_toHuman)($$try));
      }))()
      : ((((($corelib$Dict$balance)($color))($key))($value))($left))((($corelib$Dict$removeHelp)($targetKey))($right)));
    return null;
  }
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return $corelib$Dict$RBEmpty_elm_builtin;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 214:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$moveRedRight = (($dict) => ((() => {
  const $$try = $dict;
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[4])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === ((($$try)[4])[4])[0]) && (("$corelib$Dict$Red" === (((($$try)[4])[4])[1])[0]) && ("$corelib$Dict$RBNode_elm_builtin" === (($$try)[5])[0])))))) {
    const $clr = ($$try)[1];
    const $k = ($$try)[2];
    const $v = ($$try)[3];
    const $lClr = (($$try)[4])[1];
    const $lK = (($$try)[4])[2];
    const $lV = (($$try)[4])[3];
    const $llK = ((($$try)[4])[4])[2];
    const $llV = ((($$try)[4])[4])[3];
    const $llLeft = ((($$try)[4])[4])[4];
    const $llRight = ((($$try)[4])[4])[5];
    const $lRight = (($$try)[4])[5];
    const $rClr = (($$try)[5])[1];
    const $rK = (($$try)[5])[2];
    const $rV = (($$try)[5])[3];
    const $rLeft = (($$try)[5])[4];
    const $rRight = (($$try)[5])[5];
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($llK))($llV))($llLeft))($llRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($lRight))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight)));
    return null;
  }
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[4])[0]) && ("$corelib$Dict$RBNode_elm_builtin" === (($$try)[5])[0])))) {
    const $clr = ($$try)[1];
    const $k = ($$try)[2];
    const $v = ($$try)[3];
    const $lClr = (($$try)[4])[1];
    const $lK = (($$try)[4])[2];
    const $lV = (($$try)[4])[3];
    const $lLeft = (($$try)[4])[4];
    const $lRight = (($$try)[4])[5];
    const $rClr = (($$try)[5])[1];
    const $rK = (($$try)[5])[2];
    const $rV = (($$try)[5])[3];
    const $rLeft = (($$try)[5])[4];
    const $rRight = (($$try)[5])[5];
    return ((() => {
      const $$try = $clr;
      if (("$corelib$Dict$Black" === ($$try)[0])) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
      }
      if (("$corelib$Dict$Red" === ($$try)[0])) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($lK))($lV))($lLeft))($lRight)))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($rK))($rV))($rLeft))($rRight));
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 318:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return $dict;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 308:2', (sp_toHuman)($$try));
}))());

const $corelib$Dict$removeHelpPrepEQGT = (($targetKey) => (($dict) => (($color) => (($key) => (($value) => (($left) => (($right) => ((() => {
  const $$try = $left;
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
    const $lK = ($$try)[2];
    const $lV = ($$try)[3];
    const $lLeft = ($$try)[4];
    const $lRight = ($$try)[5];
    return ((((($corelib$Dict$RBNode_elm_builtin)($color))($lK))($lV))($lLeft))(((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($lRight))($right));
    return null;
  }
  if (true) {
    return ((() => {
      const $$try = $right;
      if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$Black" === (($$try)[1])[0]) && (("$corelib$Dict$RBNode_elm_builtin" === (($$try)[4])[0]) && ("$corelib$Dict$Black" === ((($$try)[4])[1])[0]))))) {
        return ($corelib$Dict$moveRedRight)($dict);
      }
      if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && (("$corelib$Dict$Black" === (($$try)[1])[0]) && ("$corelib$Dict$RBEmpty_elm_builtin" === (($$try)[4])[0])))) {
        return ($corelib$Dict$moveRedRight)($dict);
      }
      if (true) {
        return $dict;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 199:6', (sp_toHuman)($$try));
    }))();
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 189:2', (sp_toHuman)($$try));
}))())))))));

const $corelib$Dict$removeHelp = (($targetKey) => (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return $corelib$Dict$RBEmpty_elm_builtin;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $color = ($$try)[1];
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return (((sp_equal)((0 - 1)))(((basics_compare)($targetKey))($key))
      ? ((() => {
        const $$try = $left;
        if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Black" === (($$try)[1])[0]))) {
          const $lLeft = ($$try)[4];
          return ((() => {
            const $$try = $lLeft;
            if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
              return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))((($corelib$Dict$removeHelp)($targetKey))($left)))($right);
            }
            if (true) {
              return ((() => {
                const $$try = ($corelib$Dict$moveRedLeft)($dict);
                if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
                  const $nColor = ($$try)[1];
                  const $nKey = ($$try)[2];
                  const $nValue = ($$try)[3];
                  const $nLeft = ($$try)[4];
                  const $nRight = ($$try)[5];
                  return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))((($corelib$Dict$removeHelp)($targetKey))($nLeft)))($nRight);
                  return null;
                }
                if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
                  return $corelib$Dict$RBEmpty_elm_builtin;
                }
                (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 173:16', (sp_toHuman)($$try));
              }))();
            }
            (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 168:12', (sp_toHuman)($$try));
          }))();
          return null;
        }
        if (true) {
          return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($value))((($corelib$Dict$removeHelp)($targetKey))($left)))($right);
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 166:8', (sp_toHuman)($$try));
      }))()
      : (($corelib$Dict$removeHelpEQGT)($targetKey))(((((((($corelib$Dict$removeHelpPrepEQGT)($targetKey))($dict))($color))($key))($value))($left))($right)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 160:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$remove = (($key) => (($dict) => ((() => {
  const $$try = (($corelib$Dict$removeHelp)($key))($dict);
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
    const $k = ($$try)[2];
    const $v = ($$try)[3];
    const $l = ($$try)[4];
    const $r = ($$try)[5];
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($l))($r);
    return null;
  }
  if (true) {
    const $x = $$try;
    return $x;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 148:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$diff = (($t1) => (($t2) => ((($corelib$Dict$foldl)((($k) => (($v) => (($t) => (($corelib$Dict$remove)($k))($t))))))($t2))($t1)));

const $corelib$Dict$empty = $corelib$Dict$RBEmpty_elm_builtin;

const $corelib$Dict$insertHelp = (($key) => (($value) => (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Red))($key))($value))($corelib$Dict$RBEmpty_elm_builtin))($corelib$Dict$RBEmpty_elm_builtin);
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $nColor = ($$try)[1];
    const $nKey = ($$try)[2];
    const $nValue = ($$try)[3];
    const $nLeft = ($$try)[4];
    const $nRight = ($$try)[5];
    return ((() => {
      const $$try = ((basics_compare)($key))($nKey);
      if ((1 === $$try)) {
        return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))($nLeft))(((($corelib$Dict$insertHelp)($key))($value))($nRight));
      }
      if ((0 === $$try)) {
        return ((((($corelib$Dict$RBNode_elm_builtin)($nColor))($nKey))($value))($nLeft))($nRight);
      }
      if (true) {
        return ((((($corelib$Dict$balance)($nColor))($nKey))($nValue))(((($corelib$Dict$insertHelp)($key))($value))($nLeft)))($nRight);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 101:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 94:2', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$insert = (($key) => (($value) => (($dict) => ((() => {
  const $$try = ((($corelib$Dict$insertHelp)($key))($value))($dict);
  if ((("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0]) && ("$corelib$Dict$Red" === (($$try)[1])[0]))) {
    const $k = ($$try)[2];
    const $v = ($$try)[3];
    const $l = ($$try)[4];
    const $r = ($$try)[5];
    return ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($k))($v))($l))($r);
    return null;
  }
  if (true) {
    const $x = $$try;
    return $x;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 83:2', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$filter = (($isGood) => (($dict) => ((($corelib$Dict$foldl)((($k) => (($v) => (($d) => ((($isGood)($k))($v)
  ? ((($corelib$Dict$insert)($k))($v))($d)
  : $d))))))($dict))($corelib$Dict$empty)));

const $corelib$Result$onOk = (($f) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($corelib$Result$Err)($e);
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $a = ($$try)[1];
    return ($f)($a);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 18:4', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$foldlRes = (($func) => (($dict) => (($acc) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return ($corelib$Result$Ok)($acc);
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return (($corelib$Result$onOk)((($l) => (($corelib$Result$onOk)((($f) => ((($corelib$Dict$foldlRes)($func))($right))($f))))(((($func)($key))($value))($l)))))(((($corelib$Dict$foldlRes)($func))($left))($acc));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 463:4', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$foldr = (($func) => (($t) => (($acc) => ((() => {
  const $$try = $t;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return $acc;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return ((($corelib$Dict$foldr)($func))($left))(((($func)($key))($value))(((($corelib$Dict$foldr)($func))($right))($acc)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 475:2', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$for = (($dict) => (($fun) => (($corelib$Dict$foldl)($fun))($dict)));

const $corelib$List$foldl = (($function) => (($aList) => (($init) => ((() => {
  const $$try = $aList;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $init;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $tail = ($$try)[2];
    return ((($corelib$List$foldl)($function))($tail))((($function)($h))($init));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 70:4', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$fromList = (($assocs) => ((($corelib$List$foldl)((($keyAndValue) => (($dict) => ((($corelib$Dict$insert)($keyAndValue.first))($keyAndValue.second))($dict)))))($assocs))($corelib$Dict$empty));

const $corelib$Dict$get = (($targetKey) => (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return ((() => {
      const $$try = ((basics_compare)($targetKey))($key);
      if ((1 === $$try)) {
        return (($corelib$Dict$get)($targetKey))($right);
      }
      if ((0 === $$try)) {
        return ($corelib$Maybe$Just)($value);
      }
      if (true) {
        return (($corelib$Dict$get)($targetKey))($left);
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 25:6', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 20:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$member = (($key) => (($dict) => ((() => {
  const $$try = (($corelib$Dict$get)($key))($dict);
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    return true;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 42:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$intersect = (($t1) => (($t2) => (($corelib$Dict$filter)((($k) => (() => (($corelib$Dict$member)($k))($t2)))))($t1)));

const $corelib$Dict$isEmpty = (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return true;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 70:2', (sp_toHuman)($$try));
}))());

const $corelib$Dict$join = ($corelib$Dict$foldl)($corelib$Dict$insert);

const $corelib$Dict$keys = (($dict) => ((($corelib$Dict$foldr)((($key) => (($value) => (($keyList) => ((sp_cons)($keyList))($key))))))($dict))($core$SPCore$Nil));

const $corelib$Dict$map = (($func) => (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return $corelib$Dict$RBEmpty_elm_builtin;
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $color = ($$try)[1];
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return ((((($corelib$Dict$RBNode_elm_builtin)($color))($key))((($func)($key))($value)))((($corelib$Dict$map)($func))($left)))((($corelib$Dict$map)($func))($right));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 425:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$mapRes = (($func) => (($dict) => ((() => {
  const $$try = $dict;
  if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
    return ($corelib$Result$Ok)($corelib$Dict$RBEmpty_elm_builtin);
  }
  if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
    const $color = ($$try)[1];
    const $key = ($$try)[2];
    const $value = ($$try)[3];
    const $left = ($$try)[4];
    const $right = ($$try)[5];
    return (($corelib$Result$onOk)((($one) => (($corelib$Result$onOk)((($two) => (($corelib$Result$onOk)((($three) => ($corelib$Result$Ok)(((((($corelib$Dict$RBNode_elm_builtin)($color))($key))($one))($two))($three)))))((($corelib$Dict$mapRes)($func))($right)))))((($corelib$Dict$mapRes)($func))($left)))))((($func)($key))($value));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 435:2', (sp_toHuman)($$try));
}))()));

const $corelib$Dict$toList = (($dict) => {
  const $f = (($key) => (($value) => (($list) => ((sp_cons)($list))(({
    first: $key,
    second: $value,
  })))));
  return ((($corelib$Dict$foldr)($f))($dict))($core$SPCore$Nil);
});

const $corelib$Dict$merge = (($leftStep) => (($bothStep) => (($rightStep) => (($leftDict) => (($rightDict) => (($initialResult) => {
  const $stepState = (($rKey) => (($rValue) => (($q) => {
    const list$$ = $q;
    const $res = list$$.second;
    const $list = list$$.first;
    return ((() => {
      const $$try = $list;
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return ({
          first: $list,
          second: ((($rightStep)($rKey))($rValue))($res),
        });
      }
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $lKey = ($$try)[1].first;
        const $lValue = ($$try)[1].second;
        const $rest = ($$try)[2];
        return ((() => {
          const $$try = ((basics_compare)($lKey))($rKey);
          if ((1 === $$try)) {
            return ({
              first: $list,
              second: ((($rightStep)($rKey))($rValue))($res),
            });
          }
          if ((0 === $$try)) {
            return ({
              first: $rest,
              second: (((($bothStep)($lKey))($lValue))($rValue))($res),
            });
          }
          if (true) {
            return ((($stepState)($rKey))($rValue))(({
              first: $rest,
              second: ((($leftStep)($lKey))($lValue))($res),
            }));
          }
          (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 394:10', (sp_toHuman)($$try));
        }))();
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 389:4', (sp_toHuman)($$try));
    }))();
  })));
  const intermediateResult$$ = ((($corelib$Dict$foldl)($stepState))($rightDict))(({
    first: ($corelib$Dict$toList)($leftDict),
    second: $initialResult,
  }));
  const $intermediateResult = intermediateResult$$.second;
  const $leftovers = intermediateResult$$.first;
  const $liftLeftStep = (($t) => (($res) => {
    const k$$ = $t;
    const $v = k$$.second;
    const $k = k$$.first;
    return ((($leftStep)($k))($v))($res);
  }));
  return ((($corelib$List$foldl)($liftLeftStep))($leftovers))($intermediateResult);
}))))));

const $corelib$Dict$partition = (($isGood) => (($dict) => {
  const $add = (($key) => (($value) => (($t) => {
    const t1$$ = $t;
    const $t2 = t1$$.second;
    const $t1 = t1$$.first;
    return ((($isGood)($key))($value)
      ? ({
        first: ((($corelib$Dict$insert)($key))($value))($t1),
        second: $t2,
      })
      : ({
        first: $t1,
        second: ((($corelib$Dict$insert)($key))($value))($t2),
      }));
  })));
  return ((($corelib$Dict$foldl)($add))($dict))(({
    first: $corelib$Dict$empty,
    second: $corelib$Dict$empty,
  }));
}));

const $corelib$Dict$singleton = (($key) => (($value) => ((((($corelib$Dict$RBNode_elm_builtin)($corelib$Dict$Black))($key))($value))($corelib$Dict$RBEmpty_elm_builtin))($corelib$Dict$RBEmpty_elm_builtin)));

const $corelib$Dict$size = ((() => {
  const $sizeHelp = (($n) => (($dict) => ((() => {
    const $$try = $dict;
    if (("$corelib$Dict$RBEmpty_elm_builtin" === ($$try)[0])) {
      return $n;
    }
    if (("$corelib$Dict$RBNode_elm_builtin" === ($$try)[0])) {
      const $left = ($$try)[4];
      const $right = ($$try)[5];
      return (($sizeHelp)((($sizeHelp)(($n + 1)))($right)))($left);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 57:4', (sp_toHuman)($$try));
  }))()));
  return ($sizeHelp)(0);
}))();

const $corelib$Dict$update = (($targetKey) => (($alter) => (($dictionary) => ((() => {
  const $$try = ($alter)((($corelib$Dict$get)($targetKey))($dictionary));
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $value = ($$try)[1];
    return ((($corelib$Dict$insert)($targetKey))($value))($dictionary);
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return (($corelib$Dict$remove)($targetKey))($dictionary);
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Dict.sp 343:2', (sp_toHuman)($$try));
}))())));

const $corelib$Dict$values = (($dict) => ((($corelib$Dict$foldr)((($key) => (($value) => (($valueList) => ((sp_cons)($valueList))($value))))))($dict))($core$SPCore$Nil));

const $corelib$Dict_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$Dict_Test$insertAndGet = (($sp$Test$Group)("insertAndGet"))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("get, success"))((() => (($corelib$Dict$get)(($corelib$Maybe$Just)("a")))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty))))))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)(1)))))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("get, fail"))((() => (($corelib$Dict$get)(($corelib$Maybe$Just)("c")))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty))))))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))($core$SPCore$Nil)));

const $corelib$Dict_Test$lists = (($sp$Test$Group)("lists"))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("keys"))((() => ((list_sortBy)($corelib$Basics$identity))(($corelib$Dict$keys)(((($corelib$Dict$insert)($corelib$Maybe$Nothing))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(2))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(1))($corelib$Dict$empty))))))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(($corelib$Maybe$Just)("a")))((($core$SPCore$Cons)(($corelib$Maybe$Just)("b")))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Dict_Test$valueTest)("values"))((() => ((list_sortBy)($corelib$Basics$identity))(($corelib$Dict$values)(((($corelib$Dict$insert)(($corelib$Maybe$Just)("b")))(({
  a: 3,
})))(((($corelib$Dict$insert)(($corelib$Maybe$Just)("a")))(({
  a: 1,
})))($corelib$Dict$empty)))))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  a: 1,
})))((($core$SPCore$Cons)(({
  a: 3,
})))($core$SPCore$Nil))))))($core$SPCore$Nil)));

const $corelib$Dict_Test$tests = (($sp$Test$Group)("SPCore/Dict"))((($core$SPCore$Cons)($corelib$Dict_Test$insertAndGet))((($core$SPCore$Cons)($corelib$Dict_Test$lists))($core$SPCore$Nil)));

const $corelib$List$each = (($ls) => (($f) => ((() => {
  const $$try = $ls;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return null;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $tail = ($$try)[2];
    ($f)($h);
    return (($corelib$List$each)($tail))($f);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 321:4', (sp_toHuman)($$try));
}))()));

const $corelib$Hash$fromList = (($l) => {
  const $h = ({
    attr: "$",
    obj: ({
      $: (sp_clone)(hash_empty),
    }),
  });
  (($corelib$List$each)($l))(((k$$) => {
    const $k = k$$.first;
    const $v = k$$.second;
    return (((hash_insert)($h))($k))($v);
  }));
  return (sp_clone)(($h.obj)[$h.attr]);
});

const $corelib$Hash$toList = (($h) => (((hash_for)($h))((($k) => (($v) => (($l) => ((sp_cons)($l))(({
  first: $k,
  second: $v,
})))))))($core$SPCore$Nil));

const $corelib$Hash_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$List$range = (($low) => (($high) => {
  const $rec = (($accum) => (($up) => (($up > $low)
    ? (($rec)(((sp_cons)($accum))($up)))(($up - 1))
    : (((sp_equal)($low))($up)
      ? ((sp_cons)($accum))($up)
      : $accum))));
  return (($rec)($core$SPCore$Nil))($high);
}));

const $corelib$Tuple$first = (($t) => $t.first);

const $corelib$Hash_Test$tests = (($sp$Test$Group)("Hash"))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("insert"))((() => {
  const $h = ({
    attr: "$",
    obj: ({
      $: ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
        first: 1,
        second: 2,
      })))($core$SPCore$Nil)),
    }),
  });
  (((hash_insert)($h))(2))(3);
  return (sp_clone)(($h.obj)[$h.attr]);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 2,
  second: 3,
})))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("remove"))((() => {
  const $h = ({
    attr: "$",
    obj: ({
      $: ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
        first: 1,
        second: 2,
      })))((($core$SPCore$Cons)(({
        first: 3,
        second: 4,
      })))($core$SPCore$Nil))),
    }),
  });
  ((hash_remove)($h))(1);
  return (sp_clone)(($h.obj)[$h.attr]);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: 3,
  second: 4,
})))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("get Just"))((() => {
  const $h = ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 3,
    second: 4,
  })))($core$SPCore$Nil)));
  return ((hash_get)($h))(1);
})))(($sp$Test$isOkAndEqualTo)(($corelib$Maybe$Just)(2)))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("get Nothing"))((() => {
  const $h = ($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: 1,
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: 3,
    second: 4,
  })))($core$SPCore$Nil)));
  return ((hash_get)($h))(66);
})))(($sp$Test$isOkAndEqualTo)($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("for"))((() => (((hash_for)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
  first: ($corelib$Maybe$Just)(true),
  second: 2,
})))((($core$SPCore$Cons)(({
  first: $corelib$Maybe$Nothing,
  second: 4,
})))($core$SPCore$Nil)))))((($k) => (($v) => (($a) => ((list_sortBy)($corelib$Tuple$first))(((sp_cons)($a))(({
  first: $v,
  second: $k,
}))))))))($core$SPCore$Nil))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: 2,
  second: ($corelib$Maybe$Just)(true),
})))((($core$SPCore$Cons)(({
  first: 4,
  second: $corelib$Maybe$Nothing,
})))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($corelib$Hash_Test$valueTest)("each"))((() => {
  const $a = ({
    attr: "$",
    obj: ({
      $: (array_fromList)($core$SPCore$Nil),
    }),
  });
  ((hash_each)(($corelib$Hash$fromList)((($core$SPCore$Cons)(({
    first: ($corelib$Maybe$Just)(true),
    second: 2,
  })))((($core$SPCore$Cons)(({
    first: $corelib$Maybe$Nothing,
    second: 1,
  })))($core$SPCore$Nil)))))((($k) => (($v) => (($corelib$List$each)((($corelib$List$range)(1))($v)))((() => ((array_push)($a))($k))))));
  ((array_sortBy)($a))($corelib$Basics$identity);
  return (sp_clone)(($a.obj)[$a.attr]);
})))(($sp$Test$isOkAndEqualTo)((array_fromList)((($core$SPCore$Cons)(($corelib$Maybe$Just)(true)))((($core$SPCore$Cons)(($corelib$Maybe$Just)(true)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil))))))))($core$SPCore$Nil)))))));

const $corelib$List$all = (($fun) => (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return true;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return (($fun)($h)
      ? (($corelib$List$all)($fun))($t)
      : false);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 18:4', (sp_toHuman)($$try));
}))()));

const $corelib$List$any = (($fun) => (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return false;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return (($fun)($h)
      ? true
      : (($corelib$List$any)($fun))($t));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 11:4', (sp_toHuman)($$try));
}))()));

const $corelib$List$reverse = (($aList) => ((($corelib$List$foldl)($core$SPCore$Cons))($aList))($core$SPCore$Nil));

const $corelib$List$foldr = (($f) => (($list) => (($init) => {
  const $foldrHelper = (($acc) => (($ctr) => (($ls) => ((() => {
    const $$try = $ls;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return $acc;
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $a = ($$try)[1];
      const $r1 = ($$try)[2];
      return ((() => {
        const $$try = $r1;
        if (("$core$SPCore$Nil" === ($$try)[0])) {
          return (($f)($a))($acc);
        }
        if (("$core$SPCore$Cons" === ($$try)[0])) {
          const $b = ($$try)[1];
          const $r2 = ($$try)[2];
          return ((() => {
            const $$try = $r2;
            if (("$core$SPCore$Nil" === ($$try)[0])) {
              return (($f)($a))((($f)($b))($acc));
            }
            if (("$core$SPCore$Cons" === ($$try)[0])) {
              const $c = ($$try)[1];
              const $r3 = ($$try)[2];
              return ((() => {
                const $$try = $r3;
                if (("$core$SPCore$Nil" === ($$try)[0])) {
                  return (($f)($a))((($f)($b))((($f)($c))($acc)));
                }
                if (("$core$SPCore$Cons" === ($$try)[0])) {
                  const $d = ($$try)[1];
                  const $r4 = ($$try)[2];
                  const $res = (($ctr > 500)
                    ? ((($corelib$List$foldl)($f))(($corelib$List$reverse)($r4)))($acc)
                    : ((($foldrHelper)($acc))(($ctr + 1)))($r4));
                  return (($f)($a))((($f)($b))((($f)($c))((($f)($d))($res))));
                  return null;
                }
                (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 98:32', (sp_toHuman)($$try));
              }))();
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 93:24', (sp_toHuman)($$try));
          }))();
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 88:16', (sp_toHuman)($$try));
      }))();
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 83:8', (sp_toHuman)($$try));
  }))())));
  return ((($foldrHelper)($init))(0))($list);
})));

const $corelib$List$append = (($xs) => (($ys) => ((() => {
  const $$try = $ys;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $xs;
  }
  if (true) {
    return ((($corelib$List$foldr)($core$SPCore$Cons))($xs))($ys);
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 188:2', (sp_toHuman)($$try));
}))()));

const $corelib$List$concat = (($lists) => ((($corelib$List$foldr)($corelib$List$append))($lists))($core$SPCore$Nil));

const $corelib$List$map = (($f) => (($list) => ((($corelib$List$foldr)((($x) => (($acc) => ((sp_cons)($acc))(($f)($x))))))($list))($core$SPCore$Nil)));

const $corelib$List$concatMap = (($f) => (($list) => ($corelib$List$concat)((($corelib$List$map)($f))($list))));

const $corelib$List$drop = (($n) => (($ls) => (((sp_equal)(0))($n)
  ? $ls
  : ((() => {
    const $$try = $ls;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return $core$SPCore$Nil;
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $h = ($$try)[1];
      const $tail = ($$try)[2];
      return (($corelib$List$drop)(($n - 1)))($tail);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 351:6', (sp_toHuman)($$try));
  }))())));

const $corelib$List$filter = (($f) => (($ls) => ((($corelib$List$foldr)((($item) => (($acc) => (($f)($item)
  ? ((sp_cons)($acc))($item)
  : $acc)))))($ls))($core$SPCore$Nil)));

const $corelib$List$filterMap = (($f) => (($la) => {
  const $update = (($a) => (($acc) => ((() => {
    const $$try = ($f)($a);
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $b = ($$try)[1];
      return ((sp_cons)($acc))($b);
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return $acc;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 298:6', (sp_toHuman)($$try));
  }))()));
  return ((($corelib$List$foldr)($update))($la))($core$SPCore$Nil);
}));

const $corelib$List$find = (($test) => (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return (($test)($h)
      ? ($corelib$Maybe$Just)($h)
      : (($corelib$List$find)($test))($t));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 29:4', (sp_toHuman)($$try));
}))()));

const $corelib$List$foldlRes = (($f) => (($ls) => (($accum) => ((() => {
  const $$try = $ls;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($corelib$Result$Ok)($accum);
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return ((() => {
      const $$try = (($f)($h))($accum);
      if (("$corelib$Result$Err" === ($$try)[0])) {
        const $x = ($$try)[1];
        return ($corelib$Result$Err)($x);
        return null;
      }
      if (("$corelib$Result$Ok" === ($$try)[0])) {
        const $newAccum = ($$try)[1];
        return ((($corelib$List$foldlRes)($f))($t))($newAccum);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 154:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 149:4', (sp_toHuman)($$try));
}))())));

const $corelib$List$for = (($list) => (($fun) => (($corelib$List$foldl)($fun))($list)));

const $corelib$List$head = (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return ($corelib$Maybe$Just)($h);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 205:4', (sp_toHuman)($$try));
}))());

const $corelib$List$indexBy = (($getIndex) => (($list) => ((($corelib$List$foldl)((($i) => (($corelib$Dict$insert)(($getIndex)($i)))($i))))($list))($corelib$Dict$empty)));

const $corelib$List$indexedMap = (($f) => {
  const $rec = (($accum) => (($n) => (($list) => ((() => {
    const $$try = $list;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($corelib$List$reverse)($accum);
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $h = ($$try)[1];
      const $t = ($$try)[2];
      return ((($rec)(((sp_cons)($accum))((($f)($n))($h))))(($n + 1)))($t);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 179:8', (sp_toHuman)($$try));
  }))())));
  return (($rec)($core$SPCore$Nil))(0);
});

const $corelib$List$last = (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
    const $h = ($$try)[1];
    return ($corelib$Maybe$Just)($h);
    return null;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return ($corelib$List$last)($t);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 212:4', (sp_toHuman)($$try));
}))());

const $corelib$List$length = (($list) => ((($corelib$List$foldl)((() => (($a) => ($a + 1)))))($list))(0));

const $corelib$List$map2 = (($f) => {
  const $rec = (($accum) => (($ax) => (($bx) => ((() => {
    const $$try = ({
      first: $ax,
      second: $bx,
    });
    if ((("$core$SPCore$Cons" === ($$try.first)[0]) && ("$core$SPCore$Cons" === ($$try.second)[0]))) {
      const $ahead = ($$try.first)[1];
      const $atail = ($$try.first)[2];
      const $bhead = ($$try.second)[1];
      const $btail = ($$try.second)[2];
      return ((($rec)(((sp_cons)($accum))((($f)($ahead))($bhead))))($atail))($btail);
      return null;
    }
    if (true) {
      return ($corelib$List$reverse)($accum);
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 129:6', (sp_toHuman)($$try));
  }))())));
  return ($rec)($core$SPCore$Nil);
});

const $corelib$List$mapFirst = (($f) => (($ls) => ((() => {
  const $$try = $ls;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $tail = ($$try)[2];
    const $r = ($f)($h);
    return (((sp_equal)($corelib$Maybe$Nothing))($r)
      ? (($corelib$List$mapFirst)($f))($tail)
      : $r);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 307:4', (sp_toHuman)($$try));
}))()));

const $corelib$Result$map = (($f) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($corelib$Result$Err)($e);
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $a = ($$try)[1];
    return ($corelib$Result$Ok)(($f)($a));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 10:4', (sp_toHuman)($$try));
}))()));

const $corelib$List$mapRes = (($f) => (($list) => {
  const $fun = (($a) => (($acc) => (($corelib$Result$map)((($b) => ((sp_cons)($acc))($b))))(($f)($a))));
  return (($corelib$Result$map)($corelib$List$reverse))(((($corelib$List$foldlRes)($fun))($list))($core$SPCore$Nil));
}));

const $corelib$List$member = (($a) => (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return false;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $h = ($$try)[1];
    const $t = ($$try)[2];
    return (((sp_equal)($h))($a)
      ? true
      : (($corelib$List$member)($a))($t));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 40:4', (sp_toHuman)($$try));
}))()));

const $corelib$List$minimum = (($list) => ((() => {
  const $$try = $list;
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $x = ($$try)[1];
    const $xs = ($$try)[2];
    return ($corelib$Maybe$Just)(((($corelib$List$foldl)($corelib$Basics$min))($xs))($x));
    return null;
  }
  if (true) {
    return $corelib$Maybe$Nothing;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 358:4', (sp_toHuman)($$try));
}))());

const $corelib$List$repeat = (($n) => (($a) => {
  const $rec = (($c) => (($acc) => (($c > 0)
    ? (($rec)(($c - 1)))(((sp_cons)($acc))($a))
    : $acc)));
  return (($rec)($n))($core$SPCore$Nil);
}));

const $corelib$List$sort = (list_sortBy)($corelib$Basics$identity);

const $corelib$List$takeReverse = (($n) => (($list) => (($kept) => (($n < 1)
  ? $kept
  : ((() => {
    const $$try = $list;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return $kept;
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $x = ($$try)[1];
      const $xs = ($$try)[2];
      return ((($corelib$List$takeReverse)(($n - 1)))($xs))((($core$SPCore$Cons)($x))($kept));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 262:4', (sp_toHuman)($$try));
  }))()))));

const $corelib$List$takeTailRec = (($n) => (($list) => ($corelib$List$reverse)(((($corelib$List$takeReverse)($n))($list))($core$SPCore$Nil))));

const $corelib$List$takeFast = (($ctr) => (($n) => (($list) => (($n < 1)
  ? $core$SPCore$Nil
  : ((() => {
    const $$try = ({
      first: $n,
      second: $list,
    });
    if (("$core$SPCore$Nil" === ($$try.second)[0])) {
      return $list;
    }
    if (((1 === $$try.first) && ("$core$SPCore$Cons" === ($$try.second)[0]))) {
      const $x = ($$try.second)[1];
      return (($core$SPCore$Cons)($x))($core$SPCore$Nil);
      return null;
    }
    if (((2 === $$try.first) && (("$core$SPCore$Cons" === ($$try.second)[0]) && ("$core$SPCore$Cons" === (($$try.second)[2])[0])))) {
      const $x = ($$try.second)[1];
      const $y = (($$try.second)[2])[1];
      return (($core$SPCore$Cons)($x))((($core$SPCore$Cons)($y))($core$SPCore$Nil));
      return null;
    }
    if (((3 === $$try.first) && (("$core$SPCore$Cons" === ($$try.second)[0]) && (("$core$SPCore$Cons" === (($$try.second)[2])[0]) && ("$core$SPCore$Cons" === ((($$try.second)[2])[2])[0]))))) {
      const $x = ($$try.second)[1];
      const $y = (($$try.second)[2])[1];
      const $z = ((($$try.second)[2])[2])[1];
      return (($core$SPCore$Cons)($x))((($core$SPCore$Cons)($y))((($core$SPCore$Cons)($z))($core$SPCore$Nil)));
      return null;
    }
    if ((("$core$SPCore$Cons" === ($$try.second)[0]) && (("$core$SPCore$Cons" === (($$try.second)[2])[0]) && (("$core$SPCore$Cons" === ((($$try.second)[2])[2])[0]) && ("$core$SPCore$Cons" === (((($$try.second)[2])[2])[2])[0]))))) {
      const $x = ($$try.second)[1];
      const $y = (($$try.second)[2])[1];
      const $z = ((($$try.second)[2])[2])[1];
      const $w = (((($$try.second)[2])[2])[2])[1];
      const $tl = (((($$try.second)[2])[2])[2])[2];
      const $cons = $core$SPCore$Cons;
      return (($ctr > 1000)
        ? (($cons)($x))((($cons)($y))((($cons)($z))((($cons)($w))((($corelib$List$takeTailRec)(($n - 4)))($tl)))))
        : (($cons)($x))((($cons)($y))((($cons)($z))((($cons)($w))(((($corelib$List$takeFast)(($ctr + 1)))(($n - 4)))($tl))))));
      return null;
    }
    if (true) {
      return $list;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 228:4', (sp_toHuman)($$try));
  }))()))));

const $corelib$List$take = ($corelib$List$takeFast)(0);

const $corelib$List$takeWhile = (($test) => {
  const $rec = (($accum) => (($list) => ((() => {
    const $$try = $list;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($corelib$List$reverse)($accum);
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $head = ($$try)[1];
      const $tail = ($$try)[2];
      return (($test)($head)
        ? (($rec)(((sp_cons)($accum))($head)))($tail)
        : ($corelib$List$reverse)($accum));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'corelib/List.sp 275:6', (sp_toHuman)($$try));
  }))()));
  return ($rec)($core$SPCore$Nil);
});

const $corelib$List_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $corelib$List_Test$concat = (($sp$Test$Group)("concat"))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("concats two lists"))((() => ($corelib$List$concat)((($core$SPCore$Cons)((($core$SPCore$Cons)(1))((($core$SPCore$Cons)(2))($core$SPCore$Nil))))((($core$SPCore$Cons)((($core$SPCore$Cons)(3))((($core$SPCore$Cons)(4))($core$SPCore$Nil))))($core$SPCore$Nil))))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(1))((($core$SPCore$Cons)(2))((($core$SPCore$Cons)(3))((($core$SPCore$Cons)(4))($core$SPCore$Nil))))))))($core$SPCore$Nil));

const $corelib$List_Test$sortBy = (($sp$Test$Group)("sortBy"))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Can actually sort stuff"))((() => ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(($corelib$Maybe$Just)(23)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))((($core$SPCore$Cons)(($corelib$Maybe$Just)(11)))($core$SPCore$Nil)))))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(($corelib$Maybe$Just)(11)))((($core$SPCore$Cons)(($corelib$Maybe$Just)(23)))((($core$SPCore$Cons)($corelib$Maybe$Nothing))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Correctly orders tuple-2"))((() => ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(({
  first: 23,
  second: 1,
})))((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 11,
  second: 3,
})))($core$SPCore$Nil)))))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: 1,
  second: 2,
})))((($core$SPCore$Cons)(({
  first: 11,
  second: 3,
})))((($core$SPCore$Cons)(({
  first: 23,
  second: 1,
})))($core$SPCore$Nil)))))))((($core$SPCore$Cons)(((($corelib$List_Test$valueTest)("Correctly orders tuple-3"))((() => ((list_sortBy)($corelib$Basics$identity))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "2",
})))((($core$SPCore$Cons)(({
  first: "a",
  second: "b",
  third: "33",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "1",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "b",
  third: "3",
})))($core$SPCore$Nil))))))))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(({
  first: "a",
  second: "b",
  third: "33",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "1",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "a",
  third: "2",
})))((($core$SPCore$Cons)(({
  first: "z",
  second: "b",
  third: "3",
})))($core$SPCore$Nil))))))))($core$SPCore$Nil))));

const $corelib$List_Test$tests = (($sp$Test$Group)("SPCore/List"))((($core$SPCore$Cons)($corelib$List_Test$sortBy))((($core$SPCore$Cons)($corelib$List_Test$concat))($core$SPCore$Nil)));

const $corelib$Maybe$andThen = (($f) => (($ma) => ((() => {
  const $$try = $ma;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $a = ($$try)[1];
    return ($f)($a);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 9:4', (sp_toHuman)($$try));
}))()));

const $corelib$Maybe$map = (($f) => (($m) => ((() => {
  const $$try = $m;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return $corelib$Maybe$Nothing;
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $v = ($$try)[1];
    return ($corelib$Maybe$Just)(($f)($v));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 16:2', (sp_toHuman)($$try));
}))()));

const $corelib$Maybe$map2 = (($f) => (($ma) => (($mb) => (($corelib$Maybe$andThen)((($a) => (($corelib$Maybe$andThen)((($b) => ($corelib$Maybe$Just)((($f)($a))($b)))))($mb))))($ma))));

const $corelib$Maybe$map3 = (($f) => (($ma) => (($mb) => (($mc) => (($corelib$Maybe$andThen)((($a) => (($corelib$Maybe$andThen)((($b) => (($corelib$Maybe$andThen)((($c) => ($corelib$Maybe$Just)(((($f)($a))($b))($c)))))($mc))))($mb))))($ma)))));

const $corelib$Maybe$mapRes = (($f) => (($m) => ((() => {
  const $$try = $m;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ($corelib$Result$Ok)($corelib$Maybe$Nothing);
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $a = ($$try)[1];
    return (($corelib$Result$map)($corelib$Maybe$Just))(($f)($a));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 38:4', (sp_toHuman)($$try));
}))()));

const $corelib$Maybe$withDefault = (($default) => (($maybe) => ((() => {
  const $$try = $maybe;
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $v = ($$try)[1];
    return $v;
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return $default;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Maybe.sp 48:2', (sp_toHuman)($$try));
}))()));

const $corelib$Result$fromMaybe = (($err) => (($maybe) => ((() => {
  const $$try = $maybe;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ($corelib$Result$Err)($err);
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $a = ($$try)[1];
    return ($corelib$Result$Ok)($a);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 34:4', (sp_toHuman)($$try));
}))()));

const $corelib$Result$mapError = (($f) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $a = ($$try)[1];
    return ($corelib$Result$Ok)($a);
    return null;
  }
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e1 = ($$try)[1];
    return ($corelib$Result$Err)(($f)($e1));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 26:4', (sp_toHuman)($$try));
}))()));

const $corelib$Result$withDefault = (($default) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $a = ($$try)[1];
    return $a;
    return null;
  }
  if (("$corelib$Result$Err" === ($$try)[0])) {
    return $default;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Result.sp 42:4', (sp_toHuman)($$try));
}))()));

const $corelib$Set$diff = $corelib$Dict$diff;

const $corelib$Set$empty = $corelib$Dict$empty;

const $corelib$Set$insert = (($a) => (($corelib$Dict$insert)($a))(null));

const $corelib$Set$fromList = (($list) => ((($corelib$List$foldl)($corelib$Set$insert))($list))($corelib$Set$empty));

const $corelib$Set$intersect = $corelib$Dict$intersect;

const $corelib$Set$isEmpty = $corelib$Dict$isEmpty;

const $corelib$Set$join = $corelib$Dict$join;

const $corelib$Set$map = (($f) => (($set) => ((($corelib$Dict$foldl)((($k) => (() => (($corelib$Dict$insert)(($f)($k)))(null)))))($set))($corelib$Dict$empty)));

const $corelib$Set$member = $corelib$Dict$member;

const $corelib$Set$remove = $corelib$Dict$remove;

const $corelib$Set$singleton = (($a) => (($corelib$Dict$singleton)($a))(null));

const $corelib$Set$size = $corelib$Dict$size;

const $corelib$Set$toList = $corelib$Dict$keys;

const $corelib$Text$contains = (($sub) => (($str) => ((() => {
  const $$try = ((text_split)($sub))($str);
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
    return false;
  }
  if (true) {
    return true;
  }
  (sp_throw)('Missing pattern in try..as', 'corelib/Text.sp 115:4', (sp_toHuman)($$try));
}))()));

const $corelib$Text$dropRight = (($n) => (($s) => (($n > 0)
  ? (((text_slice)(0))((0 - $n)))($s)
  : $s)));

const $corelib$Text$repeat = (($n) => (($s) => (($corelib$Text$join)(""))((($corelib$List$repeat)($n))($s))));

const $corelib$Text$padLeft = (($minLength) => (($pad) => (($s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = ((sp_divide)((text_length)($pad)))(($textLength - $minLength));
      return ((($corelib$Text$repeat)($times))($pad) + $s);
    }))()
    : $s);
})));

const $corelib$Text$padRight = (($minLength) => (($pad) => (($s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = ((sp_divide)((text_length)($pad)))(($textLength - $minLength));
      return ($s + (($corelib$Text$repeat)($times))($pad));
    }))()
    : $s);
})));

const $corelib$Text$replace = (($toRemove) => (($toPut) => (($s) => (($corelib$Text$join)($toPut))(((text_split)($toRemove))($s)))));

const $corelib$Tuple$mapBoth = (($fa) => (($fb) => (($t) => ({
  first: ($fa)($t.first),
  second: ($fb)($t.second),
}))));

const $corelib$Tuple$mapFirst = (($f) => (($t) => ({
  first: ($f)($t.first),
  second: $t.second,
})));

const $corelib$Tuple$mapSecond = (($f) => (($t) => ({
  first: $t.first,
  second: ($f)($t.second),
})));

const $corelib$Tuple$pair = (($a) => (($b) => ({
  first: $a,
  second: $b,
})));

const $corelib$Tuple$second = (($t) => $t.second);

const $posix$IO$_run = (($never) => (($r) => {
  const neverToResult$$ = $r;
  const $neverToResult = (neverToResult$$)[1];
  return ($neverToResult)($never);
}));

const $posix$IO$fail = (($message) => ($posix$IO$IO)((($never) => ($corelib$Result$Err)($message))));

const $posix$IO$onResult = (($f) => (($m) => ($posix$IO$IO)((($never) => (($posix$IO$_run)($never))(($f)((($posix$IO$_run)($never))($m)))))));

const $posix$IO$onSuccess = (($f) => (($m) => ($posix$IO$IO)((($never) => ((() => {
  const $$try = (($posix$IO$_run)($never))($m);
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $a = ($$try)[1];
    return (($posix$IO$_run)($never))(($f)($a));
    return null;
  }
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($corelib$Result$Err)($e);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'posix/IO.sp 39:8', (sp_toHuman)($$try));
}))()))));

const $posix$IO$succeed = (($a) => ($posix$IO$IO)((($never) => ($corelib$Result$Ok)($a))));

const $sp$Compiler$CanonicalToJs$accessAttrs = (($attrPath) => (($e) => ((($corelib$List$foldl)($sp$Types$JavascriptAst$AccessWithDot))($attrPath))($e)));

const $sp$Compiler$CanonicalToJs$accessAttrsButTheLast = (($attrHead) => (($attrTail) => (($e) => {
  const $fold = (($attr) => ((expr$$) => {
    const $expr = expr$$.first;
    const $last = expr$$.second;
    return ({
      first: (($sp$Types$JavascriptAst$AccessWithDot)($last))($expr),
      second: $attr,
    });
  }));
  return ((($corelib$List$foldl)($fold))($attrTail))(({
    first: $e,
    second: $attrHead,
  }));
})));

const $sp$Compiler$CanonicalToJs$accessWithBracketsInt = (($index) => ($sp$Types$JavascriptAst$AccessWithBrackets)(($sp$Types$JavascriptAst$Var)((text_fromNumber)($index))));

const $sp$Compiler$CanonicalToJs$accessConstructorArg = $sp$Compiler$CanonicalToJs$accessWithBracketsInt;

const $sp$Compiler$CanonicalToJs$nativeBinops = ((($corelib$Dict$insert)("and"))(({
  fnName: "and",
  jsSymb: "&&",
  mutates: false,
})))(((($corelib$Dict$insert)("or"))(({
  fnName: "or",
  jsSymb: "||",
  mutates: false,
})))(((($corelib$Dict$insert)("<="))(({
  fnName: "lesserOrEqual",
  jsSymb: "<=",
  mutates: false,
})))(((($corelib$Dict$insert)(">="))(({
  fnName: "greaterOrEqual",
  jsSymb: ">=",
  mutates: false,
})))(((($corelib$Dict$insert)("<"))(({
  fnName: "lesserThan",
  jsSymb: "<",
  mutates: false,
})))(((($corelib$Dict$insert)(">"))(({
  fnName: "greaterThan",
  jsSymb: ">",
  mutates: false,
})))(((($corelib$Dict$insert)(".."))(({
  fnName: "strcon",
  jsSymb: "+",
  mutates: false,
})))(((($corelib$Dict$insert)("+="))(({
  fnName: "mutadd",
  jsSymb: "+=",
  mutates: true,
})))(((($corelib$Dict$insert)(":="))(({
  fnName: "mutass",
  jsSymb: "=",
  mutates: true,
})))(((($corelib$Dict$insert)("-"))(({
  fnName: "sub",
  jsSymb: "-",
  mutates: false,
})))(((($corelib$Dict$insert)("*"))(({
  fnName: "mul",
  jsSymb: "*",
  mutates: false,
})))(((($corelib$Dict$insert)("+"))(({
  fnName: "add",
  jsSymb: "+",
  mutates: false,
})))($corelib$Dict$empty))))))))))));

const $sp$Compiler$CoreTypes$umr = (($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore");

const $sp$Compiler$CoreTypes$makeUsr = ($sp$Types$Meta$USR)($sp$Compiler$CoreTypes$umr);

const $sp$Compiler$CoreTypes$false = ($sp$Compiler$CoreTypes$makeUsr)("False");

const $sp$Compiler$CoreTypes$noneName = "None";

const $sp$Compiler$CoreTypes$noneValue = ($sp$Compiler$CoreTypes$makeUsr)($sp$Compiler$CoreTypes$noneName);

const $sp$Compiler$CoreTypes$true = ($sp$Compiler$CoreTypes$makeUsr)("True");

const $sp$Compiler$CoreTypes$p = $sp$Types$Pos$N;

const $sp$Compiler$CoreTypes$defToType = (($def) => (($sp$Types$CanonicalAst$TypeConstant)($sp$Compiler$CoreTypes$p))($def.usr));

const $sp$Compiler$CoreTypes$numberDef = ({
  args: $core$SPCore$Nil,
  constructors: $corelib$Dict$empty,
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Number"),
});

const $sp$Compiler$CoreTypes$number = (($sp$Compiler$CoreTypes$defToType)($sp$Compiler$CoreTypes$numberDef))($core$SPCore$Nil);

const $sp$Prelude$tyFun = ($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N);

const $sp$Prelude$tyVar = ($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N);

const $sp$Prelude$compare = ({
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  type: ((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))($sp$Compiler$CoreTypes$number)),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("compare"),
});

const $sp$Compiler$CoreTypes$nameToType = (($name) => (($sp$Types$CanonicalAst$TypeConstant)($sp$Compiler$CoreTypes$p))(($sp$Compiler$CoreTypes$makeUsr)($name)));

const $sp$Compiler$CoreTypes$none = (($sp$Compiler$CoreTypes$nameToType)($sp$Compiler$CoreTypes$noneName))($core$SPCore$Nil);

const $sp$Prelude$debugBenchStart = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$none))(false))($sp$Compiler$CoreTypes$none),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("benchStart"),
});

const $sp$Compiler$CoreTypes$textDef = ({
  args: $core$SPCore$Nil,
  constructors: $corelib$Dict$empty,
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Text"),
});

const $sp$Compiler$CoreTypes$text = (($sp$Compiler$CoreTypes$defToType)($sp$Compiler$CoreTypes$textDef))($core$SPCore$Nil);

const $sp$Prelude$debugBenchStop = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))($sp$Compiler$CoreTypes$none),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("benchStop"),
});

const $sp$Prelude$debugLog = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("a"))),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("log"),
});

const $sp$Prelude$debugToHuman = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))($sp$Compiler$CoreTypes$text),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("toHuman"),
});

const $sp$Prelude$debugTodo = ({
  nonFn: $core$SPCore$Nil,
  type: ((($sp$Prelude$tyFun)($sp$Compiler$CoreTypes$text))(false))(($sp$Prelude$tyVar)("a")),
  usr: (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("todo"),
});

const $sp$Types$Meta$spCorePath = "SPCore";

const $sp$Types$Meta$spCoreUmr = (($sp$Types$Meta$UMR)($sp$Types$Meta$Core))($sp$Types$Meta$spCorePath);

const $sp$Types$Meta$spCoreUSR = ($sp$Types$Meta$USR)($sp$Types$Meta$spCoreUmr);

const $sp$Compiler$CanonicalToJs$allNatives = ((() => {
  const $corelib = (($m) => (($n) => (($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("corelib")))($m)))($n)));
  const $ioModule = ($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("posix")))("IO"));
  return ((($corelib$Dict$insert)(($ioModule)("writeStdout")))("io_writeStdout"))(((($corelib$Dict$insert)(($ioModule)("writeFile")))("io_writeFile"))(((($corelib$Dict$insert)(($ioModule)("readFile")))("io_readFile"))(((($corelib$Dict$insert)(($ioModule)("readDir")))("io_readDir"))(((($corelib$Dict$insert)(($ioModule)("parallel")))("io_parallel"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("/=")))("sp_not_equal"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("==")))("sp_equal"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("::")))("sp_cons"))(((($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)("/")))("sp_divide"))(((($corelib$Dict$insert)((($corelib)("List"))("sortBy")))("list_sortBy"))(((($corelib$Dict$insert)((($corelib)("Array"))("toList")))("array_toList"))(((($corelib$Dict$insert)((($corelib)("Array"))("fromList")))("array_fromList"))(((($corelib$Dict$insert)((($corelib)("Array"))("sortBy")))("array_sortBy"))(((($corelib$Dict$insert)((($corelib)("Array"))("set")))("array_set"))(((($corelib$Dict$insert)((($corelib)("Array"))("get")))("array_get"))(((($corelib$Dict$insert)((($corelib)("Array"))("pop")))("array_pop"))(((($corelib$Dict$insert)((($corelib)("Array"))("push")))("array_push"))(((($corelib$Dict$insert)((($corelib)("Hash"))("each")))("hash_each"))(((($corelib$Dict$insert)((($corelib)("Hash"))("for")))("hash_for"))(((($corelib$Dict$insert)((($corelib)("Hash"))("get")))("hash_get"))(((($corelib$Dict$insert)((($corelib)("Hash"))("remove")))("hash_remove"))(((($corelib$Dict$insert)((($corelib)("Hash"))("insert")))("hash_insert"))(((($corelib$Dict$insert)((($corelib)("Hash"))("empty")))("hash_empty"))(((($corelib$Dict$insert)((($corelib)("Text"))("forEach")))("text_forEach"))(((($corelib$Dict$insert)((($corelib)("Text"))("dropLeft")))("text_dropLeft"))(((($corelib$Dict$insert)((($corelib)("Text"))("trimLeft")))("text_trimLeft"))(((($corelib$Dict$insert)((($corelib)("Text"))("replaceRegex")))("text_replaceRegex"))(((($corelib$Dict$insert)((($corelib)("Text"))("startsWithRegex")))("text_startsWithRegex"))(((($corelib$Dict$insert)((($corelib)("Text"))("startsWith")))("text_startsWith"))(((($corelib$Dict$insert)((($corelib)("Text"))("slice")))("text_slice"))(((($corelib$Dict$insert)((($corelib)("Text"))("length")))("text_length"))(((($corelib$Dict$insert)((($corelib)("Text"))("split")))("text_split"))(((($corelib$Dict$insert)((($corelib)("Text"))("toNumber")))("text_toNumber"))(((($corelib$Dict$insert)((($corelib)("Text"))("fromNumber")))("text_fromNumber"))(((($corelib$Dict$insert)((($corelib)("Basics"))("modBy")))("basics_modBy"))(((($corelib$Dict$insert)($sp$Prelude$compare.usr))("basics_compare"))(((($corelib$Dict$insert)($sp$Prelude$debugBenchStop.usr))("sp_benchStop"))(((($corelib$Dict$insert)($sp$Prelude$debugBenchStart.usr))("sp_benchStart"))(((($corelib$Dict$insert)($sp$Prelude$debugToHuman.usr))("sp_toHuman"))(((($corelib$Dict$insert)($sp$Prelude$debugTodo.usr))("sp_todo"))(((($corelib$Dict$insert)($sp$Prelude$debugLog.usr))("sp_log"))(((($corelib$Dict$insert)($sp$Compiler$CoreTypes$noneValue))("null"))(((($corelib$Dict$insert)($sp$Compiler$CoreTypes$false))("false"))(((($corelib$Dict$insert)($sp$Compiler$CoreTypes$true))("true"))(((($corelib$Dict$for)($sp$Compiler$CanonicalToJs$nativeBinops))((($symbol) => (($v) => (($corelib$Dict$insert)(($sp$Types$Meta$spCoreUSR)($symbol)))($v.fnName)))))($corelib$Dict$empty)))))))))))))))))))))))))))))))))))))))))))));
}))();

const $sp$Compiler$CanonicalToJs$translateSource = (($src) => ((() => {
  const $$try = $src;
  if (("$sp$Types$Meta$Core" === ($$try)[0])) {
    return "core";
  }
  if (("$sp$Types$Meta$SourceDir" === ($$try)[0])) {
    const $path = ($$try)[1];
    return (((sp_equal)(""))(((text_startsWithRegex)("[a-zA-Z0-9_./]*$"))($path))
      ? (sp_todo)(("Invalid chars in source dir name: " + $path))
      : ((($corelib$Text$replace)("/"))("$"))(((($corelib$Text$replace)("."))("_"))($path)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 274:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$CanonicalToJs$translateUsr = (($usr) => ((() => {
  const $$try = (($corelib$Dict$get)($usr))($sp$Compiler$CanonicalToJs$allNatives);
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $nv = ($$try)[1];
    return $nv;
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    const modulePath$$ = $usr;
    const $name = (modulePath$$)[2];
    const $modulePath = ((modulePath$$)[1])[2];
    const $source = ((modulePath$$)[1])[1];
    return ("$" + (($sp$Compiler$CanonicalToJs$translateSource)($source) + ("$" + (((($corelib$Text$replace)("/"))("$"))($modulePath) + ("$" + $name)))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 259:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$CanonicalToJs$translateRef = (($ref) => ((() => {
  const $$try = $ref;
  if (("$sp$Types$CanonicalAst$RefBlock" === ($$try)[0])) {
    const $name = ($$try)[1];
    return ("$" + $name);
    return null;
  }
  if (("$sp$Types$CanonicalAst$RefRoot" === ($$try)[0])) {
    const $usr = ($$try)[1];
    return ($sp$Compiler$CanonicalToJs$translateUsr)($usr);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 248:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$CanonicalToJs$assignPattern = (($nameToReference) => (($insert) => (($pattern) => (($exprAccum) => (($accum) => ((() => {
  const $$try = $pattern;
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Nothing" === (($$try)[2])[0]))) {
    return $accum;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[2])[0]))) {
    const $name = (($$try)[2])[1];
    return ((($insert)($name))((($sp$Types$JavascriptAst$Define)(($sp$Compiler$CanonicalToJs$translateRef)(($nameToReference)($name))))($exprAccum)))($accum);
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
    return $accum;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
    return $accum;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
    const $path = ($$try)[2];
    const $pas = ($$try)[3];
    const $foldEveryArgument = ((index$$) => {
      const $index = index$$.first;
      const $pa = index$$.second;
      return (((($sp$Compiler$CanonicalToJs$assignPattern)($nameToReference))($insert))($pa))((($sp$Compiler$CanonicalToJs$accessConstructorArg)(($index + 1)))($exprAccum));
    });
    return ((($corelib$List$foldl)($foldEveryArgument))((($corelib$List$indexedMap)($corelib$Tuple$pair))($pas)))($accum);
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
    const $attrs = ($$try)[2];
    return ((($corelib$Dict$for)($attrs))((($name) => (($pa) => (((($sp$Compiler$CanonicalToJs$assignPattern)($nameToReference))($insert))($pa))((($sp$Types$JavascriptAst$AccessWithDot)($name))($exprAccum))))))($accum);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 937:4', (sp_toHuman)($$try));
}))())))));

const $sp$Compiler$CanonicalToJs$binopChain = (($default) => (($op) => (($es) => ((() => {
  const $$try = $es;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $default;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $head = ($$try)[1];
    const $tail = ($$try)[2];
    return ((($corelib$List$foldl)(($sp$Types$JavascriptAst$Binop)($op)))($tail))($head);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 807:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$CanonicalToJs$circularIsError = (($nodesByUsr) => (($usrs) => (($corelib$List$any)((($usr) => ((() => {
  const $$try = (($corelib$Dict$get)($usr))($nodesByUsr);
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return false;
  }
  if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Compiler$CanonicalToJs$NodeName" === (($$try)[1])[0]))) {
    return true;
  }
  if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Compiler$CanonicalToJs$NodeDef" === (($$try)[1])[0]))) {
    const $def = (($$try)[1])[2];
    return ((() => {
      const $$try = $def.body;
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$CanonicalAst$Evaluation" === (($$try)[1])[0]) && (("$sp$Types$CanonicalAst$Lambda" === ((($$try)[1])[1])[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))))) {
        return false;
      }
      if (true) {
        return true;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 438:14', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 429:6', (sp_toHuman)($$try));
}))())))($usrs)));

const $sp$Compiler$CanonicalToJs$clone = (($expr) => (($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Var)("sp_clone")))((($core$SPCore$Cons)($expr))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs$constructorArgumentName = (($i) => ("$" + (text_fromNumber)($i)));

const $sp$Compiler$CanonicalToJs$defIsFunction = (($def) => ((() => {
  const $$try = $def.body;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$CanonicalAst$Evaluation" === (($$try)[1])[0]) && ("$sp$Types$CanonicalAst$Lambda" === ((($$try)[1])[1])[0])))) {
    return true;
  }
  if (true) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 333:4', (sp_toHuman)($$try));
}))());

const $sp$Types$CanonicalAst$patternNames = (($p) => ((() => {
  const $$try = $p;
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Nothing" === (($$try)[2])[0]))) {
    const $pos = ($$try)[1];
    return $corelib$Dict$empty;
    return null;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[2])[0]))) {
    const $pos = ($$try)[1];
    const $n = (($$try)[2])[1];
    return (($corelib$Dict$singleton)($n))($pos);
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $corelib$Dict$empty;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $corelib$Dict$empty;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $path = ($$try)[2];
    const $ps = ($$try)[3];
    return ((($corelib$List$foldl)((($x) => ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($x)))))($ps))($corelib$Dict$empty);
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ps = ($$try)[2];
    return ((($corelib$Dict$foldl)((($k) => (($v) => ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($v))))))($ps))($corelib$Dict$empty);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 205:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$CanonicalToJs$getValueDefName = (($def) => (($corelib$Maybe$withDefault)("BLARGH"))(($corelib$List$head)(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($def.pattern)))));

const $sp$Compiler$CoreTypes$cons = ($sp$Compiler$CoreTypes$makeUsr)("Cons");

const $sp$Compiler$CanonicalToJs$listCons = ($sp$Compiler$CanonicalToJs$translateUsr)($sp$Compiler$CoreTypes$cons);

const $sp$Compiler$CoreTypes$nil = ($sp$Compiler$CoreTypes$makeUsr)("Nil");

const $sp$Compiler$CanonicalToJs$listNil = ($sp$Compiler$CanonicalToJs$translateUsr)($sp$Compiler$CoreTypes$nil);

const $sp$Compiler$CanonicalToJs$makeUsr = (($module) => (($name) => (($sp$Types$Meta$USR)($module.umr))($name)));

const $sp$Compiler$CanonicalToJs$maybeCloneMutable = (($caDef) => (($expr) => ((() => {
  const $$try = ({
    first: $caDef.mutable,
    second: ($corelib$List$reverse)($caDef.body),
  });
  if (((true === $$try.first) && (("$core$SPCore$Cons" === ($$try.second)[0]) && (("$sp$Types$CanonicalAst$Evaluation" === (($$try.second)[1])[0]) && ("$sp$Types$CanonicalAst$Variable" === ((($$try.second)[1])[1])[0]))))) {
    const $ar = ((($$try.second)[1])[1])[2];
    return ($sp$Compiler$CanonicalToJs$clone)($expr);
    return null;
  }
  if (true) {
    return $expr;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 498:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$CanonicalToJs$none = ($sp$Compiler$CanonicalToJs$translateUsr)($sp$Compiler$CoreTypes$noneValue);

const $sp$Compiler$CanonicalToJs$quoteAndEscape = (($s) => {
  const $escaped = ((($corelib$Text$replace)("\""))("\\\""))(((($corelib$Text$replace)("\n"))("\\n"))($s));
  return ("\"" + ($escaped + "\""));
});

const $sp$Prelude$typeUnopUniform = (($type) => ((($sp$Prelude$tyFun)($type))(false))($type));

const $sp$Prelude$unaryMinus = ({
  symbol: "0 -",
  type: ($sp$Prelude$typeUnopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$unaryPlus = ({
  symbol: "0 +",
  type: ($sp$Prelude$typeUnopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Compiler$CanonicalToJs$nativeUnops = ((($corelib$Dict$insert)($sp$Prelude$unaryMinus.symbol))(({
  jsSymb: "-",
})))(((($corelib$Dict$insert)($sp$Prelude$unaryPlus.symbol))(({
  jsSymb: "+",
})))($corelib$Dict$empty));

const $sp$Compiler$CanonicalToJs$maybeNativeUnop = (($env) => (($reference) => (($argument) => ((() => {
  const $$try = $reference;
  if ((("$sp$Types$CanonicalAst$Variable" === ($$try)[0]) && (("$sp$Types$CanonicalAst$RefRoot" === (($$try)[2].ref)[0]) && ("$sp$Types$Meta$USR" === ((($$try)[2].ref)[1])[0])))) {
    const $name = ((($$try)[2].ref)[1])[2];
    return ((() => {
      const $$try = (($corelib$Dict$get)($name))($sp$Compiler$CanonicalToJs$nativeUnops);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $corelib$Maybe$Nothing;
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $jsSymb = ($$try)[1].jsSymb;
        return ($corelib$Maybe$Just)((($sp$Types$JavascriptAst$Unop)($jsSymb))($argument));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 763:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return $corelib$Maybe$Nothing;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 761:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$CanonicalToJs$patternDefinitions = (($mainName) => (($pattern) => ((() => {
  const $$try = $pattern;
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[2])[0]))) {
    const $pos = ($$try)[1];
    return $core$SPCore$Nil;
    return null;
  }
  if (true) {
    return ((((($sp$Compiler$CanonicalToJs$assignPattern)($sp$Types$CanonicalAst$RefBlock))((() => (($s) => (($a) => ((sp_cons)($a))($s))))))($pattern))(($sp$Types$JavascriptAst$Var)($mainName)))($core$SPCore$Nil);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 964:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$CanonicalToJs$pickMainName = (($pattern) => {
  const $x = ((() => {
    const $$try = $pattern;
    if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[2])[0]))) {
      const $name = (($$try)[2])[1];
      return ($corelib$Maybe$Just)(("$" + $name));
      return null;
    }
    if (true) {
      return (($corelib$Maybe$map)((($s) => ($s + "$$"))))(($corelib$List$head)(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($pattern))));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 300:8', (sp_toHuman)($$try));
  }))();
  return (($corelib$Maybe$map)((($s) => ((($corelib$Text$replace)("."))("$"))(((($corelib$Text$replace)("/"))("$"))($s)))))($x);
});

const $sp$Compiler$CanonicalToJs$testPattern = (($pattern) => (($valueToTest) => (($accum) => ((() => {
  const $$try = $pattern;
  if (("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0])) {
    return $accum;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
    const $text = ($$try)[2];
    return ((sp_cons)($accum))(((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)($text))))($valueToTest));
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
    const $num = ($$try)[2];
    return ((sp_cons)($accum))(((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)((text_fromNumber)($num))))($valueToTest));
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
    const $usr = ($$try)[2];
    const $pas = ($$try)[3];
    const $head = ((() => {
      const $$try = (($corelib$Dict$get)($usr))($sp$Compiler$CanonicalToJs$allNatives);
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $nv = ($$try)[1];
        return ((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)($nv)))($valueToTest);
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ((($sp$Types$JavascriptAst$Binop)("==="))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)))))((($sp$Compiler$CanonicalToJs$accessWithBracketsInt)(0))($valueToTest));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 913:16', (sp_toHuman)($$try));
    }))();
    const $foldArg = (($argPattern) => ((acc$$) => {
      const $index = acc$$.first;
      const $acc = acc$$.second;
      return ({
        first: ($index + 1),
        second: ((($sp$Compiler$CanonicalToJs$testPattern)($argPattern))((($sp$Compiler$CanonicalToJs$accessWithBracketsInt)($index))($valueToTest)))($acc),
      });
    }));
    return ($corelib$Tuple$second)(((($corelib$List$foldl)($foldArg))($pas))(({
      first: 1,
      second: ((sp_cons)($accum))($head),
    })));
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
    const $attrs = ($$try)[2];
    const $foldAttr = (($name) => (($pa) => (($sp$Compiler$CanonicalToJs$testPattern)($pa))((($sp$Types$JavascriptAst$AccessWithDot)($name))($valueToTest))));
    return ((($corelib$Dict$foldl)($foldAttr))($attrs))($accum);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 900:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$CanonicalToJs$translateBodyToExpr = (($env) => (($caBody) => ((() => {
  const $$try = ((($sp$Compiler$CanonicalToJs$translateBodyToEither)($env))($core$SPCore$Nil))($caBody);
  if (("$sp$Compiler$CanonicalToJs$Left" === ($$try)[0])) {
    const $e = ($$try)[1];
    return $e;
    return null;
  }
  if (("$sp$Compiler$CanonicalToJs$Right" === ($$try)[0])) {
    const $block = ($$try)[1];
    return (($sp$Types$JavascriptAst$Call)((($sp$Types$JavascriptAst$BlockLambda)($core$SPCore$Nil))($block)))($core$SPCore$Nil);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 822:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$CanonicalToJs$wrapMutable = (($mutable) => (($expr) => ($mutable
  ? ($sp$Types$JavascriptAst$Record)(((($corelib$Dict$insert)("obj"))(($sp$Types$JavascriptAst$Record)((($corelib$Dict$singleton)("$"))($expr))))(((($corelib$Dict$insert)("attr"))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)("$"))))($corelib$Dict$empty)))
  : $expr)));

const $sp$Compiler$CanonicalToJs$translateLocalValueDef = (($env) => (($caDef) => (((sp_equal)($core$SPCore$Nil))($caDef.body)
  ? ({
    first: $core$SPCore$Nil,
    second: $env,
  })
  : ((() => {
    const $$try = ($sp$Compiler$CanonicalToJs$pickMainName)($caDef.pattern);
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return ({
        first: (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Eval)((($sp$Compiler$CanonicalToJs$translateBodyToExpr)($env))($caDef.body))))($core$SPCore$Nil),
        second: $env,
      });
    }
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $mainName = ($$try)[1];
      const $a = (($sp$Types$JavascriptAst$Define)($mainName))((($sp$Compiler$CanonicalToJs$wrapMutable)($caDef.mutable))((($sp$Compiler$CanonicalToJs$maybeCloneMutable)($caDef))((($sp$Compiler$CanonicalToJs$translateBodyToExpr)($env))($caDef.body))));
      const $b = ($caDef.mutable
        ? (Object.assign)({}, $env, ({
          mutables: (($corelib$Set$insert)($mainName))($env.mutables),
        }))
        : $env);
      return ({
        first: ((sp_cons)((($sp$Compiler$CanonicalToJs$patternDefinitions)($mainName))($caDef.pattern)))($a),
        second: $b,
      });
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 511:8', (sp_toHuman)($$try));
  }))())));

const $sp$Compiler$CanonicalToJs$translateStatement = (($env) => (($s) => ((() => {
  const $$try = $s;
  if (("$sp$Types$CanonicalAst$Definition" === ($$try)[0])) {
    const $def = ($$try)[1];
    return (($sp$Compiler$CanonicalToJs$translateLocalValueDef)($env))($def);
    return null;
  }
  if (("$sp$Types$CanonicalAst$Evaluation" === ($$try)[0])) {
    const $expr = ($$try)[1];
    return ({
      first: (($core$SPCore$Cons)(($sp$Types$JavascriptAst$Eval)((($sp$Compiler$CanonicalToJs$translateExpr)($env))($expr))))($core$SPCore$Nil),
      second: $env,
    });
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 535:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$CanonicalToJs$translateBodyToEither = (($env) => (($extra) => (($caBody) => {
  const env1$$ = ((($corelib$List$for)($caBody))((($caStat) => ((envX0$$) => {
    const $statsAccum = envX0$$.first;
    const $envX0 = envX0$$.second;
    const envX1$$ = (($sp$Compiler$CanonicalToJs$translateStatement)($envX0))($caStat);
    const $envX1 = envX1$$.second;
    const $newStats = envX1$$.first;
    const $allStats = ((($corelib$List$for)($newStats))((($stat) => (($acc) => ((sp_cons)($acc))($stat)))))($statsAccum);
    return ({
      first: $allStats,
      second: $envX1,
    });
  }))))(({
    first: $extra,
    second: $env,
  }));
  const $env1 = env1$$.second;
  const $reversedStats = env1$$.first;
  return ((() => {
    const $$try = $reversedStats;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($sp$Compiler$CanonicalToJs$Left)(($sp$Types$JavascriptAst$Var)("null"));
    }
    if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$JavascriptAst$Eval" === (($$try)[1])[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0])))) {
      const $single = (($$try)[1])[1];
      return ($sp$Compiler$CanonicalToJs$Left)($single);
      return null;
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $oldLast = ($$try)[1];
      const $rest = ($$try)[2];
      const $theParserContinuesSucking = ((() => {
        const $$try = $oldLast;
        if (("$sp$Types$JavascriptAst$Eval" === ($$try)[0])) {
          const $expr = ($$try)[1];
          return ((sp_cons)($rest))(($sp$Types$JavascriptAst$Return)($expr));
          return null;
        }
        if (true) {
          return ((sp_cons)(((sp_cons)($rest))($oldLast)))(($sp$Types$JavascriptAst$Return)(($sp$Types$JavascriptAst$Var)($sp$Compiler$CanonicalToJs$none)));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 857:16', (sp_toHuman)($$try));
      }))();
      return ($sp$Compiler$CanonicalToJs$Right)(($corelib$List$reverse)($theParserContinuesSucking));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 846:4', (sp_toHuman)($$try));
  }))();
})));

const $sp$Compiler$CanonicalToJs$unwrapMutable = (($x) => {
  const $ja_x = ($sp$Types$JavascriptAst$Var)($x);
  return (($sp$Types$JavascriptAst$AccessWithBrackets)((($sp$Types$JavascriptAst$AccessWithDot)("attr"))($ja_x)))((($sp$Types$JavascriptAst$AccessWithDot)("obj"))($ja_x));
});

const $sp$Compiler$CanonicalToJs$translateVar = (($env) => (($varArgs) => {
  const attrPath$$ = $varArgs;
  const $ref = attrPath$$.ref;
  const $attrPath = attrPath$$.attrPath;
  const $jname = ($sp$Compiler$CanonicalToJs$translateRef)($ref);
  return ((($corelib$Set$member)($jname))($env.mutables)
    ? ($sp$Compiler$CanonicalToJs$clone)((($sp$Compiler$CanonicalToJs$accessAttrs)($attrPath))(($sp$Compiler$CanonicalToJs$unwrapMutable)($jname)))
    : (($sp$Compiler$CanonicalToJs$accessAttrs)($attrPath))(($sp$Types$JavascriptAst$Var)($jname)));
}));

const $sp$Compiler$CanonicalToJs$tryName = "$$try";

const $sp$Compiler$Error$positionToLineAndColumn = (($s) => (($index) => {
  const $before = (((text_slice)(0))($index))($s);
  const $lines = ((text_split)("\n"))($before);
  const $lineNumber = ($corelib$List$length)($lines);
  const $colNumber = (($corelib$Maybe$withDefault)(0))((($corelib$Maybe$map)(text_length))(($corelib$List$last)($lines)));
  return ({
    col: $colNumber,
    line: $lineNumber,
  });
}));

const $sp$Compiler$Error$highlightSplit = (($h) => (($x) => {
  const lines$$ = $x;
  const $lines = lines$$.second;
  const $words = lines$$.first;
  return ((() => {
    const $$try = $h;
    if (("$sp$Compiler$Error$HighlightWord" === ($$try)[0])) {
      const $colEnd = ($$try)[1].colEnd;
      const $colStart = ($$try)[1].colStart;
      const $line = ($$try)[1].line;
      return ({
        first: ((($corelib$Dict$insert)($line))(({
          first: $colStart,
          second: $colEnd,
        })))($words),
        second: $lines,
      });
      return null;
    }
    if (("$sp$Compiler$Error$HighlightBlock" === ($$try)[0])) {
      const $lineEnd = ($$try)[1].lineEnd;
      const $lineStart = ($$try)[1].lineStart;
      return ({
        first: $words,
        second: ((($corelib$List$foldl)($corelib$Set$insert))((($corelib$List$range)($lineStart))($lineEnd)))($lines),
      });
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 141:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Compiler$Error$formatSeparator = "$|$|$";

const $sp$Compiler$Error$formatSuffix = "$`$`$";

const $sp$Compiler$Error$formatWrap = (($fmtName) => (($text) => ($sp$Compiler$Error$formatSeparator + ($fmtName + ($sp$Compiler$Error$formatSuffix + ($text + $sp$Compiler$Error$formatSeparator))))));

const $sp$Compiler$Error$warn = ($sp$Compiler$Error$formatWrap)("warning");

const $sp$Compiler$Error$fmtBlock = (($start) => (($highlights) => (($ls) => {
  const highlightedLines$$ = ((($corelib$List$foldl)($sp$Compiler$Error$highlightSplit))($highlights))(({
    first: $corelib$Dict$empty,
    second: $corelib$Set$empty,
  }));
  const $highlightedLines = highlightedLines$$.second;
  const $highlightedWords = highlightedLines$$.first;
  const $pad = (text_length)((text_fromNumber)(($start + ($corelib$List$length)($ls))));
  const $wordHighlight = (($lineNumber) => ((() => {
    const $$try = (($corelib$Dict$get)($lineNumber))($highlightedWords);
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return "";
    }
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $s = ($$try)[1].first;
      const $e = ($$try)[1].second;
      return ("\n" + ((($corelib$Text$repeat)($pad))(" ") + ("   " + ((($corelib$Text$repeat)(($s - 1)))(" ") + ($sp$Compiler$Error$warn)((($corelib$Text$repeat)((($corelib$Basics$max)(1))(($e - $s))))("^"))))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 162:8', (sp_toHuman)($$try));
  }))());
  const $lineDem = (($lineIndex) => ((($corelib$Set$member)($lineIndex))($highlightedLines)
    ? ($sp$Compiler$Error$warn)(" > ")
    : " | "));
  const $fmtLine = (($i) => (($line) => {
    const $index = ($i + $start);
    const $s = ((($corelib$Text$padLeft)($pad))(" "))((text_fromNumber)($index));
    return ($s + (($lineDem)($index) + ($line + ($wordHighlight)($index))));
  }));
  return ((($s) => ($s + "\n")))((($corelib$Text$join)("\n"))((($corelib$List$indexedMap)($fmtLine))($ls)));
})));

const $sp$Compiler$Error$showCodeBlock = (($code) => (($start) => (($end) => (($end.line < 0)
  ? ""
  : ((() => {
    const $highlight = (((sp_not_equal)($end.line))($start.line)
      ? ($sp$Compiler$Error$HighlightBlock)(({
        lineEnd: $end.line,
        lineStart: $start.line,
      }))
      : ($sp$Compiler$Error$HighlightWord)(({
        colEnd: $end.col,
        colStart: $start.col,
        line: $start.line,
      })));
    const $extraLines = 2;
    const $lines = ((text_split)("\n"))($code);
    const $maxLines = ($corelib$List$length)($lines);
    const $startLine = ((($corelib$Basics$clamp)(0))(($maxLines - 1)))(($start.line - ($extraLines - 1)));
    const $endLine = ((($corelib$Basics$clamp)(0))(($maxLines - 1)))(($end.line + $extraLines));
    const $size = (($corelib$Basics$max)(1))(($endLine - $startLine));
    return ((($sp$Compiler$Error$fmtBlock)(($startLine + 1)))((($core$SPCore$Cons)($highlight))($core$SPCore$Nil)))((($corelib$List$take)($size))((($corelib$List$drop)($startLine))($lines)));
  }))()))));

const $sp$Compiler$Error$posToHuman = (($eEnv) => (($pos) => {
  const $noBlock = (($loc) => ({
    block: "",
    location: $loc,
  }));
  return ((() => {
    const $$try = $pos;
    if (("$sp$Types$Pos$P" === ($$try)[0])) {
      const $moduleName = ($$try)[1];
      const $startAsInt = ($$try)[2];
      const $endAsInt = ($$try)[3];
      return ((() => {
        const $$try = (($corelib$Dict$get)($moduleName))($eEnv.moduleByName);
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $mod = ($$try)[1];
          const $start = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))($startAsInt);
          const $end = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))($endAsInt);
          return ({
            block: ((($sp$Compiler$Error$showCodeBlock)($mod.content))($start))($end),
            location: ($mod.fsPath + (" " + ((text_fromNumber)($start.line) + (":" + (text_fromNumber)($start.col))))),
          });
          return null;
        }
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 252:12', (sp_toHuman)($$try));
      }))();
      return null;
    }
    if (("$sp$Types$Pos$End" === ($$try)[0])) {
      const $moduleName = ($$try)[1];
      return ((() => {
        const $$try = (($corelib$Dict$get)($moduleName))($eEnv.moduleByName);
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $mod = ($$try)[1];
          const $end = (($sp$Compiler$Error$positionToLineAndColumn)($mod.content))(((text_length)($mod.content) - 1));
          const $start = ({
            col: 0,
            line: ($end.line - 8),
          });
          return ({
            block: ((($sp$Compiler$Error$showCodeBlock)($mod.content))($start))($end),
            location: ($mod.fsPath + (" " + ((text_fromNumber)($end.line) + ":0 (end of file)"))),
          });
          return null;
        }
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 268:12', (sp_toHuman)($$try));
      }))();
      return null;
    }
    if (("$sp$Types$Pos$N" === ($$try)[0])) {
      return ($noBlock)("<native code>");
    }
    if (("$sp$Types$Pos$S" === ($$try)[0])) {
      return ($noBlock)("<the location information has been stripped>");
    }
    if (("$sp$Types$Pos$T" === ($$try)[0])) {
      return ($noBlock)("<defined in test modules>");
    }
    if (("$sp$Types$Pos$I" === ($$try)[0])) {
      const $n = ($$try)[1];
      return ($noBlock)(("<inferred " + ((text_fromNumber)($n) + ">")));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 250:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Compiler$CanonicalToJs$translateExpr = (($env) => (($expression) => ((() => {
  const $$try = $expression;
  if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try)[0])) {
    const $num = ($$try)[2];
    return ($sp$Types$JavascriptAst$Literal)((text_fromNumber)($num));
    return null;
  }
  if (("$sp$Types$CanonicalAst$LiteralText" === ($$try)[0])) {
    const $text = ($$try)[2];
    return ($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)($text));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Variable" === ($$try)[0])) {
    const $ar = ($$try)[2];
    return (($sp$Compiler$CanonicalToJs$translateVar)($env))($ar);
    return null;
  }
  if (("$sp$Types$CanonicalAst$Constructor" === ($$try)[0])) {
    const $usr = ($$try)[2];
    return ((() => {
      const $$try = (($corelib$Dict$get)($usr))($sp$Compiler$CanonicalToJs$allNatives);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ($sp$Types$JavascriptAst$Var)(($sp$Compiler$CanonicalToJs$translateUsr)($usr));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $n = ($$try)[1];
        return ($sp$Types$JavascriptAst$Var)($n);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 573:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$Lambda" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $parameter = ($$try)[2];
    const $body = ($$try)[3];
    const args$$ = ((() => {
      const $$try = $parameter;
      if (("$sp$Types$CanonicalAst$ParameterMutable" === ($$try)[0])) {
        const $name = ($$try)[2];
        const $jaName = ("$" + $name);
        return ({
          first: (($core$SPCore$Cons)($jaName))($core$SPCore$Nil),
          second: $core$SPCore$Nil,
          third: (Object.assign)({}, $env, ({
            mutables: (($corelib$Set$insert)($jaName))($env.mutables),
          })),
        });
        return null;
      }
      if (("$sp$Types$CanonicalAst$ParameterPattern" === ($$try)[0])) {
        const $pattern = ($$try)[1];
        return ((() => {
          const $$try = ($sp$Compiler$CanonicalToJs$pickMainName)($pattern);
          if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
            return ({
              first: $core$SPCore$Nil,
              second: $core$SPCore$Nil,
              third: $env,
            });
          }
          if (("$corelib$Maybe$Just" === ($$try)[0])) {
            const $mainName = ($$try)[1];
            return ({
              first: (($core$SPCore$Cons)($mainName))($core$SPCore$Nil),
              second: (($sp$Compiler$CanonicalToJs$patternDefinitions)($mainName))($pattern),
              third: $env,
            });
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 588:24', (sp_toHuman)($$try));
        }))();
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 581:16', (sp_toHuman)($$try));
    }))();
    const $localEnv = args$$.third;
    const $extraJaStatements = args$$.second;
    const $args = args$$.first;
    return ((() => {
      const $$try = ((($sp$Compiler$CanonicalToJs$translateBodyToEither)($localEnv))($extraJaStatements))($body);
      if (("$sp$Compiler$CanonicalToJs$Left" === ($$try)[0])) {
        const $expr = ($$try)[1];
        return (($sp$Types$JavascriptAst$SimpleLambda)($args))($expr);
        return null;
      }
      if (("$sp$Compiler$CanonicalToJs$Right" === ($$try)[0])) {
        const $block = ($$try)[1];
        return (($sp$Types$JavascriptAst$BlockLambda)($args))($block);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 595:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$Record" === ($$try)[0])) {
    const $extends = ($$try)[2];
    const $attrs = ($$try)[3];
    const $obj = ($sp$Types$JavascriptAst$Record)((($corelib$Dict$map)((($k) => ($sp$Compiler$CanonicalToJs$translateExpr)($env))))($attrs));
    return ((() => {
      const $$try = $extends;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $obj;
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $extend = ($$try)[1];
        return (($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Var)("Object.assign")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Record)($corelib$Dict$empty)))((($core$SPCore$Cons)((($sp$Compiler$CanonicalToJs$translateVar)($env))($extend)))((($core$SPCore$Cons)($obj))($core$SPCore$Nil))));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 607:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$Call" === ($$try)[0])) {
    const $ref = ($$try)[2];
    const $arg = ($$try)[3];
    return ((() => {
      const $$try = ((($sp$Compiler$CanonicalToJs$maybeNativeBinop)($env))($ref))($arg);
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $jaExpr = ($$try)[1];
        return $jaExpr;
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        const $jsArg = ((($sp$Compiler$CanonicalToJs$translateArg)(({
          nativeBinop: false,
        })))($env))($arg);
        return ((() => {
          const $$try = ((($sp$Compiler$CanonicalToJs$maybeNativeUnop)($env))($ref))($jsArg);
          if (("$corelib$Maybe$Just" === ($$try)[0])) {
            const $jaExpr = ($$try)[1];
            return $jaExpr;
            return null;
          }
          if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
            return (($sp$Types$JavascriptAst$Call)((($sp$Compiler$CanonicalToJs$translateExpr)($env))($ref)))((($core$SPCore$Cons)($jsArg))($core$SPCore$Nil));
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 626:20', (sp_toHuman)($$try));
        }))();
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 619:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$If" === ($$try)[0])) {
    const $ar = ($$try)[2];
    return ((($sp$Types$JavascriptAst$Conditional)((($sp$Compiler$CanonicalToJs$translateBodyToExpr)($env))($ar.condition)))((($sp$Compiler$CanonicalToJs$translateBodyToExpr)($env))($ar.true)))((($sp$Compiler$CanonicalToJs$translateBodyToExpr)($env))($ar.false));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Try" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $value = ($$try)[2];
    const $tries = ($$try)[3];
    const $head = (($sp$Types$JavascriptAst$Define)($sp$Compiler$CanonicalToJs$tryName))((($sp$Compiler$CanonicalToJs$translateExpr)($env))($value));
    const $init = ($sp$Types$JavascriptAst$Var)($sp$Compiler$CanonicalToJs$tryName);
    const $testPa = ((block$$) => {
      const $pattern = block$$.first;
      const $block = block$$.second;
      const $extraStats = ((((($sp$Compiler$CanonicalToJs$assignPattern)($sp$Types$CanonicalAst$RefBlock))((() => (($stat) => (($acc) => ((sp_cons)($acc))($stat))))))($pattern))(($sp$Types$JavascriptAst$Var)($sp$Compiler$CanonicalToJs$tryName)))($core$SPCore$Nil);
      const $condition = ((($sp$Compiler$CanonicalToJs$binopChain)(($sp$Types$JavascriptAst$Literal)("true")))("&&"))(((($sp$Compiler$CanonicalToJs$testPattern)($pattern))($init))($core$SPCore$Nil));
      const $whenConditionMatches = ((() => {
        const $$try = ((($sp$Compiler$CanonicalToJs$translateBodyToEither)($env))($extraStats))($block);
        if (("$sp$Compiler$CanonicalToJs$Left" === ($$try)[0])) {
          const $e = ($$try)[1];
          return ($corelib$List$concat)((($core$SPCore$Cons)($extraStats))((($core$SPCore$Cons)((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)($e)))($core$SPCore$Nil)))($core$SPCore$Nil)));
          return null;
        }
        if (("$sp$Compiler$CanonicalToJs$Right" === ($$try)[0])) {
          const $bl = ($$try)[1];
          return ($corelib$List$concat)((($core$SPCore$Cons)($bl))((($core$SPCore$Cons)((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Return)(($sp$Types$JavascriptAst$Literal)("null"))))($core$SPCore$Nil)))($core$SPCore$Nil)));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 675:20', (sp_toHuman)($$try));
      }))();
      return (($sp$Types$JavascriptAst$If)($condition))($whenConditionMatches);
    });
    const $human = (($sp$Compiler$Error$posToHuman)($env.errorEnv))($pos);
    const $default = ($sp$Types$JavascriptAst$Eval)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Literal)("sp_throw")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Literal)("'Missing pattern in try..as'")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Literal)(("'" + ($human.location + "'")))))((($core$SPCore$Cons)((($sp$Types$JavascriptAst$Call)(($sp$Types$JavascriptAst$Literal)("sp_toHuman")))((($core$SPCore$Cons)(($sp$Types$JavascriptAst$Var)($sp$Compiler$CanonicalToJs$tryName)))($core$SPCore$Nil))))($core$SPCore$Nil)))));
    const $allStatements = ($corelib$List$concat)((($core$SPCore$Cons)(((sp_cons)((($corelib$List$map)($testPa))($tries)))($head)))((($core$SPCore$Cons)((($core$SPCore$Cons)($default))($core$SPCore$Nil)))($core$SPCore$Nil)));
    return (($sp$Types$JavascriptAst$Call)((($sp$Types$JavascriptAst$BlockLambda)($core$SPCore$Nil))($allStatements)))($core$SPCore$Nil);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 562:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$CanonicalToJs$translateArg = (($stuff) => (($env) => (($arg) => {
  const nativeBinop$$ = $stuff;
  const $nativeBinop = nativeBinop$$.nativeBinop;
  return ((() => {
    const $$try = $arg;
    if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try)[0])) {
      const $e = ($$try)[1];
      return (($sp$Compiler$CanonicalToJs$translateExpr)($env))($e);
      return null;
    }
    if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try)[0])) {
      const $attrPath = ($$try)[2].attrPath;
      const $ref = ($$try)[2].ref;
      return ($nativeBinop
        ? (($sp$Compiler$CanonicalToJs$accessAttrs)($attrPath))(($sp$Compiler$CanonicalToJs$unwrapMutable)(($sp$Compiler$CanonicalToJs$translateRef)($ref)))
        : ((() => {
          const $$try = $attrPath;
          if (("$core$SPCore$Nil" === ($$try)[0])) {
            return ($sp$Types$JavascriptAst$Var)(($sp$Compiler$CanonicalToJs$translateRef)($ref));
          }
          if (("$core$SPCore$Cons" === ($$try)[0])) {
            const $head = ($$try)[1];
            const $tail = ($$try)[2];
            return (((lastAttrName$$) => {
              const $wrappedExpr = lastAttrName$$.first;
              const $lastAttrName = lastAttrName$$.second;
              return ($sp$Types$JavascriptAst$Record)(((($corelib$Dict$insert)("attr"))(($sp$Types$JavascriptAst$Literal)(($sp$Compiler$CanonicalToJs$quoteAndEscape)($lastAttrName))))(((($corelib$Dict$insert)("obj"))($wrappedExpr))($corelib$Dict$empty)));
            }))(((($sp$Compiler$CanonicalToJs$accessAttrsButTheLast)($head))($tail))(($sp$Compiler$CanonicalToJs$unwrapMutable)(($sp$Compiler$CanonicalToJs$translateRef)($ref))));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 720:16', (sp_toHuman)($$try));
        }))());
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 706:4', (sp_toHuman)($$try));
  }))();
})));

const $sp$Compiler$CanonicalToJs$maybeNativeBinop = (($env) => (($reference) => (($argument) => ((() => {
  const $$try = $reference;
  if ((("$sp$Types$CanonicalAst$Call" === ($$try)[0]) && (("$sp$Types$CanonicalAst$Variable" === (($$try)[2])[0]) && (("$sp$Types$CanonicalAst$RefRoot" === ((($$try)[2])[2].ref)[0]) && ("$sp$Types$Meta$USR" === (((($$try)[2])[2].ref)[1])[0]))))) {
    const $name = (((($$try)[2])[2].ref)[1])[2];
    const $rightArg = ($$try)[3];
    return ((() => {
      const $$try = (($corelib$Dict$get)($name))($sp$Compiler$CanonicalToJs$nativeBinops);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $corelib$Maybe$Nothing;
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $jsSymb = ($$try)[1].jsSymb;
        const $mutates = ($$try)[1].mutates;
        const $cons = ($mutates
          ? (($sp$Types$JavascriptAst$Mutop)($jsSymb))($sp$Compiler$CanonicalToJs$none)
          : ($sp$Types$JavascriptAst$Binop)($jsSymb));
        const $z = (($cons)(((($sp$Compiler$CanonicalToJs$translateArg)(({
          nativeBinop: true,
        })))($env))($argument)))(((($sp$Compiler$CanonicalToJs$translateArg)(({
          nativeBinop: true,
        })))($env))($rightArg));
        return ($corelib$Maybe$Just)($z);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 783:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (true) {
    return $corelib$Maybe$Nothing;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 780:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$CanonicalToJs$nativeBinopToFunction = (($spName) => (($stuff) => (($acc) => {
  const fnName$$ = $stuff;
  const $mutates = fnName$$.mutates;
  const $jsSymb = fnName$$.jsSymb;
  const $fnName = fnName$$.fnName;
  const $d = $sp$Types$Pos$N;
  const $usr = ($sp$Compiler$CoreTypes$makeUsr)($spName);
  const $a = (($sp$Types$JavascriptAst$Define)($fnName))((($sp$Compiler$CanonicalToJs$translateBodyToExpr)(({
    errorEnv: ({
      moduleByName: $corelib$Dict$empty,
    }),
    mutables: $corelib$Set$empty,
  })))((($core$SPCore$Cons)(($sp$Types$CanonicalAst$Evaluation)(((($sp$Types$CanonicalAst$Lambda)($d))(($sp$Types$CanonicalAst$ParameterPattern)(((($sp$Types$CanonicalAst$PatternAny)($d))(($corelib$Maybe$Just)("a")))($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(($sp$Types$CanonicalAst$Evaluation)(((($sp$Types$CanonicalAst$Lambda)($d))(($sp$Types$CanonicalAst$ParameterPattern)(((($sp$Types$CanonicalAst$PatternAny)($d))(($corelib$Maybe$Just)("b")))($corelib$Maybe$Nothing))))((($core$SPCore$Cons)(($sp$Types$CanonicalAst$Evaluation)(((($sp$Types$CanonicalAst$Call)($d))(((($sp$Types$CanonicalAst$Call)($d))((($sp$Types$CanonicalAst$Variable)($d))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Types$CanonicalAst$RefRoot)($usr),
  }))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($d))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Types$CanonicalAst$RefBlock)("a"),
  }))))))((($mutates
    ? ($sp$Types$CanonicalAst$ArgumentMutable)($d)
    : (($x) => ($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($d))($x)))))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Types$CanonicalAst$RefBlock)("b"),
  }))))))($core$SPCore$Nil)))))($core$SPCore$Nil)))))($core$SPCore$Nil)));
  return ((sp_cons)($acc))($a);
})));

const $sp$Compiler$CanonicalToJs$nativeBinopsAsFns = ((($corelib$Dict$foldl)($sp$Compiler$CanonicalToJs$nativeBinopToFunction))($sp$Compiler$CanonicalToJs$nativeBinops))($core$SPCore$Nil);

const $sp$Compiler$CanonicalToJs$nativeDefinitions = ("#!/usr/bin/env node\n\n//Error.stackTraceLimit = 100;\n\n\nconst { performance } = require('perf_hooks');\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n/*  HACK\n\n    TODO this is super brittle\n    once we have a proper Platform system in place, the platform can probably\n    use its internal Meta to figure out the proper constructor\n\n*/\nconst maybe_nothing = [ \"$corelib$Maybe$Nothing\" ];\nconst maybe_just = (a) => [ \"$corelib$Maybe$Just\", a ];\n\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a) => (b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i])(b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k])(b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a) => (b) => {\n  return !sp_equal(a)(b);\n}\n\n\nconst sp_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = sp_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = sp_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (right) => (left) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\nconst basics_modBy = (a) => (b) => b % a;\n\nconst basics_compare = (a) => (b) => sp_compare(a, b);\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message) => (thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\nprocess.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.info(\"\");\n        console.info(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.info(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst sp_toHuman = (a) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a) || sp_toHumanAsUnion(a);\n\n  if (typeof a === 'function') {\n    return '<function>';\n  }\n\n  if (typeof a === 'object') {\n    let x = [];\n    for (let i in a) x.push(i + ' = ' + sp_toHuman(a[i]));\n    return '{' + x.join(', ') + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a) => {\n  return a[0] + ' ' + a.slice(1).map(arg => '(' + sp_toHuman(arg) + ')').join(' ');\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list) => {\n  if (list[0] === '" + ($sp$Compiler$CanonicalToJs$listCons + ("') {\n    arrayAccum.push(sp_toHuman(list[1]));\n    return sp_toHumanAsList(arrayAccum, list[2]);\n  }\n\n  if (list[0] === '" + ($sp$Compiler$CanonicalToJs$listNil + ("')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ? maybe_nothing : maybe_just(n);\n}\n\nconst text_split = (separator) => (target) => array_toList(target.split(separator));\n\nconst text_length = (s) => s.length;\n\nconst text_slice = (start) => (end) => (s) => s.slice(start, end);\n\nconst text_startsWith = (sub) => (s) => s.startsWith(sub);\n\nconst text_startsWithRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp('^' + regex);\n  } catch (e) {\n    return () => \"\"\n  }\n\n  return (s) => {\n    let m = s.match(re);\n    return m ? m[0] : \"\";\n  }\n}\n\nconst text_replaceRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp(regex, 'g');\n  } catch (e) {\n    return () => () => \"\"\n  }\n\n  return (replacer) => (s) => s.replace(re, replacer);\n}\n\nconst text_trimLeft = (s) => {\n  return s.trimLeft();\n}\n\nconst text_dropLeft = (n) => (s) => {\n  return s.slice(n);\n}\n\nconst text_forEach = (s) => (f) => {\n  for (let i of s) f(i);\n  return null;\n}\n\n\n//\n// Hashes\n//\n\nconst hash_empty = {};\n\n\nconst hash_insert = (hash) => (key) => (value) => {\n    const h = hash.obj[hash.attr];\n    h[JSON.stringify(key)] = [key, value];\n    return null;\n}\n\n\nconst hash_remove = (hash) => (key) => {\n    const h = hash.obj[hash.attr];\n    delete h[JSON.stringify(key)];\n    return null;\n}\n\n\nconst hash_get = (hash) => (key) => {\n    const r = hash[JSON.stringify(key)];\n    return r === undefined ? maybe_nothing : maybe_just(r[1]);\n}\n\n\nconst hash_for = (hash) => (f) => (acc) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        acc = f(kv[0])(kv[1])(acc);\n    }\n    return acc;\n}\n\n\nconst hash_each = (hash) => (f) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        f(kv[0])(kv[1]);\n    }\n    return null;\n}\n\n\n//\n// Arrays\n//\n\nconst array_push = (array) => (item) => {\n    array.obj[array.attr].push(item);\n    return null;\n}\n\nconst array_pop = (array) => {\n    const a = array.obj[array.attr];\n    return a.length ? maybe_just(a.pop()) : maybe_nothing;\n}\n\nconst array_get = (array) => (index) => {\n    const r = array[index];\n    return r === undefined ? maybe_nothing : maybe_just(r);\n}\n\nconst array_set = (array) => (index) => (item) => {\n    if (index < 0) return false;\n    const a = array.obj[array.attr];\n    if (index >= a.length) return false;\n    a[index] = item;\n    return true;\n}\n\nconst array_sortBy = (array) => (f) => {\n    const arr = array.obj[array.attr];\n    arr.sort((a, b) => sp_compare(f(a), f(b)));\n    return null;\n}\n\nconst array_toList = (array) => {\n  let length = array.length;\n  let list = [ '" + ($sp$Compiler$CanonicalToJs$listNil + ("' ];\n  for (let i = length - 1; i >= 0; i--) {\n      list = [ '" + ($sp$Compiler$CanonicalToJs$listCons + ("', array[i], list ];\n  }\n  return list;\n}\n\nconst array_fromList = (list) => {\n  const array = [];\n  const rec = (ls) => {\n    if (ls[0] === '" + ($sp$Compiler$CanonicalToJs$listNil + ("')\n      return array;\n\n    array.push(ls[1]);\n    return rec(ls[2]);\n  };\n\n  return rec(list);\n}\n\n\n\n//\n// Lists\n//\n\n\nconst sp_cons = (list) => (item) => {\n  return [ '" + ($sp$Compiler$CanonicalToJs$listCons + "', item, list];\n}\n\nconst list_sortBy = (f) => (list) => array_toList(array_fromList(list).sort((a, b) => sp_compare(f(a), f(b))));\n\n\n//\n// Platform: IO\n//\nconst fs = require('fs');\n\nconst io_wrap = (f) => [ \"IO.IO\", f ];\n\nconst io_parallel = (iosAsList) => io_wrap((never) => {\n    // as [IO a]: IO [a]\n\n    const ios = array_fromList(iosAsList);\n\n    // TODO actually run them in parallel!\n\n    let arr = [];\n    for (let io of ios) {\n        const r = io[1](never);\n        if (r[0] === \"$corelib$Result$Ok\")\n            arr.push(r[1]);\n        else\n            return $corelib$Result$Err(r[1]);\n    }\n\n    return $corelib$Result$Ok(array_toList(arr));\n});\n\n\nconst io_readDir = (dirPath) => io_wrap((never) => {\n    // as Text: IO [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(array_toList(entries.map((dirent) => ({\n        first: dirent.isDirectory(),\n        second: dirent.name,\n    }))));\n});\n\n\nconst io_readFile = (path) => io_wrap((never) => {\n    // as Text: IO Text\n\n    var content;\n    try {\n        content = fs.readFileSync(path, 'utf8');\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(content);\n});\n\n\nconst io_writeFile = (path) => (content) => io_wrap((never) => {\n    // as Text: Text: IO None\n\n    try {\n        fs.writeFileSync(path, content);\n    } catch (e) {\n        return $corelib$Result$Err(e.message);\n    }\n\n    return $corelib$Result$Ok(null);\n});\n\n\nconst io_writeStdout = (content) => io_wrap((never) => {\n    // as Text: IO None\n\n    console.info(content);\n    return $corelib$Result$Ok(null);\n});\n\n    "))))))))))));

const $sp$Compiler$CanonicalToJs$not_ = (($bool) => ($bool
  ? false
  : true));

const $sp$RefHierarchy$resolve = (($getEdges) => (($target) => (($path) => (($state0) => ((($corelib$List$member)($target))($state0.resolved)
  ? $state0
  : ((($corelib$List$member)($target))($path)
    ? ((() => {
      const $circ = ((sp_cons)((($corelib$List$takeWhile)((($key) => ((sp_not_equal)($target))($key))))($path)))($target);
      return (Object.assign)({}, $state0, ({
        circular: ((($corelib$Dict$insert)(($corelib$Set$fromList)($circ)))($circ))($state0.circular),
      }));
    }))()
    : ((() => {
      const $s = ((($corelib$Dict$for)(($getEdges)($target)))((($a) => (() => ((($sp$RefHierarchy$resolve)($getEdges))($a))(((sp_cons)($path))($target))))))($state0);
      return (Object.assign)({}, $s, ({
        resolved: ((sp_cons)($s.resolved))($target),
      }));
    }))()))))));

const $sp$RefHierarchy$reorder = (($nodeToEdges) => (($nodesById) => {
  const $keyToEdges = (($id) => ((() => {
    const $$try = (($corelib$Dict$get)($id))($nodesById);
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return $corelib$Set$empty;
    }
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $node = ($$try)[1];
      return ($nodeToEdges)($node);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/RefHierarchy.sp 44:8', (sp_toHuman)($$try));
  }))());
  const $state0 = ({
    circular: $corelib$Dict$empty,
    resolved: $core$SPCore$Nil,
  });
  const $stateF = ((($corelib$Dict$for)($nodesById))((($k) => (($v) => ((($sp$RefHierarchy$resolve)($keyToEdges))($k))($core$SPCore$Nil)))))($state0);
  return ({
    first: ($corelib$Dict$values)($stateF.circular),
    second: ($corelib$List$reverse)($stateF.resolved),
  });
}));

const $sp$Compiler$CanonicalToJs$reorderModuleValues = (($modules) => {
  (sp_benchStart)(null);
  const $nodesByUsr = ((($corelib$List$for)($modules))((($module) => (($corelib$Dict$for)($module.valueDefs))((() => (($def) => (($accum) => ((() => {
    const $$try = $def.pattern;
    if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[2])[0]))) {
      const $name = (($$try)[2])[1];
      const $usr = (($sp$Compiler$CanonicalToJs$makeUsr)($module))($name);
      return ((($corelib$Dict$member)($usr))($sp$Compiler$CanonicalToJs$allNatives)
        ? $accum
        : ((($corelib$Dict$insert)($usr))((($sp$Compiler$CanonicalToJs$NodeDef)($usr))($def)))($accum));
      return null;
    }
    if (true) {
      return ((() => {
        const $$try = ($sp$Compiler$CanonicalToJs$pickMainName)($def.pattern);
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return $accum;
        }
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $mainName = ($$try)[1];
          const $mainUsr = (($sp$Compiler$CanonicalToJs$makeUsr)($module))($mainName);
          const $jsStatementsByUsr = ((((($sp$Compiler$CanonicalToJs$assignPattern)((($n) => ($sp$Types$CanonicalAst$RefRoot)((($sp$Compiler$CanonicalToJs$makeUsr)($module))($n)))))((($n) => (($stat) => (($corelib$Dict$insert)((($sp$Compiler$CanonicalToJs$makeUsr)($module))($n)))($stat)))))($def.pattern))(($sp$Types$JavascriptAst$Var)($mainName)))($corelib$Dict$empty);
          return ((($corelib$Dict$for)($jsStatementsByUsr))((($usr) => (($stat) => (($a) => ((($corelib$Dict$insert)($usr))((($sp$Compiler$CanonicalToJs$NodeName)($mainUsr))($stat)))($a))))))(((($corelib$Dict$insert)($mainUsr))((($sp$Compiler$CanonicalToJs$NodeDef)($mainUsr))($def)))($accum));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 376:28', (sp_toHuman)($$try));
      }))();
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 367:20', (sp_toHuman)($$try));
  }))())))))))($corelib$Dict$empty);
  const $nodeToDeps = (($node) => ((() => {
    const $$try = $node;
    if (("$sp$Compiler$CanonicalToJs$NodeName" === ($$try)[0])) {
      const $d_usr = ($$try)[1];
      return ($corelib$Set$singleton)($d_usr);
      return null;
    }
    if (("$sp$Compiler$CanonicalToJs$NodeDef" === ($$try)[0])) {
      const $usr = ($$try)[1];
      const $def = ($$try)[2];
      return $def.directValueDeps;
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 399:8', (sp_toHuman)($$try));
  }))());
  const circulars$$ = (($sp$RefHierarchy$reorder)($nodeToDeps))($nodesByUsr);
  const $reorderedNodes = circulars$$.second;
  const $circulars = circulars$$.first;
  (sp_benchStop)("reorderModuleValues");
  const $errors = (($corelib$List$filter)(($sp$Compiler$CanonicalToJs$circularIsError)($nodesByUsr)))($circulars);
  return (((sp_not_equal)($core$SPCore$Nil))($errors)
    ? ($corelib$Result$Err)($errors)
    : ($corelib$Result$Ok)((($corelib$List$filterMap)((($usr) => (($corelib$Dict$get)($usr))($nodesByUsr))))($reorderedNodes)));
});

const $sp$Compiler$CanonicalToJs$translateNode = (($env) => (($node) => ((() => {
  const $$try = $node;
  if (("$sp$Compiler$CanonicalToJs$NodeName" === ($$try)[0])) {
    const $usr = ($$try)[1];
    const $jaStatement = ($$try)[2];
    return $jaStatement;
    return null;
  }
  if (("$sp$Compiler$CanonicalToJs$NodeDef" === ($$try)[0])) {
    const $usr = ($$try)[1];
    const $valueDef = ($$try)[2];
    return (($sp$Types$JavascriptAst$Define)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)))((($sp$Compiler$CanonicalToJs$translateBodyToExpr)($env))($valueDef.body));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 481:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$CanonicalToJs$translateUnionConstructor = (($usr) => (($stuff) => {
  const args$$ = $stuff;
  const $type = args$$.type;
  const $args = args$$.args;
  const $n = ($corelib$List$length)($args);
  const $range = (($corelib$List$range)(1))($n);
  const $storedArgs = (($corelib$List$map)((($x) => ($sp$Types$JavascriptAst$Var)(($sp$Compiler$CanonicalToJs$constructorArgumentName)($x)))))($range);
  const $name = ($sp$Compiler$CanonicalToJs$quoteAndEscape)(($sp$Compiler$CanonicalToJs$translateUsr)($usr));
  const $expr = ($sp$Types$JavascriptAst$Array)(((sp_cons)($storedArgs))(($sp$Types$JavascriptAst$Literal)($name)));
  const $lambdas = ((($corelib$List$foldr)((($i) => ($sp$Types$JavascriptAst$SimpleLambda)((($core$SPCore$Cons)(($sp$Compiler$CanonicalToJs$constructorArgumentName)($i)))($core$SPCore$Nil)))))($range))($expr);
  return (($sp$Types$JavascriptAst$Define)(($sp$Compiler$CanonicalToJs$translateUsr)($usr)))($lambdas);
}));

const $sp$Compiler$CanonicalToJs$translateAll = (($eenv) => (($globals) => (($modules) => ((() => {
  const $$try = ($sp$Compiler$CanonicalToJs$reorderModuleValues)($modules);
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $circular = ($$try)[1];
    ((sp_log)("translateAll: circular"))("");
    (($corelib$List$each)($circular))((($usr) => ((sp_log)("^"))($usr)));
    return (sp_todo)("translateAll circular");
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $nodes = ($$try)[1];
    const $env = ({
      errorEnv: $eenv,
      mutables: $corelib$Set$empty,
    });
    const $values = (($corelib$List$map)(($sp$Compiler$CanonicalToJs$translateNode)($env)))($nodes);
    const $constructors = ((($corelib$Dict$for)($globals.constructors))((($usr) => (($cons) => (($acc) => ((($corelib$Dict$member)($usr))($sp$Compiler$CanonicalToJs$allNatives)
      ? $acc
      : ((sp_cons)($acc))((($sp$Compiler$CanonicalToJs$translateUnionConstructor)($usr))($cons))))))))($core$SPCore$Nil);
    return ($corelib$List$concat)((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs$nativeBinopsAsFns))((($core$SPCore$Cons)($constructors))((($core$SPCore$Cons)($values))($core$SPCore$Nil))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/CanonicalToJs.sp 449:4', (sp_toHuman)($$try));
}))())));

const $sp$Test$codeTest = (($toText) => (($title) => (($code) => (($functionToTest) => (($ce) => {
  const toMaybeError$$ = $ce;
  const $toMaybeError = (toMaybeError$$)[1];
  return ((($sp$Test$Single)($title))($code))((() => ($sp$Test$maybeToOutcome)((($toMaybeError)($toText))(($functionToTest)($code)))));
})))));

const $sp$Compiler$CanonicalToJs_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$CanonicalToJs_Test$eval = (($value) => (($code) => ($corelib$Result$Ok)("CanonicalToJS.eval not implemented")));

const $sp$Compiler$CanonicalToJs_Test$ifs = (($sp$Test$Group)("ifs"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("a =\n  if True:\n    1\n  else\n    2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("1"))))($core$SPCore$Nil));

const $sp$Compiler$CanonicalToJs_Test$misc = (($sp$Test$Group)("misc"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("definitions and mutations return None"))("x =\n  m @= 0\n\ny =\n  m @= 0\n  @m += 1\n\na =\n  { x, y }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("{\"x\":null,\"y\":null}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("Cons"))("a = 1 :: []"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("[\"SPCore.Cons\",1,[\"SPCore.Nil\"]]"))))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs_Test$mutation = (($sp$Test$Group)("mutation"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("a =\n  m @= 0\n  @m += 1\n  x = m\n  @m := 10\n  y = m\n  @m += 1\n  z = m\n  { x, y, z, m }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.a")))(($sp$Test$isOkAndEqualTo)("{\"m\":11,\"x\":1,\"y\":10,\"z\":11}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("nested record"))("record = { x = { y = { z = 4 } } }\n\nresult =\n   m @= record\n   @m.x.y :=  { z = 1 }\n   @m.x.y.z += 1\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"x\":{\"y\":{\"z\":2}}}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("pass mutable to function"))("fun @m =\n  @m += 55\n\nresult =\n   m @= 2\n   fun @m\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("57"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("pass nested mutable value to function"))("fun @m =\n  @m += 55\n\nrecord = { x = { y = { z = 4 } } }\n\nresult =\n   m @= record\n   fun @m.x.y.z\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"x\":{\"y\":{\"z\":59}}}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("[reg] mut args should be dereferenced and cloned"))("result =\n    l @= 3\n    f @l\n\nf @a =\n    as Number @: Number\n    a"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("3"))))($core$SPCore$Nil))))));

const $sp$Test$errorContains = (($snippets) => ($sp$Test$CodeExpectation)((($toText) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $ok = ($$try)[1];
    return ($corelib$Maybe$Just)(("I was expecting an error, but got: Ok " + ($toText)($ok)));
    return null;
  }
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    const $missing = (($corelib$List$filter)((($sn) => ($corelib$Basics$not)((($corelib$Text$contains)($sn))($e)))))($snippets);
    return (((sp_equal)($core$SPCore$Nil))($missing)
      ? $corelib$Maybe$Nothing
      : ((() => {
        const $indentedError = (($corelib$Text$join)("\n"))((($corelib$List$map)((($l) => ("    " + $l))))(((text_split)("\n"))($e)));
        return ($corelib$Maybe$Just)(("Error message:\n\n" + ($indentedError + ("\n\nis missing snippets: " + (($corelib$Text$join)(", "))($missing)))));
      }))());
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 102:6', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$CanonicalToJs_Test$natives = (($sp$Test$Group)("natives"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.log"))("result = log \"this is produced by a test\" True"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("true"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.log, partially applied"))("result = log \"if this gets actually logged, we have a problem\""))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("undefined"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("SPCore/Debug.todo"))("a = todo \"blah\"\nresult = 1"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("Text concat (..)"))("result = \"a\" .. \"b\" .. \"c\""))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("\"abc\""))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("add"))("result = 1 + 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("3"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("subtract"))("result = 5 - 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("2"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("multiply"))("result = 3 * 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("6"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("divide"))("result = 3 / 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("1.5"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("divide by zero"))("result = 3 / 0"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("0"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("lesser than (<)"))("result = 3 < 2 & 2 < 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"first\":false,\"second\":true}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("greater than (>)"))("result = 3 > 2 & 2 > 3"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"first\":true,\"second\":false}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("partial application"))("result = (-) 2"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("undefined"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("mutable partial application"))("f = (+=) 3\n\nresult =\n   m @= 1\n   f @m\n   m"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("4"))))($core$SPCore$Nil))))))))))))));

const $sp$Compiler$CanonicalToJs_Test$try_ = (($sp$Test$Group)("try"))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("basic sanity"))("union A = A Number, B, C Bool\n\na x =\n  try x as\n    A 1: 11\n    A n: n\n    B: 3\n    C False: 5\n    C _: 6\n\nresult =\n { x = a (A 2)\n , y = a (A 1)\n , z = a B\n , w = a (C False)\n , k = a (C True)\n }"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("{\"k\":6,\"w\":6,\"x\":2,\"y\":11,\"z\":3}"))))((($core$SPCore$Cons)((((($sp$Compiler$CanonicalToJs_Test$codeTest)("[reg]: pattern any"))("result =\n   try 2 as\n     x: x"))(($sp$Compiler$CanonicalToJs_Test$eval)("Test.result")))(($sp$Test$isOkAndEqualTo)("2"))))($core$SPCore$Nil)));

const $sp$Compiler$CanonicalToJs_Test$tests = (($sp$Test$Group)("CanonicalToJS"))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$misc))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$mutation))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$ifs))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$try_))((($core$SPCore$Cons)($sp$Compiler$CanonicalToJs_Test$natives))($core$SPCore$Nil))))));

const $sp$Compiler$CoreTypes$bool = (($sp$Compiler$CoreTypes$nameToType)("Bool"))($core$SPCore$Nil);

const $sp$Compiler$CoreTypes$boolDef = ({
  args: $core$SPCore$Nil,
  constructors: ((($corelib$Dict$insert)("False"))(({
    args: $core$SPCore$Nil,
    pos: $sp$Compiler$CoreTypes$p,
    type: $sp$Compiler$CoreTypes$bool,
  })))(((($corelib$Dict$insert)("True"))(({
    args: $core$SPCore$Nil,
    pos: $sp$Compiler$CoreTypes$p,
    type: $sp$Compiler$CoreTypes$bool,
  })))($corelib$Dict$empty)),
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)("Bool"),
});

const $sp$Compiler$CoreTypes$list = (($item) => (($sp$Compiler$CoreTypes$nameToType)("List"))((($core$SPCore$Cons)($item))($core$SPCore$Nil)));

const $sp$Compiler$CoreTypes$listDef = ((() => {
  const $item = (($sp$Types$CanonicalAst$TypeVariable)($sp$Compiler$CoreTypes$p))("item");
  const $consDef = ({
    args: (($core$SPCore$Cons)($item))((($core$SPCore$Cons)(($sp$Compiler$CoreTypes$list)($item)))($core$SPCore$Nil)),
    pos: $sp$Compiler$CoreTypes$p,
    type: ((($corelib$List$foldr)((($ar) => (($ty) => (((($sp$Types$CanonicalAst$TypeFunction)($sp$Compiler$CoreTypes$p))($ar))(false))($ty)))))((($core$SPCore$Cons)($item))((($core$SPCore$Cons)(($sp$Compiler$CoreTypes$list)($item)))($core$SPCore$Nil))))(($sp$Compiler$CoreTypes$list)($item)),
  });
  return ({
    args: (($core$SPCore$Cons)("item"))($core$SPCore$Nil),
    constructors: ((($corelib$Dict$insert)("Cons"))($consDef))(((($corelib$Dict$insert)("Nil"))(({
      args: $core$SPCore$Nil,
      pos: $sp$Compiler$CoreTypes$p,
      type: ($sp$Compiler$CoreTypes$list)($item),
    })))($corelib$Dict$empty)),
    directTypeDeps: $corelib$Set$empty,
    usr: ($sp$Compiler$CoreTypes$makeUsr)("List"),
  });
}))();

const $sp$Compiler$CoreTypes$noneDef = ({
  args: $core$SPCore$Nil,
  constructors: (($corelib$Dict$singleton)($sp$Compiler$CoreTypes$noneName))(({
    args: $core$SPCore$Nil,
    pos: $sp$Compiler$CoreTypes$p,
    type: $sp$Compiler$CoreTypes$none,
  })),
  directTypeDeps: $corelib$Set$empty,
  usr: ($sp$Compiler$CoreTypes$makeUsr)($sp$Compiler$CoreTypes$noneName),
});

const $sp$Compiler$CoreTypes$allDefs = (($core$SPCore$Cons)($sp$Compiler$CoreTypes$noneDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$boolDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$listDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$textDef))((($core$SPCore$Cons)($sp$Compiler$CoreTypes$numberDef))($core$SPCore$Nil)))));

const $sp$Compiler$CoreTypes$usrToVariable = (($u) => (($sp$Types$CanonicalAst$Variable)($sp$Compiler$CoreTypes$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Types$CanonicalAst$RefRoot)($u),
})));

const $sp$Compiler$Error$breakDownText = (($text) => {
  const $formatSnippet = (($index) => (($snippet) => (((sp_equal)(0))(((basics_modBy)(2))($index))
    ? ($sp$Compiler$Error$FormattedText_Default)($snippet)
    : ((() => {
      const $$try = ((text_split)($sp$Compiler$Error$formatSuffix))($snippet);
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("emphasys" === ($$try)[1]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0]))))) {
        const $s = (($$try)[2])[1];
        return ($sp$Compiler$Error$FormattedText_Emphasys)($s);
        return null;
      }
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("warning" === ($$try)[1]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0]))))) {
        const $s = (($$try)[2])[1];
        return ($sp$Compiler$Error$FormattedText_Warning)($s);
        return null;
      }
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("decoration" === ($$try)[1]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0]))))) {
        const $s = (($$try)[2])[1];
        return ($sp$Compiler$Error$FormattedText_Decoration)($s);
        return null;
      }
      if (true) {
        return ($sp$Compiler$Error$FormattedText_Default)($snippet);
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 69:10', (sp_toHuman)($$try));
    }))())));
  return (($corelib$List$indexedMap)($formatSnippet))(((text_split)($sp$Compiler$Error$formatSeparator))($text));
});

const $sp$Compiler$Error$deco = ($sp$Compiler$Error$formatWrap)("decoration");

const $sp$Compiler$Error$emph = ($sp$Compiler$Error$formatWrap)("emphasys");

const $sp$Compiler$Error$flatten = (($e) => (($accum) => ((() => {
  const $$try = $e;
  if (("$sp$Compiler$Error$Simple" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $descr = ($$try)[2];
    return ((sp_cons)($accum))(({
      first: $pos,
      second: $descr,
    }));
    return null;
  }
  if (("$sp$Compiler$Error$Nested" === ($$try)[0])) {
    const $ls = ($$try)[1];
    return ((($corelib$List$foldl)($sp$Compiler$Error$flatten))($ls))($accum);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Error.sp 104:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$Error$res = (($pos) => (($desc) => ($corelib$Result$Err)((($sp$Compiler$Error$Simple)($pos))($desc))));

const $sp$Compiler$Error$toText = (($env) => (($pos) => (($desc) => {
  const block$$ = (($sp$Compiler$Error$posToHuman)($env))($pos);
  const $location = block$$.location;
  const $block = block$$.block;
  const $description = (($corelib$Text$join)("\n"))((($corelib$List$map)((($s) => ("  " + $s))))((($corelib$List$concatMap)((text_split)("\n")))(((($d) => ((sp_cons)($d))($block)))(($desc)($env)))));
  return ($sp$Compiler$Error$breakDownText)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(($sp$Compiler$Error$deco)(((($corelib$Text$padRight)(50))("-"))(($location + " ")))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($description))((($core$SPCore$Cons)(""))($core$SPCore$Nil))))))));
})));

const $sp$Compiler$Error$toFormattedText = (($eenv) => (($e) => {
  const $newline = ($sp$Compiler$Error$FormattedText_Default)("");
  const $tupleToFormattedText = (($x) => {
    const descr$$ = $x;
    const $descr = descr$$.second;
    const $pos = descr$$.first;
    return ((($sp$Compiler$Error$toText)($eenv))($pos))($descr);
  });
  return (($corelib$List$concatMap)($tupleToFormattedText))((($sp$Compiler$Error$flatten)($e))($core$SPCore$Nil));
}));

const $sp$Compiler$ExpandTypes$error = (($pos) => (($description) => (($sp$Compiler$Error$res)($pos))((() => $description))));

const $sp$Compiler$ExpandTypes$expandAliasVariables = (($typeByArgName) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return ((() => {
      const $$try = (($corelib$Dict$get)($name))($typeByArgName);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $ty;
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $t = ($$try)[1];
        return $t;
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 185:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return (((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($from)))($fromIsMutable))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($to));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible))((($corelib$Dict$map)((($k) => ($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))))($attrs));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $usr = ($$try)[2];
    const $args = ($$try)[3];
    return ((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))((($corelib$List$map)(($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName)))($args));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $usr = ($$try)[2];
    const $t = ($$try)[3];
    return ((($sp$Types$CanonicalAst$TypeAlias)($pos))($usr))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($t));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 183:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$ExpandTypes$expandInType = (($ga) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return ($corelib$Result$Ok)($ty);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return (($corelib$Result$onOk)((($f) => (($corelib$Result$onOk)((($t) => ($corelib$Result$Ok)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($f))($fromIsMutable))($t)))))((($sp$Compiler$ExpandTypes$expandInType)($ga))($to)))))((($sp$Compiler$ExpandTypes$expandInType)($ga))($from));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    return (($corelib$Result$map)((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible)))((($corelib$Dict$mapRes)((($k) => ($sp$Compiler$ExpandTypes$expandInType)($ga))))($attrs));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)("Did we apply aliases twice?"))($core$SPCore$Nil));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $usr = ($$try)[2];
    const $args = ($$try)[3];
    return (($corelib$Result$onOk)((($replacedArgs) => ((() => {
      const $$try = (($ga)($pos))($usr);
      if (("$corelib$Result$Err" === ($$try)[0])) {
        const $e = ($$try)[1];
        return ($corelib$Result$Err)($e);
        return null;
      }
      if ((("$corelib$Result$Ok" === ($$try)[0]) && ("$sp$Types$CanonicalAst$TypeDefUnion" === (($$try)[1])[0]))) {
        const $un = (($$try)[1])[1];
        return (((sp_not_equal)(($corelib$List$length)($un.args)))(($corelib$List$length)($replacedArgs))
          ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("union " + ((sp_toHuman)($un.usr) + (" needs " + ((text_fromNumber)(($corelib$List$length)($un.args)) + " args,"))))))((($core$SPCore$Cons)(("but was used with " + (text_fromNumber)(($corelib$List$length)($replacedArgs)))))($core$SPCore$Nil)))
          : ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))($replacedArgs)));
        return null;
      }
      if ((("$corelib$Result$Ok" === ($$try)[0]) && ("$sp$Types$CanonicalAst$TypeDefAlias" === (($$try)[1])[0]))) {
        const $al = (($$try)[1])[1];
        return (((sp_not_equal)(($corelib$List$length)($replacedArgs)))(($corelib$List$length)($al.args))
          ? (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("alias " + ((sp_toHuman)($al.usr) + (" needs " + ((text_fromNumber)(($corelib$List$length)($al.args)) + (" args, but was used with " + (text_fromNumber)(($corelib$List$length)($replacedArgs)))))))))($core$SPCore$Nil))
          : ((() => {
            const $typeByArgName = ($corelib$Dict$fromList)(((($corelib$List$map2)(((name$$) => {
              const $name = (name$$)[2];
              return (($r) => ({
                first: $name,
                second: $r,
              }));
            })))($al.args))($replacedArgs));
            return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeAlias)($pos))($usr))((($sp$Compiler$ExpandTypes$expandAliasVariables)($typeByArgName))($al.type)));
          }))());
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 39:12', (sp_toHuman)($$try));
    }))())))((($corelib$List$mapRes)(($sp$Compiler$ExpandTypes$expandInType)($ga)))($args));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 19:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions = (($nonFunctionPos) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    return $core$SPCore$Nil;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $name = ($$try)[2];
    return $core$SPCore$Nil;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return (($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos))($t);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $functionPos = ($$try)[1];
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return ($corelib$List$concat)((($core$SPCore$Cons)(((() => {
      const $$try = $nonFunctionPos;
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $constraintPos = ($$try)[1];
        return (($core$SPCore$Cons)(({
          first: $constraintPos,
          second: $functionPos,
        })))($core$SPCore$Nil);
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $core$SPCore$Nil;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 104:14', (sp_toHuman)($$try));
    }))()))((($core$SPCore$Cons)((($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)(($fromIsMutable
      ? ($corelib$Maybe$Just)($functionPos)
      : $corelib$Maybe$Nothing)))($from)))((($core$SPCore$Cons)((($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos))($to)))($core$SPCore$Nil))));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $ext = ($$try)[2];
    const $attrs = ($$try)[3];
    return (($corelib$List$concatMap)(($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($nonFunctionPos)))(($corelib$Dict$values)($attrs));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 85:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$ExpandTypes$expandAndValidateType = (($ga) => (($rawTy) => (($corelib$Result$onOk)((($expandedTy) => ((() => {
  const $$try = (($sp$Compiler$ExpandTypes$findMutableArgsThatContainFunctions)($corelib$Maybe$Nothing))($expandedTy);
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($corelib$Result$Ok)($expandedTy);
  }
  if (true) {
    const $errors = $$try;
    return (($sp$Compiler$ExpandTypes$error)(($sp$Types$Pos$I)(567)))((($core$SPCore$Cons)("Mutable arguments can't be or contain functions!"))((($core$SPCore$Cons)((($corelib$Text$join)("\n"))((($corelib$List$map)(sp_toHuman))($errors))))($core$SPCore$Nil)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 71:4', (sp_toHuman)($$try));
}))())))((($sp$Compiler$ExpandTypes$expandInType)($ga))($rawTy))));

const $sp$Compiler$ExpandTypes$expandAndInsertAlias = (($allTypes) => (($al) => (($expandedTypes) => {
  const $getAlias = (($pos) => (($usr) => ((() => {
    const $$try = (($corelib$Dict$get)($usr))($expandedTypes);
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $type = ($$try)[1];
      return ($corelib$Result$Ok)($type);
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return ((() => {
        const $$try = (($corelib$Dict$get)($usr))($allTypes);
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil));
        }
        if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Types$CanonicalAst$TypeDefAlias" === (($$try)[1])[0]))) {
          const $a = (($$try)[1])[1];
          return (sp_todo)(("expandAndInsertAlias should-not-happen: " + (sp_toHuman)($usr)));
          return null;
        }
        if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Types$CanonicalAst$TypeDefUnion" === (($$try)[1])[0]))) {
          const $u = (($$try)[1])[1];
          return ($corelib$Result$Ok)(($sp$Types$CanonicalAst$TypeDefUnion)($u));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 166:16', (sp_toHuman)($$try));
      }))();
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 161:8', (sp_toHuman)($$try));
  }))()));
  return (($corelib$Result$onOk)((($type) => ($corelib$Result$Ok)(((($corelib$Dict$insert)($al.usr))(($sp$Types$CanonicalAst$TypeDefAlias)((Object.assign)({}, $al, ({
    type: $type,
  })))))($expandedTypes)))))((($sp$Compiler$ExpandTypes$expandAndValidateType)($getAlias))($al.type));
})));

const $sp$Compiler$ExpandTypes$getTypeForUnion = (($allTypes) => (($expandedTypes) => (($pos) => (($usr) => ((() => {
  const $$try = (($corelib$Dict$get)($usr))($expandedTypes);
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $t = ($$try)[1];
    return ($corelib$Result$Ok)($t);
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ((() => {
      const $$try = (($corelib$Dict$get)($usr))($allTypes);
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $t = ($$try)[1];
        return ($corelib$Result$Ok)($t);
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type usr: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 230:12', (sp_toHuman)($$try));
    }))();
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 223:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$ExpandTypes$expandAndInsertUnion = (($allTypes) => (($usr) => (($typeDef) => (($expandedTypes) => ((() => {
  const $$try = $typeDef;
  if (("$sp$Types$CanonicalAst$TypeDefAlias" === ($$try)[0])) {
    return ($corelib$Result$Ok)($expandedTypes);
  }
  if (("$sp$Types$CanonicalAst$TypeDefUnion" === ($$try)[0])) {
    const $u = ($$try)[1];
    const $gt = (($sp$Compiler$ExpandTypes$getTypeForUnion)($allTypes))($expandedTypes);
    const $mapConstructor = (($name) => (($c) => (($corelib$Result$onOk)((($type) => (($corelib$Result$onOk)((($args) => ($corelib$Result$Ok)((Object.assign)({}, $c, ({
      args: $args,
      type: $type,
    }))))))((($corelib$List$mapRes)(($sp$Compiler$ExpandTypes$expandAndValidateType)($gt)))($c.args)))))((($sp$Compiler$ExpandTypes$expandAndValidateType)($gt))($c.type))));
    return (($corelib$Result$onOk)((($cs) => ($corelib$Result$Ok)(((($corelib$Dict$insert)($usr))(($sp$Types$CanonicalAst$TypeDefUnion)((Object.assign)({}, $u, ({
      constructors: $cs,
    })))))($expandedTypes)))))((($corelib$Dict$mapRes)($mapConstructor))($u.constructors));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 242:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$ExpandTypes$referencedAliases = (($allAliases) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $usr = ($$try)[2];
    const $args = ($$try)[3];
    const $init = ((($corelib$Dict$member)($usr))($allAliases)
      ? ($corelib$Set$singleton)($usr)
      : $corelib$Set$empty);
    return ((($corelib$List$foldl)((($ar) => ($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($ar)))))($args))(($corelib$Set$singleton)($usr));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return $corelib$Dict$empty;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $from = ($$try)[2];
    const $maybeMut = ($$try)[3];
    const $to = ($$try)[4];
    return (($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($from)))((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($to));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    return ((($corelib$Dict$foldl)((($name) => (($t) => ($corelib$Dict$join)((($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($t))))))($attrs))($corelib$Dict$empty);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return (($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($t);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 131:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$ExpandTypes$expandAllTypes = (($allTypes) => {
  const $allAliases = ((() => {
    const $insertAlias = (($usr) => (($typeDef) => (($acc) => ((() => {
      const $$try = $typeDef;
      if (("$sp$Types$CanonicalAst$TypeDefAlias" === ($$try)[0])) {
        const $a = ($$try)[1];
        return ((($corelib$Dict$insert)($usr))($a))($acc);
        return null;
      }
      if (true) {
        return $acc;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 280:12', (sp_toHuman)($$try));
    }))())));
    return ((($corelib$Dict$foldl)($insertAlias))($allTypes))($corelib$Dict$empty);
  }))();
  const circulars$$ = (($sp$RefHierarchy$reorder)((($al) => (($sp$Compiler$ExpandTypes$referencedAliases)($allAliases))($al.type))))($allAliases);
  const $orderedAliasRefs = circulars$$.second;
  const $circulars = circulars$$.first;
  return (((sp_not_equal)($core$SPCore$Nil))($circulars)
    ? ((() => {
      const $circularToError = (($circular) => (($sp$Compiler$Error$Simple)(($sp$Types$Pos$I)(121)))((() => (($core$SPCore$Cons)("circular alias: "))((($core$SPCore$Cons)((($corelib$Text$join)(" <- "))((($corelib$List$map)(sp_toHuman))($circular))))($core$SPCore$Nil)))));
      return ($corelib$Result$Err)(($sp$Compiler$Error$Nested)((($corelib$List$map)($circularToError))($circulars)));
    }))()
    : ((() => {
      const $oa = (($corelib$List$filterMap)((($ref) => (($corelib$Dict$get)($ref))($allAliases))))($orderedAliasRefs);
      return (($corelib$Result$onOk)((($corelib$Dict$foldlRes)(($sp$Compiler$ExpandTypes$expandAndInsertUnion)($allTypes)))($allTypes)))(((($corelib$List$foldlRes)(($sp$Compiler$ExpandTypes$expandAndInsertAlias)($allTypes)))($oa))($corelib$Dict$empty));
    }))());
});

const $sp$Compiler$ExpandTypes$expandAnnotation = (($allExpandedTypes) => (($type) => {
  const $gt = (($pos) => (($usr) => ((() => {
    const $$try = (($corelib$Dict$get)($usr))($allExpandedTypes);
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $t = ($$try)[1];
      return ($corelib$Result$Ok)($t);
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return (($sp$Compiler$ExpandTypes$error)($pos))((($core$SPCore$Cons)(("Undefined type usr: `" + ((sp_toHuman)($usr) + "`"))))($core$SPCore$Nil));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/ExpandTypes.sp 324:8', (sp_toHuman)($$try));
  }))()));
  return (($sp$Compiler$ExpandTypes$expandAndValidateType)($gt))($type);
}));

const $sp$Compiler$ExpandTypes$insertModuleTypes = (($module) => (($allTypes) => ((($corelib$Dict$foldl)((($name) => (($def) => (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefUnion)($def))))))($module.unionDefs))(((($corelib$Dict$foldl)((($name) => (($def) => (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefAlias)($def))))))($module.aliasDefs))($allTypes))));

const $sp$Compiler$JsToText$id = (($level) => (($corelib$Text$repeat)($level))("  "));

const $sp$Compiler$JsToText$emitExpr = (($l) => (($expression) => ((() => {
  const $$try = $expression;
  if (("$sp$Types$JavascriptAst$Literal" === ($$try)[0])) {
    const $s = ($$try)[1];
    return $s;
    return null;
  }
  if (("$sp$Types$JavascriptAst$Var" === ($$try)[0])) {
    const $n = ($$try)[1];
    return $n;
    return null;
  }
  if (("$sp$Types$JavascriptAst$Call" === ($$try)[0])) {
    const $ref = ($$try)[1];
    const $args = ($$try)[2];
    return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($ref) + (")(" + ((($corelib$Text$join)(", "))((($corelib$List$map)(($sp$Compiler$JsToText$emitExpr)($l)))($args)) + ")"))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$Unop" === ($$try)[0])) {
    const $op = ($$try)[1];
    const $left = ($$try)[2];
    return ($op + ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + ")")));
    return null;
  }
  if (("$sp$Types$JavascriptAst$Binop" === ($$try)[0])) {
    const $op = ($$try)[1];
    const $left = ($$try)[2];
    const $right = ($$try)[3];
    return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + (" " + ($op + (" " + ((($sp$Compiler$JsToText$emitExpr)($l))($right) + ")"))))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$Mutop" === ($$try)[0])) {
    const $op = ($$try)[1];
    const $yield = ($$try)[2];
    const $left = ($$try)[3];
    const $right = ($$try)[4];
    return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($left) + (" " + ($op + (" " + ((($sp$Compiler$JsToText$emitExpr)($l))($right) + (", " + ($yield + ")"))))))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$SimpleLambda" === ($$try)[0])) {
    const $params = ($$try)[1];
    const $expr = ($$try)[2];
    return ("((" + ((($corelib$Text$join)(", "))($params) + (") => " + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + ")"))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$BlockLambda" === ($$try)[0])) {
    const $params = ($$try)[1];
    const $stats = ($$try)[2];
    return ("((" + ((($corelib$Text$join)(", "))($params) + (") => " + ((($sp$Compiler$JsToText$emitBlock)($l))($stats) + ")"))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$Record" === ($$try)[0])) {
    const $attrs = ($$try)[1];
    return (((sp_equal)($corelib$Dict$empty))($attrs)
      ? "{}"
      : ((($a) => ("({\n" + ((($corelib$Text$join)("\n"))($a) + ("\n" + (($sp$Compiler$JsToText$id)($l) + "})"))))))((($corelib$List$map)(((key$$) => {
        const $key = key$$.first;
        const $value = key$$.second;
        return (($sp$Compiler$JsToText$id)(($l + 1)) + ($key + (": " + ((($sp$Compiler$JsToText$emitExpr)(($l + 1)))($value) + ","))));
      })))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs)))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$AccessWithDot" === ($$try)[0])) {
    const $name = ($$try)[1];
    const $e = ($$try)[2];
    return ((($sp$Compiler$JsToText$emitExpr)($l))($e) + ("." + $name));
    return null;
  }
  if (("$sp$Types$JavascriptAst$AccessWithBrackets" === ($$try)[0])) {
    const $i = ($$try)[1];
    const $expr = ($$try)[2];
    return ("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + (")[" + ((($sp$Compiler$JsToText$emitExpr)($l))($i) + "]"))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$Conditional" === ($$try)[0])) {
    const $p = ($$try)[1];
    const $true = ($$try)[2];
    const $false = ($$try)[3];
    return (("(" + ((($sp$Compiler$JsToText$emitExpr)($l))($p) + "\n")) + ((($sp$Compiler$JsToText$id)(($l + 1)) + ("? " + (($sp$Compiler$JsToText$emitExpr)(($l + 1)))($true))) + ("\n" + ((($sp$Compiler$JsToText$id)(($l + 1)) + (": " + (($sp$Compiler$JsToText$emitExpr)(($l + 1)))($false))) + ")"))));
    return null;
  }
  if (("$sp$Types$JavascriptAst$Array" === ($$try)[0])) {
    const $items = ($$try)[1];
    return (((sp_equal)($core$SPCore$Nil))($items)
      ? "[]"
      : ((($a) => ("([\n" + ((($corelib$Text$join)("\n"))($a) + ("\n" + (($sp$Compiler$JsToText$id)($l) + "])"))))))((($corelib$List$map)((($i) => (($sp$Compiler$JsToText$id)(($l + 1)) + ((($sp$Compiler$JsToText$emitExpr)(($l + 1)))($i) + ",")))))($items)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/JsToText.sp 41:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$JsToText$emitStatement = (($l) => (($stat) => {
  const $std = (($mid) => (($expr) => (($sp$Compiler$JsToText$id)($l) + ($mid + ((($sp$Compiler$JsToText$emitExpr)($l))($expr) + ";")))));
  return ((() => {
    const $$try = $stat;
    if (("$sp$Types$JavascriptAst$Eval" === ($$try)[0])) {
      const $e = ($$try)[1];
      return (($std)(""))($e);
      return null;
    }
    if (("$sp$Types$JavascriptAst$Return" === ($$try)[0])) {
      const $e = ($$try)[1];
      return (($std)("return "))($e);
      return null;
    }
    if (("$sp$Types$JavascriptAst$Define" === ($$try)[0])) {
      const $name = ($$try)[1];
      const $e = ($$try)[2];
      return (($std)(("const " + ($name + " = "))))($e);
      return null;
    }
    if (("$sp$Types$JavascriptAst$If" === ($$try)[0])) {
      const $condition = ($$try)[1];
      const $block = ($$try)[2];
      return (($sp$Compiler$JsToText$id)($l) + ("if (" + ((($sp$Compiler$JsToText$emitExpr)($l))($condition) + (") " + (($sp$Compiler$JsToText$emitBlock)($l))($block)))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/JsToText.sp 14:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Compiler$JsToText$emitBlock = (($l) => (($block) => {
  const $lines = (($corelib$Text$join)("\n"))((($corelib$List$map)(($sp$Compiler$JsToText$emitStatement)(($l + 1))))($block));
  return ("{\n" + ($lines + ("\n" + (($sp$Compiler$JsToText$id)($l) + "}"))));
}));

const $sp$Compiler$Lexer$addIndentToken = (($pos) => (($kind) => (($state) => ((array_push)(({
  attr: "tokens",
  obj: ($state.obj)[$state.attr],
})))(((($sp$Types$Token$Token)($pos))($pos))($kind)))));

const $sp$Compiler$Lexer$updateIndent = (($start) => (($end) => (($kind) => (($state) => {
  const $manageIndent = (($head) => (((sp_clone)(($state.obj)[$state.attr].lineIndent) > $head.indent)
    ? ((() => {
      const $newIndent = ({
        indent: (sp_clone)(($state.obj)[$state.attr].lineIndent),
        isBlock: (sp_clone)(($state.obj)[$state.attr].indentStartsABlock),
      });
      (($state.obj)[$state.attr].indentStack = ((sp_cons)((sp_clone)(($state.obj)[$state.attr].indentStack)))($newIndent), null);
      return ((sp_clone)(($state.obj)[$state.attr].indentStartsABlock)
        ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$BlockStart))($state)
        : null);
    }))()
    : (($head.isBlock && ((sp_not_equal)($sp$Types$Token$Comment))($kind))
      ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$NewSiblingLine))($state)
      : null)));
  return ((() => {
    const $$try = (sp_clone)(($state.obj)[$state.attr].indentStack);
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $head = ($$try)[1];
      const $tail = ($$try)[2];
      return (((sp_clone)(($state.obj)[$state.attr].lineIndent) < $head.indent)
        ? ((() => {
          (($state.obj)[$state.attr].indentStack = $tail, null);
          ($head.isBlock
            ? ((($sp$Compiler$Lexer$addIndentToken)($start))($sp$Types$Token$BlockEnd))($state)
            : null);
          return (((($sp$Compiler$Lexer$updateIndent)($start))($end))($kind))($state);
        }))()
        : ($manageIndent)($head));
      return null;
    }
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($manageIndent)(({
        indent: 0,
        isBlock: true,
      }));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 145:4', (sp_toHuman)($$try));
  }))();
}))));

const $sp$Compiler$Lexer$absAddToken = (($start) => (($end) => (($kind) => (($state) => {
  ((sp_clone)(($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine)
    ? ((() => {
      (($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine = false, null);
      return (((($sp$Compiler$Lexer$updateIndent)($start))($end))($kind))($state);
    }))()
    : null);
  const $indentStartsABlock = ((() => {
    const $$try = $kind;
    if (("$sp$Types$Token$Then" === ($$try)[0])) {
      return true;
    }
    if (("$sp$Types$Token$Else" === ($$try)[0])) {
      return true;
    }
    if (("$sp$Types$Token$As" === ($$try)[0])) {
      return true;
    }
    if (("$sp$Types$Token$Colon" === ($$try)[0])) {
      return true;
    }
    if (("$sp$Types$Token$MutableColon" === ($$try)[0])) {
      return true;
    }
    if (("$sp$Types$Token$Defop" === ($$try)[0])) {
      return true;
    }
    if (("$sp$Types$Token$Comment" === ($$try)[0])) {
      return (sp_clone)(($state.obj)[$state.attr].indentStartsABlock);
    }
    if (true) {
      return false;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 174:8', (sp_toHuman)($$try));
  }))();
  (($state.obj)[$state.attr].indentStartsABlock = $indentStartsABlock, null);
  ((array_push)(({
    attr: "tokens",
    obj: ($state.obj)[$state.attr],
  })))(((($sp$Types$Token$Token)($start))($end))($kind));
  return (($state.obj)[$state.attr].tokenStart = $end, null);
}))));

const $sp$Compiler$Lexer$getPos = (($state) => (sp_clone)(($state.obj)[$state.attr].buffer.nextPos));

const $sp$Compiler$Lexer$addError = (($message) => (($state) => {
  const $end = ($sp$Compiler$Lexer$getPos)($state);
  const $error = (($sp$Compiler$Error$Simple)(((($sp$Types$Pos$P)((sp_clone)(($state.obj)[$state.attr].moduleName)))((sp_clone)(($state.obj)[$state.attr].tokenStart)))($end)))((() => (($core$SPCore$Cons)($message))($core$SPCore$Nil)));
  (($state.obj)[$state.attr].errors = ((sp_cons)((sp_clone)(($state.obj)[$state.attr].errors)))($error), null);
  return (($state.obj)[$state.attr].tokenStart = $end, null);
}));

const $sp$Compiler$Lexer$startsWithUpperChar = (($s) => ((() => {
  const $$try = ((text_startsWithRegex)("[A-Z]"))($s);
  if (("" === $$try)) {
    return false;
  }
  if (true) {
    return true;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 264:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$Lexer$addLowerOrUpperWord = (($start) => (($end) => (($modifier) => (($chunk) => (($state) => {
  const $upperName = (($maybeModule) => (($name) => ((() => {
    const $$try = $modifier;
    if (("$sp$Types$Token$NameNoModifier" === ($$try)[0])) {
      return (((($sp$Compiler$Lexer$absAddToken)($start))($end))((($sp$Types$Token$UpperName)($maybeModule))($name)))($state);
    }
    if (("$sp$Types$Token$NameStartsWithDot" === ($$try)[0])) {
      return (($sp$Compiler$Lexer$addError)("Types or constructors can't start with `.` and attribute names can't start with an uppercase letter. =|"))($state);
    }
    if (("$sp$Types$Token$NameMutable" === ($$try)[0])) {
      return (($sp$Compiler$Lexer$addError)("Types or constructors can't be mutable on their own, only variables can!"))($state);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 274:8', (sp_toHuman)($$try));
  }))()));
  const $lowerName = (($maybeModule) => (($name) => (($attrs) => ((($corelib$List$any)($sp$Compiler$Lexer$startsWithUpperChar))($attrs)
    ? (($sp$Compiler$Lexer$addError)("attribute names must start with a lowercase letter"))($state)
    : ((((sp_not_equal)($corelib$Maybe$Nothing))($maybeModule) && ((sp_not_equal)($sp$Types$Token$NameNoModifier))($modifier))
      ? (($sp$Compiler$Lexer$addError)("can't use . or @ modifier on an imported value"))($state)
      : (((($sp$Compiler$Lexer$absAddToken)($start))($end))((((($sp$Types$Token$LowerName)($modifier))($maybeModule))($name))($attrs)))($state))))));
  const $snips = ((text_split)("."))($chunk);
  return ((($corelib$List$any)((($s) => ((sp_equal)(""))($s))))($snips)
    ? (($sp$Compiler$Lexer$addError)("use spaces around `..` to concatenate Text"))($state)
    : ((() => {
      const $$try = $snips;
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return (sp_todo)("should not happen");
      }
      if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
        const $one = ($$try)[1];
        return (($sp$Compiler$Lexer$startsWithUpperChar)($one)
          ? (($upperName)($corelib$Maybe$Nothing))($one)
          : ((($lowerName)($corelib$Maybe$Nothing))($one))($core$SPCore$Nil));
        return null;
      }
      if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Cons" === (($$try)[2])[0]))) {
        const $first = ($$try)[1];
        const $second = (($$try)[2])[1];
        const $more = (($$try)[2])[2];
        return ((() => {
          const $$try = ({
            first: ($sp$Compiler$Lexer$startsWithUpperChar)($first),
            second: ($sp$Compiler$Lexer$startsWithUpperChar)($second),
          });
          if (((false === $$try.first) && (false === $$try.second))) {
            return ((($lowerName)($corelib$Maybe$Nothing))($first))(((sp_cons)($more))($second));
          }
          if (((true === $$try.first) && (false === $$try.second))) {
            return ((($lowerName)(($corelib$Maybe$Just)($first)))($second))($more);
          }
          if (((true === $$try.first) && (true === $$try.second))) {
            return (((sp_not_equal)($core$SPCore$Nil))($more)
              ? (($sp$Compiler$Lexer$addError)("Types and constructors can't have .attributes"))($state)
              : (($upperName)(($corelib$Maybe$Just)($first)))($second));
          }
          if (((false === $$try.first) && (true === $$try.second))) {
            return (($sp$Compiler$Lexer$addError)("Something wrong with uppercases?"))($state);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 319:12', (sp_toHuman)($$try));
        }))();
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 300:6', (sp_toHuman)($$try));
    }))());
})))));

const $sp$SPLib$Buffer$slice = (($start) => (($end) => (($b) => (((text_slice)($start))($end))($b.fullText))));

const $sp$Compiler$Lexer$getChunk = (($state) => {
  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
  const $end = ($sp$Compiler$Lexer$getPos)($state);
  return ({
    first: $start,
    second: $end,
    third: ((($sp$SPLib$Buffer$slice)((sp_clone)(($state.obj)[$state.attr].tokenStart)))($end))((sp_clone)(($state.obj)[$state.attr].buffer)),
  });
});

const $sp$Compiler$Lexer$addNumberToken = (($state) => {
  const chunk$$ = ($sp$Compiler$Lexer$getChunk)($state);
  const $chunk = chunk$$.third;
  const $end = chunk$$.second;
  const $start = chunk$$.first;
  return (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$NumberLiteral)($chunk)))($state);
});

const $sp$Compiler$Lexer$addOneIndentToken = (($kind) => (($state) => {
  const $pos = ($sp$Compiler$Lexer$getPos)($state);
  return ((array_push)(({
    attr: "tokens",
    obj: ($state.obj)[$state.attr],
  })))(((($sp$Types$Token$Token)($pos))($pos))($kind));
}));

const $sp$Compiler$Lexer$relAddToken = (($ds) => (($de) => (($kind) => (($state) => {
  const $pos = ($sp$Compiler$Lexer$getPos)($state);
  return (((($sp$Compiler$Lexer$absAddToken)(($pos + $ds)))(($pos + $de)))($kind))($state);
}))));

const $sp$Compiler$Lexer$addParenOrCommaToken = (($char) => (($state) => {
  const $add = (($kind) => (((($sp$Compiler$Lexer$relAddToken)(0))(1))($kind))($state));
  return ((() => {
    const $$try = $char;
    if (("(" === $$try)) {
      return ($add)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open));
    }
    if ((")" === $$try)) {
      return ($add)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed));
    }
    if (("[" === $$try)) {
      return ($add)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open));
    }
    if (("]" === $$try)) {
      return ($add)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed));
    }
    if (("{" === $$try)) {
      return ($add)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Open));
    }
    if (("}" === $$try)) {
      return ($add)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Closed));
    }
    if (("," === $$try)) {
      return ($add)($sp$Types$Token$Comma);
    }
    if (true) {
      return (($sp$Compiler$Lexer$addError)(("I can't make sense of this piece of text: `" + ($char + "`"))))($state);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 456:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Prelude$typeBinop = (($mutates) => (($left) => (($right) => (($return) => ((($sp$Prelude$tyFun)($right))(false))(((($sp$Prelude$tyFun)($left))($mutates))($return))))));

const $sp$Prelude$typeBinopUniform = (($ty) => (((($sp$Prelude$typeBinop)(false))($ty))($ty))($ty));

const $sp$Prelude$add = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "+",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$and_ = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Logical,
  symbol: "and",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$divide = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Multiplicative,
  symbol: "/",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$equal = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "==",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$greaterOrEqualThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: ">=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$greaterThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: ">",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$lesserOrEqualThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "<=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$lesserThan = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "<",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$listCons = ((() => {
  const $item = ($sp$Prelude$tyVar)("item");
  return ({
    associativity: $sp$Types$Op$Right,
    nonFn: $core$SPCore$Nil,
    precedence: $sp$Types$Op$Cons,
    symbol: "::",
    type: (((($sp$Prelude$typeBinop)(false))($item))(($sp$Compiler$CoreTypes$list)($item)))(($sp$Compiler$CoreTypes$list)($item)),
  });
}))();

const $sp$Prelude$multiply = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Multiplicative,
  symbol: "*",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$mutableAdd = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: "+=",
  type: (((($sp$Prelude$typeBinop)(true))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$none),
});

const $sp$Prelude$mutableAssign = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: ":=",
  type: (((($sp$Prelude$typeBinop)(true))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$none),
});

const $sp$Prelude$mutableSubtract = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Mutop,
  symbol: "-=",
  type: (((($sp$Prelude$typeBinop)(true))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$number))($sp$Compiler$CoreTypes$none),
});

const $sp$Prelude$notEqual = ({
  associativity: $sp$Types$Op$Left,
  nonFn: (($core$SPCore$Cons)("a"))($core$SPCore$Nil),
  precedence: $sp$Types$Op$Comparison,
  symbol: "/=",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("a")))($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$or_ = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Logical,
  symbol: "or",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$bool),
});

const $sp$Prelude$sendLeft = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: "<<",
  type: (((($sp$Prelude$typeBinop)(false))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("b"))))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("b")),
});

const $sp$Prelude$sendRight = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(((($sp$Prelude$tyFun)(($sp$Prelude$tyVar)("a")))(false))(($sp$Prelude$tyVar)("b"))))(($sp$Prelude$tyVar)("b")),
});

const $sp$Prelude$subtract = ({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "-",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$number),
});

const $sp$Prelude$textConcat = ({
  associativity: $sp$Types$Op$Right,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "..",
  type: ($sp$Prelude$typeBinopUniform)($sp$Compiler$CoreTypes$text),
});

const $sp$Prelude$tuple = ({
  associativity: $sp$Types$Op$NonAssociative,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Tuple,
  symbol: "&",
  type: (((($sp$Prelude$typeBinop)(false))(($sp$Prelude$tyVar)("a")))(($sp$Prelude$tyVar)("b")))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$N))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))(($sp$Prelude$tyVar)("b")))(((($corelib$Dict$insert)("first"))(($sp$Prelude$tyVar)("a")))($corelib$Dict$empty)))),
});

const $sp$Prelude$binops = ((($list) => ((($corelib$List$foldl)((($bop) => (($corelib$Dict$insert)($bop.symbol))($bop))))($list))($corelib$Dict$empty)))((($core$SPCore$Cons)($sp$Prelude$and_))((($core$SPCore$Cons)($sp$Prelude$or_))((($core$SPCore$Cons)($sp$Prelude$textConcat))((($core$SPCore$Cons)($sp$Prelude$listCons))((($core$SPCore$Cons)($sp$Prelude$tuple))((($core$SPCore$Cons)($sp$Prelude$add))((($core$SPCore$Cons)($sp$Prelude$subtract))((($core$SPCore$Cons)($sp$Prelude$multiply))((($core$SPCore$Cons)($sp$Prelude$divide))((($core$SPCore$Cons)($sp$Prelude$mutableAssign))((($core$SPCore$Cons)($sp$Prelude$mutableAdd))((($core$SPCore$Cons)($sp$Prelude$mutableSubtract))((($core$SPCore$Cons)($sp$Prelude$equal))((($core$SPCore$Cons)($sp$Prelude$notEqual))((($core$SPCore$Cons)($sp$Prelude$lesserThan))((($core$SPCore$Cons)($sp$Prelude$greaterThan))((($core$SPCore$Cons)($sp$Prelude$lesserOrEqualThan))((($core$SPCore$Cons)($sp$Prelude$greaterOrEqualThan))((($core$SPCore$Cons)($sp$Prelude$sendRight))((($core$SPCore$Cons)($sp$Prelude$sendLeft))($core$SPCore$Nil)))))))))))))))))))));

const $sp$Compiler$Lexer$addSquiggleToken = (($nextIsSpace) => (($state) => {
  const chunk$$ = ($sp$Compiler$Lexer$getChunk)($state);
  const $chunk = chunk$$.third;
  const $end = chunk$$.second;
  const $start = chunk$$.first;
  const $add = (($kind) => (((($sp$Compiler$Lexer$absAddToken)($start))($end))($kind))($state));
  return ((() => {
    const $$try = $chunk;
    if ((":" === $$try)) {
      return ($add)($sp$Types$Token$Colon);
    }
    if (("@:" === $$try)) {
      return ($add)($sp$Types$Token$MutableColon);
    }
    if (("=" === $$try)) {
      return ($add)(($sp$Types$Token$Defop)(({
        mutable: false,
      })));
    }
    if (("@=" === $$try)) {
      return ($add)(($sp$Types$Token$Defop)(({
        mutable: true,
      })));
    }
    if (("-" === $$try)) {
      return ($add)(($nextIsSpace
        ? ($sp$Types$Token$Binop)($sp$Prelude$subtract)
        : ($sp$Types$Token$Unop)($sp$Prelude$unaryMinus)));
    }
    if (("+" === $$try)) {
      return ($add)(($nextIsSpace
        ? ($sp$Types$Token$Binop)($sp$Prelude$add)
        : ($sp$Types$Token$Unop)($sp$Prelude$unaryPlus)));
    }
    if (true) {
      const $op = $$try;
      return ((() => {
        const $$try = (($corelib$Dict$get)($chunk))($sp$Prelude$binops);
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $binop = ($$try)[1];
          return ($add)(($sp$Types$Token$Binop)($binop));
          return null;
        }
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return (($sp$Compiler$Lexer$addError)(("Invalid operator: `" + ($chunk + "`"))))($state);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 440:12', (sp_toHuman)($$try));
      }))();
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 432:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Compiler$Lexer$addWordToken = (($modifier) => (($state) => {
  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
  const $end = ($sp$Compiler$Lexer$getPos)($state);
  const $ds = (((sp_equal)($sp$Types$Token$NameNoModifier))($modifier)
    ? 0
    : 1);
  const $chunk = ((($sp$SPLib$Buffer$slice)(((sp_clone)(($state.obj)[$state.attr].tokenStart) + $ds)))($end))((sp_clone)(($state.obj)[$state.attr].buffer));
  const $maybeKeywordKind = ((() => {
    const $$try = $chunk;
    if (("if" === $$try)) {
      return ($corelib$Maybe$Just)($sp$Types$Token$If);
    }
    if (("then" === $$try)) {
      return ($corelib$Maybe$Just)($sp$Types$Token$Then);
    }
    if (("else" === $$try)) {
      return ($corelib$Maybe$Just)($sp$Types$Token$Else);
    }
    if (("try" === $$try)) {
      return ($corelib$Maybe$Just)($sp$Types$Token$Try);
    }
    if (("as" === $$try)) {
      return ($corelib$Maybe$Just)($sp$Types$Token$As);
    }
    if (("with" === $$try)) {
      return ($corelib$Maybe$Just)($sp$Types$Token$With);
    }
    if (("and" === $$try)) {
      return ($corelib$Maybe$Just)(($sp$Types$Token$Binop)($sp$Prelude$and_));
    }
    if (("or" === $$try)) {
      return ($corelib$Maybe$Just)(($sp$Types$Token$Binop)($sp$Prelude$or_));
    }
    if (true) {
      return $corelib$Maybe$Nothing;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 356:8', (sp_toHuman)($$try));
  }))();
  return ((() => {
    const $$try = ({
      first: $maybeKeywordKind,
      second: $modifier,
    });
    if ((("$corelib$Maybe$Just" === ($$try.first)[0]) && ("$sp$Types$Token$NameNoModifier" === ($$try.second)[0]))) {
      const $kind = ($$try.first)[1];
      return (((($sp$Compiler$Lexer$absAddToken)($start))($end))($kind))($state);
      return null;
    }
    if (("$corelib$Maybe$Just" === ($$try.first)[0])) {
      const $kind = ($$try.first)[1];
      return (($sp$Compiler$Lexer$addError)(($chunk + " as a keyword, you can't really use it this way")))($state);
      return null;
    }
    if (true) {
      return ((((($sp$Compiler$Lexer$addLowerOrUpperWord)($start))($end))($modifier))($chunk))($state);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 367:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Compiler$Lexer$closeOpenBlocks = (($state) => {
  const $pos = ($sp$Compiler$Lexer$getPos)($state);
  return (($corelib$List$each)((sp_clone)(($state.obj)[$state.attr].indentStack)))((() => ((array_push)(({
    attr: "tokens",
    obj: ($state.obj)[$state.attr],
  })))(((($sp$Types$Token$Token)($pos))($pos))($sp$Types$Token$BlockEnd))));
});

const $sp$Compiler$Lexer$isNumber = (($char) => ((sp_not_equal)(""))(((text_startsWithRegex)("[0-9_.]"))($char)));

const $sp$Compiler$Lexer$isSquiggle = (($char) => ((() => {
  const $$try = $char;
  if (("=" === $$try)) {
    return true;
  }
  if ((":" === $$try)) {
    return true;
  }
  if (("*" === $$try)) {
    return true;
  }
  if (("+" === $$try)) {
    return true;
  }
  if (("-" === $$try)) {
    return true;
  }
  if (("/" === $$try)) {
    return true;
  }
  if ((">" === $$try)) {
    return true;
  }
  if (("<" === $$try)) {
    return true;
  }
  if (("!" === $$try)) {
    return true;
  }
  if (("&" === $$try)) {
    return true;
  }
  if (("^" === $$try)) {
    return true;
  }
  if (true) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 408:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$Lexer$isWordBody = (($char) => ((sp_not_equal)(""))(((text_startsWithRegex)("[a-zA-Z./_0-9]"))($char)));

const $sp$Compiler$Lexer$isWordStart = (($char) => ((sp_not_equal)(""))(((text_startsWithRegex)("[a-zA-Z._]"))($char)));

const $sp$Compiler$Lexer$setMode = (($mode) => (($state) => (($state.obj)[$state.attr].mode = $mode, null)));

const $sp$Compiler$Lexer$tryIndent = (($indentChar) => (($char) => (($state) => ((((sp_equal)($indentChar))($char) || ((sp_equal)(""))($char))
  ? null
  : ((((sp_equal)(" "))($char) || ((sp_equal)("\t"))($char))
    ? (($sp$Compiler$Lexer$addError)("mixing tabs and spaces!"))($state)
    : (((sp_equal)("\n"))($char)
      ? ((() => {
        (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1), null);
        return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Indent))($state);
      }))()
      : (((sp_equal)("#"))($char)
        ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$LineComment))($state)
        : ((() => {
          (($state.obj)[$state.attr].lineIndent = (sp_clone)(($state.obj)[$state.attr].column), null);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))())))))));

const $sp$Compiler$Lexer$unindent = (($raw) => (($corelib$Basics$not)(((text_startsWith)("\n"))($raw))
  ? $raw
  : ((() => {
    const $multilineText = ((text_dropLeft)(1))($raw);
    const $lines = ((text_split)("\n"))($multilineText);
    const $countLeadingSpaces = (($line) => (text_length)(((text_startsWithRegex)("[ ]*"))($line)));
    const $minLead = (($corelib$Maybe$withDefault)(0))(($corelib$List$minimum)((($corelib$List$map)($countLeadingSpaces))((($corelib$List$filter)((($s) => ((sp_not_equal)(""))((text_trimLeft)($s)))))($lines))));
    return (((text_replaceRegex)("\n[ ]*$"))(""))((($corelib$Text$join)("\n"))((($corelib$List$map)((text_dropLeft)($minLead)))($lines)));
  }))()));

const $sp$Compiler$Lexer$lexOne = (($char) => (($state) => {
  const $pos = ($sp$Compiler$Lexer$getPos)($state);
  return ((() => {
    const $$try = (sp_clone)(($state.obj)[$state.attr].mode);
    if (("$sp$Compiler$Lexer$Indent" === ($$try)[0])) {
      return ((() => {
        const $$try = (sp_clone)(($state.obj)[$state.attr].tabsOrSpaces);
        if (("$sp$Compiler$Lexer$Tabs" === ($$try)[0])) {
          return ((($sp$Compiler$Lexer$tryIndent)("\t"))($char))($state);
        }
        if (("$sp$Compiler$Lexer$Spaces" === ($$try)[0])) {
          return ((($sp$Compiler$Lexer$tryIndent)(" "))($char))($state);
        }
        if (("$sp$Compiler$Lexer$NoTabsOrSpacesYet" === ($$try)[0])) {
          return ((() => {
            const $$try = $char;
            if ((" " === $$try)) {
              (($state.obj)[$state.attr].tabsOrSpaces = $sp$Compiler$Lexer$Spaces, null);
              return (($sp$Compiler$Lexer$lexOne)($char))($state);
              return null;
            }
            if (("\t" === $$try)) {
              (($state.obj)[$state.attr].tabsOrSpaces = $sp$Compiler$Lexer$Tabs, null);
              return (($sp$Compiler$Lexer$lexOne)($char))($state);
              return null;
            }
            if (true) {
              return ((($sp$Compiler$Lexer$tryIndent)(" "))($char))($state);
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 492:14', (sp_toHuman)($$try));
          }))();
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 484:10', (sp_toHuman)($$try));
      }))();
    }
    if (("$sp$Compiler$Lexer$Default" === ($$try)[0])) {
      return ((() => {
        const $$try = $char;
        if (("" === $$try)) {
          return null;
        }
        if (("." === $$try)) {
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Dot))($state);
        }
        if (("@" === $$try)) {
          (($state.obj)[$state.attr].tokenStart = ($sp$Compiler$Lexer$getPos)($state), null);
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Mutable))($state);
          return null;
        }
        if (("#" === $$try)) {
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$LineComment))($state);
        }
        if (("[" === $$try)) {
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningBlockComment))($state);
        }
        if (("\"" === $$try)) {
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningQuotes_One))($state);
        }
        if (("\n" === $$try)) {
          (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1), null);
          (($state.obj)[$state.attr].soFarThereAreNoTokensInThisLine = true, null);
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Indent))($state);
          return null;
        }
        if ((" " === $$try)) {
          return (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) + 1), null);
        }
        if (true) {
          (($state.obj)[$state.attr].tokenStart = ($sp$Compiler$Lexer$getPos)($state), null);
          return (($sp$Compiler$Lexer$isWordStart)($char)
            ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameNoModifier)))($state)
            : (($sp$Compiler$Lexer$isNumber)($char)
              ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$NumberLiteral))($state)
              : (($sp$Compiler$Lexer$isSquiggle)($char)
                ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Squiggles))($state)
                : (($sp$Compiler$Lexer$addParenOrCommaToken)($char))($state))));
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 503:10', (sp_toHuman)($$try));
      }))();
    }
    if (("$sp$Compiler$Lexer$Dot" === ($$try)[0])) {
      return (((sp_equal)("."))($char)
        ? ((() => {
          (((($sp$Compiler$Lexer$relAddToken)((0 - 1)))(1))(($sp$Types$Token$Binop)($sp$Prelude$textConcat)))($state);
          return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
        }))()
        : (($sp$Compiler$Lexer$isWordStart)($char)
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameStartsWithDot)))($state)
          : (($sp$Compiler$Lexer$isNumber)($char)
            ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$NumberLiteral))($state)
            : (($sp$Compiler$Lexer$addError)("no idea what this is"))($state))));
    }
    if (("$sp$Compiler$Lexer$Mutable" === ($$try)[0])) {
      return (($sp$Compiler$Lexer$isWordStart)($char)
        ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$Word)($sp$Types$Token$NameMutable)))($state)
        : (($sp$Compiler$Lexer$isSquiggle)($char)
          ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Squiggles))($state)
          : (($sp$Compiler$Lexer$addError)("no idea what this is"))($state)));
    }
    if (("$sp$Compiler$Lexer$Word" === ($$try)[0])) {
      const $modifier = ($$try)[1];
      return (($sp$Compiler$Lexer$isWordBody)($char)
        ? null
        : ((() => {
          (($sp$Compiler$Lexer$addWordToken)($modifier))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
      return null;
    }
    if (("$sp$Compiler$Lexer$NumberLiteral" === ($$try)[0])) {
      return (($sp$Compiler$Lexer$isNumber)($char)
        ? null
        : ((() => {
          ($sp$Compiler$Lexer$addNumberToken)($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$Squiggles" === ($$try)[0])) {
      return (($sp$Compiler$Lexer$isSquiggle)($char)
        ? null
        : ((() => {
          (($sp$Compiler$Lexer$addSquiggleToken)(((sp_equal)(" "))($char)))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$ContentOpeningQuotes_One" === ($$try)[0])) {
      return (((sp_equal)("\""))($char)
        ? (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$ContentOpeningQuotes_Two))($state)
        : (((sp_equal)(""))($char)
          ? (($sp$Compiler$Lexer$addError)("there's no closing quotes"))($state)
          : ((() => {
            (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) - 1), null);
            (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
              lastEscape: -(1),
            }))))($state);
            return (($sp$Compiler$Lexer$lexOne)($char))($state);
          }))()));
    }
    if (("$sp$Compiler$Lexer$ContentOpeningQuotes_Two" === ($$try)[0])) {
      return (((sp_equal)("\""))($char)
        ? ((() => {
          (($state.obj)[$state.attr].tokenStart = (($sp$Compiler$Lexer$getPos)($state) - 2), null);
          return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
            closingQuotes: 0,
            lastEscape: -(1),
          }))))($state);
        }))()
        : ((() => {
          (((($sp$Compiler$Lexer$relAddToken)((0 - 2)))(0))(($sp$Types$Token$TextLiteral)("")))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$SingleQuote" === ($$try)[0])) {
      const $lastEscape = ($$try)[1].lastEscape;
      const $previousIsEscape = ((sp_equal)(($lastEscape + 1)))($pos);
      return (((sp_equal)(""))($char)
        ? (($sp$Compiler$Lexer$addError)("there's no closing quotes"))($state)
        : ($previousIsEscape
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
            lastEscape: $lastEscape,
          }))))($state)
          : ((() => {
            const $$try = $char;
            if (("\"" === $$try)) {
              const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
              const $end = ($pos + 1);
              const $value = ((($corelib$Text$replace)("\\\""))("\""))(((($sp$SPLib$Buffer$slice)(($start + 1)))(($end - 1)))((sp_clone)(($state.obj)[$state.attr].buffer)));
              (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$TextLiteral)($value)))($state);
              return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
              return null;
            }
            if (("\\" === $$try)) {
              return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$SingleQuote)(({
                lastEscape: $pos,
              }))))($state);
            }
            if (true) {
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 629:12', (sp_toHuman)($$try));
          }))()));
      return null;
    }
    if (("$sp$Compiler$Lexer$TripleQuote" === ($$try)[0])) {
      const $closingQuotes = ($$try)[1].closingQuotes;
      const $lastEscape = ($$try)[1].lastEscape;
      const $previousIsEscape = ((sp_equal)(($lastEscape + 1)))($pos);
      return (((sp_equal)(""))($char)
        ? (($sp$Compiler$Lexer$addError)("unterminated triple quotes"))($state)
        : ($previousIsEscape
          ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
            closingQuotes: 0,
            lastEscape: $lastEscape,
          }))))($state)
          : ((() => {
            const $$try = $char;
            if (("\"" === $$try)) {
              return (((sp_equal)(2))($closingQuotes)
                ? ((() => {
                  const $start = (sp_clone)(($state.obj)[$state.attr].tokenStart);
                  const $end = ($pos + 1);
                  const $value = ($sp$Compiler$Lexer$unindent)(((($sp$SPLib$Buffer$slice)(($start + 3)))(($end - 3)))((sp_clone)(($state.obj)[$state.attr].buffer)));
                  (((($sp$Compiler$Lexer$absAddToken)($start))($end))(($sp$Types$Token$TextLiteral)($value)))($state);
                  return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
                }))()
                : (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                  closingQuotes: ($closingQuotes + 1),
                  lastEscape: $lastEscape,
                }))))($state));
            }
            if (("\\" === $$try)) {
              return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                closingQuotes: 0,
                lastEscape: $pos,
              }))))($state);
            }
            if (true) {
              return (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$TripleQuote)(({
                closingQuotes: 0,
                lastEscape: $lastEscape,
              }))))($state);
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 669:13', (sp_toHuman)($$try));
          }))()));
      return null;
    }
    if (("$sp$Compiler$Lexer$LineComment" === ($$try)[0])) {
      return ((((sp_equal)("\n"))($char) || ((sp_equal)(""))($char))
        ? ((() => {
          (((($sp$Compiler$Lexer$absAddToken)((sp_clone)(($state.obj)[$state.attr].tokenStart)))(($sp$Compiler$Lexer$getPos)($state)))($sp$Types$Token$Comment))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))()
        : null);
    }
    if (("$sp$Compiler$Lexer$ContentOpeningBlockComment" === ($$try)[0])) {
      return (((sp_equal)("#"))($char)
        ? (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$BlockComment)(({
          nesting: 1,
          previous: "",
        }))))($state)
        : ((() => {
          (((($sp$Compiler$Lexer$relAddToken)((0 - 1)))(0))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))($state);
          (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
          return (($sp$Compiler$Lexer$lexOne)($char))($state);
        }))());
    }
    if (("$sp$Compiler$Lexer$BlockComment" === ($$try)[0])) {
      const $nesting = ($$try)[1].nesting;
      const $previous = ($$try)[1].previous;
      const $continueWithDeltaNesting = (($dn) => (($sp$Compiler$Lexer$setMode)(($sp$Compiler$Lexer$BlockComment)(({
        nesting: ($nesting + $dn),
        previous: $char,
      }))))($state));
      return ((() => {
        const $$try = ({
          first: $previous,
          second: $char,
        });
        if ((("[" === $$try.first) && ("#" === $$try.second))) {
          return ($continueWithDeltaNesting)(1);
        }
        if ((("#" === $$try.first) && ("]" === $$try.second))) {
          return (($nesting > 1)
            ? ($continueWithDeltaNesting)((0 - 1))
            : ((() => {
              (((($sp$Compiler$Lexer$absAddToken)((sp_clone)(($state.obj)[$state.attr].tokenStart)))(($sp$Compiler$Lexer$getPos)($state)))($sp$Types$Token$Comment))($state);
              return (($sp$Compiler$Lexer$setMode)($sp$Compiler$Lexer$Default))($state);
            }))());
        }
        if (("" === $$try.second)) {
          return (($sp$Compiler$Lexer$addError)("unterminated block comment"))($state);
        }
        if (true) {
          return ($continueWithDeltaNesting)(0);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 713:10', (sp_toHuman)($$try));
      }))();
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Lexer.sp 481:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$SPLib$Buffer$init = (($s) => ({
  fullSize: (text_length)($s),
  fullText: $s,
  nextPos: 0,
}));

const $sp$Compiler$Lexer$readStateInit = (($moduleName) => (($moduleCode) => ({
  buffer: ($sp$SPLib$Buffer$init)($moduleCode),
  column: 0,
  errors: $core$SPCore$Nil,
  indentStack: $core$SPCore$Nil,
  indentStartsABlock: true,
  line: 0,
  lineIndent: 0,
  mode: $sp$Compiler$Lexer$Indent,
  moduleName: $moduleName,
  soFarThereAreNoTokensInThisLine: true,
  tabsOrSpaces: $sp$Compiler$Lexer$NoTabsOrSpacesYet,
  tokenStart: 0,
  tokens: (array_fromList)($core$SPCore$Nil),
})));

const $sp$Compiler$Lexer$lexer = (($moduleName) => (($moduleCode) => {
  (sp_benchStart)(null);
  const $state = ({
    attr: "$",
    obj: ({
      $: (($sp$Compiler$Lexer$readStateInit)($moduleName))($moduleCode),
    }),
  });
  ((text_forEach)($moduleCode))((($char) => {
    (($sp$Compiler$Lexer$lexOne)($char))($state);
    (($state.obj)[$state.attr].buffer.nextPos += 1, null);
    return (((sp_equal)("\n"))($char)
      ? ((() => {
        (($state.obj)[$state.attr].line += 1, null);
        return (($state.obj)[$state.attr].column = 0, null);
      }))()
      : (($state.obj)[$state.attr].column += 1, null));
  }));
  (($sp$Compiler$Lexer$lexOne)(""))($state);
  return (((sp_equal)($core$SPCore$Nil))((sp_clone)(($state.obj)[$state.attr].errors))
    ? ((() => {
      ($sp$Compiler$Lexer$closeOpenBlocks)($state);
      return ((($corelib$Basics$btw)(sp_benchStop))("lexer"))(($corelib$Result$Ok)((array_toList)((sp_clone)(($state.obj)[$state.attr].tokens))));
    }))()
    : ((($corelib$Basics$btw)(sp_benchStop))("lexer"))(($corelib$Result$Err)(($sp$Compiler$Error$Nested)((sp_clone)(($state.obj)[$state.attr].errors)))));
}));

const $sp$Compiler$Lexer_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$TestHelpers$moduleName = "(test)";

const $sp$Compiler$TestHelpers$dummyErrorEnv = (($code) => ({
  moduleByName: (($corelib$Dict$singleton)($sp$Compiler$TestHelpers$moduleName))(({
    content: $code,
    fsPath: "<TestPath>",
  })),
}));

const $sp$Compiler$TestHelpers$formattedToStrippedText = (($formatted) => {
  const $strip = (($fmt) => ((() => {
    const $$try = $fmt;
    if (("$sp$Compiler$Error$FormattedText_Default" === ($$try)[0])) {
      const $t = ($$try)[1];
      return $t;
      return null;
    }
    if (("$sp$Compiler$Error$FormattedText_Emphasys" === ($$try)[0])) {
      const $t = ($$try)[1];
      return $t;
      return null;
    }
    if (("$sp$Compiler$Error$FormattedText_Warning" === ($$try)[0])) {
      const $t = ($$try)[1];
      return $t;
      return null;
    }
    if (("$sp$Compiler$Error$FormattedText_Decoration" === ($$try)[0])) {
      const $t = ($$try)[1];
      return $t;
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TestHelpers.sp 62:8', (sp_toHuman)($$try));
  }))());
  return (($corelib$Text$join)(""))((($corelib$List$map)($strip))($formatted));
});

const $sp$Compiler$TestHelpers$resErrorToStrippedText = (($code) => ($corelib$Result$mapError)((($e) => ($sp$Compiler$TestHelpers$formattedToStrippedText)((($sp$Compiler$Error$toFormattedText)(($sp$Compiler$TestHelpers$dummyErrorEnv)($code)))($e)))));

const $sp$Compiler$Lexer_Test$lexTokens = (($s) => (($sp$Compiler$TestHelpers$resErrorToStrippedText)($s))((($sp$Compiler$Lexer$lexer)($sp$Compiler$TestHelpers$moduleName))($s)));

const $sp$Compiler$Lexer_Test$non_mut_name = (($n) => (((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))($n))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$comments = (($sp$Test$Group)("Comments"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] statement after comment"))("\n#\na = 1\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(3))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(5))(6))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] nested comments allow a spurious newline?"))("\n[#[##]#]\na = 1\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(8))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(10))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(11))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(14))(15))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Single line"))("# hello"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(7))($sp$Types$Token$Comment)))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Multi line"))("[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(16))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(19))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(20))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(32))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(34))(35))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(36))(37))(($sp$Types$Token$NumberLiteral)("1"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(58))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(61))(78))($sp$Types$Token$Comment)))($core$SPCore$Nil))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("brackets"))("[]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] Inline comments should not break a block"))("allTests = [\n    , a\n#\n    ]"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(8))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("allTests"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(9))(10))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(11))(12))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(17))(18))($sp$Types$Token$Comma)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(19))(20))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("a"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(22))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(27))(28))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(28))(28))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil)))))))))))))($core$SPCore$Nil)))))));

const $sp$Compiler$Lexer_Test$indentation = (($sp$Test$Group)("Blocks, sibling lines, indentation"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("1"))("\na =\n 1\nb = 1"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(1))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(6))(6))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(6))(7))(($sp$Types$Token$NumberLiteral)("1"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(8))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(8))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(8))(9))(($sp$Compiler$Lexer_Test$non_mut_name)("b"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(10))(11))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))(($sp$Types$Token$NumberLiteral)("1"))))($core$SPCore$Nil))))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] spurious spaces in front of field name"))("module =\n   importAs =\n      SPCore\n   globalTypes =\n      None"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("module"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(12))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(20))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("importAs"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(21))(22))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(29))(29))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(29))(35))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("SPCore"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(39))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(39))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(39))(50))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("globalTypes"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(51))(52))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(59))(59))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(59))(63))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("None"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(63))(63))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(63))(63))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil))))))))))))))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Blocks and not"))((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("module ="))((($core$SPCore$Cons)("   i ="))((($core$SPCore$Cons)("        j"))((($core$SPCore$Cons)("            >> k"))((($core$SPCore$Cons)("            >> s"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   importAs ="))((($core$SPCore$Cons)("      SPCore"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   globalTypes ="))((($core$SPCore$Cons)("      None"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   a +     # no block start!"))((($core$SPCore$Cons)("        b   # no sibling"))((($core$SPCore$Cons)("        c"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   d =     # block start"))((($core$SPCore$Cons)("        e   # sibling!"))((($core$SPCore$Cons)("        f"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("   g = h"))($core$SPCore$Nil))))))))))))))))))))))))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("module"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(7))(8))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(12))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(12))(13))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("i"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(14))(15))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(24))(24))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(24))(25))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("j"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(38))(40))(($sp$Types$Token$Binop)(({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))))(false))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))),
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(41))(42))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("k"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(55))(57))(($sp$Types$Token$Binop)(({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Pipe,
  symbol: ">>",
  type: (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))))(false))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("a")))(false))((($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$N))("b"))),
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(58))(59))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("s"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(64))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(64))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(64))(72))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("importAs"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(73))(74))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(81))(81))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(81))(87))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("SPCore"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(92))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(92))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(92))(103))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("globalTypes"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(104))(105))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(112))(112))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(112))(116))((($sp$Types$Token$UpperName)($corelib$Maybe$Nothing))("None"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(121))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(121))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(121))(122))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("a"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(123))(124))(($sp$Types$Token$Binop)(({
  associativity: $sp$Types$Op$Left,
  nonFn: $core$SPCore$Nil,
  precedence: $sp$Types$Op$Addittive,
  symbol: "+",
  type: (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$N))((($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("Number")))($core$SPCore$Nil)))(false))((((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$N))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$N))((($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("Number")))($core$SPCore$Nil)))(false))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$N))((($sp$Types$Meta$USR)((($sp$Types$Meta$UMR)($sp$Types$Meta$Core))("SPCore")))("Number")))($core$SPCore$Nil))),
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(129))(146))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(155))(156))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(159))(171))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(180))(181))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(186))(186))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(186))(187))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("d"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(188))(189))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(194))(207))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(216))(216))($sp$Types$Token$BlockStart)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(216))(217))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("e"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(220))(230))($sp$Types$Token$Comment)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(239))(239))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(239))(240))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("f"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(245))($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(245))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(245))(246))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("g"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(247))(248))(($sp$Types$Token$Defop)(({
  mutable: false,
})))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(249))(250))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("h"))($core$SPCore$Nil))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(250))(250))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))($core$SPCore$Nil))));

const $sp$Compiler$Lexer_Test$keywords = (($sp$Test$Group)("keywords"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] can't @ keywords"))("@with"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("keyword"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$lexTokensAndDrop = (($n) => (($s) => (($corelib$Result$map)(($corelib$List$drop)($n)))(($sp$Compiler$Lexer_Test$lexTokens)($s))));

const $sp$Compiler$Lexer_Test$ops = (($sp$Test$Group)("Operators"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] .. set Default"))(".. []"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$Binop)($sp$Prelude$textConcat))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(4))(5))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed))))($core$SPCore$Nil))))))))($core$SPCore$Nil));

const $sp$Compiler$Lexer_Test$position = (($sp$Test$Group)("Position"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] ops position"))("blah <>"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah <>"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] ops position, with newline"))("blah <>\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$errorContains)((($core$SPCore$Cons)("blah <>"))($core$SPCore$Nil)))))($core$SPCore$Nil)));

const $sp$Compiler$Lexer_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $sp$Compiler$Lexer_Test$textLiterals = (($sp$Test$Group)("Text literals"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Empty Text"))("\"\""))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$TextLiteral)(""))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Followed by colon"))("\"n\":\n"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(3))(($sp$Types$Token$TextLiteral)("n"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(3))(4))($sp$Types$Token$Colon)))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("[reg] should not add the indent!"))("try char as\n    \"\":\n        None\n\n    \"@\""))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(11)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(38))(41))(($sp$Types$Token$TextLiteral)("@"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(41))(41))($sp$Types$Token$BlockEnd)))($core$SPCore$Nil))))))((($core$SPCore$Cons)(((($sp$Compiler$Lexer_Test$valueTest)("Unindent function"))((() => ($sp$Compiler$Lexer$unindent)((($corelib$Text$join)(""))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("  a\n"))((($core$SPCore$Cons)("      \n"))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("  b\n"))((($core$SPCore$Cons)("  "))($core$SPCore$Nil)))))))))))(($sp$Test$isOkAndEqualTo)((($corelib$Text$join)(""))((($core$SPCore$Cons)("a\n"))((($core$SPCore$Cons)("    \n"))((($core$SPCore$Cons)("\n"))((($core$SPCore$Cons)("b"))($core$SPCore$Nil)))))))))($core$SPCore$Nil)))));

const $sp$Compiler$Lexer_Test$unaryAddittiveOps = (($sp$Test$Group)("Unary addittive ops"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("-a"))("-a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("a - -a"))("a - -a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(2))(3))(($sp$Types$Token$Binop)($sp$Prelude$subtract))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(4))(5))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(5))(6))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("a-a"))("a-a"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(1))(2))(($sp$Types$Token$Unop)($sp$Prelude$unaryMinus))))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(2))(3))(($sp$Compiler$Lexer_Test$non_mut_name)("a"))))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("Mutable colon:"))("@:"))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))($sp$Types$Token$MutableColon)))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("-="))("-="))($sp$Compiler$Lexer_Test$lexTokens))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(0))($sp$Types$Token$NewSiblingLine)))((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(2))(($sp$Types$Token$Binop)($sp$Prelude$mutableSubtract))))($core$SPCore$Nil))))))($core$SPCore$Nil))))));

const $sp$Compiler$Lexer_Test$underscores = (($sp$Test$Group)("Underscores"))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'_' as a Name"))("_"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(1))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("_"))($core$SPCore$Nil))))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'_10_20' as a Name"))("_10_20"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(6))((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("_10_20"))($core$SPCore$Nil))))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$Lexer_Test$codeTest)("'10_20' as a Number"))("10_20"))(($sp$Compiler$Lexer_Test$lexTokensAndDrop)(1)))(($sp$Test$isOkAndEqualTo)((($core$SPCore$Cons)(((($sp$Types$Token$Token)(0))(5))(($sp$Types$Token$NumberLiteral)("10_20"))))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$Lexer_Test$tests = (($sp$Test$Group)("Lexer"))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$keywords))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$ops))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$unaryAddittiveOps))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$indentation))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$comments))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$underscores))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$position))((($core$SPCore$Cons)($sp$Compiler$Lexer_Test$textLiterals))($core$SPCore$Nil)))))))));

const $sp$Compiler$MakeCanonical$makeError = (($pos) => (($msg) => (($sp$Compiler$Error$res)($pos))((($errorEnv) => $msg))));

const $sp$Compiler$MakeCanonical$maybeForeignUsr = (($getter) => (($ro) => (($maybeModule) => (($name) => ((() => {
  const $$try = $maybeModule;
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $moduleName = ($$try)[1];
    return ((() => {
      const $$try = (($corelib$Dict$get)($moduleName))($ro.meta.moduleVisibleAsToUmr);
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $umr = ($$try)[1];
        return ($corelib$Maybe$Just)((($sp$Types$Meta$USR)($umr))($name));
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (sp_todo)(("!!resolveToUsr can't find the module: " + ($moduleName + (" (for: " + ($name + ")")))));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 105:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return (($corelib$Dict$get)($name))(($getter)($ro.meta));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 103:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$MakeCanonical$resolveToUsr = (($getter) => (($ro) => (($maybeModule) => (($name) => (($corelib$Maybe$withDefault)((($sp$Types$Meta$USR)($ro.currentModule))($name)))((((($sp$Compiler$MakeCanonical$maybeForeignUsr)($getter))($ro))($maybeModule))($name))))));

const $sp$Compiler$MakeCanonical$resolveToTypeUsr = ($sp$Compiler$MakeCanonical$resolveToUsr)((($m) => $m.globalTypes));

const $sp$Compiler$MakeCanonical$translateType = (($mrf) => (($ro) => (($faType) => ((() => {
  const $$try = $faType;
  if (("$sp$Types$FormattableAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return ((() => {
      const $$try = $mrf;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$TypeVariable)($pos))($name));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $renameFunction = ($$try)[1];
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$TypeVariable)($pos))((($renameFunction)($pos))($name)));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 932:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $maybeModule = ($$try)[2];
    const $name = ($$try)[3];
    const $args = ($$try)[4];
    return (($corelib$Result$onOk)((($caArgs) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeConstant)($pos))(((($sp$Compiler$MakeCanonical$resolveToTypeUsr)($ro))($maybeModule))($name)))($caArgs)))))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro)))($args));
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fa_from = ($$try)[2];
    const $fromIsMut = ($$try)[3];
    const $fa_to = ($$try)[4];
    return (($corelib$Result$onOk)((($ca_from) => (($corelib$Result$onOk)((($ca_to) => ($corelib$Result$Ok)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($ca_from))($fromIsMut))($ca_to)))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($fa_to)))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($fa_from));
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeTuple" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $types = ($$try)[2];
    return ((() => {
      const $$try = $types;
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0])))) {
        const $faFirst = ($$try)[1];
        const $faSecond = (($$try)[2])[1];
        return (($corelib$Result$onOk)((($caFirst) => (($corelib$Result$onOk)((($caSecond) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($caSecond))(((($corelib$Dict$insert)("first"))($caFirst))($corelib$Dict$empty)))))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faSecond)))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faFirst));
        return null;
      }
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && (("$core$SPCore$Cons" === ((($$try)[2])[2])[0]) && ("$core$SPCore$Nil" === (((($$try)[2])[2])[2])[0]))))) {
        const $faFirst = ($$try)[1];
        const $faSecond = (($$try)[2])[1];
        const $faThird = ((($$try)[2])[2])[1];
        return (($corelib$Result$onOk)((($caFirst) => (($corelib$Result$onOk)((($caSecond) => (($corelib$Result$onOk)((($caThird) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("third"))($caThird))(((($corelib$Dict$insert)("second"))($caSecond))(((($corelib$Dict$insert)("first"))($caFirst))($corelib$Dict$empty))))))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faThird)))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faSecond)))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faFirst));
        return null;
      }
      if (true) {
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Tuples can only have size 2 or 3. Use a record."))($core$SPCore$Nil));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 951:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeList" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $faItem = ($$try)[2];
    return (($corelib$Result$onOk)((($caItem) => ($corelib$Result$Ok)(($sp$Compiler$CoreTypes$list)($caItem)))))(((($sp$Compiler$MakeCanonical$translateType)($mrf))($ro))($faItem));
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeRecord" === ($$try)[0])) {
    const $p = ($$try)[1];
    const $recordArgs = ($$try)[2];
    return (((sp_not_equal)($corelib$Maybe$Nothing))($recordArgs.extends)
      ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)("For now extensible types are disabled, I want to see if it's good to do without them"))($core$SPCore$Nil))
      : (((($sp$Compiler$MakeCanonical$addAttributes)($ro))($p))($recordArgs.attrs))($corelib$Dict$empty));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 930:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$MakeCanonical$addAttributes = (($ro) => (($pos) => (($faAttrs) => (($caAttrsAccum) => ((() => {
  const $$try = $faAttrs;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($caAttrsAccum));
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$sp$Types$Pos$At" === (($$try)[1].first)[0]))) {
    const $p = (($$try)[1].first)[1];
    const $name = (($$try)[1].first)[2];
    const $maybeFaType = ($$try)[1].second;
    const $faTail = ($$try)[2];
    return ((() => {
      const $$try = $maybeFaType;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)(("Attribute `" + ($name + "` must have a type"))))($core$SPCore$Nil));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $faType = ($$try)[1];
        return (($corelib$Result$onOk)((($caType) => (((($sp$Compiler$MakeCanonical$addAttributes)($ro))($p))($faTail))(((($corelib$Dict$insert)($name))($caType))($caAttrsAccum)))))(((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro))($faType));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 915:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 909:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$MakeCanonical$typeDeps = (($type) => (($acc) => ((() => {
  const $$try = $type;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $usr = ($$try)[2];
    const $args = ($$try)[3];
    return ((($corelib$List$foldl)($sp$Compiler$MakeCanonical$typeDeps))($args))((($corelib$Set$insert)($usr))($acc));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    return $acc;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $from = ($$try)[2];
    const $to = ($$try)[4];
    return (($sp$Compiler$MakeCanonical$typeDeps)($to))((($sp$Compiler$MakeCanonical$typeDeps)($from))($acc));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $attrs = ($$try)[3];
    return ((($corelib$Dict$foldl)((($k) => $sp$Compiler$MakeCanonical$typeDeps)))($attrs))($acc);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    return (sp_todo)("typeDeps: Should not happen");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 158:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$patternDeps = (($pattern) => (($deps) => ((() => {
  const $$try = $pattern;
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
    const $usr = ($$try)[2];
    const $ps = ($$try)[3];
    return ((($corelib$List$foldl)($sp$Compiler$MakeCanonical$patternDeps))($ps))((Object.assign)({}, $deps, ({
      cons: (($corelib$Set$insert)($usr))($deps.cons),
    })));
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
    const $ps = ($$try)[2];
    return ((($corelib$Dict$foldl)((($k) => $sp$Compiler$MakeCanonical$patternDeps)))($ps))($deps);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[3])[0]))) {
    const $type = (($$try)[3])[1];
    return (Object.assign)({}, $deps, ({
      types: (($sp$Compiler$MakeCanonical$typeDeps)($type))($deps.types),
    }));
    return null;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Nothing" === (($$try)[3])[0]))) {
    return $deps;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
    return $deps;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
    return $deps;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 189:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$expressionDeps = (($expr) => (($deps) => ((() => {
  const $$try = $expr;
  if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try)[0])) {
    return $deps;
  }
  if (("$sp$Types$CanonicalAst$LiteralText" === ($$try)[0])) {
    return $deps;
  }
  if ((("$sp$Types$CanonicalAst$Variable" === ($$try)[0]) && ("$sp$Types$CanonicalAst$RefRoot" === (($$try)[2].ref)[0]))) {
    const $usr = (($$try)[2].ref)[1];
    return (Object.assign)({}, $deps, ({
      values: (($corelib$Set$insert)($usr))($deps.values),
    }));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Variable" === ($$try)[0])) {
    return $deps;
  }
  if (("$sp$Types$CanonicalAst$Constructor" === ($$try)[0])) {
    const $usr = ($$try)[2];
    return (Object.assign)({}, $deps, ({
      cons: (($corelib$Set$insert)($usr))($deps.cons),
    }));
    return null;
  }
  if ((("$sp$Types$CanonicalAst$Lambda" === ($$try)[0]) && ("$sp$Types$CanonicalAst$ParameterPattern" === (($$try)[2])[0]))) {
    const $pa = (($$try)[2])[1];
    const $body = ($$try)[3];
    return (($sp$Compiler$MakeCanonical$bodyDeps)($body))((($sp$Compiler$MakeCanonical$patternDeps)($pa))($deps));
    return null;
  }
  if ((("$sp$Types$CanonicalAst$Lambda" === ($$try)[0]) && ("$sp$Types$CanonicalAst$ParameterMutable" === (($$try)[2])[0]))) {
    const $body = ($$try)[3];
    return (($sp$Compiler$MakeCanonical$bodyDeps)($body))($deps);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$Record" === ($$try)[0]) && ("$corelib$Maybe$Nothing" === (($$try)[2])[0]))) {
    const $exprByName = ($$try)[3];
    return ((($corelib$Dict$foldl)((($name) => $sp$Compiler$MakeCanonical$expressionDeps)))($exprByName))($deps);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$Record" === ($$try)[0]) && (("$corelib$Maybe$Just" === (($$try)[2])[0]) && ("$sp$Types$CanonicalAst$RefRoot" === ((($$try)[2])[1].ref)[0])))) {
    const $usr = ((($$try)[2])[1].ref)[1];
    const $exprByName = ($$try)[3];
    return ((($corelib$Dict$foldl)((($name) => $sp$Compiler$MakeCanonical$expressionDeps)))($exprByName))((Object.assign)({}, $deps, ({
      values: (($corelib$Set$insert)($usr))($deps.values),
    })));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Record" === ($$try)[0])) {
    const $exprByName = ($$try)[3];
    return ((($corelib$Dict$foldl)((($name) => $sp$Compiler$MakeCanonical$expressionDeps)))($exprByName))($deps);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$Call" === ($$try)[0]) && ("$sp$Types$CanonicalAst$ArgumentExpression" === (($$try)[3])[0]))) {
    const $e0 = ($$try)[2];
    const $e1 = (($$try)[3])[1];
    return (($sp$Compiler$MakeCanonical$expressionDeps)($e1))((($sp$Compiler$MakeCanonical$expressionDeps)($e0))($deps));
    return null;
  }
  if ((("$sp$Types$CanonicalAst$Call" === ($$try)[0]) && ("$sp$Types$CanonicalAst$ArgumentMutable" === (($$try)[3])[0]))) {
    const $e0 = ($$try)[2];
    return (($sp$Compiler$MakeCanonical$expressionDeps)($e0))($deps);
    return null;
  }
  if (("$sp$Types$CanonicalAst$If" === ($$try)[0])) {
    const $args = ($$try)[2];
    return (($sp$Compiler$MakeCanonical$bodyDeps)($args.false))((($sp$Compiler$MakeCanonical$bodyDeps)($args.true))((($sp$Compiler$MakeCanonical$bodyDeps)($args.condition))($deps)));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Try" === ($$try)[0])) {
    const $e = ($$try)[2];
    const $patternsAndBodies = ($$try)[3];
    return ((($corelib$List$foldl)(((b$$) => {
      const $p = b$$.first;
      const $b = b$$.second;
      return (($d) => (($sp$Compiler$MakeCanonical$bodyDeps)($b))((($sp$Compiler$MakeCanonical$patternDeps)($p))($d)));
    })))($patternsAndBodies))((($sp$Compiler$MakeCanonical$expressionDeps)($e))($deps));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 207:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$statementDeps = (($s) => (($deps) => ((() => {
  const $$try = $s;
  if (("$sp$Types$CanonicalAst$Definition" === ($$try)[0])) {
    const $def = ($$try)[1];
    return (($sp$Compiler$MakeCanonical$bodyDeps)($def.body))((($sp$Compiler$MakeCanonical$patternDeps)($def.pattern))($deps));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Evaluation" === ($$try)[0])) {
    const $expr = ($$try)[1];
    return (($sp$Compiler$MakeCanonical$expressionDeps)($expr))($deps);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 200:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$bodyDeps = (($stats) => (($corelib$List$foldl)($sp$Compiler$MakeCanonical$statementDeps))($stats));

const $sp$Compiler$MakeCanonical$deps_init = ({
  cons: $corelib$Set$empty,
  types: $corelib$Set$empty,
  values: $corelib$Set$empty,
});

const $sp$Compiler$MakeCanonical$initEnv = (($ro) => ({
  defsPath: $core$SPCore$Nil,
  futureNonRootValues: $corelib$Dict$empty,
  maybeShorthandTarget: $corelib$Maybe$Nothing,
  nonRootValues: $corelib$Dict$empty,
  ro: $ro,
  tyvarRenames: $corelib$Dict$empty,
}));

const $sp$Compiler$MakeCanonical$insertParamNames = (($param) => ((() => {
  const $$try = $param;
  if (("$sp$Types$CanonicalAst$ParameterMutable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $n = ($$try)[2];
    return (($corelib$Dict$insert)($n))($pos);
    return null;
  }
  if (("$sp$Types$CanonicalAst$ParameterPattern" === ($$try)[0])) {
    const $pa = ($$try)[1];
    return ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($pa));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 272:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$MakeCanonical$translateConstructor = (($ro) => (($unionType) => ((faArgs$$) => {
  const $pos = (faArgs$$.first)[1];
  const $name = (faArgs$$.first)[2];
  const $faArgs = faArgs$$.second;
  return (($constructors) => ((($corelib$Dict$member)($name))($constructors)
    ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(("constructor " + ($name + " is duplicate"))))($core$SPCore$Nil))
    : (($corelib$Result$onOk)((($caArgs) => {
      const $c = ({
        args: $caArgs,
        pos: $pos,
        type: ((($corelib$List$foldr)((($ar) => (($ty) => (((($sp$Types$CanonicalAst$TypeFunction)($pos))($ar))(false))($ty)))))($caArgs))($unionType),
      });
      return ($corelib$Result$Ok)(((($corelib$Dict$insert)($name))($c))($constructors));
    })))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro)))($faArgs))));
})));

const $sp$Compiler$MakeCanonical$resolveToConstructorUsr = ($sp$Compiler$MakeCanonical$resolveToUsr)((($m) => $m.globalValues));

const $sp$Compiler$MakeCanonical$translateNumber = (($constructor) => (($pos) => (($numberAsText) => ((() => {
  const $$try = (text_toNumber)($numberAsText);
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(("invalid number: `" + ($numberAsText + "`"))))((($core$SPCore$Cons)("TODO link to documentation on valid number formats"))($core$SPCore$Nil)));
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $n = ($$try)[1];
    return ($corelib$Result$Ok)((($constructor)($pos))($n));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 645:4', (sp_toHuman)($$try));
}))())));

const $sp$Types$FormattableAst$patternPos = (($pa) => ((() => {
  const $$try = $pa;
  if (("$sp$Types$FormattableAst$PatternAny" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralNumber" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralText" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternConstructor" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternList" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternListCons" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternRecord" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternTuple" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 155:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$MakeCanonical$translatePattern = (($ann) => (($env) => (($fa) => ((() => {
  const $$try = $fa;
  if ((("$sp$Types$FormattableAst$PatternAny" === ($$try)[0]) && (true === ($$try)[2]))) {
    const $pos = ($$try)[1];
    const $s = ($$try)[3];
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("This is the wrong place to use `@`"))($core$SPCore$Nil));
    return null;
  }
  if ((("$sp$Types$FormattableAst$PatternAny" === ($$try)[0]) && (false === ($$try)[2]))) {
    const $pos = ($$try)[1];
    const $name = ($$try)[3];
    const $maybeFaType = ($$try)[4];
    return ((((sp_equal)($corelib$Maybe$Nothing))($ann) && ((sp_not_equal)($corelib$Maybe$Nothing))($maybeFaType))
      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Can't use annotations here"))($core$SPCore$Nil))
      : (($corelib$Result$onOk)((($maybeCaType) => {
        const $n = (((sp_equal)("_"))($name)
          ? $corelib$Maybe$Nothing
          : ($corelib$Maybe$Just)($name));
        return ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$PatternAny)($pos))($n))($maybeCaType));
      })))((($corelib$Maybe$mapRes)((($sp$Compiler$MakeCanonical$translateType)($ann))($env.ro)))($maybeFaType)));
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralNumber" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $l = ($$try)[2];
    return ((($sp$Compiler$MakeCanonical$translateNumber)($sp$Types$CanonicalAst$PatternLiteralNumber))($pos))($l);
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternLiteralText" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $l = ($$try)[2];
    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$PatternLiteralText)($pos))($l));
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternConstructor" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $maybeModule = ($$try)[2];
    const $name = ($$try)[3];
    const $faArgs = ($$try)[4];
    return (($corelib$Result$onOk)((($caArgs) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$PatternConstructor)($pos))(((($sp$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro))($maybeModule))($name)))($caArgs)))))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($faArgs));
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternList" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fas = ($$try)[2];
    const $fold = (($pattern) => (($last) => ((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$cons))((($core$SPCore$Cons)($pattern))((($core$SPCore$Cons)($last))($core$SPCore$Nil)))));
    return (($corelib$Result$onOk)((($cas) => ($corelib$Result$Ok)(((($corelib$List$foldr)($fold))($cas))(((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$nil))($core$SPCore$Nil))))))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($fas));
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $recordArgs = ($$try)[2];
    return (((sp_not_equal)($corelib$Maybe$Nothing))($recordArgs.extends)
      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("can't use `with` inside patterns"))($core$SPCore$Nil))
      : ((() => {
        const $fold = ((maybePattern$$) => {
          const $p = (maybePattern$$.first)[1];
          const $name = (maybePattern$$.first)[2];
          const $maybePattern = maybePattern$$.second;
          return (($dict) => ((($corelib$Dict$member)($name))($dict)
            ? (($sp$Compiler$MakeCanonical$makeError)($p))((($core$SPCore$Cons)(("duplicate attribute name in pattern: " + $name)))($core$SPCore$Nil))
            : ((() => {
              const $$try = $maybePattern;
              if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
                return ($corelib$Result$Ok)(((($corelib$Dict$insert)($name))(((($sp$Types$CanonicalAst$PatternAny)($p))(($corelib$Maybe$Just)($name)))($corelib$Maybe$Nothing)))($dict));
              }
              if (("$corelib$Maybe$Just" === ($$try)[0])) {
                const $faPattern = ($$try)[1];
                return (($corelib$Result$map)((($caPattern) => ((($corelib$Dict$insert)($name))($caPattern))($dict))))(((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))($faPattern));
                return null;
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 401:24', (sp_toHuman)($$try));
            }))()));
        });
        return (($corelib$Result$map)((($x) => (($sp$Types$CanonicalAst$PatternRecord)($pos))($x))))(((($corelib$List$foldlRes)($fold))($recordArgs.attrs))($corelib$Dict$empty));
      }))());
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternListCons" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $pas = ($$try)[2];
    return (($corelib$Result$onOk)((($caPas) => ((() => {
      const $$try = ($corelib$List$reverse)($caPas);
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $last = ($$try)[1];
        const $rest = ($$try)[2];
        return ($corelib$Result$Ok)(((($corelib$List$foldl)((($item) => (($list) => ((($sp$Types$CanonicalAst$PatternConstructor)($pos))($sp$Compiler$CoreTypes$cons))((($core$SPCore$Cons)($item))((($core$SPCore$Cons)($list))($core$SPCore$Nil)))))))($rest))($last));
        return null;
      }
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("should not happen: empty cons pattern"))($core$SPCore$Nil));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 415:12', (sp_toHuman)($$try));
    }))())))((($corelib$List$mapRes)((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env)))($pas));
    return null;
  }
  if (("$sp$Types$FormattableAst$PatternTuple" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fas = ($$try)[2];
    return ((() => {
      const $$try = $fas;
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0])))) {
        const $fa1 = ($$try)[1];
        const $fa2 = (($$try)[2])[1];
        return ((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))((($sp$Types$FormattableAst$PatternRecord)($pos))(({
          attrs: (($core$SPCore$Cons)(({
            first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa1)))("first"),
            second: ($corelib$Maybe$Just)($fa1),
          })))((($core$SPCore$Cons)(({
            first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa2)))("second"),
            second: ($corelib$Maybe$Just)($fa2),
          })))($core$SPCore$Nil)),
          extends: $corelib$Maybe$Nothing,
        })));
        return null;
      }
      if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && (("$core$SPCore$Cons" === ((($$try)[2])[2])[0]) && ("$core$SPCore$Nil" === (((($$try)[2])[2])[2])[0]))))) {
        const $fa1 = ($$try)[1];
        const $fa2 = (($$try)[2])[1];
        const $fa3 = ((($$try)[2])[2])[1];
        return ((($sp$Compiler$MakeCanonical$translatePattern)($ann))($env))((($sp$Types$FormattableAst$PatternRecord)($pos))(({
          attrs: (($core$SPCore$Cons)(({
            first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa1)))("first"),
            second: ($corelib$Maybe$Just)($fa1),
          })))((($core$SPCore$Cons)(({
            first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa2)))("second"),
            second: ($corelib$Maybe$Just)($fa2),
          })))((($core$SPCore$Cons)(({
            first: (($sp$Types$Pos$At)(($sp$Types$FormattableAst$patternPos)($fa3)))("third"),
            second: ($corelib$Maybe$Just)($fa3),
          })))($core$SPCore$Nil))),
          extends: $corelib$Maybe$Nothing,
        })));
        return null;
      }
      if (true) {
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("tuples can be only of size 2 or 3"))($core$SPCore$Nil));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 425:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 359:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$MakeCanonical$makeUpdateTarget = (($pos) => (($env) => (($maybeShorthandTarget) => ((() => {
  const $$try = (($corelib$Maybe$map)(($sp$Compiler$MakeCanonical$translateExpression)((Object.assign)({}, $env, ({
    maybeShorthandTarget: $corelib$Maybe$Nothing,
  })))))($maybeShorthandTarget);
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ($corelib$Result$Ok)(({
      maybeName: $corelib$Maybe$Nothing,
      wrapper: $corelib$Basics$identity,
    }));
  }
  if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$corelib$Result$Err" === (($$try)[1])[0]))) {
    const $e = (($$try)[1])[1];
    return ($corelib$Result$Err)($e);
    return null;
  }
  if ((("$corelib$Maybe$Just" === ($$try)[0]) && (("$corelib$Result$Ok" === (($$try)[1])[0]) && ("$sp$Types$CanonicalAst$Variable" === ((($$try)[1])[1])[0])))) {
    const $args = ((($$try)[1])[1])[2];
    return ($corelib$Result$Ok)(({
      maybeName: ($corelib$Maybe$Just)($args),
      wrapper: $corelib$Basics$identity,
    }));
    return null;
  }
  if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$corelib$Result$Ok" === (($$try)[1])[0]))) {
    const $expr = (($$try)[1])[1];
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("NI { (expr) with ...} not yet implemented =("))($core$SPCore$Nil));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 658:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$MakeCanonical$resolveToValueRef = (($ro) => (($declaredInsideFunction) => (($maybeModule) => (($name) => ((() => {
  const $$try = (((($sp$Compiler$MakeCanonical$maybeForeignUsr)((($m) => $m.globalValues)))($ro))($maybeModule))($name);
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $usr = ($$try)[1];
    return ($sp$Types$CanonicalAst$RefRoot)($usr);
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ($declaredInsideFunction
      ? ($sp$Types$CanonicalAst$RefBlock)($name)
      : ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($ro.currentModule))($name)));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 131:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$MakeCanonical$translateArgument = (($env) => (($faExpr) => ((() => {
  const $$try = $faExpr;
  if (("$sp$Types$FormattableAst$Mutable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    const $attrPath = ($$try)[3];
    return ((($corelib$Dict$member)($name))($env.nonRootValues)
      ? ($corelib$Result$Ok)((($sp$Types$CanonicalAst$ArgumentMutable)($pos))(({
        attrPath: $attrPath,
        ref: ($sp$Types$CanonicalAst$RefBlock)($name),
      })))
      : (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("only values declared inside a function scope can be mutated!"))($core$SPCore$Nil)));
    return null;
  }
  if (true) {
    return (($corelib$Result$map)($sp$Types$CanonicalAst$ArgumentExpression))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 702:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$translateAttrsRec = (($env) => (($faAttrs) => (($caAttrsAccum) => ((() => {
  const $$try = $faAttrs;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($corelib$Result$Ok)($caAttrsAccum);
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$sp$Types$Pos$At" === (($$try)[1].first)[0]))) {
    const $pos = (($$try)[1].first)[1];
    const $attrName = (($$try)[1].first)[2];
    const $maybeAttrExpression = ($$try)[1].second;
    const $faTail = ($$try)[2];
    const $exprRes = ((() => {
      const $$try = $maybeAttrExpression;
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $faExpr = ($$try)[1];
        return (($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr);
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        const $declaredInsideFunction = (($corelib$Dict$member)($attrName))($env.nonRootValues);
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
          attrPath: $core$SPCore$Nil,
          ref: (((($sp$Compiler$MakeCanonical$resolveToValueRef)($env.ro))($declaredInsideFunction))($corelib$Maybe$Nothing))($attrName),
        })));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 682:16', (sp_toHuman)($$try));
    }))();
    return (($corelib$Result$onOk)((($expr) => ((($sp$Compiler$MakeCanonical$translateAttrsRec)($env))($faTail))(((($corelib$Dict$insert)($attrName))($expr))($caAttrsAccum)))))($exprRes);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 676:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$MakeCanonical$notAllSeparators = (($f) => (($ls) => ((() => {
  const $$try = $ls;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return false;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $sep = ($$try)[1].first;
    const $item = ($$try)[1].second;
    const $tail = ($$try)[2];
    return (($f)($sep)
      ? (($sp$Compiler$MakeCanonical$notAllSeparators)($f))($tail)
      : true);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 800:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$sameDirectionAs = (($a) => (($b) => (((sp_equal)($b.symbol))($a.symbol)
  ? true
  : ((() => {
    const $$try = $a.symbol;
    if ((">" === $$try)) {
      return ((sp_equal)(">="))($b.symbol);
    }
    if ((">=" === $$try)) {
      return ((sp_equal)(">"))($b.symbol);
    }
    if (("<" === $$try)) {
      return ((sp_equal)("<="))($b.symbol);
    }
    if (("<=" === $$try)) {
      return ((sp_equal)("<"))($b.symbol);
    }
    if (true) {
      return false;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 818:8', (sp_toHuman)($$try));
  }))())));

const $sp$Compiler$MakeCanonical$makeBinop = (($pos) => (($left) => (($op) => (($right) => ((() => {
  const $$try = ({
    first: $left,
    second: $op.symbol,
    third: $right,
  });
  if (((">>" === $$try.second) && ("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try.third)[0]))) {
    const $rightExpr = ($$try.third)[1];
    return ((($sp$Types$CanonicalAst$Call)($pos))($rightExpr))($left);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try.first)[0]) && ("<<" === $$try.second))) {
    const $leftExpr = ($$try.first)[1];
    return ((($sp$Types$CanonicalAst$Call)($pos))($leftExpr))($right);
    return null;
  }
  if (true) {
    return ((($sp$Types$CanonicalAst$Call)($pos))(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Variable)($pos))(({
      attrPath: $core$SPCore$Nil,
      ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Types$Meta$spCoreUSR)($op.symbol)),
    }))))($right)))($left);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 872:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$MakeCanonical$translateBinopSepListRec = (($env) => (($pos) => (($leftAccum) => (($opsAndRight) => ((() => {
  const $$try = $opsAndRight;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($corelib$Result$Ok)($leftAccum);
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $op = ($$try)[1].first;
    const $faRight = ($$try)[1].second;
    const $tail = ($$try)[2];
    return (($corelib$Result$onOk)((($caRight) => (((($sp$Compiler$MakeCanonical$translateBinopSepListRec)($env))($pos))((((($sp$Compiler$MakeCanonical$makeBinop)($pos))(($sp$Types$CanonicalAst$ArgumentExpression)($leftAccum)))($op))($caRight)))($tail))))((($sp$Compiler$MakeCanonical$translateArgument)($env))($faRight));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 856:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$MakeCanonical$translateBinopSepList_leftAssociative = (($env) => (($pos) => (($leftAccum) => (($opsAndRight) => (($corelib$Result$onOk)((($caLeftAccum) => (((($sp$Compiler$MakeCanonical$translateBinopSepListRec)($env))($pos))($caLeftAccum))($opsAndRight))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($leftAccum))))));

const $sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative = (($env) => (($pos) => (($left) => (($opsAndRight) => (($corelib$Result$onOk)((($caLeft) => ((() => {
  const $$try = $opsAndRight;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($corelib$Result$Ok)($caLeft);
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $op = ($$try)[1].first;
    const $right = ($$try)[1].second;
    const $tail = ($$try)[2];
    return (($corelib$Result$onOk)((($caRight) => ($corelib$Result$Ok)((((($sp$Compiler$MakeCanonical$makeBinop)($pos))(($sp$Types$CanonicalAst$ArgumentExpression)($caLeft)))($op))(($sp$Types$CanonicalAst$ArgumentExpression)($caRight))))))((((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($right))($tail));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 838:4', (sp_toHuman)($$try));
}))())))((($sp$Compiler$MakeCanonical$translateExpression)($env))($left))))));

const $sp$Compiler$MakeCanonical$translateSimpleBinop = (($env) => (($pos) => (($left) => (($op) => (($right) => (($corelib$Result$onOk)((($l) => (($corelib$Result$onOk)((($r) => ($corelib$Result$Ok)((((($sp$Compiler$MakeCanonical$makeBinop)($pos))($l))($op))($r)))))((($sp$Compiler$MakeCanonical$translateArgument)($env))($right)))))((($sp$Compiler$MakeCanonical$translateArgument)($env))($left)))))));

const $sp$Compiler$MakeCanonical$translateBinops = (($env) => (($pos) => (($group) => ((firstItem$$) => {
  const $firstItem = firstItem$$.first;
  const $firstTail = firstItem$$.second;
  return ((() => {
    const $$try = $firstTail;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return (($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem);
    }
    if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
      const $firstSep = ($$try)[1].first;
      const $secondItem = ($$try)[1].second;
      return ((() => {
        const $$try = $group;
        if (("$sp$Types$Op$Tuple" === ($$try)[0])) {
          return (($corelib$Result$onOk)((($first) => (($corelib$Result$onOk)((($second) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Record)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($second))(((($corelib$Dict$insert)("first"))($first))($corelib$Dict$empty)))))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($secondItem)))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem));
        }
        if (true) {
          return ((((($sp$Compiler$MakeCanonical$translateSimpleBinop)($env))($pos))($firstItem))($firstSep))($secondItem);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 731:12', (sp_toHuman)($$try));
      }))();
      return null;
    }
    if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Cons" === (($$try)[2])[0]))) {
      const $firstSep = ($$try)[1].first;
      const $secondItem = ($$try)[1].second;
      const $secondSep = (($$try)[2])[1].first;
      const $thirdItem = (($$try)[2])[1].second;
      const $thirdTail = (($$try)[2])[2];
      const $secondTail = ((sp_cons)($thirdTail))(({
        first: $secondSep,
        second: $thirdItem,
      }));
      return ((() => {
        const $$try = $group;
        if (("$sp$Types$Op$Comparison" === ($$try)[0])) {
          return ((($sp$Compiler$MakeCanonical$notAllSeparators)(($sp$Compiler$MakeCanonical$sameDirectionAs)($firstSep)))($secondTail)
            ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("can't mix comparison ops with different direction"))($core$SPCore$Nil))
            : (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("NI compops expansion"))($core$SPCore$Nil)));
        }
        if (("$sp$Types$Op$Logical" === ($$try)[0])) {
          return ((($sp$Compiler$MakeCanonical$notAllSeparators)((($x) => ((sp_equal)($firstSep))($x))))($secondTail)
            ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Mixing `and` and `or` is ambiguous. Use parens!"))($core$SPCore$Nil))
            : (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail));
        }
        if (("$sp$Types$Op$Tuple" === ($$try)[0])) {
          return (((sp_not_equal)($core$SPCore$Nil))($thirdTail)
            ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Tuples can't have more than 3 items, use a record instead."))($core$SPCore$Nil))
            : (($corelib$Result$onOk)((($first) => (($corelib$Result$onOk)((($second) => (($corelib$Result$onOk)((($third) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Record)($pos))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("third"))($third))(((($corelib$Dict$insert)("second"))($second))(((($corelib$Dict$insert)("first"))($first))($corelib$Dict$empty))))))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($thirdItem)))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($secondItem)))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($firstItem)));
        }
        if (("$sp$Types$Op$Pipe" === ($$try)[0])) {
          return ((($sp$Compiler$MakeCanonical$notAllSeparators)((($x) => ((sp_equal)($firstSep))($x))))($secondTail)
            ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Mixing pipes is ambigous. Use parens."))($core$SPCore$Nil))
            : (((sp_equal)($sp$Types$Op$Right))($firstSep.associativity)
              ? (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail)
              : (((($sp$Compiler$MakeCanonical$translateBinopSepList_leftAssociative)($env))($pos))($firstItem))($firstTail)));
        }
        if (("$sp$Types$Op$Mutop" === ($$try)[0])) {
          return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("mutops can't be chained"))($core$SPCore$Nil));
        }
        if (true) {
          return (((($sp$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env))($pos))($firstItem))($firstTail);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 749:12', (sp_toHuman)($$try));
      }))();
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 726:4', (sp_toHuman)($$try));
  }))();
}))));

const $sp$Compiler$MakeCanonical$translateParameter = (($env) => (($mutable) => (($faParam) => ((() => {
  const $$try = ({
    first: $faParam,
    second: $mutable,
  });
  if ((("$sp$Types$FormattableAst$PatternAny" === ($$try.first)[0]) && ((false === ($$try.first)[2]) && (("$corelib$Maybe$Nothing" === (($$try.first)[4])[0]) && (true === $$try.second))))) {
    const $pos = ($$try.first)[1];
    const $name = ($$try.first)[3];
    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$ParameterMutable)($pos))($name));
    return null;
  }
  if ((("$sp$Types$FormattableAst$PatternAny" === ($$try.first)[0]) && (true === ($$try.first)[2]))) {
    const $pos = ($$try.first)[1];
    const $name = ($$try.first)[3];
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Can't annotate this. =("))((($core$SPCore$Cons)("TODO link to rationale for forbidding annotations"))($core$SPCore$Nil)));
    return null;
  }
  if (true) {
    return (($corelib$Result$onOk)((($caPattern) => ($corelib$Result$Ok)(($sp$Types$CanonicalAst$ParameterPattern)($caPattern)))))(((($sp$Compiler$MakeCanonical$translatePattern)($corelib$Maybe$Nothing))($env))($faParam));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 453:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$MakeCanonical$translateExpression = (($env) => (($faExpr) => ((() => {
  const $$try = $faExpr;
  if (("$sp$Types$FormattableAst$LiteralNumber" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $str = ($$try)[2];
    return ((($sp$Compiler$MakeCanonical$translateNumber)($sp$Types$CanonicalAst$LiteralNumber))($pos))($str);
    return null;
  }
  if (("$sp$Types$FormattableAst$LiteralText" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $v = ($$try)[2];
    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$LiteralText)($pos))($v));
    return null;
  }
  if (("$sp$Types$FormattableAst$PrefixBinop" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $symbol = ($$try)[2];
    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
      attrPath: $core$SPCore$Nil,
      ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)($symbol)),
    })));
    return null;
  }
  if (("$sp$Types$FormattableAst$Variable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $maybeModule = ($$try)[2];
    const $name = ($$try)[3];
    const $attrs = ($$try)[4];
    const $declaredInsideFunction = (($corelib$Dict$member)($name))($env.nonRootValues);
    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))(({
      attrPath: $attrs,
      ref: (((($sp$Compiler$MakeCanonical$resolveToValueRef)($env.ro))($declaredInsideFunction))($maybeModule))($name),
    })));
    return null;
  }
  if (("$sp$Types$FormattableAst$Constructor" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $maybeModule = ($$try)[2];
    const $name = ($$try)[3];
    return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Constructor)($pos))(((($sp$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro))($maybeModule))($name)));
    return null;
  }
  if (("$sp$Types$FormattableAst$Mutable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($name + ": mutable values can be used only as arguments for function or mutation operators")))($core$SPCore$Nil));
    return null;
  }
  if (("$sp$Types$FormattableAst$RecordShorthand" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $attrPath = ($$try)[2];
    return ((() => {
      const $$try = $env.maybeShorthandTarget;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Record update shorthands must be used inside a record update such as"))((($core$SPCore$Cons)(("    { aRecord with anAttribute = doSomethingWith ." + ((($corelib$Text$join)("."))($attrPath) + " }"))))((($core$SPCore$Cons)("but we are not inside a record update!"))($core$SPCore$Nil))));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $shorthandTarget = ($$try)[1];
        return ($corelib$Result$Ok)((($sp$Types$CanonicalAst$Variable)($pos))((Object.assign)({}, $shorthandTarget, ({
          attrPath: ($corelib$List$concat)((($core$SPCore$Cons)($shorthandTarget.attrPath))((($core$SPCore$Cons)($attrPath))($core$SPCore$Nil))),
        }))));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 556:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$FormattableAst$Lambda" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $faParam = ($$try)[2];
    const $mutable = ($$try)[3];
    const $faBody = ($$try)[4];
    return (($corelib$Result$onOk)((($caParam) => {
      const $localEnv = (Object.assign)({}, $env, ({
        nonRootValues: (($sp$Compiler$MakeCanonical$insertParamNames)($caParam))($env.nonRootValues),
      }));
      return (($corelib$Result$onOk)((($caBody) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Lambda)($pos))($caParam))($caBody)))))((($sp$Compiler$MakeCanonical$translateStatementBlock)($localEnv))($faBody));
    })))(((($sp$Compiler$MakeCanonical$translateParameter)($env))($mutable))($faParam));
    return null;
  }
  if (("$sp$Types$FormattableAst$FunctionCall" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $reference = ($$try)[2];
    const $arguments = ($$try)[3];
    const $fold = (($argument) => (($refAccum) => ((($sp$Types$CanonicalAst$Call)($pos))($refAccum))($argument)));
    return (($corelib$Result$onOk)((($ref) => (($corelib$Result$onOk)((($args) => ($corelib$Result$Ok)(((($corelib$List$foldl)($fold))($args))($ref)))))((($corelib$List$mapRes)(($sp$Compiler$MakeCanonical$translateArgument)($env)))($arguments)))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($reference));
    return null;
  }
  if (("$sp$Types$FormattableAst$If" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $condition = ($$try)[2].condition;
    const $false = ($$try)[2].false;
    const $true = ($$try)[2].true;
    return (($corelib$Result$onOk)((($c) => (($corelib$Result$onOk)((($t) => (($corelib$Result$onOk)((($f) => ($corelib$Result$Ok)((($sp$Types$CanonicalAst$If)($pos))(({
      condition: (($core$SPCore$Cons)(($sp$Types$CanonicalAst$Evaluation)($c)))($core$SPCore$Nil),
      false: $f,
      true: $t,
    }))))))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($false)))))((($sp$Compiler$MakeCanonical$translateStatementBlock)($env))($true)))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($condition));
    return null;
  }
  if (("$sp$Types$FormattableAst$Unop" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $op = ($$try)[2];
    const $faOperand = ($$try)[3];
    return (($corelib$Result$onOk)((($caOperand) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Variable)($pos))(({
      attrPath: $core$SPCore$Nil,
      ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)($op.symbol)),
    }))))(($sp$Types$CanonicalAst$ArgumentExpression)($caOperand))))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faOperand));
    return null;
  }
  if (("$sp$Types$FormattableAst$Binop" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $group = ($$try)[2];
    const $sepList = ($$try)[3];
    return (((($sp$Compiler$MakeCanonical$translateBinops)($env))($pos))($group))($sepList);
    return null;
  }
  if (("$sp$Types$FormattableAst$Record" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $faArgs = ($$try)[2];
    return (($corelib$Result$onOk)((($caUpdateTarget) => (($corelib$Result$onOk)((($caAttrs) => ($corelib$Result$Ok)(($caUpdateTarget.wrapper)(((($sp$Types$CanonicalAst$Record)($pos))($caUpdateTarget.maybeName))($caAttrs))))))(((($sp$Compiler$MakeCanonical$translateAttrsRec)((Object.assign)({}, $env, ({
      maybeShorthandTarget: $caUpdateTarget.maybeName,
    }))))($faArgs.attrs))($corelib$Dict$empty)))))(((($sp$Compiler$MakeCanonical$makeUpdateTarget)($pos))($env))($faArgs.extends));
    return null;
  }
  if (("$sp$Types$FormattableAst$List" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $faItems = ($$try)[2];
    const $cons = (($item) => (($list) => ((($sp$Types$CanonicalAst$Call)($pos))(((($sp$Types$CanonicalAst$Call)($pos))((($sp$Types$CanonicalAst$Constructor)($pos))($sp$Compiler$CoreTypes$cons)))(($sp$Types$CanonicalAst$ArgumentExpression)($item))))(($sp$Types$CanonicalAst$ArgumentExpression)($list))));
    return (($corelib$Result$onOk)((($es) => ($corelib$Result$Ok)(((($corelib$List$foldr)($cons))($es))((($sp$Types$CanonicalAst$Constructor)($pos))($sp$Compiler$CoreTypes$nil))))))((($corelib$List$mapRes)(($sp$Compiler$MakeCanonical$translateExpression)($env)))($faItems));
    return null;
  }
  if (("$sp$Types$FormattableAst$Try" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fa = ($$try)[2];
    const $translatePatternAndStatements = ((faPattern$$) => {
      const $faPattern = faPattern$$.first;
      const $faStatements = faPattern$$.second;
      return (($corelib$Result$onOk)((($caPattern) => (($corelib$Result$onOk)((($block) => ($corelib$Result$Ok)(({
        first: $caPattern,
        second: $block,
      })))))((($sp$Compiler$MakeCanonical$translateStatementBlock)((Object.assign)({}, $env, ({
        nonRootValues: (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($caPattern)))($env.nonRootValues),
      }))))($faStatements)))))(((($sp$Compiler$MakeCanonical$translatePattern)($corelib$Maybe$Nothing))($env))($faPattern));
    });
    return (($corelib$Result$onOk)((($caValue) => (($corelib$Result$onOk)((($caPatternsAndStatements) => ($corelib$Result$Ok)(((($sp$Types$CanonicalAst$Try)($pos))($caValue))($caPatternsAndStatements)))))((($corelib$List$mapRes)($translatePatternAndStatements))($fa.patterns)))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($fa.value));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 523:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$MakeCanonical$translateStatement = (($env) => (($faStat) => ((() => {
  const $$try = $faStat;
  if (("$sp$Types$FormattableAst$Evaluation" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $faExpr = ($$try)[2];
    return (($corelib$Result$onOk)((($e) => ($corelib$Result$Ok)(({
      first: $env,
      second: ($sp$Types$CanonicalAst$Evaluation)($e),
    })))))((($sp$Compiler$MakeCanonical$translateExpression)($env))($faExpr));
    return null;
  }
  if (("$sp$Types$FormattableAst$Definition" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fa = ($$try)[2];
    return (($corelib$Result$onOk)((($d) => ($corelib$Result$Ok)(({
      first: (Object.assign)({}, $env, ({
        nonRootValues: (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($d.pattern)))($env.nonRootValues),
      })),
      second: ($sp$Types$CanonicalAst$Definition)($d),
    })))))(((($sp$Compiler$MakeCanonical$translateDefinition)(false))($env))($fa));
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeAlias" === ($$try)[0])) {
    const $fa = ($$try)[1];
    const pos$$ = $fa.name;
    const $pos = (pos$$)[1];
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Aliases can be declared only in the root scope"))($core$SPCore$Nil));
    return null;
  }
  if (("$sp$Types$FormattableAst$UnionDef" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fa = ($$try)[2];
    return (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)("Types can be declared only in the root scope"))($core$SPCore$Nil));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 498:4', (sp_toHuman)($$try));
}))()));

const $sp$Types$FormattableAst$patternNames = (($pattern) => {
  const $foldOver = (($pas) => ((($corelib$List$foldl)((($p) => ($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($p)))))($pas))($corelib$Dict$empty));
  const $insertAttr = (($a) => {
    const maybePa$$ = $a;
    const $maybePa = maybePa$$.second;
    const $name = (maybePa$$.first)[2];
    const $pos = (maybePa$$.first)[1];
    return ((() => {
      const $$try = $maybePa;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($corelib$Dict$insert)($name))($pos);
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $pat = ($$try)[1];
        return ($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($pat));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 176:8', (sp_toHuman)($$try));
    }))();
  });
  return ((() => {
    const $$try = $pattern;
    if (("$sp$Types$FormattableAst$PatternAny" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $n = ($$try)[3];
      return (($corelib$Dict$singleton)($n))($pos);
      return null;
    }
    if (("$sp$Types$FormattableAst$PatternLiteralNumber" === ($$try)[0])) {
      return $corelib$Dict$empty;
    }
    if (("$sp$Types$FormattableAst$PatternLiteralText" === ($$try)[0])) {
      return $corelib$Dict$empty;
    }
    if (("$sp$Types$FormattableAst$PatternConstructor" === ($$try)[0])) {
      const $pas = ($$try)[4];
      return ($foldOver)($pas);
      return null;
    }
    if (("$sp$Types$FormattableAst$PatternList" === ($$try)[0])) {
      const $pas = ($$try)[2];
      return ($foldOver)($pas);
      return null;
    }
    if (("$sp$Types$FormattableAst$PatternListCons" === ($$try)[0])) {
      const $pas = ($$try)[2];
      return ($foldOver)($pas);
      return null;
    }
    if (("$sp$Types$FormattableAst$PatternRecord" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $ars = ($$try)[2];
      return ((($corelib$List$foldl)($insertAttr))($ars.attrs))($corelib$Dict$empty);
      return null;
    }
    if (("$sp$Types$FormattableAst$PatternTuple" === ($$try)[0])) {
      const $pas = ($$try)[2];
      return ($foldOver)($pas);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 180:4', (sp_toHuman)($$try));
  }))();
});

const $sp$Compiler$MakeCanonical$translateStatementBlock = (($env) => (($stats) => {
  const $insertNames = (($stat) => (($futureNonRootValues) => ((() => {
    const $$try = $stat;
    if (("$sp$Types$FormattableAst$Definition" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $def = ($$try)[2];
      return (($corelib$Dict$join)(($sp$Types$FormattableAst$patternNames)($def.pattern)))($futureNonRootValues);
      return null;
    }
    if (true) {
      return $futureNonRootValues;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 475:8', (sp_toHuman)($$try));
  }))()));
  const $lEnv0 = (Object.assign)({}, $env, ({
    futureNonRootValues: ((($corelib$List$foldl)($insertNames))($stats))($env.futureNonRootValues),
  }));
  const $insertCaStatement = (($faStat) => ((caStats$$) => {
    const $lEnvX = caStats$$.first;
    const $caStats = caStats$$.second;
    return (($corelib$Result$map)((($x) => (($corelib$Tuple$mapSecond)((($y) => ((sp_cons)($caStats))($y))))($x))))((($sp$Compiler$MakeCanonical$translateStatement)($lEnvX))($faStat));
  }));
  return (($corelib$Result$map)((($x) => ($corelib$List$reverse)(($corelib$Tuple$second)($x)))))(((($corelib$List$foldlRes)($insertCaStatement))($stats))(({
    first: $lEnv0,
    second: $core$SPCore$Nil,
  })));
}));

const $sp$Types$CanonicalAst$patternPos = (($pa) => ((() => {
  const $$try = $pa;
  if (("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0])) {
    const $p = ($$try)[1];
    const $n = ($$try)[2];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
    const $p = ($$try)[1];
    const $path = ($$try)[2];
    const $ps = ($$try)[3];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
    const $p = ($$try)[1];
    const $ps = ($$try)[2];
    return $p;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 195:4', (sp_toHuman)($$try));
}))());

const $sp$Types$Pos$start = (($pos) => ((() => {
  const $$try = $pos;
  if (("$sp$Types$Pos$P" === ($$try)[0])) {
    const $m = ($$try)[1];
    const $s = ($$try)[2];
    const $e = ($$try)[3];
    return $s;
    return null;
  }
  if (true) {
    return 0;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 27:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$MakeCanonical$translateDefinition = (($isRoot) => (($env) => (($fa) => {
  const $dict = ({
    attr: "$",
    obj: ({
      $: (sp_clone)($env.tyvarRenames),
    }),
  });
  const $renameTyvar = (($pos) => (($faName) => ((() => {
    const $$try = (($corelib$Dict$get)($faName))((sp_clone)(($dict.obj)[$dict.attr]));
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $n = ($$try)[1];
      return $n;
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      const $n = ((text_fromNumber)(($sp$Types$Pos$start)($pos)) + $faName);
      (($dict.obj)[$dict.attr] = ((($corelib$Dict$insert)($faName))($n))((sp_clone)(($dict.obj)[$dict.attr])), null);
      return $n;
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 295:8', (sp_toHuman)($$try));
  }))()));
  return (($corelib$Result$onOk)((($pattern) => {
    const $nonRootValues1 = ($isRoot
      ? $env.nonRootValues
      : (($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNames)($pattern)))($env.nonRootValues));
    const $localEnv0 = (Object.assign)({}, $env, ({
      defsPath: ((sp_cons)($env.defsPath))($pattern),
      nonRootValues: $nonRootValues1,
      tyvarRenames: (sp_clone)(($dict.obj)[$dict.attr]),
    }));
    const $updNonFn = (($tyvarName) => (($nonFn) => ((() => {
      const $$try = (($corelib$Dict$get)($tyvarName))($localEnv0.tyvarRenames);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$CanonicalAst$patternPos)($pattern)))((($core$SPCore$Cons)("non fn on variable that's not in the annotation"))($core$SPCore$Nil));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $tr = ($$try)[1];
        return ($corelib$Result$Ok)(((($corelib$Dict$insert)($tr))(null))($nonFn));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 319:8', (sp_toHuman)($$try));
    }))()));
    return (($corelib$Result$onOk)((($nonFn) => (($corelib$Result$onOk)((($body) => {
      const $deps = ($isRoot
        ? (($sp$Compiler$MakeCanonical$bodyDeps)($body))((($sp$Compiler$MakeCanonical$patternDeps)($pattern))($sp$Compiler$MakeCanonical$deps_init))
        : $sp$Compiler$MakeCanonical$deps_init);
      return ($corelib$Result$Ok)(({
        body: $body,
        directConsDeps: $deps.cons,
        directTypeDeps: $deps.types,
        directValueDeps: $deps.values,
        mutable: $fa.mutable,
        native: false,
        nonFn: $nonFn,
        parentDefinitions: $env.defsPath,
        pattern: $pattern,
      }));
    })))((($sp$Compiler$MakeCanonical$translateStatementBlock)($localEnv0))($fa.body)))))(((($corelib$List$foldlRes)($updNonFn))($fa.nonFn))($corelib$Dict$empty));
  })))(((($sp$Compiler$MakeCanonical$translatePattern)(($corelib$Maybe$Just)($renameTyvar)))($env))($fa.pattern));
})));

const $sp$Types$FormattableAst$expressionPos = (($expr) => ((() => {
  const $$try = $expr;
  if (("$sp$Types$FormattableAst$LiteralText" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$LiteralNumber" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Variable" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Constructor" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Mutable" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$PrefixBinop" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Lambda" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$FunctionCall" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Binop" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Unop" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$If" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Try" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$Record" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$RecordShorthand" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$List" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 135:4', (sp_toHuman)($$try));
}))());

const $sp$Types$Pos$drop = (($x) => {
  const a$$ = $x;
  const $a = (a$$)[2];
  const $pos = (a$$)[1];
  return $a;
});

const $sp$Compiler$MakeCanonical$insertRootStatement = (($ro) => (($faStatement) => (($caModule) => ((() => {
  const $$try = $faStatement;
  if (("$sp$Types$FormattableAst$Evaluation" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $expr = ($$try)[2];
    return (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$FormattableAst$expressionPos)($expr)))((($core$SPCore$Cons)("Root Evaluations don't really do much =|"))($core$SPCore$Nil));
    return null;
  }
  if (("$sp$Types$FormattableAst$Definition" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fa = ($$try)[2];
    return (($corelib$Result$onOk)((($def) => ($def.mutable
      ? (($sp$Compiler$MakeCanonical$makeError)(($sp$Types$CanonicalAst$patternPos)($def.pattern)))((($core$SPCore$Cons)("Mutable values can be declared only inside functions."))($core$SPCore$Nil))
      : ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
        valueDefs: ((($corelib$Dict$insert)($def.pattern))($def))($caModule.valueDefs),
      })))))))(((($sp$Compiler$MakeCanonical$translateDefinition)(true))(($sp$Compiler$MakeCanonical$initEnv)($ro)))($fa));
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeAlias" === ($$try)[0])) {
    const $fa = ($$try)[1];
    const name$$ = $fa.name;
    const $name = (name$$)[2];
    const $pos = (name$$)[1];
    return (((($corelib$Dict$member)($name))($caModule.aliasDefs) || (($corelib$Dict$member)($name))($caModule.unionDefs))
      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($name + " declared twice!")))($core$SPCore$Nil))
      : (($corelib$Result$onOk)((($type) => {
        const $aliasDef = ({
          args: $fa.args,
          directTypeDeps: (($sp$Compiler$MakeCanonical$typeDeps)($type))($corelib$Set$empty),
          type: $type,
          usr: (($sp$Types$Meta$USR)($ro.currentModule))(($sp$Types$Pos$drop)($fa.name)),
        });
        return ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
          aliasDefs: ((($corelib$Dict$insert)($name))($aliasDef))($caModule.aliasDefs),
        })));
      })))(((($sp$Compiler$MakeCanonical$translateType)($corelib$Maybe$Nothing))($ro))($fa.ty)));
    return null;
  }
  if (("$sp$Types$FormattableAst$UnionDef" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $fa = ($$try)[2];
    return (((($corelib$Dict$member)($fa.name))($caModule.aliasDefs) || (($corelib$Dict$member)($fa.name))($caModule.unionDefs))
      ? (($sp$Compiler$MakeCanonical$makeError)($pos))((($core$SPCore$Cons)(($fa.name + " declared twice!")))($core$SPCore$Nil))
      : ((() => {
        const $usr = (($sp$Types$Meta$USR)($ro.currentModule))($fa.name);
        const $type = ((($sp$Types$CanonicalAst$TypeConstant)($pos))($usr))((($corelib$List$map)(($sp$Types$CanonicalAst$TypeVariable)($pos)))($fa.args));
        return (($corelib$Result$onOk)((($constructors) => {
          const $unionDef = ({
            args: $fa.args,
            constructors: $constructors,
            directTypeDeps: ((($corelib$Dict$foldl)((($k) => (($c) => (($corelib$List$foldl)($sp$Compiler$MakeCanonical$typeDeps))($c.args)))))($constructors))($corelib$Set$empty),
            usr: $usr,
          });
          return ($corelib$Result$Ok)((Object.assign)({}, $caModule, ({
            unionDefs: ((($corelib$Dict$insert)($fa.name))($unionDef))($caModule.unionDefs),
          })));
        })))(((($corelib$List$foldlRes)((($sp$Compiler$MakeCanonical$translateConstructor)($ro))($type)))($fa.constructors))($corelib$Dict$empty));
      }))());
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical.sp 1018:4', (sp_toHuman)($$try));
}))())));

const $sp$Types$CanonicalAst$initModule = (($asText) => (($umr) => ({
  aliasDefs: $corelib$Dict$empty,
  asText: $asText,
  umr: $umr,
  unionDefs: $corelib$Dict$empty,
  valueDefs: $corelib$Dict$empty,
})));

const $sp$Compiler$MakeCanonical$translateModule = (($ro) => (($asText) => (($umr) => (($faModule) => {
  (sp_benchStart)(null);
  const $module = (($sp$Types$CanonicalAst$initModule)($asText))($umr);
  return ((($corelib$Basics$btw)(sp_benchStop))("translateModule"))(((($corelib$List$foldlRes)(($sp$Compiler$MakeCanonical$insertRootStatement)($ro)))($faModule))($module));
}))));

const $sp$SPLib$Parser$andThen = (($chainedParser) => (($firstParser) => (($re0) => (($readState) => ((() => {
  const $$try = (($firstParser)($re0))($readState);
  if (("$sp$SPLib$Parser$Accepted" === ($$try.second)[0])) {
    const $re1 = $$try.first;
    const $nextReadState = ($$try.second)[1];
    const $a = ($$try.second)[2];
    return ((($chainedParser)($a))($re1))($nextReadState);
    return null;
  }
  if (("$sp$SPLib$Parser$Rejected" === ($$try.second)[0])) {
    const $re1 = $$try.first;
    return ({
      first: $re1,
      second: $sp$SPLib$Parser$Rejected,
    });
    return null;
  }
  if (("$sp$SPLib$Parser$Aborted" === ($$try.second)[0])) {
    const $re1 = $$try.first;
    const $rs = ($$try.second)[1];
    const $e = ($$try.second)[2];
    return ({
      first: $re1,
      second: (($sp$SPLib$Parser$Aborted)($rs))($e),
    });
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 85:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$Parser$andThen = $sp$SPLib$Parser$andThen;

const $sp$SPLib$Parser$consumeOne = (($rejections) => (($readState) => ((() => {
  const $$try = $readState;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ({
      first: ((sp_cons)($rejections))($readState),
      second: $sp$SPLib$Parser$Rejected,
    });
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $token = ($$try)[1];
    const $nextState = ($$try)[2];
    return ({
      first: $rejections,
      second: (($sp$SPLib$Parser$Accepted)($nextState))($token),
    });
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 69:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$Parser$oneToken = $sp$SPLib$Parser$consumeOne;

const $sp$SPLib$Parser$accept = (($a) => (($rejections) => (($readState) => ({
  first: $rejections,
  second: (($sp$SPLib$Parser$Accepted)($readState))($a),
}))));

const $sp$SPLib$Parser$reject = (($rejections) => (($readState) => ({
  first: ((sp_cons)($rejections))($readState),
  second: $sp$SPLib$Parser$Rejected,
})));

const $sp$Compiler$Parser$kind = (($targetKind) => (($sp$Compiler$Parser$andThen)((($token) => {
  const k$$ = $token;
  const $k = (k$$)[3];
  return (((sp_equal)($k))($targetKind)
    ? ($sp$SPLib$Parser$accept)($token)
    : $sp$SPLib$Parser$reject);
})))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$discardFirst = (($a) => (($b) => (($sp$Compiler$Parser$andThen)((() => $b)))($a)));

const $sp$SPLib$Parser$thenWithDefault = (($fallbackParser) => (($chainedParser) => (($firstParser) => (($re0) => (($readState) => ((() => {
  const $$try = (($firstParser)($re0))($readState);
  if (("$sp$SPLib$Parser$Aborted" === ($$try.second)[0])) {
    const $re1 = $$try.first;
    const $rs = ($$try.second)[1];
    const $reason = ($$try.second)[2];
    return ({
      first: $re1,
      second: (($sp$SPLib$Parser$Aborted)($rs))($reason),
    });
    return null;
  }
  if (("$sp$SPLib$Parser$Rejected" === ($$try.second)[0])) {
    const $re1 = $$try.first;
    return (($fallbackParser)($re1))($readState);
    return null;
  }
  if (("$sp$SPLib$Parser$Accepted" === ($$try.second)[0])) {
    const $re1 = $$try.first;
    const $nextReadState = ($$try.second)[1];
    const $a = ($$try.second)[2];
    return ((($chainedParser)($a))($re1))($nextReadState);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 100:4', (sp_toHuman)($$try));
}))())))));

const $sp$SPLib$Parser$zeroOrMore = (($p) => ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)($core$SPCore$Nil)))((($head) => (($sp$SPLib$Parser$andThen)((($tail) => ($sp$SPLib$Parser$accept)(((sp_cons)($tail))($head)))))(($sp$SPLib$Parser$zeroOrMore)($p)))))($p));

const $sp$Compiler$Parser$oomSeparatedBy = (($sep) => (($pa) => (($sp$Compiler$Parser$andThen)((($head) => (($sp$Compiler$Parser$andThen)((($tail) => ($sp$SPLib$Parser$accept)(((sp_cons)($tail))($head)))))(($sp$SPLib$Parser$zeroOrMore)((($sp$Compiler$Parser$discardFirst)($sep))($pa))))))($pa)));

const $sp$Compiler$Parser$defop = (($sp$Compiler$Parser$andThen)((($token) => ((() => {
  const $$try = $token;
  if ((("$sp$Types$Token$Token" === ($$try)[0]) && ("$sp$Types$Token$Defop" === (($$try)[3])[0]))) {
    const $arg = (($$try)[3])[1];
    return ($sp$SPLib$Parser$accept)($arg);
    return null;
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 194:4', (sp_toHuman)($$try));
}))())))($sp$Compiler$Parser$oneToken);

const $sp$SPLib$Parser$here = (($rejections) => (($readState) => ({
  first: $rejections,
  second: (($sp$SPLib$Parser$Accepted)($readState))($readState),
})));

const $sp$Compiler$Parser$here = (($sp$Compiler$Parser$andThen)((($tokens) => ($sp$SPLib$Parser$accept)(((() => {
  const $$try = $tokens;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$sp$Types$Token$Token" === (($$try)[1])[0]))) {
    const $mod = (($$try)[1])[1];
    const $start = (($$try)[1])[2];
    const $end = (($$try)[1])[3];
    const $rest = ($$try)[2];
    return $start;
    return null;
  }
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return 0;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 47:9', (sp_toHuman)($$try));
}))()))))($sp$SPLib$Parser$here);

const $sp$SPLib$Parser$surroundWith = (($left) => (($right) => (($parser) => (($sp$SPLib$Parser$andThen)((() => (($sp$SPLib$Parser$andThen)((($p) => (($sp$SPLib$Parser$andThen)((() => ($sp$SPLib$Parser$accept)($p))))($right))))($parser))))($left))));

const $sp$Compiler$Parser$surroundStrict = (($left) => (($right) => (($sp$SPLib$Parser$surroundWith)(($sp$Compiler$Parser$kind)($left)))(($sp$Compiler$Parser$kind)($right))));

const $sp$Compiler$Parser$block = (($sp$Compiler$Parser$surroundStrict)($sp$Types$Token$BlockStart))($sp$Types$Token$BlockEnd);

const $sp$Compiler$Parser$sib = ($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine));

const $sp$SPLib$Parser$oneOf = (($ps) => (($rejections) => (($readState) => ((() => {
  const $$try = $ps;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ({
      first: $rejections,
      second: $sp$SPLib$Parser$Rejected,
    });
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $headParser = ($$try)[1];
    const $tailParsers = ($$try)[2];
    return ((() => {
      const $$try = (($headParser)($rejections))($readState);
      if (("$sp$SPLib$Parser$Rejected" === ($$try.second)[0])) {
        const $re1 = $$try.first;
        return ((($sp$SPLib$Parser$oneOf)($tailParsers))($re1))($readState);
        return null;
      }
      if (true) {
        const $acceptedOrAborted = $$try;
        return $acceptedOrAborted;
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 147:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 142:4', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$Parser$inlineOrBelowOrIndented = (($p) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)($p)))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)($p)))((($core$SPCore$Cons)($p))($core$SPCore$Nil)))));

const $sp$Compiler$Parser$binaryOperators = (($group) => (($sp$Compiler$Parser$andThen)(((e$$) => {
  const $s = (e$$)[1];
  const $e = (e$$)[2];
  const $k = (e$$)[3];
  return ((() => {
    const $$try = $k;
    if (("$sp$Types$Token$Binop" === ($$try)[0])) {
      const $op = ($$try)[1];
      return (((sp_equal)($group))($op.precedence)
        ? ($sp$SPLib$Parser$accept)($op)
        : $sp$SPLib$Parser$reject);
      return null;
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1228:4', (sp_toHuman)($$try));
  }))();
})))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$pos = (($env) => (($start) => (($end) => ($env.stripLocations
  ? $sp$Types$Pos$T
  : ((($sp$Types$Pos$P)($env.moduleName))($start))($end)))));

const $sp$Compiler$Parser$sepListAtSep = (($sep) => (($item) => (($sp$Compiler$Parser$andThen)((($sep0) => {
  const $theParserStillSucks = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$sepListAtItem)($sep))($item))))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)((($sp$Compiler$Parser$sepListAtItem)($sep))($item))))((($core$SPCore$Cons)((($sp$Compiler$Parser$sepListAtItem)($sep))($item)))($core$SPCore$Nil))));
  return (($sp$Compiler$Parser$andThen)(((item0$$) => {
    const $item0 = item0$$.first;
    const $tail = item0$$.second;
    return ($sp$SPLib$Parser$accept)(((sp_cons)($tail))(({
      first: $sep0,
      second: $item0,
    })));
  })))($theParserStillSucks);
})))($sep)));

const $sp$Compiler$Parser$sepListAtItem = (($sep) => (($item) => (($sp$Compiler$Parser$andThen)((($item0) => {
  const $theParserStillSucks = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$sepListAtSep)($sep))($item))))((($core$SPCore$Cons)(($sp$Compiler$Parser$sib)((($sp$Compiler$Parser$sepListAtSep)($sep))($item))))((($core$SPCore$Cons)((($sp$Compiler$Parser$sepListAtSep)($sep))($item)))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($core$SPCore$Nil)))($core$SPCore$Nil)))));
  return (($sp$Compiler$Parser$andThen)((($sepsAndItems) => ($sp$SPLib$Parser$accept)(({
    first: $item0,
    second: $sepsAndItems,
  })))))($theParserStillSucks);
})))($item)));

const $sp$Compiler$Parser$sepList = $sp$Compiler$Parser$sepListAtItem;

const $sp$Compiler$Parser$binopsOr = (($env) => (($group) => (($higher) => (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)(((head$$) => {
  const $head = head$$.first;
  const $sepTail = head$$.second;
  return (($sp$Compiler$Parser$andThen)((($end) => (((sp_equal)($core$SPCore$Nil))($sepTail)
    ? ($sp$SPLib$Parser$accept)($head)
    : ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Binop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($group))(({
      first: $head,
      second: $sepTail,
    })))))))($sp$Compiler$Parser$here);
})))((($sp$Compiler$Parser$sepList)(($sp$Compiler$Parser$binaryOperators)($group)))($higher)))))($sp$Compiler$Parser$here))));

const $sp$Compiler$Parser$discardSecond = (($a) => (($b) => (($sp$Compiler$Parser$andThen)((($aa) => (($sp$Compiler$Parser$andThen)((() => ($sp$SPLib$Parser$accept)($aa))))($b))))($a)));

const $sp$SPLib$Parser$tuple2 = (($pa) => (($pb) => (($sp$SPLib$Parser$andThen)((($a) => (($sp$SPLib$Parser$andThen)((($b) => ($sp$SPLib$Parser$accept)(({
  first: $a,
  second: $b,
})))))($pb))))($pa)));

const $sp$SPLib$Parser$oneOrMore = (($p) => (($sp$SPLib$Parser$tuple2)($p))(($sp$SPLib$Parser$zeroOrMore)($p)));

const $sp$Compiler$Parser$lambdaBody = (($env) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)(((h$$) => {
  const $h = h$$.first;
  const $t = h$$.second;
  return ($sp$SPLib$Parser$accept)(((sp_cons)($t))($h));
})))(($sp$SPLib$Parser$oneOrMore)(($sp$Compiler$Parser$sib)(($sp$Compiler$Parser$statement)($env))))))((($core$SPCore$Cons)(($sp$Compiler$Parser$inlineStatementOrBlock)($env)))($core$SPCore$Nil))));

const $sp$Compiler$Parser$lambdaParser = (($env) => (($mutable) => (($pa) => (($sp$Compiler$Parser$andThen)((($body) => ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$Lambda)(($sp$Types$FormattableAst$patternPos)($pa)))($pa))($mutable))($body)))))(($sp$Compiler$Parser$lambdaBody)($env)))));

const $sp$SPLib$Parser$maybe = (($p) => ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)($corelib$Maybe$Nothing)))((($x) => ($sp$SPLib$Parser$accept)(($corelib$Maybe$Just)($x)))))($p));

const $sp$Compiler$Parser$rawList = (($item) => {
  const $sibsep = ($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)($sp$Types$Token$Comma));
  return (($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)($sibsep)))((($sp$Compiler$Parser$oomSeparatedBy)($sibsep))($item));
});

const $sp$Compiler$Parser$surroundMultiline = (($left) => (($right) => (($content) => (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($left)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)((($sp$Compiler$Parser$discardSecond)($content))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)($right))))))));

const $sp$Compiler$Parser$list = (($env) => (($constructor) => (($main) => (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)((($maybeLs) => (($sp$Compiler$Parser$andThen)((($end) => {
  const $theParserStillSucks = ((() => {
    const $$try = $maybeLs;
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $ls = ($$try)[1];
      return $ls;
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return $core$SPCore$Nil;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 629:8', (sp_toHuman)($$try));
  }))();
  return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($theParserStillSucks));
})))($sp$Compiler$Parser$here))))(((($sp$Compiler$Parser$surroundMultiline)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed)))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$rawList)($main)))))))($sp$Compiler$Parser$here))));

const $sp$Compiler$Parser$parens = (($sp$SPLib$Parser$surroundWith)(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed))));

const $sp$Compiler$Parser$lowerNameBare = (($env) => (($sp$Compiler$Parser$andThen)((($token) => ((() => {
  const $$try = $token;
  if ((("$sp$Types$Token$Token" === ($$try)[0]) && (("$sp$Types$Token$LowerName" === (($$try)[3])[0]) && (("$sp$Types$Token$NameNoModifier" === ((($$try)[3])[1])[0]) && (("$corelib$Maybe$Nothing" === ((($$try)[3])[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[3])[4])[0])))))) {
    const $start = ($$try)[1];
    const $end = ($$try)[2];
    const $name = (($$try)[3])[3];
    return ($sp$SPLib$Parser$accept)((($sp$Types$Pos$At)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
    return null;
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 184:4', (sp_toHuman)($$try));
}))())))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$record = (($env) => (($assign) => (($constructor) => (($main) => {
  const $attrAssignment = (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($assign)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)($main));
  const $attr = (($sp$Compiler$Parser$andThen)((($name) => (($sp$Compiler$Parser$andThen)((($maybeAssignment) => ($sp$SPLib$Parser$accept)(({
    first: $name,
    second: $maybeAssignment,
  })))))(($sp$SPLib$Parser$maybe)($attrAssignment)))))(($sp$Compiler$Parser$lowerNameBare)($env));
  const $updateTarget = (($sp$Compiler$Parser$andThen)((($h) => (($sp$Compiler$Parser$andThen)((() => ($sp$SPLib$Parser$accept)($h))))(($sp$Compiler$Parser$kind)($sp$Types$Token$With)))))($main);
  const $content = (($start) => (($sp$Compiler$Parser$andThen)((($maybeUpdateTarget) => (($sp$Compiler$Parser$andThen)((($attrs) => (($sp$Compiler$Parser$andThen)((($end) => ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
    attrs: $attrs,
    extends: $maybeUpdateTarget,
  }))))))($sp$Compiler$Parser$here))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$rawList)($attr))))))(($sp$SPLib$Parser$maybe)($updateTarget)));
  return (($sp$Compiler$Parser$andThen)((($s) => (($sp$Compiler$Parser$andThen)((($maybeRecord) => (($sp$Compiler$Parser$andThen)((($e) => ((() => {
    const $$try = $maybeRecord;
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $re = ($$try)[1];
      return ($sp$SPLib$Parser$accept)($re);
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($s))($e)))(({
        attrs: $core$SPCore$Nil,
        extends: $corelib$Maybe$Nothing,
      })));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 676:4', (sp_toHuman)($$try));
  }))())))($sp$Compiler$Parser$here))))(((($sp$Compiler$Parser$surroundMultiline)(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Open)))(($sp$Types$Token$CurlyBrace)($sp$Types$Token$Closed)))(($sp$SPLib$Parser$maybe)(($content)($s)))))))($sp$Compiler$Parser$here);
}))));

const $sp$Compiler$Parser$typeConstructorAppOr = (($env) => (($higher) => (($sp$Compiler$Parser$andThen)((($ty) => ((() => {
  const $$try = $ty;
  if ((("$sp$Types$FormattableAst$TypeConstant" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[4])[0]))) {
    const $p1 = ($$try)[1];
    const $maybeModule = ($$try)[2];
    const $name = ($$try)[3];
    return (($sp$Compiler$Parser$andThen)((($args) => (($sp$Compiler$Parser$andThen)((($end2) => (((sp_equal)($core$SPCore$Nil))($args)
      ? ($sp$SPLib$Parser$accept)($ty)
      : ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$TypeConstant)($p1))($maybeModule))($name))($args))))))($sp$Compiler$Parser$here))))(($sp$SPLib$Parser$zeroOrMore)($higher));
    return null;
  }
  if (true) {
    return ($sp$SPLib$Parser$accept)($ty);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 962:4', (sp_toHuman)($$try));
}))())))($higher)));

const $sp$Compiler$Parser$arrow = (($env) => (($sp$Compiler$Parser$andThen)(((end$$) => {
  const $start = (end$$)[1];
  const $end = (end$$)[2];
  const $k = (end$$)[3];
  return ((() => {
    const $$try = $k;
    if (("$sp$Types$Token$Colon" === ($$try)[0])) {
      return ($sp$SPLib$Parser$accept)(({
        first: false,
        second: ((($sp$Compiler$Parser$pos)($env))($start))($end),
      }));
    }
    if (("$sp$Types$Token$MutableColon" === ($$try)[0])) {
      return ($sp$SPLib$Parser$accept)(({
        first: true,
        second: ((($sp$Compiler$Parser$pos)($env))($start))($end),
      }));
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 947:4', (sp_toHuman)($$try));
  }))();
})))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$typeFunctionOr = (($env) => (($higher) => {
  const $arrowAndHigher = (($sp$Compiler$Parser$andThen)(((mutable$$) => {
    const $mutable = mutable$$.first;
    const $p = mutable$$.second;
    return (($sp$Compiler$Parser$andThen)((($h) => ($sp$SPLib$Parser$accept)(({
      first: $mutable,
      second: $p,
      third: $h,
    })))))($higher);
  })))(($sp$Compiler$Parser$arrow)($env));
  const $fold = ((nextIsMutable$$) => {
    const $nextIsMutable = nextIsMutable$$.first;
    const $p = nextIsMutable$$.second;
    const $ty = nextIsMutable$$.third;
    return ((accum$$) => {
      const $thisIsMutable = accum$$.first;
      const $accum = accum$$.second;
      return ({
        first: $nextIsMutable,
        second: (((($sp$Types$FormattableAst$TypeFunction)($p))($ty))($thisIsMutable))($accum),
      });
    });
  });
  return (($sp$Compiler$Parser$andThen)((($fs) => (($sp$Compiler$Parser$andThen)((($e) => (($sp$Compiler$Parser$andThen)((($fe) => (($sp$Compiler$Parser$andThen)((($es) => {
    const $firstPos = ((($sp$Compiler$Parser$pos)($env))($fs))($fe);
    const $reverseRec = (($a) => (($ls) => (($accum) => ((() => {
      const $$try = $ls;
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return ({
          first: $a,
          second: $accum,
        });
      }
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $head = ($$try)[1];
        const $tail = ($$try)[2];
        return ((($reverseRec)($head))($tail))(((sp_cons)($accum))($a));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 926:8', (sp_toHuman)($$try));
    }))())));
    const p$$ = ((($reverseRec)(({
      first: false,
      second: $firstPos,
      third: $e,
    })))($es))($core$SPCore$Nil);
    const $reversedArgs = p$$.second;
    const $return = p$$.first.third;
    const $p = p$$.first.second;
    const $thisIsMutable = p$$.first.first;
    return ((($x) => ($sp$SPLib$Parser$accept)($x.second)))(((($corelib$List$foldl)($fold))($reversedArgs))(({
      first: $thisIsMutable,
      second: $return,
    })));
  })))(($sp$SPLib$Parser$zeroOrMore)($arrowAndHigher)))))($sp$Compiler$Parser$here))))($higher))))($sp$Compiler$Parser$here);
}));

const $sp$Compiler$Parser$typeList = (($env) => (($main) => (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)((($t) => (($sp$Compiler$Parser$andThen)((($end) => ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeList)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($t)))))($sp$Compiler$Parser$here))))(((($sp$Compiler$Parser$surroundStrict)(($sp$Types$Token$SquareBracket)($sp$Types$Token$Open)))(($sp$Types$Token$SquareBracket)($sp$Types$Token$Closed)))($main)))))($sp$Compiler$Parser$here)));

const $sp$Compiler$Parser$typeParens = (($main) => ((($sp$Compiler$Parser$surroundStrict)(($sp$Types$Token$RoundParen)($sp$Types$Token$Open)))(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)))($main));

const $sp$Compiler$Parser$typeTerm = (($env) => (($sp$Compiler$Parser$andThen)(((end$$) => {
  const $start = (end$$)[1];
  const $end = (end$$)[2];
  const $k = (end$$)[3];
  return ((() => {
    const $$try = $k;
    if (("$sp$Types$Token$UpperName" === ($$try)[0])) {
      const $maybeModule = ($$try)[1];
      const $name = ($$try)[2];
      return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$TypeConstant)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($maybeModule))($name))($core$SPCore$Nil));
      return null;
    }
    if ((("$sp$Types$Token$LowerName" === ($$try)[0]) && (("$sp$Types$Token$NameNoModifier" === (($$try)[1])[0]) && (("$corelib$Maybe$Nothing" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === (($$try)[4])[0]))))) {
      const $name = ($$try)[3];
      return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeVariable)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
      return null;
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 833:4', (sp_toHuman)($$try));
  }))();
})))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$typeTupleOr = (($env) => (($higher) => {
  const $binopAndPrev = (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$binaryOperators)($sp$Types$Op$Tuple)))($higher);
  return (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)((($head) => (($sp$Compiler$Parser$andThen)((($tail) => (($sp$Compiler$Parser$andThen)((($end) => (((sp_equal)($core$SPCore$Nil))($tail)
    ? ($sp$SPLib$Parser$accept)($head)
    : ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$TypeTuple)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(((sp_cons)($tail))($head)))))))($sp$Compiler$Parser$here))))(($sp$SPLib$Parser$zeroOrMore)($binopAndPrev)))))($higher))))($sp$Compiler$Parser$here);
}));

const $sp$SPLib$Parser$breakCircularDefinition = (($a) => (($sp$SPLib$Parser$andThen)($a))(($sp$SPLib$Parser$accept)(null)));

const $sp$SPLib$Parser$expression = (($term) => (($ops) => ((() => {
  const $$try = $ops;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return $term;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $op = ($$try)[1];
    const $rest = ($$try)[2];
    return (($sp$SPLib$Parser$expression)(($op)($term)))($rest);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPLib/Parser.sp 230:4', (sp_toHuman)($$try));
}))()));

const $sp$SPLib$Parser$higherOr = (($parser) => (($higher) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($higher))((($core$SPCore$Cons)($parser))($core$SPCore$Nil)))));

const $sp$Compiler$Parser$typeExpr = (($env) => {
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => ($sp$Compiler$Parser$typeExpr)($env)));
  const $higherOr = $sp$SPLib$Parser$higherOr;
  return (($sp$SPLib$Parser$expression)(($sp$Compiler$Parser$typeTerm)($env)))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$typeParens)($nest))))((($core$SPCore$Cons)(($higherOr)((($sp$Compiler$Parser$typeList)($env))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))($sp$Types$Token$As))($sp$Types$FormattableAst$TypeRecord))($nest))))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeConstructorAppOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeTupleOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$typeFunctionOr)($env)))($core$SPCore$Nil)))))));
});

const $sp$Compiler$Parser$typeAnnotation = (($env) => (($sp$Compiler$Parser$discardFirst)(($sp$Compiler$Parser$kind)($sp$Types$Token$As)))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeExpr)($env))));

const $sp$Compiler$Parser$patternApplication = (($env) => (($param) => (($sp$Compiler$Parser$andThen)(((end$$) => {
  const $start = (end$$)[1];
  const $end = (end$$)[2];
  const $k = (end$$)[3];
  const $p = ((($sp$Compiler$Parser$pos)($env))($start))($end);
  return ((() => {
    const $$try = $k;
    if (("$sp$Types$Token$NumberLiteral" === ($$try)[0])) {
      const $s = ($$try)[1];
      return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PatternLiteralNumber)($p))($s));
      return null;
    }
    if (("$sp$Types$Token$TextLiteral" === ($$try)[0])) {
      const $s = ($$try)[1];
      return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PatternLiteralText)($p))($s));
      return null;
    }
    if ((("$sp$Types$Token$LowerName" === ($$try)[0]) && (("$corelib$Maybe$Nothing" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === (($$try)[4])[0])))) {
      const $modifier = ($$try)[1];
      const $name = ($$try)[3];
      const $thingy = (($mutable) => (($sp$Compiler$Parser$andThen)((($maybeTy) => ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$PatternAny)($p))($mutable))($name))($maybeTy)))))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeAnnotation)($env)))));
      return ((() => {
        const $$try = $modifier;
        if (("$sp$Types$Token$NameNoModifier" === ($$try)[0])) {
          return ($thingy)(false);
        }
        if (("$sp$Types$Token$NameMutable" === ($$try)[0])) {
          return ($thingy)(true);
        }
        if (("$sp$Types$Token$NameStartsWithDot" === ($$try)[0])) {
          return $sp$SPLib$Parser$reject;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1080:12', (sp_toHuman)($$try));
      }))();
      return null;
    }
    if (("$sp$Types$Token$UpperName" === ($$try)[0])) {
      const $maybeModule = ($$try)[1];
      const $name = ($$try)[2];
      return (($sp$Compiler$Parser$andThen)((($params) => (($sp$Compiler$Parser$andThen)((($end1) => ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$PatternConstructor)(((($sp$Compiler$Parser$pos)($env))($start))($end1)))($maybeModule))($name))($params)))))($sp$Compiler$Parser$here))))(($sp$SPLib$Parser$zeroOrMore)($param));
      return null;
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1063:4', (sp_toHuman)($$try));
  }))();
})))($sp$Compiler$Parser$oneToken)));

const $sp$Compiler$Parser$functionParameter = (($env) => (($nest) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$patternApplication)($env))($sp$SPLib$Parser$reject)))((($core$SPCore$Cons)(($sp$Compiler$Parser$parens)($nest)))((($core$SPCore$Cons)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$PatternList))($nest)))((($core$SPCore$Cons)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)(({
  mutable: false,
}))))($sp$Types$FormattableAst$PatternRecord))($nest)))($core$SPCore$Nil)))))));

const $sp$Compiler$Parser$patternBinopOr = (($env) => (($precedenceGroup) => (($constructor) => (($higher) => (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)(((head$$) => {
  const $head = head$$.first;
  const $sepTail = head$$.second;
  return (($sp$Compiler$Parser$andThen)((($end) => (((sp_equal)($core$SPCore$Nil))($sepTail)
    ? ($sp$SPLib$Parser$accept)($head)
    : ($sp$SPLib$Parser$accept)((($constructor)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(((sp_cons)((($corelib$List$map)((($x) => $x.second)))($sepTail)))($head)))))))($sp$Compiler$Parser$here);
})))((($sp$Compiler$Parser$sepList)(($sp$Compiler$Parser$binaryOperators)($precedenceGroup)))($higher)))))($sp$Compiler$Parser$here)))));

const $sp$Compiler$Parser$pattern = (($env) => {
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => ($sp$Compiler$Parser$pattern)($env)));
  const $higherOr = $sp$SPLib$Parser$higherOr;
  return (($sp$SPLib$Parser$expression)((($sp$Compiler$Parser$patternApplication)($env))((($sp$Compiler$Parser$functionParameter)($env))($nest))))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$parens)($nest))))((($core$SPCore$Cons)(($higherOr)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$PatternList))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)(({
    mutable: false,
  }))))($sp$Types$FormattableAst$PatternRecord))($nest))))((($core$SPCore$Cons)(((($sp$Compiler$Parser$patternBinopOr)($env))($sp$Types$Op$Cons))($sp$Types$FormattableAst$PatternListCons)))((($core$SPCore$Cons)(((($sp$Compiler$Parser$patternBinopOr)($env))($sp$Types$Op$Tuple))($sp$Types$FormattableAst$PatternTuple)))($core$SPCore$Nil))))));
});

const $sp$SPLib$Parser$map = (($f) => (($p) => (($sp$SPLib$Parser$andThen)((($b) => ($sp$SPLib$Parser$accept)(($f)($b)))))($p)));

const $sp$Compiler$Parser$exprWithLeftDelimiter = (($env) => {
  const $colon = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => false)))(($sp$Compiler$Parser$kind)($sp$Types$Token$Colon))))((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => true)))(($sp$Compiler$Parser$kind)($sp$Types$Token$MutableColon))))($core$SPCore$Nil)));
  const $maybeColon = ($sp$SPLib$Parser$maybe)($colon);
  return (($sp$Compiler$Parser$andThen)(((end$$) => {
    const $start = (end$$)[1];
    const $end = (end$$)[2];
    const $k = (end$$)[3];
    const $p = ((($sp$Compiler$Parser$pos)($env))($start))($end);
    return ((() => {
      const $$try = $k;
      if (("$sp$Types$Token$NumberLiteral" === ($$try)[0])) {
        const $s = ($$try)[1];
        return (($sp$Compiler$Parser$andThen)((($mc) => ((() => {
          const $$try = $mc;
          if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
            return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$LiteralNumber)($p))($s));
          }
          if (("$corelib$Maybe$Just" === ($$try)[0])) {
            const $mutable = ($$try)[1];
            return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((($sp$Types$FormattableAst$PatternLiteralNumber)($p))($s));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 478:20', (sp_toHuman)($$try));
        }))())))($maybeColon);
        return null;
      }
      if (("$sp$Types$Token$TextLiteral" === ($$try)[0])) {
        const $s = ($$try)[1];
        return (($sp$Compiler$Parser$andThen)((($mc) => ((() => {
          const $$try = $mc;
          if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
            return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$LiteralText)($p))($s));
          }
          if (("$corelib$Maybe$Just" === ($$try)[0])) {
            const $mutable = ($$try)[1];
            return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((($sp$Types$FormattableAst$PatternLiteralText)($p))($s));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 485:20', (sp_toHuman)($$try));
        }))())))($maybeColon);
        return null;
      }
      if (("$sp$Types$Token$LowerName" === ($$try)[0])) {
        const $modifier = ($$try)[1];
        const $maybeModule = ($$try)[2];
        const $name = ($$try)[3];
        const $attrs = ($$try)[4];
        return ((() => {
          const $$try = $modifier;
          if (("$sp$Types$Token$NameMutable" === ($$try)[0])) {
            return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Mutable)($p))($name))($attrs));
          }
          if (("$sp$Types$Token$NameStartsWithDot" === ($$try)[0])) {
            return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$RecordShorthand)($p))(((sp_cons)($attrs))($name)));
          }
          if (("$sp$Types$Token$NameNoModifier" === ($$try)[0])) {
            return (($sp$Compiler$Parser$andThen)((($mc) => ((() => {
              const $$try = $mc;
              if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
                return ($sp$SPLib$Parser$accept)((((($sp$Types$FormattableAst$Variable)($p))($maybeModule))($name))($attrs));
              }
              if (("$corelib$Maybe$Just" === ($$try)[0])) {
                const $mutable = ($$try)[1];
                return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((((($sp$Types$FormattableAst$PatternAny)($p))(false))($name))($corelib$Maybe$Nothing));
                return null;
              }
              (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 499:28', (sp_toHuman)($$try));
            }))())))($maybeColon);
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 490:16', (sp_toHuman)($$try));
        }))();
        return null;
      }
      if (("$sp$Types$Token$UpperName" === ($$try)[0])) {
        const $maybeModule = ($$try)[1];
        const $name = ($$try)[2];
        return (($sp$Compiler$Parser$andThen)((($mc) => ((() => {
          const $$try = $mc;
          if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
            return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Constructor)($p))($maybeModule))($name));
          }
          if (("$corelib$Maybe$Just" === ($$try)[0])) {
            const $mutable = ($$try)[1];
            return ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))((((($sp$Types$FormattableAst$PatternConstructor)($p))($maybeModule))($name))($core$SPCore$Nil));
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 506:20', (sp_toHuman)($$try));
        }))())))($maybeColon);
        return null;
      }
      if ((("$sp$Types$Token$RoundParen" === ($$try)[0]) && ("$sp$Types$Token$Open" === (($$try)[1])[0]))) {
        const $paParser = (($sp$Compiler$Parser$andThen)((($pa) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((($mutable) => ((($sp$Compiler$Parser$lambdaParser)($env))($mutable))($pa))))($colon))))(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed))))))(($sp$Compiler$Parser$pattern)($env));
        const $exprParser = (($sp$Compiler$Parser$discardSecond)(($sp$Compiler$Parser$expr)($env)))(($sp$Compiler$Parser$kind)(($sp$Types$Token$RoundParen)($sp$Types$Token$Closed)));
        return ($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($paParser))((($core$SPCore$Cons)($exprParser))($core$SPCore$Nil))));
        return null;
      }
      if (true) {
        return $sp$SPLib$Parser$reject;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 475:8', (sp_toHuman)($$try));
    }))();
  })))($sp$Compiler$Parser$oneToken);
});

const $sp$Compiler$Parser$maybeWithDefault = (($a) => (($p) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)($p))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($a)))($core$SPCore$Nil)))));

const $sp$Compiler$Parser$recInlineOrIndentedOrBelow = (($higher) => (($accum) => (($sp$Compiler$Parser$andThen)((($h) => {
  const $r = ((sp_cons)($accum))($h);
  return (($sp$Compiler$Parser$maybeWithDefault)($r))(($sp$Compiler$Parser$inlineOrBelowOrIndented)((($sp$Compiler$Parser$recInlineOrIndentedOrBelow)($higher))($r)));
})))($higher)));

const $sp$Compiler$Parser$functionApplicationOr = (($env) => (($higher) => {
  const $recInlineOrIndented = (($accum) => (($sp$Compiler$Parser$andThen)((($h) => {
    const $r = ((sp_cons)($accum))($h);
    return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$recInlineOrIndentedOrBelow)($higher))($r))))((($core$SPCore$Cons)(($recInlineOrIndented)($r)))((($core$SPCore$Cons)(($sp$SPLib$Parser$accept)($r)))($core$SPCore$Nil))));
  })))($higher));
  return (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)((($reversedArgs) => (($sp$Compiler$Parser$andThen)((($end) => ((() => {
    const $$try = ($corelib$List$reverse)($reversedArgs);
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return $sp$SPLib$Parser$reject;
    }
    if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
      const $fnExpression = ($$try)[1];
      return ($sp$SPLib$Parser$accept)($fnExpression);
      return null;
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $fnExpression = ($$try)[1];
      const $args = ($$try)[2];
      return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$FunctionCall)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($fnExpression))($args));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1152:4', (sp_toHuman)($$try));
  }))())))($sp$Compiler$Parser$here))))(($recInlineOrIndented)($core$SPCore$Nil)))))($sp$Compiler$Parser$here);
}));

const $sp$SPLib$Parser$abort = (($error) => (($rejections) => (($readState) => ({
  first: $rejections,
  second: (($sp$SPLib$Parser$Aborted)($readState))($error),
}))));

const $sp$Compiler$Parser$if_ = (($env) => {
  const $maybeNewLine = (($k) => (($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine))))(($sp$Compiler$Parser$kind)($k)));
  return (($sp$Compiler$Parser$andThen)(((start$$) => {
    const $start = (start$$)[1];
    return (($sp$Compiler$Parser$andThen)((($condition) => (($sp$Compiler$Parser$andThen)((($maybeThen) => (((sp_equal)($corelib$Maybe$Nothing))($maybeThen)
      ? ($sp$SPLib$Parser$abort)("`if` should be followed by a `then` but I can't find it")
      : (($sp$Compiler$Parser$andThen)((($true) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((($false) => (($sp$Compiler$Parser$andThen)((($end) => ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$If)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
        condition: $condition,
        false: $false,
        isCompact: false,
        true: $true,
      }))))))($sp$Compiler$Parser$here))))(($sp$Compiler$Parser$inlineStatementOrBlock)($env)))))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$Colon))))))(($maybeNewLine)($sp$Types$Token$Else)))))(($sp$Compiler$Parser$inlineStatementOrBlock)($env))))))(($sp$SPLib$Parser$maybe)(($maybeNewLine)($sp$Types$Token$Then))))))(($sp$Compiler$Parser$expr)($env));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$If));
});

const $sp$Compiler$Parser$try_ = (($env) => {
  const $maybeNewLine = ($sp$Compiler$Parser$discardFirst)(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)));
  const $maybeNewLineKind = (($k) => ($maybeNewLine)(($sp$Compiler$Parser$kind)($k)));
  const $patternAndAccept = (($sp$Compiler$Parser$andThen)((($p) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((($accept) => ($sp$SPLib$Parser$accept)(({
    first: $p,
    second: $accept,
  })))))(($sp$Compiler$Parser$inlineStatementOrBlock)($env)))))(($maybeNewLineKind)($sp$Types$Token$Colon)))))(($sp$Compiler$Parser$pattern)($env));
  return (($sp$Compiler$Parser$andThen)(((start$$) => {
    const $start = (start$$)[1];
    return (($sp$Compiler$Parser$andThen)((($value) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((($patterns) => (($sp$Compiler$Parser$andThen)((($end) => ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Try)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
      isCompact: false,
      patterns: $patterns,
      value: $value,
    }))))))($sp$Compiler$Parser$here))))(($sp$Compiler$Parser$block)(($sp$SPLib$Parser$zeroOrMore)(($maybeNewLine)($patternAndAccept)))))))(($maybeNewLineKind)($sp$Types$Token$As)))))(($sp$Compiler$Parser$expr)($env));
  })))(($sp$Compiler$Parser$kind)($sp$Types$Token$Try));
});

const $sp$Compiler$Parser$unaryOperator = (($sp$Compiler$Parser$andThen)((($token) => ((() => {
  const $$try = $token;
  if ((("$sp$Types$Token$Token" === ($$try)[0]) && ("$sp$Types$Token$Unop" === (($$try)[3])[0]))) {
    const $s = ($$try)[1];
    const $e = ($$try)[2];
    const $op = (($$try)[3])[1];
    return ($sp$SPLib$Parser$accept)(({
      first: $op,
      second: $token,
    }));
    return null;
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1186:4', (sp_toHuman)($$try));
}))())))($sp$Compiler$Parser$oneToken);

const $sp$Compiler$Parser$unopsOr = (($env) => (($higher) => (($sp$Compiler$Parser$andThen)((($maybeUnary) => (($sp$Compiler$Parser$andThen)((($right) => (($sp$Compiler$Parser$andThen)((($end) => ((() => {
  const $$try = $maybeUnary;
  if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Types$Token$Token" === (($$try)[1].second)[0]))) {
    const $op = ($$try)[1].first;
    const $start = (($$try)[1].second)[1];
    return ($sp$SPLib$Parser$accept)(((($sp$Types$FormattableAst$Unop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($op))($right));
    return null;
  }
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ($sp$SPLib$Parser$accept)($right);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1175:4', (sp_toHuman)($$try));
}))())))($sp$Compiler$Parser$here))))($higher))))(($sp$SPLib$Parser$maybe)($sp$Compiler$Parser$unaryOperator))));

const $sp$Compiler$Parser$expr = (($env) => {
  const $higherOr = $sp$SPLib$Parser$higherOr;
  const $nest = ($sp$SPLib$Parser$breakCircularDefinition)((() => ($sp$Compiler$Parser$expr)($env)));
  return (($sp$SPLib$Parser$expression)(($sp$Compiler$Parser$exprWithLeftDelimiter)($env)))((($core$SPCore$Cons)(($higherOr)(((($sp$Compiler$Parser$list)($env))($sp$Types$FormattableAst$List))($nest))))((($core$SPCore$Cons)(($higherOr)((((($sp$Compiler$Parser$record)($env))(($sp$Types$Token$Defop)(({
    mutable: false,
  }))))($sp$Types$FormattableAst$Record))($nest))))((($core$SPCore$Cons)(($sp$Compiler$Parser$unopsOr)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$functionApplicationOr)($env)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Exponential)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Multiplicative)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Addittive)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Comparison)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Logical)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Tuple)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Cons)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Pipe)))((($core$SPCore$Cons)((($sp$Compiler$Parser$binopsOr)($env))($sp$Types$Op$Mutop)))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$if_)($env))))((($core$SPCore$Cons)(($higherOr)(($sp$Compiler$Parser$try_)($env))))($core$SPCore$Nil))))))))))))))));
});

const $sp$Compiler$Parser$inlineStatementOrBlock = (($env) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($e) => ($sp$SPLib$Parser$accept)((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)(($sp$Types$FormattableAst$expressionPos)($e)))($e)))($core$SPCore$Nil)))))(($sp$SPLib$Parser$breakCircularDefinition)((() => ($sp$Compiler$Parser$expr)($env))))))((($core$SPCore$Cons)(($sp$Compiler$Parser$block)((($sp$Compiler$Parser$oomSeparatedBy)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))(($sp$Compiler$Parser$statement)($env)))))($core$SPCore$Nil))));

const $sp$Compiler$Parser$upperNameBare = (($env) => (($sp$Compiler$Parser$andThen)((($token) => ((() => {
  const $$try = $token;
  if ((("$sp$Types$Token$Token" === ($$try)[0]) && (("$sp$Types$Token$UpperName" === (($$try)[3])[0]) && ("$corelib$Maybe$Nothing" === ((($$try)[3])[1])[0])))) {
    const $start = ($$try)[1];
    const $end = ($$try)[2];
    const $name = (($$try)[3])[2];
    return ($sp$SPLib$Parser$accept)((($sp$Types$Pos$At)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($name));
    return null;
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 174:4', (sp_toHuman)($$try));
}))())))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$nonFunction = (($env) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((($nf) => (($sp$Compiler$Parser$andThen)(((n$$) => {
  const $n = (n$$)[2];
  return (((sp_equal)("NonFunction"))($n)
    ? ($sp$SPLib$Parser$accept)((($corelib$List$map)($sp$Types$Pos$drop))($nf))
    : ($sp$SPLib$Parser$abort)("Only NonFunction is supported for now"));
})))(($sp$Compiler$Parser$upperNameBare)($env)))))(($sp$Compiler$Parser$rawList)(($sp$Compiler$Parser$lowerNameBare)($env))))))(($sp$Compiler$Parser$kind)($sp$Types$Token$With)));

const $sp$Compiler$Parser$definition = (($env) => (($sp$Compiler$Parser$andThen)((($start) => (($sp$Compiler$Parser$andThen)((($p) => (($sp$Compiler$Parser$andThen)((($nf) => (($sp$Compiler$Parser$andThen)((($defopArgs) => (($sp$Compiler$Parser$andThen)((($body) => (($sp$Compiler$Parser$andThen)((($end) => ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Definition)(((($sp$Compiler$Parser$pos)($env))($start))($end)))(({
  body: $body,
  mutable: $defopArgs.mutable,
  nonFn: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($nf),
  pattern: $p,
}))))))($sp$Compiler$Parser$here))))(($sp$Compiler$Parser$inlineStatementOrBlock)($env)))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)($sp$Compiler$Parser$defop)))))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$nonFunction)($env)))))))(($sp$Compiler$Parser$pattern)($env)))))($sp$Compiler$Parser$here));

const $sp$Compiler$Parser$errorCantUseMutableAssignmentHere = "Can't use mutable assignment here";

const $sp$Compiler$Parser$typeAlias = (($env) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)((($name) => (($sp$Compiler$Parser$andThen)((($args) => (($sp$Compiler$Parser$andThen)((($defopArgs) => (($sp$Compiler$Parser$andThen)((($ty) => ($defopArgs.mutable
  ? ($sp$SPLib$Parser$abort)($sp$Compiler$Parser$errorCantUseMutableAssignmentHere)
  : ($sp$SPLib$Parser$accept)(($sp$Types$FormattableAst$TypeAlias)(({
    args: $args,
    name: $name,
    ty: $ty,
  })))))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$typeExpr)($env))))))($sp$Compiler$Parser$defop))))(($sp$SPLib$Parser$zeroOrMore)(($sp$Compiler$Parser$lowerNameBare)($env))))))(($sp$Compiler$Parser$upperNameBare)($env)))))(($sp$Compiler$Parser$kind)((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("alias"))($core$SPCore$Nil))));

const $sp$Compiler$Parser$unionConstructor = (($env) => (($sp$Compiler$Parser$andThen)((($type) => ((() => {
  const $$try = $type;
  if ((("$sp$Types$FormattableAst$TypeConstant" === ($$try)[0]) && ("$corelib$Maybe$Nothing" === (($$try)[2])[0]))) {
    const $p = ($$try)[1];
    const $name = ($$try)[3];
    const $args = ($$try)[4];
    return ($sp$SPLib$Parser$accept)(({
      first: (($sp$Types$Pos$At)($p))($name),
      second: $args,
    }));
    return null;
  }
  if (true) {
    return $sp$SPLib$Parser$reject;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 403:4', (sp_toHuman)($$try));
}))())))(($sp$Compiler$Parser$typeExpr)($env)));

const $sp$Compiler$Parser$unionDef = (($env) => (($sp$Compiler$Parser$andThen)((() => (($sp$Compiler$Parser$andThen)(((name$$) => {
  const $p = (name$$)[1];
  const $name = (name$$)[2];
  return (($sp$Compiler$Parser$andThen)((($args) => (($sp$Compiler$Parser$andThen)((($defopArgs) => (($sp$Compiler$Parser$andThen)((($cons) => ($defopArgs.mutable
    ? ($sp$SPLib$Parser$abort)($sp$Compiler$Parser$errorCantUseMutableAssignmentHere)
    : ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$UnionDef)($p))(({
      args: (($corelib$List$map)($sp$Types$Pos$drop))($args),
      constructors: $cons,
      name: $name,
    })))))))(($sp$Compiler$Parser$inlineOrBelowOrIndented)(($sp$Compiler$Parser$rawList)(($sp$Compiler$Parser$unionConstructor)($env)))))))($sp$Compiler$Parser$defop))))(($sp$SPLib$Parser$zeroOrMore)(($sp$Compiler$Parser$lowerNameBare)($env)));
})))(($sp$Compiler$Parser$upperNameBare)($env)))))(($sp$Compiler$Parser$kind)((((($sp$Types$Token$LowerName)($sp$Types$Token$NameNoModifier))($corelib$Maybe$Nothing))("union"))($core$SPCore$Nil))));

const $sp$Compiler$Parser$statement = (($env) => ($sp$SPLib$Parser$breakCircularDefinition)((() => (($sp$Compiler$Parser$andThen)((() => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$typeAlias)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$unionDef)($env)))((($core$SPCore$Cons)(($sp$Compiler$Parser$definition)($env)))((($core$SPCore$Cons)((($sp$Compiler$Parser$andThen)((($e) => ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$Evaluation)(($sp$Types$FormattableAst$expressionPos)($e)))($e)))))(($sp$Compiler$Parser$expr)($env))))($core$SPCore$Nil))))))))(($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine))))));

const $sp$SPLib$Parser$without = (($p) => ((($sp$SPLib$Parser$thenWithDefault)(($sp$SPLib$Parser$accept)(null)))((() => $sp$SPLib$Parser$reject)))($p));

const $sp$SPLib$Parser$end = ($sp$SPLib$Parser$without)($sp$SPLib$Parser$consumeOne);

const $sp$Compiler$Parser$module_ = (($env) => {
  const $start = ($sp$SPLib$Parser$maybe)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine));
  const $e = ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$kind)($sp$Types$Token$BlockEnd)))((($core$SPCore$Cons)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))($core$SPCore$Nil)));
  const $zzz = (($sp$Compiler$Parser$andThen)((() => $sp$SPLib$Parser$end)))(($sp$SPLib$Parser$zeroOrMore)($e));
  const $statements = (($sp$Compiler$Parser$oomSeparatedBy)(($sp$Compiler$Parser$kind)($sp$Types$Token$NewSiblingLine)))(($sp$Compiler$Parser$statement)($env));
  return ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)((($sp$SPLib$Parser$map)((() => $core$SPCore$Nil)))($sp$SPLib$Parser$end)))((($core$SPCore$Cons)(((($sp$SPLib$Parser$surroundWith)($start))($zzz))($statements)))($core$SPCore$Nil)));
});

const $sp$Compiler$Parser$makeError = (($moduleName) => (($readState) => (($message) => {
  const $p = ((() => {
    const $$try = $readState;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ((($sp$Types$Pos$P)($moduleName))(0))(1);
    }
    if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$sp$Types$Token$Token" === (($$try)[1])[0]))) {
      const $start = (($$try)[1])[1];
      const $end = (($$try)[1])[2];
      const $k = (($$try)[1])[3];
      const $rest = ($$try)[2];
      return ((($sp$Types$Pos$P)($moduleName))($start))($end);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 69:8', (sp_toHuman)($$try));
  }))();
  return (($sp$Compiler$Error$res)($p))((($eenv) => (($core$SPCore$Cons)($message))($core$SPCore$Nil)));
})));

const $sp$SPLib$Parser$runParser = (($parser) => (($readState) => (($parser)((($core$SPCore$Cons)($readState))($core$SPCore$Nil)))($readState)));

const $sp$Compiler$Parser$runParser = (($moduleName) => (($parser) => (($tokens) => {
  const failureStates$$ = (($sp$SPLib$Parser$runParser)($parser))((($corelib$List$filter)(((e$$) => {
    const $s = (e$$)[1];
    const $e = (e$$)[2];
    const $k = (e$$)[3];
    return ((sp_not_equal)($sp$Types$Token$Comment))($k);
  })))($tokens));
  const $outcome = failureStates$$.second;
  const $failureStates = failureStates$$.first;
  return ((() => {
    const $$try = $outcome;
    if (("$sp$SPLib$Parser$Accepted" === ($$try)[0])) {
      const $readState = ($$try)[1];
      const $output = ($$try)[2];
      return ($corelib$Result$Ok)($output);
      return null;
    }
    if (("$sp$SPLib$Parser$Aborted" === ($$try)[0])) {
      const $readState = ($$try)[1];
      const $message = ($$try)[2];
      return ((($sp$Compiler$Parser$makeError)($moduleName))($readState))($message);
      return null;
    }
    if (("$sp$SPLib$Parser$Rejected" === ($$try)[0])) {
      const $findMin = (($readState) => (($best) => ((($corelib$List$length)($readState) < ($corelib$List$length)($best))
        ? $readState
        : $best)));
      const $readState = ((($corelib$List$foldl)($findMin))($failureStates))($tokens);
      const $message = ((() => {
        const $$try = $readState;
        if (("$core$SPCore$Nil" === ($$try)[0])) {
          return "I got to the end of file and I can't make sense of it. =(";
        }
        if (true) {
          return "I got stuck parsing here. =(";
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 118:16', (sp_toHuman)($$try));
      }))();
      return ((($sp$Compiler$Parser$makeError)($moduleName))($readState))($message);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 103:4', (sp_toHuman)($$try));
  }))();
})));

const $sp$Compiler$Parser$parse = (($stripLocations) => (($moduleName) => (($tokens) => {
  const $parser = ($sp$Compiler$Parser$module_)(({
    moduleName: $moduleName,
    stripLocations: $stripLocations,
  }));
  return ((($sp$Compiler$Parser$runParser)($moduleName))($parser))($tokens);
})));

const $sp$Compiler$Parser$textToFormattableModule = (($pars) => (($code) => {
  const $tokensResult = (($sp$Compiler$Lexer$lexer)($pars.name))($code);
  const $tokensToStatsResult = (($tokens) => {
    (sp_benchStart)(null);
    return ((($corelib$Basics$btw)(sp_benchStop))("parse"))(((($sp$Compiler$Parser$parse)($pars.stripLocations))($pars.name))($tokens));
  });
  return (($corelib$Result$onOk)($tokensToStatsResult))($tokensResult);
}));

const $sp$Compiler$MakeCanonical$textToCanonicalModule = (($pars) => (($code) => {
  const $ro = ({
    currentModule: (($sp$Types$Meta$UMR)($pars.source))($pars.name),
    meta: $pars.meta,
  });
  const $umr = (($sp$Types$Meta$UMR)($pars.source))($pars.name);
  return (($corelib$Result$onOk)(((($sp$Compiler$MakeCanonical$translateModule)($ro))($code))($umr)))((($sp$Compiler$Parser$textToFormattableModule)(({
    name: $pars.name,
    stripLocations: $pars.stripLocations,
  })))($code));
}));

const $sp$Compiler$MakeCanonical_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$DefaultModules$asText = "library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\"\n\n    module =\n       path = SPCore\n       importAs = SPCore\n       globalTypes =\n          None\n          Bool\n          Text\n          Number\n       globalValues =\n          None\n          True\n          False\n\n    module =\n       path = SPCore/List\n       importAs = List\n\n    module =\n       path = SPCore/Maybe\n       importAs = Maybe\n       globalTypes =\n          Maybe\n       globalValues =\n          Just\n          Nothing\n\n    module =\n       path = SPCore/Text\n       importAs = Text\n\n    module =\n       path = SPCore/Tuple\n       importAs = Tuple\n\n    module =\n       path = SPCore/Debug\n       importAs = Debug\n       globalValues =\n          log\n          todo\n\n    module =\n       path = SPCore/Basics\n       globalValues =\n            assert\n            clamp\n            identity\n            modBy\n            min\n            max\n\n    module =\n       path = SPCore/Dict\n       importAs = Dict\n       globalTypes = Dict\n\n    module =\n       path = SPCore/Set\n       importAs = Set\n       globalTypes = Set\n\n    module =\n       path = SPCore/Result\n       importAs = Result\n       globalTypes = Result\n       globalValues =\n          Ok\n          Err";

const $sp$ModulesFile$initModulesFile = ({
  libraries: $core$SPCore$Nil,
  sourceDirs: $core$SPCore$Nil,
});

const $sp$SPON$posEnd = ($sp$Types$Pos$End)("");

const $sp$Types$FormattableAst$statementPos = (($statement) => ((() => {
  const $$try = $statement;
  if (("$sp$Types$FormattableAst$Evaluation" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$FormattableAst$Definition" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if ((("$sp$Types$FormattableAst$TypeAlias" === ($$try)[0]) && ("$sp$Types$Pos$At" === (($$try)[1].name)[0]))) {
    const $pos = (($$try)[1].name)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$FormattableAst$UnionDef" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 115:4', (sp_toHuman)($$try));
}))());

const $sp$SPON$field = (($fieldName) => (($fieldReader) => (($statements) => ((() => {
  const $$try = $statements;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$FormattableAst$Definition" === (($$try)[1])[0]) && (("$sp$Types$FormattableAst$PatternAny" === ((($$try)[1])[2].pattern)[0]) && ((false === ((($$try)[1])[2].pattern)[2]) && ("$corelib$Maybe$Nothing" === (((($$try)[1])[2].pattern)[4])[0])))))) {
    const $pos = (($$try)[1])[1];
    const $body = (($$try)[1])[2].body;
    const $name = ((($$try)[1])[2].pattern)[3];
    const $tail = ($$try)[2];
    return (((sp_equal)($fieldName))($name)
      ? ((() => {
        const $$try = ($fieldReader)($body);
        if (("$sp$SPON$Accepted" === ($$try)[0])) {
          const $unreadStatements = ($$try)[1];
          const $a = ($$try)[2];
          return ((() => {
            const $$try = $unreadStatements;
            if (("$core$SPCore$Nil" === ($$try)[0])) {
              return (($sp$SPON$Accepted)($tail))($a);
            }
            if (("$core$SPCore$Cons" === ($$try)[0])) {
              const $head = ($$try)[1];
              return ($sp$SPON$Failed)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($head)))(("Could not make sense of all the statements in field `" + ($fieldName + "`."))));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 202:24', (sp_toHuman)($$try));
          }))();
          return null;
        }
        if (true) {
          const $otherwise = $$try;
          return $otherwise;
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 200:16', (sp_toHuman)($$try));
      }))()
      : ($sp$SPON$Rejected)((($sp$Types$Pos$At)($pos))(("expecting `" + ($fieldName + " =`")))));
    return null;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $head = ($$try)[1];
    const $tail = ($$try)[2];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($head)))("missing a simple assignment (ie `something = `)"));
    return null;
  }
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)($sp$SPON$posEnd))("unexpected end of file"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 197:4', (sp_toHuman)($$try));
}))())));

const $sp$SPON$lowerOrUpperName = (($statements) => ((() => {
  const $$try = $statements;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try)[1])[0]) && (("$sp$Types$FormattableAst$Variable" === ((($$try)[1])[2])[0]) && (("$corelib$Maybe$Nothing" === (((($$try)[1])[2])[2])[0]) && ("$core$SPCore$Nil" === (((($$try)[1])[2])[4])[0])))))) {
    const $pos = ((($$try)[1])[2])[1];
    const $name = ((($$try)[1])[2])[3];
    const $tail = ($$try)[2];
    return (($sp$SPON$Accepted)($tail))($name);
    return null;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try)[1])[0]) && (("$sp$Types$FormattableAst$Constructor" === ((($$try)[1])[2])[0]) && ("$corelib$Maybe$Nothing" === (((($$try)[1])[2])[2])[0]))))) {
    const $pos = ((($$try)[1])[2])[1];
    const $name = ((($$try)[1])[2])[3];
    const $tail = ($$try)[2];
    return (($sp$SPON$Accepted)($tail))($name);
    return null;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
    const $s = ($$try)[1];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting an Uppercase or lowercase name"));
    return null;
  }
  if (true) {
    return ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a single statement"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 111:4', (sp_toHuman)($$try));
}))());

const $sp$SPON$many = (($readerA) => {
  const $rec = (($accum) => (($statements) => (((sp_equal)($core$SPCore$Nil))($statements)
    ? (($sp$SPON$Accepted)($core$SPCore$Nil))(($corelib$List$reverse)($accum))
    : ((() => {
      const $$try = ($readerA)($statements);
      if (("$sp$SPON$Accepted" === ($$try)[0])) {
        const $tail = ($$try)[1];
        const $a = ($$try)[2];
        return (($rec)(((sp_cons)($accum))($a)))($tail);
        return null;
      }
      if (("$sp$SPON$Rejected" === ($$try)[0])) {
        const $e = ($$try)[1];
        return ($sp$SPON$Rejected)($e);
        return null;
      }
      if (("$sp$SPON$Failed" === ($$try)[0])) {
        const $e = ($$try)[1];
        return ($sp$SPON$Failed)($e);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 168:12', (sp_toHuman)($$try));
    }))())));
  return ($rec)($core$SPCore$Nil);
});

const $sp$SPON$maybe = (($readerA) => (($statements) => ((() => {
  const $$try = ($readerA)($statements);
  if (("$sp$SPON$Accepted" === ($$try)[0])) {
    const $tail = ($$try)[1];
    const $a = ($$try)[2];
    return (($sp$SPON$Accepted)($tail))(($corelib$Maybe$Just)($a));
    return null;
  }
  if (("$sp$SPON$Rejected" === ($$try)[0])) {
    return (($sp$SPON$Accepted)($statements))($corelib$Maybe$Nothing);
  }
  if (("$sp$SPON$Failed" === ($$try)[0])) {
    const $r = ($$try)[1];
    return ($sp$SPON$Failed)($r);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 183:4', (sp_toHuman)($$try));
}))()));

const $sp$SPON$onAcc = (($chainedReaderB) => (($readerA) => (($statements) => ((() => {
  const $$try = ($readerA)($statements);
  if (("$sp$SPON$Accepted" === ($$try)[0])) {
    const $newStatements = ($$try)[1];
    const $a = ($$try)[2];
    return (($chainedReaderB)($a))($newStatements);
    return null;
  }
  if (("$sp$SPON$Rejected" === ($$try)[0])) {
    const $reason = ($$try)[1];
    return ($sp$SPON$Rejected)($reason);
    return null;
  }
  if (("$sp$SPON$Failed" === ($$try)[0])) {
    const $reason = ($$try)[1];
    return ($sp$SPON$Failed)($reason);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 14:4', (sp_toHuman)($$try));
}))())));

const $sp$SPON$return = (($a) => (($statements) => (($sp$SPON$Accepted)($statements))($a)));

const $sp$SPON$upperName = (($statements) => ((() => {
  const $$try = $statements;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try)[1])[0]) && (("$sp$Types$FormattableAst$Constructor" === ((($$try)[1])[2])[0]) && ("$corelib$Maybe$Nothing" === (((($$try)[1])[2])[2])[0]))))) {
    const $pos = ((($$try)[1])[2])[1];
    const $name = ((($$try)[1])[2])[3];
    const $tail = ($$try)[2];
    return (($sp$SPON$Accepted)($tail))($name);
    return null;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
    const $s = ($$try)[1];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting an Uppercase name"));
    return null;
  }
  if (true) {
    return ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a statement"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 98:4', (sp_toHuman)($$try));
}))());

const $sp$ModulesFile$moduleReader = (($sp$SPON$onAcc)((($path) => (($sp$SPON$onAcc)((($visibleAs) => (($sp$SPON$onAcc)((($globalTypes) => (($sp$SPON$onAcc)((($globalValues) => ($sp$SPON$return)(({
  globalTypes: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($globalTypes),
  globalValues: (($corelib$Maybe$withDefault)($core$SPCore$Nil))($globalValues),
  path: $path,
  visibleAs: (($corelib$Maybe$withDefault)($path))($visibleAs),
})))))(($sp$SPON$maybe)((($sp$SPON$field)("globalValues"))(($sp$SPON$many)($sp$SPON$lowerOrUpperName)))))))(($sp$SPON$maybe)((($sp$SPON$field)("globalTypes"))(($sp$SPON$many)($sp$SPON$upperName)))))))(($sp$SPON$maybe)((($sp$SPON$field)("importAs"))($sp$SPON$upperName))))))((($sp$SPON$field)("path"))($sp$SPON$upperName));

const $sp$SPON$text = (($statements) => ((() => {
  const $$try = $statements;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$sp$Types$FormattableAst$Evaluation" === (($$try)[1])[0]) && (("$sp$Types$FormattableAst$LiteralText" === ((($$try)[1])[2])[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))))) {
    const $pos = ((($$try)[1])[2])[1];
    const $t = ((($$try)[1])[2])[2];
    return (($sp$SPON$Accepted)($core$SPCore$Nil))($t);
    return null;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
    const $s = ($$try)[1];
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)(($sp$Types$FormattableAst$statementPos)($s)))("expecting a text literal"));
    return null;
  }
  if (true) {
    return ($sp$SPON$Failed)((($sp$Types$Pos$At)($sp$SPON$posEnd))("expecting a single statement"));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 85:4', (sp_toHuman)($$try));
}))());

const $sp$ModulesFile$libraryReader = (($sp$SPON$onAcc)((($source) => (($sp$SPON$onAcc)((($modules) => ($sp$SPON$return)(({
  modules: $modules,
  source: $source,
})))))(($sp$SPON$many)((($sp$SPON$field)("module"))($sp$ModulesFile$moduleReader))))))((($sp$SPON$field)("source"))($sp$SPON$text));

const $sp$ModulesFile$sourceDirectoryReader = (($sp$SPON$onAcc)((($path) => (($sp$SPON$onAcc)((($modules) => ($sp$SPON$return)(({
  modules: $modules,
  path: $path,
})))))(($sp$SPON$many)((($sp$SPON$field)("module"))($sp$ModulesFile$moduleReader))))))((($sp$SPON$field)("path"))($sp$SPON$text));

const $sp$SPON$oneOf = (($readers) => (($statements) => ((() => {
  const $$try = $readers;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    const $pos = ((() => {
      const $$try = $statements;
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $head = ($$try)[1];
        return ($sp$Types$FormattableAst$statementPos)($head);
        return null;
      }
      if (true) {
        return $sp$SPON$posEnd;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 136:16', (sp_toHuman)($$try));
    }))();
    return ($sp$SPON$Rejected)((($sp$Types$Pos$At)($pos))("options exhausted"));
    return null;
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $headReader = ($$try)[1];
    const $tail = ($$try)[2];
    return ((() => {
      const $$try = ($headReader)($statements);
      if (("$sp$SPON$Rejected" === ($$try)[0])) {
        return (($sp$SPON$oneOf)($tail))($statements);
      }
      if (true) {
        const $otherwise = $$try;
        return $otherwise;
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 143:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 133:4', (sp_toHuman)($$try));
}))()));

const $sp$ModulesFile$modulesFileReader = ($sp$SPON$many)(($sp$SPON$oneOf)((($core$SPCore$Cons)((($sp$SPON$onAcc)((($lib) => ($sp$SPON$return)(($sp$ModulesFile$Lib)($lib)))))((($sp$SPON$field)("library"))($sp$ModulesFile$libraryReader))))((($core$SPCore$Cons)((($sp$SPON$onAcc)((($dir) => ($sp$SPON$return)(($sp$ModulesFile$Dir)($dir)))))((($sp$SPON$field)("sourceDir"))($sp$ModulesFile$sourceDirectoryReader))))($core$SPCore$Nil))));

const $sp$SPON$unhackPosEnd = (($moduleName) => (($pos) => ((() => {
  const $$try = $pos;
  if (("$sp$Types$Pos$End" === ($$try)[0])) {
    return ($sp$Types$Pos$End)($moduleName);
  }
  if (true) {
    return $pos;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 37:4', (sp_toHuman)($$try));
}))()));

const $sp$SPON$run = (($readerA) => (($sponName) => (($statements) => ((() => {
  const $$try = ($readerA)($statements);
  if ((("$sp$SPON$Accepted" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[1])[0]))) {
    const $a = ($$try)[2];
    return ($corelib$Result$Ok)($a);
    return null;
  }
  if ((("$sp$SPON$Accepted" === ($$try)[0]) && ("$core$SPCore$Cons" === (($$try)[1])[0]))) {
    const $head = (($$try)[1])[1];
    const $tail = (($$try)[1])[2];
    const $a = ($$try)[2];
    return (($sp$Compiler$Error$res)(($sp$Types$FormattableAst$statementPos)($head)))((() => (($core$SPCore$Cons)("unread statements"))($core$SPCore$Nil)));
    return null;
  }
  if ((("$sp$SPON$Rejected" === ($$try)[0]) && ("$sp$Types$Pos$At" === (($$try)[1])[0]))) {
    const $pos = (($$try)[1])[1];
    const $r = (($$try)[1])[2];
    return (($sp$Compiler$Error$res)((($sp$SPON$unhackPosEnd)($sponName))($pos)))((() => (($core$SPCore$Cons)($r))($core$SPCore$Nil)));
    return null;
  }
  if ((("$sp$SPON$Failed" === ($$try)[0]) && ("$sp$Types$Pos$At" === (($$try)[1])[0]))) {
    const $pos = (($$try)[1])[1];
    const $r = (($$try)[1])[2];
    return (($sp$Compiler$Error$res)((($sp$SPON$unhackPosEnd)($sponName))($pos)))((() => (($core$SPCore$Cons)($r))($core$SPCore$Nil)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 44:4', (sp_toHuman)($$try));
}))())));

const $sp$SPON$read = (($reader) => (($sponName) => (($sponContent) => (($corelib$Result$onOk)((($sp$SPON$run)($reader))($sponName)))((($corelib$Result$onOk)((($sp$Compiler$Parser$parse)(false))($sponName)))((($sp$Compiler$Lexer$lexer)($sponName))($sponContent))))));

const $sp$ModulesFile$textToModulesFile = (($sponName) => (($sponContent) => {
  const $insert = (($rootEntry) => (($mf) => ((() => {
    const $$try = $rootEntry;
    if (("$sp$ModulesFile$Lib" === ($$try)[0])) {
      const $lib = ($$try)[1];
      return (Object.assign)({}, $mf, ({
        libraries: ((sp_cons)($mf.libraries))($lib),
      }));
      return null;
    }
    if (("$sp$ModulesFile$Dir" === ($$try)[0])) {
      const $dir = ($$try)[1];
      return (Object.assign)({}, $mf, ({
        sourceDirs: ((sp_cons)($mf.sourceDirs))($dir),
      }));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/ModulesFile.sp 149:8', (sp_toHuman)($$try));
  }))()));
  return (($corelib$Result$map)((($rootEntries) => ((($corelib$List$foldl)($insert))($rootEntries))($sp$ModulesFile$initModulesFile))))(((($sp$SPON$read)($sp$ModulesFile$modulesFileReader))($sponName))($sponContent));
}));

const $sp$ModulesFile$insertModule = (($source) => (($mod) => (($meta) => {
  const $visibleAs = $mod.visibleAs;
  const $umr = (($sp$Types$Meta$UMR)($source))($mod.path);
  const $insertGlobal = (($varName) => (($corelib$Dict$insert)($varName))((($sp$Types$Meta$USR)($umr))($varName)));
  return ({
    globalTypes: ((($corelib$List$foldl)($insertGlobal))($mod.globalTypes))($meta.globalTypes),
    globalValues: ((($corelib$List$foldl)($insertGlobal))($mod.globalValues))($meta.globalValues),
    moduleVisibleAsToUmr: ((($corelib$Dict$insert)($visibleAs))($umr))($meta.moduleVisibleAsToUmr),
    umrToModuleVisibleAs: ((($corelib$Dict$insert)($umr))($visibleAs))($meta.umrToModuleVisibleAs),
  });
})));

const $sp$ModulesFile$insertLibrary = (($lib) => (($meta) => (((sp_not_equal)("spcore"))($lib.source)
  ? (sp_todo)(("Library source `" + ($lib.source + "` is not supported.")))
  : ((($corelib$List$foldl)(($sp$ModulesFile$insertModule)($sp$Types$Meta$Core)))($lib.modules))($meta))));

const $sp$ModulesFile$insertModules = (($sd) => (($corelib$List$foldl)(($sp$ModulesFile$insertModule)(($sp$Types$Meta$SourceDir)($sd.path))))($sd.modules));

const $sp$Types$Meta$init = ({
  globalTypes: $corelib$Dict$empty,
  globalValues: $corelib$Dict$empty,
  moduleVisibleAsToUmr: $corelib$Dict$empty,
  umrToModuleVisibleAs: $corelib$Dict$empty,
});

const $sp$ModulesFile$toMeta = (($mf) => ((($corelib$List$foldl)($sp$ModulesFile$insertModules))($mf.sourceDirs))(((($corelib$List$foldl)($sp$ModulesFile$insertLibrary))($mf.libraries))($sp$Types$Meta$init)));

const $sp$ModulesFile$textToMeta = (($sponName) => (($sponContent) => (($corelib$Result$map)($sp$ModulesFile$toMeta))((($sp$ModulesFile$textToModulesFile)($sponName))($sponContent))));

const $sp$Compiler$TestHelpers$meta = ((() => {
  const $eenv = ({
    moduleByName: (($corelib$Dict$singleton)("DefaultModules"))(({
      content: $sp$DefaultModules$asText,
      fsPath: "<DefaultModules>",
    })),
  });
  const $metaResult = (($corelib$Result$mapError)((($e) => ($sp$Compiler$TestHelpers$formattedToStrippedText)((($sp$Compiler$Error$toFormattedText)($eenv))($e)))))((($sp$ModulesFile$textToMeta)("DefaultModules"))($sp$DefaultModules$asText));
  return ((() => {
    const $$try = $metaResult;
    if (("$corelib$Result$Err" === ($$try)[0])) {
      const $e = ($$try)[1];
      ((sp_log)(("Error in DefaultModules.sp: " + $e)))(null);
      return (sp_todo)("error loading DefaultModules.sp");
      return null;
    }
    if (("$corelib$Result$Ok" === ($$try)[0])) {
      const $m = ($$try)[1];
      return $m;
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TestHelpers.sp 46:4', (sp_toHuman)($$try));
  }))();
}))();

const $sp$Compiler$TestHelpers$source = ($sp$Types$Meta$SourceDir)("<Test>");

const $sp$Compiler$MakeCanonical_Test$params = ({
  meta: $sp$Compiler$TestHelpers$meta,
  name: $sp$Compiler$TestHelpers$moduleName,
  source: $sp$Compiler$TestHelpers$source,
  stripLocations: true,
});

const $sp$Compiler$MakeCanonical_Test$textToModule = (($code) => (($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($sp$Compiler$MakeCanonical_Test$params))($code)));

const $sp$Compiler$MakeCanonical_Test$firstDefinition = (($code) => (($corelib$Result$onOk)((($mod) => (($corelib$Result$fromMaybe)("firstDefinition fail"))(($corelib$List$head)(($corelib$Dict$values)($mod.valueDefs))))))(($sp$Compiler$MakeCanonical_Test$textToModule)($code)));

const $sp$Compiler$MakeCanonical_Test$asEvaluation = (($s) => ((() => {
  const $$try = $s;
  if (("$sp$Types$CanonicalAst$Evaluation" === ($$try)[0])) {
    const $expr = ($$try)[1];
    return ($corelib$Maybe$Just)($expr);
    return null;
  }
  if (true) {
    return $corelib$Maybe$Nothing;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical_Test.sp 46:3', (sp_toHuman)($$try));
}))());

const $sp$Compiler$MakeCanonical_Test$firstEvaluation = (($name) => (($code) => (($corelib$Result$onOk)((($x) => (($corelib$Result$fromMaybe)("asEval fail"))(($sp$Compiler$MakeCanonical_Test$asEvaluation)($x)))))((($corelib$Result$onOk)((($def) => (($corelib$Result$fromMaybe)("head fail"))(($corelib$List$head)($def.body)))))(($sp$Compiler$MakeCanonical_Test$firstDefinition)($code)))));

const $sp$Test$isOk = ($sp$Test$CodeExpectation)((($toText) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($corelib$Maybe$Just)($e);
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $actualOk = ($$try)[1];
    return $corelib$Maybe$Nothing;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 69:8', (sp_toHuman)($$try));
}))())));

const $sp$Compiler$MakeCanonical_Test$annotations = (($sp$Test$Group)("Annotations"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation on mutable value"))("x =\n  a as Number @=\n    3\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation on immutable value"))("b as Number =\n  3"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("b")))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$MakeCanonical_Test$p = $sp$Types$Pos$T;

const $sp$Test$freeform = (($test) => ($sp$Test$CodeExpectation)((($toText) => (($result) => ((() => {
  const $$try = $result;
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($corelib$Maybe$Just)($e);
    return null;
  }
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $actualOk = ($$try)[1];
    return ($test)($actualOk);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 62:4', (sp_toHuman)($$try));
}))()))));

const $sp$Compiler$MakeCanonical_Test$shouldHaveSameAB = (($getter) => ($sp$Test$freeform)(((a$$) => {
  const $a = a$$.first;
  const $b = a$$.second;
  return (((sp_equal)(($getter)($b)))(($getter)($a))
    ? $corelib$Maybe$Nothing
    : ($corelib$Maybe$Just)((($corelib$Text$join)("\n"))((($core$SPCore$Cons)("The two don't match:"))((($core$SPCore$Cons)((sp_toHuman)(($getter)($a))))((($core$SPCore$Cons)((sp_toHuman)(($getter)($b))))($core$SPCore$Nil))))));
})));

const $sp$Compiler$MakeCanonical_Test$transformAB = (($code) => {
  const $findAB = (($mod) => ((() => {
    const $$try = ((list_sortBy)((($def) => $def.pattern)))(($corelib$Dict$values)($mod.valueDefs));
    if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0])))) {
      const $a = ($$try)[1];
      const $b = (($$try)[2])[1];
      return ($corelib$Maybe$Just)(({
        first: $a,
        second: $b,
      }));
      return null;
    }
    if (true) {
      return $corelib$Maybe$Nothing;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/MakeCanonical_Test.sp 59:8', (sp_toHuman)($$try));
  }))());
  return (($corelib$Result$onOk)((($x) => (($corelib$Result$fromMaybe)("findAB fail"))(($findAB)($x)))))(($sp$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sp$Compiler$MakeCanonical_Test$binops = (($sp$Test$Group)("Binops"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("left associativity"))("a = v >> f >> g\nb = (v >> f) >> g"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => $x.body)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("right associativity"))("a = v :: f :: g\nb = v :: (f :: g)"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => $x.body)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("precedence"))("a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4"))($sp$Compiler$MakeCanonical_Test$transformAB))(($sp$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => $x.body)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP functional notation"))("a = (-)"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Types$CanonicalAst$RefRoot)(($sp$Compiler$CoreTypes$makeUsr)("-")),
}))))))($core$SPCore$Nil)))));

const $sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps = (($code) => (($corelib$Result$map)((($v) => (Object.assign)({}, $v, ({
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
})))))(($sp$Compiler$MakeCanonical_Test$firstDefinition)($code)));

const $sp$Compiler$MakeCanonical_Test$functions = (($sp$Test$Group)("Functions"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("[rec] lambda with two arguments"))("f =\n  a: b: 1"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("f")))($sp$Test$isOk)))($core$SPCore$Nil));

const $sp$Compiler$TestHelpers$boolType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("Bool")))($core$SPCore$Nil);

const $sp$Compiler$TestHelpers$moduleUmr = (($sp$Types$Meta$UMR)($sp$Compiler$TestHelpers$source))($sp$Compiler$TestHelpers$moduleName);

const $sp$Compiler$TestHelpers$rootLocal = (($name) => ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))($name)));

const $sp$Compiler$MakeCanonical_Test$lists = (($sp$Test$Group)("Lists"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("list type sugar"))("l as [ Bool ] =\n  l"))($sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps))(($sp$Test$isOkAndEqualTo)(({
  body: (($core$SPCore$Cons)(($sp$Types$CanonicalAst$Evaluation)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("l"),
  })))))($core$SPCore$Nil),
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
  mutable: false,
  native: false,
  nonFn: $corelib$Dict$empty,
  parentDefinitions: $core$SPCore$Nil,
  pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)("l")))(($corelib$Maybe$Just)(($sp$Compiler$CoreTypes$list)($sp$Compiler$TestHelpers$boolType))),
})))))($core$SPCore$Nil));

const $sp$Compiler$MakeCanonical_Test$moduleAndAttributePaths = ((() => {
  const $accept = (($s) => (((($sp$Compiler$MakeCanonical_Test$codeTest)($s))(("a = " + $s)))($sp$Compiler$MakeCanonical_Test$firstDefinition))($sp$Test$isOk));
  const $reject = (($s) => (($m) => (((($sp$Compiler$MakeCanonical_Test$codeTest)($s))(("a = " + $s)))($sp$Compiler$MakeCanonical_Test$firstDefinition))(($sp$Test$errorContains)((($core$SPCore$Cons)($m))($core$SPCore$Nil)))));
  return (($sp$Test$Group)("Module and Attribute Paths"))((($core$SPCore$Cons)(($accept)("blah.blah.blah")))((($core$SPCore$Cons)((($reject)("Blah.Blah.blah"))("constructor")))((($core$SPCore$Cons)((($reject)("blah.Blah.blah"))("case")))((($core$SPCore$Cons)((($reject)("List.blah.Blah"))("lower")))((($core$SPCore$Cons)((($reject)("List..blah"))("space")))((($core$SPCore$Cons)((($reject)(".Blah"))("upper")))((($core$SPCore$Cons)((($reject)(".blah.blah"))("shorthand")))((($core$SPCore$Cons)((($reject)(".blah"))("shorthand")))((($core$SPCore$Cons)((($reject)("..."))("")))((($core$SPCore$Cons)(($accept)("x .. y")))($core$SPCore$Nil)))))))))));
}))();

const $sp$Compiler$MakeCanonical_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("[reg] record patterns are NOT extensible"))("a =\n  { b with c } = d"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("with"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$MakeCanonical_Test$pipes = (($sp$Test$Group)("Pipes"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("sendLeft is inlined"))("a = thing >> function"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Call)($sp$Compiler$MakeCanonical_Test$p))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("function"),
}))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("thing"),
}))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("sendRight is inlined"))("a = function << thing"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Call)($sp$Compiler$MakeCanonical_Test$p))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("function"),
}))))(($sp$Types$CanonicalAst$ArgumentExpression)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("thing"),
}))))))))($core$SPCore$Nil)));

const $sp$Compiler$MakeCanonical_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("functional update"))("a = { m with b, c = 1 }"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)(({
  attrPath: $core$SPCore$Nil,
  ref: ($sp$Compiler$TestHelpers$rootLocal)("m"),
}))))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "c",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "b",
  second: (($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("b"),
  })),
})))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("update shorthand"))("b = { a.k with y = .x }"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("b")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)(({
  attrPath: (($core$SPCore$Cons)("k"))($core$SPCore$Nil),
  ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
}))))((($corelib$Dict$singleton)("y"))((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
  attrPath: (($core$SPCore$Cons)("k"))((($core$SPCore$Cons)("x"))($core$SPCore$Nil)),
  ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
}))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("annotation, extensible"))("a as { b with x as Bool } =\n  a"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("disabled"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$TestHelpers$numberType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("Number")))($core$SPCore$Nil);

const $sp$Compiler$MakeCanonical_Test$tuples = (($sp$Test$Group)("Tuples"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple2"))("a = 1 & 2"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "first",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "second",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(2),
})))($core$SPCore$Nil))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple3"))("a = 1 & 2 & 3"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$isOkAndEqualTo)(((($sp$Types$CanonicalAst$Record)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
  first: "first",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(1),
})))((($core$SPCore$Cons)(({
  first: "second",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(2),
})))((($core$SPCore$Cons)(({
  first: "third",
  second: (($sp$Types$CanonicalAst$LiteralNumber)($sp$Compiler$MakeCanonical_Test$p))(3),
})))($core$SPCore$Nil)))))))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple4"))("a = 1 & 2 & 3 & 4"))(($sp$Compiler$MakeCanonical_Test$firstEvaluation)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("use a record"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple2 type"))("a as Number & Number =\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinitionStripDeps))(($sp$Test$isOkAndEqualTo)(({
  body: (($core$SPCore$Cons)(($sp$Types$CanonicalAst$Evaluation)((($sp$Types$CanonicalAst$Variable)($sp$Compiler$MakeCanonical_Test$p))(({
    attrPath: $core$SPCore$Nil,
    ref: ($sp$Compiler$TestHelpers$rootLocal)("a"),
  })))))($core$SPCore$Nil),
  directConsDeps: $corelib$Dict$empty,
  directTypeDeps: $corelib$Dict$empty,
  directValueDeps: $corelib$Dict$empty,
  mutable: false,
  native: false,
  nonFn: $corelib$Dict$empty,
  parentDefinitions: $core$SPCore$Nil,
  pattern: ((($sp$Types$CanonicalAst$PatternAny)($sp$Compiler$MakeCanonical_Test$p))(($corelib$Maybe$Just)("a")))(($corelib$Maybe$Just)(((($sp$Types$CanonicalAst$TypeRecord)($sp$Compiler$MakeCanonical_Test$p))($corelib$Maybe$Nothing))(((($corelib$Dict$insert)("second"))($sp$Compiler$TestHelpers$numberType))(((($corelib$Dict$insert)("first"))($sp$Compiler$TestHelpers$numberType))($corelib$Dict$empty))))),
})))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("tuple4, type"))("a as Blah & Blah & Blah & Blah =\n  a"))($sp$Compiler$MakeCanonical_Test$firstDefinition))(($sp$Test$errorContains)((($core$SPCore$Cons)("Use a record"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$MakeCanonical_Test$unionTypes = (($sp$Test$Group)("Union types"))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP tuples op precedence"))("union A = X Bool & Bool"))($sp$Compiler$MakeCanonical_Test$textToModule))(($sp$Test$errorContains)((($core$SPCore$Cons)("operators"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("Tuples op precedence works with parens"))("union A = X (Bool & Bool)"))($sp$Compiler$MakeCanonical_Test$textToModule))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$MakeCanonical_Test$codeTest)("SKIP [reg] Should reject uppercase arg name"))("union Outcome Token output = A"))($sp$Compiler$MakeCanonical_Test$textToModule))(($sp$Test$errorContains)((($core$SPCore$Cons)("Token"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$MakeCanonical_Test$tests = (($sp$Test$Group)("MakeCanonical"))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$unionTypes))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$binops))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$tuples))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$lists))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$moduleAndAttributePaths))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$records))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$annotations))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$pipes))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$functions))($core$SPCore$Nil)))))))))));

const $sp$Compiler$Parser$binopInsideParens = (($env) => (($sp$Compiler$Parser$andThen)(((end$$) => {
  const $start = (end$$)[1];
  const $end = (end$$)[2];
  const $k = (end$$)[3];
  return ((() => {
    const $$try = $k;
    if (("$sp$Types$Token$Binop" === ($$try)[0])) {
      const $binop = ($$try)[1];
      return ($sp$SPLib$Parser$accept)((($sp$Types$FormattableAst$PrefixBinop)(((($sp$Compiler$Parser$pos)($env))($start))($end)))($binop.symbol));
      return null;
    }
    if (true) {
      return $sp$SPLib$Parser$reject;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser.sp 1204:4', (sp_toHuman)($$try));
  }))();
})))($sp$Compiler$Parser$oneToken));

const $sp$Compiler$Parser$inlineOrIndented = (($p) => ($sp$SPLib$Parser$oneOf)((($core$SPCore$Cons)(($sp$Compiler$Parser$block)($p)))((($core$SPCore$Cons)($p))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$codeTest = ($sp$Test$codeTest)(sp_toHuman);

const $sp$Compiler$Parser_Test$asDefinition = (($s) => ((() => {
  const $$try = $s;
  if (("$sp$Types$FormattableAst$Definition" === ($$try)[0])) {
    const $a = ($$try)[2];
    return ($corelib$Result$Ok)($a);
    return null;
  }
  if (true) {
    return ($corelib$Result$Err)("Test says: no def");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 29:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$Parser_Test$firstStatement = (($code) => {
  const $grabFirst = (($stats) => ((() => {
    const $$try = $stats;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($corelib$Result$Err)("Test says: no statements");
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $head = ($$try)[1];
      const $tail = ($$try)[2];
      return ($corelib$Result$Ok)($head);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 52:8', (sp_toHuman)($$try));
  }))());
  return (($corelib$Result$onOk)($grabFirst))((($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))((($sp$Compiler$Parser$textToFormattableModule)(({
    name: "Test",
    stripLocations: true,
  })))($code)));
});

const $sp$Compiler$Parser_Test$firstAnnotation = (($code) => {
  const $grabAnnotation = (($def) => ((() => {
    const $$try = $def.pattern;
    if ((("$sp$Types$FormattableAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[4])[0]))) {
      const $pos = ($$try)[1];
      const $name = ($$try)[2];
      const $mutable = ($$try)[3];
      const $ty = (($$try)[4])[1];
      return ($corelib$Result$Ok)($ty);
      return null;
    }
    if (true) {
      return ($corelib$Result$Err)("no annotation");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 94:8', (sp_toHuman)($$try));
  }))());
  return (($corelib$Result$onOk)($grabAnnotation))((($corelib$Result$onOk)($sp$Compiler$Parser_Test$asDefinition))(($sp$Compiler$Parser_Test$firstStatement)($code)));
});

const $sp$Compiler$Parser_Test$p = $sp$Types$Pos$T;

const $sp$Compiler$Parser_Test$typeConstant = (($name) => (((($sp$Types$FormattableAst$TypeConstant)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))($name))($core$SPCore$Nil));

const $sp$Compiler$Parser_Test$annotations = (($sp$Test$Group)("Annotations"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Mutability 1"))("a as Number @: Int: None =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Number")))(true))((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int")))(false))(($sp$Compiler$Parser_Test$typeConstant)("None")))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Mutability 2"))("a as Number: Int @: None =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Number")))(false))((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int")))(true))(($sp$Compiler$Parser_Test$typeConstant)("None")))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Tuple precedence"))("a as Int & Int: Bool =\n  1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$TypeFunction)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$TypeTuple)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)(($sp$Compiler$Parser_Test$typeConstant)("Int")))((($core$SPCore$Cons)(($sp$Compiler$Parser_Test$typeConstant)("Int")))($core$SPCore$Nil)))))(false))(($sp$Compiler$Parser_Test$typeConstant)("Bool"))))))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$asEvaluation = (($s) => ((() => {
  const $$try = $s;
  if (("$sp$Types$FormattableAst$Evaluation" === ($$try)[0])) {
    const $a = ($$try)[2];
    return ($corelib$Result$Ok)($a);
    return null;
  }
  if (true) {
    return ($corelib$Result$Err)("Test says: no eval");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 39:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$Parser_Test$firstDefinition = (($code) => (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asDefinition))(($sp$Compiler$Parser_Test$firstStatement)($code)));

const $sp$Compiler$Parser_Test$firstEvaluationOfDefinition = (($code) => {
  const $grabFirst = (($def) => ((() => {
    const $$try = $def.body;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($corelib$Result$Err)("Test says: empty def body");
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $head = ($$try)[1];
      const $tail = ($$try)[2];
      return ($corelib$Result$Ok)($head);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 79:8', (sp_toHuman)($$try));
  }))());
  return (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asEvaluation))((($corelib$Result$onOk)($grabFirst))(($sp$Compiler$Parser_Test$firstDefinition)($code)));
});

const $sp$Compiler$Parser_Test$binops = ((() => {
  const $sendBtoC = (($b) => (($c) => ((($sp$Types$FormattableAst$Binop)($sp$Compiler$Parser_Test$p))($sp$Types$Op$Pipe))(({
    first: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil),
    second: (($core$SPCore$Cons)(({
      first: $sp$Prelude$sendRight,
      second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil),
    })))($core$SPCore$Nil),
  }))));
  const $sendBtoCtoD = (($b) => (($c) => (($d) => ((($sp$Types$FormattableAst$Binop)($sp$Compiler$Parser_Test$p))($sp$Types$Op$Pipe))(({
    first: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("b"))($core$SPCore$Nil),
    second: (($core$SPCore$Cons)(({
      first: $sp$Prelude$sendRight,
      second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("c"))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: $sp$Prelude$sendRight,
      second: (((($sp$Types$FormattableAst$Variable)($sp$Compiler$Parser_Test$p))($corelib$Maybe$Nothing))("d"))($core$SPCore$Nil),
    })))($core$SPCore$Nil)),
  })))));
  return (($sp$Test$Group)("Binops"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("no indent"))("a = b >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(5))(10)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("assignment indent"))("a =\n    b >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(9))(14)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pipe indent"))("a =\n    b\n      >> c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sendBtoC)(9))(20)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pipe indent"))("a =\n    b\n      >> c\n      >> d"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)(((($sendBtoCtoD)(9))(20))(31)))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("pyramid indent"))("a =\n    b\n      >> c\n        >> d"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)(((($sendBtoCtoD)(9))(20))(33)))))($core$SPCore$Nil))))));
}))();

const $sp$Compiler$Parser_Test$firstEvaluation = (($code) => (($corelib$Result$onOk)($sp$Compiler$Parser_Test$asEvaluation))(($sp$Compiler$Parser_Test$firstStatement)($code)));

const $sp$Compiler$Parser_Test$ifs = (($sp$Test$Group)("Ifs"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("inline"))("a = if a then b else c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP multiline, formatted"))("x =\n    if a then\n        b\n    else\n        c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, compact"))("x =\n  if a then b\n  else c"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$lambdas = (($sp$Test$Group)("lambdas"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Inline nesting"))("a: b: 3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Block nesting"))("a:\n  b:\n    3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Sibling nesting"))("a:\nb:\n3"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$Lambda)($sp$Compiler$Parser_Test$p))((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))(false))((($core$SPCore$Cons)((($sp$Types$FormattableAst$Evaluation)($sp$Compiler$Parser_Test$p))((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("3"))))($core$SPCore$Nil)))))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Tuple has precedence over lambda"))("x =\n  a & b: a"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] pass to function without parens"))("i =\n  x @= 1\n  xxx y: y"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil))))));

const $sp$Compiler$Parser_Test$lists = (($sp$Test$Group)("Lists"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Inline"))("[1, 2]"))($sp$Compiler$Parser_Test$firstEvaluation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Multiline canonical"))("a =\n  [\n  , 1\n  , 2\n  ]"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Multiline compact"))("a = [\n  , 1\n  , 2\n  ]"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$List)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")))($core$SPCore$Nil)))))))($core$SPCore$Nil))));

const $sp$Compiler$Parser_Test$parens = (($sp$Test$Group)("Parens"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Can exist on multiple lines even when useless"))("tests =\n    (Ok\n    )"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Can exist on multiple lines"))("tests =\n    blah\n        (Ok\n        )"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list unpacking"))("[a, b] = x"))((($x) => (($corelib$Result$map)((($y) => $y.pattern)))(($sp$Compiler$Parser_Test$firstDefinition)($x)))))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$PatternList)($sp$Compiler$Parser_Test$p))((($core$SPCore$Cons)((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("a"))($corelib$Maybe$Nothing)))((($core$SPCore$Cons)((((($sp$Types$FormattableAst$PatternAny)($sp$Compiler$Parser_Test$p))(false))("b"))($corelib$Maybe$Nothing)))($core$SPCore$Nil)))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list unpacking, inner block"))("x =\n   [ a, b ] = c"))((($x) => (($corelib$Result$map)((($y) => $y.pattern)))(($sp$Compiler$Parser_Test$firstDefinition)($x)))))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("record unpacking"))("{ a, b } = x"))((($x) => (($corelib$Result$map)((($y) => $y.pattern)))(($sp$Compiler$Parser_Test$firstDefinition)($x)))))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$PatternRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("a"),
    second: $corelib$Maybe$Nothing,
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("b"),
    second: $corelib$Maybe$Nothing,
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("record unpacking, inner block"))("x =\n  { a, b } = c"))((($x) => (($corelib$Result$map)((($y) => $y.pattern)))(($sp$Compiler$Parser_Test$firstDefinition)($x)))))($sp$Test$isOk)))($core$SPCore$Nil)))));

const $sp$Compiler$Parser_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("inline"))("a = { x = 1 }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline"))("a =\n  {\n  , x = 1\n  , y = 2\n  }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("y"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")),
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline compact"))("a = {\n  , x = 1\n  , y = 2\n  }"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$Record)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("1")),
  })))((($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("y"),
    second: ($corelib$Maybe$Just)((($sp$Types$FormattableAst$LiteralNumber)($sp$Compiler$Parser_Test$p))("2")),
  })))($core$SPCore$Nil)),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Annotation, inline"))("a as { x as Bool } =\n  a"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Annotation, own line"))("a as\n   { x as Bool }\n   =\n   1"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("SKIP Annotation, multiline"))("a as {\n   , x as Bool\n   }\n      =\n      a"))($sp$Compiler$Parser_Test$firstAnnotation))(($sp$Test$isOkAndEqualTo)((($sp$Types$FormattableAst$TypeRecord)($sp$Compiler$Parser_Test$p))(({
  attrs: (($core$SPCore$Cons)(({
    first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("x"),
    second: ($corelib$Maybe$Just)(($sp$Compiler$Parser_Test$typeConstant)("Bool")),
  })))($core$SPCore$Nil),
  extends: $corelib$Maybe$Nothing,
}))))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, inline"))("a = { b with c }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, as block"))("a =\n  { b with c }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] simple assignment, as block"))("a =\n  { b with c = 1 }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] real-world use"))("a =\n  { state with\n      , pos = endPos\n      , code = rest\n      , accum =\n          { kind = Token.Comment\n          , start = startPos\n          , end = endPos\n          }\n              :: state.accum\n  }"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)))))))))));

const $sp$Compiler$Parser_Test$tries = (($sp$Test$Group)("Try"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, formatted"))("x =\n  try a as\n    b:\n      c\n    d:\n      e"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("multiline, compact"))("x =\n  try a as\n    b: c\n    d: e"))($sp$Compiler$Parser_Test$firstEvaluationOfDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$unionDefs = ((() => {
  const $asTypeDef = (($s) => ((() => {
    const $$try = $s;
    if (("$sp$Types$FormattableAst$UnionDef" === ($$try)[0])) {
      const $a = ($$try)[2];
      return ($corelib$Result$Ok)($a);
      return null;
    }
    if (true) {
      return ($corelib$Result$Err)("no type def");
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Parser_Test.sp 322:8', (sp_toHuman)($$try));
  }))());
  const $firstTypeDef = (($x) => (($corelib$Result$onOk)($asTypeDef))(($sp$Compiler$Parser_Test$firstStatement)($x)));
  return (($sp$Test$Group)("Type Definitions"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Parse inline def"))("union A b c = V1 b, V2 c, V3, V4 b c"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: (($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)),
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V1"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("b")))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V2"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("c")))($core$SPCore$Nil),
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V3"),
      second: $core$SPCore$Nil,
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V4"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("b")))((($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeVariable)($sp$Compiler$Parser_Test$p))("c")))($core$SPCore$Nil)),
    })))($core$SPCore$Nil)))),
    name: "A",
  })))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("Parse multiline def"))("union A =\n   , V1\n   , V2"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: $core$SPCore$Nil,
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V1"),
      second: $core$SPCore$Nil,
    })))((($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("V2"),
      second: $core$SPCore$Nil,
    })))($core$SPCore$Nil)),
    name: "A",
  })))))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("list argument"))("union A = A [Int]"))($firstTypeDef))(($sp$Test$isOkAndEqualTo)(({
    args: $core$SPCore$Nil,
    constructors: (($core$SPCore$Cons)(({
      first: (($sp$Types$Pos$At)($sp$Compiler$Parser_Test$p))("A"),
      second: (($core$SPCore$Cons)((($sp$Types$FormattableAst$TypeList)($sp$Compiler$Parser_Test$p))(($sp$Compiler$Parser_Test$typeConstant)("Int"))))($core$SPCore$Nil),
    })))($core$SPCore$Nil),
    name: "A",
  })))))($core$SPCore$Nil))));
}))();

const $sp$Compiler$Parser_Test$values = (($sp$Test$Group)("Values"))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] Unop"))("a = f -n"))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$Parser_Test$codeTest)("[reg] deal with spurious NewSiblingLine introduced by inline comments"))("library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\""))($sp$Compiler$Parser_Test$firstDefinition))($sp$Test$isOk)))($core$SPCore$Nil)));

const $sp$Compiler$Parser_Test$tests = (($sp$Test$Group)("Parser"))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$values))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$parens))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$lambdas))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$annotations))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$unionDefs))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$lists))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$records))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$ifs))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$tries))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$binops))($core$SPCore$Nil))))))))))));

const $sp$Compiler$Pipeline$insertUnionConstructors = (($typeDef) => (($constructors) => ((() => {
  const $$try = $typeDef;
  if (("$sp$Types$CanonicalAst$TypeDefAlias" === ($$try)[0])) {
    return $constructors;
  }
  if (("$sp$Types$CanonicalAst$TypeDefUnion" === ($$try)[0])) {
    const $def = ($$try)[1];
    const umr$$ = $def.usr;
    const $umr = (umr$$)[1];
    return ((($corelib$Dict$foldl)((($name) => ($corelib$Dict$insert)((($sp$Types$Meta$USR)($umr))($name)))))($def.constructors))($constructors);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Pipeline.sp 31:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$Pipeline$coreConstructors = ((($corelib$List$foldl)((($u) => ($sp$Compiler$Pipeline$insertUnionConstructors)(($sp$Types$CanonicalAst$TypeDefUnion)($u)))))($sp$Compiler$CoreTypes$allDefs))($corelib$Dict$empty);

const $sp$Compiler$Pipeline$coreTypes = ((($corelib$List$foldl)((($def) => (($corelib$Dict$insert)($def.usr))(($sp$Types$CanonicalAst$TypeDefUnion)($def)))))($sp$Compiler$CoreTypes$allDefs))($corelib$Dict$empty);

const $sp$Prelude$functions = (($core$SPCore$Cons)($sp$Prelude$compare))((($core$SPCore$Cons)($sp$Prelude$debugTodo))((($core$SPCore$Cons)($sp$Prelude$debugLog))((($core$SPCore$Cons)($sp$Prelude$debugToHuman))((($core$SPCore$Cons)($sp$Prelude$debugBenchStart))((($core$SPCore$Cons)($sp$Prelude$debugBenchStop))($core$SPCore$Nil))))));

const $sp$Types$CanonicalAst$typeTyvars = (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return (($corelib$Dict$singleton)($name))($pos);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return (($corelib$Dict$join)(($sp$Types$CanonicalAst$typeTyvars)($from)))(($sp$Types$CanonicalAst$typeTyvars)($to));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ref = ($$try)[2];
    const $args = ($$try)[3];
    return ((($corelib$List$foldl)((($a) => ($corelib$Dict$join)(($sp$Types$CanonicalAst$typeTyvars)($a)))))($args))($corelib$Dict$empty);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return ($sp$Types$CanonicalAst$typeTyvars)($t);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    const $init = ((() => {
      const $$try = $extensible;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $corelib$Dict$empty;
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $name = ($$try)[1];
        return (($corelib$Dict$singleton)($name))($pos);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 305:16', (sp_toHuman)($$try));
    }))();
    return ((($corelib$Dict$foldl)((($n) => (($t) => ($corelib$Dict$join)(($sp$Types$CanonicalAst$typeTyvars)($t))))))($attrs))($init);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 289:4', (sp_toHuman)($$try));
}))());

const $sp$Types$CanonicalAst$getFreeTypeVars = (($nonFreeTyvars) => (($nonFn) => (($ty) => {
  const $posToTyvar = (($name) => (($pos) => ({
    nonFn: (($corelib$Dict$member)($name))($nonFn),
  })));
  return (($corelib$Dict$map)($posToTyvar))((($corelib$Dict$diff)(($sp$Types$CanonicalAst$typeTyvars)($ty)))($nonFreeTyvars));
})));

const $sp$Compiler$Pipeline$coreVariables = ((() => {
  const $insertUnop = (($unop) => {
    const $ref = ($sp$Types$CanonicalAst$RefRoot)(($sp$Types$Meta$spCoreUSR)($unop.symbol));
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: $corelib$Dict$empty,
      isMutable: false,
      ty: $unop.type,
    });
    return (($corelib$Dict$insert)($ref))($iv);
  });
  const $insertBinop = (($symbol) => (($binop) => {
    const $ref = ($sp$Types$CanonicalAst$RefRoot)(($sp$Types$Meta$spCoreUSR)($symbol));
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))(($corelib$Set$fromList)($binop.nonFn)))($binop.type),
      isMutable: false,
      ty: $binop.type,
    });
    return (($corelib$Dict$insert)($ref))($iv);
  }));
  const $insertCoreFunction = (($coreFn) => {
    const $ref = ($sp$Types$CanonicalAst$RefRoot)($coreFn.usr);
    const $iv = ({
      definedAt: $sp$Types$Pos$N,
      freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))(($corelib$Set$fromList)($coreFn.nonFn)))($coreFn.type),
      isMutable: false,
      ty: $coreFn.type,
    });
    return (($corelib$Dict$insert)($ref))($iv);
  });
  return ((($corelib$List$foldl)($insertCoreFunction))($sp$Prelude$functions))(((($corelib$Dict$foldl)($insertBinop))($sp$Prelude$binops))((($insertUnop)($sp$Prelude$unaryMinus))((($insertUnop)($sp$Prelude$unaryPlus))($corelib$Dict$empty))));
}))();

const $sp$Types$CanonicalAst$patternNamedTypes = (($p) => ((() => {
  const $$try = $p;
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Nothing" === (($$try)[2])[0]))) {
    const $pos = ($$try)[1];
    return $corelib$Dict$empty;
    return null;
  }
  if ((("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0]) && ("$corelib$Maybe$Just" === (($$try)[2])[0]))) {
    const $pos = ($$try)[1];
    const $n = (($$try)[2])[1];
    const $maybeType = ($$try)[3];
    return (($corelib$Dict$singleton)($n))(({
      first: $pos,
      second: $maybeType,
    }));
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $corelib$Dict$empty;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $corelib$Dict$empty;
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $path = ($$try)[2];
    const $ps = ($$try)[3];
    return ((($corelib$List$foldl)((($x) => ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNamedTypes)($x)))))($ps))($corelib$Dict$empty);
    return null;
  }
  if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ps = ($$try)[2];
    return ((($corelib$Dict$foldl)((($k) => (($v) => ($corelib$Dict$join)(($sp$Types$CanonicalAst$patternNamedTypes)($v))))))($ps))($corelib$Dict$empty);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 216:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$Pipeline$expandAndInsertModuleAnnotations = (($types) => (($module) => {
  const $insertName = (($def) => (($name) => ((maybeType$$) => {
    const $pos = maybeType$$.first;
    const $maybeType = maybeType$$.second;
    return (($d) => ((() => {
      const $$try = $maybeType;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ($corelib$Result$Ok)($d);
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $rawType = ($$try)[1];
        return (($corelib$Result$onOk)((($type) => {
          const $ref = ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($module.umr))($name));
          const $iv = ({
            definedAt: $pos,
            freeTypeVariables: ((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($def.nonFn))($type),
            isMutable: false,
            ty: $type,
          });
          return ($corelib$Result$Ok)(((($corelib$Dict$insert)($ref))($iv))($d));
        })))((($sp$Compiler$ExpandTypes$expandAnnotation)($types))($rawType));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/Pipeline.sp 54:8', (sp_toHuman)($$try));
    }))());
  })));
  const $insertValueDef = (($def) => (($corelib$Dict$foldlRes)(($insertName)($def)))(($sp$Types$CanonicalAst$patternNamedTypes)($def.pattern)));
  return (($corelib$Dict$foldlRes)((() => $insertValueDef)))($module.valueDefs);
}));

const $sp$Compiler$Pipeline$globalExpandedTypes = (($allModules) => (($corelib$Result$onOk)((($types) => {
  const $constructors = ((($corelib$Dict$foldl)((() => $sp$Compiler$Pipeline$insertUnionConstructors)))($types))($sp$Compiler$Pipeline$coreConstructors);
  return (($corelib$Result$onOk)((($instanceVariables) => ($corelib$Result$Ok)(({
    constructors: $constructors,
    instanceVariables: $instanceVariables,
    types: $types,
  })))))(((($corelib$Dict$foldlRes)((() => ($sp$Compiler$Pipeline$expandAndInsertModuleAnnotations)($types))))($allModules))($sp$Compiler$Pipeline$coreVariables));
})))(($sp$Compiler$ExpandTypes$expandAllTypes)(((($corelib$Dict$foldl)((() => $sp$Compiler$ExpandTypes$insertModuleTypes)))($allModules))($sp$Compiler$Pipeline$coreTypes))));

const $sp$Compiler$TestHelpers$listType = (($itemType) => ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("List")))((($core$SPCore$Cons)($itemType))($core$SPCore$Nil)));

const $sp$Compiler$TestHelpers$localType = (($name) => (($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))($name));

const $sp$Compiler$TestHelpers$noneType = ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Types$Meta$spCoreUSR)("None")))($core$SPCore$Nil);

const $sp$StateMonad$andThen = (($f) => (($m) => (($state0) => {
  const a$$ = ($m)($state0);
  const $state1 = a$$.second;
  const $a = a$$.first;
  return (($f)($a))($state1);
})));

const $sp$Compiler$TypeCheck$andThen = $sp$StateMonad$andThen;

const $sp$Compiler$TypeCheck$insertError = (($e) => (($state) => ({
  first: null,
  second: (Object.assign)({}, $state, ({
    errors: ((sp_cons)($state.errors))($e),
  })),
})));

const $sp$Compiler$TypeCheck$newName = (($f) => (($state) => ({
  first: ($f)((text_fromNumber)($state.nextName)),
  second: (Object.assign)({}, $state, ({
    nextName: ($state.nextName + 1),
  })),
})));

const $sp$Compiler$TypeCheck$newType = (($pos) => ($sp$Compiler$TypeCheck$newName)(($sp$Types$CanonicalAst$TypeVariable)($pos)));

const $sp$Compiler$TypeCheck$addErrorWithEEnv = (($pos) => (($messageConstructor) => (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$newType)($pos))))(($sp$Compiler$TypeCheck$insertError)((($sp$Compiler$Error$Simple)($pos))($messageConstructor)))));

const $sp$Compiler$TypeCheck$addError = (($pos) => (($message) => (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))((() => $message))));

const $sp$StateMonad$get = (($getter) => (($state) => ({
  first: ($getter)($state),
  second: $state,
})));

const $sp$Compiler$TypeCheck$get = $sp$StateMonad$get;

const $sp$Compiler$TypeCheck$replaceTypeVariables = (($subs) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ref = ($$try)[2];
    const $args = ($$try)[3];
    return ((($sp$Types$CanonicalAst$TypeConstant)($pos))($ref))((($corelib$List$map)(($sp$Compiler$TypeCheck$replaceTypeVariables)($subs)))($args));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $name = ($$try)[2];
    return ((() => {
      const $$try = (($corelib$Dict$get)($name))($subs);
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $substitutionType = ($$try)[1];
        return $substitutionType;
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return $ty;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1663:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return (((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($from)))($fromIsMutable))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($to));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return ((($sp$Types$CanonicalAst$TypeAlias)($pos))($path))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($t));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    return ((() => {
      const $$try = (($corelib$Maybe$andThen)((($name) => (($corelib$Dict$get)($name))($subs))))($extensible);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($extensible))((($corelib$Dict$map)((($name) => ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))))($attrs));
      }
      if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Types$CanonicalAst$TypeVariable" === (($$try)[1])[0]))) {
        const $p = (($$try)[1])[1];
        const $n = (($$try)[1])[2];
        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($n)))((($corelib$Dict$map)((($name) => ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))))($attrs));
        return null;
      }
      if ((("$corelib$Maybe$Just" === ($$try)[0]) && ("$sp$Types$CanonicalAst$TypeRecord" === (($$try)[1])[0]))) {
        const $ext2 = (($$try)[1])[2];
        const $attrs2 = (($$try)[1])[3];
        return ((($sp$Types$CanonicalAst$TypeRecord)($pos))($ext2))((($corelib$Dict$map)((($name) => ($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))))((($corelib$Dict$join)($attrs2))($attrs)));
        return null;
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $what = ($$try)[1];
        return ((sp_todo)("replacing record extension with non-var"))((sp_toHuman)($what));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1682:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1658:4', (sp_toHuman)($$try));
}))()));

const $sp$StateMonad$return = (($a) => (($state) => ({
  first: $a,
  second: $state,
})));

const $sp$Compiler$TypeCheck$return = $sp$StateMonad$return;

const $sp$Compiler$TypeCheck$applySubsToType = (($ty) => (($sp$Compiler$TypeCheck$andThen)((($subs) => ($sp$Compiler$TypeCheck$return)((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($ty)))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))));

const $sp$Compiler$TypeCheck$errorTodo = (($pos) => (($message) => (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)($message))($core$SPCore$Nil))));

const $sp$Compiler$TypeCheck$typeContainsFunctions = (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $args = ($$try)[3];
    return (($corelib$List$any)($sp$Compiler$TypeCheck$typeContainsFunctions))($args);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    return false;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return true;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return ($sp$Compiler$TypeCheck$typeContainsFunctions)($t);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    return (($corelib$List$any)($sp$Compiler$TypeCheck$typeContainsFunctions))(($corelib$Dict$values)($attrs));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1436:4', (sp_toHuman)($$try));
}))());

const $sp$Human$CanonicalAst$parensIf = (($test) => (($s) => ($test
  ? ("(" + ($s + ")"))
  : $s)));

const $sp$Human$CanonicalAst$usrToText = (($currentUmr) => (($meta) => (($usr) => {
  const moduleUmr$$ = $usr;
  const $name = (moduleUmr$$)[2];
  const $moduleUmr = (moduleUmr$$)[1];
  return (((sp_equal)($moduleUmr))($currentUmr)
    ? $name
    : ((() => {
      const $maybeGlobal = (($corelib$List$find)(((k$$) => {
        const $k = k$$.first;
        const $v = k$$.second;
        return ((sp_equal)($usr))($v);
      })))(($corelib$Dict$toList)($meta.globalTypes));
      return ((() => {
        const $$try = $maybeGlobal;
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $k = ($$try)[1].first;
          const $v = ($$try)[1].second;
          return $k;
          return null;
        }
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return ((() => {
            const $$try = (($corelib$Dict$get)($moduleUmr))($meta.umrToModuleVisibleAs);
            if (("$corelib$Maybe$Just" === ($$try)[0])) {
              const $moduleAlias = ($$try)[1];
              return ($moduleAlias + ("." + $name));
              return null;
            }
            if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
              const modulePath$$ = $moduleUmr;
              const $modulePath = (modulePath$$)[2];
              const $souece = (modulePath$$)[1];
              return ($modulePath + ("." + $name));
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 52:16', (sp_toHuman)($$try));
          }))();
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 47:8', (sp_toHuman)($$try));
      }))();
    }))());
})));

const $sp$Human$CanonicalAst$typeToPriorityAndText = (($currentUmr) => (($meta) => (($type) => {
  const $parensIfGreaterThan = (($threshold) => (($ty) => {
    const pri$$ = ((($sp$Human$CanonicalAst$typeToPriorityAndText)($currentUmr))($meta))($ty);
    const $str = pri$$.second;
    const $pri = pri$$.first;
    return (($sp$Human$CanonicalAst$parensIf)(($pri > $threshold)))($str);
  }));
  return ((() => {
    const $$try = $type;
    if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $usr = ($$try)[2];
      const $args = ($$try)[3];
      return ({
        first: (((sp_equal)($core$SPCore$Nil))($args)
          ? 0
          : 1),
        second: (($corelib$Text$join)(" "))(((sp_cons)((($corelib$List$map)(($parensIfGreaterThan)(0)))($args)))(((($sp$Human$CanonicalAst$usrToText)($currentUmr))($meta))($usr))),
      });
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $name = ($$try)[2];
      return ({
        first: 0,
        second: $name,
      });
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $from = ($$try)[2];
      const $fromIsMut = ($$try)[3];
      const $to = ($$try)[4];
      const $arrow = ($fromIsMut
        ? " @: "
        : ": ");
      return ({
        first: 2,
        second: (($corelib$Text$join)(""))((($core$SPCore$Cons)((($parensIfGreaterThan)(1))($from)))((($core$SPCore$Cons)($arrow))((($core$SPCore$Cons)((($parensIfGreaterThan)(2))($to)))($core$SPCore$Nil)))),
      });
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $extend = ($$try)[2];
      const $attrs = ($$try)[3];
      const $attrsString = (($corelib$Text$join)(", "))((($corelib$List$map)(((name$$) => {
        const $name = name$$.first;
        const $ty = name$$.second;
        return ($name + (" as " + ((($sp$Human$CanonicalAst$typeToText)($currentUmr))($meta))($ty)));
      })))(((list_sortBy)($corelib$Tuple$first))(($corelib$Dict$toList)($attrs))));
      const $l = (($core$SPCore$Cons)("{"))((($core$SPCore$Cons)(((() => {
        const $$try = $extend;
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return "";
        }
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $n = ($$try)[1];
          return ($n + " with");
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 109:16', (sp_toHuman)($$try));
      }))()))((($core$SPCore$Cons)($attrsString))((($core$SPCore$Cons)("}"))($core$SPCore$Nil))));
      return ({
        first: 0,
        second: (($corelib$Text$join)(" "))($l),
      });
      return null;
    }
    if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $usr = ($$try)[2];
      const $ty2 = ($$try)[3];
      return ({
        first: 0,
        second: ((($sp$Human$CanonicalAst$usrToText)($currentUmr))($meta))($usr),
      });
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 83:4', (sp_toHuman)($$try));
  }))();
})));

const $sp$Human$CanonicalAst$typeToText = (($currentUmr) => (($meta) => (($t) => ($corelib$Tuple$second)(((($sp$Human$CanonicalAst$typeToPriorityAndText)($currentUmr))($meta))($t)))));

const $sp$Compiler$TypeCheck$typeToText = (($env) => (($sp$Human$CanonicalAst$typeToText)($env.currentModule))($env.meta));

const $sp$Compiler$TypeCheck$checkNonFunction = (($env) => (($name) => (($ty) => {
  const $nope = ({
    freeVarsToFlag: $core$SPCore$Nil,
  });
  return (($sp$Compiler$TypeCheck$andThen)((($nonFnTyvars) => ((() => {
    const $$try = (($corelib$Dict$get)($name))($nonFnTyvars);
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return ($sp$Compiler$TypeCheck$return)($nope);
    }
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $rejectReasons = ($$try)[1];
      return (($sp$Compiler$TypeCheck$typeContainsFunctions)($ty)
        ? (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)($nope))))((($sp$Compiler$TypeCheck$errorTodo)(($sp$Types$Pos$I)(26)))(("type `" + ($name + ("` should not contain functions, but is " + (($sp$Compiler$TypeCheck$typeToText)($env))($ty))))))
        : ($sp$Compiler$TypeCheck$return)($nope));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1400:4', (sp_toHuman)($$try));
  }))())))(($sp$Compiler$TypeCheck$get)((($x) => $x.nonFnTyvars)));
})));

const $sp$Compiler$TypeCheck$flagFreeVars = (($names) => ($sp$Compiler$TypeCheck$return)(null));

const $sp$Compiler$TypeCheck$isAnnotation = (($n) => ((sp_equal)($corelib$Maybe$Nothing))((text_toNumber)($n)));

const $sp$Compiler$TypeCheck$typeHasTyvar = (($n) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return ((sp_equal)($name))($n);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $from = ($$try)[2];
    const $fromIsMutable = ($$try)[3];
    const $to = ($$try)[4];
    return ((($sp$Compiler$TypeCheck$typeHasTyvar)($n))($from) || (($sp$Compiler$TypeCheck$typeHasTyvar)($n))($to));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ref = ($$try)[2];
    const $args = ($$try)[3];
    return (($corelib$List$any)(($sp$Compiler$TypeCheck$typeHasTyvar)($n)))($args);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return (($sp$Compiler$TypeCheck$typeHasTyvar)($n))($t);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $extensible = ($$try)[2];
    const $attrs = ($$try)[3];
    return (((sp_equal)($extensible))(($corelib$Maybe$Just)($n)) || (($corelib$List$any)(($sp$Compiler$TypeCheck$typeHasTyvar)($n)))(($corelib$Dict$values)($attrs)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1457:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$TypeCheck$typeIsTyvar = (($name) => (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $n = ($$try)[2];
    return ((sp_equal)($name))($n);
    return null;
  }
  if (true) {
    return false;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1385:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$TypeCheck$insertTypeClash = (($id) => (($t1) => (($t2) => (($err) => (($state) => ((() => {
  const $$try = $state.typeClashesByPlaceholderId;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ((($x) => (sp_todo)(("Inserting type clash outside of unify" + $x))))((sp_toHuman)(({
      err: $err,
      id: $id,
      t1: $t1,
      t2: $t2,
    })));
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $dict = ($$try)[1];
    const $x = ($corelib$Maybe$Just)(((($corelib$Dict$insert)($id))(({
      err: $err,
      t1: $t1,
      t2: $t2,
    })))($dict));
    return ({
      first: null,
      second: (Object.assign)({}, $state, ({
        typeClashesByPlaceholderId: $x,
      })),
    });
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 291:4', (sp_toHuman)($$try));
}))())))));

const $sp$Compiler$TypeCheck$unifyError = (($pos) => (($error) => (($t1) => (($t2) => (($sp$Compiler$TypeCheck$andThen)((($name) => (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))))((((($sp$Compiler$TypeCheck$insertTypeClash)($name))($t1))($t2))($error)))))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity))))));

const $sp$StateMonad$list_foldl = (($f) => (($items) => (($accum) => ((() => {
  const $$try = $items;
  if (("$core$SPCore$Nil" === ($$try)[0])) {
    return ($sp$StateMonad$return)($accum);
  }
  if (("$core$SPCore$Cons" === ($$try)[0])) {
    const $head = ($$try)[1];
    const $tail = ($$try)[2];
    return (($sp$StateMonad$andThen)((($sp$StateMonad$list_foldl)($f))($tail)))((($f)($head))($accum));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/StateMonad.sp 81:4', (sp_toHuman)($$try));
}))())));

const $sp$StateMonad$list_map2 = (($f) => (($la) => (($lb) => {
  const $apply = ((a$$) => {
    const $a = a$$.first;
    const $b = a$$.second;
    return (($accum) => (($sp$StateMonad$andThen)((($c) => ($sp$StateMonad$return)(((sp_cons)($accum))($c)))))((($f)($a))($b)));
  });
  return (($sp$StateMonad$andThen)((($x) => ($sp$StateMonad$return)(($corelib$List$reverse)($x)))))(((($sp$StateMonad$list_foldl)($apply))(((($corelib$List$map2)($corelib$Tuple$pair))($la))($lb)))($core$SPCore$Nil));
})));

const $sp$Compiler$TypeCheck$list_map2 = $sp$StateMonad$list_map2;

const $sp$StateMonad$dict_foldl = (($f) => (($x) => (($sp$StateMonad$list_foldl)(((k$$) => {
  const $k = k$$.first;
  const $v = k$$.second;
  return (($f)($k))($v);
})))(($corelib$Dict$toList)($x))));

const $sp$StateMonad$dict_map = (($f) => (($dict) => {
  const $insert = (($c) => (($a) => (($d) => (($sp$StateMonad$andThen)((($b) => ($sp$StateMonad$return)(((($corelib$Dict$insert)($c))($b))($d)))))((($f)($c))($a)))));
  return ((($sp$StateMonad$dict_foldl)($insert))($dict))($corelib$Dict$empty);
}));

const $sp$Compiler$TypeCheck$dict_map = $sp$StateMonad$dict_map;

const $sp$Compiler$TypeCheck$unifyToNonExtensibleRecord = (($env) => (($pos) => (($reason) => (($aName) => (($aOnly) => (($bOnly) => (($bothUnified) => (((sp_not_equal)($corelib$Dict$empty))($aOnly)
  ? (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("record is missing attrs: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($aOnly)))))((($core$SPCore$Cons)((sp_toHuman)($reason)))($core$SPCore$Nil)))
  : (($sp$Compiler$TypeCheck$andThen)((($ext) => (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))((($corelib$Dict$join)($bothUnified))($bOnly))))))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("ne"))($pos))($reason))($aName))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(5)))($ext))($bOnly))))))(($sp$Compiler$TypeCheck$newName)($corelib$Maybe$Just))))))))));

const $sp$Compiler$TypeCheck$unifyRecords = (($env) => (($reason) => (($pos) => ((a_attrs$$) => {
  const $a_ext = a_attrs$$.first;
  const $a_attrs = a_attrs$$.second;
  return ((b_attrs$$) => {
    const $b_ext = b_attrs$$.first;
    const $b_attrs = b_attrs$$.second;
    const $init = ({
      aOnly: $corelib$Dict$empty,
      bOnly: $corelib$Dict$empty,
      both: $corelib$Dict$empty,
    });
    const $onA = (($name) => (($type_) => (($state) => (Object.assign)({}, $state, ({
      aOnly: ((($corelib$Dict$insert)($name))($type_))($state.aOnly),
    })))));
    const $onB = (($name) => (($type_) => (($state) => (Object.assign)({}, $state, ({
      bOnly: ((($corelib$Dict$insert)($name))($type_))($state.bOnly),
    })))));
    const $onBoth = (($name) => (($aType) => (($bType) => (($state) => (Object.assign)({}, $state, ({
      both: ((($corelib$Dict$insert)($name))(({
        first: $aType,
        second: $bType,
      })))($state.both),
    }))))));
    const aOnly$$ = (((((($corelib$Dict$merge)($onA))($onBoth))($onB))($a_attrs))($b_attrs))($init);
    const $both = aOnly$$.both;
    const $bOnly = aOnly$$.bOnly;
    const $aOnly = aOnly$$.aOnly;
    return (($sp$Compiler$TypeCheck$andThen)((($bothUnified) => ((() => {
      const $$try = ({
        first: $a_ext,
        second: $b_ext,
      });
      if ((("$corelib$Maybe$Just" === ($$try.first)[0]) && ("$corelib$Maybe$Nothing" === ($$try.second)[0]))) {
        const $aName = ($$try.first)[1];
        return ((((((($sp$Compiler$TypeCheck$unifyToNonExtensibleRecord)($env))($pos))($reason))($aName))($aOnly))($bOnly))($bothUnified);
        return null;
      }
      if ((("$corelib$Maybe$Nothing" === ($$try.first)[0]) && ("$corelib$Maybe$Just" === ($$try.second)[0]))) {
        const $bName = ($$try.second)[1];
        return ((((((($sp$Compiler$TypeCheck$unifyToNonExtensibleRecord)($env))($pos))($reason))($bName))($bOnly))($aOnly))($bothUnified);
        return null;
      }
      if ((("$corelib$Maybe$Nothing" === ($$try.first)[0]) && ("$corelib$Maybe$Nothing" === ($$try.second)[0]))) {
        return ((((sp_equal)($corelib$Dict$empty))($bOnly) && ((sp_equal)($corelib$Dict$empty))($aOnly))
          ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(4)))($corelib$Maybe$Nothing))($bothUnified))
          : ((() => {
            const $e = ($sp$Compiler$TypeCheck$IncompatibleRecords)(({
              aOnly: ($corelib$Dict$keys)($aOnly),
              bOnly: ($corelib$Dict$keys)($bOnly),
              bothUnified: ($corelib$Dict$keys)($bothUnified),
            }));
            return (((($sp$Compiler$TypeCheck$unifyError)($pos))($e))(((($sp$Types$CanonicalAst$TypeRecord)($pos))($a_ext))($a_attrs)))(((($sp$Types$CanonicalAst$TypeRecord)($pos))($b_ext))($b_attrs));
          }))());
      }
      if ((("$corelib$Maybe$Just" === ($$try.first)[0]) && ("$corelib$Maybe$Just" === ($$try.second)[0]))) {
        const $aName = ($$try.first)[1];
        const $bName = ($$try.second)[1];
        return ((((sp_equal)($bName))($aName) && (((sp_equal)($corelib$Dict$empty))($aOnly) && ((sp_equal)($corelib$Dict$empty))($bOnly)))
          ? ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($aName)))($bothUnified))
          : (($sp$Compiler$TypeCheck$andThen)((($new) => {
            const $sub = ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($new)))((($corelib$Dict$join)($bOnly))($a_attrs));
            return (($sp$Compiler$TypeCheck$andThen)((() => (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)($sub))))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("jj2"))($pos))($reason))($bName))($sub)))))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("jj1"))($pos))($reason))($aName))($sub));
          })))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity)));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1251:4', (sp_toHuman)($$try));
    }))())))((($sp$Compiler$TypeCheck$dict_map)((($k) => ((a$$) => {
      const $a = a$$.first;
      const $b = a$$.second;
      return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a))($b);
    }))))($both));
  });
}))));

const $sp$Compiler$TypeCheck$unify_ = (($env) => (($reason) => (($pos1) => (($t1) => (($t2) => ((() => {
  const $$try = ({
    first: $t1,
    second: $t2,
  });
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try.first)[0])) {
    const $pos = ($$try.first)[1];
    const $aliased = ($$try.first)[3];
    return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($aliased))($t2);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try.second)[0])) {
    const $aliased = ($$try.second)[3];
    return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos1))($t1))($aliased);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$TypeConstant" === ($$try.first)[0]) && ("$sp$Types$CanonicalAst$TypeConstant" === ($$try.second)[0]))) {
    const $pos = ($$try.first)[1];
    const $ref1 = ($$try.first)[2];
    const $args1 = ($$try.first)[3];
    const $ref2 = ($$try.second)[2];
    const $args2 = ($$try.second)[3];
    return (((sp_not_equal)($ref2))($ref1)
      ? (((($sp$Compiler$TypeCheck$unifyError)($pos1))($sp$Compiler$TypeCheck$IncompatibleTypes))($t1))($t2)
      : ((() => {
        const $fold = (($arg1) => (($arg2) => ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($arg1))($arg2)));
        return (($sp$Compiler$TypeCheck$andThen)((($argTypes) => (($sp$Compiler$TypeCheck$andThen)((($subs) => ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($ref1))((($corelib$List$map)(($sp$Compiler$TypeCheck$replaceTypeVariables)($subs)))($argTypes))))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(((($sp$Compiler$TypeCheck$list_map2)(((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos)))($args1))($args2));
      }))());
    return null;
  }
  if ((("$sp$Types$CanonicalAst$TypeVariable" === ($$try.first)[0]) && ("$sp$Types$CanonicalAst$TypeVariable" === ($$try.second)[0]))) {
    const $pos = ($$try.first)[1];
    const $v1_name = ($$try.first)[2];
    const $v2_name = ($$try.second)[2];
    return (((sp_equal)($v2_name))($v1_name)
      ? ($sp$Compiler$TypeCheck$return)($t1)
      : (($sp$Compiler$TypeCheck$andThen)((($subs) => ((() => {
        const $$try = ({
          first: (($corelib$Dict$get)($v1_name))($subs),
          second: (($corelib$Dict$get)($v2_name))($subs),
        });
        if ((("$corelib$Maybe$Just" === ($$try.first)[0]) && ("$corelib$Maybe$Just" === ($$try.second)[0]))) {
          const $sub1 = ($$try.first)[1];
          const $sub2 = ($$try.second)[1];
          return (($sp$Compiler$TypeCheck$andThen)((($v) => (($sp$Compiler$TypeCheck$andThen)((() => (($sp$Compiler$TypeCheck$andThen)((($subbedTy) => ($sp$Compiler$TypeCheck$return)($subbedTy))))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv2"))($pos))($reason))($v2_name))($v)))))((((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv1"))($pos))($reason))($v1_name))($v)))))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos1))($sub1))($sub2));
          return null;
        }
        if ((("$corelib$Maybe$Nothing" === ($$try.first)[0]) && ("$corelib$Maybe$Just" === ($$try.second)[0]))) {
          const $sub2 = ($$try.second)[1];
          return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv3"))($pos))($reason))($v1_name))($t2);
          return null;
        }
        if (true) {
          return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vv4"))($pos))($reason))($v2_name))($t1);
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1173:16', (sp_toHuman)($$try));
      }))())))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try.first)[0])) {
    const $pos = ($$try.first)[1];
    const $name1 = ($$try.first)[2];
    return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vl"))($pos))($reason))($name1))($t2);
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try.second)[0])) {
    const $pos = ($$try.second)[1];
    const $name2 = ($$try.second)[2];
    return (((((($sp$Compiler$TypeCheck$addSubstitution)($env))("vr"))($pos))($reason))($name2))($t1);
    return null;
  }
  if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try.first)[0]) && ("$sp$Types$CanonicalAst$TypeFunction" === ($$try.second)[0]))) {
    const $pos = ($$try.first)[1];
    const $a_from = ($$try.first)[2];
    const $a_fromIsMutable = ($$try.first)[3];
    const $a_to = ($$try.first)[4];
    const $b_from = ($$try.second)[2];
    const $b_fromIsMutable = ($$try.second)[3];
    const $b_to = ($$try.second)[4];
    return (((sp_not_equal)($b_fromIsMutable))($a_fromIsMutable)
      ? (((($sp$Compiler$TypeCheck$unifyError)($pos))($sp$Compiler$TypeCheck$IncompatibleMutability))($t1))($t2)
      : (($sp$Compiler$TypeCheck$andThen)((($unified_from) => (($sp$Compiler$TypeCheck$andThen)((($subs_) => (($sp$Compiler$TypeCheck$andThen)((($unified_to) => (($sp$Compiler$TypeCheck$andThen)((($subs) => ($sp$Compiler$TypeCheck$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($unified_from)))($a_fromIsMutable))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs))($unified_to))))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs_))($a_to)))((($sp$Compiler$TypeCheck$replaceTypeVariables)($subs_))($b_to))))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a_from))($b_from)));
    return null;
  }
  if ((("$sp$Types$CanonicalAst$TypeRecord" === ($$try.first)[0]) && ("$sp$Types$CanonicalAst$TypeRecord" === ($$try.second)[0]))) {
    const $a_ext = ($$try.first)[2];
    const $a_attrs = ($$try.first)[3];
    const $b_ext = ($$try.second)[2];
    const $b_attrs = ($$try.second)[3];
    return ((((($sp$Compiler$TypeCheck$unifyRecords)($env))($reason))($pos1))(({
      first: $a_ext,
      second: $a_attrs,
    })))(({
      first: $b_ext,
      second: $b_attrs,
    }));
    return null;
  }
  if (true) {
    return (((($sp$Compiler$TypeCheck$unifyError)($pos1))($sp$Compiler$TypeCheck$IncompatibleTypes))($t1))($t2);
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1142:4', (sp_toHuman)($$try));
}))())))));

const $sp$Compiler$TypeCheck$addSubstitution = (($env) => (($debugCode) => (($pos) => (($reason) => (($name) => (($rawTy) => (($sp$Compiler$TypeCheck$andThen)((($ty) => (($sp$Compiler$TypeCheck$isAnnotation)($name)
  ? ((() => {
    const $$try = $ty;
    if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
      const $subName = ($$try)[2];
      return (((sp_equal)($name))($subName)
        ? ($sp$Compiler$TypeCheck$return)($ty)
        : (($sp$Compiler$TypeCheck$isAnnotation)($subName)
          ? (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$SubstitutingAnnotation)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty)
          : (((((($sp$Compiler$TypeCheck$addSubstitution)($env))(($debugCode + " SWITCH")))($pos))($reason))($subName))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name))));
      return null;
    }
    if (true) {
      return (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$SubstitutingAnnotation)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1331:8', (sp_toHuman)($$try));
  }))()
  : ((($sp$Compiler$TypeCheck$typeHasTyvar)($name))($ty)
    ? ((($sp$Compiler$TypeCheck$typeIsTyvar)($name))($ty)
      ? ($sp$Compiler$TypeCheck$return)($ty)
      : (((($sp$Compiler$TypeCheck$unifyError)($pos))(($sp$Compiler$TypeCheck$Cycle)($name)))((($sp$Types$CanonicalAst$TypeVariable)($pos))($name)))($ty))
    : (($sp$Compiler$TypeCheck$andThen)((($nonFunction) => {
      const freeVarsToFlag$$ = $nonFunction;
      const $freeVarsToFlag = freeVarsToFlag$$.freeVarsToFlag;
      return (($sp$Compiler$TypeCheck$andThen)((() => (($sp$Compiler$TypeCheck$andThen)((($subs) => ((() => {
        const $$try = (($corelib$Dict$get)($name))($subs);
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $sub = ($$try)[1];
          return ((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($ty))($sub);
          return null;
        }
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return (($state) => ({
            first: $ty,
            second: (Object.assign)({}, $state, ({
              substitutions: ((($corelib$Dict$insert)($name))($ty))((($corelib$Dict$map)((($k) => ($sp$Compiler$TypeCheck$replaceTypeVariables)((($corelib$Dict$singleton)($name))($ty)))))($state.substitutions)),
            })),
          }));
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1363:8', (sp_toHuman)($$try));
      }))())))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(($sp$Compiler$TypeCheck$flagFreeVars)($freeVarsToFlag));
    })))(((($sp$Compiler$TypeCheck$checkNonFunction)($env))($name))($ty)))))))(($sp$Compiler$TypeCheck$applySubsToType)($rawTy))))))));

const $sp$Compiler$TypeCheck$list_foldl = $sp$StateMonad$list_foldl;

const $sp$Compiler$TypeCheck$unifyErrorToText = (($ue) => ((() => {
  const $$try = $ue;
  if (("$sp$Compiler$TypeCheck$IncompatibleTypes" === ($$try)[0])) {
    return "The two types are incompatible.";
  }
  if (("$sp$Compiler$TypeCheck$IncompatibleMutability" === ($$try)[0])) {
    return "The mutability does not match.";
  }
  if (("$sp$Compiler$TypeCheck$IncompatibleRecords" === ($$try)[0])) {
    const $args = ($$try)[1];
    return ("The record types are not compatible" + (sp_toHuman)($args));
    return null;
  }
  if (("$sp$Compiler$TypeCheck$Cycle" === ($$try)[0])) {
    const $name = ($$try)[1];
    return ("There is a cyclic dependency on " + $name);
    return null;
  }
  if (("$sp$Compiler$TypeCheck$NonFunctionContainsFunction" === ($$try)[0])) {
    const $rejectFunctions = ($$try)[1];
    return ("NonFunction can't contain functions: " + (sp_toHuman)($rejectFunctions));
    return null;
  }
  if (("$sp$Compiler$TypeCheck$OkThisIsActuallyPossible" === ($$try)[0])) {
    return "OkThisIsActuallyPossible?";
  }
  if (("$sp$Compiler$TypeCheck$NI" === ($$try)[0])) {
    const $str = ($$try)[1];
    return ("Not Implemented: " + $str);
    return null;
  }
  if (("$sp$Compiler$TypeCheck$SubstitutingAnnotation" === ($$try)[0])) {
    const $name = ($$try)[1];
    return ("SubstitutingAnnotation: " + $name);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1080:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$TypeCheck$clashToTexts = (($env) => (($params) => ((() => {
  const $$try = $params.unifiedType;
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $p = ($$try)[1];
    const $unifiedTypeName = ($$try)[2];
    return (($corelib$Text$join)("\n"))((($corelib$List$concatMap)(((clash$$) => {
      const $clashPlaceholderName = clash$$.first;
      const $clash = clash$$.second;
      return (($core$SPCore$Cons)($params.type1_is))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t1))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($params.type2_is))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t2))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck$unifyErrorToText)($clash.err)))($core$SPCore$Nil)))))))));
    })))(($corelib$Dict$toList)($params.clashes)));
    return null;
  }
  if (true) {
    const $info = (($core$SPCore$Cons)($params.typeSeemsToBe))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($params.unifiedType)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("However I can't reconcile the following:"))($core$SPCore$Nil))));
    const $clashToError = ((clash$$) => {
      const $name = clash$$.first;
      const $clash = clash$$.second;
      return (($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("* `" + ($name + "`"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + $params.type1_is)))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t1))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + $params.type2_is)))((($core$SPCore$Cons)(("  " + (($sp$Compiler$TypeCheck$typeToText)($env))($clash.t2))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("  " + ($sp$Compiler$TypeCheck$unifyErrorToText)($clash.err))))($core$SPCore$Nil))))))))));
    });
    const $clashErrors = (($corelib$List$concatMap)($clashToError))(($corelib$Dict$toList)($params.clashes));
    return (($corelib$Text$join)("\n"))(($corelib$List$concat)((($core$SPCore$Cons)($info))((($core$SPCore$Cons)($clashErrors))($core$SPCore$Nil))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1925:4', (sp_toHuman)($$try));
}))()));

const $sp$Types$CanonicalAst$expressionPos = (($e) => ((() => {
  const $$try = $e;
  if (("$sp$Types$CanonicalAst$LiteralText" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$Variable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$Constructor" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$Lambda" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$Record" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$Call" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$If" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  if (("$sp$Types$CanonicalAst$Try" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 246:4', (sp_toHuman)($$try));
}))());

const $sp$Types$Pos$range = (($a) => (($b) => ((() => {
  const $$try = ({
    first: $a,
    second: $b,
  });
  if ((("$sp$Types$Pos$P" === ($$try.first)[0]) && ("$sp$Types$Pos$P" === ($$try.second)[0]))) {
    const $ma = ($$try.first)[1];
    const $sa = ($$try.first)[2];
    const $ea = ($$try.first)[3];
    const $mb = ($$try.second)[1];
    const $sb = ($$try.second)[2];
    const $eb = ($$try.second)[3];
    return (((sp_not_equal)($mb))($ma)
      ? (sp_todo)("trying to range across two different modules")
      : ((($sp$Types$Pos$P)($ma))((($corelib$Basics$min)($sa))($sb)))((($corelib$Basics$max)($ea))($eb)));
    return null;
  }
  if (("$sp$Types$Pos$P" === ($$try.first)[0])) {
    return $a;
  }
  if (true) {
    return $b;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 41:4', (sp_toHuman)($$try));
}))()));

const $sp$Types$CanonicalAst$statementPos = (($stat) => ((() => {
  const $$try = $stat;
  if (("$sp$Types$CanonicalAst$Definition" === ($$try)[0])) {
    const $def = ($$try)[1];
    return ((() => {
      const $$try = ($corelib$List$reverse)($def.body);
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return ($sp$Types$CanonicalAst$patternPos)($def.pattern);
      }
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $last = ($$try)[1];
        return (($sp$Types$Pos$range)(($sp$Types$CanonicalAst$patternPos)($def.pattern)))(($sp$Types$CanonicalAst$statementPos)($last));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 229:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$Evaluation" === ($$try)[0])) {
    const $expr = ($$try)[1];
    return ($sp$Types$CanonicalAst$expressionPos)($expr);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 227:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$TypeCheck$errorIncompatibleTypes = (($env) => (($reason) => (($pos_whatever) => (($unifiedType) => (($clashes) => ((() => {
  const $$try = $reason;
  if (("$sp$Compiler$TypeCheck$UnifyReason_CallArgument" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $makeError = (($eenv) => {
      const block$$ = (($sp$Compiler$Error$posToHuman)($eenv))($pos.reference);
      const $location = block$$.location;
      const $block = block$$.block;
      return (($core$SPCore$Cons)("This expression cannot be used as argument to this function:"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($block))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("the argument type seems to be: "))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
        clashes: $clashes,
        type1_is: "The functon expects:",
        type2_is: "But the actual argument is:",
        typeSeemsToBe: "The argument type seems to be",
        unifiedType: $unifiedType,
      }))))($core$SPCore$Nil))))));
    });
    return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos.argument))($makeError);
    return null;
  }
  if (("$sp$Compiler$TypeCheck$UnifyReason_TryBlock" === ($$try)[0])) {
    const $block = ($$try)[1];
    const $pos = ((() => {
      const $$try = (($corelib$List$map)($sp$Types$CanonicalAst$statementPos))($block);
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return $pos_whatever;
      }
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $h = ($$try)[1];
        const $t = ($$try)[2];
        return ((($corelib$List$foldl)($sp$Types$Pos$range))($t))($h);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1798:16', (sp_toHuman)($$try));
    }))();
    const $makeError = (($eenv) => (($core$SPCore$Cons)("This try..as block produces a different type than the blocks preceding it."))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
      clashes: $clashes,
      type1_is: "The previous block(s) produce:",
      type2_is: "But this block produces:",
      typeSeemsToBe: "The block type seems to be",
      unifiedType: $unifiedType,
    }))))($core$SPCore$Nil))));
    return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))($makeError);
    return null;
  }
  if (("$sp$Compiler$TypeCheck$UnifyReason_AnnotationVsBlock" === ($$try)[0])) {
    const $pattern = ($$try)[1];
    const $annotation = ($$try)[2];
    const $body = ($$try)[3];
    const $headerPos = ($sp$Types$CanonicalAst$patternPos)($pattern);
    const $lastStatementPos = ((() => {
      const $$try = ($corelib$List$reverse)($body);
      if (("$core$SPCore$Nil" === ($$try)[0])) {
        return $pos_whatever;
      }
      if (("$core$SPCore$Cons" === ($$try)[0])) {
        const $last = ($$try)[1];
        const $t = ($$try)[2];
        return ($sp$Types$CanonicalAst$statementPos)($last);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1824:16', (sp_toHuman)($$try));
    }))();
    const $name = (($corelib$Text$join)(", "))(($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNames)($pattern)));
    const $makeError = (($eenv) => {
      const block$$ = (($sp$Compiler$Error$posToHuman)($eenv))($headerPos);
      const $location = block$$.location;
      const $block = block$$.block;
      return (($core$SPCore$Cons)(("The definition of " + ($name + " does not match the annotation:"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)($block))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
        clashes: $clashes,
        type1_is: "The annotation says:",
        type2_is: "But this definition produces:",
        typeSeemsToBe: "The produced type seems to be",
        unifiedType: $unifiedType,
      }))))($core$SPCore$Nil)))));
    });
    return (($sp$Compiler$TypeCheck$addErrorWithEEnv)($lastStatementPos))($makeError);
    return null;
  }
  if (("$sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $referenceType = ($$try)[2];
    return (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("This expression is being called as if it was a function, but its type is:"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil))));
    return null;
  }
  if (true) {
    const $pos = $pos_whatever;
    const $title = ((() => {
      const $$try = $reason;
      if (("$sp$Compiler$TypeCheck$UnifyReason_AnnotationVsPattern" === ($$try)[0])) {
        return "The pattern unpacking is not compatible with the annotation";
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern" === ($$try)[0])) {
        return "The definition block cannot be unpacked into the pattern";
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_IfCondition" === ($$try)[0])) {
        return "The expression inside `if ... :` should always be a Bool";
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_IfBranches" === ($$try)[0])) {
        return "The branches of an `if` should produce the same type of value";
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_TryPattern" === ($$try)[0])) {
        return "try..as patterns should have the same type";
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument" === ($$try)[0])) {
        const $p = ($$try)[1];
        return ("Argument " + ((text_fromNumber)($p.argIndex) + (" to type constructor " + ((sp_toHuman)($p.usr) + " does not match the constructor definition"))));
        return null;
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_AttributeAccess" === ($$try)[0])) {
        const $attrName = ($$try)[1];
        return ("You are trying to access the ." + ($attrName + " attribute"));
        return null;
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate" === ($$try)[0])) {
        const $attrNames = ($$try)[1];
        return ("You are trying to update the " + ((($corelib$Text$join)(", "))($attrNames) + " attributes"));
        return null;
      }
      if (("$sp$Compiler$TypeCheck$UnifyReason_Override" === ($$try)[0])) {
        return "this is addSubstitution running a UnifyReason_Override, I don't know what I'm doing";
      }
      if (true) {
        return (sp_todo)(((sp_toHuman)($reason) + " should not even get here"));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1869:16', (sp_toHuman)($$try));
    }))();
    return (($sp$Compiler$TypeCheck$addError)($pos_whatever))((($core$SPCore$Cons)($title))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("The type seems to be something like"))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$clashToTexts)($env))(({
      clashes: $clashes,
      type1_is: "t1 is:",
      type2_is: "but t2 is:",
      typeSeemsToBe: "type seems to be",
      unifiedType: $unifiedType,
    }))))($core$SPCore$Nil)))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1771:4', (sp_toHuman)($$try));
}))())))));

const $sp$StateMonad$update = (($f) => (($state) => {
  const $s = ($f)($state);
  return ({
    first: $s,
    second: $s,
  });
}));

const $sp$Compiler$TypeCheck$m_update = $sp$StateMonad$update;

const $sp$Compiler$TypeCheck$popClashingtypes = (($state) => ((() => {
  const $$try = $state.typeClashesByPlaceholderId;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return (sp_todo)("popping a nothing!");
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $dict = ($$try)[1];
    return ({
      first: $dict,
      second: (Object.assign)({}, $state, ({
        typeClashesByPlaceholderId: $corelib$Maybe$Nothing,
      })),
    });
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 313:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$TypeCheck$unify = (($env) => (($pos) => (($reason) => (($a) => (($b) => (($sp$Compiler$TypeCheck$andThen)((($tc) => (((sp_not_equal)($corelib$Maybe$Nothing))($tc)
  ? (sp_todo)("typeClashesByPlaceholderId NOT EMPTY!")
  : (($sp$Compiler$TypeCheck$andThen)((() => (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => (($sp$Compiler$TypeCheck$andThen)((($typeClashes) => (((sp_equal)($corelib$Dict$empty))($typeClashes)
    ? ($sp$Compiler$TypeCheck$return)($unifiedType)
    : (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)($unifiedType))))(((((($sp$Compiler$TypeCheck$errorIncompatibleTypes)($env))($reason))($pos))($unifiedType))($typeClashes))))))($sp$Compiler$TypeCheck$popClashingtypes))))(((((($sp$Compiler$TypeCheck$unify_)($env))($reason))($pos))($a))($b)))))(($sp$Compiler$TypeCheck$m_update)((($s) => (Object.assign)({}, $s, ({
    typeClashesByPlaceholderId: ($corelib$Maybe$Just)($corelib$Dict$empty),
  })))))))))(($sp$Compiler$TypeCheck$get)((($x) => $x.typeClashesByPlaceholderId))))))));

const $sp$Compiler$TypeCheck$applyAttributePath = (($env) => (($pos) => (($attrPath) => {
  const $wrap = (($attributeName) => (($ty) => {
    const $maybeAttrType = ((() => {
      const $$try = $ty;
      if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
        const $e = ($$try)[2];
        const $attrs = ($$try)[3];
        return (($corelib$Dict$get)($attributeName))($attrs);
        return null;
      }
      if (true) {
        return $corelib$Maybe$Nothing;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1481:12', (sp_toHuman)($$try));
    }))();
    return ((() => {
      const $$try = $maybeAttrType;
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $attrType = ($$try)[1];
        return ($sp$Compiler$TypeCheck$return)($attrType);
        return null;
      }
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($sp$Compiler$TypeCheck$andThen)((($extName) => (($sp$Compiler$TypeCheck$andThen)((($attrType) => {
          const $re = ((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)($extName)))((($corelib$Dict$singleton)($attributeName))($attrType));
          return (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)($attrType))))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_AttributeAccess)($attributeName)))($ty))($re));
        })))(($sp$Compiler$TypeCheck$newType)($pos)))))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1487:8', (sp_toHuman)($$try));
    }))();
  }));
  return (($sp$Compiler$TypeCheck$list_foldl)($wrap))($attrPath);
})));

const $sp$Compiler$TypeCheck$applySubsToNonFreeTyvars = (($env) => (($sp$Compiler$TypeCheck$andThen)((($subs) => {
  const $meh = (($typeVarName) => (($constrainedVars) => ((() => {
    const $$try = (($corelib$Dict$get)($typeVarName))($subs);
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return $constrainedVars;
    }
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $ty = ($$try)[1];
      return ((($corelib$Dict$foldl)((($n) => (($p) => (($corelib$Dict$insert)($n))($p)))))(($sp$Types$CanonicalAst$typeTyvars)($ty)))($constrainedVars);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1618:8', (sp_toHuman)($$try));
  }))()));
  return ($sp$Compiler$TypeCheck$return)((Object.assign)({}, $env, ({
    nonFreeTyvars: ((($corelib$List$foldl)($meh))(($corelib$Dict$keys)($env.nonFreeTyvars)))($env.nonFreeTyvars),
  })));
})))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))));

const $sp$Compiler$TypeCheck$checkFreeVariables = (($env) => (($pos) => (($patternType) => (($blockType) => {
  const $annotatedFreeVars = (($corelib$Dict$filter)((($name) => (() => ($sp$Compiler$TypeCheck$isAnnotation)($name)))))(($sp$Types$CanonicalAst$typeTyvars)($patternType));
  const $actualFreeVars = ($sp$Types$CanonicalAst$typeTyvars)($blockType);
  return ((($corelib$Dict$size)($annotatedFreeVars) > ($corelib$Dict$size)($actualFreeVars))
    ? (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)(null))))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("The annotation is too general"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("The annotation uses: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($annotatedFreeVars)))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("But the actual type uses only: " + (($corelib$Text$join)(", "))(($corelib$Dict$keys)($actualFreeVars)))))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($blockType)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("The annotation has " + ((text_fromNumber)((($corelib$Dict$size)($annotatedFreeVars) - ($corelib$Dict$size)($actualFreeVars))) + " type variables too many"))))($core$SPCore$Nil))))))))))
    : ($sp$Compiler$TypeCheck$return)(null));
}))));

const $sp$Compiler$TypeCheck$dict_foldl = $sp$StateMonad$dict_foldl;

const $sp$Compiler$TypeCheck$errorUndefinedVariable = (($env) => (($pos) => (($ref) => (($sp$Compiler$TypeCheck$addErrorWithEEnv)($pos))((($errorEnv) => {
  const $onLocal = (($name) => ((() => {
    const $$try = (($corelib$Dict$get)($name))($env.nonAnnotatedRecursives);
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $defPos = ($$try)[1];
      return (($core$SPCore$Cons)(("To use function `" + ($name + "` recursively, you need to add a type annotation to its definition."))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("This is a limit of the compiler, not sure when I'll have the time to fix it."))($core$SPCore$Nil)));
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return (($core$SPCore$Cons)(("Undefined value: " + $name)))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)(("I can't see a definition for `" + ($name + "` anywhere, so I don't know what it is."))))($core$SPCore$Nil)));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1733:8', (sp_toHuman)($$try));
  }))());
  return ((() => {
    const $$try = $ref;
    if (("$sp$Types$CanonicalAst$RefBlock" === ($$try)[0])) {
      const $name = ($$try)[1];
      return ($onLocal)($name);
      return null;
    }
    if ((("$sp$Types$CanonicalAst$RefRoot" === ($$try)[0]) && ("$sp$Types$Meta$USR" === (($$try)[1])[0]))) {
      const $umr = (($$try)[1])[1];
      const $name = (($$try)[1])[2];
      return (((sp_equal)($env.currentModule))($umr)
        ? ($onLocal)($name)
        : ((() => {
          const path$$ = $env.currentModule;
          const $path = (path$$)[2];
          const $source = (path$$)[1];
          return ((() => {
            const $$try = (($corelib$Dict$get)($path))($errorEnv.moduleByName);
            if (("$corelib$Maybe$Just" === ($$try)[0])) {
              const $mod = ($$try)[1];
              return (($core$SPCore$Cons)(("Module `" + ($path + ("` from source `" + ((sp_toHuman)($source) + ("` does not seem to expose a variable called `" + ($name + "`."))))))))($core$SPCore$Nil);
              return null;
            }
            if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
              return (($core$SPCore$Cons)(("The code references a `" + ($path + ("." + ($name + ("` with source `" + (sp_toHuman)($source))))))))((($core$SPCore$Cons)("However, I can't find any module with that path and source."))($core$SPCore$Nil));
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1757:16', (sp_toHuman)($$try));
          }))();
        }))());
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1746:4', (sp_toHuman)($$try));
  }))();
})))));

const $sp$Compiler$TypeCheck$setNonFn = (($name) => (($state) => ({
  first: null,
  second: (Object.assign)({}, $state, ({
    nonFnTyvars: ((($corelib$Dict$insert)($name))($core$SPCore$Nil))($state.nonFnTyvars),
  })),
})));

const $sp$Compiler$TypeCheck$generateNewTypeVariables = (($tyvarByName) => {
  const $apply = (($name0) => (($arg) => (($subs) => {
    const nonFn$$ = $arg;
    const $nonFn = nonFn$$.nonFn;
    return (($sp$Compiler$TypeCheck$andThen)((($name1) => (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$return)(((($corelib$Dict$insert)($name0))((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))($name1)))($subs)))))(($nonFn
      ? ($sp$Compiler$TypeCheck$setNonFn)($name1)
      : ($sp$Compiler$TypeCheck$return)(null))))))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
  })));
  return ((($sp$Compiler$TypeCheck$dict_foldl)($apply))($tyvarByName))($corelib$Dict$empty);
});

const $sp$Compiler$TypeCheck$replaceTypeVariablesWithNew = (($freeTypeVariables) => (($type) => (((sp_equal)($corelib$Dict$empty))($freeTypeVariables)
  ? ($sp$Compiler$TypeCheck$return)($type)
  : (($sp$Compiler$TypeCheck$andThen)((($newTypeByOldType) => ($sp$Compiler$TypeCheck$return)((($sp$Compiler$TypeCheck$replaceTypeVariables)($newTypeByOldType))($type)))))(($sp$Compiler$TypeCheck$generateNewTypeVariables)($freeTypeVariables)))));

const $sp$Compiler$TypeCheck$unifyConstructorWithItsArgs = (($p) => ((() => {
  const $$try = ({
    first: $p.ty,
    second: $p.args,
  });
  if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try.first)[0]) && ("$core$SPCore$Cons" === ($$try.second)[0]))) {
    const $from = ($$try.first)[2];
    const $to = ($$try.first)[4];
    const $head = ($$try.second)[1];
    const $tail = ($$try.second)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($pa) => {
      const pos$$ = $pa;
      const $vars = pos$$.vars;
      const $ty = pos$$.ty;
      const $pos = pos$$.pos;
      return (($sp$Compiler$TypeCheck$andThen)((($unifiedFrom) => ($sp$Compiler$TypeCheck$unifyConstructorWithItsArgs)((Object.assign)({}, $p, ({
        argIndex: ($p.argIndex + 1),
        args: $tail,
        ty: $to,
        vars: $vars,
      }))))))(((((($sp$Compiler$TypeCheck$unify)($p.env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_ConstructorArgument)($p)))($from))($ty));
    })))(((($sp$Compiler$TypeCheck$fromPattern)($p.env))($head))($p.vars));
    return null;
  }
  if ((("$sp$Types$CanonicalAst$TypeFunction" === ($$try.first)[0]) && ("$core$SPCore$Nil" === ($$try.second)[0]))) {
    const $from = ($$try.first)[2];
    const $to = ($$try.first)[4];
    return (($sp$Compiler$TypeCheck$andThen)((($ety) => ($sp$Compiler$TypeCheck$return)(({
      first: $p.vars,
      second: $ety,
    })))))((($sp$Compiler$TypeCheck$addError)($p.pos))((($core$SPCore$Cons)(("Type constructor " + ((sp_toHuman)($p.usr) + (" is missing argument #" + (text_fromNumber)($p.argIndex))))))($core$SPCore$Nil)));
    return null;
  }
  if (("$core$SPCore$Nil" === ($$try.second)[0])) {
    return (($sp$Compiler$TypeCheck$andThen)((($subs) => ($sp$Compiler$TypeCheck$return)(({
      first: $p.vars,
      second: $p.ty,
    })))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions)));
  }
  if (("$core$SPCore$Cons" === ($$try.second)[0])) {
    const $head = ($$try.second)[1];
    const $tail = ($$try.second)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($ety) => ($sp$Compiler$TypeCheck$return)(({
      first: $p.vars,
      second: $ety,
    })))))((($sp$Compiler$TypeCheck$addError)($p.pos))((($core$SPCore$Cons)(("Type constructor " + ((sp_toHuman)($p.usr) + " has too many args"))))($core$SPCore$Nil)));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1011:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$TypeCheck$fromPattern = (($env) => (($pattern) => (($vars_) => {
  const $vars = $vars_;
  return ((() => {
    const $$try = $pattern;
    if (("$sp$Types$CanonicalAst$PatternAny" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $maybeName = ($$try)[2];
      const $maybeAnnotation = ($$try)[3];
      const $makeType = ((() => {
        const $$try = $maybeAnnotation;
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return ($sp$Compiler$TypeCheck$newType)($pos);
        }
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $type = ($$try)[1];
          return ((() => {
            const $$try = (($sp$Compiler$ExpandTypes$expandAnnotation)($env.types))($type);
            if (("$corelib$Result$Err" === ($$try)[0])) {
              const $e = ($$try)[1];
              return (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$newType)($pos))))(($sp$Compiler$TypeCheck$insertError)($e));
              return null;
            }
            if (("$corelib$Result$Ok" === ($$try)[0])) {
              const $t = ($$try)[1];
              return ($sp$Compiler$TypeCheck$return)($t);
              return null;
            }
            (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 936:24', (sp_toHuman)($$try));
          }))();
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 931:16', (sp_toHuman)($$try));
      }))();
      return (($sp$Compiler$TypeCheck$andThen)((($type) => {
        const $newVars = ((() => {
          const $$try = $maybeName;
          if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
            return $vars;
          }
          if (("$corelib$Maybe$Just" === ($$try)[0])) {
            const $name = ($$try)[1];
            return ((($corelib$Dict$insert)($name))(({
              isAnnotated: ((sp_not_equal)($corelib$Maybe$Nothing))($maybeAnnotation),
              pos: $pos,
              type: $type,
            })))($vars);
            return null;
          }
          (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 947:16', (sp_toHuman)($$try));
        }))();
        return ($sp$Compiler$TypeCheck$return)(({
          pos: $pos,
          ty: $type,
          vars: $newVars,
        }));
      })))($makeType);
      return null;
    }
    if (("$sp$Types$CanonicalAst$PatternLiteralNumber" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $literal = ($$try)[2];
      return ($sp$Compiler$TypeCheck$return)(({
        pos: $pos,
        ty: $sp$Compiler$CoreTypes$number,
        vars: $vars,
      }));
      return null;
    }
    if (("$sp$Types$CanonicalAst$PatternLiteralText" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $literal = ($$try)[2];
      return ($sp$Compiler$TypeCheck$return)(({
        pos: $pos,
        ty: $sp$Compiler$CoreTypes$text,
        vars: $vars,
      }));
      return null;
    }
    if (("$sp$Types$CanonicalAst$PatternConstructor" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $usr = ($$try)[2];
      const $args = ($$try)[3];
      const $constructorTyM = ((() => {
        const $$try = (($corelib$Dict$get)($usr))($env.constructors);
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr));
        }
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $c = ($$try)[1];
          return (($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type);
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 961:16', (sp_toHuman)($$try));
      }))();
      return (($sp$Compiler$TypeCheck$andThen)((($constructorTy) => {
        const $p = ({
          argIndex: 0,
          args: $args,
          env: $env,
          pos: $pos,
          ty: $constructorTy,
          usr: $usr,
          vars: $vars,
        });
        return (($sp$Compiler$TypeCheck$andThen)(((patternTy$$) => {
          const $patternVars = patternTy$$.first;
          const $patternTy = patternTy$$.second;
          return ($sp$Compiler$TypeCheck$return)(({
            pos: $pos,
            ty: $patternTy,
            vars: $patternVars,
          }));
        })))(($sp$Compiler$TypeCheck$unifyConstructorWithItsArgs)($p));
      })))($constructorTyM);
      return null;
    }
    if (("$sp$Types$CanonicalAst$PatternRecord" === ($$try)[0])) {
      const $pos = ($$try)[1];
      const $attrs = ($$try)[2];
      const $blah = (($name) => (($pa) => ((attrTypes$$) => {
        const $varsX = attrTypes$$.first;
        const $attrTypes = attrTypes$$.second;
        return (($sp$Compiler$TypeCheck$andThen)((($paOut) => ($sp$Compiler$TypeCheck$return)(({
          first: $paOut.vars,
          second: ((($corelib$Dict$insert)($name))($paOut.ty))($attrTypes),
        })))))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pa))($varsX));
      })));
      return (($sp$Compiler$TypeCheck$andThen)(((attrTypes$$) => {
        const $vars1 = attrTypes$$.first;
        const $attrTypes = attrTypes$$.second;
        return (($sp$Compiler$TypeCheck$andThen)((($extName) => ($sp$Compiler$TypeCheck$return)(({
          pos: $pos,
          ty: ((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($extName)))($attrTypes),
          vars: $vars1,
        })))))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity));
      })))(((($sp$Compiler$TypeCheck$dict_foldl)($blah))($attrs))(({
        first: $vars,
        second: $corelib$Dict$empty,
      })));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 927:4', (sp_toHuman)($$try));
  }))();
})));

const $sp$Compiler$TypeCheck$insertPatternVar = (($pars) => (($name) => (($patternVar) => (($env) => {
  const $refinedTy = ($patternVar.isAnnotated
    ? $patternVar.type
    : (($sp$Compiler$TypeCheck$replaceTypeVariables)($pars.subs))($patternVar.type));
  const $ref = ($pars.isRoot
    ? ($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($env.currentModule))($name))
    : ($sp$Types$CanonicalAst$RefBlock)($name));
  return ($sp$Compiler$TypeCheck$return)(({
    constructors: $env.constructors,
    currentModule: $env.currentModule,
    instanceVariables: ((($corelib$Dict$insert)($ref))(({
      definedAt: $patternVar.pos,
      freeTypeVariables: (($pars.isMutable || $pars.isParameter)
        ? $corelib$Dict$empty
        : ((($sp$Types$CanonicalAst$getFreeTypeVars)($env.nonFreeTyvars))($corelib$Dict$empty))($refinedTy)),
      isMutable: $pars.isMutable,
      ty: $refinedTy,
    })))($env.instanceVariables),
    meta: $env.meta,
    nonAnnotatedRecursives: ($patternVar.isAnnotated
      ? $env.nonAnnotatedRecursives
      : ((($corelib$Dict$insert)($name))($patternVar.pos))($env.nonAnnotatedRecursives)),
    nonFreeTyvars: ($pars.isParameter
      ? ((($corelib$Dict$foldl)($corelib$Dict$insert))(($sp$Types$CanonicalAst$typeTyvars)($refinedTy)))($env.nonFreeTyvars)
      : $env.nonFreeTyvars),
    types: $env.types,
  }));
}))));

const $sp$Compiler$TypeCheck$insertPatternVars = (($pars) => ($sp$Compiler$TypeCheck$dict_foldl)(($sp$Compiler$TypeCheck$insertPatternVar)($pars)));

const $sp$Compiler$TypeCheck$fromDefinition = (($isRoot) => (($def) => (($env) => (($sp$Compiler$TypeCheck$andThen)((($patternOut) => {
  const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
    isMutable: $def.mutable,
    isParameter: false,
    isRoot: $isRoot,
    subs: $corelib$Dict$empty,
  })))($patternOut.vars))($env);
  return (($sp$Compiler$TypeCheck$andThen)((($env1) => ($def.native
    ? ($sp$Compiler$TypeCheck$return)($env1)
    : (($sp$Compiler$TypeCheck$andThen)((($bodyType_) => (($sp$Compiler$TypeCheck$andThen)((($bodyType) => (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => (($sp$Compiler$TypeCheck$andThen)((() => (($sp$Compiler$TypeCheck$andThen)((($env2) => (($sp$Compiler$TypeCheck$andThen)((($subs) => ((($sp$Compiler$TypeCheck$insertPatternVars)(({
      isMutable: $def.mutable,
      isParameter: false,
      isRoot: $isRoot,
      subs: $subs,
    })))($patternOut.vars))($env2))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env1)))))((((($sp$Compiler$TypeCheck$checkFreeVariables)($env1))($patternOut.pos))($patternOut.ty))($bodyType)))))(((((($sp$Compiler$TypeCheck$unify)($env1))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_DefBlockVsPattern))($bodyType))($patternOut.ty)))))(($sp$Compiler$TypeCheck$applySubsToType)($bodyType_)))))((($sp$Compiler$TypeCheck$fromBlock)($env1))($def.body))))))($ip);
})))(((($sp$Compiler$TypeCheck$fromPattern)($env))($def.pattern))($corelib$Dict$empty)))));

const $sp$Compiler$TypeCheck$fromStatement = (($env) => (($statement) => ((() => {
  const $$try = $statement;
  if (("$sp$Types$CanonicalAst$Evaluation" === ($$try)[0])) {
    const $expr = ($$try)[1];
    return (($sp$Compiler$TypeCheck$andThen)((($expressionType) => ($sp$Compiler$TypeCheck$return)(({
      first: $env,
      second: $corelib$Maybe$Nothing,
      third: $expressionType,
    })))))((($sp$Compiler$TypeCheck$fromExpression)($env))($expr));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Definition" === ($$try)[0])) {
    const $def = ($$try)[1];
    return (($sp$Compiler$TypeCheck$andThen)((($env1) => {
      const $x = ($def.mutable
        ? ($corelib$Maybe$Just)(($sp$Types$CanonicalAst$patternPos)($def.pattern))
        : $corelib$Maybe$Nothing);
      return ($sp$Compiler$TypeCheck$return)(({
        first: $env1,
        second: $x,
        third: $sp$Compiler$CoreTypes$none,
      }));
    })))(((($sp$Compiler$TypeCheck$fromDefinition)(false))($def))($env));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 475:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$TypeCheck$fromBlock = (($env0) => (($block) => {
  const $state0 = ({
    env: $env0,
    inferredType: $sp$Compiler$CoreTypes$none,
    mutableDefs: $core$SPCore$Nil,
  });
  const $upd = (($statement) => (($state) => (($sp$Compiler$TypeCheck$andThen)(((env$$) => {
    const $env = env$$.first;
    const $maybeMutableDefinitionId = env$$.second;
    const $inferredType = env$$.third;
    return ($sp$Compiler$TypeCheck$return)(({
      env: $env,
      inferredType: $inferredType,
      mutableDefs: ((() => {
        const $$try = $maybeMutableDefinitionId;
        if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
          return $state.mutableDefs;
        }
        if (("$corelib$Maybe$Just" === ($$try)[0])) {
          const $definitionId = ($$try)[1];
          return ((sp_cons)($state.mutableDefs))($definitionId);
          return null;
        }
        (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 451:16', (sp_toHuman)($$try));
      }))(),
    }));
  })))((($sp$Compiler$TypeCheck$fromStatement)($state.env))($statement))));
  return (($sp$Compiler$TypeCheck$andThen)((($stateF) => ((() => {
    const $$try = $stateF.mutableDefs;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ($sp$Compiler$TypeCheck$return)($stateF.inferredType);
    }
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $head = ($$try)[1];
      const $tail = ($$try)[2];
      return (($sp$Compiler$TypeCheck$typeContainsFunctions)($stateF.inferredType)
        ? (($sp$Compiler$TypeCheck$addError)($head))((($core$SPCore$Cons)("blocks that define mutables can't return functions"))($core$SPCore$Nil))
        : ($sp$Compiler$TypeCheck$return)($stateF.inferredType));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 460:4', (sp_toHuman)($$try));
  }))())))(((($sp$Compiler$TypeCheck$list_foldl)($upd))($block))($state0));
}));

const $sp$Compiler$TypeCheck$fromParameter = (($env) => (($param) => ((() => {
  const $$try = $param;
  if (("$sp$Types$CanonicalAst$ParameterPattern" === ($$try)[0])) {
    const $pattern = ($$try)[1];
    return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => ($sp$Compiler$TypeCheck$return)(({
      first: false,
      second: $patternOut,
    })))))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
    return null;
  }
  if (("$sp$Types$CanonicalAst$ParameterMutable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $paramName = ($$try)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($ty) => {
      const $vars = (($corelib$Dict$singleton)($paramName))(({
        isAnnotated: false,
        pos: $pos,
        type: $ty,
      }));
      return ($sp$Compiler$TypeCheck$return)(({
        first: true,
        second: ({
          pos: $pos,
          ty: $ty,
          vars: $vars,
        }),
      }));
    })))(($sp$Compiler$TypeCheck$newType)($pos));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 826:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$TypeCheck$fromPatternAndBlock = (($env) => ((block$$) => {
  const $pattern = block$$.first;
  const $block = block$$.second;
  return ((blockTypeSoFar$$) => {
    const $patternTypeSoFar = blockTypeSoFar$$.first;
    const $blockTypeSoFar = blockTypeSoFar$$.second;
    return (($sp$Compiler$TypeCheck$andThen)((($patternOut) => (($sp$Compiler$TypeCheck$andThen)((($unifiedPatternType) => (($sp$Compiler$TypeCheck$andThen)((($env1) => (($sp$Compiler$TypeCheck$andThen)((($subs) => {
      const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
        isMutable: false,
        isParameter: false,
        isRoot: false,
        subs: $subs,
      })))($patternOut.vars))($env1);
      return (($sp$Compiler$TypeCheck$andThen)((($patternEnv) => (($sp$Compiler$TypeCheck$andThen)((($blockType) => (($sp$Compiler$TypeCheck$andThen)((($unifiedBlockType) => ($sp$Compiler$TypeCheck$return)(({
        first: $unifiedPatternType,
        second: $unifiedBlockType,
      })))))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))(($sp$Compiler$TypeCheck$UnifyReason_TryBlock)($block)))($blockTypeSoFar))($blockType)))))((($sp$Compiler$TypeCheck$fromBlock)($patternEnv))($block)))))($ip);
    })))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(($sp$Compiler$TypeCheck$applySubsToNonFreeTyvars)($env)))))(((((($sp$Compiler$TypeCheck$unify)($env))($patternOut.pos))($sp$Compiler$TypeCheck$UnifyReason_TryPattern))($patternOut.ty))($patternTypeSoFar)))))(((($sp$Compiler$TypeCheck$fromPattern)($env))($pattern))($corelib$Dict$empty));
  });
}));

const $sp$Types$CanonicalAst$argumentPos = (($arg) => ((() => {
  const $$try = $arg;
  if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($sp$Types$CanonicalAst$expressionPos)($e);
    return null;
  }
  if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    return $pos;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 239:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType = (($env) => (($reference) => (($referenceType) => (($callIsMutable) => (($argument) => (($callArgumentType) => ((() => {
  const $$try = $referenceType;
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $refArgumentType = ($$try)[2];
    const $refIsMutable = ($$try)[3];
    const $refReturnType = ($$try)[4];
    return (((sp_not_equal)($refIsMutable))($callIsMutable)
      ? (($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$expressionPos)($reference)))((($core$SPCore$Cons)("mutability clash 2"))($core$SPCore$Nil))
      : ((() => {
        const $pos = ($sp$Types$CanonicalAst$expressionPos)($reference);
        const $reason = ($sp$Compiler$TypeCheck$UnifyReason_CallArgument)(({
          argument: ($sp$Types$CanonicalAst$argumentPos)($argument),
          reference: $pos,
        }));
        return (($sp$Compiler$TypeCheck$andThen)((($unifiedArgumentType) => ($sp$Compiler$TypeCheck$applySubsToType)($refReturnType))))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($reason))($refArgumentType))($callArgumentType));
      }))());
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($returnType) => {
      const $ty = (((($sp$Types$CanonicalAst$TypeFunction)($pos))($callArgumentType))($callIsMutable))($returnType);
      return (($sp$Compiler$TypeCheck$andThen)((() => ($sp$Compiler$TypeCheck$applySubsToType)($returnType))))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))((($sp$Compiler$TypeCheck$UnifyReason_IsBeingCalledAsAFunction)($pos))($referenceType)))($referenceType))($ty));
    })))(($sp$Compiler$TypeCheck$newType)($pos));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ty = ($$try)[3];
    return (((((($sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType)($env))($reference))($ty))($callIsMutable))($argument))($callArgumentType);
    return null;
  }
  if (true) {
    return (($sp$Compiler$TypeCheck$addError)(($sp$Types$CanonicalAst$expressionPos)($reference)))((($core$SPCore$Cons)("This is being called like a function, but its type is"))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)((($sp$Compiler$TypeCheck$typeToText)($env))($referenceType)))($core$SPCore$Nil))));
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 726:4', (sp_toHuman)($$try));
}))()))))));

const $sp$Compiler$TypeCheck$fromExpression = (($env) => (($expression) => ((() => {
  const $$try = $expression;
  if (("$sp$Types$CanonicalAst$LiteralText" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $l = ($$try)[2];
    return ($sp$Compiler$TypeCheck$return)($sp$Compiler$CoreTypes$text);
    return null;
  }
  if (("$sp$Types$CanonicalAst$LiteralNumber" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $l = ($$try)[2];
    return ($sp$Compiler$TypeCheck$return)($sp$Compiler$CoreTypes$number);
    return null;
  }
  if (("$sp$Types$CanonicalAst$Variable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $attrPath = ($$try)[2].attrPath;
    const $ref = ($$try)[2].ref;
    return ((() => {
      const $$try = (($corelib$Dict$get)($ref))($env.instanceVariables);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref);
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $var = ($$try)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($varType) => (((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($varType))))((($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)($var.freeTypeVariables))($var.ty));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 580:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$Constructor" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $usr = ($$try)[2];
    return ((() => {
      const $$try = (($corelib$Dict$get)($usr))($env.constructors);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))(($sp$Types$CanonicalAst$RefRoot)($usr));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $c = ($$try)[1];
        return (($sp$Compiler$TypeCheck$replaceTypeVariablesWithNew)(((($sp$Types$CanonicalAst$getFreeTypeVars)($corelib$Dict$empty))($corelib$Dict$empty))($c.type)))($c.type);
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 654:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  if (("$sp$Types$CanonicalAst$Lambda" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $param = ($$try)[2];
    const $body = ($$try)[3];
    return (($sp$Compiler$TypeCheck$andThen)(((isMutable$$) => {
      const $isMutable = isMutable$$.first;
      const $patternOut = isMutable$$.second;
      const $ip = ((($sp$Compiler$TypeCheck$insertPatternVars)(({
        isMutable: $isMutable,
        isParameter: true,
        isRoot: false,
        subs: $corelib$Dict$empty,
      })))($patternOut.vars))($env);
      return (($sp$Compiler$TypeCheck$andThen)((($bodyEnv) => (($sp$Compiler$TypeCheck$andThen)((($bodyType) => (($sp$Compiler$TypeCheck$andThen)((($refinedPatternOutTy) => (($isMutable && ($sp$Compiler$TypeCheck$typeContainsFunctions)($refinedPatternOutTy))
        ? (($sp$Compiler$TypeCheck$errorTodo)($pos))("mutable args cannot be functions")
        : ($sp$Compiler$TypeCheck$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($refinedPatternOutTy))($isMutable))($bodyType))))))(($sp$Compiler$TypeCheck$applySubsToType)($patternOut.ty)))))((($sp$Compiler$TypeCheck$fromBlock)($bodyEnv))($body)))))($ip);
    })))((($sp$Compiler$TypeCheck$fromParameter)($env))($param));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Call" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $reference = ($$try)[2];
    const $argument = ($$try)[3];
    return (($sp$Compiler$TypeCheck$andThen)((($referenceType) => (($sp$Compiler$TypeCheck$andThen)(((argumentType$$) => {
      const $fromIsMutable = argumentType$$.first;
      const $argumentType = argumentType$$.second;
      return (((((($sp$Compiler$TypeCheck$unifyFunctionOnCallAndYieldReturnType)($env))($reference))($referenceType))($fromIsMutable))($argument))($argumentType);
    })))((($sp$Compiler$TypeCheck$fromArgument)($env))($argument)))))((($sp$Compiler$TypeCheck$fromExpression)($env))($reference));
    return null;
  }
  if (("$sp$Types$CanonicalAst$If" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ar = ($$try)[2];
    return (($sp$Compiler$TypeCheck$andThen)((($conditionType) => (($sp$Compiler$TypeCheck$andThen)((() => (($sp$Compiler$TypeCheck$andThen)((($s) => (($sp$Compiler$TypeCheck$andThen)((($trueType) => (($sp$Compiler$TypeCheck$andThen)((($falseType) => ((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_IfBranches))($trueType))($falseType))))((($sp$Compiler$TypeCheck$fromBlock)($env))($ar.false)))))((($sp$Compiler$TypeCheck$fromBlock)($env))($ar.true)))))(($sp$Compiler$TypeCheck$get)((($x) => $x.substitutions))))))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))($sp$Compiler$TypeCheck$UnifyReason_IfCondition))($conditionType))($sp$Compiler$CoreTypes$bool)))))((($sp$Compiler$TypeCheck$fromBlock)($env))($ar.condition));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Try" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $value = ($$try)[2];
    const $patternsAndBlocks = ($$try)[3];
    return (($sp$Compiler$TypeCheck$andThen)((($tryType) => (($sp$Compiler$TypeCheck$andThen)((($newBlockType) => (($sp$Compiler$TypeCheck$andThen)(((inferredBlockType$$) => {
      const $patternType = inferredBlockType$$.first;
      const $inferredBlockType = inferredBlockType$$.second;
      return ($sp$Compiler$TypeCheck$return)($inferredBlockType);
    })))(((($sp$Compiler$TypeCheck$list_foldl)(($sp$Compiler$TypeCheck$fromPatternAndBlock)($env)))($patternsAndBlocks))(({
      first: $tryType,
      second: $newBlockType,
    }))))))(($sp$Compiler$TypeCheck$newType)($pos)))))((($sp$Compiler$TypeCheck$fromExpression)($env))($value));
    return null;
  }
  if (("$sp$Types$CanonicalAst$Record" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $maybeExt = ($$try)[2];
    const $attrValues = ($$try)[3];
    return (($sp$Compiler$TypeCheck$andThen)((($attrTypes) => ((() => {
      const $$try = $maybeExt;
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return ($sp$Compiler$TypeCheck$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($corelib$Maybe$Nothing))($attrTypes));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $variableArgs = ($$try)[1];
        return (($sp$Compiler$TypeCheck$andThen)((($ty_) => (($sp$Compiler$TypeCheck$andThen)((($ty) => (($sp$Compiler$TypeCheck$andThen)((($name) => (($sp$Compiler$TypeCheck$andThen)((($unifiedType) => ($sp$Compiler$TypeCheck$return)($unifiedType))))(((((($sp$Compiler$TypeCheck$unify)($env))($pos))(($sp$Compiler$TypeCheck$UnifyReason_AttributeUpdate)(($corelib$Dict$keys)($attrTypes))))($ty))(((($sp$Types$CanonicalAst$TypeRecord)($pos))(($corelib$Maybe$Just)($name)))($attrTypes))))))(($sp$Compiler$TypeCheck$newName)($corelib$Basics$identity)))))(($sp$Compiler$TypeCheck$applySubsToType)($ty_)))))((($sp$Compiler$TypeCheck$fromExpression)($env))((($sp$Types$CanonicalAst$Variable)($pos))($variableArgs)));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 711:12', (sp_toHuman)($$try));
    }))())))((($sp$Compiler$TypeCheck$dict_map)((($k) => ($sp$Compiler$TypeCheck$fromExpression)($env))))($attrValues));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 572:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$TypeCheck$fromArgument = (($env) => (($argument) => ((() => {
  const $$try = $argument;
  if (("$sp$Types$CanonicalAst$ArgumentExpression" === ($$try)[0])) {
    const $expr = ($$try)[1];
    return (($sp$Compiler$TypeCheck$andThen)((($ty) => ($sp$Compiler$TypeCheck$return)(({
      first: false,
      second: $ty,
    })))))((($sp$Compiler$TypeCheck$fromExpression)($env))($expr));
    return null;
  }
  if (("$sp$Types$CanonicalAst$ArgumentMutable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $attrPath = ($$try)[2].attrPath;
    const $ref = ($$try)[2].ref;
    return ((() => {
      const $$try = (($corelib$Dict$get)($ref))($env.instanceVariables);
      if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
        return (($sp$Compiler$TypeCheck$andThen)((($ty) => ($sp$Compiler$TypeCheck$return)(({
          first: true,
          second: $ty,
        })))))(((($sp$Compiler$TypeCheck$errorUndefinedVariable)($env))($pos))($ref));
      }
      if (("$corelib$Maybe$Just" === ($$try)[0])) {
        const $var = ($$try)[1];
        return (($corelib$Basics$not)($var.isMutable)
          ? ((() => {
            const $ae = (($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)(("You are trying to mutate variable `" + ((sp_toHuman)($ref) + "` but it was declared as not mutable!"))))((($core$SPCore$Cons)(""))((($core$SPCore$Cons)("TODO [link to wiki page that explains how to declare variables]"))($core$SPCore$Nil))));
            return (($sp$Compiler$TypeCheck$andThen)((($ty) => ($sp$Compiler$TypeCheck$return)(({
              first: true,
              second: $ty,
            })))))($ae);
          }))()
          : (($sp$Compiler$TypeCheck$typeContainsFunctions)($var.ty)
            ? (($sp$Compiler$TypeCheck$andThen)((($ty) => ($sp$Compiler$TypeCheck$return)(({
              first: true,
              second: $ty,
            })))))((($sp$Compiler$TypeCheck$addError)($pos))((($core$SPCore$Cons)("mutable arguments can't allow functions"))($core$SPCore$Nil)))
            : (($sp$Compiler$TypeCheck$andThen)((($ty) => ($sp$Compiler$TypeCheck$return)(({
              first: true,
              second: $ty,
            })))))((((($sp$Compiler$TypeCheck$applyAttributePath)($env))($pos))($attrPath))($var.ty))));
        return null;
      }
      (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 798:12', (sp_toHuman)($$try));
    }))();
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 792:4', (sp_toHuman)($$try));
}))()));

const $sp$Compiler$TypeCheck$initState = ({
  errors: $core$SPCore$Nil,
  nextName: 0,
  nonFnTyvars: $corelib$Dict$empty,
  substitutions: $corelib$Dict$empty,
  typeClashesByPlaceholderId: $corelib$Maybe$Nothing,
});

const $sp$StateMonad$run = (($state) => (($m) => ($m)($state)));

const $sp$Compiler$TypeCheck$fromModule = (($env) => (($module) => {
  (sp_benchStart)(null);
  const $insert = (($pa) => (($def) => ((ann$$) => {
    const $ann = ann$$.first;
    const $nonAnn = ann$$.second;
    const $allAnnotated = (($corelib$List$all)(((maybeType$$) => {
      const $pos = maybeType$$.first;
      const $maybeType = maybeType$$.second;
      return ((sp_not_equal)($corelib$Maybe$Nothing))($maybeType);
    })))(($corelib$Dict$values)(($sp$Types$CanonicalAst$patternNamedTypes)($pa)));
    return ($allAnnotated
      ? ({
        first: ((sp_cons)($ann))($def),
        second: $nonAnn,
      })
      : ({
        first: $ann,
        second: ((sp_cons)($nonAnn))($def),
      }));
  })));
  const annotated$$ = ((($corelib$Dict$foldl)($insert))($module.valueDefs))(({
    first: $core$SPCore$Nil,
    second: $core$SPCore$Nil,
  }));
  const $nonAnnotated = annotated$$.second;
  const $annotated = annotated$$.first;
  return ((() => {
    const $$try = $nonAnnotated;
    if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Cons" === (($$try)[2])[0]))) {
      const $first = ($$try)[1];
      const $second = (($$try)[2])[1];
      const $tail = (($$try)[2])[2];
      const $pos = ($sp$Types$CanonicalAst$patternPos)($first.pattern);
      const $names = (($corelib$List$concatMap)((($d) => ($corelib$Dict$keys)(($sp$Types$CanonicalAst$patternNamedTypes)($d.pattern)))))($nonAnnotated);
      return (($sp$Compiler$Error$res)(($sp$Types$CanonicalAst$patternPos)($first.pattern)))((($eenv) => ((($corelib$Basics$btw)(sp_benchStop))("type check"))((($core$SPCore$Cons)("Support for non-annotated root definitions is not yet implemented. =*("))((($core$SPCore$Cons)(("These definitions need an annotation: " + (($corelib$Text$join)(", "))($names))))($core$SPCore$Nil)))));
      return null;
    }
    if (true) {
      const $orderedNonAnnotated = $nonAnnotated;
      const $allOrdered = ($corelib$List$concat)((($core$SPCore$Cons)($orderedNonAnnotated))((($core$SPCore$Cons)($annotated))($core$SPCore$Nil)));
      const envF$$ = (($sp$StateMonad$run)($sp$Compiler$TypeCheck$initState))(((($sp$StateMonad$list_foldl)(($sp$Compiler$TypeCheck$fromDefinition)(true)))($allOrdered))($env));
      const $stateF = envF$$.second;
      const $envF = envF$$.first;
      return (((sp_equal)($core$SPCore$Nil))($stateF.errors)
        ? ((($corelib$Basics$btw)(sp_benchStop))("type check"))(($corelib$Result$Ok)($envF))
        : ((($corelib$Basics$btw)(sp_benchStop))("type check"))(($corelib$Result$Err)(($sp$Compiler$Error$Nested)($stateF.errors))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 348:4', (sp_toHuman)($$try));
  }))();
}));

const $sp$Compiler$TypeCheck$splitName = (($s) => ((() => {
  const $$try = ((text_split)("."))($s);
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0])))) {
    const $moduleName = ($$try)[1];
    const $valueName = (($$try)[2])[1];
    return ({
      first: ($corelib$Maybe$Just)($moduleName),
      second: $valueName,
    });
    return null;
  }
  if (true) {
    return ({
      first: $corelib$Maybe$Nothing,
      second: $s,
    });
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck.sp 1719:4', (sp_toHuman)($$try));
}))());

const $sp$Compiler$TypeCheck_Test$outToHuman = (($out) => {
  const $freeVars = $out.freeTypeVariables;
  const $nf = (($corelib$Text$join)(", "))(($corelib$Dict$keys)((($corelib$Dict$filter)((($k) => (($v) => $v.nonFn))))($freeVars)));
  return (($corelib$Text$join)("\n"))((($core$SPCore$Cons)(("  freeTypeVariables = [ " + ((($corelib$Text$join)(", "))(($corelib$Dict$keys)($freeVars)) + " ]"))))((($core$SPCore$Cons)(("  (NonFunction = [" + ($nf + "])"))))((($core$SPCore$Cons)(("  isMutable = " + (sp_toHuman)($out.isMutable))))((($core$SPCore$Cons)(("  ty = " + ((($sp$Human$CanonicalAst$typeToText)($sp$Compiler$TestHelpers$moduleUmr))($sp$Compiler$TestHelpers$meta))($out.ty))))((($core$SPCore$Cons)(("  pos = " + (sp_toHuman)($out.ty))))($core$SPCore$Nil))))));
});

const $sp$Compiler$TypeCheck_Test$codeTest = ($sp$Test$codeTest)($sp$Compiler$TypeCheck_Test$outToHuman);

const $sp$Compiler$TypeCheck_Test$forall = (($vars) => ((($corelib$List$foldl)((($n) => (($corelib$Dict$insert)($n))(({
  nonFn: false,
})))))($vars))($corelib$Dict$empty));

const $sp$Compiler$TypeCheck_Test$ftv = (($n) => (($corelib$Dict$singleton)($n))(({
  nonFn: false,
})));

const $sp$Compiler$TypeCheck_Test$function = (($from) => (($to) => (((($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$T))($from))(false))($to)));

const $sp$Compiler$TypeCheck_Test$tyNone = $sp$Compiler$TestHelpers$noneType;

const $sp$Compiler$TypeCheck_Test$tyNumber = $sp$Compiler$TestHelpers$numberType;

const $sp$Compiler$TypeCheck_Test$typeFunction = ($sp$Types$CanonicalAst$TypeFunction)($sp$Types$Pos$T);

const $sp$Human$CanonicalAst$initNstate = ({
  next: 0,
  replacements: $corelib$Dict$empty,
});

const $sp$Human$CanonicalAst$andThen = $sp$StateMonad$andThen;

const $sp$Human$CanonicalAst$get = $sp$StateMonad$get;

const $sp$Human$CanonicalAst$intToName = (($n) => (($acc) => ((() => {
  const $$try = $n;
  if ((0 === $$try)) {
    return "a";
  }
  if ((1 === $$try)) {
    return "b";
  }
  if ((2 === $$try)) {
    return "c";
  }
  if ((3 === $$try)) {
    return "d";
  }
  if ((4 === $$try)) {
    return "e";
  }
  if ((5 === $$try)) {
    return "f";
  }
  if (true) {
    return (sp_todo)("intToName");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 163:4', (sp_toHuman)($$try));
}))()));

const $sp$Human$CanonicalAst$newName = (($state) => ({
  first: (($sp$Human$CanonicalAst$intToName)($state.next))($core$SPCore$Nil),
  second: (Object.assign)({}, $state, ({
    next: ($state.next + 1),
  })),
}));

const $sp$Human$CanonicalAst$return = $sp$StateMonad$return;

const $sp$Human$CanonicalAst$normName = (($name) => ((((text_length)($name) > 1) && ((sp_equal)($corelib$Maybe$Nothing))((text_toNumber)($name)))
  ? ($sp$Human$CanonicalAst$return)($name)
  : (($sp$Human$CanonicalAst$andThen)((($n2l) => ((() => {
    const $$try = (($corelib$Dict$get)($name))($n2l);
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $replacement = ($$try)[1];
      return ($sp$Human$CanonicalAst$return)($replacement);
      return null;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return (($sp$Human$CanonicalAst$andThen)((($n) => {
        const $addReplacement = (($s) => (Object.assign)({}, $s, ({
          replacements: ((($corelib$Dict$insert)($name))($n))($s.replacements),
        })));
        return (($sp$Human$CanonicalAst$andThen)((() => ($sp$Human$CanonicalAst$return)($n))))(($sp$StateMonad$update)($addReplacement));
      })))($sp$Human$CanonicalAst$newName);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 274:8', (sp_toHuman)($$try));
  }))())))(($sp$Human$CanonicalAst$get)((($x) => $x.replacements)))));

const $sp$StateMonad$list_map = (($f) => (($la) => {
  const $apply = (($a) => (($accum) => (($sp$StateMonad$andThen)((($b) => ($sp$StateMonad$return)(((sp_cons)($accum))($b)))))(($f)($a))));
  return (($sp$StateMonad$andThen)((($x) => ($sp$StateMonad$return)(($corelib$List$reverse)($x)))))(((($sp$StateMonad$list_foldl)($apply))($la))($core$SPCore$Nil));
}));

const $sp$StateMonad$maybe_map = (($f) => (($ma) => ((() => {
  const $$try = $ma;
  if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
    return ($sp$StateMonad$return)($corelib$Maybe$Nothing);
  }
  if (("$corelib$Maybe$Just" === ($$try)[0])) {
    const $a = ($$try)[1];
    return (($sp$StateMonad$andThen)((($b) => ($sp$StateMonad$return)(($corelib$Maybe$Just)($b)))))(($f)($a));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/StateMonad.sp 66:4', (sp_toHuman)($$try));
}))()));

const $sp$Human$CanonicalAst$normType = (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    const $args = ($$try)[3];
    return (($sp$Human$CanonicalAst$andThen)((($args_n) => ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeConstant)($pos))($name))($args_n)))))((($sp$StateMonad$list_map)($sp$Human$CanonicalAst$normType))($args));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $name = ($$try)[2];
    return (($sp$Human$CanonicalAst$andThen)((($n) => ($sp$Human$CanonicalAst$return)((($sp$Types$CanonicalAst$TypeVariable)($pos))($n)))))(($sp$Human$CanonicalAst$normName)($name));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $from0 = ($$try)[2];
    const $fromIsMut = ($$try)[3];
    const $to0 = ($$try)[4];
    return (($sp$Human$CanonicalAst$andThen)((($from1) => (($sp$Human$CanonicalAst$andThen)((($to1) => ($sp$Human$CanonicalAst$return)((((($sp$Types$CanonicalAst$TypeFunction)($pos))($from1))($fromIsMut))($to1)))))(($sp$Human$CanonicalAst$normType)($to0)))))(($sp$Human$CanonicalAst$normType)($from0));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $ext0 = ($$try)[2];
    const $attrs0 = ($$try)[3];
    return (($sp$Human$CanonicalAst$andThen)((($ext1) => (($sp$Human$CanonicalAst$andThen)((($attrs1) => ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeRecord)($pos))($ext1))($attrs1)))))((($sp$StateMonad$dict_map)((($k) => $sp$Human$CanonicalAst$normType)))($attrs0)))))((($sp$StateMonad$maybe_map)($sp$Human$CanonicalAst$normName))($ext0));
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $pos = ($$try)[1];
    const $path = ($$try)[2];
    const $t = ($$try)[3];
    return (($sp$Human$CanonicalAst$andThen)((($t1) => ($sp$Human$CanonicalAst$return)(((($sp$Types$CanonicalAst$TypeAlias)($pos))($path))($t1)))))(($sp$Human$CanonicalAst$normType)($t));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Human/CanonicalAst.sp 242:4', (sp_toHuman)($$try));
}))());

const $sp$Human$CanonicalAst$normalizeTypeAndTyvars = (($tyOld) => (($tyvarsOld) => {
  const state$$ = (($sp$StateMonad$run)($sp$Human$CanonicalAst$initNstate))(($sp$Human$CanonicalAst$normType)($tyOld));
  const $state = state$$.second;
  const $tyNew = state$$.first;
  const $replace = (($name) => ($corelib$Dict$insert)((($corelib$Maybe$withDefault)($name))((($corelib$Dict$get)($name))($state.replacements))));
  const $tyvarsNew = ((($corelib$Dict$foldl)($replace))($tyvarsOld))($corelib$Dict$empty);
  return ({
    first: $tyNew,
    second: $tyvarsNew,
  });
}));

const $sp$Compiler$TypeCheck_Test$infer = (($name) => (($code) => {
  const $tcEnvResult = ((() => {
    const $params = ({
      meta: $sp$Compiler$TestHelpers$meta,
      name: $sp$Compiler$TestHelpers$moduleName,
      source: $sp$Compiler$TestHelpers$source,
      stripLocations: true,
    });
    return (($corelib$Result$onOk)((($module) => (($corelib$Result$onOk)((($expandedTypes) => {
      const constructors$$ = $expandedTypes;
      const $types = constructors$$.types;
      const $instanceVariables = constructors$$.instanceVariables;
      const $constructors = constructors$$.constructors;
      const $env = ({
        constructors: $constructors,
        currentModule: $sp$Compiler$TestHelpers$moduleUmr,
        instanceVariables: ((($corelib$Dict$insert)(($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))("reset"))))(({
          definedAt: $sp$Types$Pos$T,
          freeTypeVariables: $corelib$Dict$empty,
          isMutable: false,
          ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$TypeCheck_Test$tyNumber))(true))($sp$Compiler$TypeCheck_Test$tyNone),
        })))(((($corelib$Dict$insert)(($sp$Types$CanonicalAst$RefRoot)((($sp$Types$Meta$USR)($sp$Compiler$TestHelpers$moduleUmr))("add"))))(({
          definedAt: $sp$Types$Pos$T,
          freeTypeVariables: $corelib$Dict$empty,
          isMutable: false,
          ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))((($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber)),
        })))($instanceVariables)),
        meta: $sp$Compiler$TestHelpers$meta,
        nonAnnotatedRecursives: $corelib$Dict$empty,
        nonFreeTyvars: $corelib$Dict$empty,
        types: $types,
      });
      return (($sp$Compiler$TypeCheck$fromModule)($env))($module);
    })))(($sp$Compiler$Pipeline$globalExpandedTypes)((($corelib$Dict$singleton)($sp$Compiler$TestHelpers$moduleUmr))($module))))))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($params))($code));
  }))();
  return (($corelib$Result$onOk)((($tcEnv) => ((() => {
    const $$try = (($corelib$Dict$get)(($sp$Compiler$TestHelpers$rootLocal)($name)))($tcEnv.instanceVariables);
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return ($corelib$Result$Err)("dict fail");
    }
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      const $var = ($$try)[1];
      const ty$$ = (($sp$Human$CanonicalAst$normalizeTypeAndTyvars)($var.ty))($var.freeTypeVariables);
      const $tyvars = ty$$.second;
      const $ty = ty$$.first;
      return ($corelib$Result$Ok)(({
        freeTypeVariables: $var.freeTypeVariables,
        isMutable: $var.isMutable,
        ty: $ty,
      }));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Compiler/TypeCheck_Test.sp 143:4', (sp_toHuman)($$try));
  }))())))((($sp$Compiler$TestHelpers$resErrorToStrippedText)($code))($tcEnvResult));
}));

const $sp$Compiler$TypeCheck_Test$typeVariable = ($sp$Types$CanonicalAst$TypeVariable)($sp$Types$Pos$T);

const $sp$Compiler$TypeCheck_Test$functions = (($sp$Test$Group)("functions"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Known function with correct params"))("a = add 3 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$TypeCheck_Test$tyNumber,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Known function with wrong params"))("a = add False"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Function inference 1"))("a = x: add x 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Function inference 2: same as 1, but with swapped args"))("a = x: add 1 x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: (($sp$Compiler$TypeCheck_Test$function)($sp$Compiler$TypeCheck_Test$tyNumber))($sp$Compiler$TypeCheck_Test$tyNumber),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] fn has type None"))("a = x: 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("1"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$TypeCheck_Test$typeVariable)("a")))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Multiple arguments are correctly inferred"))("a = x: y: z: x + y + z"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Annotation should be consistent with mutability"))("f as Number @: Number = a:\n  a"))(($sp$Compiler$TypeCheck_Test$infer)("f")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability"))($core$SPCore$Nil)))))($core$SPCore$Nil))))))));

const $sp$Compiler$TypeCheck_Test$higherOrderTypes = (($sp$Test$Group)("higher order types"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Parse precedence"))("union T a = T a\n\na as T a: T a =\n    l: l"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("0a"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("T")))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))($core$SPCore$Nil))))(false))(((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("T")))((($core$SPCore$Cons)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))($core$SPCore$Nil))),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Union type constructors"))("union X a = L\nl = L"))(($sp$Compiler$TypeCheck_Test$infer)("l")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("1"),
  isMutable: false,
  ty: ((($sp$Types$CanonicalAst$TypeConstant)($sp$Types$Pos$T))(($sp$Compiler$TestHelpers$localType)("X")))((($core$SPCore$Cons)((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a")))($core$SPCore$Nil)),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP [reg] type check mistakes a union type with free tyvars for a free tyvar?"))("union O r e o = O r e o\n\nrun as (r: O r e o): r: O r e o = rToOreo: r:\n    rToOreo r"))(($sp$Compiler$TypeCheck_Test$infer)("run")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Wrong should be Text"))("union O o = O Text o\n\nfun as Number: Text: O wrong = _: a:\n    O a a"))(($sp$Compiler$TypeCheck_Test$infer)("fun")))(($sp$Test$errorContains)((($core$SPCore$Cons)("wrong"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP [reg] Should complain about undefined type argument"))("union O a = O Text output\nx = 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("undefined"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$TypeCheck_Test$if_else = (($sp$Test$Group)("if..else"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("basic functionality"))("x = q:\n  if q then 1\n  else 2"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$CoreTypes$bool))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-bool conditions"))("x = q:\n  if 1 then 1\n  else 2"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks"))("x = q:\n  if q then 2\n  else False"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Number"))($core$SPCore$Nil)))))($core$SPCore$Nil))));

const $sp$Compiler$TypeCheck_Test$mu = (($sp$Test$Group)("mutability"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks that define mutables can't return functions"))("a =\n  x @= 1\n  y: y"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("can't return functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Immutable variables can't be used as mutable"))("a = x:\n  @x := 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Detect mismatching annotations"))("a as Number: None =\n  reset"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utability"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Correctly unify annotation's mutability"))("a as Number @: None =\n  reset"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$TypeCheck_Test$tyNumber))(true))($sp$Compiler$TypeCheck_Test$tyNone),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 1"))("a @= x: x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 2"))("a = f@:\n    @f := (x: x)"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable args cannot be functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable 3"))("a = f@:\n  f 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutable args cannot be functions"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Lambda argument mutability is correctly inferred"))("a = x: reset x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("*Nested* lambda argument mutability is correctly inferred"))("a = x: (y: reset y) x"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("mutability clash"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Functions can't be mutable (annotation)"))("a as Number: Number @=\n  add 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$errorContains)((($core$SPCore$Cons)("utable"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Mutables can contain functions via free tyvars"))("a = x:\n  s @= x\n  s\n\nz as x: x =\n  a (x: x)"))(($sp$Compiler$TypeCheck_Test$infer)("a")))($sp$Test$isOk)))($core$SPCore$Nil))))))))))));

const $sp$Compiler$TypeCheck_Test$nonFunction = (($sp$Test$Group)("NonFunction"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Basic functionality"))("blah as List a: List a =\n  with a NonFunction\n  a:\n  a\n\nmeh =\n  blah [x: x]"))(($sp$Compiler$TypeCheck_Test$infer)("meh")))(($sp$Test$errorContains)((($core$SPCore$Cons)("should not contain functions"))($core$SPCore$Nil)))))($core$SPCore$Nil));

const $sp$Compiler$TypeCheck_Test$patterns = (($sp$Test$Group)("Patterns"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("List unpacking"))("x = q:\n   [ first, second ] = q\n   first"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("2"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$CoreTypes$list)((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a"))))(false))((($sp$Types$CanonicalAst$TypeVariable)(($sp$Types$Pos$I)(11)))("a")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Records are correctly unpacked"))("x = q:\n    { first } = q\n    first"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("3"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: "first",
    second: ($sp$Compiler$TypeCheck_Test$typeVariable)("b"),
  })))($core$SPCore$Nil)))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("b")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] Constructors should instantiate their variable types"))("each as [a]: (a: b): None =\n    ls: f:\n    try ls as\n        SPCore.Nil:\n            None\n\nresult =\n      1 :: SPCore.Nil = SPCore.Nil"))(($sp$Compiler$TypeCheck_Test$infer)("result")))($sp$Test$isOk)))($core$SPCore$Nil))));

const $sp$Compiler$TypeCheck_Test$records = (($sp$Test$Group)("Records"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Attribute access"))("a = b: b.meh.blah"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("4"))((($core$SPCore$Cons)("5"))($core$SPCore$Nil)))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("meh"))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("b")))((($corelib$Dict$singleton)("blah"))(($sp$Compiler$TypeCheck_Test$typeVariable)("c")))))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("c")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Attribute mutation"))("a = b@: @b.meh.blah += 1"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))((($core$SPCore$Cons)("4"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("meh"))(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("b")))((($corelib$Dict$singleton)("blah"))($sp$Compiler$CoreTypes$number))))))(true))($sp$Compiler$CoreTypes$none),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Tuple3 direct item mutability"))("x =\n    a @= 3 & False & 2\n\n    @a.third += 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Tuple2 direct item mutability, annotated"))("x = y:\n   a as Number & Number @=\n     1 & 2\n\n   @a.first += 1"))(($sp$Compiler$TypeCheck_Test$infer)("x")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("functional update"))("a = b: { b with x = 1 }"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(((($re) => ({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("2"))($core$SPCore$Nil)),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($re))(false))($re),
})))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("x"))($sp$Compiler$CoreTypes$number)))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP instantiate and refine inferred records"))("a = t: { t with x = 1 }\nc = a"))(($sp$Compiler$TypeCheck_Test$infer)("c")))(($sp$Test$isOkAndEqualTo)(((($re) => ({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("a"))($core$SPCore$Nil)),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($re))(false))($re),
})))(((($sp$Types$CanonicalAst$TypeRecord)($sp$Types$Pos$T))(($corelib$Maybe$Just)("a")))((($corelib$Dict$singleton)("x"))($sp$Compiler$CoreTypes$number)))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] excessive forallness in records"))("x = q:\n a = q.first\n a"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$forall)((($core$SPCore$Cons)("3"))((($core$SPCore$Cons)("4"))($core$SPCore$Nil))),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(((($sp$Types$CanonicalAst$TypeRecord)(($sp$Types$Pos$I)(2)))(($corelib$Maybe$Just)("a")))(($corelib$Dict$fromList)((($core$SPCore$Cons)(({
    first: "first",
    second: ($sp$Compiler$TypeCheck_Test$typeVariable)("b"),
  })))($core$SPCore$Nil)))))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("b")),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] refineType when the record has a non-extensible alias"))("alias A = { c as Number, d as Number }\n\nupd as A: A = a:\n  { a with c = .c + 1 }"))(($sp$Compiler$TypeCheck_Test$infer)("upd")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] infinite recursion on addSubstitution/unify_"))("alias B = { l as [Text] }\n\nreadOne as B: (Text & B) = b:\n    try b.l as\n        []: \"\" & b\n        h :: t: h & { b with l = t }"))(($sp$Compiler$TypeCheck_Test$infer)("readOne")))($sp$Test$isOk)))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("[reg] unifyToNonExtensibleRecord correctly substitutes the record extension"))("alias R = { x as Number, y as Number }\n\nrec as R: R =\n    s:\n        if True then\n            { s with y = .y }\n        else\n            rec { s with y = .y }"))(($sp$Compiler$TypeCheck_Test$infer)("rec")))($sp$Test$isOk)))($core$SPCore$Nil)))))))))));

const $sp$Compiler$TypeCheck_Test$statements = (($sp$Test$Group)("statements"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Statement blocks should return the last statement's type"))("a =\n  3\n  False"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$CoreTypes$bool,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Definition statement return type None"))("a =\n  f = x: 3"))(($sp$Compiler$TypeCheck_Test$infer)("a")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: $sp$Compiler$CoreTypes$none,
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Local values can't shadow root values"))("a = 1\nb as Number =\n    a = 1\n    a"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("already"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Prevent local redeclarations"))("b =\n  a = 1\n  a = 1"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("declar"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("SKIP Prevent root redeclarations"))("a = 1\na = 1"))(($sp$Compiler$TypeCheck_Test$infer)("b")))(($sp$Test$errorContains)((($core$SPCore$Cons)("declar"))($core$SPCore$Nil)))))($core$SPCore$Nil))))));

const $sp$Compiler$TypeCheck_Test$try_as = (($sp$Test$Group)("try..as"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("basic functionality"))("x = q:\n    try q as\n        True: 2\n        _: 3"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: $corelib$Dict$empty,
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)($sp$Compiler$CoreTypes$bool))(false))($sp$Compiler$CoreTypes$number),
})))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching patterns"))("x = q:\n    try q as\n        True: 2\n        []: 3"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("List"))((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil))))))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks"))("x = q:\n try q as\n   True: 2\n   False: False"))(($sp$Compiler$TypeCheck_Test$infer)("x")))(($sp$Test$errorContains)((($core$SPCore$Cons)("Number"))((($core$SPCore$Cons)("Bool"))($core$SPCore$Nil))))))($core$SPCore$Nil))));

const $sp$Compiler$TypeCheck_Test$variableTypes = (($sp$Test$Group)("Variable types"))((($core$SPCore$Cons)((((($sp$Compiler$TypeCheck_Test$codeTest)("Identity"))("id as a: a =\n  a: a"))(($sp$Compiler$TypeCheck_Test$infer)("id")))(($sp$Test$isOkAndEqualTo)(({
  freeTypeVariables: ($sp$Compiler$TypeCheck_Test$ftv)("0a"),
  isMutable: false,
  ty: ((($sp$Compiler$TypeCheck_Test$typeFunction)(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")))(false))(($sp$Compiler$TypeCheck_Test$typeVariable)("0a")),
})))))($core$SPCore$Nil));

const $sp$Compiler$TypeCheck_Test$tests = (($sp$Test$Group)("TypeCheck"))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$functions))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$statements))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$variableTypes))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$mu))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$higherOrderTypes))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$records))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$patterns))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$try_as))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$if_else))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$nonFunction))($core$SPCore$Nil)))))))))));

const $sp$Human$CanonicalAst$normalizeType = (($t) => ($corelib$Tuple$first)((($sp$StateMonad$run)($sp$Human$CanonicalAst$initNstate))(($sp$Human$CanonicalAst$normType)($t))));

const $sp$RefHierarchy_Test$valueTest = ($sp$Test$valueTest)(sp_toHuman);

const $sp$RefHierarchy_Test$canonicalJsTest = ((($sp$RefHierarchy_Test$valueTest)("[reg] THIS SHOULD BE IN CANONICALTOJS"))((() => ((basics_compare)(null))(null))))(($sp$Test$isOkAndEqualTo)(0));

const $sp$RefHierarchy_Test$graph1 = ((() => {
  const $x = (($k) => (($l) => ({
    first: $k,
    second: ({
      first: $k,
      second: ($corelib$Set$fromList)($l),
    }),
  })));
  return ($corelib$Dict$fromList)((($core$SPCore$Cons)((($x)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("b"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("e"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("c"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("d"))($core$SPCore$Nil)))((($core$SPCore$Cons)((($x)("e"))($core$SPCore$Nil)))($core$SPCore$Nil))))));
}))();

const $sp$RefHierarchy_Test$graph2 = ((() => {
  const $x = (($k) => (($l) => ({
    first: $k,
    second: ({
      first: $k,
      second: ($corelib$Set$fromList)($l),
    }),
  })));
  return ($corelib$Dict$fromList)((($core$SPCore$Cons)((($x)("a"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("b"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("e"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("c"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("d"))($core$SPCore$Nil)))))((($core$SPCore$Cons)((($x)("d"))((($core$SPCore$Cons)("b"))($core$SPCore$Nil))))((($core$SPCore$Cons)((($x)("e"))($core$SPCore$Nil)))($core$SPCore$Nil))))));
}))();

const $sp$RefHierarchy_Test$tests = (($sp$Test$Group)("RefHierarchy"))((($core$SPCore$Cons)($sp$RefHierarchy_Test$canonicalJsTest))((($core$SPCore$Cons)(((($sp$RefHierarchy_Test$valueTest)("Basic"))((() => (($sp$RefHierarchy$reorder)($corelib$Tuple$second))($sp$RefHierarchy_Test$graph1))))(($sp$Test$isOkAndEqualTo)(({
  first: $core$SPCore$Nil,
  second: (($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("a"))($core$SPCore$Nil))))),
})))))((($core$SPCore$Cons)(((($sp$RefHierarchy_Test$valueTest)("Circular"))((() => (($sp$RefHierarchy$reorder)($corelib$Tuple$second))($sp$RefHierarchy_Test$graph2))))(($sp$Test$isOkAndEqualTo)(({
  first: (($core$SPCore$Cons)((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("c"))($core$SPCore$Nil)))))($core$SPCore$Nil),
  second: (($core$SPCore$Cons)("d"))((($core$SPCore$Cons)("e"))((($core$SPCore$Cons)("c"))((($core$SPCore$Cons)("b"))((($core$SPCore$Cons)("a"))($core$SPCore$Nil))))),
})))))($core$SPCore$Nil))));

const $sp$Main$allTests = (($core$SPCore$Cons)($sp$Compiler$Lexer_Test$tests))((($core$SPCore$Cons)($sp$Compiler$Parser_Test$tests))((($core$SPCore$Cons)($sp$Compiler$MakeCanonical_Test$tests))((($core$SPCore$Cons)($sp$Compiler$TypeCheck_Test$tests))((($core$SPCore$Cons)($corelib$Hash_Test$tests))((($core$SPCore$Cons)($corelib$Array_Test$tests))((($core$SPCore$Cons)($corelib$List_Test$tests))((($core$SPCore$Cons)($corelib$Dict_Test$tests))((($core$SPCore$Cons)($sp$RefHierarchy_Test$tests))($core$SPCore$Nil)))))))));

const $sp$Main$asModule = (($tuple) => {
  const isDirectory$$ = $tuple;
  const $name = isDirectory$$.second;
  const $isDirectory = isDirectory$$.first;
  return (($isDirectory || ((sp_not_equal)($name))(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$"))($name)))
    ? $corelib$Maybe$Nothing
    : ($corelib$Maybe$Just)(((($corelib$Text$replace)(".sp"))(""))($name)));
});

const $sp$Main$asModuleDirectory = (($tuple) => {
  const isDirectory$$ = $tuple;
  const $name = isDirectory$$.second;
  const $isDirectory = isDirectory$$.first;
  return (($isDirectory && ((sp_equal)($name))(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$"))($name)))
    ? ($corelib$Maybe$Just)($name)
    : $corelib$Maybe$Nothing);
});

const $sp$Main$color = (($code) => (($text) => ($code + ($text + "\x1b[0m"))));

const $sp$Main$blue = ($sp$Main$color)("\x1b[34m");

const $sp$Main$getTargetUsr = (($meta) => (($entryModule) => (($entryValue) => (($globals) => {
  const $asEntry = (($ref) => ((() => {
    const $$try = $ref;
    if (("$sp$Types$CanonicalAst$RefBlock" === ($$try)[0])) {
      return $corelib$Maybe$Nothing;
    }
    if (("$sp$Types$CanonicalAst$RefRoot" === ($$try)[0])) {
      const $usr = ($$try)[1];
      const moduleName$$ = $usr;
      const $valueName = (moduleName$$)[2];
      const $moduleName = ((moduleName$$)[1])[2];
      const $source = ((moduleName$$)[1])[1];
      return ((((sp_equal)($entryModule))($moduleName) && ((sp_equal)($entryValue))($valueName))
        ? ($corelib$Maybe$Just)($usr)
        : $corelib$Maybe$Nothing);
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 292:8', (sp_toHuman)($$try));
  }))());
  const $possibleTargets = (($corelib$List$filterMap)($asEntry))(($corelib$Dict$keys)($globals.instanceVariables));
  return ((() => {
    const $$try = $possibleTargets;
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return (sp_todo)(("Can't find build target `" + ($entryModule + ("." + ($entryValue + "` anywhere.")))));
    }
    if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
      const $usr = ($$try)[1];
      return ($corelib$Result$Ok)($usr);
      return null;
    }
    if (true) {
      const $many = $$try;
      const $x = (($corelib$Text$join)(", "))((($corelib$List$map)(sp_toHuman))($many));
      return (sp_todo)(("Multiple values match build target `" + ($entryModule + ("." + ($entryValue + ("`: " + $x))))));
      return null;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 308:4', (sp_toHuman)($$try));
  }))();
}))));

const $sp$Main$listSourceDir = (($sourceDirRoot) => (($modulePathWithTrailingSlash) => {
  const $path = ($sourceDirRoot + ("/" + $modulePathWithTrailingSlash));
  return (($posix$IO$onSuccess)((($dirContents) => {
    const $directChildren = (($corelib$List$map)((($fileName) => ($modulePathWithTrailingSlash + $fileName))))((($corelib$List$filterMap)($sp$Main$asModule))($dirContents));
    const $getDescendants = (io_parallel)((($corelib$List$map)((($subDir) => (($sp$Main$listSourceDir)($sourceDirRoot))(($modulePathWithTrailingSlash + ($subDir + "/"))))))((($corelib$List$filterMap)($sp$Main$asModuleDirectory))($dirContents)));
    return (($posix$IO$onSuccess)((($descendants) => ($posix$IO$succeed)(($corelib$List$concat)((($core$SPCore$Cons)($directChildren))((($core$SPCore$Cons)(($corelib$List$concat)($descendants)))($core$SPCore$Nil)))))))($getDescendants);
  })))((io_readDir)($path));
}));

const $sp$Main$red = ($sp$Main$color)("\x1b[31m");

const $sp$Main$yellow = ($sp$Main$color)("\x1b[33m");

const $sp$Main$formattedToConsoleColoredText = (($formattedText) => ((() => {
  const $$try = $formattedText;
  if (("$sp$Compiler$Error$FormattedText_Default" === ($$try)[0])) {
    const $t = ($$try)[1];
    return $t;
    return null;
  }
  if (("$sp$Compiler$Error$FormattedText_Emphasys" === ($$try)[0])) {
    const $t = ($$try)[1];
    return ($sp$Main$yellow)($t);
    return null;
  }
  if (("$sp$Compiler$Error$FormattedText_Warning" === ($$try)[0])) {
    const $t = ($$try)[1];
    return ($sp$Main$red)($t);
    return null;
  }
  if (("$sp$Compiler$Error$FormattedText_Decoration" === ($$try)[0])) {
    const $t = ($$try)[1];
    return ($sp$Main$blue)($t);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 69:4', (sp_toHuman)($$try));
}))());

const $sp$Main$resToIo = (($errorEnv) => (($res) => ((() => {
  const $$try = $res;
  if (("$corelib$Result$Ok" === ($$try)[0])) {
    const $a = ($$try)[1];
    return ($posix$IO$succeed)($a);
    return null;
  }
  if (("$corelib$Result$Err" === ($$try)[0])) {
    const $e = ($$try)[1];
    return ($posix$IO$fail)((($corelib$Text$join)(""))((($corelib$List$map)($sp$Main$formattedToConsoleColoredText))((($sp$Compiler$Error$toFormattedText)($errorEnv))($e))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 91:4', (sp_toHuman)($$try));
}))()));

const $sp$Main$loadModulesFile = ((() => {
  const $modulesFileName = "modules.sp";
  return (($posix$IO$onSuccess)((($modulesAsText) => {
    const $eenv = ({
      moduleByName: (($corelib$Dict$singleton)($modulesFileName))(({
        content: $modulesAsText,
        fsPath: $modulesFileName,
      })),
    });
    return (($sp$Main$resToIo)($eenv))((($sp$ModulesFile$textToModulesFile)($modulesFileName))($modulesAsText));
  })))((io_readFile)($modulesFileName));
}))();

const $sp$Main$updateSd = (($fileNames) => {
  const $insertModuleName = (($name) => (($sd) => ((() => {
    const $$try = (($corelib$List$find)((($m) => ((sp_equal)($name))($m.path))))($sd.modules);
    if (("$corelib$Maybe$Just" === ($$try)[0])) {
      return $sd;
    }
    if (("$corelib$Maybe$Nothing" === ($$try)[0])) {
      return (Object.assign)({}, $sd, ({
        modules: ((sp_cons)($sd.modules))(({
          globalTypes: $core$SPCore$Nil,
          globalValues: $core$SPCore$Nil,
          path: $name,
          visibleAs: $name,
        })),
      }));
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 236:8', (sp_toHuman)($$try));
  }))()));
  return (($corelib$List$foldl)($insertModuleName))($fileNames);
});

const $sp$Main$loadMeta = (($env) => (($posix$IO$onSuccess)((($modulesFile) => {
  const $getAllSourceDirLists = (io_parallel)((($corelib$List$map)((($sd) => (($sp$Main$listSourceDir)($sd.path))(""))))($modulesFile.sourceDirs));
  return (($posix$IO$onSuccess)((($allSourceDirLists) => {
    const $updatedSourceDirs = ((($corelib$List$map2)($sp$Main$updateSd))($allSourceDirLists))($modulesFile.sourceDirs);
    return ($posix$IO$succeed)(($sp$ModulesFile$toMeta)((Object.assign)({}, $modulesFile, ({
      sourceDirs: $updatedSourceDirs,
    }))));
  })))($getAllSourceDirLists);
})))($sp$Main$loadModulesFile));

const $sp$Main$loadModule = (($meta) => (($umr) => (($fileName) => {
  const moduleName$$ = $umr;
  const $moduleName = (moduleName$$)[2];
  const $source = (moduleName$$)[1];
  return (($posix$IO$onSuccess)((($moduleAsText) => {
    const $params = ({
      meta: $meta,
      name: $moduleName,
      source: $source,
      stripLocations: false,
    });
    const $eenv = ({
      moduleByName: (($corelib$Dict$singleton)($moduleName))(({
        content: $moduleAsText,
        fsPath: $fileName,
      })),
    });
    return (($sp$Main$resToIo)($eenv))((($sp$Compiler$MakeCanonical$textToCanonicalModule)($params))($moduleAsText));
  })))((io_readFile)($fileName));
})));

const $sp$Main$onResSuccess = (($errorEnv) => (($f) => (($res) => (($posix$IO$onSuccess)($f))((($sp$Main$resToIo)($errorEnv))($res)))));

const $sp$Main$typeCheckModule = (($meta) => (($globals) => (($module) => {
  const $env = ({
    constructors: $globals.constructors,
    currentModule: $module.umr,
    instanceVariables: $globals.instanceVariables,
    meta: $meta,
    nonAnnotatedRecursives: $corelib$Dict$empty,
    nonFreeTyvars: $corelib$Dict$empty,
    types: $globals.types,
  });
  return (($sp$Compiler$TypeCheck$fromModule)($env))($module);
})));

const $sp$Main$umrToFileName = (($x) => {
  const name$$ = $x;
  const $name = (name$$)[2];
  const $source = (name$$)[1];
  return ((() => {
    const $$try = $source;
    if (("$sp$Types$Meta$SourceDir" === ($$try)[0])) {
      const $d = ($$try)[1];
      return ($corelib$Maybe$Just)(($d + ("/" + ($name + ".sp"))));
      return null;
    }
    if (true) {
      return $corelib$Maybe$Nothing;
    }
    (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 185:4', (sp_toHuman)($$try));
  }))();
});

const $sp$Main$compile = (($env) => (($entryModule) => (($entryValue) => (($outputFile) => {
  ((sp_log)("Loading meta..."))("");
  return (($posix$IO$onSuccess)((($meta) => {
    ((sp_log)("Loading modules..."))("");
    const $loadAllModules = (io_parallel)((($corelib$List$filterMap)((($umr) => (($corelib$Maybe$map)((($sp$Main$loadModule)($meta))($umr)))(($sp$Main$umrToFileName)($umr)))))(($corelib$Dict$values)($meta.moduleVisibleAsToUmr)));
    return (($posix$IO$onSuccess)((($modules) => {
      const $eenv = ((() => {
        const $getName = (($n) => {
          const name$$ = $n;
          const $name = (name$$.umr)[2];
          const $source = (name$$.umr)[1];
          return $name;
        });
        return ({
          moduleByName: ((($corelib$List$foldl)((($m) => (($corelib$Dict$insert)(($getName)($m)))(({
            content: $m.asText,
            fsPath: (($corelib$Maybe$withDefault)("CORE"))(($sp$Main$umrToFileName)($m.umr)),
          })))))($modules))($corelib$Dict$empty),
        });
      }))();
      ((sp_log)("Solving globals..."))("");
      const $x = ($sp$Compiler$Pipeline$globalExpandedTypes)((($corelib$List$indexBy)((($m) => $m.umr)))($modules));
      return ((($sp$Main$onResSuccess)($eenv))((($globals) => ((($sp$Main$onResSuccess)($eenv))((($targetUsr) => {
        ((sp_log)("Type checking..."))("");
        const $typeCheckModules = (io_parallel)((($corelib$List$map)((($m) => (($sp$Main$resToIo)($eenv))(((($sp$Main$typeCheckModule)($meta))($globals))($m)))))($modules));
        return (($posix$IO$onSuccess)((($typeCheckEnvs) => {
          ((sp_log)("Creating JS AST..."))("");
          const $jaStatements = ((($sp$Compiler$CanonicalToJs$translateAll)($eenv))($globals))($modules);
          ((sp_log)("Emitting JS..."))("");
          const $callMain = ("\nconst out = " + (($sp$Compiler$CanonicalToJs$translateUsr)($targetUsr) + "({})(array_toList(process.argv.slice(1)))[1]('never');\n        if (out[1]) console.error(out[1]);\n        "));
          const $statements = (($corelib$Text$join)("\n\n"))((($corelib$List$map)(($sp$Compiler$JsToText$emitStatement)(0)))($jaStatements));
          const $js = ($sp$Compiler$CanonicalToJs$nativeDefinitions + ($statements + $callMain));
          return ((io_writeFile)($outputFile))($js);
        })))($typeCheckModules);
      })))((((($sp$Main$getTargetUsr)($meta))($entryModule))($entryValue))($globals)))))($x);
    })))($loadAllModules);
  })))(($sp$Main$loadMeta)($env));
}))));

const $sp$Main$green = ($sp$Main$color)("\x1b[32m");

const $sp$Main$indent = (($s) => (($corelib$Text$join)("\n"))((($corelib$List$map)((($l) => ("  " + $l))))(((text_split)("\n"))($s))));

const $sp$Main$order = (($outcome) => ((() => {
  const $$try = $outcome;
  if (("$sp$Test$Success" === ($$try)[0])) {
    return 0;
  }
  if (("$sp$Test$Skipped" === ($$try)[0])) {
    return 1;
  }
  if (("$sp$Test$Error" === ($$try)[0])) {
    return 2;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 78:4', (sp_toHuman)($$try));
}))());

const $sp$Main$testOutcomeToText = (($name) => (($code) => (($outcome) => ((() => {
  const $$try = $outcome;
  if (("$sp$Test$Success" === ($$try)[0])) {
    return ($sp$Main$green)(("* PASS: " + $name));
  }
  if (("$sp$Test$Skipped" === ($$try)[0])) {
    return ($sp$Main$yellow)(("* skip: " + $name));
  }
  if (("$sp$Test$Error" === ($$try)[0])) {
    const $error = ($$try)[1];
    return (($sp$Main$red)(("FAIL ! " + $name)) + ("\n" + (($sp$Main$indent)($code) + ("\n" + ($sp$Main$indent)($error)))));
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 56:4', (sp_toHuman)($$try));
}))())));

const $sp$Test$getName = (($test) => ((() => {
  const $$try = $test;
  if (("$sp$Test$Single" === ($$try)[0])) {
    const $n = ($$try)[1];
    const $code = ($$try)[2];
    const $f = ($$try)[3];
    return $n;
    return null;
  }
  if (("$sp$Test$Group" === ($$try)[0])) {
    const $n = ($$try)[1];
    const $ls = ($$try)[2];
    return $n;
    return null;
  }
  if (("$sp$Test$NotNow" === ($$try)[0])) {
    const $t = ($$try)[1];
    return ($sp$Test$getName)($t);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 145:4', (sp_toHuman)($$try));
}))());

const $sp$Test$outcomesRec = (($path) => (($test) => (($accum) => ((() => {
  const $$try = $test;
  if (("$sp$Test$Single" === ($$try)[0])) {
    const $name = ($$try)[1];
    const $code = ($$try)[2];
    const $f = ($$try)[3];
    return (((text_startsWith)("SKIP"))($name)
      ? ((sp_cons)($accum))(({
        code: "",
        name: ($path + $name),
        outcome: $sp$Test$Skipped,
      }))
      : ((sp_cons)($accum))(({
        code: $code,
        name: ($path + $name),
        outcome: ($f)(null),
      })));
    return null;
  }
  if (("$sp$Test$NotNow" === ($$try)[0])) {
    const $t = ($$try)[1];
    return ((sp_cons)($accum))(({
      code: "",
      name: ($path + ($sp$Test$getName)($t)),
      outcome: $sp$Test$Skipped,
    }));
    return null;
  }
  if (("$sp$Test$Group" === ($$try)[0])) {
    const $pathSegment = ($$try)[1];
    const $ts = ($$try)[2];
    return ((($corelib$List$foldl)(($sp$Test$outcomesRec)(($path + ($pathSegment + " / ")))))($ts))($accum);
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 126:4', (sp_toHuman)($$try));
}))())));

const $sp$Test$flatten = (($tests) => ((($corelib$List$foldl)(($sp$Test$outcomesRec)("")))($tests))($core$SPCore$Nil));

const $sp$Main$main = (($env) => (($args) => ((() => {
  const $$try = $args;
  if ((("$core$SPCore$Cons" === ($$try)[0]) && ("$core$SPCore$Nil" === (($$try)[2])[0]))) {
    const $self = ($$try)[1];
    return (io_writeStdout)((($corelib$Text$join)("\n"))((($corelib$List$map)((($x) => ((($sp$Main$testOutcomeToText)($x.name))($x.code))($x.outcome))))(((list_sortBy)((($x) => ({
      first: ($sp$Main$order)($x.outcome),
      second: $x.name,
    }))))(($sp$Test$flatten)($sp$Main$allTests)))));
    return null;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && ("$core$SPCore$Nil" === ((($$try)[2])[2])[0])))) {
    const $self = ($$try)[1];
    const $testFile = (($$try)[2])[1];
    const $umr = (($sp$Types$Meta$UMR)(($sp$Types$Meta$SourceDir)("")))($testFile);
    return (($posix$IO$onSuccess)((($caModule) => ($posix$IO$succeed)(null))))(((($sp$Main$loadModule)($sp$Compiler$TestHelpers$meta))($umr))($testFile));
    return null;
  }
  if ((("$core$SPCore$Cons" === ($$try)[0]) && (("$core$SPCore$Cons" === (($$try)[2])[0]) && (("$core$SPCore$Cons" === ((($$try)[2])[2])[0]) && (("$core$SPCore$Cons" === (((($$try)[2])[2])[2])[0]) && ("$core$SPCore$Nil" === ((((($$try)[2])[2])[2])[2])[0])))))) {
    const $self = ($$try)[1];
    const $entryModule = (($$try)[2])[1];
    const $entryValue = ((($$try)[2])[2])[1];
    const $outputFile = (((($$try)[2])[2])[2])[1];
    return (((($sp$Main$compile)($env))($entryModule))($entryValue))($outputFile);
    return null;
  }
  if (true) {
    return (io_writeStdout)("Usage\n\nspcc EntryModule entryFunction outputFile.js");
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Main.sp 398:4', (sp_toHuman)($$try));
}))()));

const $sp$Main$sdItemToUMR = (($source) => (($fileName) => (($sp$Types$Meta$UMR)($source))(((($corelib$Text$replace)(".sp"))(""))($fileName))));

const $sp$SPLib$Buffer$readOne = (($b) => (($b.nextPos < $b.fullSize)
  ? ({
    first: (((text_slice)($b.nextPos))(($b.nextPos + 1)))($b.fullText),
    second: (Object.assign)({}, $b, ({
      nextPos: ($b.nextPos + 1),
    })),
  })
  : ({
    first: "",
    second: $b,
  })));

const $sp$SPLib$Parser$tuple3 = (($pa) => (($pb) => (($pc) => (($sp$SPLib$Parser$andThen)((($a) => (($sp$SPLib$Parser$andThen)((($b) => (($sp$SPLib$Parser$andThen)((($c) => ($sp$SPLib$Parser$accept)(({
  first: $a,
  second: $b,
  third: $c,
})))))($pc))))($pb))))($pa))));

const $sp$SPON$logHead = (($statements) => {
  ((() => {
    const $$try = $statements;
    if (("$core$SPCore$Cons" === ($$try)[0])) {
      const $head = ($$try)[1];
      const $tail = ($$try)[2];
      ((sp_log)("LOG"))($head);
      return null;
      return null;
    }
    if (("$core$SPCore$Nil" === ($$try)[0])) {
      return ((sp_log)("LOG"))(null);
    }
    (sp_throw)('Missing pattern in try..as', 'sp/SPON.sp 68:4', (sp_toHuman)($$try));
  }))();
  return (($sp$SPON$Accepted)($statements))(null);
});

const $sp$StateMonad$map = (($f) => (($m) => (($sp$StateMonad$andThen)((($x) => ($sp$StateMonad$return)(($f)($x)))))($m)));

const $sp$Test$errorsFirst = (($outcome) => ((() => {
  const $$try = $outcome;
  if (("$sp$Test$Error" === ($$try)[0])) {
    const $e = ($$try)[1];
    return (0 - 1);
    return null;
  }
  if (("$sp$Test$Skipped" === ($$try)[0])) {
    return 0;
  }
  if (("$sp$Test$Success" === ($$try)[0])) {
    return 1;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Test.sp 165:4', (sp_toHuman)($$try));
}))());

const $sp$Types$CanonicalAst$typePos = (($ty) => ((() => {
  const $$try = $ty;
  if (("$sp$Types$CanonicalAst$TypeConstant" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeVariable" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeFunction" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeRecord" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$CanonicalAst$TypeAlias" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/CanonicalAst.sp 183:4', (sp_toHuman)($$try));
}))());

const $sp$Types$FormattableAst$sepList_mapItem = (($f) => (($aAndLa) => {
  const a$$ = $aAndLa;
  const $la = a$$.second;
  const $a = a$$.first;
  return ({
    first: ($f)($a),
    second: (($corelib$List$map)(($corelib$Tuple$mapSecond)($f)))($la),
  });
}));

const $sp$Types$FormattableAst$typePos = (($type) => ((() => {
  const $$try = $type;
  if (("$sp$Types$FormattableAst$TypeVariable" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeConstant" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeFunction" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeTuple" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeList" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  if (("$sp$Types$FormattableAst$TypeRecord" === ($$try)[0])) {
    const $p = ($$try)[1];
    return $p;
    return null;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/FormattableAst.sp 124:4', (sp_toHuman)($$try));
}))());

const $sp$Types$Pos$end = (($pos) => ((() => {
  const $$try = $pos;
  if (("$sp$Types$Pos$P" === ($$try)[0])) {
    const $m = ($$try)[1];
    const $s = ($$try)[2];
    const $e = ($$try)[3];
    return $e;
    return null;
  }
  if (true) {
    return 0;
  }
  (sp_throw)('Missing pattern in try..as', 'sp/Types/Pos.sp 34:4', (sp_toHuman)($$try));
}))());
const out = $sp$Main$main({})(array_toList(process.argv.slice(1)))[1]('never');
        if (out[1]) console.error(out[1]);
        