
----> TCO

----> Error.Env needs only the current module

----> Caching system, because everything depends on that?

----> Humanize must break a type into multiple lines



* an inline lambda can't continue on a NewSiblingLine?
    value
        >> List.map x: blah
        >> sblorp

* lambdas can't unpack records?

    { blah }: xxx

* Remove Pattern from FormattableAST and just use Expression for everything?
    (This should simplify the parser and make it more accepting)

* replace fold with for

* :: -> List.stack?

* Remove module name from Pos

* Platforms should use their default modules.sp to figure out the USR of native values

* bodyDeps requires an explicit argument in order not to cause a cyclical init dependency:

        bodyDeps as [CA.Statement]: Deps: Deps =
            stats:
            List.foldl statementDeps stats

  How do I allow it to be written point-free?


* Translate ApplyAliases tests

* try..as rejects function types outright
    "Hey, is there an argument missing?"

* Parser test

        here as Parser Int =
            Parser.here >> andThen tokens:
            Parser.accept
                (try tokens as
                    Token mod start end :: rest:
                        start

                    []:
                        0
                )

* When there is any collision between types, ensure that either types are replaced with a fresh tyvar, so that the error does not propagate?

* test: List.range 0 -1 == []

* Duplicate name checks should be case-insensitive

* Clean up At vs Pos?

* Annotate every lambda with their function name and argument number, so that we can give better errors?

* When a constructor can't be found, its type should be assumed as a new free tyvar, but its args should be dealt with normally
    (Or maybe we should first deal with undefined variables?)

* TypeCheck env can keep track of the last definition name and use that when referring to errors within blocks?


* later:
        Compiler should be able to produce a stacktrace
        Or better, a call tree, which would be very useful to debug the parser?

* later: sp-format should recognize and preserve two main modes from the input format: a compact and an expanded one

* Add test for triple quotes containing quotes

* Add tests for Text functions

* Add test: variable names and attr names cannot contain `/`

* add test: it should be possible to write

      allTests
          >> Test.flatten
          >> List.sortBy (fn (name & code & outcome): outcome & name)
          >> List.map (fn (name & code & outcome): testOutcomeToText name code outcome)
          >> Text.join "\n"

  without parens around the `fn`s


* Remove support for prefix op notation (-) ?


* Decide the precedence between :: and &, then write tests to ensure it works as it should
    in both expressions and patterns.
    ---> This is one more reason to replace :: with a better syntax
    ---> squarepants-format should replace a :: b with [a, ...b]?



* How do we ensure that execution order is consistent in record expressions?
        # which one gets executed first?
        { b = doThingsWith @mutable
        , a = doThingsWith @mutable
        }


# All core iterators should have a test that ensures the order they call an argument function doesn't change
    This is to ensure that if the argument function mutates stuff, the result is not implementation dependent



* Macro: a definition that, given a type, provides me with the definition's body?

        compare as {Type}: a: a: Int
        compare type x y =
            try type as
                CA....
                ????









type Array a

#
# Array.push @theArray theNewItem
#
push =
    as Array a @: a: None

#
# Array.get theArray index
#
get =
    as Array a: Int: Maybe a

#
# Array.set @theArray index newItemValue
#
set =
    as Array a @: Int: a: Bool

#
# Array.sort @theArray
#
sortBy =
    as Array a @: (a: b): None
    with b NonFunction


List.sortBy fun ls =
    as (a: b): List a: List a
    with b NonFunction

    array @= Array.fromList ls
    Array.sortBy @array fun
    Array.toList array

