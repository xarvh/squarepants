
High Priority Stuff
===================

* callback op
  (So I can test the new type check)

* Union types behave like aliases (ie, become tag types)
  (So I don't have to rewrite all code)
  ---> What about recursive definitions?

* get rid of `union`

* TypeOpaque

* TypeGenerated vs TypeAnnotated?
  or:
    SpecifiedType = <TypeVariable name, ... >
    InferredType = <Generated Int, Specified SpecifiedType>

* Humanize must break a type into multiple lines

* Caching system, because everything depends on that?

* Error.Env needs only the current module
    > Remove module name from Pos

* TCO

* code instrumenting, track on which variables/expession sp_clone is used?

* actual parallelism with io_parallel?

* Write tests and fix: `SPCore.todo "TODO needs proper type comparison without `pos`"`


Error messages to improve
=========================

```
attributeNotFoundOnRecord =
    record = {}
    record.nonExistentAttribute
```





Intermediate Representation
===========================
* contains inferred and annotated types
    - for every try..as
    - for every variable?

* expands value def's patterns into several definitions
    (generating dummy intermediate values)



Lexer / Parser
==============

* lambdas can't unpack records?
    { blah }: xxx

* Add test for triple quotes containing quotes

* Add tests for Text functions

* Add test: variable names and attr names cannot contain `/`

* add test: it should be possible to write

      allTests
          >> Test.flatten
          >> List.sortBy (fn (name & code & outcome): outcome & name)
          >> List.map (fn (name & code & outcome): testOutcomeToText name code outcome)
          >> Text.join "\n"

  without parens around the `fn`s

* an inline lambda can't continue on a NewSiblingLine?
    value
        >> List.map x: blah
        >> sblorp


* lexer doesn't like sibling with nested statements?
        , valueTest
            """
            for
            """
            _:
                []
                    >> Hash.for (Hash.fromList [Just True & 2, Nothing & 4]) k: v: a:
                        (v & k) :: a
                    >> List.sortBy Tuple.first

* Parser test

        here as Parser Int =
            Parser.here >> andThen tokens:
            Parser.accept
                (try tokens as
                    Token mod start end :: rest:
                        start

                    []:
                        0
                )


* parser sbarella con

    s =
        env & []
            >> List.for block statement: (envX & depsAccum):
                    statementDependencies envX statement
                          >> Tuple.mapSecond (merge depsAccum)
            >> Tuple.second



Backlog?
========

* Remove Pattern from FormattableAST and just use Expression for everything?
    (This should simplify the parser and make it more accepting)

* replace fold with for

* Murder `::`
    * have a List.stack
    * have [a, b, ...c] syntax for expr and patterns


* Platforms should use their default modules.sp to figure out the USR of native values


* try..as rejects function types outright
    "Hey, is there an argument missing?"

* When there is any collision between types, ensure that either types are replaced with a fresh tyvar, so that the error does not propagate?

* test: List.range 0 -1 == []

* Duplicate name checks should be case-insensitive

* Clean up At vs Pos?

* Annotate every lambda with their function name and argument number, so that we can give better errors?

* When a constructor can't be found, its type should be assumed as a new free tyvar, but its args should be dealt with normally
    (Or maybe we should first deal with undefined variables?)

* TypeCheck env can keep track of the last definition name and use that when referring to errors within blocks?

* later:
        Compiler should be able to produce a stacktrace
        Or better, a call tree, which would be very useful to debug the parser?

* later: sp-format should recognize and preserve two main modes from the input format: a compact and an expanded one

* Remove support for prefix op notation (-) ?

* How do we ensure that execution order is consistent in record expressions?
        # which one gets executed first?
        { b = doThingsWith @mutable
        , a = doThingsWith @mutable
        }

# All core iterators should have a test that ensures the order they call an argument function doesn't change
    This is to ensure that if the argument function mutates stuff, the result is not implementation dependent

* Macro: a definition that, given a type, provides me with the definition's body?

        compare as {Type}: a: a: Int
        compare type x y =
            try type as
                CA....
                ????

Target https://github.com/bytecodealliance/wasmtime ?

