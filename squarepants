#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096

//Error.stackTraceLimit = 100;

const { performance } = require('perf_hooks');

let __re__;


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


//
// Basic ops
//


const sp_equal = (a, b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i], b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k], b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a, b) => {
  return !sp_equal(a, b);
}


const basics_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = basics_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = basics_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (left, right) => {
  if (right === 0) return 0;
  return left / right;
}


// TODO remove this and handle it like any other op?
const basics_modBy = (a, b) => b % a;


const basics_cloneImm = sp_clone;


const basics_cloneUni = (uni) =>
    [ sp_clone(uni), uni ];


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message, thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


// TODO how should benchmark work in a browser?
typeof process !== 'undefined' && process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.error("");
        console.error("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.error(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const id = (n) => '    '.repeat(n);


const sp_toHuman = (a, l = 0) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a, l) || sp_toHumanAsDict(a, l) || sp_toHumanAsUnion(a, l);

  if (typeof a === 'function') {
    return '<fn ' + a.length + '>';
  }

  if (typeof a === 'object') {
    let acc = '{\n';
    for (let key in a)
        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\n';

    return acc + id(l) + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a, l) => {

  if (a.length === 1) {
      return a[0];
  }

  let acc = a[0] + '\n';

  a.slice(1).forEach(arg => {

      const sub = sp_toHuman(arg, l + 1);
      if (!sub.startsWith('{') && sub.indexOf('\n') > -1)
          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\n';
      else
          acc += id(l + 1) + sub + '\n';

  })

  return acc;
}


const sp_toHumanAsList = (arrayAccum, list, l) => {
  if (list[0] === '$Cons' && list.length === 3) {
    arrayAccum.push(sp_toHuman(list[1], l));
    return sp_toHumanAsList(arrayAccum, list[2], l);
  }

  if (list[0] === '$Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}

const sp_toHumanAsDict = (dict, l) => {
  if (dict[0] === 'RBNode_elm_builtin') {
      return 'DICT' + sp_toHumanAsList([], $core$Dict$toList(dict), l);
  }

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ? $c$$src$Maybe$$Nothing : $c$$src$Maybe$$Just(n);
    }

    const text_toLower = (s) => s.toLowerCase()

    const text_toUpper = (s) => s.toUpperCase()

    const text_split = (separator, target) => arrayToListLow(target.split(separator));

    const text_length = (s) => s.length;

    const text_slice = (start, end, s) => s.slice(start, end);

    const text_startsWith = (sub, s) => s.startsWith(sub);

    const text_startsWithRegex = (regex) => {
      let re;
      try {
        re = new RegExp('^' + regex, 's');
      } catch (e) {
        return () => ""
      }

      return (s) => {
        let m = s.match(re);
        return m ? m[0] : "";
      }
    }

    const text_replaceRegex = (regex) => {
      let re;
      try {
        re = new RegExp(regex, 'g');
      } catch (e) {
        return () => ""
      }

      return (replacer, s) => s.replace(re, replacer);
    }

    const text_trimLeft = (s) => s.trimLeft();

    const text_dropLeft = (n, s) => s.slice(n);

    const text_forEach = (s, f) => {
      for (let i of s) f(i);
      return null;
    }


    //
    // Hashes
    //

    const hash_pop = (hash) => {
        for (let key in hash) {
            const [actualKey, value] = hash[key];
            delete hash[key];
            return [ $c$$src$Maybe$$Just({ first: actualKey, second: value }), hash ];
        }

        return [ $c$$src$Maybe$$Nothing, hash ];
    }


    const hash_fromList = (list) => {
      const hash = {};

      // TODO iteration instead of recursion
      const rec = (ls) => {
        if (ls[0] === '$Nil')
          return hash;

        const { first, second } = ls[1];

        hash[JSON.stringify(first)] = [first, second];

        return rec(ls[2]);
      };

      return rec(list);
    }


    const hash_insert = (hash, key, value) => {
        hash[JSON.stringify(key)] = [key, value];
        return [null, hash];
    }


    const hash_remove = (hash, key) => {
        delete hash[JSON.stringify(key)];
        return [null, hash];
    }


    const hash_get = (hash, key) => {
        const r = hash[JSON.stringify(key)];
        return [r === undefined ? $c$$src$Maybe$$Nothing : $c$$src$Maybe$$Just(r[1]), hash];
    }


    const hash_for = (hash, f, acc) => {
        for (let k in hash) {
            const kv = hash[k];
            acc = f(kv[0], kv[1], acc);
        }
        return [acc, hash];
    }


    const hash_each = (hash, f) => {
        for (let k in hash) {
            const kv = hash[k];
            f(kv[0], kv[1]);
        }
        return [null, hash];
    }


    //
    // Arrays
    //

    const array_each = (array, f) => {
        array.forEach(f);
        return [null, array];
    }

    const array_push = (array, item) => {
        array.push(item);
        return [null, array];
    }

    const array_pop = (a) => {
        return [a.length ? $c$$src$Maybe$$Just(a.pop()) : $c$$src$Maybe$$Nothing, a];
    }

    const array_get = (array, index) => {
        const r = array[index];
        return [r === undefined ? $c$$src$Maybe$$Nothing : $c$$src$Maybe$$Just(r), array];
    }

    const array_set = (a, index, item) => {
        if (index < 0) return false;
        if (index >= a.length) return [false, a];
        a[index] = item;
        return [true, a];
    }

    const array_sortBy = (arr, f) => {
        arr.sort((a, b) => basics_compare(f(a), f(b)));
        return [null, arr];
    }

    const arrayToListLow = (arr) => {
      const length = arr.length;
      let list = [ '$Nil' ];
      for (let i = length - 1; i >= 0; i--) {
          list = [ '$Cons', arr[i], list ];
      }
      return list;
    }

    const array_toList = (arr) => [arrayToListLow(arr), arr];


    const arrayFromListLow = (list) => {
      const array = [];
      const rec = (ls) => {
        if (ls[0] === '$Nil')
          return array;

        array.push(ls[1]);
        return rec(ls[2]);
      };

      return rec(list);
    }

    const array_fromList = arrayFromListLow;


    //
    // Lists
    //


    const sp_cons = (item, list) => {
      return [ '$Cons', item, list];
    }

    const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f(a), f(b))));


    //
    // Dynamic loading
    //
    const self_load = (requestedTypeHumanized, pars, variantConstructor) => {

        const actualTypeHumanized = sp_toHuman(pars.type);
        if (actualTypeHumanized !== requestedTypeHumanized) {
            return [ 'Err', pars.type ];
        }

        // TODO using directly the source name sd1 is super fragile: must revisit this as soon as I have `Load.expose`
        // TODO hoping that the state won't be mutated, once we have `Load.expose` maybe we don't need to lug the state around any more?
        const translateUsr = $sd1$Targets$Javascript$EmittableToJs$translateUsr;
        const js = $sd1$Platforms$Browser$compile(pars);

        //   { name1, name2, name3, ... } = externals;
        const unpackExterns = 'const { ' + pars.externalValues.map((e) => translateUsr(e.usr)).join(', ') + ' } = externs;';

        const body = `{ ${unpackExterns}
${js}; return ${translateUsr(pars.entryUsr)}; }`;

        const arg = {};
        pars.externalValues.forEach((e) => arg[translateUsr(e.usr)] = e.self.value);

        return [ 'wwwwok', variantConstructor(Function('externs', body)(arg)) ];
    };

    
//
// Platform: IO
//
const fs = require('fs');
const path = require('path');

const io_readDir = (io, dirPath) => {
    // as @IO, Text: Re [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return [$c$$src$Result$$Ok(e.message), null];
        }

        return [$c$$src$Result$$Ok(arrayToListLow(entries.map((dirent) => ({
            first: dirent.isDirectory(),
            second: dirent.name,
        })))), null];
    };


    const io_readFile = (io, path) => {
        // as @IO, Text: Re Text

        var content;
        try {
            content = fs.readFileSync(path, 'utf8');
        } catch (e) {
            return [$c$$src$Result$$Ok(e.message), null];
        }

        return [$c$$src$Result$$Ok(content), null];
    };


    const io_writeFile = (io, path, content) => {
        // as @IO, Text, Text: Re Int

        try {
            fs.writeFileSync(path, content);
        } catch (e) {
            return [$c$$src$Result$$Ok(e.message), null];
        }

        return [$c$$src$Result$$Ok(0), null];
    };


    const io_readStdin = (io) => {
        // as @IO: Re Text

        try {
            return [$c$$src$Result$$Ok(fs.readFileSync(0, 'utf8')), null];
        } catch (e) {
            return [$c$$src$Result$$Ok(e.message), null];
        }
    };


    const io_writeStdout = (io, content) => {
        // as @IO, Text: Re None

        try {
            fs.writeFileSync(1, content);
        } catch (e) {
            return [$c$$src$Result$$Ok(e.message), null];
        }

        return [$c$$src$Result$$Ok(null), null];
    };


    const io_writeStderr = (io, content) => {
        // as @IO, Text: Re Int

        try {
            fs.writeFileSync(2, content);
        } catch (e) {
            return [$c$$src$Result$$Ok(e.message), null];
        }

        return [$c$$src$Result$$Ok(null), null];
    };


    const path_resolve = (p) => path.resolve(...arrayFromListLow(p));

    const path_join = (p) => path.join(...arrayFromListLow(p));

    const path_dirname = path.dirname;

const $c$$src$Compiler$Ast$$Depends = (($1) => ([
  "$Depends",
  $1,
]));

const $c$$src$Compiler$Ast$$Imm = ([
  "$Imm",
]);

const $c$$src$Compiler$Ast$$RefGlobal = (($1) => ([
  "$RefGlobal",
  $1,
]));

const $c$$src$Compiler$Ast$$RefLocal = (($1) => ([
  "$RefLocal",
  $1,
]));

const $c$$src$Compiler$Ast$$RefPlaceholder = (($1) => ([
  "$RefPlaceholder",
  $1,
]));

const $c$$src$Compiler$Ast$$Uni = ([
  "$Uni",
]);

const $c$$src$Compiler$CanonicalAst$$ArgumentExpression = (($1) => ([
  "$ArgumentExpression",
  $1,
]));

const $c$$src$Compiler$CanonicalAst$$ArgumentRecycle = (($1, $2, $3) => ([
  "$ArgumentRecycle",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$Call = (($1, $2, $3) => ([
  "$Call",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$Complete = ([
  "$Complete",
]);

const $c$$src$Compiler$CanonicalAst$$Constructor = (($1, $2) => ([
  "$Constructor",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$Fn = (($1, $2, $3) => ([
  "$Fn",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$If = (($1, $2) => ([
  "$If",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$LetIn = (($1, $2) => ([
  "$LetIn",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$LiteralNumber = (($1, $2) => ([
  "$LiteralNumber",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$LiteralText = (($1, $2) => ([
  "$LiteralText",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$ParRe = (($1) => ([
  "$ParRe",
  $1,
]));

const $c$$src$Compiler$CanonicalAst$$ParSp = (($1) => ([
  "$ParSp",
  $1,
]));

const $c$$src$Compiler$CanonicalAst$$ParameterPattern = (($1, $2) => ([
  "$ParameterPattern",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$ParameterPlaceholder = (($1) => ([
  "$ParameterPlaceholder",
  $1,
]));

const $c$$src$Compiler$CanonicalAst$$ParameterRecycle = (($1, $2) => ([
  "$ParameterRecycle",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$Partial = ([
  "$Partial",
]);

const $c$$src$Compiler$CanonicalAst$$PatternAny = (($1, $2, $3) => ([
  "$PatternAny",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$PatternConstructor = (($1, $2, $3) => ([
  "$PatternConstructor",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$PatternLiteralNumber = (($1, $2) => ([
  "$PatternLiteralNumber",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$PatternLiteralText = (($1, $2) => ([
  "$PatternLiteralText",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$PatternRecord = (($1, $2, $3) => ([
  "$PatternRecord",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$Record = (($1, $2, $3) => ([
  "$Record",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$RecordAccess = (($1, $2, $3) => ([
  "$RecordAccess",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$Try = (($1, $2) => ([
  "$Try",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$TypeAnnotationVariable = (($1, $2) => ([
  "$TypeAnnotationVariable",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$TypeError = (($1) => ([
  "$TypeError",
  $1,
]));

const $c$$src$Compiler$CanonicalAst$$TypeFn = (($1, $2, $3) => ([
  "$TypeFn",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$TypeNamed = (($1, $2, $3) => ([
  "$TypeNamed",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$CanonicalAst$$TypeRecord = (($1, $2) => ([
  "$TypeRecord",
  $1,
  $2,
]));

const $c$$src$Compiler$CanonicalAst$$Variable = (($1, $2) => ([
  "$Variable",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$And = (($1) => ([
  "$And",
  $1,
]));

const $c$$src$Compiler$EmittableAst$$ArgumentRecycle = (($1, $2, $3) => ([
  "$ArgumentRecycle",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$EmittableAst$$ArgumentSpend = (($1, $2) => ([
  "$ArgumentSpend",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$ArrayAccess = (($1, $2) => ([
  "$ArrayAccess",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$Call = (($1, $2) => ([
  "$Call",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$Conditional = (($1, $2, $3) => ([
  "$Conditional",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$EmittableAst$$Constructor = (($1) => ([
  "$Constructor",
  $1,
]));

const $c$$src$Compiler$EmittableAst$$ConstructorAccess = (($1, $2) => ([
  "$ConstructorAccess",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$Fn = (($1, $2) => ([
  "$Fn",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$IsConstructor = (($1, $2) => ([
  "$IsConstructor",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$LetIn = (($1) => ([
  "$LetIn",
  $1,
]));

const $c$$src$Compiler$EmittableAst$$LiteralArray = (($1) => ([
  "$LiteralArray",
  $1,
]));

const $c$$src$Compiler$EmittableAst$$LiteralNumber = (($1) => ([
  "$LiteralNumber",
  $1,
]));

const $c$$src$Compiler$EmittableAst$$LiteralRecord = (($1, $2) => ([
  "$LiteralRecord",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$LiteralText = (($1) => ([
  "$LiteralText",
  $1,
]));

const $c$$src$Compiler$EmittableAst$$MissingPattern = (($1, $2) => ([
  "$MissingPattern",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$RecordAccess = (($1, $2) => ([
  "$RecordAccess",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$ShallowEqual = (($1, $2) => ([
  "$ShallowEqual",
  $1,
  $2,
]));

const $c$$src$Compiler$EmittableAst$$Variable = (($1) => ([
  "$Variable",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$AliasDef = (($1) => ([
  "$AliasDef",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Aligned = ([
  "$Aligned",
]);

const $c$$src$Compiler$FormattableAst$$ArgumentPlaceholder = ([
  "$ArgumentPlaceholder",
]);

const $c$$src$Compiler$FormattableAst$$BinopChain = (($1, $2) => ([
  "$BinopChain",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$Call = (($1, $2) => ([
  "$Call",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$CommentStatement = (($1) => ([
  "$CommentStatement",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Constructor = (($1) => ([
  "$Constructor",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Evaluation = (($1) => ([
  "$Evaluation",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Expression = (($1, $2, $3) => ([
  "$Expression",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$FormattableAst$$Fn = (($1, $2, $3) => ([
  "$Fn",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$FormattableAst$$If = (($1) => ([
  "$If",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Indented = ([
  "$Indented",
]);

const $c$$src$Compiler$FormattableAst$$Inline = ([
  "$Inline",
]);

const $c$$src$Compiler$FormattableAst$$List = (($1, $2) => ([
  "$List",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$LiteralNumber = (($1, $2) => ([
  "$LiteralNumber",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$LiteralText = (($1, $2) => ([
  "$LiteralText",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$Lowercase = (($1) => ([
  "$Lowercase",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Native = ([
  "$Native",
]);

const $c$$src$Compiler$FormattableAst$$Poly = (($1, $2) => ([
  "$Poly",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$Record = (($1) => ([
  "$Record",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$RecordShorthand = (($1) => ([
  "$RecordShorthand",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$ResolvedArgumentPlaceholder = (($1) => ([
  "$ResolvedArgumentPlaceholder",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Statements = (($1) => ([
  "$Statements",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$Try = (($1) => ([
  "$Try",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$UnionDef = (($1) => ([
  "$UnionDef",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$UnopCall = (($1, $2) => ([
  "$UnopCall",
  $1,
  $2,
]));

const $c$$src$Compiler$FormattableAst$$Uppercase = (($1) => ([
  "$Uppercase",
  $1,
]));

const $c$$src$Compiler$FormattableAst$$ValueDef = (($1) => ([
  "$ValueDef",
  $1,
]));

const $c$$src$Compiler$Meta$$UMR = (($1, $2, $3) => ([
  "$UMR",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$Meta$$USR = (($1, $2) => ([
  "$USR",
  $1,
  $2,
]));

const $c$$src$Compiler$Meta$$ConstructorDependency = ([
  "$ConstructorDependency",
]);

const $c$$src$Compiler$Meta$$Core = ([
  "$Core",
]);

const $c$$src$Compiler$Meta$$ImportsPath = (($1, $2) => ([
  "$ImportsPath",
  $1,
  $2,
]));

const $c$$src$Compiler$Meta$$Installed = ([
  "$Installed",
]);

const $c$$src$Compiler$Meta$$LocationLibrary = (($1, $2) => ([
  "$LocationLibrary",
  $1,
  $2,
]));

const $c$$src$Compiler$Meta$$LocationSourceDir = (($1) => ([
  "$LocationSourceDir",
  $1,
]));

const $c$$src$Compiler$Meta$$TypeDependency = ([
  "$TypeDependency",
]);

const $c$$src$Compiler$Meta$$User = ([
  "$User",
]);

const $c$$src$Compiler$Meta$$ValueDependency = ([
  "$ValueDependency",
]);

const $c$$src$Compiler$Op$$Left = ([
  "$Left",
]);

const $c$$src$Compiler$Op$$NonAssociative = ([
  "$NonAssociative",
]);

const $c$$src$Compiler$Op$$Right = ([
  "$Right",
]);

const $c$$src$Compiler$Op$$UnopMinus = ([
  "$UnopMinus",
]);

const $c$$src$Compiler$Op$$UnopPlus = ([
  "$UnopPlus",
]);

const $c$$src$Compiler$Op$$UnopRecycle = ([
  "$UnopRecycle",
]);

const $c$$src$Compiler$Op$$UnopUnique = ([
  "$UnopUnique",
]);

const $c$$src$Compiler$Pos$$At = (($1, $2) => ([
  "$At",
  $1,
  $2,
]));

const $c$$src$Compiler$Pos$$End = ([
  "$End",
]);

const $c$$src$Compiler$Pos$$G = ([
  "$G",
]);

const $c$$src$Compiler$Pos$$I = (($1) => ([
  "$I",
  $1,
]));

const $c$$src$Compiler$Pos$$N = ([
  "$N",
]);

const $c$$src$Compiler$Pos$$P = (($1, $2) => ([
  "$P",
  $1,
  $2,
]));

const $c$$src$Compiler$Pos$$S = ([
  "$S",
]);

const $c$$src$Compiler$Pos$$T = ([
  "$T",
]);

const $c$$src$Compiler$Token$$ArgumentPlaceholder = ([
  "$ArgumentPlaceholder",
]);

const $c$$src$Compiler$Token$$As = ([
  "$As",
]);

const $c$$src$Compiler$Token$$Binop = (($1, $2) => ([
  "$Binop",
  $1,
  $2,
]));

const $c$$src$Compiler$Token$$BlockEnd = ([
  "$BlockEnd",
]);

const $c$$src$Compiler$Token$$BlockStart = ([
  "$BlockStart",
]);

const $c$$src$Compiler$Token$$Closed = ([
  "$Closed",
]);

const $c$$src$Compiler$Token$$Colon = ([
  "$Colon",
]);

const $c$$src$Compiler$Token$$Comma = ([
  "$Comma",
]);

const $c$$src$Compiler$Token$$Comment = (($1) => ([
  "$Comment",
  $1,
]));

const $c$$src$Compiler$Token$$Constructor = (($1) => ([
  "$Constructor",
  $1,
]));

const $c$$src$Compiler$Token$$CurlyBrace = (($1, $2) => ([
  "$CurlyBrace",
  $1,
  $2,
]));

const $c$$src$Compiler$Token$$Defop = ([
  "$Defop",
]);

const $c$$src$Compiler$Token$$Else = (($1) => ([
  "$Else",
  $1,
]));

const $c$$src$Compiler$Token$$Fn = ([
  "$Fn",
]);

const $c$$src$Compiler$Token$$If = (($1) => ([
  "$If",
  $1,
]));

const $c$$src$Compiler$Token$$Lowercase = (($1) => ([
  "$Lowercase",
  $1,
]));

const $c$$src$Compiler$Token$$Native = ([
  "$Native",
]);

const $c$$src$Compiler$Token$$NewSiblingLine = ([
  "$NewSiblingLine",
]);

const $c$$src$Compiler$Token$$NumberLiteral = (($1, $2) => ([
  "$NumberLiteral",
  $1,
  $2,
]));

const $c$$src$Compiler$Token$$Open = ([
  "$Open",
]);

const $c$$src$Compiler$Token$$RecordShorthand = (($1) => ([
  "$RecordShorthand",
  $1,
]));

const $c$$src$Compiler$Token$$RoundParen = (($1) => ([
  "$RoundParen",
  $1,
]));

const $c$$src$Compiler$Token$$SingleQuote = ([
  "$SingleQuote",
]);

const $c$$src$Compiler$Token$$SquareBracket = (($1, $2) => ([
  "$SquareBracket",
  $1,
  $2,
]));

const $c$$src$Compiler$Token$$TextLiteral = (($1, $2) => ([
  "$TextLiteral",
  $1,
  $2,
]));

const $c$$src$Compiler$Token$$Then = ([
  "$Then",
]);

const $c$$src$Compiler$Token$$ThreeDots = ([
  "$ThreeDots",
]);

const $c$$src$Compiler$Token$$Token = (($1, $2, $3) => ([
  "$Token",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$Token$$TripleQuote = ([
  "$TripleQuote",
]);

const $c$$src$Compiler$Token$$Try = ([
  "$Try",
]);

const $c$$src$Compiler$Token$$UniquenessPolymorphismBinop = ([
  "$UniquenessPolymorphismBinop",
]);

const $c$$src$Compiler$Token$$Unop = (($1) => ([
  "$Unop",
  $1,
]));

const $c$$src$Compiler$Token$$Uppercase = (($1) => ([
  "$Uppercase",
  $1,
]));

const $c$$src$Compiler$Token$$With = ([
  "$With",
]);

const $c$$src$Compiler$TypedAst$$ArgumentExpression = (($1, $2) => ([
  "$ArgumentExpression",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$ArgumentRecycle = (($1, $2, $3, $4) => ([
  "$ArgumentRecycle",
  $1,
  $2,
  $3,
  $4,
]));

const $c$$src$Compiler$TypedAst$$Call = (($1, $2, $3) => ([
  "$Call",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$TypedAst$$Constructor = (($1, $2) => ([
  "$Constructor",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$DestroyIn = (($1, $2) => ([
  "$DestroyIn",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$Error = (($1) => ([
  "$Error",
  $1,
]));

const $c$$src$Compiler$TypedAst$$Fn = (($1, $2, $3, $4) => ([
  "$Fn",
  $1,
  $2,
  $3,
  $4,
]));

const $c$$src$Compiler$TypedAst$$If = (($1, $2) => ([
  "$If",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$LetIn = (($1, $2, $3) => ([
  "$LetIn",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$TypedAst$$LiteralNumber = (($1, $2) => ([
  "$LiteralNumber",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$LiteralText = (($1, $2) => ([
  "$LiteralText",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$ParRe = (($1) => ([
  "$ParRe",
  $1,
]));

const $c$$src$Compiler$TypedAst$$ParSp = (($1) => ([
  "$ParSp",
  $1,
]));

const $c$$src$Compiler$TypedAst$$ParameterPattern = (($1, $2) => ([
  "$ParameterPattern",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$ParameterPlaceholder = (($1, $2) => ([
  "$ParameterPlaceholder",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$ParameterRecycle = (($1, $2, $3) => ([
  "$ParameterRecycle",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$TypedAst$$PatternAny = (($1, $2) => ([
  "$PatternAny",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$PatternConstructor = (($1, $2, $3) => ([
  "$PatternConstructor",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$TypedAst$$PatternLiteralNumber = (($1, $2) => ([
  "$PatternLiteralNumber",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$PatternLiteralText = (($1, $2) => ([
  "$PatternLiteralText",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$PatternRecord = (($1, $2) => ([
  "$PatternRecord",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$Record = (($1, $2, $3) => ([
  "$Record",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$TypedAst$$RecordAccess = (($1, $2, $3) => ([
  "$RecordAccess",
  $1,
  $2,
  $3,
]));

const $c$$src$Compiler$TypedAst$$Try = (($1, $2) => ([
  "$Try",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$TypeError = ([
  "$TypeError",
]);

const $c$$src$Compiler$TypedAst$$TypeExact = (($1, $2) => ([
  "$TypeExact",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$TypeFn = (($1, $2) => ([
  "$TypeFn",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$TypeRecord = (($1, $2) => ([
  "$TypeRecord",
  $1,
  $2,
]));

const $c$$src$Compiler$TypedAst$$TypeVar = (($1) => ([
  "$TypeVar",
  $1,
]));

const $c$$src$Compiler$TypedAst$$Variable = (($1, $2) => ([
  "$Variable",
  $1,
  $2,
]));

const $c$$src$Core$$Cons = (($1, $2) => ([
  "$Cons",
  $1,
  $2,
]));

const $c$$src$Core$$False = ([
  "$False",
]);

const $c$$src$Core$$Nil = ([
  "$Nil",
]);

const $c$$src$Core$$None = ([
  "$None",
]);

const $c$$src$Core$$True = ([
  "$True",
]);

const $c$$src$Dict$$RBEmpty_elm_builtin = ([
  "$RBEmpty_elm_builtin",
]);

const $c$$src$Dict$$RBNode_elm_builtin = (($1, $2, $3, $4, $5) => ([
  "$RBNode_elm_builtin",
  $1,
  $2,
  $3,
  $4,
  $5,
]));

const $c$$src$Dict$$Black = ([
  "$Black",
]);

const $c$$src$Dict$$Red = ([
  "$Red",
]);

const $c$$src$Maybe$$Just = (($1) => ([
  "$Just",
  $1,
]));

const $c$$src$Maybe$$Nothing = ([
  "$Nothing",
]);

const $c$$src$Result$$Err = (($1) => ([
  "$Err",
  $1,
]));

const $c$$src$Result$$Ok = (($1) => ([
  "$Ok",
  $1,
]));

const $i$test$$Test$$CodeExpectation = (($1) => ([
  "$CodeExpectation",
  $1,
]));

const $i$test$$Test$$Error = (($1) => ([
  "$Error",
  $1,
]));

const $i$test$$Test$$Group = (($1, $2) => ([
  "$Group",
  $1,
  $2,
]));

const $i$test$$Test$$NotNow = (($1) => ([
  "$NotNow",
  $1,
]));

const $i$test$$Test$$Single = (($1, $2, $3) => ([
  "$Single",
  $1,
  $2,
  $3,
]));

const $i$test$$Test$$Skipped = ([
  "$Skipped",
]);

const $i$test$$Test$$Success = ([
  "$Success",
]);

const $u$$src$Compiler$Error$$FormattedText_Decoration = (($1) => ([
  "$FormattedText_Decoration",
  $1,
]));

const $u$$src$Compiler$Error$$FormattedText_Default = (($1) => ([
  "$FormattedText_Default",
  $1,
]));

const $u$$src$Compiler$Error$$FormattedText_Emphasys = (($1) => ([
  "$FormattedText_Emphasys",
  $1,
]));

const $u$$src$Compiler$Error$$FormattedText_Warning = (($1) => ([
  "$FormattedText_Warning",
  $1,
]));

const $u$$src$Compiler$Error$$HighlightBlock = (($1) => ([
  "$HighlightBlock",
  $1,
]));

const $u$$src$Compiler$Error$$HighlightWord = (($1) => ([
  "$HighlightWord",
  $1,
]));

const $u$$src$Compiler$Error$$Nested = (($1) => ([
  "$Nested",
  $1,
]));

const $u$$src$Compiler$Error$$Raw = (($1) => ([
  "$Raw",
  $1,
]));

const $u$$src$Compiler$Error$$Simple = (($1, $2, $3) => ([
  "$Simple",
  $1,
  $2,
  $3,
]));

const $u$$src$Compiler$LazyBuild$$AliasDef = (($1) => ([
  "$AliasDef",
  $1,
]));

const $u$$src$Compiler$LazyBuild$$ConstructorDef = (($1) => ([
  "$ConstructorDef",
  $1,
]));

const $u$$src$Compiler$LazyBuild$$MissingDef = ([
  "$MissingDef",
]);

const $u$$src$Compiler$LazyBuild$$ValueDef = (($1) => ([
  "$ValueDef",
  $1,
]));

const $u$$src$Compiler$LazyBuild$$VariantTypeDef = (($1) => ([
  "$VariantTypeDef",
  $1,
]));

const $u$$src$Compiler$Lexer$$BlockComment = (($1) => ([
  "$BlockComment",
  $1,
]));

const $u$$src$Compiler$Lexer$$ContentOpeningBlockComment = ([
  "$ContentOpeningBlockComment",
]);

const $u$$src$Compiler$Lexer$$ContentOpeningQuotes_One = ([
  "$ContentOpeningQuotes_One",
]);

const $u$$src$Compiler$Lexer$$ContentOpeningQuotes_Two = ([
  "$ContentOpeningQuotes_Two",
]);

const $u$$src$Compiler$Lexer$$Default = ([
  "$Default",
]);

const $u$$src$Compiler$Lexer$$Dot_One = ([
  "$Dot_One",
]);

const $u$$src$Compiler$Lexer$$Dot_Two = ([
  "$Dot_Two",
]);

const $u$$src$Compiler$Lexer$$Indent = ([
  "$Indent",
]);

const $u$$src$Compiler$Lexer$$LineComment = (($1) => ([
  "$LineComment",
  $1,
]));

const $u$$src$Compiler$Lexer$$Mutable = ([
  "$Mutable",
]);

const $u$$src$Compiler$Lexer$$NoTabsOrSpacesYet = ([
  "$NoTabsOrSpacesYet",
]);

const $u$$src$Compiler$Lexer$$NumberLiteral = ([
  "$NumberLiteral",
]);

const $u$$src$Compiler$Lexer$$SingleQuote = (($1) => ([
  "$SingleQuote",
  $1,
]));

const $u$$src$Compiler$Lexer$$Spaces = ([
  "$Spaces",
]);

const $u$$src$Compiler$Lexer$$Squiggles = ([
  "$Squiggles",
]);

const $u$$src$Compiler$Lexer$$Tabs = ([
  "$Tabs",
]);

const $u$$src$Compiler$Lexer$$TripleQuote = (($1) => ([
  "$TripleQuote",
  $1,
]));

const $u$$src$Compiler$Lexer$$Word = ([
  "$Word",
]);

const $u$$src$Compiler$MakeEmittable$$GenerateName = ([
  "$GenerateName",
]);

const $u$$src$Compiler$MakeEmittable$$NoNamedVariables = ([
  "$NoNamedVariables",
]);

const $u$$src$Compiler$MakeEmittable$$TrivialPattern = (($1, $2) => ([
  "$TrivialPattern",
  $1,
  $2,
]));

const $u$$src$Compiler$Parser$$E_full = (($1) => ([
  "$E_full",
  $1,
]));

const $u$$src$Compiler$Parser$$E_under = (($1) => ([
  "$E_under",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$CanBeCastNo = (($1) => ([
  "$CanBeCastNo",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$CanBeCastYes = ([
  "$CanBeCastYes",
]);

const $u$$src$Compiler$TypeCheck$$Context_Argument = (($1, $2) => ([
  "$Context_Argument",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$Context_AttributeName = (($1, $2) => ([
  "$Context_AttributeName",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$Context_FnBody = (($1, $2) => ([
  "$Context_FnBody",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$Context_FnPar = (($1, $2) => ([
  "$Context_FnPar",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$Context_Global = ([
  "$Context_Global",
]);

const $u$$src$Compiler$TypeCheck$$Context_IfCondition = ([
  "$Context_IfCondition",
]);

const $u$$src$Compiler$TypeCheck$$Context_IfFalse = ([
  "$Context_IfFalse",
]);

const $u$$src$Compiler$TypeCheck$$Context_IfTrue = ([
  "$Context_IfTrue",
]);

const $u$$src$Compiler$TypeCheck$$Context_LetInBody = (($1) => ([
  "$Context_LetInBody",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$Context_TryBranch = ([
  "$Context_TryBranch",
]);

const $u$$src$Compiler$TypeCheck$$ErrorCallingANonFunction = (($1) => ([
  "$ErrorCallingANonFunction",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorConstructorNotFound = (($1) => ([
  "$ErrorConstructorNotFound",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorIncompatiblePattern = (($1, $2) => ([
  "$ErrorIncompatiblePattern",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$ErrorIncompatibleTypes = (($1, $2) => ([
  "$ErrorIncompatibleTypes",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$ErrorNotCompatibleWithRecord = ([
  "$ErrorNotCompatibleWithRecord",
]);

const $u$$src$Compiler$TypeCheck$$ErrorRecordDoesNotHaveAttribute = (($1) => ([
  "$ErrorRecordDoesNotHaveAttribute",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorRecordHasAttributesNotInAnnotation = (($1) => ([
  "$ErrorRecordHasAttributesNotInAnnotation",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorRecordIsMissingAttibutesInAnnotation = (($1) => ([
  "$ErrorRecordIsMissingAttibutesInAnnotation",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorRecyclingDoesNotMatch = ([
  "$ErrorRecyclingDoesNotMatch",
]);

const $u$$src$Compiler$TypeCheck$$ErrorShouldBeUnique = ([
  "$ErrorShouldBeUnique",
]);

const $u$$src$Compiler$TypeCheck$$ErrorTryingToAccessAttributeOfNonRecord = (($1, $2) => ([
  "$ErrorTryingToAccessAttributeOfNonRecord",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$ErrorTypeNotFound = (($1) => ([
  "$ErrorTypeNotFound",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorTyvarNotIndependent = (($1) => ([
  "$ErrorTyvarNotIndependent",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorUndefinedTypeVariable = (($1) => ([
  "$ErrorUndefinedTypeVariable",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorUniquenessDoesNotMatch = (($1) => ([
  "$ErrorUniquenessDoesNotMatch",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorUniquenessDoesNotMatchArgument = ([
  "$ErrorUniquenessDoesNotMatchArgument",
]);

const $u$$src$Compiler$TypeCheck$$ErrorUniquenessDoesNotMatchParameter = (($1, $2) => ([
  "$ErrorUniquenessDoesNotMatchParameter",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$ErrorUnresolvableUniqueness = (($1, $2) => ([
  "$ErrorUnresolvableUniqueness",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$ErrorVariableNotFound = (($1) => ([
  "$ErrorVariableNotFound",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfArguments = (($1) => ([
  "$ErrorWrongNumberOfArguments",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfConstructorArguments = ([
  "$ErrorWrongNumberOfConstructorArguments",
]);

const $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfParameters = ([
  "$ErrorWrongNumberOfParameters",
]);

const $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfTypeArguments = (($1, $2, $3) => ([
  "$ErrorWrongNumberOfTypeArguments",
  $1,
  $2,
  $3,
]));

const $u$$src$Compiler$TypeCheck$$Why_Annotation = ([
  "$Why_Annotation",
]);

const $u$$src$Compiler$TypeCheck$$Why_Argument = (($1) => ([
  "$Why_Argument",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$Why_Attribute = (($1) => ([
  "$Why_Attribute",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$Why_CalledAsFunction = ([
  "$Why_CalledAsFunction",
]);

const $u$$src$Compiler$TypeCheck$$Why_FunctionInput = (($1, $2) => ([
  "$Why_FunctionInput",
  $1,
  $2,
]));

const $u$$src$Compiler$TypeCheck$$Why_FunctionOutput = (($1) => ([
  "$Why_FunctionOutput",
  $1,
]));

const $u$$src$Compiler$TypeCheck$$Why_IfBranches = ([
  "$Why_IfBranches",
]);

const $u$$src$Compiler$TypeCheck$$Why_IfCondition = ([
  "$Why_IfCondition",
]);

const $u$$src$Compiler$TypeCheck$$Why_LetIn = ([
  "$Why_LetIn",
]);

const $u$$src$Compiler$TypeCheck$$Why_Record = ([
  "$Why_Record",
]);

const $u$$src$Compiler$TypeCheck$$Why_RecordAccess = ([
  "$Why_RecordAccess",
]);

const $u$$src$Compiler$TypeCheck$$Why_RecordExt = ([
  "$Why_RecordExt",
]);

const $u$$src$Compiler$TypeCheck$$Why_TryExpression = ([
  "$Why_TryExpression",
]);

const $u$$src$Compiler$TypeCheck$$Why_TryPattern = ([
  "$Why_TryPattern",
]);

const $u$$src$Compiler$TypeCheck$$Why_TypeArgument = (($1, $2, $3) => ([
  "$Why_TypeArgument",
  $1,
  $2,
  $3,
]));

const $u$$src$Compiler$UniquenessCheck$$Available = ([
  "$Available",
]);

const $u$$src$Compiler$UniquenessCheck$$ConsumedAt = (($1) => ([
  "$ConsumedAt",
  $1,
]));

const $u$$src$Compiler$UniquenessCheck$$Immutable = ([
  "$Immutable",
]);

const $u$$src$Compiler$UniquenessCheck$$Unique = (($1) => ([
  "$Unique",
  $1,
]));

const $u$$src$ImportsFile$$Core = ([
  "$Core",
]);

const $u$$src$ImportsFile$$Dir = (($1) => ([
  "$Dir",
  $1,
]));

const $u$$src$ImportsFile$$Installed = (($1) => ([
  "$Installed",
  $1,
]));

const $u$$src$ImportsFile$$Lib = (($1) => ([
  "$Lib",
  $1,
]));

const $u$$src$ImportsFile$$Local = (($1) => ([
  "$Local",
  $1,
]));

const $u$$src$SPLib$Format$$Blank = ([
  "$Blank",
]);

const $u$$src$SPLib$Format$$CommentIgnoreIndent = (($1) => ([
  "$CommentIgnoreIndent",
  $1,
]));

const $u$$src$SPLib$Format$$CommentWithIndent = (($1) => ([
  "$CommentWithIndent",
  $1,
]));

const $u$$src$SPLib$Format$$Empty = ([
  "$Empty",
]);

const $u$$src$SPLib$Format$$Indented = (($1, $2) => ([
  "$Indented",
  $1,
  $2,
]));

const $u$$src$SPLib$Format$$MustBreakAtEnd = ([
  "$MustBreakAtEnd",
]);

const $u$$src$SPLib$Format$$NoRequiredBreaks = ([
  "$NoRequiredBreaks",
]);

const $u$$src$SPLib$Format$$Row = (($1, $2) => ([
  "$Row",
  $1,
  $2,
]));

const $u$$src$SPLib$Format$$SingleLine = (($1, $2) => ([
  "$SingleLine",
  $1,
  $2,
]));

const $u$$src$SPLib$Format$$Space = ([
  "$Space",
]);

const $u$$src$SPLib$Format$$Stack = (($1, $2) => ([
  "$Stack",
  $1,
  $2,
]));

const $u$$src$SPLib$Format$$Text_ = (($1) => ([
  "$Text_",
  $1,
]));

const $u$$src$SPLib$Parser$$Aborted = (($1, $2) => ([
  "$Aborted",
  $1,
  $2,
]));

const $u$$src$SPLib$Parser$$Accepted = (($1, $2) => ([
  "$Accepted",
  $1,
  $2,
]));

const $u$$src$SPLib$Parser$$Rejected = ([
  "$Rejected",
]);

const $u$$src$SPLib$SPON$$Accepted = (($1, $2) => ([
  "$Accepted",
  $1,
  $2,
]));

const $u$$src$SPLib$SPON$$Failed = (($1) => ([
  "$Failed",
  $1,
]));

const $u$$src$SPLib$SPON$$Rejected = (($1) => ([
  "$Rejected",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$AccessWithBrackets = (($1, $2) => ([
  "$AccessWithBrackets",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$AccessWithDot = (($1, $2) => ([
  "$AccessWithDot",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$Array = (($1) => ([
  "$Array",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$Binop = (($1, $2, $3) => ([
  "$Binop",
  $1,
  $2,
  $3,
]));

const $u$$src$Targets$Javascript$Ast$$BlockLambda = (($1, $2) => ([
  "$BlockLambda",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$Call = (($1, $2) => ([
  "$Call",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$Comma = (($1) => ([
  "$Comma",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$Conditional = (($1, $2, $3) => ([
  "$Conditional",
  $1,
  $2,
  $3,
]));

const $u$$src$Targets$Javascript$Ast$$Define = (($1, $2, $3) => ([
  "$Define",
  $1,
  $2,
  $3,
]));

const $u$$src$Targets$Javascript$Ast$$Eval = (($1) => ([
  "$Eval",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$If = (($1, $2) => ([
  "$If",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$Literal = (($1) => ([
  "$Literal",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$Mutop = (($1, $2, $3, $4) => ([
  "$Mutop",
  $1,
  $2,
  $3,
  $4,
]));

const $u$$src$Targets$Javascript$Ast$$Record = (($1) => ([
  "$Record",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$Return = (($1) => ([
  "$Return",
  $1,
]));

const $u$$src$Targets$Javascript$Ast$$SimpleLambda = (($1, $2) => ([
  "$SimpleLambda",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$Unop = (($1, $2) => ([
  "$Unop",
  $1,
  $2,
]));

const $u$$src$Targets$Javascript$Ast$$Var = (($1) => ([
  "$Var",
  $1,
]));

const $u$$src$Targets$Javascript$EmittableToJs$$Block = (($1) => ([
  "$Block",
  $1,
]));

const $u$$src$Targets$Javascript$EmittableToJs$$Inline = (($1) => ([
  "$Inline",
  $1,
]));

const $u$$src$Targets$Javascript$EmittableToJs$$Override = (($1) => ([
  "$Override",
  $1,
]));

const $i$test$$Test$$maybeToOutcome = (($m) => {
  return ((($m)[0] === "$Just")
    ? ((() => {
      const $e = ($m)[1];
      return ($i$test$$Test$$Error)($e);
    }))()
    : ((($m)[0] === "$Nothing")
      ? $i$test$$Test$$Success
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 15:4', (sp_toHuman)($m))));
});

const $i$test$$Test$$valueTest = (($toText, $title, $generateValue, $ce) => {
  const $5 = $ce;
  const $toMaybeError = ($5)[1];
  return ($i$test$$Test$$Single)($title, "", ((_0) => {
    return ($i$test$$Test$$maybeToOutcome)(((($0) => {
      return ($toMaybeError)($toText, $0);
    }))(($c$$src$Result$$Ok)(($generateValue)(null))));
  }));
});

const $c$$src$Array_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $c$$src$Text$$join = (($sep, $listOfText) => {
  return ((($listOfText)[0] === "$Nil")
    ? ""
    : ((($listOfText)[0] === "$Cons")
      ? ((() => {
        const $head = ($listOfText)[1];
        const $tail = ($listOfText)[2];
        const $rec = (($ls, $acc) => {
          return ((($ls)[0] === "$Nil")
            ? $acc
            : ((($ls)[0] === "$Cons")
              ? ((() => {
                const $h = ($ls)[1];
                const $t = ($ls)[2];
                return ($rec)($t, ($acc + ($sep + $h)));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 139:16', (sp_toHuman)($ls))));
        });
        return ($rec)($tail, $head);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 131:4', (sp_toHuman)($listOfText))));
});

const $i$test$$Test$$isOkAndEqualTo = (($expectedOk) => {
  return ($i$test$$Test$$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($c$$src$Maybe$$Just)($e);
      }))()
      : ((($result)[0] === "$Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return ((sp_equal)($actualOk, $expectedOk)
            ? $c$$src$Maybe$$Nothing
            : ($c$$src$Maybe$$Just)(((($0) => {
              return ($c$$src$Text$$join)("\n", $0);
            }))(($c$$src$Core$$Cons)("expected = ", ($c$$src$Core$$Cons)(($toText)($expectedOk), ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)("actual = ", ($c$$src$Core$$Cons)(($toText)($actualOk), $c$$src$Core$$Nil))))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 73:8', (sp_toHuman)($result))));
  }));
});

const $c$$src$Array_Test$$tests = ($i$test$$Test$$Group)("Array", ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("push", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil));
  ((__re__ = (array_push)($a, "b")), ($a = (__re__)[1]), (__re__)[0]);
  ((__re__ = (array_push)($a, "c")), ($a = (__re__)[1]), (__re__)[0]);
  return ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("a", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("c", $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("pop 1", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)("x", ($c$$src$Core$$Cons)("y", ($c$$src$Core$$Cons)("z", $c$$src$Core$$Nil))));
  const $b = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $c = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  b: ($c$$src$Maybe$$Just)("z"),
  c: ($c$$src$Maybe$$Just)("y"),
  l: ($c$$src$Core$$Cons)("x", $c$$src$Core$$Nil),
}))), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("pop empty", ((_0) => {
  let $a = (array_fromList)($c$$src$Core$$Nil);
  const $b = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    b: $b,
    l: $l,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  b: $c$$src$Maybe$$Nothing,
  l: $c$$src$Core$$Nil,
}))), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("get Just", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)("p", ($c$$src$Core$$Cons)("q", $c$$src$Core$$Nil)));
  return ((__re__ = (array_get)($a, 1)), ($a = (__re__)[1]), (__re__)[0]);
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Maybe$$Just)("q"))), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("get Nothing", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)("p", ($c$$src$Core$$Cons)("q", $c$$src$Core$$Nil)));
  return ((__re__ = (array_get)($a, 3)), ($a = (__re__)[1]), (__re__)[0]);
}), ($i$test$$Test$$isOkAndEqualTo)($c$$src$Maybe$$Nothing)), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("set success", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)(8, ($c$$src$Core$$Cons)(9, $c$$src$Core$$Nil)));
  const $r = ((__re__ = (array_set)($a, 0, 10)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    l: $l,
    r: $r,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  l: ($c$$src$Core$$Cons)(10, ($c$$src$Core$$Cons)(9, $c$$src$Core$$Nil)),
  r: true,
}))), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("set fail", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)(8, ($c$$src$Core$$Cons)(9, $c$$src$Core$$Nil)));
  const $r = ((__re__ = (array_set)($a, 3, 10)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    l: $l,
    r: $r,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  l: ($c$$src$Core$$Cons)(8, ($c$$src$Core$$Cons)(9, $c$$src$Core$$Nil)),
  r: false,
}))), ($c$$src$Core$$Cons)(($c$$src$Array_Test$$valueTest)("sortBy", ((_0) => {
  let $a = (array_fromList)(($c$$src$Core$$Cons)(55, ($c$$src$Core$$Cons)(99, ($c$$src$Core$$Cons)(22, $c$$src$Core$$Nil))));
  ((__re__ = (array_sortBy)($a, (($x) => {
    return -($x);
  }))), ($a = (__re__)[1]), (__re__)[0]);
  return ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(99, ($c$$src$Core$$Cons)(55, ($c$$src$Core$$Cons)(22, $c$$src$Core$$Nil))))), $c$$src$Core$$Nil)))))))));

const $c$$src$Basics$$identity = (($a) => {
  return $a;
});

const $c$$src$Basics$$applyIf = (($condition, $f) => {
  return ($condition
    ? $f
    : $c$$src$Basics$$identity);
});

const $c$$src$Basics$$btw = (($f, $a, $c) => {
  ($f)($a);
  return $c;
});

const $c$$src$Basics$$clamp = (($low, $high, $n) => {
  return (($n < $low)
    ? $low
    : (($n > $high)
      ? $high
      : $n));
});

const $c$$src$Basics$$max = (($a, $b) => {
  return (($a > $b)
    ? $a
    : $b);
});

const $c$$src$Basics$$min = (($a, $b) => {
  return (($a < $b)
    ? $a
    : $b);
});

const $c$$src$Basics$$not = (($b) => {
  return ($b
    ? false
    : true);
});

const $c$$src$Compiler$Ast$$toImm = (($raw) => {
  return ({
    raw: $raw,
    uni: $c$$src$Compiler$Ast$$Imm,
  });
});

const $c$$src$Compiler$Ast$$toUni = (($raw) => {
  return ({
    raw: $raw,
    uni: $c$$src$Compiler$Ast$$Uni,
  });
});

const $c$$src$Compiler$CanonicalAst$$expressionPos = (($exp) => {
  return ((($exp)[0] === "$LiteralNumber")
    ? ((() => {
      const $p = ($exp)[1];
      return $p;
    }))()
    : ((($exp)[0] === "$LiteralText")
      ? ((() => {
        const $p = ($exp)[1];
        return $p;
      }))()
      : ((($exp)[0] === "$Variable")
        ? ((() => {
          const $p = ($exp)[1];
          return $p;
        }))()
        : ((($exp)[0] === "$Constructor")
          ? ((() => {
            const $p = ($exp)[1];
            return $p;
          }))()
          : ((($exp)[0] === "$Fn")
            ? ((() => {
              const $p = ($exp)[1];
              return $p;
            }))()
            : ((($exp)[0] === "$Call")
              ? ((() => {
                const $p = ($exp)[1];
                return $p;
              }))()
              : ((($exp)[0] === "$Record")
                ? ((() => {
                  const $p = ($exp)[1];
                  return $p;
                }))()
                : ((($exp)[0] === "$RecordAccess")
                  ? ((() => {
                    const $p = ($exp)[1];
                    return $p;
                  }))()
                  : ((($exp)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($exp)[1];
                      const $e = ($exp)[2];
                      return ($c$$src$Compiler$CanonicalAst$$expressionPos)($e);
                    }))()
                    : ((($exp)[0] === "$If")
                      ? ((() => {
                        const $p = ($exp)[1];
                        return $p;
                      }))()
                      : ((($exp)[0] === "$Try")
                        ? ((() => {
                          const $p = ($exp)[1];
                          return $p;
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 280:4', (sp_toHuman)($exp)))))))))))));
});

const $c$$src$Dict$$empty = $c$$src$Dict$$RBEmpty_elm_builtin;

const $c$$src$Compiler$CanonicalAst$$initModule = (($fsPath, $umr, $asText) => {
  return ({
    aliasDefs: $c$$src$Dict$$empty,
    asText: $asText,
    constructorDefs: $c$$src$Dict$$empty,
    fsPath: $fsPath,
    umr: $umr,
    valueDefs: $c$$src$Dict$$empty,
    variantTypeDefs: $c$$src$Dict$$empty,
  });
});

const $c$$src$Compiler$CanonicalAst$$parTypeToRaw = (($p) => {
  return ((($p)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($p)[1];
      return $raw;
    }))()
    : ((($p)[0] === "$ParSp")
      ? ((() => {
        const $full = ($p)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 169:4', (sp_toHuman)($p))));
});

const $c$$src$Dict$$for = (($acc, $dict, $func) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? $acc
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ($c$$src$Dict$$for)(($func)($key, $value, ($c$$src$Dict$$for)($acc, $left, $func)), $right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 361:4', (sp_toHuman)($dict))));
});

const $c$$src$List$$for = (($init, $aList, $function) => {
  return ((($aList)[0] === "$Nil")
    ? $init
    : ((($aList)[0] === "$Cons")
      ? ((() => {
        const $h = ($aList)[1];
        const $tail = ($aList)[2];
        return ($c$$src$List$$for)(($function)($h, $init), $tail, $function);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 80:4', (sp_toHuman)($aList))));
});

const $c$$src$Compiler$CanonicalAst$$patternNames = ((() => {
  const $rec = (($p, $acc) => {
    return (((($p)[0] === "$PatternAny") && ((($p)[2])[0] === "$Nothing"))
      ? ((() => {
        const $pos = ($p)[1];
        return $acc;
      }))()
      : (((($p)[0] === "$PatternAny") && ((($p)[2])[0] === "$Just"))
        ? ((() => {
          const $pos = ($p)[1];
          const $name = (($p)[2])[1];
          const $maybeAnnotation = ($p)[3];
          return ($c$$src$Core$$Cons)(({
            maybeAnnotation: $maybeAnnotation,
            name: $name,
            pos: $pos,
          }), $acc);
        }))()
        : ((($p)[0] === "$PatternLiteralNumber")
          ? ((() => {
            const $pos = ($p)[1];
            return $acc;
          }))()
          : ((($p)[0] === "$PatternLiteralText")
            ? ((() => {
              const $pos = ($p)[1];
              return $acc;
            }))()
            : ((($p)[0] === "$PatternConstructor")
              ? ((() => {
                const $pos = ($p)[1];
                const $path = ($p)[2];
                const $ps = ($p)[3];
                return ($c$$src$List$$for)($acc, $ps, $rec);
              }))()
              : ((($p)[0] === "$PatternRecord")
                ? ((() => {
                  const $pos = ($p)[1];
                  const $ps = ($p)[3];
                  return ($c$$src$Dict$$for)($acc, $ps, (($k, $v, $a) => {
                    return ($rec)($v, $a);
                  }));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 267:8', (sp_toHuman)($p))))))));
  });
  return (($0) => {
    return ($rec)($0, $c$$src$Core$$Nil);
  });
}))();

const $c$$src$Compiler$CanonicalAst$$patternPos = (($pa) => {
  return ((($pa)[0] === "$PatternAny")
    ? ((() => {
      const $p = ($pa)[1];
      return $p;
    }))()
    : ((($pa)[0] === "$PatternLiteralText")
      ? ((() => {
        const $p = ($pa)[1];
        return $p;
      }))()
      : ((($pa)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $p = ($pa)[1];
          return $p;
        }))()
        : ((($pa)[0] === "$PatternConstructor")
          ? ((() => {
            const $p = ($pa)[1];
            return $p;
          }))()
          : ((($pa)[0] === "$PatternRecord")
            ? ((() => {
              const $p = ($pa)[1];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 234:4', (sp_toHuman)($pa)))))));
});

const $c$$src$Dict$$balance = (($color, $key, $value, $left, $right) => {
  return (((($right)[0] === "$RBNode_elm_builtin") && ((($right)[1])[0] === "$Red"))
    ? ((() => {
      const $rK = ($right)[2];
      const $rV = ($right)[3];
      const $rLeft = ($right)[4];
      const $rRight = ($right)[5];
      return (((($left)[0] === "$RBNode_elm_builtin") && ((($left)[1])[0] === "$Red"))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $lLeft = ($left)[4];
          const $lRight = ($left)[5];
          return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $key, $value, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $lK, $lV, $lLeft, $lRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $rK, $rV, $rLeft, $rRight));
        }))()
        : (true
          ? ($c$$src$Dict$$RBNode_elm_builtin)($color, $rK, $rV, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $key, $value, $left, $rLeft), $rRight)
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 84:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? (((($left)[0] === "$RBNode_elm_builtin") && (((($left)[1])[0] === "$Red") && (((($left)[4])[0] === "$RBNode_elm_builtin") && (((($left)[4])[1])[0] === "$Red"))))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $llK = (($left)[4])[2];
          const $llV = (($left)[4])[3];
          const $llLeft = (($left)[4])[4];
          const $llRight = (($left)[4])[5];
          const $lRight = ($left)[5];
          return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $llK, $llV, $llLeft, $llRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $key, $value, $lRight, $right));
        }))()
        : (true
          ? ($c$$src$Dict$$RBNode_elm_builtin)($color, $key, $value, $left, $right)
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 89:12', (sp_toHuman)($left))))
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 81:4', (sp_toHuman)($right))));
});

const $c$$src$Dict$$insertHelp = (($key, $value, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $key, $value, $c$$src$Dict$$RBEmpty_elm_builtin, $c$$src$Dict$$RBEmpty_elm_builtin)
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $nColor = ($dict)[1];
        const $nKey = ($dict)[2];
        const $nValue = ($dict)[3];
        const $nLeft = ($dict)[4];
        const $nRight = ($dict)[5];
        const $4 = (basics_compare)($key, $nKey);
        return ((1 === $4)
          ? ($c$$src$Dict$$balance)($nColor, $nKey, $nValue, $nLeft, ($c$$src$Dict$$insertHelp)($key, $value, $nRight))
          : ((0 === $4)
            ? ($c$$src$Dict$$RBNode_elm_builtin)($nColor, $nKey, $value, $nLeft, $nRight)
            : (true
              ? ($c$$src$Dict$$balance)($nColor, $nKey, $nValue, ($c$$src$Dict$$insertHelp)($key, $value, $nLeft), $nRight)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 73:12', (sp_toHuman)($4)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 65:4', (sp_toHuman)($dict))));
});

const $c$$src$Dict$$insert = (($key, $value, $dict) => {
  const $4 = ($c$$src$Dict$$insertHelp)($key, $value, $dict);
  return (((($4)[0] === "$RBNode_elm_builtin") && ((($4)[1])[0] === "$Red"))
    ? ((() => {
      const $k = ($4)[2];
      const $v = ($4)[3];
      const $l = ($4)[4];
      const $r = ($4)[5];
      return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $4;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 58:4', (sp_toHuman)($4))));
});

const $c$$src$Dict$$join = (($0, $1) => {
  return ($c$$src$Dict$$for)($0, $1, $c$$src$Dict$$insert);
});

const $c$$src$Dict$$ofOne = (($key, $value) => {
  return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $key, $value, $c$$src$Dict$$RBEmpty_elm_builtin, $c$$src$Dict$$RBEmpty_elm_builtin);
});

const $c$$src$Dict$$forReversed = (($acc, $t, $func) => {
  return ((($t)[0] === "$RBEmpty_elm_builtin")
    ? $acc
    : ((($t)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($t)[2];
        const $value = ($t)[3];
        const $left = ($t)[4];
        const $right = ($t)[5];
        return ($c$$src$Dict$$forReversed)(($func)($key, $value, ($c$$src$Dict$$forReversed)($acc, $right, $func)), $left, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 383:4', (sp_toHuman)($t))));
});

const $c$$src$Dict$$values = (($0) => {
  return ($c$$src$Dict$$forReversed)($c$$src$Core$$Nil, $0, (($key, $value, $valueList) => {
    return ($c$$src$Core$$Cons)($value, $valueList);
  }));
});

const $c$$src$List$$reverse = (($aList) => {
  return ($c$$src$List$$for)($c$$src$Core$$Nil, $aList, $c$$src$Core$$Cons);
});

const $c$$src$List$$forReversed = (($init, $list, $f) => {
  const $foldrHelper = (($acc, $ctr, $ls) => {
    return ((($ls)[0] === "$Nil")
      ? $acc
      : ((($ls)[0] === "$Cons")
        ? ((() => {
          const $a = ($ls)[1];
          const $r1 = ($ls)[2];
          return ((($r1)[0] === "$Nil")
            ? ($f)($a, $acc)
            : ((($r1)[0] === "$Cons")
              ? ((() => {
                const $b = ($r1)[1];
                const $r2 = ($r1)[2];
                return ((($r2)[0] === "$Nil")
                  ? ($f)($a, ($f)($b, $acc))
                  : ((($r2)[0] === "$Cons")
                    ? ((() => {
                      const $c = ($r2)[1];
                      const $r3 = ($r2)[2];
                      return ((($r3)[0] === "$Nil")
                        ? ($f)($a, ($f)($b, ($f)($c, $acc)))
                        : ((($r3)[0] === "$Cons")
                          ? ((() => {
                            const $d = ($r3)[1];
                            const $r4 = ($r3)[2];
                            const $res = (($ctr > 500)
                              ? ($c$$src$List$$for)($acc, ($c$$src$List$$reverse)($r4), $f)
                              : ($foldrHelper)($acc, ($ctr + 1), $r4));
                            return ($f)($a, ($f)($b, ($f)($c, ($f)($d, $res))));
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 125:32', (sp_toHuman)($r3))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 119:24', (sp_toHuman)($r2))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 113:16', (sp_toHuman)($r1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 107:8', (sp_toHuman)($ls))));
  });
  return ($foldrHelper)($init, 0, $list);
});

const $c$$src$List$$map = (($f, $list) => {
  return ($c$$src$List$$forReversed)($c$$src$Core$$Nil, $list, (($x, $acc) => {
    return (sp_cons)(($f)($x), $acc);
  }));
});

const $c$$src$Compiler$CanonicalAst$$typeTyvars = (($raw) => {
  const $fromList = (($list) => {
    return ($c$$src$List$$for)($c$$src$Dict$$empty, $list, (($item, $acc) => {
      return ($c$$src$Dict$$join)($acc, ($c$$src$Compiler$CanonicalAst$$typeTyvars)($item));
    }));
  });
  return ((($raw)[0] === "$TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList)($args);
    }))()
    : ((($raw)[0] === "$TypeFn")
      ? ((() => {
        const $pars = ($raw)[2];
        const $to = ($raw)[3];
        return ($fromList)((sp_cons)($to.raw, ($c$$src$List$$map)($c$$src$Compiler$CanonicalAst$$parTypeToRaw, $pars)));
      }))()
      : ((($raw)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($raw)[2];
          return ($fromList)(($c$$src$Dict$$values)($attrs));
        }))()
        : ((($raw)[0] === "$TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($raw)[1];
            const $name = ($raw)[2];
            return ($c$$src$Dict$$ofOne)($name, $pos);
          }))()
          : ((($raw)[0] === "$TypeError")
            ? $c$$src$Dict$$empty
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 180:4', (sp_toHuman)($raw)))))));
});

const $c$$src$Compiler$CanonicalAst$$typeUnivars = (($raw) => {
  const $fromList = (($list) => {
    return ($c$$src$List$$for)($c$$src$Dict$$empty, $list, (($item, $acc) => {
      return ($c$$src$Dict$$join)($acc, ($c$$src$Compiler$CanonicalAst$$typeUnivars)($item));
    }));
  });
  const $insertUni = (($uni, $acc) => {
    return ((($uni)[0] === "$Depends")
      ? ((() => {
        const $uid = ($uni)[1];
        return ($c$$src$Dict$$insert)($uid, null, $acc);
      }))()
      : (true
        ? $acc
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 196:8', (sp_toHuman)($uni))));
  });
  const $parUnivars = (($par, $acc) => {
    return ((($par)[0] === "$ParRe")
      ? $acc
      : ((($par)[0] === "$ParSp")
        ? ((() => {
          const $full = ($par)[1];
          return ((($0) => {
            return ($insertUni)($full.uni, $0);
          }))(((($0) => {
            return ($c$$src$Dict$$join)($0, ($c$$src$Compiler$CanonicalAst$$typeUnivars)($full.raw));
          }))($acc));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 202:8', (sp_toHuman)($par))));
  });
  return ((($raw)[0] === "$TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList)($args);
    }))()
    : ((($raw)[0] === "$TypeRecord")
      ? ((() => {
        const $attrs = ($raw)[2];
        return ($fromList)(($c$$src$Dict$$values)($attrs));
      }))()
      : ((($raw)[0] === "$TypeAnnotationVariable")
        ? ((() => {
          const $pos = ($raw)[1];
          const $name = ($raw)[2];
          return $c$$src$Dict$$empty;
        }))()
        : ((($raw)[0] === "$TypeError")
          ? $c$$src$Dict$$empty
          : ((($raw)[0] === "$TypeFn")
            ? ((() => {
              const $pars = ($raw)[2];
              const $to = ($raw)[3];
              return ((($0) => {
                return ($c$$src$List$$for)($0, $pars, $parUnivars);
              }))(((($0) => {
                return ($insertUni)($to.uni, $0);
              }))($c$$src$Dict$$empty));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 212:4', (sp_toHuman)($raw)))))));
});

const $c$$src$Compiler$FormattableAst$$binopChainAllBinops = (($f, $ls) => {
  const $3 = $ls.second;
  return ((($3)[0] === "$Nil")
    ? true
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $sep = ($3)[1].first;
        const $item = ($3)[1].second;
        const $tail = ($3)[2];
        return (($f)($sep)
          ? ($c$$src$Compiler$FormattableAst$$binopChainAllBinops)($f, ({
            first: $item,
            second: $tail,
          }))
          : false);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 172:4', (sp_toHuman)($3))));
});

const $c$$src$Tuple$$second = (($t) => {
  return $t.second;
});

const $c$$src$Compiler$FormattableAst$$binopChainExpressions = (($1) => {
  const $head = $1.first;
  const $tuples = $1.second;
  return (sp_cons)($head, ($c$$src$List$$map)($c$$src$Tuple$$second, $tuples));
});

const $c$$src$Compiler$FormattableAst$$binopChainReverse = ((() => {
  const $rec = (($acc, $1) => {
    const $oddItem = $1.first;
    const $remainder = $1.second;
    return ((($remainder)[0] === "$Nil")
      ? ({
        first: $oddItem,
        second: $acc,
      })
      : ((($remainder)[0] === "$Cons")
        ? ((() => {
          const $sep = ($remainder)[1].first;
          const $item = ($remainder)[1].second;
          const $tail = ($remainder)[2];
          return ($rec)(($c$$src$Core$$Cons)(({
            first: $sep,
            second: $oddItem,
          }), $acc), ({
            first: $item,
            second: $tail,
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 163:8', (sp_toHuman)($remainder))));
  });
  return (($0) => {
    return ($rec)($c$$src$Core$$Nil, $0);
  });
}))();

const $c$$src$Compiler$FormattableAst$$statementPos = (($statement) => {
  return ((($statement)[0] === "$CommentStatement")
    ? ((() => {
      const $end = ($statement)[1].end;
      const $start = ($statement)[1].start;
      return ($c$$src$Compiler$Pos$$P)($start, $end);
    }))()
    : (((($statement)[0] === "$Evaluation") && ((($statement)[1])[0] === "$Expression"))
      ? ((() => {
        const $pos = (($statement)[1])[2];
        const $expr_ = (($statement)[1])[3];
        return $pos;
      }))()
      : (((($statement)[0] === "$ValueDef") && ((($statement)[1].pattern)[0] === "$Expression"))
        ? ((() => {
          const $body = ($statement)[1].body;
          const $nonFn = ($statement)[1].nonFn;
          const $pos = (($statement)[1].pattern)[2];
          const $expr_ = (($statement)[1].pattern)[3];
          return $pos;
        }))()
        : ((($statement)[0] === "$AliasDef")
          ? ((() => {
            const $args = ($statement)[1].args;
            const $name = ($statement)[1].name;
            const $type = ($statement)[1].type;
            return $name.first;
          }))()
          : ((($statement)[0] === "$UnionDef")
            ? ((() => {
              const $args = ($statement)[1].args;
              const $constructors = ($statement)[1].constructors;
              const $name = ($statement)[1].name;
              return $name.first;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 186:4', (sp_toHuman)($statement)))))));
});

const $c$$src$Compiler$Meta$$initImports = ({
  globalNameToLocation: $c$$src$Dict$$empty,
  moduleAliasToLocation: $c$$src$Dict$$empty,
  modulePathToLocation: $c$$src$Dict$$empty,
});

const $c$$src$Dict$$get = (($targetKey, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? $c$$src$Maybe$$Nothing
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        const $3 = (basics_compare)($targetKey, $key);
        return ((1 === $3)
          ? ($c$$src$Dict$$get)($targetKey, $right)
          : ((0 === $3)
            ? ($c$$src$Maybe$$Just)($value)
            : (true
              ? ($c$$src$Dict$$get)($targetKey, $left)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 25:12', (sp_toHuman)($3)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 19:4', (sp_toHuman)($dict))));
});

const $c$$src$List$$filterMap = (($f, $la) => {
  const $update = (($a, $acc) => {
    const $5 = ($f)($a);
    return ((($5)[0] === "$Just")
      ? ((() => {
        const $b = ($5)[1];
        return (sp_cons)($b, $acc);
      }))()
      : ((($5)[0] === "$Nothing")
        ? $acc
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 347:8', (sp_toHuman)($5))));
  });
  return ($c$$src$List$$forReversed)($c$$src$Core$$Nil, $la, $update);
});

const $c$$src$Result$$onOk = (($f) => {
  return (($result) => {
    return ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($c$$src$Result$$Err)($e);
      }))()
      : ((($result)[0] === "$Ok")
        ? ((() => {
          const $a = ($result)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 16:4', (sp_toHuman)($result))));
  });
});

const $c$$src$Compiler$Meta$$resolveLocation = (($pars, $location, $maybeReferencedModuleAlias, $referencedName) => {
  return ((($location)[0] === "$LocationSourceDir")
    ? ((() => {
      const $umr = ($location)[1];
      return ($c$$src$Result$$Ok)(($c$$src$Compiler$Meta$$USR)($umr, $referencedName));
    }))()
    : ((($location)[0] === "$LocationLibrary")
      ? ((() => {
        const $importsPath = ($location)[1];
        const $modulePath = ($location)[2];
        return (($c$$src$Result$$onOk)((($modulesByPath) => {
          const $6 = ($c$$src$Dict$$get)($modulePath, $modulesByPath);
          return ((($6)[0] === "$Nothing")
            ? ((($maybeReferencedModuleAlias)[0] === "$Just")
              ? ((() => {
                const $referencedModuleAlias = ($maybeReferencedModuleAlias)[1];
                return ($c$$src$Result$$Err)(($pars.makeError)(((($0) => {
                  return ($c$$src$List$$filterMap)($c$$src$Basics$$identity, $0);
                }))(($c$$src$Core$$Cons)(((sp_equal)($referencedModuleAlias, $modulePath)
                  ? $c$$src$Maybe$$Nothing
                  : ($c$$src$Maybe$$Just)(("imports.sp translates `" + ($referencedModuleAlias + ("` as `" + ($modulePath + "`")))))), ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(("However, library $directoryPathOfLibrary does not expose any " + ($modulePath + " module."))), $c$$src$Core$$Nil)))));
              }))()
              : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
                ? ($c$$src$Result$$Err)(($pars.makeError)(($c$$src$Core$$Cons)(("Library cannot find: " + ($modulePath + (" which contains " + $referencedName))), $c$$src$Core$$Nil)))
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 259:24', (sp_toHuman)($maybeReferencedModuleAlias))))
            : ((($6)[0] === "$Just")
              ? ((() => {
                const $moduleUsrByName = ($6)[1];
                const $7 = ($c$$src$Dict$$get)($referencedName, $moduleUsrByName);
                return ((($7)[0] === "$Just")
                  ? ((() => {
                    const $exportOptions = ($7)[1];
                    return ($c$$src$Result$$Ok)($exportOptions.usr);
                  }))()
                  : ((($7)[0] === "$Nothing")
                    ? ((($maybeReferencedModuleAlias)[0] === "$Just")
                      ? ((() => {
                        const $referencedModuleAlias = ($maybeReferencedModuleAlias)[1];
                        return ($c$$src$Result$$Err)(($pars.makeError)(((sp_equal)($referencedModuleAlias, $modulePath)
                          ? ($c$$src$Core$$Cons)(($modulePath + (" in library $directoryPathOfLibrary does not expose any `" + ($referencedName + "`."))), $c$$src$Core$$Nil)
                          : ($c$$src$Core$$Cons)(("imports.sp translates `" + ($referencedModuleAlias + ("` as `" + ($modulePath + "`")))), ($c$$src$Core$$Cons)(("However, " + ($modulePath + (" in library $directoryPathOfLibrary does not expose any `" + ($referencedName + "`.")))), $c$$src$Core$$Nil)))));
                      }))()
                      : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
                        ? ($c$$src$Result$$Err)(($pars.makeError)(($c$$src$Core$$Cons)(($referencedName + (" is not in " + $modulePath)), $c$$src$Core$$Nil)))
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 287:32', (sp_toHuman)($maybeReferencedModuleAlias))))
                    : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 281:24', (sp_toHuman)($7))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 256:16', (sp_toHuman)($6))));
        })))(($pars.loadExports)($importsPath));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 240:4', (sp_toHuman)($location))));
});

const $c$$src$Compiler$Meta$$resolve = (($pars, $maybeReferencedModuleAlias, $referencedName) => {
  return ((($maybeReferencedModuleAlias)[0] === "$Just")
    ? ((() => {
      const $alias = ($maybeReferencedModuleAlias)[1];
      const $4 = ($c$$src$Dict$$get)($alias, $pars.currentImports.moduleAliasToLocation);
      return ((($4)[0] === "$Nothing")
        ? ($c$$src$Result$$Err)(($pars.makeError)(($c$$src$Core$$Cons)(("I cannot find the module: " + $alias), $c$$src$Core$$Nil)))
        : ((($4)[0] === "$Just")
          ? ((() => {
            const $location = ($4)[1];
            return ($c$$src$Compiler$Meta$$resolveLocation)($pars, $location, $maybeReferencedModuleAlias, $referencedName);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 220:12', (sp_toHuman)($4))));
    }))()
    : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
      ? ((() => {
        const $4 = ($c$$src$Dict$$get)($referencedName, $pars.currentImports.globalNameToLocation);
        return ((($4)[0] === "$Nothing")
          ? ($c$$src$Result$$Ok)(($c$$src$Compiler$Meta$$USR)($pars.currentModule, $referencedName))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $location = ($4)[1];
              return ($c$$src$Compiler$Meta$$resolveLocation)($pars, $location, $maybeReferencedModuleAlias, $referencedName);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 233:12', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 217:4', (sp_toHuman)($maybeReferencedModuleAlias))));
});

const $c$$src$Compiler$Meta$$rootDirectoryToPath = (($paths, $rootDirectory) => {
  return ((($rootDirectory)[0] === "$Core")
    ? $paths.core
    : ((($rootDirectory)[0] === "$User")
      ? $paths.project
      : ((($rootDirectory)[0] === "$Installed")
        ? $paths.installed
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 118:4', (sp_toHuman)($rootDirectory)))));
});

const $c$$src$Compiler$Op$$precedence_addittive = 7;

const $c$$src$Compiler$Op$$precedence_application = 9;

const $c$$src$Compiler$Op$$precedence_comparison = 6;

const $c$$src$Compiler$Op$$precedence_cons = 3;

const $c$$src$Compiler$Op$$precedence_function = 0;

const $c$$src$Compiler$Op$$precedence_logical = 5;

const $c$$src$Compiler$Op$$precedence_multiplicative = 8;

const $c$$src$Compiler$Op$$precedence_mutop = 1;

const $c$$src$Compiler$Op$$precedence_pipe = 2;

const $c$$src$Compiler$Op$$precedence_tuple = 4;

const $c$$src$Compiler$Pos$$range = (($a, $b) => {
  const $3 = ({
    first: $a,
    second: $b,
  });
  return (((($3.first)[0] === "$P") && (($3.second)[0] === "$P"))
    ? ((() => {
      const $sa = ($3.first)[1];
      const $ea = ($3.first)[2];
      const $sb = ($3.second)[1];
      const $eb = ($3.second)[2];
      return ($c$$src$Compiler$Pos$$P)(($c$$src$Basics$$min)($sa, $sb), ($c$$src$Basics$$max)($ea, $eb));
    }))()
    : ((($3.first)[0] === "$P")
      ? $a
      : (true
        ? $b
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Pos.sp 46:4', (sp_toHuman)($3)))));
});

const $c$$src$Compiler$TypedAst$$mapPars = (($f, $pars) => {
  const $zzz = (($par) => {
    return ((($par)[0] === "$ParRe")
      ? ((() => {
        const $raw = ($par)[1];
        return ($c$$src$Compiler$TypedAst$$ParRe)(($f)($raw));
      }))()
      : ((($par)[0] === "$ParSp")
        ? ((() => {
          const $full = ($par)[1];
          return ($c$$src$Compiler$TypedAst$$ParSp)(((() => {
            const $0 = $full;
            return (Object.assign)({}, $0, ({
              raw: ($f)($0.raw),
            }));
          }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 309:8', (sp_toHuman)($par))));
  });
  return ($c$$src$List$$map)($zzz, $pars);
});

const $c$$src$Compiler$TypedAst$$normalizeTyvarId = (($hash, $id) => {
  const $3 = ((__re__ = (hash_get)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]);
  return ([
    ((($3)[0] === "$Just")
      ? ((() => {
        const $nid = ($3)[1];
        return $nid;
      }))()
      : ((($3)[0] === "$Nothing")
        ? ((() => {
          let $maxId = 0;
          ((__re__ = (hash_each)($hash, (($k, $v) => {
            return (($v > ((__re__ = (basics_cloneUni)($maxId)), ($maxId = (__re__)[1]), (__re__)[0]))
              ? ($maxId = (basics_cloneImm)($v))
              : null);
          }))), ($hash = (__re__)[1]), (__re__)[0]);
          const $nid = ($maxId + 1);
          ((__re__ = (hash_insert)($hash, $id, $nid)), ($hash = (__re__)[1]), (__re__)[0]);
          return $nid;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 350:4', (sp_toHuman)($3)))),
    $hash,
  ]);
});

const $c$$src$Dict$$map = (($func, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? $c$$src$Dict$$RBEmpty_elm_builtin
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ($c$$src$Dict$$RBNode_elm_builtin)($color, $key, ($func)($key, $value), ($c$$src$Dict$$map)($func, $left), ($c$$src$Dict$$map)($func, $right));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 317:4', (sp_toHuman)($dict))));
});

const $c$$src$Compiler$TypedAst$$normalizeType = (($hash, $type) => {
  return ([
    ((($type)[0] === "$TypeExact")
      ? ((() => {
        const $usr = ($type)[1];
        const $args = ($type)[2];
        return ($c$$src$Compiler$TypedAst$$TypeExact)($usr, ($c$$src$List$$map)((($0) => {
          return ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $0)), ($hash = (__re__)[1]), (__re__)[0]);
        }), $args));
      }))()
      : ((($type)[0] === "$TypeFn")
        ? ((() => {
          const $pars = ($type)[1];
          const $out = ($type)[2];
          return ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Compiler$TypedAst$$mapPars)((($0) => {
            return ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $0)), ($hash = (__re__)[1]), (__re__)[0]);
          }), $pars), ((() => {
            const $0 = $out;
            return (Object.assign)({}, $0, ({
              raw: ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $0.raw)), ($hash = (__re__)[1]), (__re__)[0]),
            }));
          }))());
        }))()
        : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Nothing"))
          ? ((() => {
            const $attrs = ($type)[2];
            return ($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, ($c$$src$Dict$$map)((($k, $v) => {
              return ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $v)), ($hash = (__re__)[1]), (__re__)[0]);
            }), $attrs));
          }))()
          : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Just"))
            ? ((() => {
              const $id = (($type)[1])[1];
              const $attrs = ($type)[2];
              return ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(((__re__ = ($c$$src$Compiler$TypedAst$$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0])), ($c$$src$Dict$$map)((($k, $v) => {
                return ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $v)), ($hash = (__re__)[1]), (__re__)[0]);
              }), $attrs));
            }))()
            : ((($type)[0] === "$TypeVar")
              ? ((() => {
                const $id = ($type)[1];
                return ($c$$src$Compiler$TypedAst$$TypeVar)(((__re__ = ($c$$src$Compiler$TypedAst$$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]));
              }))()
              : ((($type)[0] === "$TypeError")
                ? $c$$src$Compiler$TypedAst$$TypeError
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 375:4', (sp_toHuman)($type)))))))),
    $hash,
  ]);
});

const $c$$src$Compiler$TypedAst$$patternNames = (($p) => {
  return (((($p)[0] === "$PatternAny") && ((($p)[2].maybeName)[0] === "$Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return $c$$src$Dict$$empty;
    }))()
    : (((($p)[0] === "$PatternAny") && ((($p)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $n = (($p)[2].maybeName)[1];
        const $type = ($p)[2].type;
        return ($c$$src$Dict$$ofOne)($n, ({
          pos: $pos,
          type: $type,
        }));
      }))()
      : ((($p)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return $c$$src$Dict$$empty;
        }))()
        : ((($p)[0] === "$PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return $c$$src$Dict$$empty;
          }))()
          : ((($p)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $usr = ($p)[2];
              const $ps = ($p)[3];
              return ($c$$src$List$$for)($c$$src$Dict$$empty, $ps, (($x, $a) => {
                return ((($0) => {
                  return ($c$$src$Dict$$join)($0, $a);
                }))(($c$$src$Compiler$TypedAst$$patternNames)($x));
              }));
            }))()
            : ((($p)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[2];
                return ($c$$src$Dict$$for)($c$$src$Dict$$empty, $ps, (($k, $3, $a) => {
                  const $pa = $3.first;
                  const $ty = $3.second;
                  return ((($0) => {
                    return ($c$$src$Dict$$join)($a, $0);
                  }))(($c$$src$Compiler$TypedAst$$patternNames)($pa));
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 318:4', (sp_toHuman)($p))))))));
});

const $c$$src$Compiler$TypedAst$$resolveParType = (($saf, $par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return ($c$$src$Compiler$TypedAst$$ParRe)(($c$$src$Compiler$TypedAst$$resolveRaw)($saf, $raw));
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return ($c$$src$Compiler$TypedAst$$ParSp)(($c$$src$Compiler$TypedAst$$resolveFull)($saf, $full));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 163:4', (sp_toHuman)($par))));
});

const $c$$src$Compiler$TypedAst$$resolveRaw = (($saf, $raw) => {
  const $rec = (($0) => {
    return ($c$$src$Compiler$TypedAst$$resolveRaw)($saf, $0);
  });
  return ((($raw)[0] === "$TypeVar")
    ? ((() => {
      const $id = ($raw)[1];
      const $3 = ($saf.ty)($id);
      return ((($3)[0] === "$Nothing")
        ? $raw
        : ((($3)[0] === "$Just")
          ? ((() => {
            const $replacement = ($3)[1];
            return $replacement;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 184:12', (sp_toHuman)($3))));
    }))()
    : ((($raw)[0] === "$TypeExact")
      ? ((() => {
        const $usr = ($raw)[1];
        const $pars = ($raw)[2];
        return ($c$$src$Compiler$TypedAst$$TypeExact)($usr, ($c$$src$List$$map)($rec, $pars));
      }))()
      : ((($raw)[0] === "$TypeFn")
        ? ((() => {
          const $pars = ($raw)[1];
          const $out = ($raw)[2];
          return ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$List$$map)((($0) => {
            return ($c$$src$Compiler$TypedAst$$resolveParType)($saf, $0);
          }), $pars), ($c$$src$Compiler$TypedAst$$resolveFull)($saf, $out));
        }))()
        : (((($raw)[0] === "$TypeRecord") && ((($raw)[1])[0] === "$Nothing"))
          ? ((() => {
            const $attrs = ($raw)[2];
            return ($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, ($c$$src$Dict$$map)((($k, $v) => {
              return ($rec)($v);
            }), $attrs));
          }))()
          : (((($raw)[0] === "$TypeRecord") && ((($raw)[1])[0] === "$Just"))
            ? ((() => {
              const $id = (($raw)[1])[1];
              const $attrs = ($raw)[2];
              const $3 = ($saf.ty)($id);
              return ((($3)[0] === "$Just")
                ? ((() => {
                  const $replacement = ($3)[1];
                  return $replacement;
                }))()
                : ((($3)[0] === "$Nothing")
                  ? ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($id), ($c$$src$Dict$$map)((($k, $v) => {
                    return ($rec)($v);
                  }), $attrs))
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 198:12', (sp_toHuman)($3))));
            }))()
            : ((($raw)[0] === "$TypeError")
              ? $c$$src$Compiler$TypedAst$$TypeError
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 181:4', (sp_toHuman)($raw))))))));
});

const $c$$src$Compiler$TypedAst$$resolveUni = (($uniSub, $uni) => {
  return ((($uni)[0] === "$Depends")
    ? ((() => {
      const $id = ($uni)[1];
      const $3 = ($uniSub)($id);
      return ((($3)[0] === "$Nothing")
        ? $uni
        : ((($3)[0] === "$Just")
          ? ((() => {
            const $u = ($3)[1];
            return $u;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 153:12', (sp_toHuman)($3))));
    }))()
    : (true
      ? $uni
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 150:4', (sp_toHuman)($uni))));
});

const $c$$src$Compiler$TypedAst$$resolveFull = (($saf, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return ({
    raw: ($c$$src$Compiler$TypedAst$$resolveRaw)($saf, $raw),
    uni: ($c$$src$Compiler$TypedAst$$resolveUni)($saf.uni, $uni),
  });
});

const $c$$src$Compiler$TypedAst$$resolvePattern = (($saf, $pattern) => {
  return ((($pattern)[0] === "$PatternLiteralNumber")
    ? ((() => {
      const $pos = ($pattern)[1];
      return $pattern;
    }))()
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $pos = ($pattern)[1];
        return $pattern;
      }))()
      : ((($pattern)[0] === "$PatternAny")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $stuff = ($pattern)[2];
          return ($c$$src$Compiler$TypedAst$$PatternAny)($pos, ((() => {
            const $0 = $stuff;
            return (Object.assign)({}, $0, ({
              type: ($c$$src$Compiler$TypedAst$$resolveFull)($saf, $0.type),
            }));
          }))());
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $usr = ($pattern)[2];
            const $ps = ($pattern)[3];
            return ($c$$src$Compiler$TypedAst$$PatternConstructor)($pos, $usr, ($c$$src$List$$map)((($0) => {
              return ($c$$src$Compiler$TypedAst$$resolvePattern)($saf, $0);
            }), $ps));
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $ps = ($pattern)[2];
              return ($c$$src$Compiler$TypedAst$$PatternRecord)($pos, ($c$$src$Dict$$map)((($k, $3) => {
                const $p = $3.first;
                const $t = $3.second;
                return ({
                  first: ($c$$src$Compiler$TypedAst$$resolvePattern)($saf, $p),
                  second: ($c$$src$Compiler$TypedAst$$resolveRaw)($saf, $t),
                });
              }), $ps));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 276:4', (sp_toHuman)($pattern)))))));
});

const $c$$src$Compiler$TypedAst$$resolvePar = (($saf, $par) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $full = ($par)[1];
      const $pa = ($par)[2];
      return ($c$$src$Compiler$TypedAst$$ParameterPattern)(($c$$src$Compiler$TypedAst$$resolveFull)($saf, $full), ($c$$src$Compiler$TypedAst$$resolvePattern)($saf, $pa));
    }))()
    : ((($par)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $full = ($par)[1];
        const $n = ($par)[2];
        return ($c$$src$Compiler$TypedAst$$ParameterPlaceholder)(($c$$src$Compiler$TypedAst$$resolveFull)($saf, $full), $n);
      }))()
      : ((($par)[0] === "$ParameterRecycle")
        ? ((() => {
          const $p = ($par)[1];
          const $raw = ($par)[2];
          const $name = ($par)[3];
          return ($c$$src$Compiler$TypedAst$$ParameterRecycle)($p, ($c$$src$Compiler$TypedAst$$resolveRaw)($saf, $raw), $name);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 215:4', (sp_toHuman)($par)))));
});

const $c$$src$Compiler$TypedAst$$resolveValueDef = (($saf, $def) => {
  const $0 = $def;
  return (Object.assign)({}, $0, ({
    body: ($c$$src$Compiler$TypedAst$$resolveExpression)($saf, $0.body),
    pattern: ($c$$src$Compiler$TypedAst$$resolvePattern)($saf, $0.pattern),
    type: ($c$$src$Compiler$TypedAst$$resolveFull)($saf, $0.type),
  }));
});

const $c$$src$Maybe$$map = (($f, $m) => {
  return ((($m)[0] === "$Nothing")
    ? $c$$src$Maybe$$Nothing
    : ((($m)[0] === "$Just")
      ? ((() => {
        const $v = ($m)[1];
        return ($c$$src$Maybe$$Just)(($f)($v));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 16:4', (sp_toHuman)($m))));
});

const $c$$src$Tuple$$mapBoth = (($fa, $fb, $t) => {
  return ({
    first: ($fa)($t.first),
    second: ($fb)($t.second),
  });
});

const $c$$src$Compiler$TypedAst$$resolveExpression = (($saf, $expression) => {
  const $rec = (($0) => {
    return ($c$$src$Compiler$TypedAst$$resolveExpression)($saf, $0);
  });
  return ((($expression)[0] === "$LiteralNumber")
    ? $expression
    : ((($expression)[0] === "$LiteralText")
      ? $expression
      : ((($expression)[0] === "$Variable")
        ? $expression
        : ((($expression)[0] === "$Constructor")
          ? $expression
          : ((($expression)[0] === "$Fn")
            ? ((() => {
              const $p = ($expression)[1];
              const $pars = ($expression)[2];
              const $body = ($expression)[3];
              const $bodyType = ($expression)[4];
              return ($c$$src$Compiler$TypedAst$$Fn)($p, ($c$$src$List$$map)((($0) => {
                return ($c$$src$Compiler$TypedAst$$resolvePar)($saf, $0);
              }), $pars), ($rec)($body), ($c$$src$Compiler$TypedAst$$resolveFull)($saf, $bodyType));
            }))()
            : ((($expression)[0] === "$Call")
              ? ((() => {
                const $p = ($expression)[1];
                const $ref = ($expression)[2];
                const $args = ($expression)[3];
                return ($c$$src$Compiler$TypedAst$$Call)($p, ($rec)($ref), ($c$$src$List$$map)((($0) => {
                  return ($c$$src$Compiler$TypedAst$$resolveArg)($saf, $0);
                }), $args));
              }))()
              : ((($expression)[0] === "$Record")
                ? ((() => {
                  const $p = ($expression)[1];
                  const $maybeExt = ($expression)[2];
                  const $attrs = ($expression)[3];
                  return ($c$$src$Compiler$TypedAst$$Record)($p, ($c$$src$Maybe$$map)($rec, $maybeExt), ($c$$src$Dict$$map)((($k, $v) => {
                    return ($rec)($v);
                  }), $attrs));
                }))()
                : ((($expression)[0] === "$RecordAccess")
                  ? ((() => {
                    const $p = ($expression)[1];
                    const $name = ($expression)[2];
                    const $exp = ($expression)[3];
                    return ($c$$src$Compiler$TypedAst$$RecordAccess)($p, $name, ($rec)($exp));
                  }))()
                  : ((($expression)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($expression)[1];
                      const $rest = ($expression)[2];
                      const $restType = ($expression)[3];
                      return ($c$$src$Compiler$TypedAst$$LetIn)(($c$$src$Compiler$TypedAst$$resolveValueDef)($saf, $def), ($rec)($rest), ($c$$src$Compiler$TypedAst$$resolveFull)($saf, $restType));
                    }))()
                    : ((($expression)[0] === "$If")
                      ? ((() => {
                        const $p = ($expression)[1];
                        const $condition = ($expression)[2].condition;
                        const $false = ($expression)[2].false;
                        const $true = ($expression)[2].true;
                        return ($c$$src$Compiler$TypedAst$$If)($p, ({
                          condition: ($rec)($condition),
                          false: ($rec)($false),
                          true: ($rec)($true),
                        }));
                      }))()
                      : ((($expression)[0] === "$Try")
                        ? ((() => {
                          const $p = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          return ($c$$src$Compiler$TypedAst$$Try)($p, ({
                            patternsAndExpressions: ($c$$src$List$$map)((($0) => {
                              return ($c$$src$Tuple$$mapBoth)((($0) => {
                                return ($c$$src$Compiler$TypedAst$$resolvePattern)($saf, $0);
                              }), $rec, $0);
                            }), $patternsAndExpressions),
                            value: ($rec)($value),
                            valueType: ($c$$src$Compiler$TypedAst$$resolveFull)($saf, $valueType),
                          }));
                        }))()
                        : ((($expression)[0] === "$DestroyIn")
                          ? ((() => {
                            const $n = ($expression)[1];
                            const $e = ($expression)[2];
                            return ($c$$src$Compiler$TypedAst$$DestroyIn)($n, ($rec)($e));
                          }))()
                          : ((($expression)[0] === "$Error")
                            ? ((() => {
                              const $p = ($expression)[1];
                              return $expression;
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 226:4', (sp_toHuman)($expression)))))))))))))));
});

const $c$$src$Compiler$TypedAst$$resolveArg = (($saf, $arg) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $full = ($arg)[1];
      const $expr = ($arg)[2];
      return ($c$$src$Compiler$TypedAst$$ArgumentExpression)(($c$$src$Compiler$TypedAst$$resolveFull)($saf, $full), ($c$$src$Compiler$TypedAst$$resolveExpression)($saf, $expr));
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $attrPath = ($arg)[3];
        const $name = ($arg)[4];
        return ($c$$src$Compiler$TypedAst$$ArgumentRecycle)($p, ($c$$src$Compiler$TypedAst$$resolveRaw)($saf, $raw), $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 208:4', (sp_toHuman)($arg))));
});

const $c$$src$Compiler$TypedAst$$toRaw = (($par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return $raw;
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 300:4', (sp_toHuman)($par))));
});

const $c$$src$Dict$$any = (($f, $dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $v = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return (($f)($key, $v)
        ? true
        : (($c$$src$Dict$$any)($f, $left) || ($c$$src$Dict$$any)($f, $right)));
    }))()
    : ((($dict)[0] === "$RBEmpty_elm_builtin")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 412:4', (sp_toHuman)($dict))));
});

const $c$$src$List$$any = (($fun, $list) => {
  return ((($list)[0] === "$Nil")
    ? false
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($fun)($h)
          ? true
          : ($c$$src$List$$any)($fun, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 3:4', (sp_toHuman)($list))));
});

const $c$$src$Compiler$TypedAst$$typeAllowsFunctions = (($testId, $type) => {
  return ((($type)[0] === "$TypeFn")
    ? ((() => {
      const $ins = ($type)[1];
      const $out = ($type)[2];
      return true;
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return ($testId)($id);
      }))()
      : ((($type)[0] === "$TypeExact")
        ? ((() => {
          const $usr = ($type)[1];
          const $args = ($type)[2];
          return ($c$$src$List$$any)((($0) => {
            return ($c$$src$Compiler$TypedAst$$typeAllowsFunctions)($testId, $0);
          }), $args);
        }))()
        : ((($type)[0] === "$TypeRecord")
          ? ((() => {
            const $attrs = ($type)[2];
            return ($c$$src$Dict$$any)((($k, $v) => {
              return ($c$$src$Compiler$TypedAst$$typeAllowsFunctions)($testId, $v);
            }), $attrs);
          }))()
          : ((($type)[0] === "$TypeError")
            ? true
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 340:4', (sp_toHuman)($type)))))));
});

const $c$$src$Compiler$TypedAst$$typeTyvars = (($type) => {
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($type)[1];
      const $args = ($type)[2];
      return ($c$$src$List$$for)($c$$src$Dict$$empty, $args, (($a, $acc) => {
        return ($c$$src$Dict$$join)(($c$$src$Compiler$TypedAst$$typeTyvars)($a), $acc);
      }));
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return ($c$$src$Dict$$ofOne)($id, null);
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Nothing"))
        ? ((() => {
          const $attrs = ($type)[2];
          return ($c$$src$Dict$$for)($c$$src$Dict$$empty, $attrs, (($k, $a, $d) => {
            return ($c$$src$Dict$$join)(($c$$src$Compiler$TypedAst$$typeTyvars)($a), $d);
          }));
        }))()
        : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Just"))
          ? ((() => {
            const $id = (($type)[1])[1];
            const $attrs = ($type)[2];
            return ((($0) => {
              return ($c$$src$Dict$$for)($0, $attrs, (($k, $a, $d) => {
                return ($c$$src$Dict$$join)(($c$$src$Compiler$TypedAst$$typeTyvars)($a), $d);
              }));
            }))(($c$$src$Dict$$ofOne)($id, null));
          }))()
          : ((($type)[0] === "$TypeError")
            ? $c$$src$Dict$$empty
            : ((($type)[0] === "$TypeFn")
              ? ((() => {
                const $ins = ($type)[1];
                const $out = ($type)[2];
                return ((($0) => {
                  return ($c$$src$List$$for)($0, $ins, (($in, $a) => {
                    return ($c$$src$Dict$$join)(($c$$src$Compiler$TypedAst$$typeTyvars)(($c$$src$Compiler$TypedAst$$toRaw)($in)), $a);
                  }));
                }))(($c$$src$Compiler$TypedAst$$typeTyvars)($out.raw));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 329:4', (sp_toHuman)($type))))))));
});

const $c$$src$Dict$$moveRedLeft = (($dict) => {
  return (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && (((($dict)[5])[0] === "$RBNode_elm_builtin") && ((((($dict)[5])[4])[0] === "$RBNode_elm_builtin") && ((((($dict)[5])[4])[1])[0] === "$Red")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $lLeft = (($dict)[4])[4];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rlK = ((($dict)[5])[4])[2];
      const $rlV = ((($dict)[5])[4])[3];
      const $rlL = ((($dict)[5])[4])[4];
      const $rlR = ((($dict)[5])[4])[5];
      const $rRight = (($dict)[5])[5];
      return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $rlK, $rlV, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, $lLeft, $lRight), $rlL), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $rK, $rV, $rlR, $rRight));
    }))()
    : (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && ((($dict)[5])[0] === "$RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "$Black")
          ? ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, $lLeft, $lRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "$Red")
            ? ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, $lLeft, $lRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 212:12', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 206:4', (sp_toHuman)($dict)))));
});

const $c$$src$Dict$$getMin = (($dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $left = ($dict)[4];
      return ((($left)[0] === "$RBNode_elm_builtin")
        ? ($c$$src$Dict$$getMin)($left)
        : (true
          ? $dict
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 165:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? $dict
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 162:4', (sp_toHuman)($dict))));
});

const $c$$src$Dict$$removeMin = (($dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((($left)[0] === "$RBNode_elm_builtin")
        ? ((() => {
          const $lColor = ($left)[1];
          const $lLeft = ($left)[4];
          return ((($lColor)[0] === "$Black")
            ? (((($lLeft)[0] === "$RBNode_elm_builtin") && ((($lLeft)[1])[0] === "$Red"))
              ? ($c$$src$Dict$$RBNode_elm_builtin)($color, $key, $value, ($c$$src$Dict$$removeMin)($left), $right)
              : (true
                ? ((() => {
                  const $2 = ($c$$src$Dict$$moveRedLeft)($dict);
                  return ((($2)[0] === "$RBNode_elm_builtin")
                    ? ((() => {
                      const $nColor = ($2)[1];
                      const $nKey = ($2)[2];
                      const $nValue = ($2)[3];
                      const $nLeft = ($2)[4];
                      const $nRight = ($2)[5];
                      return ($c$$src$Dict$$balance)($nColor, $nKey, $nValue, ($c$$src$Dict$$removeMin)($nLeft), $nRight);
                    }))()
                    : ((($2)[0] === "$RBEmpty_elm_builtin")
                      ? $c$$src$Dict$$RBEmpty_elm_builtin
                      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 190:36', (sp_toHuman)($2))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 184:28', (sp_toHuman)($lLeft))))
            : (true
              ? ($c$$src$Dict$$RBNode_elm_builtin)($color, $key, $value, ($c$$src$Dict$$removeMin)($left), $right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 181:20', (sp_toHuman)($lColor))));
        }))()
        : (true
          ? $c$$src$Dict$$RBEmpty_elm_builtin
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 178:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? $c$$src$Dict$$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 175:4', (sp_toHuman)($dict))));
});

const $c$$src$Dict$$removeHelpEQGT = (($targetKey, $dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((sp_equal)($targetKey, $key)
        ? ((() => {
          const $3 = ($c$$src$Dict$$getMin)($right);
          return ((($3)[0] === "$RBNode_elm_builtin")
            ? ((() => {
              const $minKey = ($3)[2];
              const $minValue = ($3)[3];
              return ($c$$src$Dict$$balance)($color, $minKey, $minValue, $left, ($c$$src$Dict$$removeMin)($right));
            }))()
            : ((($3)[0] === "$RBEmpty_elm_builtin")
              ? $c$$src$Dict$$RBEmpty_elm_builtin
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 150:16', (sp_toHuman)($3))));
        }))()
        : ($c$$src$Dict$$balance)($color, $key, $value, $left, ($c$$src$Dict$$removeHelp)($targetKey, $right)));
    }))()
    : ((($dict)[0] === "$RBEmpty_elm_builtin")
      ? $c$$src$Dict$$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 146:4', (sp_toHuman)($dict))));
});

const $c$$src$Dict$$moveRedRight = (($dict) => {
  return (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && ((((($dict)[4])[4])[0] === "$RBNode_elm_builtin") && (((((($dict)[4])[4])[1])[0] === "$Red") && ((($dict)[5])[0] === "$RBNode_elm_builtin")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $llK = ((($dict)[4])[4])[2];
      const $llV = ((($dict)[4])[4])[3];
      const $llLeft = ((($dict)[4])[4])[4];
      const $llRight = ((($dict)[4])[4])[5];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rLeft = (($dict)[5])[4];
      const $rRight = (($dict)[5])[5];
      return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $llK, $llV, $llLeft, $llRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, $lRight, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $rK, $rV, $rLeft, $rRight)));
    }))()
    : (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && ((($dict)[5])[0] === "$RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "$Black")
          ? ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, $lLeft, $lRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "$Red")
            ? ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $lK, $lV, $lLeft, $lRight), ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 228:12', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 222:4', (sp_toHuman)($dict)))));
});

const $c$$src$Dict$$removeHelpPrepEQGT = (($targetKey, $dict, $color, $key, $value, $left, $right) => {
  return (((($left)[0] === "$RBNode_elm_builtin") && ((($left)[1])[0] === "$Red"))
    ? ((() => {
      const $lK = ($left)[2];
      const $lV = ($left)[3];
      const $lLeft = ($left)[4];
      const $lRight = ($left)[5];
      return ($c$$src$Dict$$RBNode_elm_builtin)($color, $lK, $lV, $lLeft, ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Red, $key, $value, $lRight, $right));
    }))()
    : (true
      ? (((($right)[0] === "$RBNode_elm_builtin") && (((($right)[1])[0] === "$Black") && (((($right)[4])[0] === "$RBNode_elm_builtin") && (((($right)[4])[1])[0] === "$Black"))))
        ? ($c$$src$Dict$$moveRedRight)($dict)
        : (((($right)[0] === "$RBNode_elm_builtin") && (((($right)[1])[0] === "$Black") && ((($right)[4])[0] === "$RBEmpty_elm_builtin")))
          ? ($c$$src$Dict$$moveRedRight)($dict)
          : (true
            ? $dict
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 138:12', (sp_toHuman)($right)))))
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 132:4', (sp_toHuman)($left))));
});

const $c$$src$Dict$$removeHelp = (($targetKey, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? $c$$src$Dict$$RBEmpty_elm_builtin
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ((sp_equal)((basics_compare)($targetKey, $key), (0 - 1))
          ? (((($left)[0] === "$RBNode_elm_builtin") && ((($left)[1])[0] === "$Black"))
            ? ((() => {
              const $lLeft = ($left)[4];
              return (((($lLeft)[0] === "$RBNode_elm_builtin") && ((($lLeft)[1])[0] === "$Red"))
                ? ($c$$src$Dict$$RBNode_elm_builtin)($color, $key, $value, ($c$$src$Dict$$removeHelp)($targetKey, $left), $right)
                : (true
                  ? ((() => {
                    const $3 = ($c$$src$Dict$$moveRedLeft)($dict);
                    return ((($3)[0] === "$RBNode_elm_builtin")
                      ? ((() => {
                        const $nColor = ($3)[1];
                        const $nKey = ($3)[2];
                        const $nValue = ($3)[3];
                        const $nLeft = ($3)[4];
                        const $nRight = ($3)[5];
                        return ($c$$src$Dict$$balance)($nColor, $nKey, $nValue, ($c$$src$Dict$$removeHelp)($targetKey, $nLeft), $nRight);
                      }))()
                      : ((($3)[0] === "$RBEmpty_elm_builtin")
                        ? $c$$src$Dict$$RBEmpty_elm_builtin
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 120:32', (sp_toHuman)($3))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 114:24', (sp_toHuman)($lLeft))));
            }))()
            : (true
              ? ($c$$src$Dict$$RBNode_elm_builtin)($color, $key, $value, ($c$$src$Dict$$removeHelp)($targetKey, $left), $right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 111:16', (sp_toHuman)($left))))
          : ($c$$src$Dict$$removeHelpEQGT)($targetKey, ($c$$src$Dict$$removeHelpPrepEQGT)($targetKey, $dict, $color, $key, $value, $left, $right)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 104:4', (sp_toHuman)($dict))));
});

const $c$$src$Dict$$remove = (($key, $dict) => {
  const $3 = ($c$$src$Dict$$removeHelp)($key, $dict);
  return (((($3)[0] === "$RBNode_elm_builtin") && ((($3)[1])[0] === "$Red"))
    ? ((() => {
      const $k = ($3)[2];
      const $v = ($3)[3];
      const $l = ($3)[4];
      const $r = ($3)[5];
      return ($c$$src$Dict$$RBNode_elm_builtin)($c$$src$Dict$$Black, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $3;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 97:4', (sp_toHuman)($3))));
});

const $c$$src$Dict$$diff = (($t1, $t2) => {
  return ($c$$src$Dict$$for)($t1, $t2, (($k, $v, $t) => {
    return ($c$$src$Dict$$remove)($k, $t);
  }));
});

const $c$$src$Dict$$each = (($dict, $func) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? null
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        ($func)($key, $value);
        ($c$$src$Dict$$each)($left, $func);
        return ($c$$src$Dict$$each)($right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 346:4', (sp_toHuman)($dict))));
});

const $c$$src$Dict$$filter = (($isGood, $dict) => {
  return ($c$$src$Dict$$for)($c$$src$Dict$$empty, $dict, (($k, $v, $d) => {
    return (($isGood)($k, $v)
      ? ($c$$src$Dict$$insert)($k, $v, $d)
      : $d);
  }));
});

const $c$$src$Dict$$fromList = (($0) => {
  return ($c$$src$List$$for)($c$$src$Dict$$empty, $0, (($keyAndValue, $dict) => {
    return ($c$$src$Dict$$insert)($keyAndValue.first, $keyAndValue.second, $dict);
  }));
});

const $c$$src$Dict$$member = (($key, $dict) => {
  const $3 = ($c$$src$Dict$$get)($key, $dict);
  return ((($3)[0] === "$Just")
    ? true
    : ((($3)[0] === "$Nothing")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 33:4', (sp_toHuman)($3))));
});

const $c$$src$Dict$$intersect = (($t1, $t2) => {
  return ($c$$src$Dict$$filter)((($k, _1) => {
    return ($c$$src$Dict$$member)($k, $t2);
  }), $t1);
});

const $c$$src$Dict$$keys = (($0) => {
  return ($c$$src$Dict$$forReversed)($c$$src$Core$$Nil, $0, (($key, $value, $keyList) => {
    return ($c$$src$Core$$Cons)($key, $keyList);
  }));
});

const $c$$src$Dict$$toList = ((() => {
  const $f = (($key, $value, $list) => {
    return ($c$$src$Core$$Cons)(({
      first: $key,
      second: $value,
    }), $list);
  });
  return (($0) => {
    return ($c$$src$Dict$$forReversed)($c$$src$Core$$Nil, $0, $f);
  });
}))();

const $c$$src$Dict$$merge = (($leftStep, $bothStep, $rightStep, $leftDict, $rightDict, $initialResult) => {
  const $stepState = (($rKey, $rValue, $q) => {
    const $10 = $q;
    const $res = $10.second;
    const $list = $10.first;
    return ((($list)[0] === "$Nil")
      ? ({
        first: $list,
        second: ($rightStep)($rKey, $rValue, $res),
      })
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $lKey = ($list)[1].first;
          const $lValue = ($list)[1].second;
          const $rest = ($list)[2];
          const $11 = (basics_compare)($lKey, $rKey);
          return ((1 === $11)
            ? ({
              first: $list,
              second: ($rightStep)($rKey, $rValue, $res),
            })
            : ((0 === $11)
              ? ({
                first: $rest,
                second: ($bothStep)($lKey, $lValue, $rValue, $res),
              })
              : (true
                ? ($stepState)($rKey, $rValue, ({
                  first: $rest,
                  second: ($leftStep)($lKey, $lValue, $res),
                }))
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 278:16', (sp_toHuman)($11)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 272:8', (sp_toHuman)($list))));
  });
  const $7 = ($c$$src$Dict$$for)(({
    first: ($c$$src$Dict$$toList)($leftDict),
    second: $initialResult,
  }), $rightDict, $stepState);
  const $intermediateResult = $7.second;
  const $leftovers = $7.first;
  const $liftLeftStep = (($t, $res) => {
    const $10 = $t;
    const $v = $10.second;
    const $k = $10.first;
    return ($leftStep)($k, $v, $res);
  });
  return ($c$$src$List$$for)($intermediateResult, $leftovers, $liftLeftStep);
});

const $c$$src$Dict$$onlyBothOnly = (($da, $db) => {
  const $onAOnly = (($key, $a, $3) => {
    const $aOnly = $3.first;
    const $both = $3.second;
    const $bOnly = $3.third;
    return ({
      first: ($c$$src$Dict$$insert)($key, $a, $aOnly),
      second: $both,
      third: $bOnly,
    });
  });
  const $onBOnly = (($key, $b, $3) => {
    const $aOnly = $3.first;
    const $both = $3.second;
    const $bOnly = $3.third;
    return ({
      first: $aOnly,
      second: $both,
      third: ($c$$src$Dict$$insert)($key, $b, $bOnly),
    });
  });
  const $onBoth = (($key, $a, $b, $3) => {
    const $aOnly = $3.first;
    const $both = $3.second;
    const $bOnly = $3.third;
    return ({
      first: $aOnly,
      second: ($c$$src$Dict$$insert)($key, ({
        first: $a,
        second: $b,
      }), $both),
      third: $bOnly,
    });
  });
  return ($c$$src$Dict$$merge)($onAOnly, $onBoth, $onBOnly, $da, $db, ({
    first: $c$$src$Dict$$empty,
    second: $c$$src$Dict$$empty,
    third: $c$$src$Dict$$empty,
  }));
});

const $c$$src$Dict$$size = ((() => {
  const $sizeHelp = (($n, $dict) => {
    return ((($dict)[0] === "$RBEmpty_elm_builtin")
      ? $n
      : ((($dict)[0] === "$RBNode_elm_builtin")
        ? ((() => {
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          return ($sizeHelp)(($sizeHelp)(($n + 1), $right), $left);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 41:8', (sp_toHuman)($dict))));
  });
  return (($0) => {
    return ($sizeHelp)(0, $0);
  });
}))();

const $c$$src$Dict$$update = (($targetKey, $alter, $dictionary) => {
  const $4 = ($alter)(($c$$src$Dict$$get)($targetKey, $dictionary));
  return ((($4)[0] === "$Just")
    ? ((() => {
      const $value = ($4)[1];
      return ($c$$src$Dict$$insert)($targetKey, $value, $dictionary);
    }))()
    : ((($4)[0] === "$Nothing")
      ? ($c$$src$Dict$$remove)($targetKey, $dictionary)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 238:4', (sp_toHuman)($4))));
});

const $c$$src$Dict_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $c$$src$Dict_Test$$insertAndGet = ($i$test$$Test$$Group)("insertAndGet", ($c$$src$Core$$Cons)(($c$$src$Dict_Test$$valueTest)("get, success", ((_0) => {
  return ((($0) => {
    return ($c$$src$Dict$$get)(($c$$src$Maybe$$Just)("a"), $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("b"), 2, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("a"), 1, $0);
  }))($c$$src$Dict$$empty)));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Maybe$$Just)(1))), ($c$$src$Core$$Cons)(($c$$src$Dict_Test$$valueTest)("get, fail", ((_0) => {
  return ((($0) => {
    return ($c$$src$Dict$$get)(($c$$src$Maybe$$Just)("c"), $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("b"), 2, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("a"), 1, $0);
  }))($c$$src$Dict$$empty)));
}), ($i$test$$Test$$isOkAndEqualTo)($c$$src$Maybe$$Nothing)), $c$$src$Core$$Nil)));

const $c$$src$Dict_Test$$lists = ($i$test$$Test$$Group)("lists", ($c$$src$Core$$Cons)(($c$$src$Dict_Test$$valueTest)("keys", ((_0) => {
  return ((($0) => {
    return (list_sortBy)($c$$src$Basics$$identity, $0);
  }))(($c$$src$Dict$$keys)(((($0) => {
    return ($c$$src$Dict$$insert)($c$$src$Maybe$$Nothing, 2, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("b"), 2, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("a"), 1, $0);
  }))($c$$src$Dict$$empty)))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)("a"), ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)("b"), ($c$$src$Core$$Cons)($c$$src$Maybe$$Nothing, $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($c$$src$Dict_Test$$valueTest)("values", ((_0) => {
  return ((($0) => {
    return (list_sortBy)($c$$src$Basics$$identity, $0);
  }))(($c$$src$Dict$$values)(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("b"), ({
      a: 3,
    }), $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)(($c$$src$Maybe$$Just)("a"), ({
      a: 1,
    }), $0);
  }))($c$$src$Dict$$empty))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(({
  a: 1,
}), ($c$$src$Core$$Cons)(({
  a: 3,
}), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)));

const $c$$src$Dict_Test$$tests = ($i$test$$Test$$Group)("Dict", ($c$$src$Core$$Cons)($c$$src$Dict_Test$$insertAndGet, ($c$$src$Core$$Cons)($c$$src$Dict_Test$$lists, $c$$src$Core$$Nil)));

const $c$$src$Hash$$for_ = (($a, $h, $f) => {
  return ([
    ((__re__ = (hash_for)($h, $f, $a)), ($h = (__re__)[1]), (__re__)[0]),
    $h,
  ]);
});

const $c$$src$Hash$$toList = (($h) => {
  return ([
    ((__re__ = (hash_for)($h, (($k, $v, $l) => {
      return ($c$$src$Core$$Cons)(({
        first: $k,
        second: $v,
      }), $l);
    }), $c$$src$Core$$Nil)), ($h = (__re__)[1]), (__re__)[0]),
    $h,
  ]);
});

const $c$$src$Hash_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $c$$src$List$$each = (($ls, $f) => {
  return ((($ls)[0] === "$Nil")
    ? null
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $tail = ($ls)[2];
        ($f)($h);
        return ($c$$src$List$$each)($tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 372:4', (sp_toHuman)($ls))));
});

const $c$$src$List$$range = (($low, $high) => {
  const $rec = (($accum, $up) => {
    return (($up > $low)
      ? ($rec)((sp_cons)($up, $accum), ($up - 1))
      : ((sp_equal)($up, $low)
        ? (sp_cons)($up, $accum)
        : $accum));
  });
  return ($rec)($c$$src$Core$$Nil, $high);
});

const $c$$src$Tuple$$first = (($t) => {
  return $t.first;
});

const $c$$src$Hash_Test$$tests = ($i$test$$Test$$Group)("Hash", ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("insert", ((_0) => {
  let $h = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: 1,
    second: 2,
  }), $c$$src$Core$$Nil));
  ((__re__ = (hash_insert)($h, 2, 3)), ($h = (__re__)[1]), (__re__)[0]);
  return $h;
}), ($i$test$$Test$$isOkAndEqualTo)((hash_fromList)(($c$$src$Core$$Cons)(({
  first: 1,
  second: 2,
}), ($c$$src$Core$$Cons)(({
  first: 2,
  second: 3,
}), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("remove", ((_0) => {
  let $h = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: 1,
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: 3,
    second: 4,
  }), $c$$src$Core$$Nil)));
  ((__re__ = (hash_remove)($h, 1)), ($h = (__re__)[1]), (__re__)[0]);
  return $h;
}), ($i$test$$Test$$isOkAndEqualTo)((hash_fromList)(($c$$src$Core$$Cons)(({
  first: 3,
  second: 4,
}), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("get Just", ((_0) => {
  let $h = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: 1,
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: 3,
    second: 4,
  }), $c$$src$Core$$Nil)));
  return ((__re__ = (hash_get)($h, 1)), ($h = (__re__)[1]), (__re__)[0]);
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Maybe$$Just)(2))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("get Nothing", ((_0) => {
  let $h = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: 1,
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: 3,
    second: 4,
  }), $c$$src$Core$$Nil)));
  return ((__re__ = (hash_get)($h, 66)), ($h = (__re__)[1]), (__re__)[0]);
}), ($i$test$$Test$$isOkAndEqualTo)($c$$src$Maybe$$Nothing)), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("for", ((_0) => {
  let $hash = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: ($c$$src$Maybe$$Just)(true),
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: $c$$src$Maybe$$Nothing,
    second: 4,
  }), $c$$src$Core$$Nil)));
  return ((($0) => {
    return (list_sortBy)($c$$src$Tuple$$first, $0);
  }))(((($0) => {
    return ((__re__ = (hash_for)($hash, (($k, $v, $a) => {
      return ($c$$src$Core$$Cons)(({
        first: $v,
        second: $k,
      }), $a);
    }), $0)), ($hash = (__re__)[1]), (__re__)[0]);
  }))($c$$src$Core$$Nil));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(({
  first: 2,
  second: ($c$$src$Maybe$$Just)(true),
}), ($c$$src$Core$$Cons)(({
  first: 4,
  second: $c$$src$Maybe$$Nothing,
}), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("each", ((_0) => {
  let $a = (array_fromList)($c$$src$Core$$Nil);
  let $hash = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: ($c$$src$Maybe$$Just)(true),
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: $c$$src$Maybe$$Nothing,
    second: 1,
  }), $c$$src$Core$$Nil)));
  ((__re__ = (hash_each)($hash, (($k, $v) => {
    return ($c$$src$List$$each)(($c$$src$List$$range)(1, $v), ((_0) => {
      return ((__re__ = (array_push)($a, $k)), ($a = (__re__)[1]), (__re__)[0]);
    }));
  }))), ($hash = (__re__)[1]), (__re__)[0]);
  ((__re__ = (array_sortBy)($a, $c$$src$Basics$$identity)), ($a = (__re__)[1]), (__re__)[0]);
  return $a;
}), ($i$test$$Test$$isOkAndEqualTo)((array_fromList)(($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(true), ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(true), ($c$$src$Core$$Cons)($c$$src$Maybe$$Nothing, $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("pop (empty)", ((_0) => {
  let $h = (hash_fromList)($c$$src$Core$$Nil);
  const $r = ((__re__ = (hash_pop)($h)), ($h = (__re__)[1]), (__re__)[0]);
  return ({
    first: $r,
    second: $h,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  first: $c$$src$Maybe$$Nothing,
  second: (hash_fromList)($c$$src$Core$$Nil),
}))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("pop (one element)", ((_0) => {
  let $h = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: ({
      b: $c$$src$Maybe$$Nothing,
    }),
    second: 2,
  }), $c$$src$Core$$Nil));
  const $r = ((__re__ = (hash_pop)($h)), ($h = (__re__)[1]), (__re__)[0]);
  return ({
    first: $r,
    second: $h,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  first: ($c$$src$Maybe$$Just)(({
    first: ({
      b: $c$$src$Maybe$$Nothing,
    }),
    second: 2,
  })),
  second: (hash_fromList)($c$$src$Core$$Nil),
}))), ($c$$src$Core$$Cons)(($c$$src$Hash_Test$$valueTest)("pop (several element)", ((_0) => {
  let $h = (hash_fromList)(($c$$src$Core$$Cons)(({
    first: ({
      b: $c$$src$Maybe$$Nothing,
    }),
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: ({
      b: ($c$$src$Maybe$$Just)(4),
    }),
    second: 8,
  }), $c$$src$Core$$Nil)));
  const $r = ((__re__ = (hash_pop)($h)), ($h = (__re__)[1]), (__re__)[0]);
  return ({
    first: $r,
    second: $h,
  });
}), ($i$test$$Test$$isOkAndEqualTo)(({
  first: ($c$$src$Maybe$$Just)(({
    first: ({
      b: $c$$src$Maybe$$Nothing,
    }),
    second: 2,
  })),
  second: (hash_fromList)(($c$$src$Core$$Cons)(({
    first: ({
      b: ($c$$src$Maybe$$Just)(4),
    }),
    second: 8,
  }), $c$$src$Core$$Nil)),
}))), $c$$src$Core$$Nil))))))))));

const $c$$src$List$$append = (($xs, $ys) => {
  return ((($ys)[0] === "$Nil")
    ? $xs
    : (true
      ? ($c$$src$List$$forReversed)($ys, $xs, $c$$src$Core$$Cons)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 228:4', (sp_toHuman)($ys))));
});

const $c$$src$List$$concat = (($lists) => {
  return ($c$$src$List$$forReversed)($c$$src$Core$$Nil, $lists, $c$$src$List$$append);
});

const $c$$src$List$$concatMap = (($f, $list) => {
  return ($c$$src$List$$concat)(($c$$src$List$$map)($f, $list));
});

const $c$$src$List$$drop = (($n, $ls) => {
  return ((sp_equal)($n, 0)
    ? $ls
    : ((($ls)[0] === "$Nil")
      ? $c$$src$Core$$Nil
      : ((($ls)[0] === "$Cons")
        ? ((() => {
          const $h = ($ls)[1];
          const $tail = ($ls)[2];
          return ($c$$src$List$$drop)(($n - 1), $tail);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 418:8', (sp_toHuman)($ls)))));
});

const $c$$src$List$$filter = (($f, $ls) => {
  return ($c$$src$List$$forReversed)($c$$src$Core$$Nil, $ls, (($item, $acc) => {
    return (($f)($item)
      ? (sp_cons)($item, $acc)
      : $acc);
  }));
});

const $c$$src$List$$find = (($test, $list) => {
  return ((($list)[0] === "$Nil")
    ? $c$$src$Maybe$$Nothing
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($test)($h)
          ? ($c$$src$Maybe$$Just)($h)
          : ($c$$src$List$$find)($test, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 24:4', (sp_toHuman)($list))));
});

const $c$$src$List$$forRes = (($accum, $ls, $f) => {
  return ((($ls)[0] === "$Nil")
    ? ($c$$src$Result$$Ok)($accum)
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $t = ($ls)[2];
        const $4 = ($f)($h, $accum);
        return ((($4)[0] === "$Err")
          ? ((() => {
            const $x = ($4)[1];
            return ($c$$src$Result$$Err)($x);
          }))()
          : ((($4)[0] === "$Ok")
            ? ((() => {
              const $newAccum = ($4)[1];
              return ($c$$src$List$$forRes)($newAccum, $t, $f);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 185:12', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 179:4', (sp_toHuman)($ls))));
});

const $c$$src$List$$head = (($list) => {
  return ((($list)[0] === "$Nil")
    ? $c$$src$Maybe$$Nothing
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ($c$$src$Maybe$$Just)($h);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 255:4', (sp_toHuman)($list))));
});

const $c$$src$List$$indexBy = (($getIndex, $list) => {
  return ($c$$src$List$$for)($c$$src$Dict$$empty, $list, (($i, $a) => {
    return ($c$$src$Dict$$insert)(($getIndex)($i), $i, $a);
  }));
});

const $c$$src$List$$indexedEach2 = ((() => {
  const $rec = (($index, $aa, $bb, $f) => {
    const $5 = ({
      first: $aa,
      second: $bb,
    });
    return (((($5.first)[0] === "$Cons") && (($5.second)[0] === "$Cons"))
      ? ((() => {
        const $a = ($5.first)[1];
        const $at = ($5.first)[2];
        const $b = ($5.second)[1];
        const $bt = ($5.second)[2];
        ($f)($index, $a, $b);
        return ($rec)(($index + 1), $at, $bt, $f);
      }))()
      : (true
        ? null
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 386:8', (sp_toHuman)($5))));
  });
  return (($0, $1, $2) => {
    return ($rec)(0, $0, $1, $2);
  });
}))();

const $c$$src$List$$indexedFor = (($init, $aList, $function) => {
  return ($c$$src$Tuple$$second)(($c$$src$List$$for)(({
    first: 0,
    second: $init,
  }), $aList, (($item, $4) => {
    const $index = $4.first;
    const $accum = $4.second;
    return ({
      first: ($index + 1),
      second: ($function)($index, $item, $accum),
    });
  })));
});

const $c$$src$List$$indexedMap = (($f, $aa) => {
  const $rec = (($accum, $n, $list) => {
    return ((($list)[0] === "$Nil")
      ? ($c$$src$List$$reverse)($accum)
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return ($rec)((sp_cons)(($f)($n, $h), $accum), ($n + 1), $t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 208:8', (sp_toHuman)($list))));
  });
  return ($rec)($c$$src$Core$$Nil, 0, $aa);
});

const $c$$src$List$$intersperse = ((() => {
  const $rec = (($separator, $items, $acc) => {
    return ((($items)[0] === "$Nil")
      ? ($c$$src$List$$reverse)($acc)
      : (((($items)[0] === "$Cons") && ((($items)[2])[0] === "$Nil"))
        ? ((() => {
          const $last_ = ($items)[1];
          return ($c$$src$List$$reverse)((sp_cons)($last_, $acc));
        }))()
        : ((($items)[0] === "$Cons")
          ? ((() => {
            const $h = ($items)[1];
            const $tail = ($items)[2];
            return ($rec)($separator, $tail, (sp_cons)($separator, (sp_cons)($h, $acc)));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 460:8', (sp_toHuman)($items)))));
  });
  return (($0, $1) => {
    return ($rec)($0, $1, $c$$src$Core$$Nil);
  });
}))();

const $c$$src$List$$last = (($list) => {
  return ((($list)[0] === "$Nil")
    ? $c$$src$Maybe$$Nothing
    : (((($list)[0] === "$Cons") && ((($list)[2])[0] === "$Nil"))
      ? ((() => {
        const $h = ($list)[1];
        return ($c$$src$Maybe$$Just)($h);
      }))()
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return ($c$$src$List$$last)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 262:4', (sp_toHuman)($list)))));
});

const $c$$src$List$$length = (($list) => {
  return ($c$$src$List$$for)(0, $list, ((_0, $a) => {
    return ($a + 1);
  }));
});

const $c$$src$List$$map2 = (($f, $aa, $bb) => {
  const $rec = (($accum, $ax, $bx) => {
    const $7 = ({
      first: $ax,
      second: $bx,
    });
    return (((($7.first)[0] === "$Cons") && (($7.second)[0] === "$Cons"))
      ? ((() => {
        const $ahead = ($7.first)[1];
        const $atail = ($7.first)[2];
        const $bhead = ($7.second)[1];
        const $btail = ($7.second)[2];
        return ($rec)(($c$$src$Core$$Cons)(($f)($ahead, $bhead), $accum), $atail, $btail);
      }))()
      : (true
        ? ($c$$src$List$$reverse)($accum)
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 162:8', (sp_toHuman)($7))));
  });
  return ($rec)($c$$src$Core$$Nil, $aa, $bb);
});

const $c$$src$Result$$map = (($f, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return ($c$$src$Result$$Err)($e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $a = ($result)[1];
        return ($c$$src$Result$$Ok)(($f)($a));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 8:4', (sp_toHuman)($result))));
});

const $c$$src$List$$mapRes = (($f, $list) => {
  const $fun = (($a, $acc) => {
    return ($c$$src$Result$$map)((($b) => {
      return ($c$$src$Core$$Cons)($b, $acc);
    }), ($f)($a));
  });
  return ((($0) => {
    return ($c$$src$Result$$map)($c$$src$List$$reverse, $0);
  }))(($c$$src$List$$forRes)($c$$src$Core$$Nil, $list, $fun));
});

const $c$$src$List$$member = (($a, $list) => {
  return ((($list)[0] === "$Nil")
    ? false
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ((sp_equal)($a, $h)
          ? true
          : ($c$$src$List$$member)($a, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 52:4', (sp_toHuman)($list))));
});

const $c$$src$List$$minimum = (($list) => {
  return ((($list)[0] === "$Cons")
    ? ((() => {
      const $x = ($list)[1];
      const $xs = ($list)[2];
      return ($c$$src$Maybe$$Just)(($c$$src$List$$for)($x, $xs, $c$$src$Basics$$min));
    }))()
    : (true
      ? $c$$src$Maybe$$Nothing
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 425:4', (sp_toHuman)($list))));
});

const $c$$src$List$$partition = (($f, $ls) => {
  return ((($0) => {
    return ($c$$src$List$$forReversed)($0, $ls, (($item, $4) => {
      const $true = $4.first;
      const $false = $4.second;
      return (($f)($item)
        ? ({
          first: (sp_cons)($item, $true),
          second: $false,
        })
        : ({
          first: $true,
          second: (sp_cons)($item, $false),
        }));
    }));
  }))(({
    first: $c$$src$Core$$Nil,
    second: $c$$src$Core$$Nil,
  }));
});

const $c$$src$List$$partitionWhile = (($f, $xs) => {
  const $rec = (($acc, $rest) => {
    return ((($rest)[0] === "$Nil")
      ? ({
        first: $xs,
        second: $c$$src$Core$$Nil,
      })
      : ((($rest)[0] === "$Cons")
        ? ((() => {
          const $h = ($rest)[1];
          const $tail = ($rest)[2];
          return (($f)($h)
            ? ($rec)((sp_cons)($h, $acc), $tail)
            : ({
              first: ($c$$src$List$$reverse)($acc),
              second: $rest,
            }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 472:8', (sp_toHuman)($rest))));
  });
  return ($rec)($c$$src$Core$$Nil, $xs);
});

const $c$$src$List$$repeat = (($n, $a) => {
  const $rec = (($c, $acc) => {
    return (($c > 0)
      ? ($rec)(($c - 1), (sp_cons)($a, $acc))
      : $acc);
  });
  return ($rec)($n, $c$$src$Core$$Nil);
});

const $c$$src$List$$takeReverse = (($n, $list, $kept) => {
  return (($n < 1)
    ? $kept
    : ((($list)[0] === "$Nil")
      ? $kept
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $x = ($list)[1];
          const $xs = ($list)[2];
          return ($c$$src$List$$takeReverse)(($n - 1), $xs, ($c$$src$Core$$Cons)($x, $kept));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 315:8', (sp_toHuman)($list)))));
});

const $c$$src$List$$takeTailRec = (($n, $list) => {
  return ($c$$src$List$$reverse)(($c$$src$List$$takeReverse)($n, $list, $c$$src$Core$$Nil));
});

const $c$$src$List$$takeFast = (($ctr, $n, $list) => {
  return (($n < 1)
    ? $c$$src$Core$$Nil
    : ((() => {
      const $4 = ({
        first: $n,
        second: $list,
      });
      return ((($4.second)[0] === "$Nil")
        ? $list
        : (((1 === $4.first) && (($4.second)[0] === "$Cons"))
          ? ((() => {
            const $x = ($4.second)[1];
            return ($c$$src$Core$$Cons)($x, $c$$src$Core$$Nil);
          }))()
          : (((2 === $4.first) && ((($4.second)[0] === "$Cons") && ((($4.second)[2])[0] === "$Cons")))
            ? ((() => {
              const $x = ($4.second)[1];
              const $y = (($4.second)[2])[1];
              return ($c$$src$Core$$Cons)($x, ($c$$src$Core$$Cons)($y, $c$$src$Core$$Nil));
            }))()
            : (((3 === $4.first) && ((($4.second)[0] === "$Cons") && (((($4.second)[2])[0] === "$Cons") && (((($4.second)[2])[2])[0] === "$Cons"))))
              ? ((() => {
                const $x = ($4.second)[1];
                const $y = (($4.second)[2])[1];
                const $z = ((($4.second)[2])[2])[1];
                return ($c$$src$Core$$Cons)($x, ($c$$src$Core$$Cons)($y, ($c$$src$Core$$Cons)($z, $c$$src$Core$$Nil)));
              }))()
              : (((($4.second)[0] === "$Cons") && (((($4.second)[2])[0] === "$Cons") && ((((($4.second)[2])[2])[0] === "$Cons") && ((((($4.second)[2])[2])[2])[0] === "$Cons"))))
                ? ((() => {
                  const $x = ($4.second)[1];
                  const $y = (($4.second)[2])[1];
                  const $z = ((($4.second)[2])[2])[1];
                  const $w = (((($4.second)[2])[2])[2])[1];
                  const $tl = (((($4.second)[2])[2])[2])[2];
                  const $cons = $c$$src$Core$$Cons;
                  return (($ctr > 1000)
                    ? ($cons)($x, ($cons)($y, ($cons)($z, ($cons)($w, ($c$$src$List$$takeTailRec)(($n - 4), $tl)))))
                    : ($cons)($x, ($cons)($y, ($cons)($z, ($cons)($w, ($c$$src$List$$takeFast)(($ctr + 1), ($n - 4), $tl))))));
                }))()
                : (true
                  ? $list
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 278:8', (sp_toHuman)($4))))))));
    }))());
});

const $c$$src$List$$take = (($0, $1) => {
  return ($c$$src$List$$takeFast)(0, $0, $1);
});

const $c$$src$List$$takeWhile = (($test, $its) => {
  const $rec = (($accum, $list) => {
    return ((($list)[0] === "$Nil")
      ? ($c$$src$List$$reverse)($accum)
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $tail = ($list)[2];
          return (($test)($h)
            ? ($rec)((sp_cons)($h, $accum), $tail)
            : ($c$$src$List$$reverse)($accum));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 324:8', (sp_toHuman)($list))));
  });
  return ($rec)($c$$src$Core$$Nil, $its);
});

const $c$$src$List_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $c$$src$List_Test$$concat = ($i$test$$Test$$Group)("concat", ($c$$src$Core$$Cons)(($c$$src$List_Test$$valueTest)("concats two lists", ((_0) => {
  return ($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(3, ($c$$src$Core$$Cons)(4, $c$$src$Core$$Nil)), $c$$src$Core$$Nil)));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, ($c$$src$Core$$Cons)(3, ($c$$src$Core$$Cons)(4, $c$$src$Core$$Nil)))))), $c$$src$Core$$Nil));

const $c$$src$List_Test$$sortBy = ($i$test$$Test$$Group)("sortBy", ($c$$src$Core$$Cons)(($c$$src$List_Test$$valueTest)("Can actually sort stuff", ((_0) => {
  return ((($0) => {
    return (list_sortBy)($c$$src$Basics$$identity, $0);
  }))(($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(23), ($c$$src$Core$$Cons)($c$$src$Maybe$$Nothing, ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(11), $c$$src$Core$$Nil))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(11), ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(23), ($c$$src$Core$$Cons)($c$$src$Maybe$$Nothing, $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($c$$src$List_Test$$valueTest)("Correctly orders tuple-2", ((_0) => {
  return ((($0) => {
    return (list_sortBy)($c$$src$Basics$$identity, $0);
  }))(($c$$src$Core$$Cons)(({
    first: 23,
    second: 1,
  }), ($c$$src$Core$$Cons)(({
    first: 1,
    second: 2,
  }), ($c$$src$Core$$Cons)(({
    first: 11,
    second: 3,
  }), $c$$src$Core$$Nil))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(({
  first: 1,
  second: 2,
}), ($c$$src$Core$$Cons)(({
  first: 11,
  second: 3,
}), ($c$$src$Core$$Cons)(({
  first: 23,
  second: 1,
}), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($c$$src$List_Test$$valueTest)("Correctly orders tuple-3", ((_0) => {
  return ((($0) => {
    return (list_sortBy)($c$$src$Basics$$identity, $0);
  }))(($c$$src$Core$$Cons)(({
    first: "z",
    second: "a",
    third: "2",
  }), ($c$$src$Core$$Cons)(({
    first: "a",
    second: "b",
    third: "33",
  }), ($c$$src$Core$$Cons)(({
    first: "z",
    second: "a",
    third: "1",
  }), ($c$$src$Core$$Cons)(({
    first: "z",
    second: "b",
    third: "3",
  }), $c$$src$Core$$Nil)))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(({
  first: "a",
  second: "b",
  third: "33",
}), ($c$$src$Core$$Cons)(({
  first: "z",
  second: "a",
  third: "1",
}), ($c$$src$Core$$Cons)(({
  first: "z",
  second: "a",
  third: "2",
}), ($c$$src$Core$$Cons)(({
  first: "z",
  second: "b",
  third: "3",
}), $c$$src$Core$$Nil)))))), $c$$src$Core$$Nil))));

const $c$$src$List_Test$$tests = ($i$test$$Test$$Group)("List", ($c$$src$Core$$Cons)($c$$src$List_Test$$sortBy, ($c$$src$Core$$Cons)($c$$src$List_Test$$concat, $c$$src$Core$$Nil)));

const $c$$src$Maybe$$onJust = (($f) => {
  return (($ma) => {
    return ((($ma)[0] === "$Nothing")
      ? $c$$src$Maybe$$Nothing
      : ((($ma)[0] === "$Just")
        ? ((() => {
          const $a = ($ma)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 9:4', (sp_toHuman)($ma))));
  });
});

const $c$$src$Maybe$$toResult = (($e, $maybeA) => {
  return ((($maybeA)[0] === "$Just")
    ? ((() => {
      const $a = ($maybeA)[1];
      return ($c$$src$Result$$Ok)($a);
    }))()
    : ((($maybeA)[0] === "$Nothing")
      ? ($c$$src$Result$$Err)($e)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 36:4', (sp_toHuman)($maybeA))));
});

const $c$$src$Maybe$$withDefault = (($default, $maybe) => {
  return ((($maybe)[0] === "$Just")
    ? ((() => {
      const $v = ($maybe)[1];
      return $v;
    }))()
    : ((($maybe)[0] === "$Nothing")
      ? $default
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 50:4', (sp_toHuman)($maybe))));
});

const $c$$src$Result$$fromMaybe = (($err, $maybe) => {
  return ((($maybe)[0] === "$Nothing")
    ? ($c$$src$Result$$Err)($err)
    : ((($maybe)[0] === "$Just")
      ? ((() => {
        const $a = ($maybe)[1];
        return ($c$$src$Result$$Ok)($a);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 38:4', (sp_toHuman)($maybe))));
});

const $c$$src$Result$$mapError = (($f, $result) => {
  return ((($result)[0] === "$Ok")
    ? ((() => {
      const $a = ($result)[1];
      return ($c$$src$Result$$Ok)($a);
    }))()
    : ((($result)[0] === "$Err")
      ? ((() => {
        const $e1 = ($result)[1];
        return ($c$$src$Result$$Err)(($f)($e1));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 31:4', (sp_toHuman)($result))));
});

const $c$$src$Set$$empty = $c$$src$Dict$$empty;

const $c$$src$Set$$for = (($init, $set, $f) => {
  return ($c$$src$Dict$$for)($init, $set, (($k, _1, $d) => {
    return ($f)($k, $d);
  }));
});

const $c$$src$Set$$insert = (($0, $1) => {
  return ($c$$src$Dict$$insert)($0, null, $1);
});

const $c$$src$Set$$fromList = (($0) => {
  return ($c$$src$List$$for)($c$$src$Set$$empty, $0, $c$$src$Set$$insert);
});

const $c$$src$Set$$member = $c$$src$Dict$$member;

const $c$$src$Text$$contains = (($sub, $str) => {
  const $3 = (text_split)($sub, $str);
  return (((($3)[0] === "$Cons") && ((($3)[2])[0] === "$Nil"))
    ? false
    : (true
      ? true
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 120:4', (sp_toHuman)($3))));
});

const $c$$src$Text$$repeat = (($n, $s) => {
  return ($c$$src$Text$$join)("", ($c$$src$List$$repeat)($n, $s));
});

const $c$$src$Text$$padLeft = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($textLength - $minLength), (text_length)($pad));
      return (($c$$src$Text$$repeat)($times, $pad) + $s);
    }))()
    : $s);
});

const $c$$src$Text$$padRight = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($textLength - $minLength), (text_length)($pad));
      return ($s + ($c$$src$Text$$repeat)($times, $pad));
    }))()
    : $s);
});

const $c$$src$Text$$replace = (($toRemove, $toPut, $s) => {
  return ((($0) => {
    return ($c$$src$Text$$join)($toPut, $0);
  }))(((($0) => {
    return (text_split)($toRemove, $0);
  }))($s));
});

const $c$$src$Text$$trimRight = ((() => {
  const $re = (text_replaceRegex)("[ ]*$");
  return (($0) => {
    return ($re)("", $0);
  });
}))();

const $c$$src$Tuple$$mapFirst = (($f, $t) => {
  return ({
    first: ($f)($t.first),
    second: $t.second,
  });
});

const $c$$src$Tuple$$mapSecond = (($f, $t) => {
  return ({
    first: $t.first,
    second: ($f)($t.second),
  });
});

const $c$$src$Tuple$$pair = (($a, $b) => {
  return ({
    first: $a,
    second: $b,
  });
});

const $i$posix$$IO$$reToStderr = (($io, $re) => {
  return ([
    ((($re)[0] === "$Ok")
      ? 0
      : ((($re)[0] === "$Err")
        ? ((() => {
          const $error = ($re)[1];
          ((__re__ = (io_writeStderr)($io, ($error + "\n"))), ($io = (__re__)[1]), (__re__)[0]);
          return 1;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/posix/IO.sp 19:4', (sp_toHuman)($re)))),
    $io,
  ]);
});

const $i$test$$Test$$codeTest = (($toText, $title, $code, $functionToTest, $ce) => {
  const $6 = $ce;
  const $toMaybeError = ($6)[1];
  return ($i$test$$Test$$Single)($title, $code, ((_0) => {
    return ($i$test$$Test$$maybeToOutcome)(((($0) => {
      return ($toMaybeError)($toText, $0);
    }))(($functionToTest)($code)));
  }));
});

const $i$test$$Test$$errorContains = (($snippets) => {
  return ($i$test$$Test$$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "$Ok")
      ? ((() => {
        const $ok = ($result)[1];
        return ($c$$src$Maybe$$Just)(("I was expecting an error, but got: Ok " + ($toText)($ok)));
      }))()
      : ((($result)[0] === "$Err")
        ? ((() => {
          const $e = ($result)[1];
          const $missing = ((($0) => {
            return ($c$$src$List$$filter)((($sn) => {
              return ($c$$src$Basics$$not)(($c$$src$Text$$contains)($sn, $e));
            }), $0);
          }))($snippets);
          return ((sp_equal)($missing, $c$$src$Core$$Nil)
            ? $c$$src$Maybe$$Nothing
            : ((() => {
              const $indentedError = ((($0) => {
                return ($c$$src$Text$$join)("\n", $0);
              }))(((($0) => {
                return ($c$$src$List$$map)((($l) => {
                  return ("    " + $l);
                }), $0);
              }))(((($0) => {
                return (text_split)("\n", $0);
              }))($e)));
              return ($c$$src$Maybe$$Just)(("Error message:\n\n" + ($indentedError + ("\n\nis missing snippets: " + ($c$$src$Text$$join)(", ", $missing)))));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 96:8', (sp_toHuman)($result))));
  }));
});

const $i$test$$Test$$getName = (($test) => {
  return ((($test)[0] === "$Single")
    ? ((() => {
      const $n = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return $n;
    }))()
    : ((($test)[0] === "$Group")
      ? ((() => {
        const $n = ($test)[1];
        const $ls = ($test)[2];
        return $n;
      }))()
      : ((($test)[0] === "$NotNow")
        ? ((() => {
          const $t = ($test)[1];
          return ($i$test$$Test$$getName)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 145:4', (sp_toHuman)($test)))));
});

const $i$test$$Test$$outcomesRec = (($path, $test, $accum) => {
  return ((($test)[0] === "$Single")
    ? ((() => {
      const $name = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return (sp_cons)(({
        code: $code,
        getOutcome: $f,
        name: ($path + $name),
      }), $accum);
    }))()
    : ((($test)[0] === "$NotNow")
      ? ((() => {
        const $t = ($test)[1];
        const $thing = ({
          code: "",
          getOutcome: ((_0) => {
            return $i$test$$Test$$Skipped;
          }),
          name: ($path + ($i$test$$Test$$getName)($t)),
        });
        return (sp_cons)($thing, $accum);
      }))()
      : ((($test)[0] === "$Group")
        ? ((() => {
          const $pathSegment = ($test)[1];
          const $ts = ($test)[2];
          return ($c$$src$List$$for)($accum, $ts, (($0, $1) => {
            return ($i$test$$Test$$outcomesRec)(($path + ($pathSegment + " / ")), $0, $1);
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 128:4', (sp_toHuman)($test)))));
});

const $i$test$$Test$$flattenAndRun = (($tests) => {
  const $flattened = ((($0) => {
    return ($c$$src$List$$map)((($r) => {
      return (($c$$src$Text$$contains)("SKIP", $r.name)
        ? ((() => {
          const $0 = $r;
          return (Object.assign)({}, $0, ({
            getOutcome: ((_0) => {
              return $i$test$$Test$$Skipped;
            }),
          }));
        }))()
        : $r);
    }), $0);
  }))(($i$test$$Test$$outcomesRec)("", ($i$test$$Test$$Group)("", $tests), $c$$src$Core$$Nil));
  const $onlies = ((($0) => {
    return ($c$$src$List$$filter)((($r) => {
      return ($c$$src$Text$$contains)("ONLY", $r.name);
    }), $0);
  }))($flattened);
  const $runnable = ((sp_not_equal)($onlies, $c$$src$Core$$Nil)
    ? $onlies
    : $flattened);
  const $runTest = (($r) => {
    const $3 = $r;
    const $name = $3.name;
    const $getOutcome = $3.getOutcome;
    const $code = $3.code;
    return ({
      code: $code,
      name: $name,
      outcome: ($getOutcome)(null),
    });
  });
  return ($c$$src$List$$map)($runTest, $runnable);
});

const $i$test$$Test$$freeform = (($test) => {
  return ($i$test$$Test$$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($c$$src$Maybe$$Just)($e);
      }))()
      : ((($result)[0] === "$Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return ($test)($actualOk);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 57:5', (sp_toHuman)($result))));
  }));
});

const $i$test$$Test$$isOk = ($i$test$$Test$$CodeExpectation)((($toText, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return ($c$$src$Maybe$$Just)($e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $actualOk = ($result)[1];
        return $c$$src$Maybe$$Nothing;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 65:8', (sp_toHuman)($result))));
}));

const $u$$specs$Uniqueness$$codeTest = (($0, $1, $2, $3) => {
  return ($i$test$$Test$$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const $u$$src$Compiler$CoreDefs$$defToType = (($def, $pars) => {
  return ($c$$src$Compiler$CanonicalAst$$TypeNamed)($c$$src$Compiler$Pos$$N, $def.usr, $pars);
});

const $u$$src$Compiler$CoreDefs$$importsPath = ($c$$src$Compiler$Meta$$ImportsPath)($c$$src$Compiler$Meta$$Core, "");

const $u$$src$Compiler$CoreDefs$$umr = ($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$CoreDefs$$importsPath, "src", "Core");

const $u$$src$Compiler$CoreDefs$$usr = (($0) => {
  return ($c$$src$Compiler$Meta$$USR)($u$$src$Compiler$CoreDefs$$umr, $0);
});

const $u$$src$Compiler$CoreDefs$$numberUsr = ($u$$src$Compiler$CoreDefs$$usr)("Number");

const $u$$src$Compiler$CoreDefs$$numberDef = ({
  constructors: $c$$src$Dict$$empty,
  pars: $c$$src$Core$$Nil,
  usr: $u$$src$Compiler$CoreDefs$$numberUsr,
});

const $u$$src$Compiler$CoreDefs$$number = ($u$$src$Compiler$CoreDefs$$defToType)($u$$src$Compiler$CoreDefs$$numberDef, $c$$src$Core$$Nil);

const $u$$src$Compiler$CoreDefs$$typeBinopUnique = (($ty) => {
  return ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$N, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($ty)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($ty)), $c$$src$Core$$Nil)), ($c$$src$Compiler$Ast$$toUni)($ty));
});

const $u$$src$Compiler$CoreDefs$$add = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_addittive,
  symbol: "+",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$number),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("add"),
});

const $u$$src$Compiler$CoreDefs$$boolName = "Bool";

const $u$$src$Compiler$CoreDefs$$nameToType = (($name, $args) => {
  return ($c$$src$Compiler$CanonicalAst$$TypeNamed)($c$$src$Compiler$Pos$$N, ($u$$src$Compiler$CoreDefs$$usr)($name), $args);
});

const $u$$src$Compiler$CoreDefs$$boolType = ($u$$src$Compiler$CoreDefs$$nameToType)($u$$src$Compiler$CoreDefs$$boolName, $c$$src$Core$$Nil);

const $u$$src$Compiler$CoreDefs$$and_ = ({
  associativity: $c$$src$Compiler$Op$$Right,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_logical,
  symbol: "and",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("and_"),
});

const $u$$src$Compiler$CoreDefs$$divide = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_multiplicative,
  symbol: "/",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$number),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("divide"),
});

const $u$$src$Compiler$CoreDefs$$tyVar = (($0) => {
  return ($c$$src$Compiler$CanonicalAst$$TypeAnnotationVariable)($c$$src$Compiler$Pos$$N, $0);
});

const $u$$src$Compiler$CoreDefs$$tyFn = (($pars, $to) => {
  return ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$N, ($c$$src$List$$map)((($p) => {
    return ($c$$src$Compiler$CanonicalAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($p));
  }), $pars), ($c$$src$Compiler$Ast$$toImm)($to));
});

const $u$$src$Compiler$CoreDefs$$typeBinop = (($left, $right, $return) => {
  return ($u$$src$Compiler$CoreDefs$$tyFn)(($c$$src$Core$$Cons)($left, ($c$$src$Core$$Cons)($right, $c$$src$Core$$Nil)), $return);
});

const $u$$src$Compiler$CoreDefs$$equal = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil),
  precedence: $c$$src$Compiler$Op$$precedence_comparison,
  symbol: "==",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("equal"),
});

const $u$$src$Compiler$CoreDefs$$greaterOrEqualThan = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil),
  precedence: $c$$src$Compiler$Op$$precedence_comparison,
  symbol: ">=",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("greaterOrEqualThan"),
});

const $u$$src$Compiler$CoreDefs$$greaterThan = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil),
  precedence: $c$$src$Compiler$Op$$precedence_comparison,
  symbol: ">",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("greaterThan"),
});

const $u$$src$Compiler$CoreDefs$$lesserOrEqualThan = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil),
  precedence: $c$$src$Compiler$Op$$precedence_comparison,
  symbol: "<=",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("lesserOrEqualThan"),
});

const $u$$src$Compiler$CoreDefs$$lesserThan = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil),
  precedence: $c$$src$Compiler$Op$$precedence_comparison,
  symbol: "<",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("lesserThan"),
});

const $u$$src$Compiler$CoreDefs$$listName = "List";

const $u$$src$Compiler$CoreDefs$$listType = (($item) => {
  return ($u$$src$Compiler$CoreDefs$$nameToType)($u$$src$Compiler$CoreDefs$$listName, ($c$$src$Core$$Cons)($item, $c$$src$Core$$Nil));
});

const $u$$src$Compiler$CoreDefs$$listCons = ((() => {
  const $item = ($u$$src$Compiler$CoreDefs$$tyVar)("item");
  return ({
    associativity: $c$$src$Compiler$Op$$Right,
    nonFn: $c$$src$Core$$Nil,
    precedence: $c$$src$Compiler$Op$$precedence_cons,
    symbol: "::",
    type: ($u$$src$Compiler$CoreDefs$$typeBinop)($item, ($u$$src$Compiler$CoreDefs$$listType)($item), ($u$$src$Compiler$CoreDefs$$listType)($item)),
    usr: ($u$$src$Compiler$CoreDefs$$usr)("stack"),
  });
}))();

const $u$$src$Compiler$CoreDefs$$multiply = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_multiplicative,
  symbol: "*",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$number),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("multiply"),
});

const $u$$src$Compiler$CoreDefs$$noneTypeName = "None";

const $u$$src$Compiler$CoreDefs$$noneType = ($u$$src$Compiler$CoreDefs$$nameToType)($u$$src$Compiler$CoreDefs$$noneTypeName, $c$$src$Core$$Nil);

const $u$$src$Compiler$CoreDefs$$mutableAdd = ({
  associativity: $c$$src$Compiler$Op$$NonAssociative,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_mutop,
  symbol: "+=",
  type: ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$N, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParRe)($u$$src$Compiler$CoreDefs$$number), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParSp)(({
    raw: $u$$src$Compiler$CoreDefs$$number,
    uni: $c$$src$Compiler$Ast$$Imm,
  })), $c$$src$Core$$Nil)), ({
    raw: $u$$src$Compiler$CoreDefs$$noneType,
    uni: $c$$src$Compiler$Ast$$Imm,
  })),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("mutableAdd"),
});

const $u$$src$Compiler$CoreDefs$$mutableAssign = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_mutop,
  symbol: ":=",
  type: ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$N, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParRe)(($u$$src$Compiler$CoreDefs$$tyVar)("a")), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParSp)(({
    raw: ($u$$src$Compiler$CoreDefs$$tyVar)("a"),
    uni: $c$$src$Compiler$Ast$$Uni,
  })), $c$$src$Core$$Nil)), ({
    raw: $u$$src$Compiler$CoreDefs$$noneType,
    uni: $c$$src$Compiler$Ast$$Imm,
  })),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("mutableAssign"),
});

const $u$$src$Compiler$CoreDefs$$mutableSubtract = ({
  associativity: $c$$src$Compiler$Op$$NonAssociative,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_mutop,
  symbol: "-=",
  type: ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$N, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParRe)($u$$src$Compiler$CoreDefs$$number), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParSp)(({
    raw: $u$$src$Compiler$CoreDefs$$number,
    uni: $c$$src$Compiler$Ast$$Imm,
  })), $c$$src$Core$$Nil)), ({
    raw: $u$$src$Compiler$CoreDefs$$noneType,
    uni: $c$$src$Compiler$Ast$$Imm,
  })),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("mutableSubtract"),
});

const $u$$src$Compiler$CoreDefs$$notEqual = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil),
  precedence: $c$$src$Compiler$Op$$precedence_comparison,
  symbol: "/=",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("notEqual"),
});

const $u$$src$Compiler$CoreDefs$$or_ = ({
  associativity: $c$$src$Compiler$Op$$Right,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_logical,
  symbol: "or",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$boolType),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("or_"),
});

const $u$$src$Compiler$CoreDefs$$sendLeft = ({
  associativity: $c$$src$Compiler$Op$$Right,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_pipe,
  symbol: "<<",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyFn)(($c$$src$Core$$Cons)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), $c$$src$Core$$Nil), ($u$$src$Compiler$CoreDefs$$tyVar)("b")), ($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("b")),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("sendLeft"),
});

const $u$$src$Compiler$CoreDefs$$sendRight = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_pipe,
  symbol: ">>",
  type: ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyFn)(($c$$src$Core$$Cons)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), $c$$src$Core$$Nil), ($u$$src$Compiler$CoreDefs$$tyVar)("b")), ($u$$src$Compiler$CoreDefs$$tyVar)("b")),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("sendRight"),
});

const $u$$src$Compiler$CoreDefs$$subtract = ({
  associativity: $c$$src$Compiler$Op$$Left,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_addittive,
  symbol: "-",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$number),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("subtract"),
});

const $u$$src$Compiler$CoreDefs$$textUsr = ($u$$src$Compiler$CoreDefs$$usr)("Text");

const $u$$src$Compiler$CoreDefs$$textDef = ({
  constructors: $c$$src$Dict$$empty,
  pars: $c$$src$Core$$Nil,
  usr: $u$$src$Compiler$CoreDefs$$textUsr,
});

const $u$$src$Compiler$CoreDefs$$text = ($u$$src$Compiler$CoreDefs$$defToType)($u$$src$Compiler$CoreDefs$$textDef, $c$$src$Core$$Nil);

const $u$$src$Compiler$CoreDefs$$textConcat = ({
  associativity: $c$$src$Compiler$Op$$Right,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_addittive,
  symbol: "..",
  type: ($u$$src$Compiler$CoreDefs$$typeBinopUnique)($u$$src$Compiler$CoreDefs$$text),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("concat"),
});

const $u$$src$Compiler$CoreDefs$$tuple = ({
  associativity: $c$$src$Compiler$Op$$NonAssociative,
  nonFn: $c$$src$Core$$Nil,
  precedence: $c$$src$Compiler$Op$$precedence_tuple,
  symbol: "&",
  type: ((($0) => {
    return ($u$$src$Compiler$CoreDefs$$typeBinop)(($u$$src$Compiler$CoreDefs$$tyVar)("a"), ($u$$src$Compiler$CoreDefs$$tyVar)("b"), $0);
  }))(((($0) => {
    return ($c$$src$Compiler$CanonicalAst$$TypeRecord)($c$$src$Compiler$Pos$$N, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)("second", ($u$$src$Compiler$CoreDefs$$tyVar)("b"), $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)("first", ($u$$src$Compiler$CoreDefs$$tyVar)("a"), $0);
  }))($c$$src$Dict$$empty)))),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("<& is just sugar>"),
});

const $u$$src$Compiler$CoreDefs$$binops = ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$and_, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$or_, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$textConcat, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$listCons, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$tuple, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$add, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$subtract, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$multiply, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$divide, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$mutableAssign, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$mutableAdd, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$mutableSubtract, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$equal, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$notEqual, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$lesserThan, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$greaterThan, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$lesserOrEqualThan, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$greaterOrEqualThan, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$sendRight, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$sendLeft, $c$$src$Core$$Nil))))))))))))))))))));

const $u$$src$Compiler$CoreDefs$$boolUsr = ($u$$src$Compiler$CoreDefs$$usr)("Bool");

const $u$$src$Compiler$CoreDefs$$falseName = "'false";

const $u$$src$Compiler$CoreDefs$$falseUsr = ($u$$src$Compiler$CoreDefs$$usr)($u$$src$Compiler$CoreDefs$$falseName);

const $u$$src$Compiler$CoreDefs$$falseDef = ({
  constructorUsr: $u$$src$Compiler$CoreDefs$$falseUsr,
  directDeps: ($c$$src$Dict$$ofOne)($u$$src$Compiler$CoreDefs$$boolUsr, $c$$src$Compiler$Meta$$TypeDependency),
  ins: $c$$src$Core$$Nil,
  name: $u$$src$Compiler$CoreDefs$$falseName,
  out: $u$$src$Compiler$CoreDefs$$boolType,
  pos: $c$$src$Compiler$Pos$$N,
  variantTypeUsr: $u$$src$Compiler$CoreDefs$$boolUsr,
});

const $u$$src$Compiler$CoreDefs$$trueName = "'true";

const $u$$src$Compiler$CoreDefs$$trueUsr = ($u$$src$Compiler$CoreDefs$$usr)($u$$src$Compiler$CoreDefs$$trueName);

const $u$$src$Compiler$CoreDefs$$trueDef = ({
  constructorUsr: $u$$src$Compiler$CoreDefs$$trueUsr,
  directDeps: ($c$$src$Dict$$ofOne)($u$$src$Compiler$CoreDefs$$boolUsr, $c$$src$Compiler$Meta$$TypeDependency),
  ins: $c$$src$Core$$Nil,
  name: $u$$src$Compiler$CoreDefs$$trueName,
  out: $u$$src$Compiler$CoreDefs$$boolType,
  pos: $c$$src$Compiler$Pos$$N,
  variantTypeUsr: $u$$src$Compiler$CoreDefs$$boolUsr,
});

const $u$$src$Compiler$CoreDefs$$boolDef = ({
  constructors: ((($0) => {
    return ($c$$src$Dict$$insert)($u$$src$Compiler$CoreDefs$$falseName, $u$$src$Compiler$CoreDefs$$falseDef, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)($u$$src$Compiler$CoreDefs$$trueName, $u$$src$Compiler$CoreDefs$$trueDef, $0);
  }))($c$$src$Dict$$empty)),
  pars: $c$$src$Core$$Nil,
  usr: $u$$src$Compiler$CoreDefs$$boolUsr,
});

const $u$$src$Compiler$CoreDefs$$consName = "'cons";

const $u$$src$Compiler$CoreDefs$$consUsr = ($u$$src$Compiler$CoreDefs$$usr)($u$$src$Compiler$CoreDefs$$consName);

const $u$$src$Compiler$CoreDefs$$listItem = ($c$$src$Compiler$CanonicalAst$$TypeAnnotationVariable)($c$$src$Compiler$Pos$$N, "item");

const $u$$src$Compiler$CoreDefs$$listUsr = ($u$$src$Compiler$CoreDefs$$usr)("List");

const $u$$src$Compiler$CoreDefs$$consDef = ({
  constructorUsr: $u$$src$Compiler$CoreDefs$$consUsr,
  directDeps: ($c$$src$Dict$$ofOne)($u$$src$Compiler$CoreDefs$$listUsr, $c$$src$Compiler$Meta$$TypeDependency),
  ins: ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$listItem, ($c$$src$Core$$Cons)(($u$$src$Compiler$CoreDefs$$listType)($u$$src$Compiler$CoreDefs$$listItem), $c$$src$Core$$Nil)),
  name: $u$$src$Compiler$CoreDefs$$consName,
  out: ($u$$src$Compiler$CoreDefs$$listType)($u$$src$Compiler$CoreDefs$$listItem),
  pos: $c$$src$Compiler$Pos$$N,
  variantTypeUsr: $u$$src$Compiler$CoreDefs$$listUsr,
});

const $u$$src$Compiler$MakeCanonical$$typeDeps = (($type, $acc) => {
  return ((($type)[0] === "$TypeNamed")
    ? ((() => {
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return ((($0) => {
        return ($c$$src$List$$for)($0, $args, $u$$src$Compiler$MakeCanonical$$typeDeps);
      }))(((($0) => {
        return ($c$$src$Dict$$insert)($usr, $c$$src$Compiler$Meta$$TypeDependency, $0);
      }))($acc));
    }))()
    : ((($type)[0] === "$TypeAnnotationVariable")
      ? $acc
      : ((($type)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($type)[2];
          return ($c$$src$Dict$$for)($acc, $attrs, (($k, $v, $a) => {
            return ($u$$src$Compiler$MakeCanonical$$typeDeps)($v, $a);
          }));
        }))()
        : ((($type)[0] === "$TypeError")
          ? $acc
          : ((($type)[0] === "$TypeFn")
            ? ((() => {
              const $params = ($type)[2];
              const $to = ($type)[3];
              return ((($0) => {
                return ($c$$src$List$$for)($0, $params, (($par, $z) => {
                  return ((($par)[0] === "$ParRe")
                    ? ((() => {
                      const $raw = ($par)[1];
                      return ($u$$src$Compiler$MakeCanonical$$typeDeps)($raw, $z);
                    }))()
                    : ((($par)[0] === "$ParSp")
                      ? ((() => {
                        const $full = ($par)[1];
                        return ($u$$src$Compiler$MakeCanonical$$typeDeps)($full.raw, $z);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 97:16', (sp_toHuman)($par))));
                }));
              }))(((($0) => {
                return ($u$$src$Compiler$MakeCanonical$$typeDeps)($to.raw, $0);
              }))($acc));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 79:4', (sp_toHuman)($type)))))));
});

const $u$$src$Compiler$CoreDefs$$insert = (($4, $raw, $nonFnAsList, $dict) => {
  const $name = ($4)[2];
  const $nonFn = ($c$$src$Set$$fromList)($nonFnAsList);
  const $tyvars = ((($0) => {
    return ($c$$src$Dict$$map)((($n, $pos) => {
      return ({
        nonFn: (($c$$src$Set$$member)($n, $nonFn)
          ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Pos$$N)
          : $c$$src$Maybe$$Nothing),
      });
    }), $0);
  }))(((($0) => {
    return ($c$$src$Compiler$CanonicalAst$$typeTyvars)($0);
  }))($raw));
  return ((($0) => {
    return ($c$$src$Dict$$insert)($name, $0, $dict);
  }))(({
    directDeps: ($u$$src$Compiler$MakeCanonical$$typeDeps)($raw, $c$$src$Dict$$empty),
    maybeAnnotation: ($c$$src$Maybe$$Just)(({
      raw: $raw,
      tyvars: $tyvars,
      univars: $c$$src$Dict$$empty,
    })),
    maybeBody: $c$$src$Maybe$$Nothing,
    name: $name,
    namePos: $c$$src$Compiler$Pos$$N,
  }));
});

const $u$$src$Compiler$CoreDefs$$nilName = "'nil";

const $u$$src$Compiler$CoreDefs$$nilUsr = ($u$$src$Compiler$CoreDefs$$usr)($u$$src$Compiler$CoreDefs$$nilName);

const $u$$src$Compiler$CoreDefs$$nilDef = ({
  constructorUsr: $u$$src$Compiler$CoreDefs$$nilUsr,
  directDeps: ($c$$src$Dict$$ofOne)($u$$src$Compiler$CoreDefs$$listUsr, $c$$src$Compiler$Meta$$TypeDependency),
  ins: $c$$src$Core$$Nil,
  name: $u$$src$Compiler$CoreDefs$$nilName,
  out: ($u$$src$Compiler$CoreDefs$$listType)($u$$src$Compiler$CoreDefs$$listItem),
  pos: $c$$src$Compiler$Pos$$N,
  variantTypeUsr: $u$$src$Compiler$CoreDefs$$listUsr,
});

const $u$$src$Compiler$CoreDefs$$listDef = ({
  constructors: ((($0) => {
    return ($c$$src$Dict$$insert)($u$$src$Compiler$CoreDefs$$consName, $u$$src$Compiler$CoreDefs$$consDef, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$insert)($u$$src$Compiler$CoreDefs$$nilName, $u$$src$Compiler$CoreDefs$$nilDef, $0);
  }))($c$$src$Dict$$empty)),
  pars: ($c$$src$Core$$Cons)(({
    first: "item",
    second: $c$$src$Compiler$Pos$$N,
  }), $c$$src$Core$$Nil),
  usr: $u$$src$Compiler$CoreDefs$$listUsr,
});

const $u$$src$Compiler$CoreDefs$$noneConsName = "'none";

const $u$$src$Compiler$CoreDefs$$noneConsUsr = ($u$$src$Compiler$CoreDefs$$usr)($u$$src$Compiler$CoreDefs$$noneConsName);

const $u$$src$Compiler$CoreDefs$$noneTypeUsr = ($u$$src$Compiler$CoreDefs$$usr)($u$$src$Compiler$CoreDefs$$noneTypeName);

const $u$$src$Compiler$CoreDefs$$noneConsDef = ({
  constructorUsr: $u$$src$Compiler$CoreDefs$$noneConsUsr,
  directDeps: ($c$$src$Dict$$ofOne)($u$$src$Compiler$CoreDefs$$noneTypeUsr, $c$$src$Compiler$Meta$$TypeDependency),
  ins: $c$$src$Core$$Nil,
  name: $u$$src$Compiler$CoreDefs$$noneConsName,
  out: $u$$src$Compiler$CoreDefs$$noneType,
  pos: $c$$src$Compiler$Pos$$N,
  variantTypeUsr: $u$$src$Compiler$CoreDefs$$noneTypeUsr,
});

const $u$$src$Compiler$CoreDefs$$noneTypeDef = ({
  constructors: ($c$$src$Dict$$ofOne)($u$$src$Compiler$CoreDefs$$noneConsName, $u$$src$Compiler$CoreDefs$$noneConsDef),
  pars: $c$$src$Core$$Nil,
  usr: $u$$src$Compiler$CoreDefs$$noneTypeUsr,
});

const $u$$src$Compiler$CoreDefs$$unaryMinus = ({
  symbol: "0 -",
  type: ($u$$src$Compiler$CoreDefs$$tyFn)(($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$number, $c$$src$Core$$Nil), $u$$src$Compiler$CoreDefs$$number),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("unaryMinus"),
});

const $u$$src$Compiler$CoreDefs$$unaryPlus = ({
  symbol: "0 +",
  type: ($u$$src$Compiler$CoreDefs$$tyFn)(($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$number, $c$$src$Core$$Nil), $u$$src$Compiler$CoreDefs$$number),
  usr: ($u$$src$Compiler$CoreDefs$$usr)("unaryPlus"),
});

const $u$$src$Compiler$CoreDefs$$coreModule = ((() => {
  const $variantTypeDefs = ((($0) => {
    return ($c$$src$List$$for)($c$$src$Dict$$empty, $0, (($def, $dict) => {
      const $4 = $def.usr;
      const $name = ($4)[2];
      return ($c$$src$Dict$$insert)($name, $def, $dict);
    }));
  }))(($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$textDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$numberDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$noneTypeDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$boolDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$listDef, $c$$src$Core$$Nil))))));
  const $constructorDefs = ((($0) => {
    return ($c$$src$List$$for)($c$$src$Dict$$empty, $0, (($def, $dict) => {
      return ($c$$src$Dict$$insert)($def.name, $def, $dict);
    }));
  }))(($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$noneConsDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$trueDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$falseDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$nilDef, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$consDef, $c$$src$Core$$Nil))))));
  const $valueDefs = ((($0) => {
    return ($c$$src$List$$for)($0, $u$$src$Compiler$CoreDefs$$binops, (($binop, $dict) => {
      return ($u$$src$Compiler$CoreDefs$$insert)($binop.usr, $binop.type, $binop.nonFn, $dict);
    }));
  }))(((($0) => {
    return ($c$$src$List$$for)($0, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$unaryPlus, ($c$$src$Core$$Cons)($u$$src$Compiler$CoreDefs$$unaryMinus, $c$$src$Core$$Nil)), (($unop, $dict) => {
      return ($u$$src$Compiler$CoreDefs$$insert)($unop.usr, $unop.type, $c$$src$Core$$Nil, $dict);
    }));
  }))($c$$src$Dict$$empty));
  return ({
    aliasDefs: $c$$src$Dict$$empty,
    asText: "<core module>",
    constructorDefs: $constructorDefs,
    fsPath: "<core module>",
    umr: $u$$src$Compiler$CoreDefs$$umr,
    valueDefs: $valueDefs,
    variantTypeDefs: $variantTypeDefs,
  });
}))();

const $u$$src$Compiler$LazyBuild$$collectUsrDependencies = (($env, $state, $usr, $depType) => {
  const $5 = $usr;
  const $name = ($5)[2];
  const $umr = ($5)[1];
  return ([
    (($c$$src$Result$$onOk)((($caModule) => {
      const $7 = ((($depType)[0] === "$TypeDependency")
        ? ((() => {
          const $8 = ($c$$src$Dict$$get)($name, $caModule.aliasDefs);
          return ((($8)[0] === "$Just")
            ? ((() => {
              const $d = ($8)[1];
              return ({
                first: ($u$$src$Compiler$LazyBuild$$AliasDef)($d),
                second: $d.directDeps,
              });
            }))()
            : ((($8)[0] === "$Nothing")
              ? ((() => {
                const $9 = ($c$$src$Dict$$get)($name, $caModule.variantTypeDefs);
                return ((($9)[0] === "$Just")
                  ? ((() => {
                    const $d = ($9)[1];
                    return ({
                      first: ($u$$src$Compiler$LazyBuild$$VariantTypeDef)($d),
                      second: $c$$src$Dict$$empty,
                    });
                  }))()
                  : ((($9)[0] === "$Nothing")
                    ? ({
                      first: $u$$src$Compiler$LazyBuild$$MissingDef,
                      second: $c$$src$Dict$$empty,
                    })
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 78:24', (sp_toHuman)($9))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 72:16', (sp_toHuman)($8))));
        }))()
        : ((($depType)[0] === "$ConstructorDependency")
          ? ((() => {
            const $8 = ($c$$src$Dict$$get)($name, $caModule.constructorDefs);
            return ((($8)[0] === "$Just")
              ? ((() => {
                const $d = ($8)[1];
                return ({
                  first: ($u$$src$Compiler$LazyBuild$$ConstructorDef)($d),
                  second: $d.directDeps,
                });
              }))()
              : ((($8)[0] === "$Nothing")
                ? ({
                  first: $u$$src$Compiler$LazyBuild$$MissingDef,
                  second: $c$$src$Dict$$empty,
                })
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 88:16', (sp_toHuman)($8))));
          }))()
          : ((($depType)[0] === "$ValueDependency")
            ? ((() => {
              const $8 = ($c$$src$Dict$$get)($name, $caModule.valueDefs);
              return ((($8)[0] === "$Just")
                ? ((() => {
                  const $d = ($8)[1];
                  return ({
                    first: ($u$$src$Compiler$LazyBuild$$ValueDef)($d),
                    second: $d.directDeps,
                  });
                }))()
                : ((($8)[0] === "$Nothing")
                  ? ({
                    first: $u$$src$Compiler$LazyBuild$$MissingDef,
                    second: $c$$src$Dict$$empty,
                  })
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 93:16', (sp_toHuman)($8))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 69:8', (sp_toHuman)($depType)))));
      const $deps = $7.second;
      const $def = $7.first;
      ((__re__ = (hash_insert)($state.done, $usr, ({
        def: $def,
        deps: $deps,
      }))), ($state.done = (__re__)[1]), (__re__)[0]);
      ($c$$src$Dict$$each)($deps, (($u, $c) => {
        return ((sp_equal)(((__re__ = (hash_get)($state.done, $u)), ($state.done = (__re__)[1]), (__re__)[0]), $c$$src$Maybe$$Nothing)
          ? ((__re__ = (hash_insert)($state.pending, $u, $c)), ($state.pending = (__re__)[1]), (__re__)[0])
          : null);
      }));
      return ($c$$src$Result$$Ok)(null);
    })))(((() => {
      const $6 = ((__re__ = (hash_get)($state.loadedModulesByUmr, $umr)), ($state.loadedModulesByUmr = (__re__)[1]), (__re__)[0]);
      return ((($6)[0] === "$Just")
        ? ((() => {
          const $caModule = ($6)[1];
          return ($c$$src$Result$$Ok)($caModule);
        }))()
        : ((($6)[0] === "$Nothing")
          ? (($c$$src$Result$$onOk)((($caModule) => {
            ((__re__ = (hash_insert)($state.loadedModulesByUmr, $umr, $caModule)), ($state.loadedModulesByUmr = (__re__)[1]), (__re__)[0]);
            return ($c$$src$Result$$Ok)($caModule);
          })))(($env.loadCaModule)($umr))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 56:4', (sp_toHuman)($6))));
    }))()),
    $state,
  ]);
});

const $u$$src$Compiler$LazyBuild$$collectRequiredUsrs = (($env, $state) => {
  const $3 = ((__re__ = (hash_pop)($state.pending)), ($state.pending = (__re__)[1]), (__re__)[0]);
  return ([
    ((($3)[0] === "$Nothing")
      ? ($c$$src$Result$$Ok)(null)
      : ((($3)[0] === "$Just")
        ? ((() => {
          const $usr = ($3)[1].first;
          const $depType = ($3)[1].second;
          return (($c$$src$Result$$onOk)(((_0) => {
            return ((__re__ = ($u$$src$Compiler$LazyBuild$$collectRequiredUsrs)($env, $state)), ($state = (__re__)[1]), (__re__)[0]);
          })))(((__re__ = ($u$$src$Compiler$LazyBuild$$collectUsrDependencies)($env, $state, $usr, $depType)), ($state = (__re__)[1]), (__re__)[0]));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 110:4', (sp_toHuman)($3)))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$startsWithUpperChar = ((() => {
  const $re = (text_startsWithRegex)("[A-Z]");
  return (($s) => {
    const $2 = ($re)($s);
    return (("" === $2)
      ? false
      : (true
        ? true
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 316:4', (sp_toHuman)($2))));
  });
}))();

const $u$$src$Compiler$LazyBuild$$usrToDependencyType = (($1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return (($u$$src$Compiler$Lexer$$startsWithUpperChar)($name)
    ? $c$$src$Compiler$Meta$$TypeDependency
    : ((text_startsWith)("'", $name)
      ? $c$$src$Compiler$Meta$$ConstructorDependency
      : $c$$src$Compiler$Meta$$ValueDependency));
});

const $u$$src$Compiler$TypeCheck$$initState = (($lastUnificationVarId) => {
  return ({
    boundTyvars: (hash_fromList)($c$$src$Core$$Nil),
    errors: (array_fromList)($c$$src$Core$$Nil),
    lastUnificationVarId: $lastUnificationVarId,
    tyvarSubs: (hash_fromList)($c$$src$Core$$Nil),
    tyvarsById: (hash_fromList)($c$$src$Core$$Nil),
    univarSubs: (hash_fromList)($c$$src$Core$$Nil),
    univarsById: (hash_fromList)($c$$src$Core$$Nil),
  });
});

const $u$$src$Compiler$TypeCheck$$newTyvarId = (($state) => {
  ($state.lastUnificationVarId += 1);
  return ([
    ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$getErrorModule = (($env) => {
  const $2 = $env.currentRootUsr;
  const $umr = ($2)[1];
  const $3 = ($c$$src$Dict$$get)($umr, $env.modulesByUmr);
  return ((($3)[0] === "$Nothing")
    ? ({
      content: "",
      fsPath: "N/A",
    })
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $content = ($3)[1].asText;
        const $fsPath = ($3)[1].fsPath;
        return ({
          content: $content,
          fsPath: $fsPath,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 288:4', (sp_toHuman)($3))));
});

const $u$$src$Compiler$TypeCheck$$addErrorE = (($env, $pos, $error, $errors) => {
  return ([
    ((($0) => {
      return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
    }))(((($0) => {
      return ($u$$src$Compiler$Error$$Simple)(($u$$src$Compiler$TypeCheck$$getErrorModule)($env), $pos, $0);
    }))(($c$$src$Core$$Cons)((sp_toHuman)($error), ($c$$src$Core$$Cons)((sp_toHuman)($env.context), $c$$src$Core$$Nil)))),
    $errors,
  ]);
});

const $u$$src$Compiler$TypeCheck$$bug = (($msg) => {
  return (sp_todo)(("Compiler bug: " + $msg));
});

const $u$$src$Compiler$TypeCheck$$expandTyvarsInType = (($tyvarIdsToType, $type) => {
  const $rec = (($0) => {
    return ($u$$src$Compiler$TypeCheck$$expandTyvarsInType)($tyvarIdsToType, $0);
  });
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($type)[1];
      const $args = ($type)[2];
      return ($c$$src$Compiler$TypedAst$$TypeExact)($usr, ($c$$src$List$$map)($rec, $args));
    }))()
    : ((($type)[0] === "$TypeFn")
      ? ((() => {
        const $ins = ($type)[1];
        const $out = ($type)[2];
        return ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Compiler$TypedAst$$mapPars)($rec, $ins), ((() => {
          const $0 = $out;
          return (Object.assign)({}, $0, ({
            raw: ($rec)($0.raw),
          }));
        }))());
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Nothing"))
        ? ((() => {
          const $attrs = ($type)[2];
          return ($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, ($c$$src$Dict$$map)((($k, $v) => {
            return ($rec)($v);
          }), $attrs));
        }))()
        : ((($type)[0] === "$TypeVar")
          ? ((() => {
            const $id = ($type)[1];
            const $3 = ($c$$src$Dict$$get)($id, $tyvarIdsToType);
            return ((($3)[0] === "$Nothing")
              ? ($u$$src$Compiler$TypeCheck$$bug)("this is not supposed to happen")
              : ((($3)[0] === "$Just")
                ? ((() => {
                  const $ty = ($3)[1];
                  return $ty;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 428:12', (sp_toHuman)($3))));
          }))()
          : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Just"))
            ? ((() => {
              const $id = (($type)[1])[1];
              const $attrs = ($type)[2];
              return ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($id), ($c$$src$Dict$$map)((($k, $v) => {
                return ($rec)($v);
              }), $attrs));
            }))()
            : ((($type)[0] === "$TypeError")
              ? $c$$src$Compiler$TypedAst$$TypeError
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 416:4', (sp_toHuman)($type))))))));
});

const $u$$src$Compiler$TypeCheck$$translateUni = (($originalIdToNewId, $originalUni) => {
  return ((($originalUni)[0] === "$Depends")
    ? ((() => {
      const $originalId = ($originalUni)[1];
      const $3 = ($c$$src$Dict$$get)($originalId, $originalIdToNewId);
      return ((($3)[0] === "$Just")
        ? ((() => {
          const $newId = ($3)[1];
          return ($c$$src$Compiler$Ast$$Depends)($newId);
        }))()
        : ((($3)[0] === "$Nothing")
          ? $originalUni
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 445:12', (sp_toHuman)($3))));
    }))()
    : (true
      ? $originalUni
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 442:4', (sp_toHuman)($originalUni))));
});

const $u$$src$Compiler$TypeCheck$$translateFullType = (($env, $argsByName, $originalIdToNewId, $errors, $caFull) => {
  return ([
    ({
      raw: ((__re__ = ($u$$src$Compiler$TypeCheck$$translateRawType)($env, $argsByName, $originalIdToNewId, $errors, $caFull.raw)), ($errors = (__re__)[1]), (__re__)[0]),
      uni: ($u$$src$Compiler$TypeCheck$$translateUni)($originalIdToNewId, $caFull.uni),
    }),
    $errors,
  ]);
});

const $u$$src$Compiler$TypeCheck$$translateRawType = (($env, $argsByName, $originalIdToNewId, $errors, $caType) => {
  const $rec = (($0) => {
    return ((__re__ = ($u$$src$Compiler$TypeCheck$$translateRawType)($env, $argsByName, $originalIdToNewId, $errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((($caType)[0] === "$TypeFn")
      ? ((() => {
        const $pos = ($caType)[1];
        const $caPars = ($caType)[2];
        const $caOut = ($caType)[3];
        const $zzz = (($caPar) => {
          return ((($caPar)[0] === "$ParRe")
            ? ((() => {
              const $caRaw = ($caPar)[1];
              return ($c$$src$Compiler$TypedAst$$ParRe)(($rec)($caRaw));
            }))()
            : ((($caPar)[0] === "$ParSp")
              ? ((() => {
                const $caFull = ($caPar)[1];
                return ($c$$src$Compiler$TypedAst$$ParSp)(((__re__ = ($u$$src$Compiler$TypeCheck$$translateFullType)($env, $argsByName, $originalIdToNewId, $errors, $caFull)), ($errors = (__re__)[1]), (__re__)[0]));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 471:20', (sp_toHuman)($caPar))));
        });
        const $taArgs = ($c$$src$List$$map)($zzz, $caPars);
        return ($c$$src$Compiler$TypedAst$$TypeFn)($taArgs, ((__re__ = ($u$$src$Compiler$TypeCheck$$translateFullType)($env, $argsByName, $originalIdToNewId, $errors, $caOut)), ($errors = (__re__)[1]), (__re__)[0]));
      }))()
      : ((($caType)[0] === "$TypeRecord")
        ? ((() => {
          const $pos = ($caType)[1];
          const $caAttrs = ($caType)[2];
          return ($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, ($c$$src$Dict$$map)((($name, $v) => {
            return ($rec)($v);
          }), $caAttrs));
        }))()
        : ((($caType)[0] === "$TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($caType)[1];
            const $name = ($caType)[2];
            const $6 = ($c$$src$Dict$$get)($name, $argsByName);
            return ((($6)[0] === "$Nothing")
              ? ((() => {
                ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorE)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorUndefinedTypeVariable)($name), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                return $c$$src$Compiler$TypedAst$$TypeError;
              }))()
              : ((($6)[0] === "$Just")
                ? ((() => {
                  const $raw = ($6)[1];
                  return $raw;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 484:12', (sp_toHuman)($6))));
          }))()
          : ((($caType)[0] === "$TypeNamed")
            ? ((() => {
              const $pos = ($caType)[1];
              const $usr = ($caType)[2];
              const $pars = ($caType)[3];
              const $expandedPars = ($c$$src$List$$map)($rec, $pars);
              const $6 = ($c$$src$Dict$$get)($usr, $env.expandedAliases);
              return ((($6)[0] === "$Nothing")
                ? ((() => {
                  const $7 = ($c$$src$Dict$$get)($usr, $env.exactTypes);
                  return ((($7)[0] === "$Just")
                    ? ((() => {
                      const $exact = ($7)[1];
                      return ($c$$src$Compiler$TypedAst$$TypeExact)($usr, $expandedPars);
                    }))()
                    : ((($7)[0] === "$Nothing")
                      ? ((() => {
                        ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorE)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorTypeNotFound)($usr), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                        return $c$$src$Compiler$TypedAst$$TypeError;
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 501:20', (sp_toHuman)($7))));
                }))()
                : ((($6)[0] === "$Just")
                  ? ((() => {
                    const $expandedAlias = ($6)[1];
                    return ((sp_not_equal)(($c$$src$List$$length)($expandedAlias.pars), ($c$$src$List$$length)($expandedPars))
                      ? ((() => {
                        ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorE)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfTypeArguments)($usr, $expandedAlias.pars, $expandedPars), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                        return $c$$src$Compiler$TypedAst$$TypeError;
                      }))()
                      : ((() => {
                        const $tyvarIdsToType = ($c$$src$Dict$$fromList)(($c$$src$List$$map2)($c$$src$Tuple$$pair, $expandedAlias.pars, $expandedPars));
                        return ($u$$src$Compiler$TypeCheck$$expandTyvarsInType)($tyvarIdsToType, $expandedAlias.type);
                      }))());
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 498:12', (sp_toHuman)($6))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 466:4', (sp_toHuman)($caType)))))),
    $errors,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addInstance = (($lastUnificationVarId, $errors, $umr, $def, $env) => {
  let $state = ($u$$src$Compiler$TypeCheck$$initState)(((__re__ = (basics_cloneUni)($lastUnificationVarId)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  const $nameToIdAndClasses = ((() => {
    const $zzzz = (($tyvarName, $6) => {
      const $nonFn = $6.nonFn;
      return ({
        first: ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]),
        second: ({
          maybeAnnotated: ($c$$src$Maybe$$Just)(({
            allowFunctions: (sp_equal)($nonFn, $c$$src$Maybe$$Nothing),
            name: $tyvarName,
          })),
        }),
      });
    });
    return ((($0) => {
      return ($c$$src$Maybe$$withDefault)($c$$src$Dict$$empty, $0);
    }))(((($0) => {
      return ($c$$src$Maybe$$map)((($ann) => {
        return ($c$$src$Dict$$map)($zzzz, $ann.tyvars);
      }), $0);
    }))($def.maybeAnnotation));
  }))();
  const $nameToType = ($c$$src$Dict$$map)((($k, $6) => {
    const $id = $6.first;
    const $classes = $6.second;
    return ($c$$src$Compiler$TypedAst$$TypeVar)($id);
  }), $nameToIdAndClasses);
  const $tyvarIdToClasses = ($c$$src$Dict$$fromList)(($c$$src$Dict$$values)($nameToIdAndClasses));
  const $originalIdToNewIdAndUnivar = ((() => {
    const $6 = $def.maybeAnnotation;
    return ((($6)[0] === "$Just")
      ? ((() => {
        const $ann = ($6)[1];
        return ((($0) => {
          return ($c$$src$Dict$$map)((($annotatedId, _1) => {
            return ({
              first: ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]),
              second: ({
                annotatedId: $annotatedId,
              }),
            });
          }), $0);
        }))(($c$$src$Compiler$CanonicalAst$$typeUnivars)($ann.raw));
      }))()
      : ((($6)[0] === "$Nothing")
        ? $c$$src$Dict$$empty
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2028:8', (sp_toHuman)($6))));
  }))();
  const $originalIdToUniqueness = ((($0) => {
    return ($c$$src$Dict$$map)((($annotatedId, $7) => {
      const $newId = $7.first;
      const $univar = $7.second;
      return $newId;
    }), $0);
  }))($originalIdToNewIdAndUnivar);
  const $freeUnivars = ($c$$src$Dict$$fromList)(($c$$src$Dict$$values)($originalIdToNewIdAndUnivar));
  const $envF = ((() => {
    const $6 = $def.maybeAnnotation;
    return ((($6)[0] === "$Nothing")
      ? $env
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $annotation = ($6)[1];
          const $raw = ((__re__ = ($u$$src$Compiler$TypeCheck$$translateRawType)($env, $nameToType, $originalIdToUniqueness, $state.errors, $annotation.raw)), ($state.errors = (__re__)[1]), (__re__)[0]);
          const $instance = ({
            definedAt: $def.namePos,
            freeTyvars: ($c$$src$Dict$$intersect)($tyvarIdToClasses, ($c$$src$Compiler$TypedAst$$typeTyvars)($raw)),
            freeUnivars: $freeUnivars,
            type: ({
              raw: $raw,
              uni: $c$$src$Compiler$Ast$$Imm,
            }),
          });
          const $ref = ($c$$src$Compiler$Ast$$RefGlobal)(((($0) => {
            return ($c$$src$Compiler$Meta$$USR)($umr, $0);
          }))($def.name));
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            variables: ($c$$src$Dict$$insert)($ref, $instance, $0.variables),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2050:8', (sp_toHuman)($6))));
  }))();
  ($lastUnificationVarId = ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  ((__re__ = (array_each)($state.errors, (($err) => {
    return ((__re__ = (array_push)($errors, $err)), ($errors = (__re__)[1]), (__re__)[0]);
  }))), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    $envF,
    $lastUnificationVarId,
    $errors,
  ]);
});

const $u$$src$Compiler$LazyBuild$$evaluateCircularValues = (($state, $errors, $lastUnificationVarId, $circular, $env0) => {
  return ([
    ((($circular)[0] === "$Cons")
      ? ((() => {
        const $u = ($circular)[1];
        const $others = ($circular)[2];
        return ((sp_equal)(($u$$src$Compiler$LazyBuild$$usrToDependencyType)($u), $c$$src$Compiler$Meta$$TypeDependency)
          ? $env0
          : ($c$$src$List$$for)($env0, $circular, (($usr, $envX) => {
            const $8 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
            return (((($8)[0] === "$Just") && ((($8)[1].def)[0] === "$ValueDef"))
              ? ((() => {
                const $def = (($8)[1].def)[1];
                const $9 = $def.maybeAnnotation;
                return ((($9)[0] === "$Just")
                  ? ((() => {
                    const $ann = ($9)[1];
                    const $10 = $u;
                    const $umr = ($10)[1];
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$addInstance)($lastUnificationVarId, $errors, $umr, $def, $envX)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
                  }))()
                  : ((($9)[0] === "$Nothing")
                    ? ((() => {
                      ((($0) => {
                        return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
                      }))(($u$$src$Compiler$Error$$Raw)(((sp_equal)($others, $c$$src$Core$$Nil)
                        ? ($c$$src$Core$$Cons)(("Value " + ($def.name + "  is recursive, so I need a type annotation for it.")), $c$$src$Core$$Nil)
                        : ($c$$src$Core$$Cons)(("Value " + ($def.name + (" depends is mutually recursive with " + ((sp_toHuman)($circular) + " so I need it to be annotated.")))), $c$$src$Core$$Nil))));
                      return $envX;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 176:32', (sp_toHuman)($9))));
              }))()
              : (true
                ? $envX
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 173:24', (sp_toHuman)($8))));
          })));
      }))()
      : (true
        ? $env0
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 165:8', (sp_toHuman)($circular)))),
    $state,
    $errors,
    $lastUnificationVarId,
  ]);
});

const $u$$src$Compiler$TypeCheck$$namedParsToIdParsAndDict = (($atPars) => {
  const $idPars = ((($0) => {
    return ($c$$src$List$$indexedMap)((($index, $atName) => {
      return -($index);
    }), $0);
  }))($atPars);
  const $typeByName = ($c$$src$Dict$$fromList)(((($0) => {
    return ($c$$src$List$$indexedMap)((($index, $3) => {
      const $name = $3.first;
      const $pos = $3.second;
      return ({
        first: $name,
        second: ($c$$src$Compiler$TypedAst$$TypeVar)(-($index)),
      });
    }), $0);
  }))($atPars));
  return ({
    first: $idPars,
    second: $typeByName,
  });
});

const $u$$src$Compiler$TypeCheck$$expandAndInsertAlias = (($errors, $env, $aliasDef, $aliasAccum) => {
  const $5 = ($u$$src$Compiler$TypeCheck$$namedParsToIdParsAndDict)($aliasDef.pars);
  const $typeByName = $5.second;
  const $pars = $5.first;
  const $originalIdToNewId = $c$$src$Dict$$empty;
  const $type = ((__re__ = ($u$$src$Compiler$TypeCheck$$translateRawType)(((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      expandedAliases: $aliasAccum,
    }));
  }))(), $typeByName, $originalIdToNewId, $errors, $aliasDef.type)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    ($c$$src$Dict$$insert)($aliasDef.usr, ({
      pars: $pars,
      type: $type,
    }), $aliasAccum),
    $errors,
  ]);
});

const $u$$src$Compiler$LazyBuild$$expandAndInsertType = (($state, $errors, $usr, $env0) => {
  const $5 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
  return ([
    ((($5)[0] === "$Nothing")
      ? (sp_todo)(("compiler bug, missing type usr" + (sp_toHuman)($usr)))
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $def = ($5)[1].def;
          const $deps = ($5)[1].deps;
          return ((($def)[0] === "$VariantTypeDef")
            ? ((() => {
              const $variantTypeDef = ($def)[1];
              const $0 = $env0;
              return (Object.assign)({}, $0, ({
                exactTypes: ($c$$src$Dict$$insert)($usr, $variantTypeDef.pars, $0.exactTypes),
              }));
            }))()
            : ((($def)[0] === "$AliasDef")
              ? ((() => {
                const $aliasDef = ($def)[1];
                const $0 = $env0;
                return (Object.assign)({}, $0, ({
                  expandedAliases: ((__re__ = ($u$$src$Compiler$TypeCheck$$expandAndInsertAlias)($errors, ((() => {
                    const $1 = $env0;
                    return (Object.assign)({}, $1, ({
                      currentRootUsr: $usr,
                    }));
                  }))(), $aliasDef, $0.expandedAliases)), ($errors = (__re__)[1]), (__re__)[0]),
                }));
              }))()
              : (true
                ? $env0
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 131:12', (sp_toHuman)($def)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 125:4', (sp_toHuman)($5)))),
    $state,
    $errors,
  ]);
});

const $u$$src$Compiler$LazyBuild$$initCollectDependenciesState = (($pendingList) => {
  let $pending = (hash_fromList)($pendingList);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$noneTypeUsr, $c$$src$Compiler$Meta$$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$noneConsUsr, $c$$src$Compiler$Meta$$ConstructorDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$boolUsr, $c$$src$Compiler$Meta$$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$trueUsr, $c$$src$Compiler$Meta$$ConstructorDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$falseUsr, $c$$src$Compiler$Meta$$ConstructorDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$numberUsr, $c$$src$Compiler$Meta$$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$textUsr, $c$$src$Compiler$Meta$$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, $u$$src$Compiler$CoreDefs$$listUsr, $c$$src$Compiler$Meta$$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  return ({
    done: (hash_fromList)($c$$src$Core$$Nil),
    loadedModulesByUmr: (hash_fromList)(($c$$src$Core$$Cons)(({
      first: $u$$src$Compiler$CoreDefs$$umr,
      second: $u$$src$Compiler$CoreDefs$$coreModule,
    }), $c$$src$Core$$Nil)),
    pending: $pending,
  });
});

const $u$$src$Compiler$LazyBuild$$stopOnError = (($pars, $errors) => {
  const $3 = ((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    ((($3)[0] === "$Nil")
      ? ($c$$src$Result$$Ok)(null)
      : (true
        ? ((() => {
          const $errorsAsList = $3;
          return ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Nested)($errorsAsList));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 224:4', (sp_toHuman)($3)))),
    $errors,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addConstructorToGlobalEnv = (($errors, $name, $caConstructor, $env) => {
  const $5 = $caConstructor.variantTypeUsr;
  const $umr = ($5)[1];
  const $ins = ((($0) => {
    return ($c$$src$List$$map)((($in) => {
      return ($c$$src$Compiler$CanonicalAst$$ParSp)(({
        raw: $in,
        uni: ($c$$src$Compiler$Ast$$Depends)(1),
      }));
    }), $0);
  }))($caConstructor.ins);
  const $caRaw = ((sp_equal)($ins, $c$$src$Core$$Nil)
    ? $caConstructor.out
    : ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$G, $ins, ({
      raw: $caConstructor.out,
      uni: ($c$$src$Compiler$Ast$$Depends)(1),
    })));
  const $tyvarNamesAndIds = ((($0) => {
    return ($c$$src$List$$indexedMap)((($index, $n) => {
      return ({
        first: $n,
        second: -($index),
      });
    }), $0);
  }))(($c$$src$Dict$$keys)(($c$$src$Compiler$CanonicalAst$$typeTyvars)($caRaw)));
  const $paramsByName = ($c$$src$List$$for)($c$$src$Dict$$empty, $tyvarNamesAndIds, (($7, $d) => {
    const $n = $7.first;
    const $id = $7.second;
    return ($c$$src$Dict$$insert)($n, ($c$$src$Compiler$TypedAst$$TypeVar)($id), $d);
  }));
  const $raw = ((__re__ = ($u$$src$Compiler$TypeCheck$$translateRawType)($env, $paramsByName, $c$$src$Dict$$empty, $errors, $caRaw)), ($errors = (__re__)[1]), (__re__)[0]);
  const $freeTyvars = ($c$$src$List$$for)($c$$src$Dict$$empty, $tyvarNamesAndIds, (($7, $d) => {
    const $n = $7.first;
    const $id = $7.second;
    return ($c$$src$Dict$$insert)($id, ({
      maybeAnnotated: ($c$$src$Maybe$$Just)(({
        allowFunctions: true,
        name: $n,
      })),
    }), $d);
  }));
  const $taConstructor = ({
    definedAt: $c$$src$Compiler$Pos$$G,
    freeTyvars: $freeTyvars,
    freeUnivars: ($c$$src$Dict$$ofOne)(1, ({
      annotatedId: 1,
    })),
    type: ($c$$src$Compiler$Ast$$toImm)($raw),
  });
  const $0 = $env;
  return ([
    (Object.assign)({}, $0, ({
      constructors: ($c$$src$Dict$$insert)(($c$$src$Compiler$Meta$$USR)($umr, $name), $taConstructor, $0.constructors),
    })),
    $errors,
  ]);
});

const $u$$src$Compiler$TypeCheck$$applyAllSubs = (($state, $raw) => {
  const $subsAsFns = ({
    ty: (($id) => {
      return ((__re__ = (hash_get)($state.tyvarSubs, $id)), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
    }),
    uni: (($id) => {
      return ((__re__ = (hash_get)($state.univarSubs, $id)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
    }),
  });
  return ([
    ($c$$src$Compiler$TypedAst$$resolveRaw)($subsAsFns, $raw),
    $state,
  ]);
});

const $u$$src$Human$Format$$chainPrecedence = (($ls) => {
  return ((($ls)[0] === "$Nil")
    ? 0
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $op = ($ls)[1].first;
        return $op.precedence;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 113:4', (sp_toHuman)($ls))));
});

const $u$$src$Human$Format$$expressionPrecedence = (($1) => {
  const $e_ = ($1)[3];
  return ((($e_)[0] === "$Statements")
    ? ((() => {
      const $stats = ($e_)[1];
      return 0;
    }))()
    : ((($e_)[0] === "$BinopChain")
      ? ((() => {
        const $priority = ($e_)[1];
        const $binopChain = ($e_)[2];
        return ($u$$src$Human$Format$$chainPrecedence)($binopChain.second);
      }))()
      : ((($e_)[0] === "$Poly")
        ? ((() => {
          const $text = ($e_)[1];
          const $expression = ($e_)[2];
          return 9;
        }))()
        : ((($e_)[0] === "$If")
          ? 9
          : ((($e_)[0] === "$Try")
            ? 9
            : ((($e_)[0] === "$Call")
              ? $c$$src$Compiler$Op$$precedence_application
              : ((($e_)[0] === "$Fn")
                ? ((() => {
                  const $pars = ($e_)[2];
                  const $body = ($e_)[3];
                  return $c$$src$Compiler$Op$$precedence_function;
                }))()
                : (((($e_)[0] === "$Lowercase") && ((($e_)[1].maybeType)[0] === "$Just"))
                  ? ($c$$src$Compiler$Op$$precedence_tuple - 1)
                  : (true
                    ? 10
                    : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 129:4', (sp_toHuman)($e_)))))))))));
});

const $u$$src$SPLib$Format$$indent_map = (($f, $1) => {
  const $indent = ($1)[1];
  const $l = ($1)[2];
  return ($u$$src$SPLib$Format$$Indented)($indent, ($f)($l));
});

const $u$$src$SPLib$Format$$indent_spaces = (($n) => {
  return ($c$$src$Core$$Cons)($n, $c$$src$Core$$Nil);
});

const $u$$src$SPLib$Format$$mapFirstLine = (($firstFn, $restFn, $b) => {
  return ((($b)[0] === "$Empty")
    ? $u$$src$SPLib$Format$$Empty
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $breaks = ($b)[1];
        const $l1 = ($b)[2];
        return ($u$$src$SPLib$Format$$SingleLine)($breaks, ($firstFn)($l1));
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $ls = ($b)[2];
          return ($u$$src$SPLib$Format$$Stack)(($firstFn)($l1), ($c$$src$List$$map)($restFn, $ls));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 245:4', (sp_toHuman)($b)))));
});

const $u$$src$SPLib$Format$$stripEnd = (($l) => {
  return ((($l)[0] === "$Space")
    ? $u$$src$SPLib$Format$$Blank
    : ((($l)[0] === "$Row")
      ? ((() => {
        const $r1 = ($l)[1];
        const $r2 = ($l)[2];
        const $2 = ($u$$src$SPLib$Format$$stripEnd)($r2);
        return ((($2)[0] === "$Blank")
          ? ($u$$src$SPLib$Format$$stripEnd)($r1)
          : (true
            ? ((() => {
              const $r2_ = $2;
              return ($u$$src$SPLib$Format$$Row)($r1, $r2_);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 424:12', (sp_toHuman)($2))));
      }))()
      : (true
        ? $l
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 418:4', (sp_toHuman)($l)))));
});

const $u$$src$SPLib$Format$$prefix = (($prefixLength, $pref, $blocks) => {
  const $padLineWithSpaces = (($4) => {
    const $i = ($4)[1];
    const $l = ($4)[2];
    return ($u$$src$SPLib$Format$$Indented)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent_spaces)($prefixLength), ($c$$src$Core$$Cons)($i, $c$$src$Core$$Nil))), $l);
  });
  const $addPrefixToLine = (($x) => {
    return ((($x)[0] === "$Blank")
      ? ($u$$src$SPLib$Format$$stripEnd)($pref)
      : (true
        ? ((() => {
          const $l = $x;
          return ($u$$src$SPLib$Format$$Row)($pref, $l);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 409:8', (sp_toHuman)($x))));
  });
  return ($u$$src$SPLib$Format$$mapFirstLine)((($0) => {
    return ($u$$src$SPLib$Format$$indent_map)($addPrefixToLine, $0);
  }), $padLineWithSpaces, $blocks);
});

const $u$$src$SPLib$Format$$for1 = (($items, $f) => {
  return ((($items)[0] === "$Nil")
    ? (sp_todo)("for1 got an empty list....")
    : ((($items)[0] === "$Cons")
      ? ((() => {
        const $head = ($items)[1];
        const $tail = ($items)[2];
        return ($c$$src$List$$for)($head, $tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 9:4', (sp_toHuman)($items))));
});

const $u$$src$SPLib$Format$$mkIndentedLine = (($l) => {
  return ((($l)[0] === "$Space")
    ? ($u$$src$SPLib$Format$$Indented)(($u$$src$SPLib$Format$$indent_spaces)(1), $u$$src$SPLib$Format$$Blank)
    : (((($l)[0] === "$Row") && ((($l)[1])[0] === "$Space"))
      ? ((() => {
        const $next = ($l)[2];
        const $2 = ($u$$src$SPLib$Format$$mkIndentedLine)($next);
        const $rest_ = ($2)[2];
        const $i = ($2)[1];
        return ($u$$src$SPLib$Format$$Indented)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent_spaces)(1), ($c$$src$Core$$Cons)($i, $c$$src$Core$$Nil))), $rest_);
      }))()
      : (true
        ? ((() => {
          const $other = $l;
          return ($u$$src$SPLib$Format$$Indented)($c$$src$Core$$Nil, $other);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 192:4', (sp_toHuman)($l)))));
});

const $u$$src$SPLib$Format$$lineToBlock = (($x) => {
  return ($u$$src$SPLib$Format$$SingleLine)($u$$src$SPLib$Format$$NoRequiredBreaks, ($u$$src$SPLib$Format$$mkIndentedLine)($x));
});

const $u$$src$SPLib$Format$$mustBreak = (($x) => {
  return ($u$$src$SPLib$Format$$SingleLine)($u$$src$SPLib$Format$$MustBreakAtEnd, ($u$$src$SPLib$Format$$mkIndentedLine)($x));
});

const $u$$src$SPLib$Format$$maybeAllSingleLines = ((() => {
  const $rec = (($blocks, $reversedLines) => {
    return ((($blocks)[0] === "$Nil")
      ? ($c$$src$Maybe$$Just)(({
        first: $reversedLines,
        second: $u$$src$SPLib$Format$$lineToBlock,
      }))
      : ((($blocks)[0] === "$Cons")
        ? ((() => {
          const $block = ($blocks)[1];
          const $rest = ($blocks)[2];
          return (((($block)[0] === "$SingleLine") && (((($block)[1])[0] === "$NoRequiredBreaks") && ((($block)[2])[0] === "$Indented")))
            ? ((() => {
              const $l = (($block)[2])[2];
              return ($rec)($rest, (sp_cons)($l, $reversedLines));
            }))()
            : (((($block)[0] === "$SingleLine") && (((($block)[1])[0] === "$MustBreakAtEnd") && ((($block)[2])[0] === "$Indented")))
              ? ((() => {
                const $l = (($block)[2])[2];
                return ((sp_equal)($rest, $c$$src$Core$$Nil)
                  ? ($c$$src$Maybe$$Just)(({
                    first: (sp_cons)($l, $reversedLines),
                    second: $u$$src$SPLib$Format$$mustBreak,
                  }))
                  : $c$$src$Maybe$$Nothing);
              }))()
              : (true
                ? $c$$src$Maybe$$Nothing
                : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 347:16', (sp_toHuman)($block)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 341:8', (sp_toHuman)($blocks))));
  });
  return (($0) => {
    return ($rec)($0, $c$$src$Core$$Nil);
  });
}))();

const $u$$src$SPLib$Format$$stack = ((() => {
  const $stackForce = (($b1, $b2) => {
    const $toLines = (($b) => {
      return ((($b)[0] === "$Empty")
        ? $c$$src$Core$$Nil
        : ((($b)[0] === "$SingleLine")
          ? ((() => {
            const $l1 = ($b)[2];
            return ($c$$src$Core$$Cons)($l1, $c$$src$Core$$Nil);
          }))()
          : ((($b)[0] === "$Stack")
            ? ((() => {
              const $l1 = ($b)[1];
              const $rest = ($b)[2];
              return (sp_cons)($l1, $rest);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 213:12', (sp_toHuman)($b)))));
    });
    const $3 = ($toLines)($b1);
    return ((($3)[0] === "$Nil")
      ? $b2
      : ((($3)[0] === "$Cons")
        ? ((() => {
          const $line1first = ($3)[1];
          const $line1rest = ($3)[2];
          return ($u$$src$SPLib$Format$$Stack)($line1first, ($c$$src$List$$concat)(($c$$src$Core$$Cons)($line1rest, ($c$$src$Core$$Cons)(($toLines)($b2), $c$$src$Core$$Nil))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 227:8', (sp_toHuman)($3))));
  });
  return (($bs) => {
    return ((sp_equal)($bs, $c$$src$Core$$Nil)
      ? $u$$src$SPLib$Format$$Empty
      : ($u$$src$SPLib$Format$$for1)(($c$$src$List$$reverse)($bs), $stackForce));
  });
}))();

const $u$$src$SPLib$Format$$rowOrStackForce = (($forceMultiline, $joiner, $blocks) => {
  return (((($blocks)[0] === "$Cons") && ((($blocks)[2])[0] === "$Nil"))
    ? ((() => {
      const $single = ($blocks)[1];
      return $single;
    }))()
    : (true
      ? ($forceMultiline
        ? ($u$$src$SPLib$Format$$stack)($blocks)
        : ((() => {
          const $4 = ($u$$src$SPLib$Format$$maybeAllSingleLines)($blocks);
          return ((($4)[0] === "$Just")
            ? ((() => {
              const $lines = ($4)[1].first;
              const $mkLine = ($4)[1].second;
              return ($mkLine)(((($joiner)[0] === "$Nothing")
                ? ($u$$src$SPLib$Format$$for1)($lines, $u$$src$SPLib$Format$$Row)
                : ((($joiner)[0] === "$Just")
                  ? ((() => {
                    const $j = ($joiner)[1];
                    return ($u$$src$SPLib$Format$$for1)(($c$$src$List$$intersperse)($j, $lines), $u$$src$SPLib$Format$$Row);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 294:24', (sp_toHuman)($joiner)))));
            }))()
            : (true
              ? ($u$$src$SPLib$Format$$stack)($blocks)
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 291:16', (sp_toHuman)($4))));
        }))())
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 282:4', (sp_toHuman)($blocks))));
});

const $u$$src$SPLib$Format$$rowOrStack = (($0, $1) => {
  return ($u$$src$SPLib$Format$$rowOrStackForce)(false, $0, $1);
});

const $u$$src$SPLib$Format$$textToBlock = (($f) => {
  return ($u$$src$SPLib$Format$$lineToBlock)(($u$$src$SPLib$Format$$Text_)($f));
});

const $u$$src$Human$Format$$parens = (($block) => {
  return ((($0) => {
    return ($u$$src$SPLib$Format$$rowOrStack)($c$$src$Maybe$$Nothing, $0);
  }))(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$prefix)(1, ($u$$src$SPLib$Format$$Text_)("("), $block), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)(")"), $c$$src$Core$$Nil)));
});

const $u$$src$Human$Format$$formatExpressionAndMaybeAddParens = (($env, $binopPrecedence, $expression) => {
  const $block = ($u$$src$Human$Format$$formatExpression)($env, $expression);
  return ((($u$$src$Human$Format$$expressionPrecedence)($expression) > $binopPrecedence)
    ? $block
    : ($u$$src$Human$Format$$parens)($block));
});

const $u$$src$Human$Format$$lineIsNonEmpty = (($s) => {
  return (sp_not_equal)((text_trimLeft)($s), "");
});

const $u$$src$Human$Format$$unindentBlockComment = (($indent, $content) => {
  const $3 = (text_split)("\n", $content);
  return ((($3)[0] === "$Nil")
    ? $c$$src$Core$$Nil
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $head = ($3)[1];
        const $tail = ($3)[2];
        const $getLeadingSpaces = (text_startsWithRegex)("[ ]*");
        const $countLeadingSpaces = (($l) => {
          return (text_length)(($getLeadingSpaces)($l));
        });
        const $minLead = ((($0) => {
          return ($c$$src$List$$for)($indent, $0, (($line, $length) => {
            return ($c$$src$Basics$$min)(($countLeadingSpaces)($line), $length);
          }));
        }))(((($0) => {
          return ($c$$src$List$$filter)($u$$src$Human$Format$$lineIsNonEmpty, $0);
        }))($tail));
        return (sp_cons)($head, ($c$$src$List$$map)((($0) => {
          return (text_dropLeft)($minLead, $0);
        }), $tail));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 245:4', (sp_toHuman)($3))));
});

const $u$$src$SPLib$Format$$blankLine = ($u$$src$SPLib$Format$$lineToBlock)($u$$src$SPLib$Format$$Blank);

const $u$$src$Human$Format$$formatComment = (($env, $1) => {
  const $end = $1.end;
  const $indent = $1.indent;
  const $isBlock = $1.isBlock;
  const $isFollowedByBlank = $1.isFollowedByBlank;
  const $start = $1.start;
  const $content = (text_slice)($start, $end, $env.originalContent);
  const $blockOrBlank = (($text) => {
    return (($u$$src$Human$Format$$lineIsNonEmpty)($text)
      ? ($u$$src$SPLib$Format$$lineToBlock)(($u$$src$SPLib$Format$$CommentWithIndent)($text))
      : $u$$src$SPLib$Format$$blankLine);
  });
  const $comment = ((sp_equal)($indent, 0)
    ? ($u$$src$SPLib$Format$$stack)(((($0) => {
      return ($c$$src$List$$map)((($l) => {
        return ($u$$src$SPLib$Format$$lineToBlock)(($u$$src$SPLib$Format$$CommentIgnoreIndent)($l));
      }), $0);
    }))(((($0) => {
      return ($u$$src$Human$Format$$unindentBlockComment)($indent, $0);
    }))($content)))
    : ($isBlock
      ? ($u$$src$SPLib$Format$$stack)(((($0) => {
        return ($c$$src$List$$map)($blockOrBlank, $0);
      }))(((($0) => {
        return ($u$$src$Human$Format$$unindentBlockComment)($indent, $0);
      }))($content)))
      : ($u$$src$SPLib$Format$$lineToBlock)(($u$$src$SPLib$Format$$CommentWithIndent)($content))));
  return ($isFollowedByBlank
    ? ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)($comment, ($c$$src$Core$$Cons)($u$$src$SPLib$Format$$blankLine, $c$$src$Core$$Nil)))
    : $comment);
});

const $u$$src$Human$Format$$formatComments = (($env, $comments) => {
  return ($u$$src$SPLib$Format$$stack)(((($0) => {
    return ($c$$src$List$$map)((($0) => {
      return ($u$$src$Human$Format$$formatComment)($env, $0);
    }), $0);
  }))($comments));
});

const $u$$src$Human$Format$$stackWithComments = (($env, $comments, $block) => {
  return ((sp_equal)($comments, $c$$src$Core$$Nil)
    ? $block
    : ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatComments)($env, $comments), ($c$$src$Core$$Cons)($block, $c$$src$Core$$Nil))));
});

const $u$$src$SPLib$Format$$space = $u$$src$SPLib$Format$$Space;

const $u$$src$SPLib$Format$$spaceSeparatedOrStackForce = (($force, $blocks) => {
  return ($u$$src$SPLib$Format$$rowOrStackForce)($force, ($c$$src$Maybe$$Just)($u$$src$SPLib$Format$$space), $blocks);
});

const $u$$src$Human$Format$$formatBinopChain = (($env, $priority, $1) => {
  const $left = $1.first;
  const $opsAndRights = $1.second;
  const $formatOpAndRight = (($4) => {
    const $binop = $4.first;
    const $expr = $4.second;
    return ((($0) => {
      return ($u$$src$Human$Format$$stackWithComments)($env, $binop.comments, $0);
    }))(((($0) => {
      return ($u$$src$SPLib$Format$$prefix)(0, ($u$$src$SPLib$Format$$Text_)(($binop.symbol + " ")), $0);
    }))(($u$$src$Human$Format$$formatExpressionAndMaybeAddParens)($env, $binop.precedence, $expr)));
  });
  const $forceMultiline = ((($opsAndRights)[0] === "$Nil")
    ? false
    : ((($opsAndRights)[0] === "$Cons")
      ? ((() => {
        const $first = ($opsAndRights)[1].first;
        const $rest = ($opsAndRights)[2];
        const $last = ($c$$src$List$$for)($first, $rest, (($5, $acc) => {
          const $opX = $5.first;
          return $opX;
        }));
        return ($last.line > $first.line);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 666:8', (sp_toHuman)($opsAndRights))));
  return ((($0) => {
    return ($u$$src$SPLib$Format$$spaceSeparatedOrStackForce)($forceMultiline, $0);
  }))(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatExpressionAndMaybeAddParens)($env, ($u$$src$Human$Format$$chainPrecedence)($opsAndRights), $left), ($c$$src$List$$map)($formatOpAndRight, $opsAndRights)));
});

const $u$$src$Human$Format$$extractComments = (($1) => {
  const $comments = ($1)[1];
  const $pos = ($1)[2];
  const $expr = ($1)[3];
  return ({
    first: ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $pos, $expr),
    second: $comments,
  });
});

const $u$$src$Human$Format$$prefixToFirstNonBlank = (($prefix) => {
  return (($block) => {
    return ((($block)[0] === "$Empty")
      ? $block
      : ((($block)[0] === "$SingleLine")
        ? ($u$$src$SPLib$Format$$prefix)((text_length)($prefix), ($u$$src$SPLib$Format$$Text_)($prefix), $block)
        : ((($block)[0] === "$Stack")
          ? ((() => {
            const $head = ($block)[1];
            const $tail = ($block)[2];
            let $done = false;
            const $doLine = (($indentedLine) => {
              return (((__re__ = (basics_cloneUni)($done)), ($done = (__re__)[1]), (__re__)[0])
                ? $indentedLine
                : ((($indentedLine)[0] === "$Indented")
                  ? ((() => {
                    const $i = ($indentedLine)[1];
                    const $line = ($indentedLine)[2];
                    const $isDecoration = ((($line)[0] === "$CommentWithIndent")
                      ? true
                      : ((($line)[0] === "$CommentIgnoreIndent")
                        ? true
                        : ((($line)[0] === "$Blank")
                          ? true
                          : (true
                            ? false
                            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 36:32', (sp_toHuman)($line))))));
                    return ($isDecoration
                      ? $indentedLine
                      : ((() => {
                        ($done = true);
                        return ((($0) => {
                          return ($u$$src$SPLib$Format$$Indented)($i, $0);
                        }))(($u$$src$SPLib$Format$$Row)(($u$$src$SPLib$Format$$Text_)($prefix), $line));
                      }))());
                  }))()
                  : (true
                    ? $indentedLine
                    : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 31:20', (sp_toHuman)($indentedLine)))));
            });
            const $3 = ($c$$src$List$$reverse)(((($0) => {
              return ($c$$src$List$$map)($doLine, $0);
            }))(($c$$src$List$$reverse)((sp_cons)($head, $tail))));
            return ((($3)[0] === "$Nil")
              ? $block
              : ((($3)[0] === "$Cons")
                ? ((() => {
                  const $h = ($3)[1];
                  const $t = ($3)[2];
                  return (((__re__ = (basics_cloneUni)($done)), ($done = (__re__)[1]), (__re__)[0])
                    ? ($u$$src$SPLib$Format$$Stack)($h, $t)
                    : ($u$$src$SPLib$Format$$prefix)((text_length)($prefix), ($u$$src$SPLib$Format$$Text_)($prefix), $block));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 52:12', (sp_toHuman)($3))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 14:4', (sp_toHuman)($block)))));
  });
});

const $u$$src$SPLib$Format$$mapLastLine = (($lastFn, $b) => {
  return ((($b)[0] === "$Empty")
    ? $u$$src$SPLib$Format$$Empty
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $breaks = ($b)[1];
        const $l1 = ($b)[2];
        return ($u$$src$SPLib$Format$$SingleLine)($breaks, ($lastFn)($l1));
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $ls = ($b)[2];
          const $3 = ($c$$src$List$$reverse)($ls);
          return ((($3)[0] === "$Cons")
            ? ((() => {
              const $last = ($3)[1];
              const $init = ($3)[2];
              return ((($0) => {
                return ($u$$src$SPLib$Format$$Stack)($l1, $0);
              }))(($c$$src$List$$reverse)(($c$$src$Core$$Cons)(($lastFn)($last), $init)));
            }))()
            : (true
              ? (sp_todo)("what")
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 262:12', (sp_toHuman)($3))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 253:4', (sp_toHuman)($b)))));
});

const $u$$src$SPLib$Format$$addSuffix = (($suffix, $block) => {
  return ($u$$src$SPLib$Format$$mapLastLine)((($0) => {
    return ($u$$src$SPLib$Format$$indent_map)((($0) => {
      return ($u$$src$SPLib$Format$$Row)($0, $suffix);
    }), $0);
  }), $block);
});

const $u$$src$Human$Format$$commaSeparatedList = (($forceMultiline, $open, $close, $closeHasAPrecedingSpace, $items) => {
  return ((sp_equal)($items, $c$$src$Core$$Nil)
    ? ($u$$src$SPLib$Format$$addSuffix)(($u$$src$SPLib$Format$$Text_)($close), $open)
    : ((() => {
      const $z = ($forceMultiline
        ? $c$$src$Maybe$$Nothing
        : ((($0) => {
          return ($c$$src$Maybe$$map)((($0) => {
            return ($c$$src$Tuple$$mapFirst)($c$$src$List$$reverse, $0);
          }), $0);
        }))(($u$$src$SPLib$Format$$maybeAllSingleLines)((sp_cons)($open, $items))));
      return (((($z)[0] === "$Just") && ((($z)[1].first)[0] === "$Cons"))
        ? ((() => {
          const $openLine = (($z)[1].first)[1];
          const $itemLines = (($z)[1].first)[2];
          const $mkLine = ($z)[1].second;
          const $closeLine = ($closeHasAPrecedingSpace
            ? ($u$$src$SPLib$Format$$Row)($u$$src$SPLib$Format$$Space, ($u$$src$SPLib$Format$$Text_)($close))
            : ($u$$src$SPLib$Format$$Text_)($close));
          return ((($0) => {
            return ($u$$src$SPLib$Format$$addSuffix)($closeLine, $0);
          }))(($mkLine)(((($0) => {
            return ($c$$src$List$$for)(($u$$src$SPLib$Format$$Row)($openLine, $u$$src$SPLib$Format$$Space), $0, (($a, $b) => {
              return ($u$$src$SPLib$Format$$Row)($b, $a);
            }));
          }))(((($0) => {
            return ($c$$src$List$$intersperse)(($u$$src$SPLib$Format$$Text_)(", "), $0);
          }))($itemLines))));
        }))()
        : ((($z)[0] === "$Nothing")
          ? ($u$$src$SPLib$Format$$stack)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)($open, $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($c$$src$List$$map)(($u$$src$Human$Format$$prefixToFirstNonBlank)(", "), $items), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)($close), $c$$src$Core$$Nil), $c$$src$Core$$Nil)))))
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 77:8', (sp_toHuman)($z))));
    }))());
});

const $u$$src$Human$Format$$formatFunctionHeader = (($env, $pars) => {
  return ((($0) => {
    return ($u$$src$Human$Format$$commaSeparatedList)(false, ($u$$src$SPLib$Format$$textToBlock)("fn"), ":", false, $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($0) => {
      return ($u$$src$Human$Format$$formatExpression)($env, $0);
    }), $0);
  }))($pars));
});

const $u$$src$SPLib$Format$$spacesInTab = 4;

const $u$$src$SPLib$Format$$indent_tab = ($c$$src$Core$$Cons)($u$$src$SPLib$Format$$spacesInTab, $c$$src$Core$$Nil);

const $u$$src$SPLib$Format$$mapLines = (($f, $b) => {
  return ($u$$src$SPLib$Format$$mapFirstLine)($f, $f, $b);
});

const $u$$src$SPLib$Format$$indent = (($0) => {
  return ($u$$src$SPLib$Format$$mapLines)((($2) => {
    const $i = ($2)[1];
    const $l = ($2)[2];
    return ($u$$src$SPLib$Format$$Indented)(($c$$src$List$$concat)(($c$$src$Core$$Cons)($u$$src$SPLib$Format$$indent_tab, ($c$$src$Core$$Cons)($i, $c$$src$Core$$Nil))), $l);
  }), $0);
});

const $u$$src$SPLib$Format$$rowOrIndentForce = (($forceMultiline, $joiner, $blocks) => {
  return ((($blocks)[0] === "$Nil")
    ? (sp_todo)("blocks is supposed to be NonEmpty")
    : (((($blocks)[0] === "$Cons") && ((($blocks)[2])[0] === "$Nil"))
      ? ((() => {
        const $single = ($blocks)[1];
        return $single;
      }))()
      : ((($blocks)[0] === "$Cons")
        ? ((() => {
          const $b1 = ($blocks)[1];
          const $rest = ($blocks)[2];
          const $4 = ($u$$src$SPLib$Format$$maybeAllSingleLines)($blocks);
          return ((($4)[0] === "$Just")
            ? ((() => {
              const $reversedLines = ($4)[1].first;
              const $mkLine = ($4)[1].second;
              return ($forceMultiline
                ? ($u$$src$SPLib$Format$$stack)((sp_cons)($b1, ($c$$src$List$$map)($u$$src$SPLib$Format$$indent, $rest)))
                : ($mkLine)(((($joiner)[0] === "$Nothing")
                  ? ($u$$src$SPLib$Format$$for1)($reversedLines, $u$$src$SPLib$Format$$Row)
                  : ((($joiner)[0] === "$Just")
                    ? ((() => {
                      const $j = ($joiner)[1];
                      return ($u$$src$SPLib$Format$$for1)(($c$$src$List$$intersperse)($j, $reversedLines), $u$$src$SPLib$Format$$Row);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 328:24', (sp_toHuman)($joiner))))));
            }))()
            : (true
              ? ($u$$src$SPLib$Format$$stack)((sp_cons)($b1, ($c$$src$List$$map)($u$$src$SPLib$Format$$indent, $rest)))
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 321:12', (sp_toHuman)($4))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 312:4', (sp_toHuman)($blocks)))));
});

const $u$$src$SPLib$Format$$rowOrIndent = (($0, $1) => {
  return ($u$$src$SPLib$Format$$rowOrIndentForce)(false, $0, $1);
});

const $u$$src$SPLib$Format$$spaceSeparatedOrIndent = (($0) => {
  return ($u$$src$SPLib$Format$$rowOrIndent)(($c$$src$Maybe$$Just)($u$$src$SPLib$Format$$space), $0);
});

const $u$$src$Human$Format$$formatCall = (($env, $ref, $args) => {
  const $lastIndex = (($c$$src$List$$length)($args) - 1);
  const $asContinuingFn = (($index, $arg) => {
    return (((($arg)[0] === "$Expression") && ((($arg)[3])[0] === "$Fn"))
      ? ((() => {
        const $layout = (($arg)[3])[1];
        const $params = (($arg)[3])[2];
        const $body = (($arg)[3])[3];
        return (((sp_equal)($index, $lastIndex) && (sp_not_equal)($layout, $c$$src$Compiler$FormattableAst$$Inline))
          ? ($c$$src$Maybe$$Just)(({
            first: $layout,
            second: $params,
            third: $body,
          }))
          : $c$$src$Maybe$$Nothing);
      }))()
      : (true
        ? $c$$src$Maybe$$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 692:8', (sp_toHuman)($arg))));
  });
  const $formatArgument = (($index, $arg) => {
    let $6 = ($asContinuingFn)($index, $arg);
    return ((($6)[0] === "$Nothing")
      ? ($u$$src$Human$Format$$formatExpressionAndMaybeAddParens)($env, $c$$src$Compiler$Op$$precedence_application, $arg)
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $layout = ($6)[1].first;
          const $params = ($6)[1].second;
          const $body = ($6)[1].third;
          return ($u$$src$Human$Format$$formatFunctionHeader)($env, $params);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 705:8', (sp_toHuman)($6))));
  });
  const $maybeContinuing = (($c$$src$Maybe$$onJust)((($0) => {
    return ($asContinuingFn)($lastIndex, $0);
  })))(($c$$src$List$$last)($args));
  const $4 = ($u$$src$Human$Format$$extractComments)($ref);
  const $refComments = $4.second;
  const $refNoComments = $4.first;
  const $call = ($u$$src$SPLib$Format$$spaceSeparatedOrIndent)(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatExpressionAndMaybeAddParens)($env, $c$$src$Compiler$Op$$precedence_application, $refNoComments), ($c$$src$List$$indexedMap)($formatArgument, $args)));
  return ((($0) => {
    return ($u$$src$Human$Format$$stackWithComments)($env, $refComments, $0);
  }))(((($maybeContinuing)[0] === "$Nothing")
    ? $call
    : ((($maybeContinuing)[0] === "$Just")
      ? ((() => {
        const $layout = ($maybeContinuing)[1].first;
        const $params = ($maybeContinuing)[1].second;
        const $body = ($maybeContinuing)[1].third;
        return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)($call, ($c$$src$Core$$Cons)((($c$$src$Basics$$applyIf)((sp_equal)($layout, $c$$src$Compiler$FormattableAst$$Indented), $u$$src$SPLib$Format$$indent))(($u$$src$Human$Format$$formatExpression)($env, $body)), $c$$src$Core$$Nil)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 724:4', (sp_toHuman)($maybeContinuing)))));
});

const $u$$src$Human$Format$$formatConstructor = (($env, $maybeModule, $name) => {
  return ($u$$src$SPLib$Format$$textToBlock)(((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(($c$$src$List$$concat)(($c$$src$Core$$Cons)(((($maybeModule)[0] === "$Nothing")
    ? $c$$src$Core$$Nil
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return ($c$$src$Core$$Cons)($module, ($c$$src$Core$$Cons)(".", $c$$src$Core$$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 597:10', (sp_toHuman)($maybeModule)))), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)($name, $c$$src$Core$$Nil), $c$$src$Core$$Nil)))));
});

const $u$$src$Human$Format$$formatFunction = (($env, $layout, $pars, $body) => {
  const $forceStack = (sp_not_equal)($layout, $c$$src$Compiler$FormattableAst$$Inline);
  return ((($0) => {
    return ($u$$src$SPLib$Format$$spaceSeparatedOrStackForce)($forceStack, $0);
  }))(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatFunctionHeader)($env, $pars), ($c$$src$Core$$Cons)((($c$$src$Basics$$applyIf)((sp_equal)($layout, $c$$src$Compiler$FormattableAst$$Indented), $u$$src$SPLib$Format$$indent))(($u$$src$Human$Format$$formatExpression)($env, $body)), $c$$src$Core$$Nil)));
});

const $u$$src$Human$Format$$extractIfElses = (($env, $x) => {
  const $rec = (($acc, $expr) => {
    return (((($expr)[0] === "$Expression") && ((($expr)[3])[0] === "$If"))
      ? ((() => {
        const $comments = ($expr)[1];
        const $args = (($expr)[3])[1];
        return ($rec)(($c$$src$Core$$Cons)(({
          first: $comments,
          second: ($u$$src$Human$Format$$formatExpression)($env, $args.condition),
          third: ($u$$src$Human$Format$$formatExpression)($env, $args.true),
        }), $acc), $args.false);
      }))()
      : (true
        ? ({
          first: ($c$$src$List$$reverse)($acc),
          second: ($u$$src$Human$Format$$formatExpression)($env, $expr),
        })
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 742:8', (sp_toHuman)($expr))));
  });
  return ($rec)($c$$src$Core$$Nil, $x);
});

const $u$$src$SPLib$Format$$blockAsLine = (($b) => {
  return (((($b)[0] === "$SingleLine") && ((($b)[2])[0] === "$Indented"))
    ? ((() => {
      const $l = (($b)[2])[2];
      return ($c$$src$Maybe$$Just)($l);
    }))()
    : (true
      ? $c$$src$Maybe$$Nothing
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 163:4', (sp_toHuman)($b))));
});

const $u$$src$SPLib$Format$$spaceSeparatedOrStack = (($0) => {
  return ($u$$src$SPLib$Format$$rowOrStack)(($c$$src$Maybe$$Just)($u$$src$SPLib$Format$$space), $0);
});

const $u$$src$Human$Format$$formatIf = (($env, $isMultiline, $expr) => {
  const $4 = ($u$$src$Human$Format$$extractIfElses)($env, $expr);
  const $default = $4.second;
  const $conditionsAndValues = $4.first;
  const $maybeSingleLine = ($isMultiline
    ? $c$$src$Maybe$$Nothing
    : (((($conditionsAndValues)[0] === "$Cons") && (((($conditionsAndValues)[1].first)[0] === "$Nil") && ((($conditionsAndValues)[2])[0] === "$Nil")))
      ? ((() => {
        const $condition = ($conditionsAndValues)[1].second;
        const $valueIfTrue = ($conditionsAndValues)[1].third;
        const $l = $u$$src$SPLib$Format$$blockAsLine;
        const $5 = ({
          first: ($l)($condition),
          second: ($l)($valueIfTrue),
          third: ($l)($default),
        });
        return (((($5.first)[0] === "$Just") && ((($5.second)[0] === "$Just") && (($5.third)[0] === "$Just")))
          ? ((() => {
            const $conditionLine = ($5.first)[1];
            const $trueLine = ($5.second)[1];
            const $falseLine = ($5.third)[1];
            return ($c$$src$Maybe$$Just)(({
              first: $conditionLine,
              second: $trueLine,
              third: $falseLine,
            }));
          }))()
          : (true
            ? $c$$src$Maybe$$Nothing
            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 764:20', (sp_toHuman)($5))));
      }))()
      : (true
        ? $c$$src$Maybe$$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 758:12', (sp_toHuman)($conditionsAndValues)))));
  return ((($maybeSingleLine)[0] === "$Just")
    ? ((() => {
      const $conditionLine = ($maybeSingleLine)[1].first;
      const $trueLine = ($maybeSingleLine)[1].second;
      const $falseLine = ($maybeSingleLine)[1].third;
      return ($u$$src$SPLib$Format$$lineToBlock)(((($0) => {
        return ($u$$src$SPLib$Format$$for1)($0, (($item, $acc) => {
          return ($u$$src$SPLib$Format$$Row)($acc, $item);
        }));
      }))(((($0) => {
        return ($c$$src$List$$intersperse)($u$$src$SPLib$Format$$Space, $0);
      }))(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$Text_)("if"), ($c$$src$Core$$Cons)($conditionLine, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$Text_)("then"), ($c$$src$Core$$Cons)($trueLine, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$Text_)("else"), ($c$$src$Core$$Cons)($falseLine, $c$$src$Core$$Nil)))))))));
    }))()
    : ((($maybeSingleLine)[0] === "$Nothing")
      ? ((() => {
        const $formatCAndV = (($index, $5) => {
          const $comments = $5.first;
          const $condition = $5.second;
          const $value = $5.third;
          return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(((($0) => {
            return ($u$$src$Human$Format$$stackWithComments)($env, $comments, $0);
          }))(($u$$src$SPLib$Format$$spaceSeparatedOrStack)(($c$$src$Core$$Cons)(((sp_equal)($index, 0)
            ? ($u$$src$SPLib$Format$$textToBlock)("if")
            : ($u$$src$SPLib$Format$$textToBlock)("else if")), ($c$$src$Core$$Cons)($condition, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("then"), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)($value), $c$$src$Core$$Nil)));
        });
        return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$stack)(((($0) => {
          return ($c$$src$List$$indexedMap)($formatCAndV, $0);
        }))($conditionsAndValues)), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("else"), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)($default), $c$$src$Core$$Nil))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 771:4', (sp_toHuman)($maybeSingleLine))));
});

const $u$$src$Human$Format$$formatList = (($env, $isMultiline, $unpacksAndExprs) => {
  const $formatListItem = (($4) => {
    const $isUnpacked = $4.first;
    const $expr = $4.second;
    return ($isUnpacked
      ? ((($0) => {
        return ($u$$src$SPLib$Format$$addSuffix)(($u$$src$SPLib$Format$$Text_)("..."), $0);
      }))(((($0) => {
        return ($u$$src$Human$Format$$formatExpression)($env, $0);
      }))($expr))
      : ($u$$src$Human$Format$$formatExpression)($env, $expr));
  });
  return ((($0) => {
    return ($u$$src$Human$Format$$commaSeparatedList)($isMultiline, ($u$$src$SPLib$Format$$textToBlock)("["), "]", true, $0);
  }))(((($0) => {
    return ($c$$src$List$$map)($formatListItem, $0);
  }))($unpacksAndExprs));
});

const $u$$src$Human$Format$$formatLiteralNumber = (($hasPercentage, $numberAsText) => {
  return ($hasPercentage
    ? ($u$$src$SPLib$Format$$textToBlock)(($numberAsText + "%"))
    : ($u$$src$SPLib$Format$$textToBlock)($numberAsText));
});

const $u$$src$Human$Format$$formatLiteralText = ((() => {
  const $singleQuote = "\"";
  const $tripleQuote = ($u$$src$SPLib$Format$$textToBlock)("\"\"\"");
  return (($singleOrTriple, $text) => {
    return ((($singleOrTriple)[0] === "$SingleQuote")
      ? ($u$$src$SPLib$Format$$textToBlock)(($singleQuote + ($text + $singleQuote)))
      : ((($singleOrTriple)[0] === "$TripleQuote")
        ? ((() => {
          const $rows = ((($0) => {
            return ($c$$src$List$$map)($u$$src$SPLib$Format$$textToBlock, $0);
          }))(((($0) => {
            return (text_split)("\n", $0);
          }))($text));
          return ($u$$src$SPLib$Format$$stack)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)($tripleQuote, $c$$src$Core$$Nil), ($c$$src$Core$$Cons)($rows, ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)($tripleQuote, $c$$src$Core$$Nil), $c$$src$Core$$Nil)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 332:4', (sp_toHuman)($singleOrTriple))));
  });
}))();

const $u$$src$Human$Format$$formatLowercase = (($env, $maybeType, $maybeModule, $name, $attrPath) => {
  const $word = ($u$$src$SPLib$Format$$textToBlock)(((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(($c$$src$List$$concat)(($c$$src$Core$$Cons)(((($maybeModule)[0] === "$Nothing")
    ? $c$$src$Core$$Nil
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return ($c$$src$Core$$Cons)($module, ($c$$src$Core$$Cons)(".", $c$$src$Core$$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 558:10', (sp_toHuman)($maybeModule)))), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)($name, $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($c$$src$List$$map)((($p) => {
    return ("." + $p);
  }), $attrPath), $c$$src$Core$$Nil))))));
  return ((($maybeType)[0] === "$Nothing")
    ? $word
    : ((($maybeType)[0] === "$Just")
      ? ((() => {
        const $type = ($maybeType)[1];
        return ((($0) => {
          return ($u$$src$SPLib$Format$$spaceSeparatedOrIndent)($0);
        }))(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$addSuffix)(($u$$src$SPLib$Format$$Text_)(" as"), $word), ($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatExpression)($env, $type), $c$$src$Core$$Nil)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 568:4', (sp_toHuman)($maybeType))));
});

const $u$$src$Human$Format$$formatRecord = (($env, $isMultiline, $maybeMaybeExt, $attrs) => {
  const $open = ((($maybeMaybeExt)[0] === "$Nothing")
    ? ($u$$src$SPLib$Format$$textToBlock)("{")
    : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Nothing"))
      ? ($u$$src$SPLib$Format$$textToBlock)("{ with ")
      : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Just"))
        ? ((() => {
          const $ext = (($maybeMaybeExt)[1])[1];
          return ((($0) => {
            return ($u$$src$SPLib$Format$$addSuffix)(($u$$src$SPLib$Format$$Text_)(" with"), $0);
          }))(((($0) => {
            return ($u$$src$SPLib$Format$$prefix)(1, ($u$$src$SPLib$Format$$Text_)("{ "), $0);
          }))(((($0) => {
            return ($u$$src$Human$Format$$formatExpression)($env, $0);
          }))($ext)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 494:8', (sp_toHuman)($maybeMaybeExt)))));
  const $formatRecordAttribute = (($5) => {
    const $maybeExpr = $5.maybeExpr;
    const $name = $5.name;
    return ((($maybeExpr)[0] === "$Nothing")
      ? ($u$$src$Human$Format$$formatExpression)($env, $name)
      : ((($maybeExpr)[0] === "$Just")
        ? ((() => {
          const $expr = ($maybeExpr)[1];
          return ((($0) => {
            return ($u$$src$SPLib$Format$$rowOrIndent)(($c$$src$Maybe$$Just)($u$$src$SPLib$Format$$Space), $0);
          }))(($c$$src$Core$$Cons)(((($0) => {
            return ($u$$src$SPLib$Format$$addSuffix)(($u$$src$SPLib$Format$$Text_)(" ="), $0);
          }))(($u$$src$Human$Format$$formatExpression)($env, $name)), ($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatExpression)($env, $expr), $c$$src$Core$$Nil)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 510:8', (sp_toHuman)($maybeExpr))));
  });
  const $attributeName = (($nameExpr) => {
    const $6 = $nameExpr.name;
    return (((($6)[0] === "$Expression") && ((($6)[3])[0] === "$Lowercase"))
      ? ((() => {
        const $name = (($6)[3])[1].name;
        return $name;
      }))()
      : (true
        ? ""
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 524:8', (sp_toHuman)($6))));
  });
  return ((($0) => {
    return ($u$$src$Human$Format$$commaSeparatedList)($isMultiline, $open, "}", true, $0);
  }))(((($0) => {
    return ($c$$src$List$$map)($formatRecordAttribute, $0);
  }))(((($0) => {
    return (list_sortBy)($attributeName, $0);
  }))($attrs)));
});

const $u$$src$Human$Format$$formatRecordShorthand = (($env, $name, $attrPath) => {
  return ($u$$src$SPLib$Format$$textToBlock)(((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(($c$$src$List$$map)((($p) => {
    return ("." + $p);
  }), (sp_cons)($name, $attrPath))));
});

const $u$$src$Human$Format$$formatFaWord = (($1) => {
  const $pos = $1.first;
  const $name = $1.second;
  return ($u$$src$SPLib$Format$$textToBlock)($name);
});

const $u$$src$Human$Format$$formatDef = (($maybeKeyword, $name, $args) => {
  const $formattedArgs = ((sp_equal)($args, $c$$src$Core$$Nil)
    ? $c$$src$Maybe$$Nothing
    : ($c$$src$Maybe$$Just)(($u$$src$SPLib$Format$$spaceSeparatedOrIndent)(((($0) => {
      return ($c$$src$List$$map)($u$$src$Human$Format$$formatFaWord, $0);
    }))($args))));
  return ($u$$src$SPLib$Format$$spaceSeparatedOrIndent)(((($0) => {
    return ($c$$src$List$$filterMap)($c$$src$Basics$$identity, $0);
  }))(($c$$src$Core$$Cons)(($c$$src$Maybe$$map)($u$$src$SPLib$Format$$textToBlock, $maybeKeyword), ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(($u$$src$Human$Format$$formatFaWord)($name)), ($c$$src$Core$$Cons)($formattedArgs, ($c$$src$Core$$Cons)(($c$$src$Maybe$$Just)(($u$$src$SPLib$Format$$textToBlock)("=")), $c$$src$Core$$Nil))))));
});

const $u$$src$Human$Format$$formatAliasDef = (($env, $1) => {
  const $args = $1.args;
  const $name = $1.name;
  const $type = $1.type;
  return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatDef)($c$$src$Maybe$$Nothing, $name, $args), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)(($u$$src$Human$Format$$formatExpression)($env, $type)), $c$$src$Core$$Nil)));
});

const $u$$src$Human$Format$$formatUnionDef = (($env, $1) => {
  const $args = $1.args;
  const $constructors = $1.constructors;
  const $name = $1.name;
  return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatDef)(($c$$src$Maybe$$Just)("var"), $name, $args), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)(($u$$src$SPLib$Format$$stack)(((($0) => {
    return ($c$$src$List$$map)((($c) => {
      return ($u$$src$SPLib$Format$$prefix)(2, ($u$$src$SPLib$Format$$Text_)(", "), ($u$$src$Human$Format$$formatExpression)($env, $c));
    }), $0);
  }))($constructors))), $c$$src$Core$$Nil)));
});

const $u$$src$Human$Format$$formatNonFn = (($words) => {
  return ((($0) => {
    return ($u$$src$Human$Format$$commaSeparatedList)(false, ($u$$src$SPLib$Format$$textToBlock)("with"), "NonFunction", true, $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($3) => {
      const $pos = $3.first;
      const $name = $3.second;
      return ($u$$src$SPLib$Format$$textToBlock)($name);
    }), $0);
  }))($words));
});

const $u$$src$Human$Format$$formatValueDef = (($env, $1) => {
  const $body = $1.body;
  const $nonFn = $1.nonFn;
  const $pattern = $1.pattern;
  return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$spaceSeparatedOrIndent)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatExpression)($env, $pattern), $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(((sp_equal)($nonFn, $c$$src$Core$$Nil)
    ? $c$$src$Core$$Nil
    : ($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatNonFn)($nonFn), $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("="), $c$$src$Core$$Nil), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)(($u$$src$Human$Format$$formatExpression)($env, $body)), $c$$src$Core$$Nil)));
});

const $u$$src$Human$Format$$formatStatement = (($env, $stat) => {
  return ((($stat)[0] === "$CommentStatement")
    ? ((() => {
      const $comment = ($stat)[1];
      return ($u$$src$Human$Format$$formatComment)($env, $comment);
    }))()
    : ((($stat)[0] === "$Evaluation")
      ? ((() => {
        const $expression = ($stat)[1];
        return ($u$$src$Human$Format$$formatExpression)($env, $expression);
      }))()
      : ((($stat)[0] === "$ValueDef")
        ? ((() => {
          const $valueDef = ($stat)[1];
          return ($u$$src$Human$Format$$formatValueDef)($env, $valueDef);
        }))()
        : ((($stat)[0] === "$AliasDef")
          ? ((() => {
            const $aliasDef = ($stat)[1];
            return ($u$$src$Human$Format$$formatAliasDef)($env, $aliasDef);
          }))()
          : ((($stat)[0] === "$UnionDef")
            ? ((() => {
              const $unionDef = ($stat)[1];
              return ($u$$src$Human$Format$$formatUnionDef)($env, $unionDef);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 403:4', (sp_toHuman)($stat)))))));
});

const $u$$src$Human$Format$$formatStatements = (($env, $sss) => {
  const $rec = (($maybePrevious, $stats, $acc) => {
    return ((($stats)[0] === "$Nil")
      ? ($c$$src$List$$reverse)($acc)
      : ((($stats)[0] === "$Cons")
        ? ((() => {
          const $head = ($stats)[1];
          const $tail = ($stats)[2];
          return ((($0) => {
            return ($rec)(($c$$src$Maybe$$Just)($head), $tail, $0);
          }))(((($0) => {
            return (sp_cons)(($u$$src$Human$Format$$formatStatement)(((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                isRoot: false,
              }));
            }))(), $head), $0);
          }))(((($maybePrevious)[0] === "$Nothing")
            ? $acc
            : (((($maybePrevious)[0] === "$Just") && ((($maybePrevious)[1])[0] === "$CommentStatement"))
              ? $acc
              : ((($maybePrevious)[0] === "$Just")
                ? ($env.isRoot
                  ? (sp_cons)($u$$src$SPLib$Format$$blankLine, (sp_cons)($u$$src$SPLib$Format$$blankLine, $acc))
                  : (sp_cons)($u$$src$SPLib$Format$$blankLine, $acc))
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 382:16', (sp_toHuman)($maybePrevious)))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 376:8', (sp_toHuman)($stats))));
  });
  return ($u$$src$SPLib$Format$$stack)(($rec)($c$$src$Maybe$$Nothing, $sss, $c$$src$Core$$Nil));
});

const $u$$src$Human$Format$$formatTry = (($env, $value, $patterns) => {
  const $formatted = ($c$$src$List$$map)((($4) => {
    const $pattern = $4.first;
    const $block = $4.second;
    return ({
      first: ($u$$src$Human$Format$$formatExpression)($env, $pattern),
      second: ($u$$src$Human$Format$$formatExpression)($env, $block),
    });
  }), $patterns);
  const $tryOneLine = (($4) => {
    const $pa = $4.first;
    const $bl = $4.second;
    return (($c$$src$Result$$onOk)((($paLine) => {
      return (($c$$src$Result$$onOk)((($blockLine) => {
        return ($c$$src$Result$$Ok)(({
          first: $paLine,
          second: $blockLine,
        }));
      })))(((($0) => {
        return ($c$$src$Maybe$$toResult)(null, $0);
      }))(($u$$src$SPLib$Format$$blockAsLine)($bl)));
    })))(((($0) => {
      return ($c$$src$Maybe$$toResult)(null, $0);
    }))(($u$$src$SPLib$Format$$blockAsLine)($pa)));
  });
  const $blocks = ((() => {
    const $4 = ($c$$src$List$$mapRes)($tryOneLine, $formatted);
    return ((($4)[0] === "$Ok")
      ? ((() => {
        const $lines = ($4)[1];
        const $formatInline = (($5) => {
          const $paLine = $5.first;
          const $blockLine = $5.second;
          return ($u$$src$SPLib$Format$$lineToBlock)(($u$$src$SPLib$Format$$Row)($paLine, ($u$$src$SPLib$Format$$Row)(($u$$src$SPLib$Format$$Text_)(": "), $blockLine)));
        });
        return ($c$$src$List$$map)($formatInline, $lines);
      }))()
      : ((($4)[0] === "$Err")
        ? ((() => {
          const $formatIndented = (($5) => {
            const $paBlock = $5.first;
            const $blockBlock = $5.second;
            return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)($u$$src$SPLib$Format$$blankLine, ($c$$src$Core$$Cons)(((($0) => {
              return ($u$$src$SPLib$Format$$addSuffix)(($u$$src$SPLib$Format$$Text_)(":"), $0);
            }))($paBlock), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)($blockBlock), $c$$src$Core$$Nil))));
          });
          return ($c$$src$List$$map)($formatIndented, $formatted);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 827:8', (sp_toHuman)($4))));
  }))();
  return ($u$$src$SPLib$Format$$stack)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$spaceSeparatedOrIndent)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("try"), ($c$$src$Core$$Cons)(($u$$src$Human$Format$$formatExpression)($env, $value), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("as"), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$indent)(($u$$src$SPLib$Format$$stack)($blocks)), $c$$src$Core$$Nil)));
});

const $u$$src$Human$Format$$unopToText = (($unopId) => {
  return ((($unopId)[0] === "$UnopPlus")
    ? "+"
    : ((($unopId)[0] === "$UnopMinus")
      ? "-"
      : ((($unopId)[0] === "$UnopUnique")
        ? "!"
        : ((($unopId)[0] === "$UnopRecycle")
          ? "@"
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 635:4', (sp_toHuman)($unopId))))));
});

const $u$$src$Human$Format$$formatUnopCall = (($env, $unopId, $expr) => {
  const $unop = ($u$$src$Human$Format$$unopToText)($unopId);
  return ((($0) => {
    return ($u$$src$SPLib$Format$$prefix)((text_length)($unop), ($u$$src$SPLib$Format$$Text_)($unop), $0);
  }))(((($0) => {
    return ($u$$src$Human$Format$$formatExpression)($env, $0);
  }))($expr));
});

const $u$$src$Human$Format$$formatUppercase = (($env, $maybeModule, $name) => {
  return ($u$$src$SPLib$Format$$textToBlock)(((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(($c$$src$List$$concat)(($c$$src$Core$$Cons)(((($maybeModule)[0] === "$Nothing")
    ? $c$$src$Core$$Nil
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return ($c$$src$Core$$Cons)($module, ($c$$src$Core$$Cons)(".", $c$$src$Core$$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 584:10', (sp_toHuman)($maybeModule)))), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)($name, $c$$src$Core$$Nil), $c$$src$Core$$Nil)))));
});

const $u$$src$Human$Format$$formatExpression = (($env, $faExpression) => {
  const $3 = $faExpression;
  const $e_ = ($3)[3];
  const $comments = ($3)[1];
  return ((($0) => {
    return ($u$$src$Human$Format$$stackWithComments)($env, $comments, $0);
  }))(((($e_)[0] === "$LiteralText")
    ? ((() => {
      const $singleOrTriple = ($e_)[1];
      const $text = ($e_)[2];
      return ($u$$src$Human$Format$$formatLiteralText)($singleOrTriple, $text);
    }))()
    : ((($e_)[0] === "$LiteralNumber")
      ? ((() => {
        const $hasPercentage = ($e_)[1];
        const $text = ($e_)[2];
        return ($u$$src$Human$Format$$formatLiteralNumber)($hasPercentage, $text);
      }))()
      : ((($e_)[0] === "$ArgumentPlaceholder")
        ? ($u$$src$SPLib$Format$$textToBlock)("__")
        : ((($e_)[0] === "$Statements")
          ? ((() => {
            const $stats = ($e_)[1];
            return ($u$$src$Human$Format$$formatStatements)($env, $stats);
          }))()
          : ((($e_)[0] === "$List")
            ? ((() => {
              const $isMultiline = ($e_)[1];
              const $unpacksAndExprs = ($e_)[2];
              return ($u$$src$Human$Format$$formatList)($env, $isMultiline, $unpacksAndExprs);
            }))()
            : ((($e_)[0] === "$Record")
              ? ((() => {
                const $attrs = ($e_)[1].attrs;
                const $isMultiline = ($e_)[1].isMultiline;
                const $maybeExtension = ($e_)[1].maybeExtension;
                return ($u$$src$Human$Format$$formatRecord)($env, $isMultiline, $maybeExtension, $attrs);
              }))()
              : ((($e_)[0] === "$Lowercase")
                ? ((() => {
                  const $attrPath = ($e_)[1].attrPath;
                  const $maybeModule = ($e_)[1].maybeModule;
                  const $maybeType = ($e_)[1].maybeType;
                  const $name = ($e_)[1].name;
                  return ($u$$src$Human$Format$$formatLowercase)($env, $maybeType, $maybeModule, $name, $attrPath);
                }))()
                : ((($e_)[0] === "$Uppercase")
                  ? ((() => {
                    const $maybeModule = ($e_)[1].maybeModule;
                    const $name = ($e_)[1].name;
                    return ($u$$src$Human$Format$$formatUppercase)($env, $maybeModule, $name);
                  }))()
                  : ((($e_)[0] === "$Constructor")
                    ? ((() => {
                      const $maybeModule = ($e_)[1].maybeModule;
                      const $name = ($e_)[1].name;
                      return ($u$$src$Human$Format$$formatConstructor)($env, $maybeModule, $name);
                    }))()
                    : ((($e_)[0] === "$RecordShorthand")
                      ? ((() => {
                        const $attrPath = ($e_)[1].attrPath;
                        const $name = ($e_)[1].name;
                        return ($u$$src$Human$Format$$formatRecordShorthand)($env, $name, $attrPath);
                      }))()
                      : ((($e_)[0] === "$Fn")
                        ? ((() => {
                          const $layout = ($e_)[1];
                          const $pars = ($e_)[2];
                          const $body = ($e_)[3];
                          return ($u$$src$Human$Format$$formatFunction)($env, $layout, $pars, $body);
                        }))()
                        : ((($e_)[0] === "$UnopCall")
                          ? ((() => {
                            const $unopId = ($e_)[1];
                            const $expr = ($e_)[2];
                            return ($u$$src$Human$Format$$formatUnopCall)($env, $unopId, $expr);
                          }))()
                          : ((($e_)[0] === "$BinopChain")
                            ? ((() => {
                              const $priority = ($e_)[1];
                              const $binopChain = ($e_)[2];
                              return ($u$$src$Human$Format$$formatBinopChain)($env, $priority, $binopChain);
                            }))()
                            : ((($e_)[0] === "$Call")
                              ? ((() => {
                                const $ref = ($e_)[1];
                                const $args = ($e_)[2];
                                return ($u$$src$Human$Format$$formatCall)($env, $ref, $args);
                              }))()
                              : ((($e_)[0] === "$Poly")
                                ? ((() => {
                                  const $text = ($e_)[1];
                                  const $expression = ($e_)[2];
                                  const $prefix = ($text + "?");
                                  return ((($0) => {
                                    return ($u$$src$SPLib$Format$$prefix)((text_length)($prefix), ($u$$src$SPLib$Format$$Text_)($prefix), $0);
                                  }))(((($0) => {
                                    return ($u$$src$Human$Format$$formatExpression)($env, $0);
                                  }))($expression));
                                }))()
                                : ((($e_)[0] === "$If")
                                  ? ((() => {
                                    const $condition = ($e_)[1].condition;
                                    const $false = ($e_)[1].false;
                                    const $isMultiline = ($e_)[1].isMultiline;
                                    const $true = ($e_)[1].true;
                                    return ($u$$src$Human$Format$$formatIf)($env, $isMultiline, $faExpression);
                                  }))()
                                  : ((($e_)[0] === "$Try")
                                    ? ((() => {
                                      const $patterns = ($e_)[1].patterns;
                                      const $value = ($e_)[1].value;
                                      return ($u$$src$Human$Format$$formatTry)($env, $value, $patterns);
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 176:4', (sp_toHuman)($e_))))))))))))))))))));
});

const $u$$src$Human$Type$$toExpression = (($0) => {
  return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $c$$src$Compiler$Pos$$G, $0);
});

const $u$$src$Human$Type$$uniToText = (($env, $uni) => {
  return ((($uni)[0] === "$Imm")
    ? ""
    : ((($uni)[0] === "$Uni")
      ? "!"
      : ((($uni)[0] === "$Depends")
        ? ((() => {
          const $n = ($uni)[1];
          return ((text_fromNumber)($n) + "?");
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 57:4', (sp_toHuman)($uni)))));
});

const $u$$src$Human$Type$$doFullType = (($env, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return ($u$$src$Human$Type$$toExpression)(($c$$src$Compiler$FormattableAst$$Poly)(($u$$src$Human$Type$$uniToText)($env, $uni), ($u$$src$Human$Type$$doRawType)($env, $raw)));
});

const $u$$src$Human$Type$$doLowercase = (($env, $name) => {
  return ($u$$src$Human$Type$$toExpression)(($c$$src$Compiler$FormattableAst$$Lowercase)(({
    attrPath: $c$$src$Core$$Nil,
    maybeModule: $c$$src$Maybe$$Nothing,
    maybeType: $c$$src$Maybe$$Nothing,
    name: $name,
  })));
});

const $u$$src$Human$Type$$doParType = (($env, $parType) => {
  return ((($parType)[0] === "$ParSp")
    ? ((() => {
      const $full = ($parType)[1];
      return ($u$$src$Human$Type$$doFullType)($env, $full);
    }))()
    : ((($parType)[0] === "$ParRe")
      ? ((() => {
        const $raw = ($parType)[1];
        return ($u$$src$Human$Type$$toExpression)(((($0) => {
          return ($c$$src$Compiler$FormattableAst$$UnopCall)($c$$src$Compiler$Op$$UnopRecycle, $0);
        }))(((($0) => {
          return ($u$$src$Human$Type$$doRawType)($env, $0);
        }))($raw)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 140:4', (sp_toHuman)($parType))));
});

const $u$$src$Human$Type$$doTyvarId = (($env, $tyvarId) => {
  return ($c$$src$Compiler$FormattableAst$$Lowercase)(({
    attrPath: $c$$src$Core$$Nil,
    maybeModule: $c$$src$Maybe$$Nothing,
    maybeType: $c$$src$Maybe$$Nothing,
    name: (text_fromNumber)($tyvarId),
  }));
});

const $u$$src$Human$Type$$rootToPath = (($0) => {
  return ((($0)[0] === "$Core")
    ? "core:"
    : ((($0)[0] === "$User")
      ? "user:"
      : ((($0)[0] === "$Installed")
        ? "installed:"
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 17:4', (sp_toHuman)($0)))));
});

const $u$$src$Human$Type$$importsPathToText = (($1) => {
  const $root = ($1)[1];
  const $importsDir = ($1)[2];
  return (($u$$src$Human$Type$$rootToPath)($root) + $importsDir);
});

const $u$$src$Human$Type$$umrToText = (($env, $1) => {
  const $importsPath = ($1)[1];
  const $sourceDir = ($1)[2];
  const $modulePath = ($1)[3];
  return (($u$$src$Human$Type$$importsPathToText)($importsPath) + ("/" + ($sourceDir + ("/" + $modulePath))));
});

const $u$$src$Human$Type$$usrToText = (($env, $1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return (($u$$src$Human$Type$$umrToText)($env, $umr) + ("." + $name));
});

const $u$$src$Human$Type$$doUsr = (($env, $usr) => {
  return ($u$$src$Human$Type$$toExpression)(($c$$src$Compiler$FormattableAst$$Uppercase)(({
    maybeModule: $c$$src$Maybe$$Nothing,
    name: ($u$$src$Human$Type$$usrToText)($env, $usr),
  })));
});

const $u$$src$Human$Type$$doRawType = (($env, $rawType) => {
  return ($u$$src$Human$Type$$toExpression)(((($rawType)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($rawType)[1];
      const $args = ($rawType)[2];
      return ($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Human$Type$$doUsr)($env, $usr), ($c$$src$List$$map)((($0) => {
        return ($u$$src$Human$Type$$doRawType)($env, $0);
      }), $args));
    }))()
    : ((($rawType)[0] === "$TypeFn")
      ? ((() => {
        const $parTypes = ($rawType)[1];
        const $full = ($rawType)[2];
        return ($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Inline, ($c$$src$List$$map)((($0) => {
          return ($u$$src$Human$Type$$doParType)($env, $0);
        }), $parTypes), ($u$$src$Human$Type$$doFullType)($env, $full));
      }))()
      : ((($rawType)[0] === "$TypeVar")
        ? ((() => {
          const $tyvarId = ($rawType)[1];
          return ($u$$src$Human$Type$$doTyvarId)($env, $tyvarId);
        }))()
        : ((($rawType)[0] === "$TypeRecord")
          ? ((() => {
            const $maybeExtId = ($rawType)[1];
            const $taAttrs = ($rawType)[2];
            const $maybeExtension = ((($maybeExtId)[0] === "$Nothing")
              ? $c$$src$Maybe$$Nothing
              : ((($maybeExtId)[0] === "$Just")
                ? ((() => {
                  const $id = ($maybeExtId)[1];
                  return ($c$$src$Maybe$$Just)(($c$$src$Maybe$$Just)(($u$$src$Human$Type$$toExpression)(($u$$src$Human$Type$$doTyvarId)($env, $id))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 85:16', (sp_toHuman)($maybeExtId))));
            const $attrs = ((($0) => {
              return ($c$$src$List$$map)((($4) => {
                const $name = $4.first;
                const $raw = $4.second;
                return ({
                  maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Human$Type$$doRawType)($env, $raw)),
                  name: ($u$$src$Human$Type$$doLowercase)($env, $name),
                });
              }), $0);
            }))(((($0) => {
              return (list_sortBy)($c$$src$Tuple$$first, $0);
            }))(($c$$src$Dict$$toList)($taAttrs)));
            return ($c$$src$Compiler$FormattableAst$$Record)(({
              attrs: $attrs,
              isMultiline: false,
              maybeExtension: $maybeExtension,
            }));
          }))()
          : ((($rawType)[0] === "$TypeError")
            ? ($c$$src$Compiler$FormattableAst$$LiteralText)($c$$src$Compiler$Token$$SingleQuote, "???")
            : (true
              ? ((() => {
                const $wtf = $rawType;
                return (sp_todo)("bug: this should not be a type");
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 72:4', (sp_toHuman)($rawType)))))))));
});

const $u$$src$SPLib$Format$$indent_combine = (($pos, $i) => {
  return ($pos + $i);
});

const $u$$src$SPLib$Format$$indent_width = (($0) => {
  return ($c$$src$List$$for)(0, $0, $u$$src$SPLib$Format$$indent_combine);
});

const $u$$src$SPLib$Format$$spaces = (($0) => {
  return ($c$$src$Text$$repeat)($0, " ");
});

const $u$$src$SPLib$Format$$renderLine = (($i, $l) => {
  return ((($l)[0] === "$Text_")
    ? ((() => {
      const $text = ($l)[1];
      return (($u$$src$SPLib$Format$$spaces)(($u$$src$SPLib$Format$$indent_width)($i)) + $text);
    }))()
    : ((($l)[0] === "$CommentWithIndent")
      ? ((() => {
        const $text = ($l)[1];
        return (($u$$src$SPLib$Format$$spaces)(($u$$src$SPLib$Format$$indent_width)($i)) + $text);
      }))()
      : ((($l)[0] === "$CommentIgnoreIndent")
        ? ((() => {
          const $text = ($l)[1];
          return $text;
        }))()
        : ((($l)[0] === "$Space")
          ? ($u$$src$SPLib$Format$$spaces)((1 + ($u$$src$SPLib$Format$$indent_width)($i)))
          : ((($l)[0] === "$Row")
            ? ((() => {
              const $left = ($l)[1];
              const $right = ($l)[2];
              return (($u$$src$SPLib$Format$$renderLine)($i, $left) + ($u$$src$SPLib$Format$$renderLine)($c$$src$Core$$Nil, $right));
            }))()
            : ((($l)[0] === "$Blank")
              ? ""
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 454:4', (sp_toHuman)($l))))))));
});

const $u$$src$SPLib$Format$$renderIndentedLine = (($1) => {
  const $i = ($1)[1];
  const $line_ = ($1)[2];
  return ((($0) => {
    return ($0 + "\n");
  }))(($c$$src$Text$$trimRight)(((($0) => {
    return ($u$$src$SPLib$Format$$renderLine)($i, $0);
  }))(($u$$src$SPLib$Format$$stripEnd)($line_))));
});

const $u$$src$SPLib$Format$$render = (($block) => {
  return ((($block)[0] === "$Empty")
    ? ""
    : ((($block)[0] === "$SingleLine")
      ? ((() => {
        const $line_ = ($block)[2];
        return ($u$$src$SPLib$Format$$renderIndentedLine)($line_);
      }))()
      : ((($block)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($block)[1];
          const $rest = ($block)[2];
          return ((($0) => {
            return ($c$$src$Text$$join)("", $0);
          }))(((($0) => {
            return ($c$$src$List$$map)($u$$src$SPLib$Format$$renderIndentedLine, $0);
          }))(($c$$src$Core$$Cons)($l1, $rest)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 469:4', (sp_toHuman)($block)))));
});

const $u$$src$Compiler$TypeCheck$$typeToHuman = (($env, $raw) => {
  return ($u$$src$SPLib$Format$$render)(((($0) => {
    return ($u$$src$Human$Format$$formatExpression)(({
      isRoot: true,
      originalContent: "",
    }), $0);
  }))(((($0) => {
    return ($u$$src$Human$Type$$doRawType)($env, $0);
  }))($raw)));
});

const $u$$src$Compiler$TypeCheck$$addErError = (($env, $equality, $message, $state) => {
  const $5 = $equality;
  const $why = $5.why;
  const $type2 = $5.type2;
  const $type1 = $5.type1;
  const $pos = $5.pos;
  const $context = $5.context;
  return ([
    ((($0) => {
      return ((__re__ = (array_push)($state.errors, $0)), ($state.errors = (__re__)[1]), (__re__)[0]);
    }))(((($0) => {
      return ($u$$src$Compiler$Error$$Simple)(($u$$src$Compiler$TypeCheck$$getErrorModule)($env), $pos, $0);
    }))(($c$$src$Core$$Cons)($message, ($c$$src$Core$$Cons)((sp_toHuman)($context), ($c$$src$Core$$Cons)((sp_toHuman)($why), ($c$$src$Core$$Cons)("TYPE 1 -----------------------", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck$$typeToHuman)($env, $type1), ($c$$src$Core$$Cons)("TYPE 2 -----------------------", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck$$typeToHuman)($env, $type2), $c$$src$Core$$Nil))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addErErrorIf = (($env, $test, $equality, $message, $state) => {
  return ([
    ($test
      ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $equality, $message, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addError = (($env, $pos, $error, $state) => {
  return ([
    ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorE)($env, $pos, $error, $state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addSub = (($newId, $newUni, $subs) => {
  let $newSubs = (hash_fromList)($c$$src$Core$$Nil);
  const $replace = (($uni) => {
    return ((($uni)[0] === "$Depends")
      ? ((() => {
        const $id = ($uni)[1];
        return ((sp_equal)($id, $newId)
          ? $newUni
          : $uni);
      }))()
      : (true
        ? $uni
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2176:8', (sp_toHuman)($uni))));
  });
  ((__re__ = (hash_each)($subs, (($univarId, $uniqueness) => {
    return ((__re__ = (hash_insert)($newSubs, $univarId, ($replace)($uniqueness))), ($newSubs = (__re__)[1]), (__re__)[0]);
  }))), ($subs = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($newSubs, $newId, $newUni)), ($newSubs = (__re__)[1]), (__re__)[0]);
  return ([
    ($subs = $newSubs),
    $subs,
  ]);
});

const $u$$src$Compiler$TypeCheck$$solveUniquenessConstraint = (($env, $eq, $state) => {
  const $4 = ((__re__ = (hash_get)($state.univarSubs, $eq.id)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Nothing")
      ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addSub)($eq.id, $eq.uni, $state.univarSubs)), ($state.univarSubs = (__re__)[1]), (__re__)[0])
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $subUni = ($4)[1];
          return ((sp_equal)($subUni, $eq.uni)
            ? null
            : ((() => {
              const $5 = ({
                first: $subUni,
                second: $eq.uni,
              });
              return ((($5.first)[0] === "$Depends")
                ? ((() => {
                  const $subId = ($5.first)[1];
                  return ((__re__ = ($u$$src$Compiler$TypeCheck$$addSub)($subId, $eq.uni, $state.univarSubs)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
                }))()
                : ((($5.second)[0] === "$Depends")
                  ? ((() => {
                    const $newId = ($5.second)[1];
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$addSub)($newId, $subUni, $state.univarSubs)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $eq.pos, ($u$$src$Compiler$TypeCheck$$ErrorUnresolvableUniqueness)($eq, $subUni), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2200:16', (sp_toHuman)($5)))));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2190:4', (sp_toHuman)($4)))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$uniCanBeCastTo = (($1) => {
  const $given = $1.given;
  const $required = $1.required;
  const $2 = ({
    first: $given,
    second: $required,
  });
  return ((($2.second)[0] === "$Imm")
    ? $u$$src$Compiler$TypeCheck$$CanBeCastYes
    : ((($2.first)[0] === "$Uni")
      ? $u$$src$Compiler$TypeCheck$$CanBeCastYes
      : (((($2.first)[0] === "$Imm") && (($2.second)[0] === "$Uni"))
        ? ($u$$src$Compiler$TypeCheck$$CanBeCastNo)($c$$src$Core$$Nil)
        : (((($2.first)[0] === "$Depends") && (($2.second)[0] === "$Uni"))
          ? ((() => {
            const $a = ($2.first)[1];
            return ($u$$src$Compiler$TypeCheck$$CanBeCastNo)(($c$$src$Core$$Cons)(({
              first: $a,
              second: $c$$src$Compiler$Ast$$Uni,
            }), $c$$src$Core$$Nil));
          }))()
          : (((($2.first)[0] === "$Depends") && (($2.second)[0] === "$Depends"))
            ? ((() => {
              const $a = ($2.first)[1];
              const $b = ($2.second)[1];
              return ((sp_equal)($a, $b)
                ? $u$$src$Compiler$TypeCheck$$CanBeCastYes
                : ($u$$src$Compiler$TypeCheck$$CanBeCastNo)(($c$$src$Core$$Cons)(({
                  first: $a,
                  second: ($c$$src$Compiler$Ast$$Depends)($b),
                }), ($c$$src$Core$$Cons)(({
                  first: $b,
                  second: ($c$$src$Compiler$Ast$$Depends)($a),
                }), $c$$src$Core$$Nil))));
            }))()
            : (((($2.first)[0] === "$Imm") && (($2.second)[0] === "$Depends"))
              ? ((() => {
                const $b = ($2.second)[1];
                return ($u$$src$Compiler$TypeCheck$$CanBeCastNo)(($c$$src$Core$$Cons)(({
                  first: $b,
                  second: $c$$src$Compiler$Ast$$Imm,
                }), $c$$src$Core$$Nil));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 543:4', (sp_toHuman)($2))))))));
});

const $u$$src$Compiler$TypeCheck$$compareParTypes = (($env, $currentEquality, $index, $p1, $p2, $state) => {
  const $7 = $currentEquality;
  const $why = $7.why;
  const $pos = $7.pos;
  const $expandedRecursives = $7.expandedRecursives;
  const $context = $7.context;
  const $8 = ({
    first: $p1,
    second: $p2,
  });
  return ([
    (((($8.first)[0] === "$ParRe") && (($8.second)[0] === "$ParRe"))
      ? ((() => {
        const $raw1 = ($8.first)[1];
        const $raw2 = ($8.second)[1];
        return ((($0) => {
          return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))(({
          context: $context,
          expandedRecursives: $expandedRecursives,
          pos: $pos,
          type1: $raw1,
          type2: $raw2,
          why: ($u$$src$Compiler$TypeCheck$$Why_FunctionInput)($index, $why),
        }));
      }))()
      : (((($8.first)[0] === "$ParSp") && (($8.second)[0] === "$ParSp"))
        ? ((() => {
          const $full1 = ($8.first)[1];
          const $full2 = ($8.second)[1];
          ((($0) => {
            return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))(({
            context: $context,
            expandedRecursives: $expandedRecursives,
            pos: $pos,
            type1: $full1.raw,
            type2: $full2.raw,
            why: ($u$$src$Compiler$TypeCheck$$Why_FunctionInput)($index, $why),
          }));
          const $9 = ($u$$src$Compiler$TypeCheck$$uniCanBeCastTo)(({
            given: $full1.uni,
            required: $full2.uni,
          }));
          return ((($9)[0] === "$CanBeCastYes")
            ? null
            : (((($9)[0] === "$CanBeCastNo") && ((($9)[1])[0] === "$Nil"))
              ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $currentEquality, ("Function call par " + ((text_fromNumber)($index) + " with wrong uniqueness")), $state)), ($state = (__re__)[1]), (__re__)[0])
              : (((($9)[0] === "$CanBeCastNo") && ((($9)[1])[0] === "$Cons"))
                ? ((() => {
                  const $id = (($9)[1])[1].first;
                  const $uni = (($9)[1])[1].second;
                  const $tail = (($9)[1])[2];
                  return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveUniquenessConstraint)($env, ({
                    context: $context,
                    id: $id,
                    pos: $pos,
                    uni: $uni,
                    why: "fn arg",
                  }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2255:12', (sp_toHuman)($9)))));
          return null;
        }))()
        : (true
          ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, ((() => {
            const $0 = $currentEquality;
            return (Object.assign)({}, $0, ({
              why: ($u$$src$Compiler$TypeCheck$$Why_FunctionInput)($index, $why),
            }));
          }))(), "recycling does not match", $state)), ($state = (__re__)[1]), (__re__)[0])
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2239:4', (sp_toHuman)($8))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$applySubstitutionToType = (($tyvarId, $replacingType, $originalType) => {
  const $subsAsFns = ({
    ty: (($id) => {
      return ((sp_equal)($id, $tyvarId)
        ? ($c$$src$Maybe$$Just)($replacingType)
        : $c$$src$Maybe$$Nothing);
    }),
    uni: ((_0) => {
      return $c$$src$Maybe$$Nothing;
    }),
  });
  return ($c$$src$Compiler$TypedAst$$resolveRaw)($subsAsFns, $originalType);
});

const $u$$src$Compiler$TypeCheck$$occurs = (($tyvarId, $type) => {
  const $rec = (($0) => {
    return ($u$$src$Compiler$TypeCheck$$occurs)($tyvarId, $0);
  });
  return ((($type)[0] === "$TypeFn")
    ? ((() => {
      const $ins = ($type)[1];
      const $out = ($type)[2];
      return (($c$$src$List$$any)((($t) => {
        return ($rec)(($c$$src$Compiler$TypedAst$$toRaw)($t));
      }), $ins) || ($rec)($out.raw));
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return (sp_equal)($id, $tyvarId);
      }))()
      : ((($type)[0] === "$TypeExact")
        ? ((() => {
          const $usr = ($type)[1];
          const $args = ($type)[2];
          return ($c$$src$List$$any)($rec, $args);
        }))()
        : ((($type)[0] === "$TypeRecord")
          ? ((() => {
            const $attrs = ($type)[2];
            return ($c$$src$Dict$$any)((($k, $v) => {
              return ($rec)($v);
            }), $attrs);
          }))()
          : ((($type)[0] === "$TypeError")
            ? false
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2415:4', (sp_toHuman)($type)))))));
});

const $u$$src$Compiler$TypeCheck$$replaceUnificationVariable = (($env, $equality, $tyvarId, $replacingType, $state) => {
  const $isSame = ((($replacingType)[0] === "$TypeVar")
    ? ((() => {
      const $tyvarId2 = ($replacingType)[1];
      return (sp_equal)($tyvarId, $tyvarId2);
    }))()
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2390:8', (sp_toHuman)($replacingType))));
  return ([
    ($isSame
      ? null
      : (($u$$src$Compiler$TypeCheck$$occurs)($tyvarId, $replacingType)
        ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $equality, "circular!?", $state)), ($state = (__re__)[1]), (__re__)[0])
        : ((() => {
          let $new = (hash_fromList)($c$$src$Core$$Nil);
          ((__re__ = (hash_each)($state.tyvarSubs, (($tId, $rawType) => {
            return ((__re__ = (hash_insert)($new, $tId, ($u$$src$Compiler$TypeCheck$$applySubstitutionToType)($tyvarId, $replacingType, $rawType))), ($new = (__re__)[1]), (__re__)[0]);
          }))), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
          ((__re__ = (hash_insert)($new, $tyvarId, $replacingType)), ($new = (__re__)[1]), (__re__)[0]);
          return ($state.tyvarSubs = $new);
        }))())),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$solveRecordExt = (($env, $equality, $swapEquality, $tyvar1, $attrs1, $attrs2, $state) => {
  const $8 = $equality;
  const $why = $8.why;
  const $pos = $8.pos;
  const $context = $8.context;
  ($c$$src$Dict$$each)($attrs1, (($name, $type1) => {
    const $11 = ($c$$src$Dict$$get)($name, $attrs2);
    return ((($11)[0] === "$Nothing")
      ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $equality, ("missing attribute " + $name), $state)), ($state = (__re__)[1]), (__re__)[0])
      : ((($11)[0] === "$Just")
        ? ((() => {
          const $type2 = ($11)[1];
          const $12 = ($swapEquality
            ? ({
              first: $type2,
              second: $type1,
            })
            : ({
              first: $type1,
              second: $type2,
            }));
          const $b = $12.second;
          const $a = $12.first;
          return ((($0) => {
            return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))(((() => {
            const $0 = $equality;
            return (Object.assign)({}, $0, ({
              context: ($u$$src$Compiler$TypeCheck$$Context_AttributeName)($name, $context),
              type1: $a,
              type2: $b,
            }));
          }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2368:8', (sp_toHuman)($11))));
  }));
  return ([
    ((__re__ = ($u$$src$Compiler$TypeCheck$$replaceUnificationVariable)($env, $equality, $tyvar1, ($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, $attrs2), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$solveEquality = (($env, $head, $state) => {
  const $4 = $head;
  const $why = $4.why;
  const $type2 = $4.type2;
  const $type1 = $4.type1;
  const $pos = $4.pos;
  const $expandedRecursives = $4.expandedRecursives;
  const $context = $4.context;
  const $5 = ({
    first: $type1,
    second: $type2,
  });
  return ([
    ((($5.first)[0] === "$TypeVar")
      ? ((() => {
        const $tyvarId = ($5.first)[1];
        const $t2 = $5.second;
        return ((__re__ = ($u$$src$Compiler$TypeCheck$$replaceUnificationVariable)($env, $head, $tyvarId, $t2, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($5.second)[0] === "$TypeVar")
        ? ((() => {
          const $t1 = $5.first;
          const $tyvarId = ($5.second)[1];
          return ((__re__ = ($u$$src$Compiler$TypeCheck$$replaceUnificationVariable)($env, $head, $tyvarId, $t1, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : (((($5.first)[0] === "$TypeExact") && (($5.second)[0] === "$TypeExact"))
          ? ((() => {
            const $usr1 = ($5.first)[1];
            const $args1 = ($5.first)[2];
            const $usr2 = ($5.second)[1];
            const $args2 = ($5.second)[2];
            return ((sp_not_equal)($usr1, $usr2)
              ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $head, "types are incompatible2", $state)), ($state = (__re__)[1]), (__re__)[0])
              : ((() => {
                ($c$$src$List$$indexedEach2)($args2, $args1, (($index, $raw1, $raw2) => {
                  return ((($0) => {
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))(((() => {
                    const $0 = $head;
                    return (Object.assign)({}, $0, ({
                      type1: $raw1,
                      type2: $raw2,
                      why: ($u$$src$Compiler$TypeCheck$$Why_TypeArgument)($usr1, $index, $why),
                    }));
                  }))());
                }));
                return null;
              }))());
          }))()
          : (((($5.first)[0] === "$TypeFn") && (($5.second)[0] === "$TypeFn"))
            ? ((() => {
              const $pars1 = ($5.first)[1];
              const $out1 = ($5.first)[2];
              const $pars2 = ($5.second)[1];
              const $out2 = ($5.second)[2];
              return ((sp_not_equal)(($c$$src$List$$length)($pars1), ($c$$src$List$$length)($pars2))
                ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $head, "functions expect a different number of arguments", $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((() => {
                  ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, ((() => {
                    const $0 = $head;
                    return (Object.assign)({}, $0, ({
                      type1: $out1.raw,
                      type2: $out2.raw,
                      why: ($u$$src$Compiler$TypeCheck$$Why_FunctionOutput)($why),
                    }));
                  }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  const $bleh = ((() => {
                    const $6 = ($u$$src$Compiler$TypeCheck$$uniCanBeCastTo)(({
                      given: $out2.uni,
                      required: $out1.uni,
                    }));
                    return ((($6)[0] === "$CanBeCastYes")
                      ? null
                      : (((($6)[0] === "$CanBeCastNo") && ((($6)[1])[0] === "$Nil"))
                        ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $head, "the function return type have different uniqueness", $state)), ($state = (__re__)[1]), (__re__)[0])
                        : (((($6)[0] === "$CanBeCastNo") && ((($6)[1])[0] === "$Cons"))
                          ? ((() => {
                            const $id = (($6)[1])[1].first;
                            const $uni = (($6)[1])[1].second;
                            const $tail = (($6)[1])[2];
                            return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveUniquenessConstraint)($env, ({
                              context: $context,
                              id: $id,
                              pos: $pos,
                              uni: $uni,
                              why: "fn out",
                            }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2304:20', (sp_toHuman)($6)))));
                  }))();
                  return ($c$$src$List$$indexedEach2)($pars1, $pars2, (($0, $1, $2) => {
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$compareParTypes)($env, $head, $0, $1, $2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }));
                }))());
            }))()
            : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
              ? ((() => {
                const $attrs1 = ($5.first)[2];
                const $attrs2 = ($5.second)[2];
                const $6 = ($c$$src$Dict$$onlyBothOnly)($attrs1, $attrs2);
                const $only2 = $6.third;
                const $both = $6.second;
                const $only1 = $6.first;
                ($c$$src$Dict$$each)($both, (($attrName, $7) => {
                  const $attrType1 = $7.first;
                  const $attrType2 = $7.second;
                  return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, ((() => {
                    const $0 = $head;
                    return (Object.assign)({}, $0, ({
                      type1: $attrType1,
                      type2: $attrType2,
                      why: ($u$$src$Compiler$TypeCheck$$Why_Attribute)($why),
                    }));
                  }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
                }));
                return ((__re__ = ($u$$src$Compiler$TypeCheck$$addErErrorIf)($env, ((sp_not_equal)($only1, $c$$src$Dict$$empty) || (sp_not_equal)($only2, $c$$src$Dict$$empty)), $head, "record attrs don't match", $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
                ? ((() => {
                  const $tyvar1 = (($5.first)[1])[1];
                  const $attrs1 = ($5.first)[2];
                  const $attrs2 = ($5.second)[2];
                  return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveRecordExt)($env, $head, false, $tyvar1, $attrs1, $attrs2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Just"))))
                  ? ((() => {
                    const $attrs1 = ($5.first)[2];
                    const $tyvar2 = (($5.second)[1])[1];
                    const $attrs2 = ($5.second)[2];
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveRecordExt)($env, $head, true, $tyvar2, $attrs2, $attrs1, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Just"))))
                    ? ((() => {
                      const $tyvar1 = (($5.first)[1])[1];
                      const $attrs1 = ($5.first)[2];
                      const $tyvar2 = (($5.second)[1])[1];
                      const $attrs2 = ($5.second)[2];
                      const $6 = ($c$$src$Dict$$onlyBothOnly)($attrs1, $attrs2);
                      const $only2 = $6.third;
                      const $both = $6.second;
                      const $only1 = $6.first;
                      const $newExtId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $newType = ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($newExtId), ($c$$src$Dict$$join)($attrs1, $only2));
                      ((__re__ = ($u$$src$Compiler$TypeCheck$$replaceUnificationVariable)($env, $head, $tyvar1, $newType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      ((__re__ = ($u$$src$Compiler$TypeCheck$$replaceUnificationVariable)($env, $head, $tyvar2, $newType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return ($c$$src$Dict$$each)($both, (($name, $7) => {
                        const $t1 = $7.first;
                        const $t2 = $7.second;
                        return ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, ({
                          context: ($u$$src$Compiler$TypeCheck$$Context_AttributeName)($name, $context),
                          expandedRecursives: $expandedRecursives,
                          pos: $pos,
                          type1: $t1,
                          type2: $t1,
                          why: $why,
                        }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }));
                    }))()
                    : ((($5.first)[0] === "$TypeError")
                      ? null
                      : ((($5.second)[0] === "$TypeError")
                        ? null
                        : (true
                          ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addErError)($env, $head, "types are incompatible1", $state)), ($state = (__re__)[1]), (__re__)[0])
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2274:4', (sp_toHuman)($5))))))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addEquality = (($env, $pos, $why, $t1, $t2, $state) => {
  return ([
    ((__re__ = ($u$$src$Compiler$TypeCheck$$solveEquality)($env, ({
      context: $env.context,
      expandedRecursives: $c$$src$Set$$empty,
      pos: $pos,
      type1: ((__re__ = ($u$$src$Compiler$TypeCheck$$applyAllSubs)($state, $t1)), ($state = (__re__)[1]), (__re__)[0]),
      type2: ((__re__ = ($u$$src$Compiler$TypeCheck$$applyAllSubs)($state, $t2)), ($state = (__re__)[1]), (__re__)[0]),
      why: $why,
    }), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addErrorIf = (($test, $env, $pos, $error, $state) => {
  return ([
    ($test
      ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $error, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$replaceUnivarRec = (($old, $new, $raw) => {
  const $doRaw = (($0) => {
    return ($u$$src$Compiler$TypeCheck$$replaceUnivarRec)($old, $new, $0);
  });
  return ((($raw)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($raw)[1];
      const $args = ($raw)[2];
      return ($c$$src$Compiler$TypedAst$$TypeExact)($usr, ($c$$src$List$$map)($doRaw, $args));
    }))()
    : ((($raw)[0] === "$TypeRecord")
      ? ((() => {
        const $maybeExt = ($raw)[1];
        const $attrs = ($raw)[2];
        return ($c$$src$Compiler$TypedAst$$TypeRecord)($maybeExt, ($c$$src$Dict$$map)((($k, $v) => {
          return ($doRaw)($v);
        }), $attrs));
      }))()
      : ((($raw)[0] === "$TypeError")
        ? $c$$src$Compiler$TypedAst$$TypeError
        : ((($raw)[0] === "$TypeVar")
          ? ((() => {
            const $id = ($raw)[1];
            return ($c$$src$Compiler$TypedAst$$TypeVar)($id);
          }))()
          : ((($raw)[0] === "$TypeFn")
            ? ((() => {
              const $ins = ($raw)[1];
              const $out = ($raw)[2];
              const $doUni = (($uni) => {
                return ((($uni)[0] === "$Depends")
                  ? ((() => {
                    const $id = ($uni)[1];
                    return ((sp_equal)($id, $old)
                      ? $new
                      : $uni);
                  }))()
                  : (true
                    ? $uni
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 393:16', (sp_toHuman)($uni))));
              });
              const $mapPar = (($par) => {
                return ((($par)[0] === "$ParRe")
                  ? ((() => {
                    const $r = ($par)[1];
                    return ($c$$src$Compiler$TypedAst$$ParRe)(($doRaw)($r));
                  }))()
                  : ((($par)[0] === "$ParSp")
                    ? ((() => {
                      const $f = ($par)[1];
                      return ($c$$src$Compiler$TypedAst$$ParSp)(({
                        raw: ($doRaw)($f.raw),
                        uni: ($doUni)($f.uni),
                      }));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 399:16', (sp_toHuman)($par))));
              });
              return ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$List$$map)($mapPar, $ins), ({
                raw: ($doRaw)($out.raw),
                uni: ($doUni)($out.uni),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 376:4', (sp_toHuman)($raw)))))));
});

const $u$$src$Compiler$TypeCheck$$generalize = (($env, $pos, $ref, $instance, $state) => {
  const $replaceUnivar = (($originalUnivarId, _1, $r) => {
    const $newUnivarId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
    return ($u$$src$Compiler$TypeCheck$$replaceUnivarRec)($originalUnivarId, ($c$$src$Compiler$Ast$$Depends)($newUnivarId), $r);
  });
  const $raw = ((($0) => {
    return ($c$$src$Dict$$for)($0, $instance.freeTyvars, (($originalTyvarId, $tyvar, $a) => {
      const $generalizedTyvarId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = (hash_insert)($state.tyvarsById, $generalizedTyvarId, $tyvar)), ($state.tyvarsById = (__re__)[1]), (__re__)[0]);
      return ($u$$src$Compiler$TypeCheck$$applySubstitutionToType)($originalTyvarId, ($c$$src$Compiler$TypedAst$$TypeVar)($generalizedTyvarId), $a);
    }));
  }))(((($0) => {
    return ($c$$src$Dict$$for)($0, $instance.freeUnivars, $replaceUnivar);
  }))($instance.type.raw));
  const $0 = $instance.type;
  return ([
    (Object.assign)({}, $0, ({
      raw: $raw,
    })),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$getConstructorByUsr = (($usr, $env) => {
  return ($c$$src$Dict$$get)($usr, $env.constructors);
});

const $u$$src$Compiler$TypeCheck$$coreTypeNumber = ($c$$src$Compiler$TypedAst$$TypeExact)($u$$src$Compiler$CoreDefs$$numberDef.usr, $c$$src$Core$$Nil);

const $u$$src$Compiler$TypeCheck$$coreTypeText = ($c$$src$Compiler$TypedAst$$TypeExact)($u$$src$Compiler$CoreDefs$$textDef.usr, $c$$src$Core$$Nil);

const $u$$src$Compiler$TypeCheck$$newRawType = (($state) => {
  return ([
    ($c$$src$Compiler$TypedAst$$TypeVar)(((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0])),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$translateAnnotationType = (($env, $state, $ca) => {
  const $nameToType = ($c$$src$Dict$$map)((($k, $v) => {
    return ($c$$src$Compiler$TypedAst$$TypeVar)($v);
  }), $env.annotatedTyvarsByName);
  return ([
    ((__re__ = ($u$$src$Compiler$TypeCheck$$translateRawType)($env, $nameToType, $env.annotatedUnivarsByOriginalId, $state.errors, $ca)), ($state.errors = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferPatternAny = (($baseEnv, $pos, $uni, $maybeName, $maybeAnnotation, $state) => {
  const $7 = ((($maybeAnnotation)[0] === "$Nothing")
    ? ({
      first: ((__re__ = ($u$$src$Compiler$TypeCheck$$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]),
      second: $baseEnv,
    })
    : ((($maybeAnnotation)[0] === "$Just")
      ? ((() => {
        const $annotation = ($maybeAnnotation)[1];
        const $annotatedTyvarsByName = ($c$$src$Dict$$for)($baseEnv.annotatedTyvarsByName, $annotation.tyvars, (($name, $9, $acc) => {
          const $nonFn = $9.nonFn;
          return (($c$$src$Dict$$member)($name, $acc)
            ? $acc
            : ($c$$src$Dict$$insert)($name, ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]), $acc));
        }));
        const $annotatedUnivarsByOriginalId = ($c$$src$Dict$$for)($baseEnv.annotatedUnivarsByOriginalId, $annotation.univars, (($id, _1, $acc) => {
          return (($c$$src$Dict$$member)($id, $acc)
            ? $acc
            : ($c$$src$Dict$$insert)($id, ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]), $acc));
        }));
        const $newEnv = ((() => {
          const $0 = $baseEnv;
          return (Object.assign)({}, $0, ({
            annotatedTyvarsByName: $annotatedTyvarsByName,
            annotatedUnivarsByOriginalId: $annotatedUnivarsByOriginalId,
          }));
        }))();
        return ({
          first: ((__re__ = ($u$$src$Compiler$TypeCheck$$translateAnnotationType)($newEnv, $state, $annotation.raw)), ($state = (__re__)[1]), (__re__)[0]),
          second: $newEnv,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1707:8', (sp_toHuman)($maybeAnnotation))));
  const $envWithAnnotations = $7.second;
  const $raw = $7.first;
  const $type = ({
    raw: $raw,
    uni: $uni,
  });
  const $envWithVariable = ((($maybeName)[0] === "$Nothing")
    ? $envWithAnnotations
    : ((($maybeName)[0] === "$Just")
      ? ((() => {
        const $name = ($maybeName)[1];
        const $variable = ({
          definedAt: $pos,
          freeTyvars: $c$$src$Dict$$empty,
          freeUnivars: $c$$src$Dict$$empty,
          type: $type,
        });
        const $0 = $envWithAnnotations;
        return (Object.assign)({}, $0, ({
          variables: ($c$$src$Dict$$insert)(($c$$src$Compiler$Ast$$RefLocal)($name), $variable, $0.variables),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1737:8', (sp_toHuman)($maybeName))));
  const $typedPattern = ($c$$src$Compiler$TypedAst$$PatternAny)($pos, ({
    maybeName: $maybeName,
    type: $type,
  }));
  return ([
    ({
      env: $envWithVariable,
      maybeFullAnnotation: $maybeAnnotation,
      patternType: $raw,
      typedPattern: $typedPattern,
    }),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferPattern = (($env, $uni, $pattern, $state) => {
  return ([
    ((($pattern)[0] === "$PatternAny")
      ? ((() => {
        const $pos = ($pattern)[1];
        const $maybeName = ($pattern)[2];
        const $maybeAnn = ($pattern)[3];
        return ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPatternAny)($env, $pos, $uni, $maybeName, $maybeAnn, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($pattern)[0] === "$PatternLiteralText")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $text = ($pattern)[2];
          return ({
            env: $env,
            maybeFullAnnotation: $c$$src$Maybe$$Nothing,
            patternType: $u$$src$Compiler$TypeCheck$$coreTypeText,
            typedPattern: ($c$$src$Compiler$TypedAst$$PatternLiteralText)($pos, $text),
          });
        }))()
        : ((($pattern)[0] === "$PatternLiteralNumber")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $n = ($pattern)[2];
            return ({
              env: $env,
              maybeFullAnnotation: $c$$src$Maybe$$Nothing,
              patternType: $u$$src$Compiler$TypeCheck$$coreTypeNumber,
              typedPattern: ($c$$src$Compiler$TypedAst$$PatternLiteralNumber)($pos, $n),
            });
          }))()
          : ((($pattern)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $usr = ($pattern)[2];
              const $arguments = ($pattern)[3];
              const $5 = ((($0) => {
                return ($c$$src$List$$forReversed)($0, $arguments, (($arg, $7) => {
                  const $argOuts = $7.first;
                  const $envX = $7.second;
                  const $out = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($envX, $uni, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return ({
                    first: (sp_cons)($out, $argOuts),
                    second: $out.env,
                  });
                }));
              }))(({
                first: $c$$src$Core$$Nil,
                second: $env,
              }));
              const $newEnv = $5.second;
              const $argumentOuts = $5.first;
              const $typedArguments = ($c$$src$List$$map)((($out) => {
                return $out.typedPattern;
              }), $argumentOuts);
              const $argumentTypes = ($c$$src$List$$map)((($out) => {
                return $out.patternType;
              }), $argumentOuts);
              const $finalType = ((() => {
                const $6 = ($u$$src$Compiler$TypeCheck$$getConstructorByUsr)($usr, $env);
                return ((($6)[0] === "$Nothing")
                  ? ((() => {
                    ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $c$$src$Compiler$TypedAst$$TypeError;
                  }))()
                  : ((($6)[0] === "$Just")
                    ? ((() => {
                      const $cons = ($6)[1];
                      const $x = ((__re__ = ($u$$src$Compiler$TypeCheck$$generalize)($env, $pos, ($c$$src$Compiler$Ast$$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $7 = ((() => {
                        const $8 = $x.raw;
                        return ((($8)[0] === "$TypeFn")
                          ? ((() => {
                            const $ins = ($8)[1];
                            const $out = ($8)[2];
                            return ({
                              first: $ins,
                              second: $out.raw,
                            });
                          }))()
                          : (true
                            ? ({
                              first: $c$$src$Core$$Nil,
                              second: $x.raw,
                            })
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1652:28', (sp_toHuman)($8))));
                      }))();
                      const $returnType = $7.second;
                      const $parTypes = $7.first;
                      ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)(($c$$src$List$$length)($parTypes), ($c$$src$List$$length)($arguments)), $env, $pos, $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfConstructorArguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      ($c$$src$List$$indexedEach2)($parTypes, $argumentTypes, (($index, $parType, $argType) => {
                        return ((($parType)[0] === "$ParRe")
                          ? ((() => {
                            const $raw = ($parType)[1];
                            return ($u$$src$Compiler$TypeCheck$$bug)("cons can't recycle?!");
                          }))()
                          : ((($parType)[0] === "$ParSp")
                            ? ((() => {
                              const $full = ($parType)[1];
                              return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, ($u$$src$Compiler$TypeCheck$$Why_Argument)($index), $full.raw, $argType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1659:28', (sp_toHuman)($parType))));
                      }));
                      return $returnType;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1640:16', (sp_toHuman)($6))));
              }))();
              return ({
                env: $newEnv,
                maybeFullAnnotation: $c$$src$Maybe$$Nothing,
                patternType: $finalType,
                typedPattern: ($c$$src$Compiler$TypedAst$$PatternConstructor)($pos, $usr, $typedArguments),
              });
            }))()
            : ((($pattern)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($pattern)[1];
                const $completeness = ($pattern)[2];
                const $pas = ($pattern)[3];
                const $5 = ((($0) => {
                  return ($c$$src$Dict$$for)($0, $pas, (($name, $pa, $7) => {
                    const $dict = $7.first;
                    const $envX = $7.second;
                    const $out = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($envX, $uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ({
                      first: ($c$$src$Dict$$insert)($name, $out, $dict),
                      second: $out.env,
                    });
                  }));
                }))(({
                  first: $c$$src$Dict$$empty,
                  second: $env,
                }));
                const $newEnv = $5.second;
                const $outs = $5.first;
                const $patternExt = ((($completeness)[0] === "$Complete")
                  ? $c$$src$Maybe$$Nothing
                  : ((($completeness)[0] === "$Partial")
                    ? ($c$$src$Maybe$$Just)(((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]))
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1688:16', (sp_toHuman)($completeness))));
                const $raw = ($c$$src$Compiler$TypedAst$$TypeRecord)($patternExt, ((($0) => {
                  return ($c$$src$Dict$$map)((($name, $out) => {
                    return $out.patternType;
                  }), $0);
                }))($outs));
                return ({
                  env: $newEnv,
                  maybeFullAnnotation: $c$$src$Maybe$$Nothing,
                  patternType: $raw,
                  typedPattern: ($c$$src$Compiler$TypedAst$$PatternRecord)($pos, ((($0) => {
                    return ($c$$src$Dict$$map)((($k, $o) => {
                      return ({
                        first: $o.typedPattern,
                        second: $o.patternType,
                      });
                    }), $0);
                  }))($outs)),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1603:4', (sp_toHuman)($pattern))))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$fullTypeError = ({
  raw: $c$$src$Compiler$TypedAst$$TypeError,
  uni: $c$$src$Compiler$Ast$$Uni,
});

const $u$$src$Compiler$TypeCheck$$patternError = (($pos) => {
  return ($c$$src$Compiler$TypedAst$$PatternAny)($pos, ({
    maybeName: $c$$src$Maybe$$Nothing,
    type: $u$$src$Compiler$TypeCheck$$fullTypeError,
  }));
});

const $u$$src$Compiler$TypeCheck$$checkPatternConstructor = (($env, $pos, $expectedType, $usr, $arguments, $state) => {
  const $insertArgsOnError = (($0) => {
    return ($c$$src$List$$for)($0, $arguments, (($arg, $envX) => {
      const $out = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($envX, $expectedType.uni, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
      return $out.env;
    }));
  });
  const $7 = ($u$$src$Compiler$TypeCheck$$getConstructorByUsr)($usr, $env);
  return ([
    ((($7)[0] === "$Nothing")
      ? ((() => {
        ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
        return ({
          first: ($u$$src$Compiler$TypeCheck$$patternError)($pos),
          second: ($insertArgsOnError)($env),
        });
      }))()
      : ((($7)[0] === "$Just")
        ? ((() => {
          const $instance = ($7)[1];
          const $fullType_ = ((__re__ = ($u$$src$Compiler$TypeCheck$$generalize)($env, $pos, ($c$$src$Compiler$Ast$$RefGlobal)($usr), ((() => {
            const $0 = $instance;
            return (Object.assign)({}, $0, ({
              freeUnivars: $c$$src$Dict$$empty,
            }));
          }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $fullType = ((() => {
            const $0 = $fullType_;
            return (Object.assign)({}, $0, ({
              raw: ($u$$src$Compiler$TypeCheck$$replaceUnivarRec)(1, $expectedType.uni, $0.raw),
            }));
          }))();
          const $8 = ((() => {
            const $9 = $fullType.raw;
            return ((($9)[0] === "$TypeFn")
              ? ((() => {
                const $ax = ($9)[1];
                const $o = ($9)[2];
                return ({
                  first: $ax,
                  second: $o,
                });
              }))()
              : (true
                ? ({
                  first: $c$$src$Core$$Nil,
                  second: $fullType,
                })
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1887:16', (sp_toHuman)($9))));
          }))();
          const $requiredOut = $8.second;
          const $requiredParTypes = $8.first;
          return ((sp_not_equal)(($c$$src$List$$length)($arguments), ($c$$src$List$$length)($requiredParTypes))
            ? ((() => {
              ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfConstructorArguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: ($u$$src$Compiler$TypeCheck$$patternError)($pos),
                second: ($insertArgsOnError)($env),
              });
            }))()
            : ((() => {
              const $checkArg = (($10, $9) => {
                const $arg = $10.first;
                const $parType = $10.second;
                const $envX = $9.first;
                const $args = $9.second;
                const $11 = ((($parType)[0] === "$ParSp")
                  ? ((() => {
                    const $full = ($parType)[1];
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$checkPattern)($envX, $full, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($parType)[0] === "$ParRe")
                    ? ((() => {
                      const $raw = ($parType)[1];
                      return ($u$$src$Compiler$TypeCheck$$bug)("should not happen???");
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1899:28', (sp_toHuman)($parType))));
                const $envX1 = $11.second;
                const $taArg = $11.first;
                return ({
                  first: $envX1,
                  second: (sp_cons)($taArg, $args),
                });
              });
              const $9 = ((($0) => {
                return ($c$$src$List$$forReversed)($0, ($c$$src$List$$map2)($c$$src$Tuple$$pair, $arguments, $requiredParTypes), $checkArg);
              }))(({
                first: $env,
                second: $c$$src$Core$$Nil,
              }));
              const $typedArgs = $9.second;
              const $newEnv = $9.first;
              ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_CalledAsFunction, $requiredOut.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: ($c$$src$Compiler$TypedAst$$PatternConstructor)($pos, $usr, $typedArgs),
                second: $newEnv,
              });
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1870:4', (sp_toHuman)($7)))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$checkPatternRecord = (($env, $pos, $expectedType, $completeness, $pas, $state) => {
  const $7 = $expectedType;
  const $uni = $7.uni;
  const $8 = $expectedType.raw;
  return ([
    (((($8)[0] === "$TypeRecord") && ((($8)[1])[0] === "$Nothing"))
      ? ((() => {
        const $attrs = ($8)[2];
        const $9 = ($c$$src$Dict$$onlyBothOnly)($pas, $attrs);
        const $typeOnly = $9.third;
        const $both = $9.second;
        const $paOnly = $9.first;
        ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($paOnly, $c$$src$Dict$$empty), $env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordHasAttributesNotInAnnotation)(($c$$src$Dict$$keys)($paOnly)), $state)), ($state = (__re__)[1]), (__re__)[0]);
        ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)(((sp_not_equal)($typeOnly, $c$$src$Dict$$empty) && (sp_equal)($completeness, $c$$src$Compiler$CanonicalAst$$Complete)), $env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordIsMissingAttibutesInAnnotation)(($c$$src$Dict$$keys)($typeOnly)), $state)), ($state = (__re__)[1]), (__re__)[0]);
        const $10 = ((($0) => {
          return ($c$$src$Dict$$for)($0, $both, (($name, $13, $12) => {
            const $pa = $13.first;
            const $raw = $13.second;
            const $acc = $12.first;
            const $envX = $12.second;
            const $15 = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkPattern)(((() => {
              const $0 = $envX;
              return (Object.assign)({}, $0, ({
                context: ($u$$src$Compiler$TypeCheck$$Context_AttributeName)($name, $env.context),
              }));
            }))(), ({
              raw: $raw,
              uni: $uni,
            }), $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $envX0 = $15.second;
            const $taPa = $15.first;
            return ({
              first: ($c$$src$Dict$$insert)($name, ({
                first: $taPa,
                second: $raw,
              }), $acc),
              second: ((() => {
                const $0 = $envX0;
                return (Object.assign)({}, $0, ({
                  context: $env.context,
                }));
              }))(),
            });
          }));
        }))(({
          first: $c$$src$Dict$$empty,
          second: $env,
        }));
        const $envF = $10.second;
        const $taPas = $10.first;
        return ({
          first: ($c$$src$Compiler$TypedAst$$PatternRecord)($pos, $taPas),
          second: $envF,
        });
      }))()
      : (((($8)[0] === "$TypeRecord") && ((($8)[1])[0] === "$Just"))
        ? ((() => {
          const $tyvarId = (($8)[1])[1];
          const $a = ($8)[2];
          return ($u$$src$Compiler$TypeCheck$$bug)("can't annotate extensible types");
        }))()
        : (true
          ? ((() => {
            ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $u$$src$Compiler$TypeCheck$$ErrorNotCompatibleWithRecord, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $envF = ((($0) => {
              return ($c$$src$Dict$$for)($0, $pas, (($name, $pa, $envX) => {
                const $out = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($envX, $expectedType.uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $out.env;
              }));
            }))($env);
            return ({
              first: ($u$$src$Compiler$TypeCheck$$patternError)($pos),
              second: $envF,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1818:4', (sp_toHuman)($8))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$checkPattern = (($env, $expectedType, $pattern, $state) => {
  const $5 = ({
    first: $pattern,
    second: $expectedType.raw,
  });
  return ([
    ((($5.first)[0] === "$PatternAny")
      ? ((() => {
        const $pos = ($5.first)[1];
        const $maybeName = ($5.first)[2];
        const $maybeAnnotation = ($5.first)[3];
        const $newEnv = ((($maybeName)[0] === "$Nothing")
          ? $env
          : ((($maybeName)[0] === "$Just")
            ? ((() => {
              const $name = ($maybeName)[1];
              const $variable = ({
                definedAt: $pos,
                freeTyvars: $c$$src$Dict$$empty,
                freeUnivars: $c$$src$Dict$$empty,
                type: $expectedType,
              });
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: ($c$$src$Dict$$insert)(($c$$src$Compiler$Ast$$RefLocal)($name), $variable, $0.variables),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1775:16', (sp_toHuman)($maybeName))));
        return ({
          first: ($c$$src$Compiler$TypedAst$$PatternAny)($pos, ({
            maybeName: $maybeName,
            type: $expectedType,
          })),
          second: $newEnv,
        });
      }))()
      : (((($5.first)[0] === "$PatternLiteralText") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
        ? ((() => {
          const $pos = ($5.first)[1];
          const $text = ($5.first)[2];
          const $typeUsr = ($5.second)[1];
          ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($typeUsr, $u$$src$Compiler$CoreDefs$$textDef.usr), $env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorIncompatiblePattern)($pattern, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
          return ({
            first: ($c$$src$Compiler$TypedAst$$PatternLiteralText)($pos, $text),
            second: $env,
          });
        }))()
        : (((($5.first)[0] === "$PatternLiteralNumber") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
          ? ((() => {
            const $pos = ($5.first)[1];
            const $text = ($5.first)[2];
            const $typeUsr = ($5.second)[1];
            ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($typeUsr, $u$$src$Compiler$CoreDefs$$numberDef.usr), $env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorIncompatiblePattern)($pattern, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: ($c$$src$Compiler$TypedAst$$PatternLiteralNumber)($pos, $text),
              second: $env,
            });
          }))()
          : ((($5.first)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($5.first)[1];
              const $usr = ($5.first)[2];
              const $arguments = ($5.first)[3];
              return ((__re__ = ($u$$src$Compiler$TypeCheck$$checkPatternConstructor)($env, $pos, $expectedType, $usr, $arguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((($5.first)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($5.first)[1];
                const $completeness = ($5.first)[2];
                const $pas = ($5.first)[3];
                return ((__re__ = ($u$$src$Compiler$TypeCheck$$checkPatternRecord)($env, $pos, $expectedType, $completeness, $pas, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1771:4', (sp_toHuman)($5))))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$checkParameter = (($env, $expectedParType, $par, $state) => {
  return ([
    ((($par)[0] === "$ParameterPattern")
      ? ((() => {
        const $originalUni = ($par)[1];
        const $pa = ($par)[2];
        const $5 = ((($expectedParType)[0] === "$ParRe")
          ? ((() => {
            ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, ($c$$src$Compiler$CanonicalAst$$patternPos)($pa), $u$$src$Compiler$TypeCheck$$ErrorRecyclingDoesNotMatch, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $o = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($env, $c$$src$Compiler$Ast$$Uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: ({
                raw: $o.patternType,
                uni: $c$$src$Compiler$Ast$$Uni,
              }),
              second: ({
                first: $o.typedPattern,
                second: $o.env,
              }),
            });
          }))()
          : ((($expectedParType)[0] === "$ParSp")
            ? ((() => {
              const $full = ($expectedParType)[1];
              const $uni = ($u$$src$Compiler$TypeCheck$$translateUni)($env.annotatedUnivarsByOriginalId, $originalUni);
              ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($uni, $full.uni), $env, ($c$$src$Compiler$CanonicalAst$$patternPos)($pa), ($u$$src$Compiler$TypeCheck$$ErrorUniquenessDoesNotMatchParameter)($uni, $full), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: $full,
                second: ((__re__ = ($u$$src$Compiler$TypeCheck$$checkPattern)($env, $full, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1195:16', (sp_toHuman)($expectedParType))));
        const $env1 = $5.second.second;
        const $typedPa = $5.second.first;
        const $fullType = $5.first;
        return ({
          first: ($c$$src$Compiler$TypedAst$$ParameterPattern)($fullType, $typedPa),
          second: $env1,
        });
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? ((() => {
          const $num = ($par)[1];
          return ((($expectedParType)[0] === "$ParRe")
            ? (sp_todo)("TA.ParRe")
            : ((($expectedParType)[0] === "$ParSp")
              ? ((() => {
                const $type = ($expectedParType)[1];
                const $variable = ({
                  definedAt: $c$$src$Compiler$Pos$$G,
                  freeTyvars: $c$$src$Dict$$empty,
                  freeUnivars: $c$$src$Dict$$empty,
                  type: $type,
                });
                return ({
                  first: ($c$$src$Compiler$TypedAst$$ParameterPlaceholder)($type, $num),
                  second: ((() => {
                    const $0 = $env;
                    return (Object.assign)({}, $0, ({
                      variables: ($c$$src$Dict$$insert)(($c$$src$Compiler$Ast$$RefPlaceholder)($num), $variable, $0.variables),
                    }));
                  }))(),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1216:12', (sp_toHuman)($expectedParType))));
        }))()
        : ((($par)[0] === "$ParameterRecycle")
          ? ((() => {
            const $pos = ($par)[1];
            const $name = ($par)[2];
            const $expectedRaw = ((($expectedParType)[0] === "$ParSp")
              ? ((() => {
                const $full = ($expectedParType)[1];
                ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $u$$src$Compiler$TypeCheck$$ErrorRecyclingDoesNotMatch, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $c$$src$Compiler$TypedAst$$TypeError;
              }))()
              : ((($expectedParType)[0] === "$ParRe")
                ? ((() => {
                  const $raw = ($expectedParType)[1];
                  return $raw;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1234:16', (sp_toHuman)($expectedParType))));
            const $variable = ({
              definedAt: $pos,
              freeTyvars: $c$$src$Dict$$empty,
              freeUnivars: $c$$src$Dict$$empty,
              type: ({
                raw: $expectedRaw,
                uni: $c$$src$Compiler$Ast$$Uni,
              }),
            });
            const $localEnv = ((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: ($c$$src$Dict$$insert)(($c$$src$Compiler$Ast$$RefLocal)($name), $variable, $0.variables),
              }));
            }))();
            return ({
              first: ($c$$src$Compiler$TypedAst$$ParameterRecycle)($pos, $expectedRaw, $name),
              second: $localEnv,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1191:4', (sp_toHuman)($par))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$addConstraint = (($env, $pos, $id, $uni, $state) => {
  const $eq = ({
    context: $u$$src$Compiler$TypeCheck$$Context_Global,
    id: $id,
    pos: $pos,
    uni: $uni,
    why: "-",
  });
  return ([
    ((__re__ = ($u$$src$Compiler$TypeCheck$$solveUniquenessConstraint)($env, $eq, $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$checkUni = (($env, $pos, $2, $state) => {
  const $given = $2.given;
  const $required = $2.required;
  const $5 = ($u$$src$Compiler$TypeCheck$$uniCanBeCastTo)(({
    given: $given,
    required: $required,
  }));
  return ([
    ((($5)[0] === "$CanBeCastYes")
      ? null
      : (((($5)[0] === "$CanBeCastNo") && ((($5)[1])[0] === "$Nil"))
        ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorUniquenessDoesNotMatch)(({
          given: $given,
          required: $required,
        })), $state)), ($state = (__re__)[1]), (__re__)[0])
        : (((($5)[0] === "$CanBeCastNo") && ((($5)[1])[0] === "$Cons"))
          ? ((() => {
            const $univarId = (($5)[1])[1].first;
            const $uni = (($5)[1])[1].second;
            const $tail = (($5)[1])[2];
            return ((__re__ = ($u$$src$Compiler$TypeCheck$$addConstraint)($env, $pos, $univarId, $uni, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 573:4', (sp_toHuman)($5))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$coreTypeBool = ($c$$src$Compiler$TypedAst$$TypeExact)($u$$src$Compiler$CoreDefs$$boolUsr, $c$$src$Core$$Nil);

const $u$$src$Compiler$TypeCheck$$getVariableByRef = (($ref, $env) => {
  return ($c$$src$Dict$$get)($ref, $env.variables);
});

const $u$$src$Compiler$TypeCheck$$inferUni = (($a, $b) => {
  const $3 = ({
    first: $a,
    second: $b,
  });
  return ((($3.first)[0] === "$Imm")
    ? $c$$src$Compiler$Ast$$Imm
    : ((($3.second)[0] === "$Imm")
      ? $c$$src$Compiler$Ast$$Imm
      : (((($3.first)[0] === "$Depends") && (($3.second)[0] === "$Depends"))
        ? ((() => {
          const $aId = ($3.first)[1];
          const $bId = ($3.second)[1];
          return $c$$src$Compiler$Ast$$Imm;
        }))()
        : ((($3.second)[0] === "$Depends")
          ? $b
          : (true
            ? $c$$src$Compiler$Ast$$Uni
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 618:4', (sp_toHuman)($3)))))));
});

const $u$$src$Compiler$TypeCheck$$doTry = (($env, $pos, $expectedRaw, $value, $caPatternsAndExpressions, $state) => {
  const $7 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $valueType = $7.second;
  const $typedValue = $7.first;
  const $8 = ((($0) => {
    return ($c$$src$List$$forReversed)($0, $caPatternsAndExpressions, (($11, $10) => {
      const $u = $11.first;
      const $pa = $11.second;
      const $exp = $11.third;
      const $uniX = $10.first;
      const $acc = $10.second;
      const $patternOut = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($env, $u, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_TryPattern, $patternOut.patternType, $valueType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($env, $pos, ({
        given: $valueType.uni,
        required: $u,
      }), $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $newEnv = ((() => {
        const $0 = $patternOut.env;
        return (Object.assign)({}, $0, ({
          context: $u$$src$Compiler$TypeCheck$$Context_TryBranch,
        }));
      }))();
      const $12 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($newEnv, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $expressionType = $12.second;
      const $typedExpression = $12.first;
      ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($newEnv, ($c$$src$Compiler$CanonicalAst$$expressionPos)($exp), $u$$src$Compiler$TypeCheck$$Why_TryExpression, $expectedRaw, $expressionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $uf = ($u$$src$Compiler$TypeCheck$$inferUni)($uniX, $expressionType.uni);
      const $l = (sp_cons)(({
        first: $patternOut.typedPattern,
        second: $typedExpression,
      }), $acc);
      return ({
        first: $uf,
        second: $l,
      });
    }));
  }))(({
    first: $c$$src$Compiler$Ast$$Uni,
    second: $c$$src$Core$$Nil,
  }));
  const $patternsAndExpressions = $8.second;
  const $uni = $8.first;
  return ([
    ({
      first: ($c$$src$Compiler$TypedAst$$Try)($pos, ({
        patternsAndExpressions: $patternsAndExpressions,
        value: $typedValue,
        valueType: $valueType,
      })),
      second: ({
        raw: $expectedRaw,
        uni: $uni,
      }),
    }),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferParam = (($env, $parIndex, $par, $state) => {
  return ([
    ((($par)[0] === "$ParameterRecycle")
      ? ((() => {
        const $pos = ($par)[1];
        const $name = ($par)[2];
        const $tyvarId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
        ((__re__ = (hash_insert)($state.boundTyvars, $tyvarId, null)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
        const $raw = ($c$$src$Compiler$TypedAst$$TypeVar)($tyvarId);
        const $instance = ({
          definedAt: $pos,
          freeTyvars: $c$$src$Dict$$empty,
          freeUnivars: $c$$src$Dict$$empty,
          type: ({
            raw: $raw,
            uni: $c$$src$Compiler$Ast$$Uni,
          }),
        });
        const $newEnv = ((() => {
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            variables: ($c$$src$Dict$$insert)(($c$$src$Compiler$Ast$$RefLocal)($name), $instance, $0.variables),
          }));
        }))();
        return ({
          first: ($c$$src$Compiler$TypedAst$$ParameterRecycle)($pos, $raw, $name),
          second: ($c$$src$Compiler$TypedAst$$ParRe)($raw),
          third: $newEnv,
        });
      }))()
      : ((($par)[0] === "$ParameterPattern")
        ? ((() => {
          const $uni = ($par)[1];
          const $pa = ($par)[2];
          const $out = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($env, $uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
          ($c$$src$Dict$$each)(($c$$src$Compiler$TypedAst$$typeTyvars)($out.patternType), (($tyvarId, _1) => {
            return ((__re__ = (hash_insert)($state.boundTyvars, $tyvarId, null)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
          }));
          const $full = ({
            raw: $out.patternType,
            uni: $uni,
          });
          return ({
            first: ($c$$src$Compiler$TypedAst$$ParameterPattern)($full, $out.typedPattern),
            second: ($c$$src$Compiler$TypedAst$$ParSp)($full),
            third: $out.env,
          });
        }))()
        : ((($par)[0] === "$ParameterPlaceholder")
          ? ((() => {
            const $num = ($par)[1];
            const $tyvarId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            ((__re__ = (hash_insert)($state.boundTyvars, $tyvarId, null)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
            const $raw = ($c$$src$Compiler$TypedAst$$TypeVar)($tyvarId);
            const $univarId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $type = ({
              raw: $raw,
              uni: ($c$$src$Compiler$Ast$$Depends)($univarId),
            });
            const $instance = ({
              definedAt: $c$$src$Compiler$Pos$$G,
              freeTyvars: $c$$src$Dict$$empty,
              freeUnivars: $c$$src$Dict$$empty,
              type: $type,
            });
            const $newEnv = ((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: ($c$$src$Dict$$insert)(($c$$src$Compiler$Ast$$RefPlaceholder)($num), $instance, $0.variables),
              }));
            }))();
            return ({
              first: ($c$$src$Compiler$TypedAst$$ParameterPlaceholder)($type, $num),
              second: ($c$$src$Compiler$TypedAst$$ParSp)($type),
              third: $newEnv,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 951:4', (sp_toHuman)($par))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferFn = (($env, $pos, $caPars, $body, $state) => {
  let $typedPars = (array_fromList)($c$$src$Core$$Nil);
  let $parTypes = (array_fromList)($c$$src$Core$$Nil);
  const $newEnv = ($c$$src$List$$indexedFor)($env, $caPars, (($index, $par, $envX) => {
    const $9 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferParam)($envX, $index, $par, $state)), ($state = (__re__)[1]), (__re__)[0]);
    const $envX1 = $9.third;
    const $parType = $9.second;
    const $typedPar = $9.first;
    ((__re__ = (array_push)($typedPars, $typedPar)), ($typedPars = (__re__)[1]), (__re__)[0]);
    ((__re__ = (array_push)($parTypes, $parType)), ($parTypes = (__re__)[1]), (__re__)[0]);
    return $envX1;
  }));
  const $6 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)(((() => {
    const $0 = $newEnv;
    return (Object.assign)({}, $0, ({
      context: ($u$$src$Compiler$TypeCheck$$Context_FnBody)($pos, $env.context),
    }));
  }))(), $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $bodyType = $6.second;
  const $typedBody = $6.first;
  const $type = ($c$$src$Compiler$TypedAst$$TypeFn)(((__re__ = (array_toList)($parTypes)), ($parTypes = (__re__)[1]), (__re__)[0]), $bodyType);
  const $exp = ($c$$src$Compiler$TypedAst$$Fn)($pos, ((__re__ = (array_toList)($typedPars)), ($typedPars = (__re__)[1]), (__re__)[0]), $typedBody, $bodyType);
  return ([
    ({
      first: $exp,
      second: ({
        raw: $type,
        uni: $c$$src$Compiler$Ast$$Uni,
      }),
    }),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferRecord = (($env, $pos, $maybeExt, $caAttrs, $state) => {
  const $taAttrs = ($c$$src$Dict$$map)((($name, $value) => {
    return ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        context: ($u$$src$Compiler$TypeCheck$$Context_Argument)($name, $0.context),
      }));
    }))(), $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }), $caAttrs);
  const $typedAttrs = ($c$$src$Dict$$map)((($k, $v) => {
    return ($c$$src$Tuple$$first)($v);
  }), $taAttrs);
  const $attrTypes = ($c$$src$Dict$$map)((($k, $6) => {
    const $t = $6.second;
    return $t.raw;
  }), $taAttrs);
  const $uni = ((($0) => {
    return ($c$$src$Dict$$for)($0, $taAttrs, (($k, $8, $u) => {
      const $full = $8.second;
      return ($u$$src$Compiler$TypeCheck$$inferUni)($full.uni, $u);
    }));
  }))($c$$src$Compiler$Ast$$Uni);
  return ([
    ((($maybeExt)[0] === "$Nothing")
      ? ({
        first: ($c$$src$Compiler$TypedAst$$Record)($pos, $c$$src$Maybe$$Nothing, $typedAttrs),
        second: ({
          raw: ($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, $attrTypes),
          uni: $uni,
        }),
      })
      : ((($maybeExt)[0] === "$Just")
        ? ((() => {
          const $caExt = ($maybeExt)[1];
          const $6 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $caExt, $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $extType = $6.second;
          const $typedExt = $6.first;
          const $finalType = ((() => {
            const $7 = $extType.raw;
            return (((($7)[0] === "$TypeRecord") && ((($7)[1])[0] === "$Nothing"))
              ? ((() => {
                const $fixedTypes = ($7)[2];
                ($c$$src$Dict$$each)($attrTypes, (($name, $valueType) => {
                  const $10 = ($c$$src$Dict$$get)($name, $fixedTypes);
                  return ((($10)[0] === "$Nothing")
                    ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordDoesNotHaveAttribute)($name), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : ((($10)[0] === "$Just")
                      ? ((() => {
                        const $ty = ($10)[1];
                        return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_Record, $ty, $valueType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1150:28', (sp_toHuman)($10))));
                }));
                return $extType.raw;
              }))()
              : (((($7)[0] === "$TypeRecord") && ((($7)[1])[0] === "$Just"))
                ? ((() => {
                  const $tyvarId = (($7)[1])[1];
                  const $extensionAttrTypes = ($7)[2];
                  const $8 = ($c$$src$Dict$$onlyBothOnly)($attrTypes, $extensionAttrTypes);
                  const $extensionOnly = $8.third;
                  const $both = $8.second;
                  const $expressionOnly = $8.first;
                  ($c$$src$Dict$$each)($both, (($name, $9) => {
                    const $inAttr = $9.first;
                    const $extAttr = $9.second;
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_Record, $inAttr, $extAttr, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }));
                  const $newExtId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                  return ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($newExtId), ($c$$src$Dict$$join)($attrTypes, $extensionOnly));
                }))()
                : ((($7)[0] === "$TypeVar")
                  ? ((() => {
                    const $id = ($7)[1];
                    const $ty = ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0])), $attrTypes);
                    ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_RecordExt, $extType.raw, $ty, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $ty;
                  }))()
                  : (true
                    ? ((() => {
                      ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $u$$src$Compiler$TypeCheck$$ErrorNotCompatibleWithRecord, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return $c$$src$Compiler$TypedAst$$TypeError;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1146:16', (sp_toHuman)($7))))));
          }))();
          return ({
            first: ($c$$src$Compiler$TypedAst$$Record)($pos, ($c$$src$Maybe$$Just)($typedExt), $typedAttrs),
            second: ({
              raw: $finalType,
              uni: ($u$$src$Compiler$TypeCheck$$inferUni)($uni, $extType.uni),
            }),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1136:4', (sp_toHuman)($maybeExt)))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferRecordAccess = (($env, $pos, $attrName, $inferredType, $state) => {
  return ([
    (((($inferredType)[0] === "$TypeRecord") && ((($inferredType)[1])[0] === "$Nothing"))
      ? ((() => {
        const $attrTypes = ($inferredType)[2];
        const $6 = ($c$$src$Dict$$get)($attrName, $attrTypes);
        return ((($6)[0] === "$Just")
          ? ((() => {
            const $type = ($6)[1];
            return $type;
          }))()
          : ((($6)[0] === "$Nothing")
            ? ((() => {
              ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordDoesNotHaveAttribute)($attrName), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return $c$$src$Compiler$TypedAst$$TypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1069:12', (sp_toHuman)($6))));
      }))()
      : (((($inferredType)[0] === "$TypeRecord") && ((($inferredType)[1])[0] === "$Just"))
        ? ((() => {
          const $tyvarId = (($inferredType)[1])[1];
          const $extensionAttrTypes = ($inferredType)[2];
          const $6 = ($c$$src$Dict$$get)($attrName, $extensionAttrTypes);
          return ((($6)[0] === "$Just")
            ? ((() => {
              const $type = ($6)[1];
              return $type;
            }))()
            : ((($6)[0] === "$Nothing")
              ? ((() => {
                const $newExtId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $newAttrType = ((__re__ = ($u$$src$Compiler$TypeCheck$$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $type = ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($newExtId), ($c$$src$Dict$$insert)($attrName, $newAttrType, $extensionAttrTypes));
                ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_RecordAccess, ($c$$src$Compiler$TypedAst$$TypeVar)($tyvarId), $type, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $newAttrType;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1080:12', (sp_toHuman)($6))));
        }))()
        : ((($inferredType)[0] === "$TypeVar")
          ? ((() => {
            const $id = ($inferredType)[1];
            const $newExtId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $newAttrType = ($c$$src$Compiler$TypedAst$$TypeVar)(((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]));
            const $type = ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($newExtId), ($c$$src$Dict$$ofOne)($attrName, $newAttrType));
            ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_RecordAccess, $inferredType, $type, $state)), ($state = (__re__)[1]), (__re__)[0]);
            return $newAttrType;
          }))()
          : (true
            ? ((() => {
              ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorTryingToAccessAttributeOfNonRecord)($attrName, $inferredType), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return $c$$src$Compiler$TypedAst$$TypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1066:4', (sp_toHuman)($inferredType)))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferExpression = (($env, $caExpression, $state) => {
  return ([
    ((($caExpression)[0] === "$LiteralNumber")
      ? ((() => {
        const $pos = ($caExpression)[1];
        const $n = ($caExpression)[2];
        return ({
          first: ($c$$src$Compiler$TypedAst$$LiteralNumber)($pos, $n),
          second: ({
            raw: $u$$src$Compiler$TypeCheck$$coreTypeNumber,
            uni: $c$$src$Compiler$Ast$$Uni,
          }),
        });
      }))()
      : ((($caExpression)[0] === "$LiteralText")
        ? ((() => {
          const $pos = ($caExpression)[1];
          const $text = ($caExpression)[2];
          return ({
            first: ($c$$src$Compiler$TypedAst$$LiteralText)($pos, $text),
            second: ({
              raw: $u$$src$Compiler$TypeCheck$$coreTypeText,
              uni: $c$$src$Compiler$Ast$$Uni,
            }),
          });
        }))()
        : ((($caExpression)[0] === "$Variable")
          ? ((() => {
            const $pos = ($caExpression)[1];
            const $ref = ($caExpression)[2];
            const $ty = ((() => {
              const $4 = ($u$$src$Compiler$TypeCheck$$getVariableByRef)($ref, $env);
              return ((($4)[0] === "$Nothing")
                ? ((() => {
                  ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return $u$$src$Compiler$TypeCheck$$fullTypeError;
                }))()
                : ((($4)[0] === "$Just")
                  ? ((() => {
                    const $var = ($4)[1];
                    const $t = ((__re__ = ($u$$src$Compiler$TypeCheck$$generalize)($env, $pos, $ref, $var, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $t;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 816:16', (sp_toHuman)($4))));
            }))();
            return ({
              first: ($c$$src$Compiler$TypedAst$$Variable)($pos, $ref),
              second: $ty,
            });
          }))()
          : ((($caExpression)[0] === "$Constructor")
            ? ((() => {
              const $pos = ($caExpression)[1];
              const $usr = ($caExpression)[2];
              const $ty = ((() => {
                const $4 = ($u$$src$Compiler$TypeCheck$$getConstructorByUsr)($usr, $env);
                return ((($4)[0] === "$Nothing")
                  ? ((() => {
                    ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $u$$src$Compiler$TypeCheck$$fullTypeError;
                  }))()
                  : ((($4)[0] === "$Just")
                    ? ((() => {
                      const $cons = ($4)[1];
                      return ((__re__ = ($u$$src$Compiler$TypeCheck$$generalize)($env, $pos, ($c$$src$Compiler$Ast$$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 834:16', (sp_toHuman)($4))));
              }))();
              return ({
                first: ($c$$src$Compiler$TypedAst$$Constructor)($pos, $usr),
                second: ((() => {
                  const $0 = $ty;
                  return (Object.assign)({}, $0, ({
                    uni: $c$$src$Compiler$Ast$$Uni,
                  }));
                }))(),
              });
            }))()
            : ((($caExpression)[0] === "$Fn")
              ? ((() => {
                const $pos = ($caExpression)[1];
                const $caPars = ($caExpression)[2];
                const $body = ($caExpression)[3];
                return ((__re__ = ($u$$src$Compiler$TypeCheck$$inferFn)($env, $pos, $caPars, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((($caExpression)[0] === "$Call")
                ? ((() => {
                  const $pos = ($caExpression)[1];
                  const $reference = ($caExpression)[2];
                  const $args = ($caExpression)[3];
                  return ((__re__ = ($u$$src$Compiler$TypeCheck$$doCall)($env, $pos, $c$$src$Maybe$$Nothing, $reference, $args, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : ((($caExpression)[0] === "$Record")
                  ? ((() => {
                    const $pos = ($caExpression)[1];
                    const $maybeExt = ($caExpression)[2];
                    const $attrs = ($caExpression)[3];
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$inferRecord)($env, $pos, $maybeExt, $attrs, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($caExpression)[0] === "$RecordAccess")
                    ? ((() => {
                      const $pos = ($caExpression)[1];
                      const $attrName = ($caExpression)[2];
                      const $recordExpression = ($caExpression)[3];
                      const $4 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $recordExpression, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $inferredType = $4.second;
                      const $typedExpr = $4.first;
                      return ({
                        first: ($c$$src$Compiler$TypedAst$$RecordAccess)($pos, $attrName, $typedExpr),
                        second: ((() => {
                          const $0 = $inferredType;
                          return (Object.assign)({}, $0, ({
                            raw: ((__re__ = ($u$$src$Compiler$TypeCheck$$inferRecordAccess)($env, $pos, $attrName, $0.raw, $state)), ($state = (__re__)[1]), (__re__)[0]),
                          }));
                        }))(),
                      });
                    }))()
                    : ((($caExpression)[0] === "$LetIn")
                      ? ((() => {
                        const $def = ($caExpression)[1];
                        const $rest = ($caExpression)[2];
                        const $4 = ((($0) => {
                          return ((__re__ = ($u$$src$Compiler$TypeCheck$$doDefinition)($c$$src$Compiler$Ast$$RefLocal, $env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        }))(({
                          directDeps: $c$$src$Dict$$empty,
                          maybeBody: ($c$$src$Maybe$$Just)($def.body),
                          pattern: $def.pattern,
                          uni: $def.uni,
                        }));
                        const $defEnv = $4.second;
                        const $typedDef = $4.first;
                        const $5 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($defEnv, $rest, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $restType = $5.second;
                        const $typedRest = $5.first;
                        return ({
                          first: ($c$$src$Compiler$TypedAst$$LetIn)($typedDef, $typedRest, $restType),
                          second: $restType,
                        });
                      }))()
                      : ((($caExpression)[0] === "$If")
                        ? ((() => {
                          const $pos = ($caExpression)[1];
                          const $condition = ($caExpression)[2].condition;
                          const $false = ($caExpression)[2].false;
                          const $true = ($caExpression)[2].true;
                          const $4 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: $u$$src$Compiler$TypeCheck$$Context_IfCondition,
                            }));
                          }))(), $condition, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $conditionType = $4.second;
                          const $typedCondition = $4.first;
                          ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_IfCondition, $u$$src$Compiler$TypeCheck$$coreTypeBool, $conditionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $5 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: $u$$src$Compiler$TypeCheck$$Context_IfTrue,
                            }));
                          }))(), $true, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $trueType = $5.second;
                          const $typedTrue = $5.first;
                          const $6 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: $u$$src$Compiler$TypeCheck$$Context_IfFalse,
                            }));
                          }))(), $false, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $falseType = $6.second;
                          const $typedFalse = $6.first;
                          ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_IfBranches, $trueType.raw, $falseType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $expression = ($c$$src$Compiler$TypedAst$$If)($pos, ({
                            condition: $typedCondition,
                            false: $typedFalse,
                            true: $typedTrue,
                          }));
                          const $uni = ($u$$src$Compiler$TypeCheck$$inferUni)($trueType.uni, $falseType.uni);
                          return ({
                            first: $expression,
                            second: ({
                              raw: $trueType.raw,
                              uni: $uni,
                            }),
                          });
                        }))()
                        : ((($caExpression)[0] === "$Try")
                          ? ((() => {
                            const $pos = ($caExpression)[1];
                            const $patternsAndExpressions = ($caExpression)[2].patternsAndExpressions;
                            const $value = ($caExpression)[2].value;
                            return ((__re__ = ($u$$src$Compiler$TypeCheck$$doTry)($env, $pos, ((__re__ = ($u$$src$Compiler$TypeCheck$$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]), $value, $patternsAndExpressions, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 806:4', (sp_toHuman)($caExpression))))))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$inferArgument = (($env, $arg, $state) => {
  return ([
    ((($arg)[0] === "$ArgumentExpression")
      ? ((() => {
        const $exp = ($arg)[1];
        const $4 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
        const $expType = $4.second;
        const $typedExp = $4.first;
        return ($c$$src$Compiler$TypedAst$$ArgumentExpression)($expType, $typedExp);
      }))()
      : ((($arg)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $pos = ($arg)[1];
          const $name = ($arg)[2];
          const $attrPath = ($arg)[3];
          const $ref = ($c$$src$Compiler$Ast$$RefLocal)($name);
          const $raw = ((() => {
            const $4 = ($u$$src$Compiler$TypeCheck$$getVariableByRef)($ref, $env);
            return ((($4)[0] === "$Nothing")
              ? ((() => {
                ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $c$$src$Compiler$TypedAst$$TypeError;
              }))()
              : ((($4)[0] === "$Just")
                ? ((() => {
                  const $var = ($4)[1];
                  return ((($0) => {
                    return ($c$$src$List$$for)($0, $attrPath, (($attrName, $tyAcc) => {
                      return ((__re__ = ($u$$src$Compiler$TypeCheck$$inferRecordAccess)($env, $pos, $attrName, $tyAcc, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }));
                  }))($var.type.raw);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1570:16', (sp_toHuman)($4))));
          }))();
          return ($c$$src$Compiler$TypedAst$$ArgumentRecycle)($pos, $raw, $attrPath, $name);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1557:4', (sp_toHuman)($arg)))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$doCall = (($env, $pos, $maybeExpectedType, $reference, $givenArgs, $state) => {
  const $7 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $reference, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $inferredReferenceType = $7.second;
  const $typedReference = $7.first;
  const $typedArguments = ((($0) => {
    return ($c$$src$List$$map)((($arg) => {
      return ((__re__ = ($u$$src$Compiler$TypeCheck$$inferArgument)($env, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
    }), $0);
  }))($givenArgs);
  const $toTypeArg = (($arg) => {
    return ((($arg)[0] === "$ArgumentExpression")
      ? ((() => {
        const $full = ($arg)[1];
        return ($c$$src$Compiler$TypedAst$$ParSp)($full);
      }))()
      : ((($arg)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $raw = ($arg)[2];
          return ($c$$src$Compiler$TypedAst$$ParRe)($raw);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1471:8', (sp_toHuman)($arg))));
  });
  const $expectedReturnType = ((() => {
    const $8 = $inferredReferenceType.raw;
    return ((($8)[0] === "$TypeFn")
      ? ((() => {
        const $parTypes = ($8)[1];
        const $outType = ($8)[2];
        const $given = ($c$$src$List$$length)($typedArguments);
        const $expected = ($c$$src$List$$length)($parTypes);
        return ((sp_not_equal)($expected, $given)
          ? ((() => {
            ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfArguments)(({
              expected: $expected,
              given: $given,
              reference: $reference,
            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return $u$$src$Compiler$TypeCheck$$fullTypeError;
          }))()
          : ((() => {
            ($c$$src$List$$indexedEach2)($typedArguments, $parTypes, (($index, $givenArg, $parType) => {
              const $12 = ({
                first: $givenArg,
                second: $parType,
              });
              return (((($12.first)[0] === "$ArgumentRecycle") && (($12.second)[0] === "$ParRe"))
                ? ((() => {
                  const $p = ($12.first)[1];
                  const $givenRaw = ($12.first)[2];
                  const $attrPath = ($12.first)[3];
                  const $name = ($12.first)[4];
                  const $inferredRaw = ($12.second)[1];
                  const $13 = ($u$$src$Compiler$TypeCheck$$getVariableByRef)(($c$$src$Compiler$Ast$$RefLocal)($name), $env);
                  return ((($13)[0] === "$Nothing")
                    ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $p, ($u$$src$Compiler$TypeCheck$$ErrorVariableNotFound)(($c$$src$Compiler$Ast$$RefLocal)($name)), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : ((($13)[0] === "$Just")
                      ? ((() => {
                        const $instance = ($13)[1];
                        ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($instance.type.uni, $c$$src$Compiler$Ast$$Uni), $env, $p, $u$$src$Compiler$TypeCheck$$ErrorShouldBeUnique, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, ($u$$src$Compiler$TypeCheck$$Why_Argument)($index), $givenRaw, $inferredRaw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1494:32', (sp_toHuman)($13))));
                }))()
                : (((($12.first)[0] === "$ArgumentExpression") && (($12.second)[0] === "$ParSp"))
                  ? ((() => {
                    const $givenFull = ($12.first)[1];
                    const $expr = ($12.first)[2];
                    const $inferredFull = ($12.second)[1];
                    ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($env, $pos, ({
                      given: $givenFull.uni,
                      required: $inferredFull.uni,
                    }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, ($u$$src$Compiler$TypeCheck$$Why_Argument)($index), $inferredFull.raw, $givenFull.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $u$$src$Compiler$TypeCheck$$ErrorUniquenessDoesNotMatchArgument, $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1491:24', (sp_toHuman)($12)))));
            }));
            return ((($maybeExpectedType)[0] === "$Nothing")
              ? $outType
              : ((($maybeExpectedType)[0] === "$Just")
                ? ((() => {
                  const $e = ($maybeExpectedType)[1];
                  ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($env, $pos, ({
                    given: $outType.uni,
                    required: $e.uni,
                  }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_Annotation, $outType.raw, $e.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return $e;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1514:20', (sp_toHuman)($maybeExpectedType))));
          }))());
      }))()
      : ((($8)[0] === "$TypeVar")
        ? ((() => {
          const $id = ($8)[1];
          const $returnType = ((($maybeExpectedType)[0] === "$Just")
            ? ((() => {
              const $e = ($maybeExpectedType)[1];
              return $e;
            }))()
            : ((($maybeExpectedType)[0] === "$Nothing")
              ? ({
                raw: ((__re__ = ($u$$src$Compiler$TypeCheck$$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]),
                uni: $c$$src$Compiler$Ast$$Imm,
              })
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1528:20', (sp_toHuman)($maybeExpectedType))));
          const $refTy = ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$List$$map)($toTypeArg, $typedArguments), $returnType);
          ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_CalledAsFunction, $refTy, $inferredReferenceType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
          return $returnType;
        }))()
        : ((($8)[0] === "$TypeError")
          ? $u$$src$Compiler$TypeCheck$$fullTypeError
          : (true
            ? ((() => {
              const $z = $8;
              ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorCallingANonFunction)($z), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return $u$$src$Compiler$TypeCheck$$fullTypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1476:8', (sp_toHuman)($8))))));
  }))();
  return ([
    ({
      first: ($c$$src$Compiler$TypedAst$$Call)($pos, $typedReference, $typedArguments),
      second: $expectedReturnType,
    }),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$checkExpression = (($env, $expectedType, $caExpression, $state) => {
  const $5 = ({
    first: $caExpression,
    second: $expectedType.raw,
  });
  return ([
    (((($5.first)[0] === "$LiteralNumber") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
      ? ((() => {
        const $pos = ($5.first)[1];
        const $n = ($5.first)[2];
        const $typeUsr = ($5.second)[1];
        ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($typeUsr, $u$$src$Compiler$CoreDefs$$numberDef.usr), $env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
        return ($c$$src$Compiler$TypedAst$$LiteralNumber)($pos, $n);
      }))()
      : (((($5.first)[0] === "$LiteralText") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
        ? ((() => {
          const $pos = ($5.first)[1];
          const $text = ($5.first)[2];
          const $typeUsr = ($5.second)[1];
          ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((sp_not_equal)($typeUsr, $u$$src$Compiler$CoreDefs$$textDef.usr), $env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
          return ($c$$src$Compiler$TypedAst$$LiteralText)($pos, $text);
        }))()
        : ((($5.first)[0] === "$Variable")
          ? ((() => {
            const $pos = ($5.first)[1];
            const $ref = ($5.first)[2];
            const $__bleh__ = ((() => {
              const $6 = ($u$$src$Compiler$TypeCheck$$getVariableByRef)($ref, $env);
              return ((($6)[0] === "$Nothing")
                ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((($6)[0] === "$Just")
                  ? ((() => {
                    const $var = ($6)[1];
                    const $full = ((__re__ = ($u$$src$Compiler$TypeCheck$$generalize)($env, $pos, $ref, $var, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($env, $pos, ({
                      given: $full.uni,
                      required: $expectedType.uni,
                    }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_Annotation, $full.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1275:16', (sp_toHuman)($6))));
            }))();
            return ($c$$src$Compiler$TypedAst$$Variable)($pos, $ref);
          }))()
          : (((($5.first)[0] === "$Constructor") && (($5.second)[0] === "$TypeExact"))
            ? ((() => {
              const $pos = ($5.first)[1];
              const $usr = ($5.first)[2];
              const $bleh = ((() => {
                const $6 = ($u$$src$Compiler$TypeCheck$$getConstructorByUsr)($usr, $env);
                return ((($6)[0] === "$Nothing")
                  ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0])
                  : ((($6)[0] === "$Just")
                    ? ((() => {
                      const $cons = ($6)[1];
                      const $full = ((__re__ = ($u$$src$Compiler$TypeCheck$$generalize)($env, $pos, ($c$$src$Compiler$Ast$$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_Annotation, $full.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1292:16', (sp_toHuman)($6))));
              }))();
              return ($c$$src$Compiler$TypedAst$$Constructor)($pos, $usr);
            }))()
            : (((($5.first)[0] === "$Fn") && (($5.second)[0] === "$TypeFn"))
              ? ((() => {
                const $pos = ($5.first)[1];
                const $pars = ($5.first)[2];
                const $body = ($5.first)[3];
                const $parTypes = ($5.second)[1];
                const $out = ($5.second)[2];
                return ((sp_not_equal)(($c$$src$List$$length)($pars), ($c$$src$List$$length)($parTypes))
                  ? ((() => {
                    ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, $u$$src$Compiler$TypeCheck$$ErrorWrongNumberOfParameters, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ($c$$src$Compiler$TypedAst$$Error)($pos);
                  }))()
                  : ((() => {
                    let $typedPars = (array_fromList)($c$$src$Core$$Nil);
                    let $parIndex = 0;
                    const $localEnv = ((($0) => {
                      return ($c$$src$List$$for)($0, ($c$$src$List$$map2)($c$$src$Tuple$$pair, $pars, $parTypes), (($8, $envX) => {
                        const $par = $8.first;
                        const $parType = $8.second;
                        const $9 = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkParameter)(((() => {
                          const $0 = $envX;
                          return (Object.assign)({}, $0, ({
                            context: ($u$$src$Compiler$TypeCheck$$Context_FnPar)(((__re__ = (basics_cloneUni)($parIndex)), ($parIndex = (__re__)[1]), (__re__)[0]), $0.context),
                          }));
                        }))(), $parType, $par, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $envX1 = $9.second;
                        const $typedPar = $9.first;
                        ((__re__ = (array_push)($typedPars, $typedPar)), ($typedPars = (__re__)[1]), (__re__)[0]);
                        ($parIndex += 1);
                        const $0 = $envX1;
                        return (Object.assign)({}, $0, ({
                          context: $envX.context,
                        }));
                      }));
                    }))($env);
                    const $typedBody = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)($localEnv, $out, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ($c$$src$Compiler$TypedAst$$Fn)($pos, ((__re__ = (array_toList)($typedPars)), ($typedPars = (__re__)[1]), (__re__)[0]), $typedBody, $out);
                  }))());
              }))()
              : ((($5.first)[0] === "$Call")
                ? ((() => {
                  const $pos = ($5.first)[1];
                  const $reference = ($5.first)[2];
                  const $args = ($5.first)[3];
                  return ($c$$src$Tuple$$first)(((__re__ = ($u$$src$Compiler$TypeCheck$$doCall)($env, $pos, ($c$$src$Maybe$$Just)($expectedType), $reference, $args, $state)), ($state = (__re__)[1]), (__re__)[0]));
                }))()
                : (((($5.first)[0] === "$Record") && (((($5.first)[2])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
                  ? ((() => {
                    const $pos = ($5.first)[1];
                    const $ext = (($5.first)[2])[1];
                    const $valueByName = ($5.first)[3];
                    const $typeByName = ($5.second)[2];
                    const $typedExt = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)($env, $expectedType, $ext, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    const $zzz = (($attrName, $attrExpr) => {
                      const $8 = ($c$$src$Dict$$get)($attrName, $typeByName);
                      return ((($8)[0] === "$Nothing")
                        ? ((() => {
                          ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordHasAttributesNotInAnnotation)(($c$$src$Core$$Cons)($attrName, $c$$src$Core$$Nil)), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          return ($c$$src$Tuple$$first)(((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $attrExpr, $state)), ($state = (__re__)[1]), (__re__)[0]));
                        }))()
                        : ((($8)[0] === "$Just")
                          ? ((() => {
                            const $attrType = ($8)[1];
                            const $fullAttrType = ({
                              raw: $attrType,
                              uni: $expectedType.uni,
                            });
                            return ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: ($u$$src$Compiler$TypeCheck$$Context_AttributeName)($attrName, $0.context),
                              }));
                            }))(), $fullAttrType, $attrExpr, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1349:20', (sp_toHuman)($8))));
                    });
                    const $typedValueByName = ($c$$src$Dict$$map)($zzz, $valueByName);
                    return ($c$$src$Compiler$TypedAst$$Record)($pos, ($c$$src$Maybe$$Just)($typedExt), $typedValueByName);
                  }))()
                  : (((($5.first)[0] === "$Record") && (((($5.first)[2])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
                    ? ((() => {
                      const $pos = ($5.first)[1];
                      const $valueByName = ($5.first)[3];
                      const $typeByName = ($5.second)[2];
                      const $6 = ($c$$src$Dict$$onlyBothOnly)($valueByName, $typeByName);
                      const $bOnly = $6.third;
                      const $both = $6.second;
                      const $aOnly = $6.first;
                      ((sp_not_equal)($aOnly, $c$$src$Dict$$empty)
                        ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordHasAttributesNotInAnnotation)(($c$$src$Dict$$keys)($aOnly)), $state)), ($state = (__re__)[1]), (__re__)[0])
                        : ((sp_not_equal)($bOnly, $c$$src$Dict$$empty)
                          ? ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorRecordIsMissingAttibutesInAnnotation)(($c$$src$Dict$$keys)($bOnly)), $state)), ($state = (__re__)[1]), (__re__)[0])
                          : null));
                      const $typedAttrs = ((($0) => {
                        return ($c$$src$Dict$$map)((($name, $8) => {
                          const $value = $8.first;
                          const $type = $8.second;
                          return ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)($env, ({
                            raw: $type,
                            uni: $expectedType.uni,
                          }), $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        }), $0);
                      }))($both);
                      return ($c$$src$Compiler$TypedAst$$Record)($pos, $c$$src$Maybe$$Nothing, $typedAttrs);
                    }))()
                    : ((($5.first)[0] === "$RecordAccess")
                      ? ((() => {
                        const $pos = ($5.first)[1];
                        const $attrName = ($5.first)[2];
                        const $exp = ($5.first)[3];
                        const $6 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($env, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $expressionType = $6.second;
                        const $typedExpression = $6.first;
                        const $newId = ((__re__ = ($u$$src$Compiler$TypeCheck$$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $requiredType = ((($0) => {
                          return ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)($newId), $0);
                        }))(((($0) => {
                          return ($c$$src$Dict$$ofOne)($attrName, $0);
                        }))($expectedType.raw));
                        ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_RecordAccess, $expressionType.raw, $requiredType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($env, $pos, ({
                          given: $expressionType.uni,
                          required: $expectedType.uni,
                        }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ($c$$src$Compiler$TypedAst$$RecordAccess)($pos, $attrName, $typedExpression);
                      }))()
                      : ((($5.first)[0] === "$LetIn")
                        ? ((() => {
                          const $def = ($5.first)[1];
                          const $rest = ($5.first)[2];
                          const $6 = ((($0) => {
                            return ((__re__ = ($u$$src$Compiler$TypeCheck$$doDefinition)($c$$src$Compiler$Ast$$RefLocal, $env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))(({
                            directDeps: $c$$src$Dict$$empty,
                            maybeBody: ($c$$src$Maybe$$Just)($def.body),
                            pattern: $def.pattern,
                            uni: $def.uni,
                          }));
                          const $defEnv = $6.second;
                          const $typedDef = $6.first;
                          const $typedRest = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)($defEnv, $expectedType, $rest, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          return ($c$$src$Compiler$TypedAst$$LetIn)($typedDef, $typedRest, $expectedType);
                        }))()
                        : ((($5.first)[0] === "$If")
                          ? ((() => {
                            const $pos = ($5.first)[1];
                            const $condition = ($5.first)[2].condition;
                            const $false = ($5.first)[2].false;
                            const $true = ($5.first)[2].true;
                            const $6 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: $u$$src$Compiler$TypeCheck$$Context_IfCondition,
                              }));
                            }))(), $condition, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $conditionType = $6.second;
                            const $typedCondition = $6.first;
                            ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($env, $pos, $u$$src$Compiler$TypeCheck$$Why_IfCondition, $u$$src$Compiler$TypeCheck$$coreTypeBool, $conditionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $typedTrue = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: $u$$src$Compiler$TypeCheck$$Context_IfTrue,
                              }));
                            }))(), $expectedType, $true, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $typedFalse = ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: $u$$src$Compiler$TypeCheck$$Context_IfFalse,
                              }));
                            }))(), $expectedType, $false, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ($c$$src$Compiler$TypedAst$$If)($pos, ({
                              condition: $typedCondition,
                              false: $typedFalse,
                              true: $typedTrue,
                            }));
                          }))()
                          : ((($5.first)[0] === "$Try")
                            ? ((() => {
                              const $pos = ($5.first)[1];
                              const $patternsAndExpressions = ($5.first)[2].patternsAndExpressions;
                              const $value = ($5.first)[2].value;
                              const $6 = ((__re__ = ($u$$src$Compiler$TypeCheck$$doTry)($env, $pos, $expectedType.raw, $value, $patternsAndExpressions, $state)), ($state = (__re__)[1]), (__re__)[0]);
                              const $fullType = $6.second;
                              const $typedExp = $6.first;
                              ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($env, $pos, ({
                                given: $fullType.uni,
                                required: $expectedType.uni,
                              }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                              return $typedExp;
                            }))()
                            : ((($5.second)[0] === "$TypeError")
                              ? ($c$$src$Compiler$TypedAst$$Error)(($c$$src$Compiler$CanonicalAst$$expressionPos)($caExpression))
                              : (true
                                ? ((() => {
                                  const $pos = ($c$$src$Compiler$CanonicalAst$$expressionPos)($caExpression);
                                  ((__re__ = ($u$$src$Compiler$TypeCheck$$addError)($env, $pos, ($u$$src$Compiler$TypeCheck$$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  return ($c$$src$Compiler$TypedAst$$Error)($pos);
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1261:4', (sp_toHuman)($5)))))))))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$doDefinition = (($nameToRef, $baseEnv, $def, $state) => {
  let $parentBoundTyvars = ((__re__ = (basics_cloneUni)($state.boundTyvars)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
  const $patternOut = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferPattern)($baseEnv, $def.uni, $def.pattern, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $localEnv = ((() => {
    const $0 = $patternOut.env;
    return (Object.assign)({}, $0, ({
      context: ($u$$src$Compiler$TypeCheck$$Context_LetInBody)(($c$$src$Dict$$keys)(($c$$src$Compiler$TypedAst$$patternNames)($patternOut.typedPattern))),
    }));
  }))();
  const $5 = ((() => {
    const $6 = $def.maybeBody;
    return ((($6)[0] === "$Nothing")
      ? ({
        first: ($c$$src$Compiler$TypedAst$$LiteralText)($c$$src$Compiler$Pos$$N, "native"),
        second: ({
          raw: $patternOut.patternType,
          uni: $def.uni,
        }),
      })
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $body = ($6)[1];
          const $7 = $patternOut.maybeFullAnnotation;
          return ((($7)[0] === "$Just")
            ? ((() => {
              const $annotation = ($7)[1];
              const $raw = ((__re__ = ($u$$src$Compiler$TypeCheck$$translateAnnotationType)($localEnv, $state, $annotation.raw)), ($state = (__re__)[1]), (__re__)[0]);
              const $full = ({
                raw: $raw,
                uni: $def.uni,
              });
              return ({
                first: ((__re__ = ($u$$src$Compiler$TypeCheck$$checkExpression)($localEnv, $full, $body, $state)), ($state = (__re__)[1]), (__re__)[0]),
                second: $full,
              });
            }))()
            : ((($7)[0] === "$Nothing")
              ? ((() => {
                const $8 = ((__re__ = ($u$$src$Compiler$TypeCheck$$inferExpression)($localEnv, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
                const $inferredType = $8.second;
                const $typed = $8.first;
                const $pos = ($c$$src$Compiler$CanonicalAst$$patternPos)($def.pattern);
                ((__re__ = ($u$$src$Compiler$TypeCheck$$addEquality)($localEnv, $pos, $u$$src$Compiler$TypeCheck$$Why_LetIn, $patternOut.patternType, $inferredType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                ((__re__ = ($u$$src$Compiler$TypeCheck$$checkUni)($localEnv, $pos, ({
                  given: $inferredType.uni,
                  required: $def.uni,
                }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ({
                  first: $typed,
                  second: $inferredType,
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 673:16', (sp_toHuman)($7))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 667:8', (sp_toHuman)($6))));
  }))();
  const $bodyType = $5.second;
  const $typedBody = $5.first;
  const $defType = ({
    raw: ((__re__ = ($u$$src$Compiler$TypeCheck$$applyAllSubs)($state, $bodyType.raw)), ($state = (__re__)[1]), (__re__)[0]),
    uni: $def.uni,
  });
  const $freeUnivars = ((($0) => {
    return ($c$$src$Dict$$for)($c$$src$Dict$$empty, $0, (($annotatedId, _1, $acc) => {
      const $10 = ($c$$src$Dict$$get)($annotatedId, $localEnv.annotatedUnivarsByOriginalId);
      return ((($10)[0] === "$Nothing")
        ? $acc
        : ((($10)[0] === "$Just")
          ? ((() => {
            const $newId = ($10)[1];
            return ($c$$src$Dict$$insert)($newId, ({
              annotatedId: $annotatedId,
            }), $acc);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 711:12', (sp_toHuman)($10))));
    }));
  }))(((($0) => {
    return ($c$$src$List$$for)($c$$src$Dict$$empty, $0, (($annotation, $acc) => {
      return ($c$$src$Dict$$join)($annotation.univars, $acc);
    }));
  }))(((($0) => {
    return ($c$$src$List$$filterMap)((($entry) => {
      return $entry.maybeAnnotation;
    }), $0);
  }))(($c$$src$Compiler$CanonicalAst$$patternNames)($def.pattern))));
  const $freeTyvars = ((() => {
    const $allBindableTyvarsIn = (($tyvarId) => {
      const $7 = ((__re__ = (hash_get)($state.tyvarSubs, $tyvarId)), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
      return ((($7)[0] === "$Nothing")
        ? $c$$src$Set$$empty
        : ((($7)[0] === "$Just")
          ? ((() => {
            const $raw = ($7)[1];
            return ($c$$src$Dict$$map)((($k, $v) => {
              return null;
            }), ($c$$src$Compiler$TypedAst$$typeTyvars)($raw));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 721:12', (sp_toHuman)($7))));
    });
    const $resolvedParentBoundTyvars = ((__re__ = ($c$$src$Hash$$for_)($c$$src$Set$$empty, $parentBoundTyvars, (($parentTyvar, _1, $set) => {
      return ((($0) => {
        return ($c$$src$Set$$for)($0, ($allBindableTyvarsIn)($parentTyvar), $c$$src$Set$$insert);
      }))(((($0) => {
        return ($c$$src$Set$$insert)($parentTyvar, $0);
      }))($set));
    }))), ($parentBoundTyvars = (__re__)[1]), (__re__)[0]);
    const $tyvarAnnotatedNameByTyvarId = ($c$$src$Dict$$for)($c$$src$Dict$$empty, $localEnv.annotatedTyvarsByName, (($name, $tyvarId, $acc) => {
      return ($c$$src$Dict$$insert)($tyvarId, $name, $acc);
    }));
    return ((($0) => {
      return ($c$$src$Dict$$for)($c$$src$Dict$$empty, $0, (($id, _1, $acc) => {
        return (($c$$src$Set$$member)($id, $resolvedParentBoundTyvars)
          ? $acc
          : ((($0) => {
            return ($c$$src$Dict$$insert)($id, $0, $acc);
          }))(((() => {
            const $10 = ($c$$src$Dict$$get)($id, $tyvarAnnotatedNameByTyvarId);
            return ((($10)[0] === "$Nothing")
              ? ({
                maybeAnnotated: $c$$src$Maybe$$Nothing,
              })
              : ((($10)[0] === "$Just")
                ? ((() => {
                  const $name = ($10)[1];
                  return ({
                    maybeAnnotated: ($c$$src$Maybe$$Just)(({
                      allowFunctions: true,
                      name: $name,
                    })),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 740:16', (sp_toHuman)($10))));
          }))()));
      }));
    }))(($c$$src$Compiler$TypedAst$$typeTyvars)($defType.raw));
  }))();
  const $caNames = ((($0) => {
    return ($c$$src$List$$indexBy)((($e) => {
      return $e.name;
    }), $0);
  }))(($c$$src$Compiler$CanonicalAst$$patternNames)($def.pattern));
  const $instance = (($name, $6) => {
    const $pos = $6.pos;
    const $unresolvedType = $6.type;
    const $type = ((() => {
      const $0 = $unresolvedType;
      return (Object.assign)({}, $0, ({
        raw: ((__re__ = ($u$$src$Compiler$TypeCheck$$applyAllSubs)($state, $0.raw)), ($state = (__re__)[1]), (__re__)[0]),
      }));
    }))();
    const $typeTyvars = ($c$$src$Compiler$TypedAst$$typeTyvars)($type.raw);
    const $actualTyvars = ($c$$src$Dict$$filter)((($k, $v) => {
      return ($c$$src$Dict$$member)($k, $typeTyvars);
    }), $freeTyvars);
    const $tryAsStillBreaksIfUsedImperatively = ((() => {
      const $8 = ($c$$src$Dict$$get)($name, $caNames);
      return (((($8)[0] === "$Just") && ((($8)[1].maybeAnnotation)[0] === "$Just"))
        ? ((() => {
          const $annotation = (($8)[1].maybeAnnotation)[1];
          const $p = ($8)[1].pos;
          return ((__re__ = ($u$$src$Compiler$TypeCheck$$addErrorIf)((($c$$src$Dict$$size)($annotation.tyvars) > ($c$$src$Dict$$size)($actualTyvars)), $localEnv, $p, ($u$$src$Compiler$TypeCheck$$ErrorTyvarNotIndependent)($name), $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : (true
          ? null
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 768:12', (sp_toHuman)($8))));
    }))();
    return ({
      definedAt: $pos,
      freeTyvars: $actualTyvars,
      freeUnivars: $freeUnivars,
      type: $type,
    });
  });
  const $variables = ((($0) => {
    return ($c$$src$Dict$$for)($0, ($c$$src$Compiler$TypedAst$$patternNames)($patternOut.typedPattern), (($name, $stuff, $vars) => {
      return ($c$$src$Dict$$insert)(($nameToRef)($name), ($instance)($name, $stuff), $vars);
    }));
  }))($patternOut.env.variables);
  return ([
    ({
      first: ({
        body: $typedBody,
        directDeps: $def.directDeps,
        freeTyvars: $freeTyvars,
        freeUnivars: $freeUnivars,
        isFullyAnnotated: (sp_not_equal)($patternOut.maybeFullAnnotation, $c$$src$Maybe$$Nothing),
        native: (sp_equal)($def.maybeBody, $c$$src$Maybe$$Nothing),
        pattern: $patternOut.typedPattern,
        type: $defType,
      }),
      second: ((() => {
        const $0 = $baseEnv;
        return (Object.assign)({}, $0, ({
          variables: $variables,
        }));
      }))(),
    }),
    $state,
  ]);
});

const $u$$src$Compiler$TypeCheck$$doRootDefinition = (($lastUnificationVarId, $errors, $usr, $envRaw, $def) => {
  const $env0 = ((() => {
    const $0 = $envRaw;
    return (Object.assign)({}, $0, ({
      currentRootUsr: $usr,
    }));
  }))();
  let $state = ($u$$src$Compiler$TypeCheck$$initState)(((__re__ = (basics_cloneUni)($lastUnificationVarId)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  const $6 = $usr;
  const $umr = ($6)[1];
  const $nameToRef = (($name) => {
    return ($c$$src$Compiler$Ast$$RefGlobal)(($c$$src$Compiler$Meta$$USR)($umr, $name));
  });
  (sp_benchStart)(null);
  const $7 = ((($0) => {
    return ((__re__ = ($u$$src$Compiler$TypeCheck$$doDefinition)($nameToRef, $env0, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }))(({
    directDeps: $def.directDeps,
    maybeBody: $def.maybeBody,
    pattern: ($c$$src$Compiler$CanonicalAst$$PatternAny)($def.namePos, ($c$$src$Maybe$$Just)($def.name), $def.maybeAnnotation),
    uni: $c$$src$Compiler$Ast$$Imm,
  }));
  const $env1 = $7.second;
  const $typedDef = $7.first;
  (sp_benchStop)("type inference");
  (sp_benchStart)(null);
  const $subsAsFns = ({
    ty: (($tyvarId) => {
      return ((__re__ = (hash_get)($state.tyvarSubs, $tyvarId)), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
    }),
    uni: (($univarId) => {
      return ((__re__ = (hash_get)($state.univarSubs, $univarId)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
    }),
  });
  const $resolvedValueDef = ($c$$src$Compiler$TypedAst$$resolveValueDef)($subsAsFns, $typedDef);
  (sp_benchStop)("def resolution");
  ($lastUnificationVarId = ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  ((__re__ = (array_each)($state.errors, (($err) => {
    return ((__re__ = (array_push)($errors, $err)), ($errors = (__re__)[1]), (__re__)[0]);
  }))), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    ((($0) => {
      return ((__re__ = ($u$$src$Compiler$TypeCheck$$addInstance)($lastUnificationVarId, $errors, $umr, $def, $0)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
    }))(((() => {
      const $0 = $env1;
      return (Object.assign)({}, $0, ({
        reversedRootValueDefs: ($c$$src$Core$$Cons)(({
          first: $usr,
          second: $resolvedValueDef,
        }), $0.reversedRootValueDefs),
      }));
    }))()),
    $lastUnificationVarId,
    $errors,
  ]);
});

const $u$$src$Compiler$LazyBuild$$typecheckDefinition = (($state, $errors, $lastUnificationVarId, $usr, $env0) => {
  const $6 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
  return ([
    ((($6)[0] === "$Nothing")
      ? (sp_todo)(("compiler bug, missing value usr" + (sp_toHuman)($usr)))
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $def = ($6)[1].def;
          const $deps = ($6)[1].deps;
          return ((($def)[0] === "$ValueDef")
            ? ((() => {
              const $valueDef = ($def)[1];
              return ((__re__ = ($u$$src$Compiler$TypeCheck$$doRootDefinition)($lastUnificationVarId, $errors, $usr, $env0, $valueDef)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
            }))()
            : ((($def)[0] === "$ConstructorDef")
              ? ((() => {
                const $constructorDef = ($def)[1];
                return ((__re__ = ($u$$src$Compiler$TypeCheck$$addConstructorToGlobalEnv)($errors, $constructorDef.name, $constructorDef, $env0)), ($errors = (__re__)[1]), (__re__)[0]);
              }))()
              : (true
                ? $env0
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 155:12', (sp_toHuman)($def)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 149:4', (sp_toHuman)($6)))),
    $state,
    $errors,
    $lastUnificationVarId,
  ]);
});

const $u$$src$Compiler$MakeEmittable$$mkEnv = (($2, $modulesByUmr) => {
  const $umr = ($2)[1];
  const $name = ($2)[2];
  return ({
    genVarCounter: 0,
    module: ((() => {
      const $3 = ($c$$src$Dict$$get)($umr, $modulesByUmr);
      return ((($3)[0] === "$Just")
        ? ((() => {
          const $m = ($3)[1];
          return $m;
        }))()
        : ((($3)[0] === "$Nothing")
          ? (sp_todo)(("compiler bug: no module for " + $name))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 12:10', (sp_toHuman)($3))));
    }))(),
  });
});

const $u$$src$Compiler$Error$$positionToLineAndColumn = (($s, $index) => {
  const $before = (text_slice)(0, $index, $s);
  const $lines = (text_split)("\n", $before);
  const $lineNumber = ($c$$src$List$$length)($lines);
  const $colNumber = ((($0) => {
    return ($c$$src$Maybe$$withDefault)(0, $0);
  }))(((($0) => {
    return ($c$$src$Maybe$$map)(text_length, $0);
  }))(($c$$src$List$$last)($lines)));
  return ({
    col: $colNumber,
    line: $lineNumber,
  });
});

const $u$$src$Compiler$Error$$highlightSplit = (($h, $x) => {
  const $3 = $x;
  const $lines = $3.second;
  const $words = $3.first;
  return ((($h)[0] === "$HighlightWord")
    ? ((() => {
      const $colEnd = ($h)[1].colEnd;
      const $colStart = ($h)[1].colStart;
      const $line = ($h)[1].line;
      return ({
        first: ($c$$src$Dict$$insert)($line, ({
          first: $colStart,
          second: $colEnd,
        }), $words),
        second: $lines,
      });
    }))()
    : ((($h)[0] === "$HighlightBlock")
      ? ((() => {
        const $lineEnd = ($h)[1].lineEnd;
        const $lineStart = ($h)[1].lineStart;
        return ({
          first: $words,
          second: ($c$$src$List$$for)($lines, ($c$$src$List$$range)($lineStart, $lineEnd), $c$$src$Set$$insert),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 129:4', (sp_toHuman)($h))));
});

const $u$$src$Compiler$Error$$formatSeparator = "$|$|$";

const $u$$src$Compiler$Error$$formatSuffix = "$`$`$";

const $u$$src$Compiler$Error$$formatWrap = (($fmtName, $text) => {
  return ($u$$src$Compiler$Error$$formatSeparator + ($fmtName + ($u$$src$Compiler$Error$$formatSuffix + ($text + $u$$src$Compiler$Error$$formatSeparator))));
});

const $u$$src$Compiler$Error$$warn = (($0) => {
  return ($u$$src$Compiler$Error$$formatWrap)("warning", $0);
});

const $u$$src$Compiler$Error$$fmtBlock = (($start, $highlights, $ls) => {
  const $4 = ($c$$src$List$$for)(({
    first: $c$$src$Dict$$empty,
    second: $c$$src$Set$$empty,
  }), $highlights, $u$$src$Compiler$Error$$highlightSplit);
  const $highlightedLines = $4.second;
  const $highlightedWords = $4.first;
  const $pad = (text_length)((text_fromNumber)(($start + ($c$$src$List$$length)($ls))));
  const $wordHighlight = (($lineNumber) => {
    const $6 = ($c$$src$Dict$$get)($lineNumber, $highlightedWords);
    return ((($6)[0] === "$Nothing")
      ? ""
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $s = ($6)[1].first;
          const $e = ($6)[1].second;
          return ("\n" + (($c$$src$Text$$repeat)($pad, " ") + ("   " + (($c$$src$Text$$repeat)(($s - 1), " ") + ($u$$src$Compiler$Error$$warn)(($c$$src$Text$$repeat)(($c$$src$Basics$$max)(1, ($e - $s)), "^"))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 146:8', (sp_toHuman)($6))));
  });
  const $lineDem = (($lineIndex) => {
    return (($c$$src$Set$$member)($lineIndex, $highlightedLines)
      ? ($u$$src$Compiler$Error$$warn)(" > ")
      : " | ");
  });
  const $fmtLine = (($i, $line) => {
    const $index = ($i + $start);
    const $s = ((($0) => {
      return ($c$$src$Text$$padLeft)($pad, " ", $0);
    }))((text_fromNumber)($index));
    return ($s + (($lineDem)($index) + ($line + ($wordHighlight)($index))));
  });
  return ((($s) => {
    return ($s + "\n");
  }))(((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(((($0) => {
    return ($c$$src$List$$indexedMap)($fmtLine, $0);
  }))($ls)));
});

const $u$$src$Compiler$Error$$showCodeBlock = (($code, $start, $end) => {
  return (($end.line < 0)
    ? ""
    : ((() => {
      const $highlight = ((sp_not_equal)($start.line, $end.line)
        ? ($u$$src$Compiler$Error$$HighlightBlock)(({
          lineEnd: $end.line,
          lineStart: $start.line,
        }))
        : ($u$$src$Compiler$Error$$HighlightWord)(({
          colEnd: $end.col,
          colStart: $start.col,
          line: $start.line,
        })));
      const $extraLines = 2;
      const $lines = (text_split)("\n", $code);
      const $maxLines = ($c$$src$List$$length)($lines);
      const $startLine = ($c$$src$Basics$$clamp)(0, ($maxLines - 1), ($start.line - ($extraLines - 1)));
      const $endLine = ($c$$src$Basics$$clamp)(0, ($maxLines - 1), ($end.line + $extraLines));
      const $size = ($c$$src$Basics$$max)(1, ($endLine - $startLine));
      return ((($0) => {
        return ($u$$src$Compiler$Error$$fmtBlock)(($startLine + 1), ($c$$src$Core$$Cons)($highlight, $c$$src$Core$$Nil), $0);
      }))(((($0) => {
        return ($c$$src$List$$take)($size, $0);
      }))(((($0) => {
        return ($c$$src$List$$drop)($startLine, $0);
      }))($lines)));
    }))());
});

const $u$$src$Compiler$Error$$posToHuman = (($mod, $pos) => {
  const $noBlock = (($loc) => {
    return ({
      block: "",
      location: $loc,
    });
  });
  return ((($pos)[0] === "$P")
    ? ((() => {
      const $startAsInt = ($pos)[1];
      const $endAsInt = ($pos)[2];
      const $start = ($u$$src$Compiler$Error$$positionToLineAndColumn)($mod.content, $startAsInt);
      const $end = ($u$$src$Compiler$Error$$positionToLineAndColumn)($mod.content, $endAsInt);
      return ({
        block: ($u$$src$Compiler$Error$$showCodeBlock)($mod.content, $start, $end),
        location: ($mod.fsPath + (" " + ((text_fromNumber)($start.line) + (":" + (text_fromNumber)($start.col))))),
      });
    }))()
    : ((($pos)[0] === "$End")
      ? ((() => {
        const $end = ($u$$src$Compiler$Error$$positionToLineAndColumn)($mod.content, ((text_length)($mod.content) - 1));
        const $start = ({
          col: 0,
          line: ($end.line - 8),
        });
        return ({
          block: ($u$$src$Compiler$Error$$showCodeBlock)($mod.content, $start, $end),
          location: ($mod.fsPath + (" " + ((text_fromNumber)($end.line) + ":0 (end of file)"))),
        });
      }))()
      : ((($pos)[0] === "$N")
        ? ($noBlock)("<native code>")
        : ((($pos)[0] === "$S")
          ? ($noBlock)("<the location information has been stripped>")
          : ((($pos)[0] === "$T")
            ? ($noBlock)("<defined in test modules>")
            : ((($pos)[0] === "$I")
              ? ((() => {
                const $n = ($pos)[1];
                return ($noBlock)(("<inferred " + ((text_fromNumber)($n) + ">")));
              }))()
              : ((($pos)[0] === "$G")
                ? ($noBlock)("<generated>")
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 230:4', (sp_toHuman)($pos)))))))));
});

const $u$$src$Compiler$MakeEmittable$$generateName = (($env) => {
  return ({
    first: (text_fromNumber)(($env.genVarCounter + 1)),
    second: ((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        genVarCounter: (1 + $0.genVarCounter),
      }));
    }))(),
  });
});

const $u$$src$Compiler$MakeEmittable$$pickMainName = (($pattern) => {
  return (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Just"))
    ? ((() => {
      const $pos = ($pattern)[1];
      const $name = (($pattern)[2].maybeName)[1];
      const $type = ($pattern)[2].type;
      return ($u$$src$Compiler$MakeEmittable$$TrivialPattern)($name, $type);
    }))()
    : (true
      ? ((sp_not_equal)(($c$$src$Compiler$TypedAst$$patternNames)($pattern), $c$$src$Dict$$empty)
        ? $u$$src$Compiler$MakeEmittable$$GenerateName
        : $u$$src$Compiler$MakeEmittable$$NoNamedVariables)
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 35:4', (sp_toHuman)($pattern))));
});

const $u$$src$Compiler$MakeEmittable$$testPattern = (($pattern, $valueToTest, $accum) => {
  return ((($pattern)[0] === "$PatternAny")
    ? $accum
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $text = ($pattern)[2];
        return (sp_cons)(($c$$src$Compiler$EmittableAst$$ShallowEqual)(($c$$src$Compiler$EmittableAst$$LiteralText)($text), $valueToTest), $accum);
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $num = ($pattern)[2];
          return (sp_cons)(($c$$src$Compiler$EmittableAst$$ShallowEqual)(($c$$src$Compiler$EmittableAst$$LiteralNumber)($num), $valueToTest), $accum);
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $usr = ($pattern)[2];
            const $pas = ($pattern)[3];
            return ((($0) => {
              return ($c$$src$List$$indexedFor)($0, $pas, (($index, $argPattern, $a) => {
                return ($u$$src$Compiler$MakeEmittable$$testPattern)($argPattern, ($c$$src$Compiler$EmittableAst$$ConstructorAccess)($index, $valueToTest), $a);
              }));
            }))((sp_cons)(($c$$src$Compiler$EmittableAst$$IsConstructor)($usr, $valueToTest), $accum));
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $attrs = ($pattern)[2];
              return ((($0) => {
                return ($c$$src$Dict$$for)($0, $attrs, (($name, $6, $a) => {
                  const $pa = $6.first;
                  const $type = $6.second;
                  return ($u$$src$Compiler$MakeEmittable$$testPattern)($pa, ($c$$src$Compiler$EmittableAst$$RecordAccess)($name, $valueToTest), $a);
                }));
              }))($accum);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 86:4', (sp_toHuman)($pattern)))))));
});

const $u$$src$Compiler$MakeEmittable$$translateArgAndType = (($env, $taArg) => {
  return ((($taArg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $fullType = ($taArg)[1];
      const $exp = ($taArg)[2];
      return ($c$$src$Compiler$EmittableAst$$ArgumentSpend)($fullType, ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $exp));
    }))()
    : ((($taArg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $pos = ($taArg)[1];
        const $rawType = ($taArg)[2];
        const $attrPath = ($taArg)[3];
        const $name = ($taArg)[4];
        return ($c$$src$Compiler$EmittableAst$$ArgumentRecycle)($rawType, $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 149:4', (sp_toHuman)($taArg))));
});

const $u$$src$Compiler$MakeEmittable$$translatePatternRec = (($pattern, $accessExpr, $accum) => {
  return (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Nothing"))
    ? ((() => {
      const $type = ($pattern)[2].type;
      return $accum;
    }))()
    : (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $name = (($pattern)[2].maybeName)[1];
        const $type = ($pattern)[2].type;
        return (sp_cons)(({
          first: $type,
          second: $name,
          third: $accessExpr,
        }), $accum);
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? $accum
        : ((($pattern)[0] === "$PatternLiteralText")
          ? $accum
          : ((($pattern)[0] === "$PatternConstructor")
            ? ((() => {
              const $path = ($pattern)[2];
              const $pas = ($pattern)[3];
              return ((($0) => {
                return ($c$$src$List$$indexedFor)($0, $pas, (($index, $pa, $a) => {
                  return ($u$$src$Compiler$MakeEmittable$$translatePatternRec)($pa, ($c$$src$Compiler$EmittableAst$$ConstructorAccess)($index, $accessExpr), $a);
                }));
              }))($accum);
            }))()
            : ((($pattern)[0] === "$PatternRecord")
              ? ((() => {
                const $attrs = ($pattern)[2];
                return ((($0) => {
                  return ($c$$src$Dict$$for)($0, $attrs, (($name, $6, $a) => {
                    const $pa = $6.first;
                    const $type = $6.second;
                    return ($u$$src$Compiler$MakeEmittable$$translatePatternRec)($pa, ($c$$src$Compiler$EmittableAst$$RecordAccess)($name, $accessExpr), $a);
                  }));
                }))($accum);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 59:4', (sp_toHuman)($pattern))))))));
});

const $u$$src$Compiler$MakeEmittable$$translatePattern = (($pattern, $accessExpr) => {
  return ($u$$src$Compiler$MakeEmittable$$translatePatternRec)($pattern, $accessExpr, $c$$src$Core$$Nil);
});

const $u$$src$Compiler$MakeEmittable$$translateParameter = (($env, $bodyAcc, $param) => {
  return ((($param)[0] === "$ParameterRecycle")
    ? ((() => {
      const $pos = ($param)[1];
      const $rawType = ($param)[2];
      const $name = ($param)[3];
      return ({
        first: $bodyAcc,
        second: ({
          first: true,
          second: ($c$$src$Maybe$$Just)($name),
        }),
      });
    }))()
    : ((($param)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $fullType = ($param)[1];
        const $n = ($param)[2];
        return ({
          first: $bodyAcc,
          second: ({
            first: false,
            second: ($c$$src$Maybe$$Just)((text_fromNumber)($n)),
          }),
        });
      }))()
      : ((($param)[0] === "$ParameterPattern")
        ? ((() => {
          const $fullType = ($param)[1];
          const $pa = ($param)[2];
          const $4 = ($u$$src$Compiler$MakeEmittable$$pickMainName)($pa);
          return ((($4)[0] === "$NoNamedVariables")
            ? ({
              first: $bodyAcc,
              second: ({
                first: false,
                second: $c$$src$Maybe$$Nothing,
              }),
            })
            : ((($4)[0] === "$TrivialPattern")
              ? ((() => {
                const $argName = ($4)[1];
                const $type = ($4)[2];
                return ({
                  first: $bodyAcc,
                  second: ({
                    first: false,
                    second: ($c$$src$Maybe$$Just)($argName),
                  }),
                });
              }))()
              : ((($4)[0] === "$GenerateName")
                ? ((() => {
                  const $5 = ($u$$src$Compiler$MakeEmittable$$generateName)($env);
                  const $newEnv = $5.second;
                  const $mainName = $5.first;
                  const $namesAndExpressions = ($u$$src$Compiler$MakeEmittable$$translatePattern)($pa, ($c$$src$Compiler$EmittableAst$$Variable)(($c$$src$Compiler$Ast$$RefLocal)($mainName)));
                  const $wrapWithArgumentLetIn = (($7, $inExpression) => {
                    const $type = $7.first;
                    const $varName = $7.second;
                    const $letExpression = $7.third;
                    return ($c$$src$Compiler$EmittableAst$$LetIn)(({
                      inExpression: $inExpression,
                      letExpression: $letExpression,
                      maybeName: ($c$$src$Maybe$$Just)($varName),
                      type: $type,
                    }));
                  });
                  return ({
                    first: ($c$$src$List$$for)($bodyAcc, $namesAndExpressions, $wrapWithArgumentLetIn),
                    second: ({
                      first: false,
                      second: ($c$$src$Maybe$$Just)($mainName),
                    }),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 119:12', (sp_toHuman)($4)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 110:4', (sp_toHuman)($param)))));
});

const $u$$src$Compiler$MakeEmittable$$translateExpression = (($env, $expression) => {
  return ((($expression)[0] === "$LiteralNumber")
    ? ((() => {
      const $num = ($expression)[2];
      return ($c$$src$Compiler$EmittableAst$$LiteralNumber)($num);
    }))()
    : ((($expression)[0] === "$LiteralText")
      ? ((() => {
        const $text = ($expression)[2];
        return ($c$$src$Compiler$EmittableAst$$LiteralText)($text);
      }))()
      : ((($expression)[0] === "$Variable")
        ? ((() => {
          const $ref = ($expression)[2];
          return ($c$$src$Compiler$EmittableAst$$Variable)($ref);
        }))()
        : ((($expression)[0] === "$Constructor")
          ? ((() => {
            const $usr = ($expression)[2];
            return ($c$$src$Compiler$EmittableAst$$Constructor)($usr);
          }))()
          : ((($expression)[0] === "$RecordAccess")
            ? ((() => {
              const $attrName = ($expression)[2];
              const $exp = ($expression)[3];
              return ($c$$src$Compiler$EmittableAst$$RecordAccess)($attrName, ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $exp));
            }))()
            : ((($expression)[0] === "$Fn")
              ? ((() => {
                const $pos = ($expression)[1];
                const $taPars = ($expression)[2];
                const $body = ($expression)[3];
                const $bodyT = ($expression)[4];
                const $eaBody = ($u$$src$Compiler$MakeEmittable$$translateExpression)(((() => {
                  const $0 = $env;
                  return (Object.assign)({}, $0, ({
                    genVarCounter: (($c$$src$List$$length)($taPars) + $0.genVarCounter),
                  }));
                }))(), $body);
                const $3 = ((($0) => {
                  return ($c$$src$List$$forReversed)($0, $taPars, (($taPar, $5) => {
                    const $bodyAcc = $5.first;
                    const $eaParsAcc = $5.second;
                    const $7 = ((() => {
                      const $newEnv = ((() => {
                        const $0 = $env;
                        return (Object.assign)({}, $0, ({
                          genVarCounter: (($c$$src$List$$length)($eaParsAcc) + $0.genVarCounter),
                        }));
                      }))();
                      return ($u$$src$Compiler$MakeEmittable$$translateParameter)($newEnv, $bodyAcc, $taPar);
                    }))();
                    const $eaPar = $7.second;
                    const $bodyX = $7.first;
                    return ({
                      first: $bodyX,
                      second: (sp_cons)($eaPar, $eaParsAcc),
                    });
                  }));
                }))(({
                  first: $eaBody,
                  second: $c$$src$Core$$Nil,
                }));
                const $eaPars = $3.second;
                const $wrappedBody = $3.first;
                return ($c$$src$Compiler$EmittableAst$$Fn)($eaPars, $wrappedBody);
              }))()
              : ((($expression)[0] === "$Record")
                ? ((() => {
                  const $extends = ($expression)[2];
                  const $attrs = ($expression)[3];
                  return ((($0) => {
                    return ($c$$src$Compiler$EmittableAst$$LiteralRecord)(($c$$src$Maybe$$map)((($0) => {
                      return ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $0);
                    }), $extends), $0);
                  }))(((($0) => {
                    return ($c$$src$List$$map)((($0) => {
                      return ($c$$src$Tuple$$mapSecond)((($0) => {
                        return ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $0);
                      }), $0);
                    }), $0);
                  }))(((($0) => {
                    return (list_sortBy)($c$$src$Tuple$$first, $0);
                  }))(($c$$src$Dict$$toList)($attrs))));
                }))()
                : ((($expression)[0] === "$Call")
                  ? ((() => {
                    const $ref = ($expression)[2];
                    const $argsAndTypes = ($expression)[3];
                    return ($c$$src$Compiler$EmittableAst$$Call)(($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $ref), ($c$$src$List$$map)((($0) => {
                      return ($u$$src$Compiler$MakeEmittable$$translateArgAndType)($env, $0);
                    }), $argsAndTypes));
                  }))()
                  : ((($expression)[0] === "$If")
                    ? ((() => {
                      const $ar = ($expression)[2];
                      return ($c$$src$Compiler$EmittableAst$$Conditional)(($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $ar.condition), ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $ar.true), ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $ar.false));
                    }))()
                    : ((($expression)[0] === "$Try")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                        const $value = ($expression)[2].value;
                        const $valueType = ($expression)[2].valueType;
                        const $3 = ((() => {
                          const $4 = ({
                            first: $value,
                            second: $valueType.uni,
                          });
                          return (((($4.first)[0] === "$Variable") && (($4.second)[0] === "$Imm"))
                            ? ((() => {
                              const $ref = ($4.first)[2];
                              return ({
                                first: ($c$$src$Compiler$EmittableAst$$Variable)($ref),
                                second: $c$$src$Basics$$identity,
                                third: $env,
                              });
                            }))()
                            : (true
                              ? ((() => {
                                const $5 = ($u$$src$Compiler$MakeEmittable$$generateName)($env);
                                const $env_ = $5.second;
                                const $tryName = $5.first;
                                const $wrap = (($tryExpression) => {
                                  return ($c$$src$Compiler$EmittableAst$$LetIn)(({
                                    inExpression: $tryExpression,
                                    letExpression: ($u$$src$Compiler$MakeEmittable$$translateExpression)($env_, $value),
                                    maybeName: ($c$$src$Maybe$$Just)($tryName),
                                    type: $valueType,
                                  }));
                                });
                                return ({
                                  first: ($c$$src$Compiler$EmittableAst$$Variable)(($c$$src$Compiler$Ast$$RefLocal)($tryName)),
                                  second: $wrap,
                                  third: $env_,
                                });
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 206:16', (sp_toHuman)($4))));
                        }))();
                        const $newEnv = $3.third;
                        const $wrapWithLetIn = $3.second;
                        const $valueExpression = $3.first;
                        const $addTryPatternAndBlock = (($5, $nextTryExpression) => {
                          const $pattern = $5.first;
                          const $block = $5.second;
                          const $testIfPatternMatches = ($c$$src$Compiler$EmittableAst$$And)(($c$$src$List$$reverse)(($u$$src$Compiler$MakeEmittable$$testPattern)($pattern, $valueExpression, $c$$src$Core$$Nil)));
                          const $namesAndExpressions = ($u$$src$Compiler$MakeEmittable$$translatePattern)($pattern, $valueExpression);
                          const $whenConditionMatches = ((($0) => {
                            return ($c$$src$List$$for)($0, $namesAndExpressions, (($8, $inExpression) => {
                              const $type = $8.first;
                              const $name = $8.second;
                              const $letExpression = $8.third;
                              return ($c$$src$Compiler$EmittableAst$$LetIn)(({
                                inExpression: $inExpression,
                                letExpression: $letExpression,
                                maybeName: ($c$$src$Maybe$$Just)($name),
                                type: $type,
                              }));
                            }));
                          }))(($u$$src$Compiler$MakeEmittable$$translateExpression)($newEnv, $block));
                          return ($c$$src$Compiler$EmittableAst$$Conditional)($testIfPatternMatches, $whenConditionMatches, $nextTryExpression);
                        });
                        const $default = ((() => {
                          const $human = ($u$$src$Compiler$Error$$posToHuman)(({
                            content: $env.module.asText,
                            fsPath: $env.module.fsPath,
                          }), $pos);
                          return ($c$$src$Compiler$EmittableAst$$MissingPattern)($human.location, $valueExpression);
                        }))();
                        return ($wrapWithLetIn)(((($0) => {
                          return ($c$$src$List$$forReversed)($0, $patternsAndExpressions, $addTryPatternAndBlock);
                        }))($default));
                      }))()
                      : ((($expression)[0] === "$LetIn")
                        ? ((() => {
                          const $valueDef = ($expression)[1];
                          const $e = ($expression)[2];
                          const $bodyType = ($expression)[3];
                          const $3 = ($u$$src$Compiler$MakeEmittable$$pickMainName)($valueDef.pattern);
                          return ((($3)[0] === "$NoNamedVariables")
                            ? ($c$$src$Compiler$EmittableAst$$LetIn)(({
                              inExpression: ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $e),
                              letExpression: ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $valueDef.body),
                              maybeName: $c$$src$Maybe$$Nothing,
                              type: $valueDef.type,
                            }))
                            : ((($3)[0] === "$TrivialPattern")
                              ? ((() => {
                                const $defName = ($3)[1];
                                const $type = ($3)[2];
                                return ($c$$src$Compiler$EmittableAst$$LetIn)(({
                                  inExpression: ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $e),
                                  letExpression: ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $valueDef.body),
                                  maybeName: ($c$$src$Maybe$$Just)($defName),
                                  type: $type,
                                }));
                              }))()
                              : ((($3)[0] === "$GenerateName")
                                ? ((() => {
                                  const $4 = ($u$$src$Compiler$MakeEmittable$$generateName)($env);
                                  const $newEnv = $4.second;
                                  const $mainName = $4.first;
                                  const $namesAndExpressions = ($u$$src$Compiler$MakeEmittable$$translatePattern)($valueDef.pattern, ($c$$src$Compiler$EmittableAst$$Variable)(($c$$src$Compiler$Ast$$RefLocal)($mainName)));
                                  const $wrapWithUnpackedPatternVar = (($6, $inExpression) => {
                                    const $type = $6.first;
                                    const $name = $6.second;
                                    const $letExpression = $6.third;
                                    return ($c$$src$Compiler$EmittableAst$$LetIn)(({
                                      inExpression: $inExpression,
                                      letExpression: $letExpression,
                                      maybeName: ($c$$src$Maybe$$Just)($name),
                                      type: $type,
                                    }));
                                  });
                                  const $wrapWithActualLetIn = (($inExpression) => {
                                    return ($c$$src$Compiler$EmittableAst$$LetIn)(({
                                      inExpression: $inExpression,
                                      letExpression: ($u$$src$Compiler$MakeEmittable$$translateExpression)($newEnv, $valueDef.body),
                                      maybeName: ($c$$src$Maybe$$Just)($mainName),
                                      type: $valueDef.type,
                                    }));
                                  });
                                  return ($wrapWithActualLetIn)(((($0) => {
                                    return ($c$$src$List$$forReversed)($0, $namesAndExpressions, $wrapWithUnpackedPatternVar);
                                  }))(($u$$src$Compiler$MakeEmittable$$translateExpression)($newEnv, $e)));
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 256:12', (sp_toHuman)($3)))));
                        }))()
                        : ((($expression)[0] === "$DestroyIn")
                          ? ((() => {
                            const $name = ($expression)[1];
                            const $e = ($expression)[2];
                            return ($u$$src$Compiler$MakeEmittable$$translateExpression)($env, $e);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 156:4', (sp_toHuman)($expression))))))))))))));
});

const $u$$src$Compiler$TypeCheck$$initEnv = (($modulesByUmr) => {
  return ({
    annotatedTyvarsByName: $c$$src$Dict$$empty,
    annotatedUnivarsByOriginalId: $c$$src$Dict$$empty,
    constructors: $c$$src$Dict$$empty,
    context: $u$$src$Compiler$TypeCheck$$Context_Global,
    currentRootUsr: ($u$$src$Compiler$CoreDefs$$usr)("error"),
    exactTypes: $c$$src$Dict$$empty,
    expandedAliases: $c$$src$Dict$$empty,
    modulesByUmr: $modulesByUmr,
    reversedRootValueDefs: $c$$src$Core$$Nil,
    variables: $c$$src$Dict$$empty,
  });
});

const $u$$src$Compiler$UniquenessCheck$$addPatternToEnv = (($errors, $pattern, $env) => {
  const $names = ($c$$src$Compiler$TypedAst$$patternNames)($pattern);
  const $insertVariable = (($name, $5, $z) => {
    const $pos = $5.pos;
    const $type = $5.type;
    const $mode = ((sp_equal)($type.uni, $c$$src$Compiler$Ast$$Imm)
      ? $u$$src$Compiler$UniquenessCheck$$Immutable
      : ($u$$src$Compiler$UniquenessCheck$$Unique)($u$$src$Compiler$UniquenessCheck$$Available));
    const $variable = ({
      definedAt: $pos,
      mode: $mode,
      name: $name,
      required: $c$$src$Dict$$empty,
      type: $type,
    });
    return ($c$$src$Dict$$insert)($name, $variable, $z);
  });
  const $localEnv = ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      variables: ($c$$src$Dict$$for)($0.variables, $names, $insertVariable),
    }));
  }))();
  const $uniques = ((($0) => {
    return ($c$$src$Dict$$map)((($n, $s) => {
      return $s.pos;
    }), $0);
  }))(((($0) => {
    return ($c$$src$Dict$$filter)((($n, $s) => {
      return (sp_not_equal)($s.type.uni, $c$$src$Compiler$Ast$$Imm);
    }), $0);
  }))($names));
  return ([
    ({
      first: ($c$$src$Dict$$keys)($names),
      second: $uniques,
      third: $localEnv,
    }),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$consumeInEnv = (($spent, $env) => {
  const $translate = (($name, $variable) => {
    const $5 = ($c$$src$Dict$$get)($name, $spent);
    return ((($5)[0] === "$Nothing")
      ? $variable
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $pos = ($5)[1];
          const $0 = $variable;
          return (Object.assign)({}, $0, ({
            mode: ($u$$src$Compiler$UniquenessCheck$$Unique)(($u$$src$Compiler$UniquenessCheck$$ConsumedAt)($pos)),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 290:12', (sp_toHuman)($5))));
  });
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: ($c$$src$Dict$$map)($translate, $0.variables),
  }));
});

const $u$$src$Compiler$UniquenessCheck$$getErrorModule = (($env) => {
  const $2 = $env.usr;
  const $umr = ($2)[1];
  const $3 = ($c$$src$Dict$$get)($umr, $env.modulesByUmr);
  return ((($3)[0] === "$Nothing")
    ? ({
      content: "",
      fsPath: "N/A",
    })
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $content = ($3)[1].asText;
        const $fsPath = ($3)[1].fsPath;
        return ({
          content: $content,
          fsPath: $fsPath,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 48:4', (sp_toHuman)($3))));
});

const $u$$src$Compiler$UniquenessCheck$$addError = (($env, $pos, $errors, $messageConstructor) => {
  return ([
    ((__re__ = (array_push)($errors, ($u$$src$Compiler$Error$$Simple)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $pos, $messageConstructor))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorMutatingAConsumed = (($env, $name, $p2, $p1, $errors) => {
  const $6 = ($u$$src$Compiler$Error$$posToHuman)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $p2);
  const $location = $6.location;
  const $block = $6.block;
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $p1, $errors, ($c$$src$Core$$Cons)(("This code spends the unique variable `" + ($name + ("`, but `" + ($name + "` is being used again here:")))), ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)($block, ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)("If you want to use a unique more than once, you need to use a function that recycles it.", ($c$$src$Core$$Cons)("TODO: link to uniqueness wiki page", $c$$src$Core$$Nil)))))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorMutatingAnImmutable = (($env, $name, $p, $errors) => {
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $p, $errors, ($c$$src$Core$$Cons)(($name + " is immutable, but you are trying to mutate it"), $c$$src$Core$$Nil))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorMutatingTwice = (($env, $name, $p1, $p2, $errors) => {
  const $6 = ($u$$src$Compiler$Error$$posToHuman)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $p2);
  const $location = $6.location;
  const $block = $6.block;
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $p1, $errors, ($c$$src$Core$$Cons)(($name + " is already being mutated here: "), ($c$$src$Core$$Cons)($block, ($c$$src$Core$$Cons)("You can't use the same unique twice in the same function call", ($c$$src$Core$$Cons)("TODO: link to wiki explaining why", $c$$src$Core$$Nil)))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorReferencingConsumedVariable = (($env, $name, $pos, $consumedPos, $errors) => {
  const $6 = ($u$$src$Compiler$Error$$posToHuman)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $pos);
  const $location = $6.location;
  const $block = $6.block;
  const $cons = ($u$$src$Compiler$Error$$posToHuman)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $consumedPos);
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $pos, $errors, ($c$$src$Core$$Cons)(("You can't reference again the variable `" + ($name + "` because it was used already here:")), ($c$$src$Core$$Cons)($cons.block, $c$$src$Core$$Nil)))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorUndefinedVariable = (($env, $p, $name, $errors) => {
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $p, $errors, ($c$$src$Core$$Cons)(("undefined variable: " + $name), $c$$src$Core$$Nil))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$doArgument = (($env, $errors, $pos, $doneSoFar) => {
  const $5 = $doneSoFar.resolved;
  return ([
    ((($5)[0] === "$ArgumentExpression")
      ? ((() => {
        const $fullType = ($5)[1];
        const $expr = ($5)[2];
        const $doneExpression = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $expr)), ($errors = (__re__)[1]), (__re__)[0]);
        ($c$$src$Dict$$each)($doneExpression.spent, (($name, $p1) => {
          const $8 = ($c$$src$Dict$$get)($name, $doneSoFar.spent);
          return ((($8)[0] === "$Nothing")
            ? null
            : ((($8)[0] === "$Just")
              ? ((() => {
                const $p2 = ($8)[1];
                return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorReferencingConsumedVariable)($env, $name, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 397:16', (sp_toHuman)($8))));
        }));
        return ({
          recycled: $doneSoFar.recycled,
          required: ($c$$src$Dict$$join)($doneExpression.required, $doneSoFar.required),
          resolved: ($c$$src$Compiler$TypedAst$$ArgumentExpression)($fullType, $doneExpression.resolved),
          spent: ($c$$src$Dict$$join)($doneExpression.spent, $doneSoFar.spent),
        });
      }))()
      : ((($5)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $p1 = ($5)[1];
          const $rawType = ($5)[2];
          const $attrPath = ($5)[3];
          const $name = ($5)[4];
          const $x = ((() => {
            const $6 = ($c$$src$Dict$$get)($name, $env.variables);
            return ((($6)[0] === "$Nothing")
              ? ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorUndefinedVariable)($env, $p1, $name, $errors)), ($errors = (__re__)[1]), (__re__)[0])
              : ((($6)[0] === "$Just")
                ? ((() => {
                  const $variable = ($6)[1];
                  const $7 = $variable.mode;
                  return (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$Available"))
                    ? null
                    : ((($7)[0] === "$Immutable")
                      ? ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorMutatingAnImmutable)($env, $name, $p1, $errors)), ($errors = (__re__)[1]), (__re__)[0])
                      : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$ConsumedAt"))
                        ? ((() => {
                          const $p2 = (($7)[1])[1];
                          return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorMutatingAConsumed)($env, $name, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 420:24', (sp_toHuman)($7)))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 414:16', (sp_toHuman)($6))));
          }))();
          const $y = ((() => {
            const $6 = ($c$$src$Dict$$get)($name, $doneSoFar.recycled);
            return ((($6)[0] === "$Nothing")
              ? null
              : ((($6)[0] === "$Just")
                ? ((() => {
                  const $p2 = ($6)[1];
                  return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorMutatingTwice)($env, $name, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 426:16', (sp_toHuman)($6))));
          }))();
          const $0 = $doneSoFar;
          return (Object.assign)({}, $0, ({
            recycled: ($c$$src$Dict$$insert)($name, $p1, $doneSoFar.recycled),
            resolved: ($c$$src$Compiler$TypedAst$$ArgumentRecycle)($p1, $rawType, $attrPath, $name),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 390:4', (sp_toHuman)($5)))),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorTaintedCallRecyclesFunctions = (($env, $callPos, $name, $required, $errors) => {
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $callPos, $errors, ($c$$src$Core$$Cons)(("This function call could allow some unique values (" + (((($0) => {
      return ($c$$src$Text$$join)(", ", $0);
    }))(($c$$src$Dict$$keys)($required)) + ")")), ($c$$src$Core$$Cons)(("to be recycled by a functions contained in the argument `" + ($name + "` outside of the scope where they were declared.")), ($c$$src$Core$$Cons)("This would be BAD. [TODO link to wiki]", ($c$$src$Core$$Cons)("TODO improve this explanation.", $c$$src$Core$$Nil)))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$uniOutInit = (($a) => {
  return ({
    recycled: $c$$src$Dict$$empty,
    required: $c$$src$Dict$$empty,
    resolved: $a,
    spent: $c$$src$Dict$$empty,
  });
});

const $u$$src$Compiler$UniquenessCheck$$uniOutMap = (($f, $1) => {
  const $recycled = $1.recycled;
  const $required = $1.required;
  const $resolved = $1.resolved;
  const $spent = $1.spent;
  return ({
    recycled: $recycled,
    required: $required,
    resolved: ($f)($resolved),
    spent: $spent,
  });
});

const $u$$src$Compiler$UniquenessCheck$$doCall = (($env, $errors, $pos, $reference, $arguments) => {
  const $doneReference = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $reference)), ($errors = (__re__)[1]), (__re__)[0]);
  const $doneArgs = ((($0) => {
    return ($c$$src$List$$forReversed)($0, $arguments, (($arg, $acc) => {
      return ((($0) => {
        return ($u$$src$Compiler$UniquenessCheck$$uniOutMap)((($resolvedArg) => {
          return (sp_cons)($resolvedArg, $acc.resolved);
        }), $0);
      }))(((($0) => {
        return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doArgument)($env, $errors, $pos, $0)), ($errors = (__re__)[1]), (__re__)[0]);
      }))(((($0) => {
        return ($u$$src$Compiler$UniquenessCheck$$uniOutMap)(((_0) => {
          return $arg;
        }), $0);
      }))($acc)));
    }));
  }))(($u$$src$Compiler$UniquenessCheck$$uniOutInit)($c$$src$Core$$Nil));
  const $asRecyclingFunction = (($arg) => {
    return ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $path = ($arg)[3];
        const $name = ($arg)[4];
        return (($c$$src$Compiler$TypedAst$$typeAllowsFunctions)((($tyvarId) => {
          return false;
        }), $raw)
          ? ($c$$src$Maybe$$Just)($name)
          : $c$$src$Maybe$$Nothing);
      }))()
      : ((($arg)[0] === "$ArgumentExpression")
        ? $c$$src$Maybe$$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 354:8', (sp_toHuman)($arg))));
  });
  (((sp_not_equal)($doneArgs.required, $c$$src$Dict$$empty) || (sp_not_equal)($doneReference.required, $c$$src$Dict$$empty))
    ? ($c$$src$List$$each)(($c$$src$List$$filterMap)($asRecyclingFunction, $arguments), (($name) => {
      return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorTaintedCallRecyclesFunctions)($env, $pos, $name, ($c$$src$Dict$$join)($doneArgs.required, $doneReference.required), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
    }))
    : null);
  return ([
    ({
      recycled: ($c$$src$Dict$$join)($doneReference.recycled, $doneArgs.recycled),
      required: $doneArgs.required,
      resolved: ($c$$src$Compiler$TypedAst$$Call)($pos, $doneReference.resolved, $doneArgs.resolved),
      spent: ($c$$src$Dict$$join)($doneReference.spent, $doneArgs.spent),
    }),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$doParameter = (($errors, $par, $acc) => {
  return ([
    ((($par)[0] === "$ParameterPattern")
      ? ((() => {
        const $fullType = ($par)[1];
        const $pa = ($par)[2];
        const $4 = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addPatternToEnv)($errors, $pa, $acc.localEnv)), ($errors = (__re__)[1]), (__re__)[0]);
        const $localEnv = $4.third;
        const $uniques = $4.second;
        const $addedVars = $4.first;
        const $0 = $acc;
        return (Object.assign)({}, $0, ({
          localEnv: $localEnv,
          parsToBeSpent: ($c$$src$Dict$$join)($uniques, $0.parsToBeSpent),
        }));
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? ((() => {
          const $fullType = ($par)[1];
          const $n = ($par)[2];
          const $pa = ($c$$src$Compiler$TypedAst$$PatternAny)($c$$src$Compiler$Pos$$G, ({
            maybeName: ($c$$src$Maybe$$Just)((text_fromNumber)($n)),
            type: $fullType,
          }));
          const $4 = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addPatternToEnv)($errors, $pa, $acc.localEnv)), ($errors = (__re__)[1]), (__re__)[0]);
          const $localEnv = $4.third;
          const $uniques = $4.second;
          const $addedVars = $4.first;
          const $0 = $acc;
          return (Object.assign)({}, $0, ({
            localEnv: $localEnv,
            parsToBeSpent: ($c$$src$Dict$$join)($uniques, $0.parsToBeSpent),
          }));
        }))()
        : ((($par)[0] === "$ParameterRecycle")
          ? ((() => {
            const $pos = ($par)[1];
            const $rawType = ($par)[2];
            const $name = ($par)[3];
            const $var = ({
              definedAt: $pos,
              mode: ($u$$src$Compiler$UniquenessCheck$$Unique)($u$$src$Compiler$UniquenessCheck$$Available),
              name: $name,
              required: $c$$src$Dict$$empty,
              type: ({
                raw: $rawType,
                uni: $c$$src$Compiler$Ast$$Uni,
              }),
            });
            const $0 = $acc;
            return (Object.assign)({}, $0, ({
              localEnv: ((() => {
                const $1 = $acc.localEnv;
                return (Object.assign)({}, $1, ({
                  variables: ($c$$src$Dict$$insert)($name, $var, $1.variables),
                }));
              }))(),
              parsToBeRecycled: ($c$$src$Dict$$insert)($name, $pos, $0.parsToBeRecycled),
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 448:4', (sp_toHuman)($par))))),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorConsumingRecycledParameters = (($env, $pos, $spentThatShouldHaveBeenRecycled, $errors) => {
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $pos, $errors, ($c$$src$Core$$Cons)("errorConsumingRecycledParameters", ($c$$src$Core$$Cons)((sp_toHuman)($spentThatShouldHaveBeenRecycled), $c$$src$Core$$Nil)))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorFunctionsCannotConsumeParentUniques = (($env, $functionPos, $spentFromParent, $errors) => {
  const $zzz = (($5) => {
    const $name = $5.first;
    const $spentPos = $5.second;
    const $6 = ($u$$src$Compiler$Error$$posToHuman)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $spentPos);
    const $location = $6.location;
    const $block = $6.block;
    return ($block + "\n");
  });
  const $blocks = ((($0) => {
    return ($c$$src$List$$map)($zzz, $0);
  }))(((($0) => {
    return (list_sortBy)($c$$src$Tuple$$second, $0);
  }))(($c$$src$Dict$$toList)($spentFromParent)));
  return ([
    ((($0) => {
      return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $functionPos, $errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
    }))(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(("This function is spending the unique variable `" + (((($0) => {
      return ($c$$src$Text$$join)("`, `", $0);
    }))(($c$$src$Dict$$keys)($spentFromParent)) + "`")), $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)("", $c$$src$Core$$Nil), ($c$$src$Core$$Cons)($blocks, ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)("However, functions cannot spend uniques that were declared outside their body.", $c$$src$Core$$Nil), $c$$src$Core$$Nil)))))),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope = (($env, $name, $2, $errors) => {
  const $fnPos = $2.fnPos;
  const $usedAt = $2.usedAt;
  const $5 = ($u$$src$Compiler$Error$$posToHuman)(($u$$src$Compiler$UniquenessCheck$$getErrorModule)($env), $usedAt);
  const $location = $5.location;
  const $block = $5.block;
  return ([
    ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addError)($env, $fnPos, $errors, ($c$$src$Core$$Cons)(("This expression needs to access the unique variable `" + ($name + "` because it uses it here:")), ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)($block, ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)(("The problem is that returning a function from the expression could allow accessing `" + ($name + ("` from outside of where `" + ($name + "` was declared.")))), ($c$$src$Core$$Cons)("This would be BAD. [TODO link to wiki]", $c$$src$Core$$Nil)))))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$doFn = (($env, $pos, $errors, $pars, $body, $bodyType) => {
  const $7 = ((($0) => {
    return ($c$$src$List$$for)($0, $pars, (($0, $1) => {
      return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doParameter)($errors, $0, $1)), ($errors = (__re__)[1]), (__re__)[0]);
    }));
  }))(({
    localEnv: $env,
    parsToBeRecycled: $c$$src$Dict$$empty,
    parsToBeSpent: $c$$src$Dict$$empty,
  }));
  const $parsToBeSpent = $7.parsToBeSpent;
  const $parsToBeRecycled = $7.parsToBeRecycled;
  const $localEnv = $7.localEnv;
  const $doneBody = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($localEnv, $errors, $body)), ($errors = (__re__)[1]), (__re__)[0]);
  const $exprWithDestruction = ((($0) => {
    return ($c$$src$Dict$$for)($0, $parsToBeSpent, (($name, _1, $exp) => {
      return (($c$$src$Dict$$member)($name, $doneBody.spent)
        ? $exp
        : ($c$$src$Compiler$TypedAst$$DestroyIn)($name, $exp));
    }));
  }))($doneBody.resolved);
  const $spentThatShouldHaveBeenRecycled = ($c$$src$Dict$$intersect)($doneBody.spent, $parsToBeRecycled);
  ((sp_not_equal)($spentThatShouldHaveBeenRecycled, $c$$src$Dict$$empty)
    ? ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorConsumingRecycledParameters)($env, $pos, $spentThatShouldHaveBeenRecycled, $errors)), ($errors = (__re__)[1]), (__re__)[0])
    : null);
  const $spentFromParent = ($c$$src$Dict$$diff)($doneBody.spent, $parsToBeSpent);
  (((sp_equal)($spentThatShouldHaveBeenRecycled, $c$$src$Dict$$empty) && (sp_not_equal)($spentFromParent, $c$$src$Dict$$empty))
    ? ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorFunctionsCannotConsumeParentUniques)($env, $pos, $spentFromParent, $errors)), ($errors = (__re__)[1]), (__re__)[0])
    : null);
  const $required = ((($0) => {
    return ($c$$src$Dict$$diff)($0, $parsToBeRecycled);
  }))(((($0) => {
    return ($c$$src$Dict$$join)($doneBody.required, $0);
  }))(((($0) => {
    return ($c$$src$Dict$$map)((($k, $usedAt) => {
      return ({
        fnPos: $pos,
        usedAt: $usedAt,
      });
    }), $0);
  }))($doneBody.recycled)));
  (($c$$src$Compiler$TypedAst$$typeAllowsFunctions)((($tyvarId) => {
    return false;
  }), $bodyType.raw)
    ? ($c$$src$Dict$$each)(($c$$src$Dict$$join)($parsToBeRecycled, $parsToBeSpent), (($varName, $parPos) => {
      const $10 = ($c$$src$Dict$$get)($varName, $doneBody.required);
      return ((($10)[0] === "$Nothing")
        ? null
        : ((($10)[0] === "$Just")
          ? ((() => {
            const $r = ($10)[1];
            return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope)($env, $varName, $r, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 810:12', (sp_toHuman)($10))));
    }))
    : null);
  return ([
    ({
      recycled: ($c$$src$Dict$$diff)($doneBody.recycled, $parsToBeRecycled),
      required: $required,
      resolved: ($c$$src$Compiler$TypedAst$$Fn)($pos, $pars, $exprWithDestruction, $bodyType),
      spent: $c$$src$Dict$$empty,
    }),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$doVariable = (($env, $errors, $pos, $name, $e) => {
  const $6 = ($c$$src$Dict$$get)($name, $env.variables);
  return ([
    ((($6)[0] === "$Nothing")
      ? ((() => {
        ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorUndefinedVariable)($env, $pos, $name, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
        return ($u$$src$Compiler$UniquenessCheck$$uniOutInit)($e);
      }))()
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $variable = ($6)[1];
          const $7 = $variable.mode;
          return ((($7)[0] === "$Immutable")
            ? ({
              recycled: $c$$src$Dict$$empty,
              required: $variable.required,
              resolved: $e,
              spent: $c$$src$Dict$$empty,
            })
            : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$Available"))
              ? ({
                recycled: $c$$src$Dict$$empty,
                required: $variable.required,
                resolved: $e,
                spent: ($c$$src$Dict$$ofOne)($name, $pos),
              })
              : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$ConsumedAt"))
                ? ((() => {
                  const $consumedPos = (($7)[1])[1];
                  ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorReferencingConsumedVariable)($env, $name, $pos, $consumedPos, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                  return ({
                    recycled: $c$$src$Dict$$empty,
                    required: $variable.required,
                    resolved: $e,
                    spent: ($c$$src$Dict$$ofOne)($name, $pos),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 728:12', (sp_toHuman)($7)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 720:4', (sp_toHuman)($6)))),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$requireInEnv = (($varNames, $required, $env) => {
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: ((($0) => {
      return ($c$$src$List$$for)($0, $varNames, (($name, $a) => {
        return ($c$$src$Dict$$update)($name, (($0) => {
          return ($c$$src$Maybe$$map)((($var) => {
            const $1 = $var;
            return (Object.assign)({}, $1, ({
              required: $required,
            }));
          }), $0);
        }), $a);
      }));
    }))($0.variables),
  }));
});

const $u$$src$Compiler$UniquenessCheck$$doExpression = (($env, $errors, $expression) => {
  const $re = ($u$$src$Compiler$UniquenessCheck$$uniOutInit)($expression);
  return ([
    ((($expression)[0] === "$LiteralText")
      ? ((() => {
        const $pos = ($expression)[1];
        const $l = ($expression)[2];
        return $re;
      }))()
      : ((($expression)[0] === "$LiteralNumber")
        ? ((() => {
          const $pos = ($expression)[1];
          const $l = ($expression)[2];
          return $re;
        }))()
        : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
          ? ((() => {
            const $pos = ($expression)[1];
            return $re;
          }))()
          : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefLocal"))
            ? ((() => {
              const $pos = ($expression)[1];
              const $name = (($expression)[2])[1];
              return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doVariable)($env, $errors, $pos, $name, $expression)), ($errors = (__re__)[1]), (__re__)[0]);
            }))()
            : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefPlaceholder"))
              ? ((() => {
                const $pos = ($expression)[1];
                const $n = (($expression)[2])[1];
                return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doVariable)($env, $errors, $pos, (text_fromNumber)($n), $expression)), ($errors = (__re__)[1]), (__re__)[0]);
              }))()
              : ((($expression)[0] === "$Constructor")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $usr = ($expression)[2];
                  return $re;
                }))()
                : ((($expression)[0] === "$Fn")
                  ? ((() => {
                    const $pos = ($expression)[1];
                    const $pars = ($expression)[2];
                    const $body = ($expression)[3];
                    const $bodyType = ($expression)[4];
                    return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doFn)($env, $pos, $errors, $pars, $body, $bodyType)), ($errors = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($expression)[0] === "$Call")
                    ? ((() => {
                      const $pos = ($expression)[1];
                      const $reference = ($expression)[2];
                      const $arguments = ($expression)[3];
                      return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doCall)($env, $errors, $pos, $reference, $arguments)), ($errors = (__re__)[1]), (__re__)[0]);
                    }))()
                    : ((($expression)[0] === "$If")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $condition = ($expression)[2].condition;
                        const $false = ($expression)[2].false;
                        const $true = ($expression)[2].true;
                        const $doneCondition = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $condition)), ($errors = (__re__)[1]), (__re__)[0]);
                        const $newEnv = ($u$$src$Compiler$UniquenessCheck$$consumeInEnv)($doneCondition.spent, $env);
                        const $doneTrue = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($newEnv, $errors, $true)), ($errors = (__re__)[1]), (__re__)[0]);
                        const $doneFalse = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($newEnv, $errors, $false)), ($errors = (__re__)[1]), (__re__)[0]);
                        const $finalTrueExpression = ((($0) => {
                          return ($c$$src$Dict$$for)($0, $doneFalse.spent, (($name, _1, $exp) => {
                            return (($c$$src$Dict$$member)($name, $doneTrue.spent)
                              ? $exp
                              : ($c$$src$Compiler$TypedAst$$DestroyIn)($name, $exp));
                          }));
                        }))($doneTrue.resolved);
                        const $finalFalseExpression = ((($0) => {
                          return ($c$$src$Dict$$for)($0, $doneTrue.spent, (($name, _1, $exp) => {
                            return (($c$$src$Dict$$member)($name, $doneFalse.spent)
                              ? $exp
                              : ($c$$src$Compiler$TypedAst$$DestroyIn)($name, $exp));
                          }));
                        }))($doneFalse.resolved);
                        const $finalExpression = ($c$$src$Compiler$TypedAst$$If)($pos, ({
                          condition: $doneCondition.resolved,
                          false: $finalFalseExpression,
                          true: $finalTrueExpression,
                        }));
                        return ({
                          recycled: ((($0) => {
                            return ($c$$src$Dict$$join)($doneFalse.recycled, $0);
                          }))(((($0) => {
                            return ($c$$src$Dict$$join)($doneTrue.recycled, $0);
                          }))($doneCondition.recycled)),
                          required: ((($0) => {
                            return ($c$$src$Dict$$join)($doneFalse.required, $0);
                          }))(((($0) => {
                            return ($c$$src$Dict$$join)($doneTrue.required, $0);
                          }))($doneCondition.required)),
                          resolved: $finalExpression,
                          spent: ((($0) => {
                            return ($c$$src$Dict$$join)($doneFalse.spent, $0);
                          }))(((($0) => {
                            return ($c$$src$Dict$$join)($doneTrue.spent, $0);
                          }))($doneCondition.spent)),
                        });
                      }))()
                      : ((($expression)[0] === "$Try")
                        ? ((() => {
                          const $pos = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          const $doneValue = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $value)), ($errors = (__re__)[1]), (__re__)[0]);
                          const $newEnv = ($u$$src$Compiler$UniquenessCheck$$consumeInEnv)($doneValue.spent, $env);
                          const $zzz = (($4) => {
                            const $pattern = $4.first;
                            const $block = $4.second;
                            const $5 = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addPatternToEnv)($errors, $pattern, $newEnv)), ($errors = (__re__)[1]), (__re__)[0]);
                            const $env0 = $5.third;
                            const $mutables_should_be_empty = $5.second;
                            const $addedVars = $5.first;
                            const $localEnv = ($u$$src$Compiler$UniquenessCheck$$requireInEnv)($addedVars, $doneValue.required, $env0);
                            return ((($0) => {
                              return ($u$$src$Compiler$UniquenessCheck$$uniOutMap)((($expr) => {
                                return ({
                                  first: $pattern,
                                  second: $expr,
                                });
                              }), $0);
                            }))(((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($localEnv, $errors, $block)), ($errors = (__re__)[1]), (__re__)[0]));
                          });
                          const $donePatternsAndBlocks = ((($0) => {
                            return ($c$$src$List$$map)($zzz, $0);
                          }))($patternsAndExpressions);
                          const $allRecycled = ((($0) => {
                            return ($c$$src$List$$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                              return ($c$$src$Dict$$join)($d.recycled, $a);
                            }));
                          }))($c$$src$Dict$$empty);
                          const $allRequired = ((($0) => {
                            return ($c$$src$List$$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                              return ($c$$src$Dict$$join)($d.required, $a);
                            }));
                          }))($c$$src$Dict$$empty);
                          const $allSpent = ((($0) => {
                            return ($c$$src$List$$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                              return ($c$$src$Dict$$join)($d.spent, $a);
                            }));
                          }))($c$$src$Dict$$empty);
                          const $newPatternsAndBlocks = ((() => {
                            const $xxx = (($4) => {
                              const $recycled = $4.recycled;
                              const $required = $4.required;
                              const $pattern = $4.resolved.first;
                              const $blockExpression = $4.resolved.second;
                              const $spent = $4.spent;
                              const $finalBlock = ((($0) => {
                                return ($c$$src$Dict$$for)($0, $allSpent, (($name, _1, $exp) => {
                                  return (($c$$src$Dict$$member)($name, $spent)
                                    ? $exp
                                    : ($c$$src$Compiler$TypedAst$$DestroyIn)($name, $exp));
                                }));
                              }))($blockExpression);
                              return ({
                                first: $pattern,
                                second: $finalBlock,
                              });
                            });
                            return ($c$$src$List$$map)($xxx, $donePatternsAndBlocks);
                          }))();
                          return ({
                            recycled: $allRecycled,
                            required: $allRequired,
                            resolved: ($c$$src$Compiler$TypedAst$$Try)($pos, ({
                              patternsAndExpressions: $newPatternsAndBlocks,
                              value: $doneValue.resolved,
                              valueType: $valueType,
                            })),
                            spent: $allSpent,
                          });
                        }))()
                        : ((($expression)[0] === "$Record")
                          ? ((() => {
                            const $pos = ($expression)[1];
                            const $maybeExtending = ($expression)[2];
                            const $attrValueByName = ($expression)[3];
                            const $doneExt = ((($maybeExtending)[0] === "$Nothing")
                              ? ($u$$src$Compiler$UniquenessCheck$$uniOutInit)($c$$src$Maybe$$Nothing)
                              : ((($maybeExtending)[0] === "$Just")
                                ? ((() => {
                                  const $extending = ($maybeExtending)[1];
                                  return ((($0) => {
                                    return ($u$$src$Compiler$UniquenessCheck$$uniOutMap)($c$$src$Maybe$$Just, $0);
                                  }))(((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $extending)), ($errors = (__re__)[1]), (__re__)[0]));
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 620:16', (sp_toHuman)($maybeExtending))));
                            const $doneAttrs = ((($0) => {
                              return ($c$$src$Dict$$for)($0, $attrValueByName, (($name, $value, $doneSoFar) => {
                                const $8 = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $value)), ($errors = (__re__)[1]), (__re__)[0]);
                                const $spent = $8.spent;
                                const $resolved = $8.resolved;
                                const $required = $8.required;
                                const $recycled = $8.recycled;
                                const $consumedTwice = ($c$$src$Dict$$merge)((($k, $v, $d) => {
                                  return $d;
                                }), (($k, $a, $b, $d) => {
                                  return ($c$$src$Dict$$insert)($k, ({
                                    first: $a,
                                    second: $b,
                                  }), $d);
                                }), (($k, $v, $d) => {
                                  return $d;
                                }), $spent, $doneSoFar.spent, $c$$src$Dict$$empty);
                                ($c$$src$Dict$$each)($consumedTwice, (($n, $9) => {
                                  const $p1 = $9.first;
                                  const $p2 = $9.second;
                                  return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorReferencingConsumedVariable)($env, $n, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                                }));
                                return ({
                                  recycled: ($c$$src$Dict$$join)($recycled, $doneSoFar.recycled),
                                  required: ($c$$src$Dict$$join)($required, $doneSoFar.required),
                                  resolved: ($c$$src$Dict$$insert)($name, $resolved, $doneSoFar.resolved),
                                  spent: ($c$$src$Dict$$join)($spent, $doneSoFar.spent),
                                });
                              }));
                            }))(($u$$src$Compiler$UniquenessCheck$$uniOutInit)($c$$src$Dict$$empty));
                            return ({
                              recycled: ($c$$src$Dict$$join)($doneExt.recycled, $doneAttrs.recycled),
                              required: ($c$$src$Dict$$join)($doneExt.required, $doneAttrs.required),
                              resolved: ($c$$src$Compiler$TypedAst$$Record)($pos, $doneExt.resolved, $doneAttrs.resolved),
                              spent: ($c$$src$Dict$$join)($doneExt.spent, $doneAttrs.spent),
                            });
                          }))()
                          : ((($expression)[0] === "$RecordAccess")
                            ? ((() => {
                              const $pos = ($expression)[1];
                              const $name = ($expression)[2];
                              const $expr = ($expression)[3];
                              return ((($0) => {
                                return ($u$$src$Compiler$UniquenessCheck$$uniOutMap)((($0) => {
                                  return ($c$$src$Compiler$TypedAst$$RecordAccess)($pos, $name, $0);
                                }), $0);
                              }))(((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $expr)), ($errors = (__re__)[1]), (__re__)[0]));
                            }))()
                            : ((($expression)[0] === "$LetIn")
                              ? ((() => {
                                const $valueDef = ($expression)[1];
                                const $rest = ($expression)[2];
                                const $restType = ($expression)[3];
                                const $4 = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$addPatternToEnv)($errors, $valueDef.pattern, $env)), ($errors = (__re__)[1]), (__re__)[0]);
                                const $env1 = $4.third;
                                const $uniques = $4.second;
                                const $addedVars = $4.first;
                                const $doneDefBody = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env1, $errors, $valueDef.body)), ($errors = (__re__)[1]), (__re__)[0]);
                                const $localEnv = ((($0) => {
                                  return ($u$$src$Compiler$UniquenessCheck$$requireInEnv)($addedVars, $doneDefBody.required, $0);
                                }))(((($0) => {
                                  return ($u$$src$Compiler$UniquenessCheck$$consumeInEnv)($doneDefBody.spent, $0);
                                }))($env1));
                                const $doneExpression = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($localEnv, $errors, $rest)), ($errors = (__re__)[1]), (__re__)[0]);
                                (($c$$src$Compiler$TypedAst$$typeAllowsFunctions)((($tyvarId) => {
                                  return false;
                                }), $restType.raw)
                                  ? ($c$$src$List$$each)($addedVars, (($varName) => {
                                    const $6 = ($c$$src$Dict$$get)($varName, $doneExpression.required);
                                    return ((($6)[0] === "$Nothing")
                                      ? null
                                      : ((($6)[0] === "$Just")
                                        ? ((() => {
                                          const $r = ($6)[1];
                                          return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope)($env, $varName, $r, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                                        }))()
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 685:20', (sp_toHuman)($6))));
                                  }))
                                  : null);
                                const $finalExpression = ((($0) => {
                                  return ($c$$src$Dict$$for)($0, $uniques, (($name, $pos, $exp) => {
                                    const $9 = ($c$$src$Dict$$get)($name, $doneExpression.spent);
                                    return ((($9)[0] === "$Just")
                                      ? $exp
                                      : ((($9)[0] === "$Nothing")
                                        ? ($c$$src$Compiler$TypedAst$$DestroyIn)($name, $exp)
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 694:20', (sp_toHuman)($9))));
                                  }));
                                }))(($c$$src$Compiler$TypedAst$$LetIn)(((() => {
                                  const $0 = $valueDef;
                                  return (Object.assign)({}, $0, ({
                                    body: $doneDefBody.resolved,
                                  }));
                                }))(), $doneExpression.resolved, $restType));
                                const $spent = ((($0) => {
                                  return ($c$$src$Dict$$join)($doneDefBody.spent, $0);
                                }))(((($0) => {
                                  return ($c$$src$Dict$$for)($0, $uniques, (($name, _1, $d) => {
                                    return ($c$$src$Dict$$remove)($name, $d);
                                  }));
                                }))($doneExpression.spent));
                                return ({
                                  recycled: ($c$$src$Dict$$join)($doneDefBody.recycled, $doneExpression.recycled),
                                  required: $doneExpression.required,
                                  resolved: $finalExpression,
                                  spent: $spent,
                                });
                              }))()
                              : ((($expression)[0] === "$Error")
                                ? $re
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 492:4', (sp_toHuman)($expression)))))))))))))))),
    $errors,
  ]);
});

const $u$$src$Compiler$UniquenessCheck$$updateValueDef = (($errors, $modulesByUmr, $1) => {
  const $usr = $1.first;
  const $def = $1.second;
  const $env = ({
    modulesByUmr: $modulesByUmr,
    usr: $usr,
    variables: $c$$src$Dict$$empty,
  });
  const $doneExpression = ((__re__ = ($u$$src$Compiler$UniquenessCheck$$doExpression)($env, $errors, $def.body)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    ({
      first: $usr,
      second: ((() => {
        const $0 = $def;
        return (Object.assign)({}, $0, ({
          body: $doneExpression.resolved,
        }));
      }))(),
    }),
    $errors,
  ]);
});

const $u$$src$SPLib$RefHierarchy$$resolve = (($getEdges, $target, $path, $state0) => {
  return (($c$$src$List$$member)($target, $state0.resolved)
    ? $state0
    : (($c$$src$List$$member)($target, $path)
      ? ((() => {
        const $circ = (sp_cons)($target, ($c$$src$List$$takeWhile)((($key) => {
          return (sp_not_equal)($key, $target);
        }), $path));
        const $0 = $state0;
        return (Object.assign)({}, $0, ({
          circular: ($c$$src$Dict$$insert)(($c$$src$Set$$fromList)($circ), $circ, $0.circular),
        }));
      }))()
      : ((() => {
        const $s = ((($0) => {
          return ($c$$src$Dict$$for)($0, ($getEdges)($target), (($a, _1, $d) => {
            return ($u$$src$SPLib$RefHierarchy$$resolve)($getEdges, $a, (sp_cons)($target, $path), $d);
          }));
        }))($state0);
        const $0 = $s;
        return (Object.assign)({}, $0, ({
          resolved: (sp_cons)($target, $0.resolved),
        }));
      }))()));
});

const $u$$src$SPLib$RefHierarchy$$reorder = (($nodeToEdges, $nodesById) => {
  const $keyToEdges = (($id) => {
    const $4 = ($c$$src$Dict$$get)($id, $nodesById);
    return ((($4)[0] === "$Nothing")
      ? $c$$src$Dict$$empty
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $node = ($4)[1];
          return ($nodeToEdges)($node);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/RefHierarchy.sp 40:8', (sp_toHuman)($4))));
  });
  const $state0 = ({
    circular: $c$$src$Dict$$empty,
    resolved: $c$$src$Core$$Nil,
  });
  const $stateF = ((($0) => {
    return ($c$$src$Dict$$for)($0, $nodesById, (($k, $v, $d) => {
      return ($u$$src$SPLib$RefHierarchy$$resolve)($keyToEdges, $k, $c$$src$Core$$Nil, $d);
    }));
  }))($state0);
  return ({
    first: ($c$$src$Dict$$values)($stateF.circular),
    second: ($c$$src$List$$reverse)($stateF.resolved),
  });
});

const $u$$src$Compiler$LazyBuild$$build = (($pars) => {
  let $state = ($u$$src$Compiler$LazyBuild$$initCollectDependenciesState)(((($0) => {
    return ($c$$src$List$$map)((($usr) => {
      return ({
        first: $usr,
        second: ($u$$src$Compiler$LazyBuild$$usrToDependencyType)($usr),
      });
    }), $0);
  }))($pars.requiredUsrs));
  return (($c$$src$Result$$onOk)(((_0) => {
    const $nodeToEdges = (($usr) => {
      const $4 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
      return ((($4)[0] === "$Nothing")
        ? $c$$src$Dict$$empty
        : ((($4)[0] === "$Just")
          ? ((() => {
            const $deps = ($4)[1].deps;
            return $deps;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 256:8', (sp_toHuman)($4))));
    });
    const $nodesById = ((__re__ = ($c$$src$Hash$$for_)($c$$src$Dict$$empty, $state.done, (($usr, _1, $dict) => {
      return ($c$$src$Dict$$insert)($usr, $usr, $dict);
    }))), ($state.done = (__re__)[1]), (__re__)[0]);
    const $3 = ($u$$src$SPLib$RefHierarchy$$reorder)($nodeToEdges, $nodesById);
    const $orderedUsrs = $3.second;
    const $circulars = $3.first;
    let $errors = (array_fromList)($c$$src$Core$$Nil);
    ($c$$src$List$$each)($circulars, (($circular) => {
      return ((($circular)[0] === "$Cons")
        ? ((() => {
          const $usr = ($circular)[1];
          const $others = ($circular)[2];
          return ((sp_equal)(($u$$src$Compiler$LazyBuild$$usrToDependencyType)($usr), $c$$src$Compiler$Meta$$TypeDependency)
            ? ((($0) => {
              return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
            }))(($u$$src$Compiler$Error$$Raw)(($c$$src$Core$$Cons)("Circular aliases!", ($c$$src$Core$$Cons)((sp_toHuman)($circular), $c$$src$Core$$Nil))))
            : null);
        }))()
        : (true
          ? null
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 283:8', (sp_toHuman)($circular))));
    }));
    return (($c$$src$Result$$onOk)(((_0) => {
      const $modulesByUmr = ($c$$src$Dict$$fromList)(((__re__ = ($c$$src$Hash$$toList)($state.loadedModulesByUmr)), ($state.loadedModulesByUmr = (__re__)[1]), (__re__)[0]));
      const $env0 = ($u$$src$Compiler$TypeCheck$$initEnv)($modulesByUmr);
      const $env1 = ($c$$src$List$$for)($env0, $orderedUsrs, (($0, $1) => {
        return ((__re__ = ($u$$src$Compiler$LazyBuild$$expandAndInsertType)($state, $errors, $0, $1)), ($state = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
      }));
      return (($c$$src$Result$$onOk)(((_0) => {
        let $lastUnificationVarId = (basics_cloneImm)(0);
        const $env2 = ($c$$src$List$$for)($env1, $circulars, (($0, $1) => {
          return ((__re__ = ($u$$src$Compiler$LazyBuild$$evaluateCircularValues)($state, $errors, $lastUnificationVarId, $0, $1)), ($state = (__re__)[1]), ($errors = (__re__)[2]), ($lastUnificationVarId = (__re__)[3]), (__re__)[0]);
        }));
        return (($c$$src$Result$$onOk)(((_0) => {
          const $envF = ($c$$src$List$$for)($env2, $orderedUsrs, (($0, $1) => {
            return ((__re__ = ($u$$src$Compiler$LazyBuild$$typecheckDefinition)($state, $errors, $lastUnificationVarId, $0, $1)), ($state = (__re__)[1]), ($errors = (__re__)[2]), ($lastUnificationVarId = (__re__)[3]), (__re__)[0]);
          }));
          const $valueDefsWithDestruction = ((($0) => {
            return ($c$$src$List$$map)((($0) => {
              return ((__re__ = ($u$$src$Compiler$UniquenessCheck$$updateValueDef)($errors, $modulesByUmr, $0)), ($errors = (__re__)[1]), (__re__)[0]);
            }), $0);
          }))(($c$$src$List$$reverse)($envF.reversedRootValueDefs));
          return (($c$$src$Result$$onOk)(((_0) => {
            const $translateDef = (($8) => {
              const $usr = $8.first;
              const $def = $8.second;
              return ({
                deps: $def.directDeps,
                expr: ($u$$src$Compiler$MakeEmittable$$translateExpression)(($u$$src$Compiler$MakeEmittable$$mkEnv)($usr, $modulesByUmr), $def.body),
                freeTyvars: $def.freeTyvars,
                freeUnivars: $def.freeUnivars,
                type: $def.type.raw,
                usr: $usr,
              });
            });
            const $rootValues = ($c$$src$List$$map)($translateDef, $valueDefsWithDestruction);
            const $constructors = ($c$$src$Dict$$toList)(($c$$src$Dict$$map)((($k, $v) => {
              return $v.type.raw;
            }), $envF.constructors));
            return ($c$$src$Result$$Ok)(({
              constructors: $constructors,
              rootValues: $rootValues,
            }));
          })))(((__re__ = ($u$$src$Compiler$LazyBuild$$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
        })))(((__re__ = ($u$$src$Compiler$LazyBuild$$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
      })))(((__re__ = ($u$$src$Compiler$LazyBuild$$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
    })))(((__re__ = ($u$$src$Compiler$LazyBuild$$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
  })))(((__re__ = ($u$$src$Compiler$LazyBuild$$collectRequiredUsrs)($pars, $state)), ($state = (__re__)[1]), (__re__)[0]));
});

const $u$$src$Compiler$MakeCanonical$$initEnv = (($ro) => {
  return ({
    maybeShorthandTarget: $c$$src$Maybe$$Nothing,
    nextGeneratedVariableName: 0,
    nonFn: $c$$src$Dict$$empty,
    ro: $ro,
    values: $c$$src$Dict$$empty,
  });
});

const $u$$src$Compiler$Error$$res = (($mod, $pos, $desc) => {
  return ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Simple)($mod, $pos, $desc));
});

const $u$$src$Compiler$MakeCanonical$$error = (($env, $pos, $msg) => {
  return ($u$$src$Compiler$Error$$res)($env.ro.errorModule, $pos, $msg);
});

const $u$$src$Compiler$MakeCanonical$$insertPatternNames = (($isRoot, $pattern, $env) => {
  return (($c$$src$Result$$onOk)((($values) => {
    return ($c$$src$Result$$Ok)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        values: $values,
      }));
    }))());
  })))(($c$$src$List$$forRes)($env.values, ($c$$src$Compiler$CanonicalAst$$patternNames)($pattern), (($paName, $vs) => {
    const $6 = ($c$$src$Dict$$get)($paName.name, $vs);
    return ((($6)[0] === "$Just")
      ? ((() => {
        const $duplicateName = ($6)[1];
        return ($u$$src$Compiler$MakeCanonical$$error)($env, $paName.pos, ($c$$src$Core$$Cons)(("A variable named `" + ($paName.name + "` has already been defined.")), ($c$$src$Core$$Cons)("You need to find a less ambiguous name.", $c$$src$Core$$Nil)));
      }))()
      : ((($6)[0] === "$Nothing")
        ? ((() => {
          const $resolvePars = ($env.ro.resolvePars)($paName.pos);
          const $shadowsAGlobal = ((() => {
            const $7 = ($c$$src$Dict$$get)($paName.name, $resolvePars.currentImports.globalNameToLocation);
            return ((($7)[0] === "$Nothing")
              ? false
              : ((($7)[0] === "$Just")
                ? ((() => {
                  const $location = ($7)[1];
                  return (($c$$src$Basics$$not)($isRoot)
                    ? true
                    : ((() => {
                      const $8 = ($c$$src$Compiler$Meta$$resolve)($resolvePars, $c$$src$Maybe$$Nothing, $paName.name);
                      return ((($8)[0] === "$Err")
                        ? true
                        : (((($8)[0] === "$Ok") && ((($8)[1])[0] === "$USR"))
                          ? ((() => {
                            const $umr = (($8)[1])[1];
                            const $name = (($8)[1])[2];
                            return (sp_not_equal)($umr, $env.ro.umr);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 846:32', (sp_toHuman)($8))));
                    }))());
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 832:20', (sp_toHuman)($7))));
          }))();
          return (($c$$src$Basics$$not)($shadowsAGlobal)
            ? ($c$$src$Result$$Ok)(($c$$src$Dict$$insert)($paName.name, ({
              isRoot: $isRoot,
              pos: $paName.pos,
            }), $vs))
            : ($u$$src$Compiler$MakeCanonical$$error)($env, $paName.pos, ($c$$src$Core$$Cons)(("There is already a global variable named `" + ($paName.name + "`.")), ($c$$src$Core$$Cons)("You need to find a different name, or modify imports.sp", $c$$src$Core$$Nil))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 815:8', (sp_toHuman)($6))));
  })));
});

const $u$$src$Compiler$MakeCanonical$$erroro = (($ro, $pos, $msg) => {
  return ($u$$src$Compiler$Error$$res)($ro.errorModule, $pos, $msg);
});

const $u$$src$Compiler$MakeCanonical$$resolveToUsr = (($ro, $pos, $maybeModule, $name) => {
  return ($c$$src$Compiler$Meta$$resolve)(($ro.resolvePars)($pos), $maybeModule, $name);
});

const $u$$src$Compiler$MakeCanonical$$translateAttributeName = (($ro, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Lowercase")
    ? ((() => {
      const $attrPath = ($expr_)[1].attrPath;
      const $maybeModule = ($expr_)[1].maybeModule;
      const $maybeType = ($expr_)[1].maybeType;
      const $name = ($expr_)[1].name;
      return ((sp_not_equal)($maybeModule, $c$$src$Maybe$$Nothing)
        ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("Attribute names must be single words", $c$$src$Core$$Nil))
        : ((sp_not_equal)($attrPath, $c$$src$Core$$Nil)
          ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("Attribute names can't contain dots", $c$$src$Core$$Nil))
          : ($c$$src$Result$$Ok)(({
            first: $pos,
            second: $name,
            third: $maybeType,
          }))));
    }))()
    : (true
      ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("I need a lowercase attribute name here", $c$$src$Core$$Nil))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 282:4', (sp_toHuman)($expr_))));
});

const $u$$src$Compiler$MakeCanonical$$translateAndInsertRecordAttributeType = (($ro, $faAttr, $caAttrs) => {
  return (($c$$src$Result$$onOk)((($4) => {
    const $pos = $4.first;
    const $name = $4.second;
    const $maybeFaType = $4.third;
    return (($c$$src$Dict$$member)($name, $caAttrs)
      ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)(("Duplicate attribute name: " + $name), $c$$src$Core$$Nil))
      : ((($maybeFaType)[0] === "$Nothing")
        ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)(("I need to see the type of this attribute, `" + ($name + " as TheType`")), $c$$src$Core$$Nil))
        : ((($maybeFaType)[0] === "$Just")
          ? ((() => {
            const $faType = ($maybeFaType)[1];
            return (($c$$src$Result$$onOk)((($caType) => {
              return ((sp_not_equal)($faAttr.maybeExpr, $c$$src$Maybe$$Nothing)
                ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("I need a type here; `=` is for assignign values", $c$$src$Core$$Nil))
                : ($c$$src$Result$$Ok)(((($0) => {
                  return ($c$$src$Dict$$insert)($name, $caType, $0);
                }))($caAttrs)));
            })))(((($0) => {
              return ($u$$src$Compiler$MakeCanonical$$translateRawType)($ro, $0);
            }))($faType));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1260:8', (sp_toHuman)($maybeFaType)))));
  })))(($u$$src$Compiler$MakeCanonical$$translateAttributeName)($ro, $faAttr.name));
});

const $u$$src$Compiler$MakeCanonical$$translatePoly = (($ro, $expr) => {
  const $3 = $expr;
  const $expr_ = ($3)[3];
  const $pos = ($3)[2];
  return (((($expr_)[0] === "$UnopCall") && ((($expr_)[1])[0] === "$UnopUnique"))
    ? ((() => {
      const $e = ($expr_)[2];
      return ($c$$src$Result$$Ok)(({
        first: $c$$src$Compiler$Ast$$Uni,
        second: $e,
      }));
    }))()
    : ((($expr_)[0] === "$Poly")
      ? ((() => {
        const $numberAsString = ($expr_)[1];
        const $e = ($expr_)[2];
        const $4 = (text_toNumber)($numberAsString);
        return ((($4)[0] === "$Nothing")
          ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("I need an integer number here", $c$$src$Core$$Nil))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $n = ($4)[1];
              return ($c$$src$Result$$Ok)(({
                first: ($c$$src$Compiler$Ast$$Depends)($n),
                second: $e,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1306:12', (sp_toHuman)($4))));
      }))()
      : (true
        ? ($c$$src$Result$$Ok)(({
          first: $c$$src$Compiler$Ast$$Imm,
          second: $expr,
        }))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1300:4', (sp_toHuman)($expr_)))));
});

const $u$$src$Compiler$MakeCanonical$$translateFullType = (($ro, $expr) => {
  return (($c$$src$Result$$onOk)((($3) => {
    const $uni = $3.first;
    const $e = $3.second;
    return (($c$$src$Result$$onOk)((($raw) => {
      return ($c$$src$Result$$Ok)(({
        raw: $raw,
        uni: $uni,
      }));
    })))(($u$$src$Compiler$MakeCanonical$$translateRawType)($ro, $e));
  })))(((($0) => {
    return ($u$$src$Compiler$MakeCanonical$$translatePoly)($ro, $0);
  }))($expr));
});

const $u$$src$Compiler$MakeCanonical$$translateTuple = (($ro, $translate, $chain) => {
  const $faExpressions = ($c$$src$Compiler$FormattableAst$$binopChainExpressions)($chain);
  return (($c$$src$Result$$onOk)((($items) => {
    const $pos = ($c$$src$List$$for)($c$$src$Compiler$Pos$$G, $faExpressions, (($6, $z) => {
      const $p = ($6)[2];
      return ($c$$src$Compiler$Pos$$range)($p, $z);
    }));
    return (((($items)[0] === "$Cons") && (((($items)[2])[0] === "$Cons") && (((($items)[2])[2])[0] === "$Nil")))
      ? ((() => {
        const $ca1 = ($items)[1];
        const $ca2 = (($items)[2])[1];
        return ($c$$src$Result$$Ok)(((($0) => {
          return ($c$$src$Dict$$insert)("second", $ca2, $0);
        }))(((($0) => {
          return ($c$$src$Dict$$insert)("first", $ca1, $0);
        }))($c$$src$Dict$$empty)));
      }))()
      : (((($items)[0] === "$Cons") && (((($items)[2])[0] === "$Cons") && ((((($items)[2])[2])[0] === "$Cons") && ((((($items)[2])[2])[2])[0] === "$Nil"))))
        ? ((() => {
          const $ca1 = ($items)[1];
          const $ca2 = (($items)[2])[1];
          const $ca3 = ((($items)[2])[2])[1];
          return ($c$$src$Result$$Ok)(((($0) => {
            return ($c$$src$Dict$$insert)("third", $ca3, $0);
          }))(((($0) => {
            return ($c$$src$Dict$$insert)("second", $ca2, $0);
          }))(((($0) => {
            return ($c$$src$Dict$$insert)("first", $ca1, $0);
          }))($c$$src$Dict$$empty))));
        }))()
        : (true
          ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("tuples can be only of size 2 or 3, use a record instead", $c$$src$Core$$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 407:4', (sp_toHuman)($items)))));
  })))(((($0) => {
    return ($c$$src$List$$mapRes)($translate, $0);
  }))($faExpressions));
});

const $u$$src$Compiler$MakeCanonical$$translateTypeFunctionParameter = (($ro, $expression) => {
  const $3 = $expression;
  const $expr_ = ($3)[3];
  return (((($expr_)[0] === "$UnopCall") && ((($expr_)[1])[0] === "$UnopRecycle"))
    ? ((() => {
      const $faOperand = ($expr_)[2];
      return ((($0) => {
        return ($c$$src$Result$$map)($c$$src$Compiler$CanonicalAst$$ParRe, $0);
      }))(((($0) => {
        return ($u$$src$Compiler$MakeCanonical$$translateRawType)($ro, $0);
      }))($faOperand));
    }))()
    : (true
      ? ((($0) => {
        return ($c$$src$Result$$map)($c$$src$Compiler$CanonicalAst$$ParSp, $0);
      }))(((($0) => {
        return ($u$$src$Compiler$MakeCanonical$$translateFullType)($ro, $0);
      }))($expression))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1282:4', (sp_toHuman)($expr_))));
});

const $u$$src$Compiler$MakeCanonical$$translateRawType = (($ro, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Uppercase")
    ? ((() => {
      const $maybeModule = ($expr_)[1].maybeModule;
      const $name = ($expr_)[1].name;
      return (($c$$src$Result$$onOk)((($usr) => {
        return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$TypeNamed)($pos, $usr, $c$$src$Core$$Nil));
      })))(($u$$src$Compiler$MakeCanonical$$resolveToUsr)($ro, $pos, $maybeModule, $name));
    }))()
    : ((($expr_)[0] === "$Lowercase")
      ? ((() => {
        const $attrPath = ($expr_)[1].attrPath;
        const $maybeModule = ($expr_)[1].maybeModule;
        const $maybeType = ($expr_)[1].maybeType;
        const $name = ($expr_)[1].name;
        return ((sp_not_equal)($maybeType, $c$$src$Maybe$$Nothing)
          ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("Can't really specify the type of a type.", $c$$src$Core$$Nil))
          : ((sp_not_equal)($maybeModule, $c$$src$Maybe$$Nothing)
            ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("no modules for tyvars!", $c$$src$Core$$Nil))
            : ((sp_not_equal)($attrPath, $c$$src$Core$$Nil)
              ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("no attributes for tyvars!", $c$$src$Core$$Nil))
              : ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$TypeAnnotationVariable)($pos, $name)))));
      }))()
      : (((($expr_)[0] === "$Call") && ((($expr_)[1])[0] === "$Expression"))
        ? ((() => {
          const $refPos = (($expr_)[1])[2];
          const $ref = (($expr_)[1])[3];
          const $faArgs = ($expr_)[2];
          return ((($ref)[0] === "$Uppercase")
            ? ((() => {
              const $maybeModule = ($ref)[1].maybeModule;
              const $name = ($ref)[1].name;
              return (($c$$src$Result$$onOk)((($caArgs) => {
                return (($c$$src$Result$$onOk)((($usr) => {
                  return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$TypeNamed)($pos, $usr, $caArgs));
                })))(($u$$src$Compiler$MakeCanonical$$resolveToUsr)($ro, $pos, $maybeModule, $name));
              })))(((($0) => {
                return ($c$$src$List$$mapRes)((($0) => {
                  return ($u$$src$Compiler$MakeCanonical$$translateRawType)($ro, $0);
                }), $0);
              }))($faArgs));
            }))()
            : (true
              ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $refPos, ($c$$src$Core$$Cons)("I need an Uppercase type name here", $c$$src$Core$$Nil))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1344:12', (sp_toHuman)($ref))));
        }))()
        : ((($expr_)[0] === "$List")
          ? ((() => {
            const $dotsAndItems = ($expr_)[2];
            return ((($dotsAndItems)[0] === "$Nil")
              ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("You need to specify the type of the List items", $c$$src$Core$$Nil))
              : (((($dotsAndItems)[0] === "$Cons") && ((($dotsAndItems)[2])[0] === "$Nil"))
                ? ((() => {
                  const $hasDots = ($dotsAndItems)[1].first;
                  const $faItem = ($dotsAndItems)[1].second;
                  return ($hasDots
                    ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("No need to use dots here", $c$$src$Core$$Nil))
                    : (($c$$src$Result$$onOk)((($caItem) => {
                      return ($c$$src$Result$$Ok)(($u$$src$Compiler$CoreDefs$$listType)($caItem));
                    })))(($u$$src$Compiler$MakeCanonical$$translateRawType)($ro, $faItem)));
                }))()
                : (true
                  ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("List items must all have the same type, so you can specify only one type", $c$$src$Core$$Nil))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1358:12', (sp_toHuman)($dotsAndItems)))));
          }))()
          : ((($expr_)[0] === "$Record")
            ? ((() => {
              const $attrs = ($expr_)[1].attrs;
              const $maybeExtension = ($expr_)[1].maybeExtension;
              return ((sp_not_equal)($maybeExtension, $c$$src$Maybe$$Nothing)
                ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("Experimentally, extensible type annotations are disabled", $c$$src$Core$$Nil))
                : (($c$$src$Result$$onOk)((($caAttrs) => {
                  return ($c$$src$Result$$Ok)(((($0) => {
                    return ($c$$src$Compiler$CanonicalAst$$TypeRecord)($pos, $0);
                  }))($caAttrs));
                })))(((($0) => {
                  return ($c$$src$List$$forRes)($0, $attrs, (($0, $1) => {
                    return ($u$$src$Compiler$MakeCanonical$$translateAndInsertRecordAttributeType)($ro, $0, $1);
                  }));
                }))($c$$src$Dict$$empty)));
            }))()
            : ((($expr_)[0] === "$Fn")
              ? ((() => {
                const $faParams = ($expr_)[2];
                const $faReturn = ($expr_)[3];
                return (($c$$src$Result$$onOk)((($caParams) => {
                  return (($c$$src$Result$$onOk)((($caReturn) => {
                    return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$TypeFn)($pos, $caParams, $caReturn));
                  })))(((($0) => {
                    return ($u$$src$Compiler$MakeCanonical$$translateFullType)($ro, $0);
                  }))($faReturn));
                })))(((($0) => {
                  return ($c$$src$List$$mapRes)((($0) => {
                    return ($u$$src$Compiler$MakeCanonical$$translateTypeFunctionParameter)($ro, $0);
                  }), $0);
                }))($faParams));
              }))()
              : ((($expr_)[0] === "$BinopChain")
                ? ((() => {
                  const $precedence = ($expr_)[1];
                  const $chain = ($expr_)[2];
                  return ((sp_equal)($precedence, $c$$src$Compiler$Op$$precedence_tuple)
                    ? (($c$$src$Result$$onOk)((($recordAttrs) => {
                      return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$TypeRecord)($pos, $recordAttrs));
                    })))(((($0) => {
                      return ($u$$src$Compiler$MakeCanonical$$translateTuple)($ro, (($0) => {
                        return ($u$$src$Compiler$MakeCanonical$$translateRawType)($ro, $0);
                      }), $0);
                    }))($chain))
                    : ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("This operator can't be used in type definitions", ($c$$src$Core$$Cons)((sp_toHuman)($expr_), $c$$src$Core$$Nil))));
                }))()
                : (true
                  ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)("Not sure what's up with this type =|", ($c$$src$Core$$Cons)((sp_toHuman)($expr_), $c$$src$Core$$Nil)))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1326:4', (sp_toHuman)($expr_))))))))));
});

const $u$$src$Compiler$MakeCanonical$$translateConstructor = (($varType, $varUsr, $varPars, $2, $1) => {
  const $pos = ($2)[2];
  const $expr_ = ($2)[3];
  const $constructors = $1.first;
  const $env = $1.second;
  return (($c$$src$Result$$onOk)((($6) => {
    const $name = $6.first;
    const $faPars = $6.second;
    return (($c$$src$Result$$onOk)(((_0) => {
      return (($c$$src$Result$$onOk)((($ins) => {
        const $tyvars = ($c$$src$List$$for)($c$$src$Dict$$empty, $ins, (($in, $dict) => {
          return ($c$$src$Dict$$join)(($c$$src$Compiler$CanonicalAst$$typeTyvars)($in), $dict);
        }));
        const $undeclaredTyvars = ($c$$src$Dict$$diff)($tyvars, $varPars);
        return (($c$$src$Result$$onOk)(((_0) => {
          return (($c$$src$Result$$onOk)((($newEnv) => {
            const $directDeps = ((($0) => {
              return ($c$$src$List$$for)($0, $ins, $u$$src$Compiler$MakeCanonical$$typeDeps);
            }))(($c$$src$Dict$$ofOne)($varUsr, $c$$src$Compiler$Meta$$TypeDependency));
            const $11 = $varUsr;
            const $umr = ($11)[1];
            const $c = ({
              constructorUsr: ($c$$src$Compiler$Meta$$USR)($umr, $name),
              directDeps: $directDeps,
              ins: $ins,
              name: $name,
              out: $varType,
              pos: $pos,
              variantTypeUsr: $varUsr,
            });
            return ($c$$src$Result$$Ok)(({
              first: ($c$$src$Dict$$insert)($name, $c, $constructors),
              second: $newEnv,
            }));
          })))(((($0) => {
            return ($u$$src$Compiler$MakeCanonical$$insertPatternNames)(true, ($c$$src$Compiler$CanonicalAst$$PatternAny)($pos, ($c$$src$Maybe$$Just)($name), $c$$src$Maybe$$Nothing), $0);
          }))($env));
        })))(((sp_equal)($undeclaredTyvars, $c$$src$Dict$$empty)
          ? ($c$$src$Result$$Ok)(null)
          : ((() => {
            const $toError = (($9) => {
              const $n = $9.first;
              const $p = $9.second;
              return ($u$$src$Compiler$Error$$Simple)($env.ro.errorModule, $p, ($c$$src$Core$$Cons)(("Undeclared type variable: " + $n), $c$$src$Core$$Nil));
            });
            return ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Nested)(((($0) => {
              return ($c$$src$List$$map)($toError, $0);
            }))(($c$$src$Dict$$toList)($undeclaredTyvars))));
          }))()));
      })))(((($0) => {
        return ($c$$src$List$$mapRes)((($0) => {
          return ($u$$src$Compiler$MakeCanonical$$translateRawType)($env.ro, $0);
        }), $0);
      }))($faPars));
    })))((($c$$src$Dict$$member)($name, $constructors)
      ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)(("constructor " + ($name + " is duplicate")), $c$$src$Core$$Nil))
      : ($c$$src$Result$$Ok)(null)));
  })))((((($expr_)[0] === "$Constructor") && ((($expr_)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($expr_)[1].name;
      return ($c$$src$Result$$Ok)(({
        first: $name,
        second: $c$$src$Core$$Nil,
      }));
    }))()
    : (((($expr_)[0] === "$Call") && (((($expr_)[1])[0] === "$Expression") && ((((($expr_)[1])[3])[0] === "$Constructor") && ((((($expr_)[1])[3])[1].maybeModule)[0] === "$Nothing"))))
      ? ((() => {
        const $name = ((($expr_)[1])[3])[1].name;
        const $pars = ($expr_)[2];
        return ($c$$src$Result$$Ok)(({
          first: $name,
          second: $pars,
        }));
      }))()
      : (true
        ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("I need a 'constructor name here!", $c$$src$Core$$Nil))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1414:4', (sp_toHuman)($expr_))))));
});

const $u$$src$Compiler$MakeCanonical$$argumentDeps = (($arg, $deps) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $e = ($arg)[1];
      return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($e, $deps);
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? $deps
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 197:4', (sp_toHuman)($arg))));
});

const $u$$src$Compiler$MakeCanonical$$patternDeps = (($pattern, $deps) => {
  return ((($pattern)[0] === "$PatternConstructor")
    ? ((() => {
      const $usr = ($pattern)[2];
      const $ps = ($pattern)[3];
      return ((($0) => {
        return ($c$$src$List$$for)($0, $ps, $u$$src$Compiler$MakeCanonical$$patternDeps);
      }))(((($0) => {
        return ($c$$src$Dict$$insert)($usr, $c$$src$Compiler$Meta$$ConstructorDependency, $0);
      }))($deps));
    }))()
    : ((($pattern)[0] === "$PatternRecord")
      ? ((() => {
        const $completeness = ($pattern)[2];
        const $ps = ($pattern)[3];
        return ($c$$src$Dict$$for)($deps, $ps, (($k, $v, $a) => {
          return ($u$$src$Compiler$MakeCanonical$$patternDeps)($v, $a);
        }));
      }))()
      : (((($pattern)[0] === "$PatternAny") && ((($pattern)[3])[0] === "$Just"))
        ? ((() => {
          const $annotation = (($pattern)[3])[1];
          return ($u$$src$Compiler$MakeCanonical$$typeDeps)($annotation.raw, $deps);
        }))()
        : (((($pattern)[0] === "$PatternAny") && ((($pattern)[3])[0] === "$Nothing"))
          ? $deps
          : ((($pattern)[0] === "$PatternLiteralNumber")
            ? $deps
            : ((($pattern)[0] === "$PatternLiteralText")
              ? $deps
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 104:4', (sp_toHuman)($pattern))))))));
});

const $u$$src$Compiler$MakeCanonical$$parameterDeps = (($par, $deps) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $pa = ($par)[2];
      return ($u$$src$Compiler$MakeCanonical$$patternDeps)($pa, $deps);
    }))()
    : (true
      ? $deps
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 204:4', (sp_toHuman)($par))));
});

const $u$$src$Compiler$MakeCanonical$$expressionDeps = (($expression, $deps) => {
  return ((($expression)[0] === "$LiteralNumber")
    ? $deps
    : ((($expression)[0] === "$LiteralText")
      ? $deps
      : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
        ? ((() => {
          const $usr = (($expression)[2])[1];
          return ($c$$src$Dict$$insert)($usr, $c$$src$Compiler$Meta$$ValueDependency, $deps);
        }))()
        : ((($expression)[0] === "$Variable")
          ? $deps
          : ((($expression)[0] === "$Constructor")
            ? ((() => {
              const $usr = ($expression)[2];
              return ($c$$src$Dict$$insert)($usr, $c$$src$Compiler$Meta$$ConstructorDependency, $deps);
            }))()
            : ((($expression)[0] === "$Fn")
              ? ((() => {
                const $pars = ($expression)[2];
                const $body = ($expression)[3];
                return ((($0) => {
                  return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($body, $0);
                }))(((($0) => {
                  return ($c$$src$List$$for)($0, $pars, $u$$src$Compiler$MakeCanonical$$parameterDeps);
                }))($deps));
              }))()
              : (((($expression)[0] === "$Record") && ((($expression)[2])[0] === "$Nothing"))
                ? ((() => {
                  const $exprByName = ($expression)[3];
                  return ($c$$src$Dict$$for)($deps, $exprByName, (($name, $v, $a) => {
                    return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($v, $a);
                  }));
                }))()
                : (((($expression)[0] === "$Record") && ((($expression)[2])[0] === "$Just"))
                  ? ((() => {
                    const $expr = (($expression)[2])[1];
                    const $exprByName = ($expression)[3];
                    return ((($0) => {
                      return ($c$$src$Dict$$for)($0, $exprByName, (($name, $v, $a) => {
                        return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($v, $a);
                      }));
                    }))(((($0) => {
                      return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($expr, $0);
                    }))($deps));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $exprByName = ($expression)[3];
                      return ($c$$src$Dict$$for)($deps, $exprByName, (($name, $v, $a) => {
                        return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($v, $a);
                      }));
                    }))()
                    : ((($expression)[0] === "$RecordAccess")
                      ? ((() => {
                        const $e = ($expression)[3];
                        return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($e, $deps);
                      }))()
                      : ((($expression)[0] === "$Call")
                        ? ((() => {
                          const $e0 = ($expression)[2];
                          const $args = ($expression)[3];
                          return ((($0) => {
                            return ($c$$src$List$$for)($0, $args, $u$$src$Compiler$MakeCanonical$$argumentDeps);
                          }))(((($0) => {
                            return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($e0, $0);
                          }))($deps));
                        }))()
                        : ((($expression)[0] === "$If")
                          ? ((() => {
                            const $args = ($expression)[2];
                            return ((($0) => {
                              return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($args.false, $0);
                            }))(((($0) => {
                              return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($args.true, $0);
                            }))(((($0) => {
                              return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($args.condition, $0);
                            }))($deps)));
                          }))()
                          : ((($expression)[0] === "$Try")
                            ? ((() => {
                              const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                              const $value = ($expression)[2].value;
                              const $addDeps = (($4, $d) => {
                                const $u = $4.first;
                                const $p = $4.second;
                                const $b = $4.third;
                                return ((($0) => {
                                  return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($b, $0);
                                }))(((($0) => {
                                  return ($u$$src$Compiler$MakeCanonical$$patternDeps)($p, $0);
                                }))($d));
                              });
                              return ((($0) => {
                                return ($c$$src$List$$for)($0, $patternsAndExpressions, $addDeps);
                              }))(((($0) => {
                                return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($value, $0);
                              }))($deps));
                            }))()
                            : ((($expression)[0] === "$LetIn")
                              ? ((() => {
                                const $valueDef = ($expression)[1];
                                const $e = ($expression)[2];
                                return ((($0) => {
                                  return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($e, $0);
                                }))(((($0) => {
                                  return ($u$$src$Compiler$MakeCanonical$$expressionDeps)($valueDef.body, $0);
                                }))(((($0) => {
                                  return ($u$$src$Compiler$MakeCanonical$$patternDeps)($valueDef.pattern, $0);
                                }))($deps)));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 130:4', (sp_toHuman)($expression))))))))))))))));
});

const $u$$src$Compiler$MakeCanonical$$escapeLiteralText = (($singleOrTriple, $l) => {
  return ((($singleOrTriple)[0] === "$SingleQuote")
    ? $l
    : ((($singleOrTriple)[0] === "$TripleQuote")
      ? ((($0) => {
        return ($c$$src$Text$$replace)("\n", "\\n", $0);
      }))(((($0) => {
        return ($c$$src$Text$$replace)("\"", "\\\"", $0);
      }))($l))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 551:8', (sp_toHuman)($singleOrTriple))));
});

const $u$$src$Compiler$MakeCanonical$$isPlaceholder = (($1) => {
  const $expr = ($1)[3];
  return ((($expr)[0] === "$ArgumentPlaceholder")
    ? true
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1058:4', (sp_toHuman)($expr))));
});

const $u$$src$Compiler$MakeCanonical$$makePartiallyAppliedFunction = (($env, $pos, $placeholdersCount, $body) => {
  const $ex = (($0) => {
    return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $pos, $0);
  });
  return ((($0) => {
    return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
  }))(($ex)(((($0) => {
    return ($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Inline, $0, ($ex)($body));
  }))(((($0) => {
    return ($c$$src$List$$map)((($x) => {
      return ($ex)(($c$$src$Compiler$FormattableAst$$ResolvedArgumentPlaceholder)($x));
    }), $0);
  }))(($c$$src$List$$range)(0, ($placeholdersCount - 1))))));
});

const $u$$src$Compiler$MakeCanonical$$translateArgument = (($env, $faExpression) => {
  const $3 = $faExpression;
  const $expr = ($3)[3];
  const $pos = ($3)[2];
  return (((($expr)[0] === "$UnopCall") && (((($expr)[1])[0] === "$UnopRecycle") && ((($expr)[2])[0] === "$Expression")))
    ? ((() => {
      const $faOperand = (($expr)[2])[3];
      return ((($faOperand)[0] === "$Lowercase")
        ? ((() => {
          const $attrPath = ($faOperand)[1].attrPath;
          const $maybeModule = ($faOperand)[1].maybeModule;
          const $maybeType = ($faOperand)[1].maybeType;
          const $name = ($faOperand)[1].name;
          return ((sp_not_equal)($maybeType, $c$$src$Maybe$$Nothing)
            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Sorry, at least for now annotations are not supported here", $c$$src$Core$$Nil))
            : ((sp_not_equal)($maybeModule, $c$$src$Maybe$$Nothing)
              ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Only values declared inside a function scope can be mutated!", $c$$src$Core$$Nil))
              : ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$ArgumentRecycle)($pos, $name, $attrPath))));
        }))()
        : (true
          ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("I can recycle only variables!", $c$$src$Core$$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1030:12', (sp_toHuman)($faOperand))));
    }))()
    : ((($expr)[0] === "$ArgumentPlaceholder")
      ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("compiler error: this should have been eliminated already", $c$$src$Core$$Nil))
      : ((($expr)[0] === "$ResolvedArgumentPlaceholder")
        ? ((() => {
          const $n = ($expr)[1];
          return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($pos, ($c$$src$Compiler$Ast$$RefPlaceholder)($n))));
        }))()
        : (true
          ? (($c$$src$Result$$onOk)((($caExpr) => {
            return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)($caExpr));
          })))(((($0) => {
            return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
          }))($faExpression))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1027:4', (sp_toHuman)($expr))))));
});

const $u$$src$Compiler$MakeCanonical$$resolvePipe = (($env, $pos, $opChain) => {
  return (($c$$src$Compiler$FormattableAst$$binopChainAllBinops)((($sep) => {
    return (sp_equal)($sep.usr, $u$$src$Compiler$CoreDefs$$sendRight.usr);
  }), $opChain)
    ? ((() => {
      const $4 = $opChain;
      const $chainTail = $4.second;
      const $head = $4.first;
      return ($c$$src$Result$$Ok)(($c$$src$List$$for)($head, $chainTail, (($6, $acc) => {
        const $sep = $6.first;
        const $faExp = $6.second;
        const $7 = $faExp;
        const $p = ($7)[2];
        return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $p, ($c$$src$Compiler$FormattableAst$$Call)($faExp, ($c$$src$Core$$Cons)($acc, $c$$src$Core$$Nil)));
      })));
    }))()
    : (($c$$src$Compiler$FormattableAst$$binopChainAllBinops)((($sep) => {
      return (sp_equal)($sep.usr, $u$$src$Compiler$CoreDefs$$sendLeft.usr);
    }), $opChain)
      ? ((() => {
        const $4 = ($c$$src$Compiler$FormattableAst$$binopChainReverse)($opChain);
        const $body = $4.second;
        const $last = $4.first;
        return ($c$$src$Result$$Ok)(($c$$src$List$$for)($last, $body, (($6, $acc) => {
          const $sep = $6.first;
          const $faExp = $6.second;
          const $7 = $faExp;
          const $p = ($7)[2];
          return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $p, ($c$$src$Compiler$FormattableAst$$Call)($faExp, ($c$$src$Core$$Cons)($acc, $c$$src$Core$$Nil)));
        })));
      }))()
      : ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Mixing `>>` and `<<` is ambiguous. Use parens!", $c$$src$Core$$Nil))));
});

const $u$$src$Compiler$MakeCanonical$$sameDirectionAs = (($a, $b) => {
  return ((sp_equal)($a.symbol, $b.symbol)
    ? true
    : ((() => {
      const $3 = $a.symbol;
      return ((">" === $3)
        ? (sp_equal)($b.symbol, ">=")
        : ((">=" === $3)
          ? (sp_equal)($b.symbol, ">")
          : (("<" === $3)
            ? (sp_equal)($b.symbol, "<=")
            : (("<=" === $3)
              ? (sp_equal)($b.symbol, "<")
              : (true
                ? false
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1223:8', (sp_toHuman)($3)))))));
    }))());
});

const $u$$src$Compiler$MakeCanonical$$translateRightAssociativeBinopChain = (($env, $pos, $1) => {
  const $faLeft = $1.first;
  const $faOpsAndRight = $1.second;
  return ((($faOpsAndRight)[0] === "$Nil")
    ? ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $faLeft)
    : ((($faOpsAndRight)[0] === "$Cons")
      ? ((() => {
        const $op = ($faOpsAndRight)[1].first;
        const $faRight = ($faOpsAndRight)[1].second;
        const $faTail = ($faOpsAndRight)[2];
        return (($c$$src$Result$$onOk)((($caLeft) => {
          return (($c$$src$Result$$onOk)((($caRight) => {
            const $caRef = ($c$$src$Compiler$CanonicalAst$$Variable)($op.pos, ($c$$src$Compiler$Ast$$RefGlobal)($op.usr));
            return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Call)($pos, $caRef, ($c$$src$Core$$Cons)($caLeft, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)($caRight), $c$$src$Core$$Nil))));
          })))(($u$$src$Compiler$MakeCanonical$$translateRightAssociativeBinopChain)($env, $pos, ({
            first: $faRight,
            second: $faTail,
          })));
        })))(($u$$src$Compiler$MakeCanonical$$translateArgument)($env, $faLeft));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1233:4', (sp_toHuman)($faOpsAndRight))));
});

const $u$$src$Compiler$MakeCanonical$$translateComparison = (($env, $pos, $opChain) => {
  const $4 = $opChain.second;
  return ((($4)[0] === "$Nil")
    ? ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $opChain.first)
    : (((($4)[0] === "$Cons") && ((($4)[2])[0] === "$Nil"))
      ? ((() => {
        const $sep = ($4)[1].first;
        const $second = ($4)[1].second;
        return ($u$$src$Compiler$MakeCanonical$$translateRightAssociativeBinopChain)($env, $pos, $opChain);
      }))()
      : ((($4)[0] === "$Cons")
        ? ((() => {
          const $firstSep = ($4)[1].first;
          const $second = ($4)[1].second;
          const $moar = ($4)[2];
          return (($c$$src$Compiler$FormattableAst$$binopChainAllBinops)((($0) => {
            return ($u$$src$Compiler$MakeCanonical$$sameDirectionAs)($firstSep, $0);
          }), $opChain)
            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("TODO: not (yet) implemented: compops expansion", $c$$src$Core$$Nil))
            : ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("can't mix comparison ops with different direction", $c$$src$Core$$Nil)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1170:4', (sp_toHuman)($4)))));
});

const $u$$src$Compiler$MakeCanonical$$translateLogical = (($env, $pos, $opChain) => {
  const $allSame = (($c$$src$Compiler$FormattableAst$$binopChainAllBinops)((($sep) => {
    return (sp_equal)($sep.usr, $u$$src$Compiler$CoreDefs$$and_.usr);
  }), $opChain) || ($c$$src$Compiler$FormattableAst$$binopChainAllBinops)((($sep) => {
    return (sp_equal)($sep.usr, $u$$src$Compiler$CoreDefs$$or_.usr);
  }), $opChain));
  return ($allSame
    ? ($u$$src$Compiler$MakeCanonical$$translateRightAssociativeBinopChain)($env, $pos, $opChain)
    : ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Mixing `and` and `or` is ambiguous. Use parens!", $c$$src$Core$$Nil)));
});

const $u$$src$Compiler$MakeCanonical$$translateMutop = (($env, $pos, $1) => {
  const $left = $1.first;
  const $chainTail = $1.second;
  return ((($chainTail)[0] === "$Nil")
    ? ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $left)
    : (((($chainTail)[0] === "$Cons") && ((($chainTail)[2])[0] === "$Nil"))
      ? ((() => {
        const $op = ($chainTail)[1].first;
        const $right = ($chainTail)[1].second;
        const $caRef = ($c$$src$Compiler$CanonicalAst$$Variable)($op.pos, ($c$$src$Compiler$Ast$$RefGlobal)($op.usr));
        return (($c$$src$Result$$onOk)((($caArgs) => {
          return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Call)($pos, $caRef, $caArgs));
        })))(((($0) => {
          return ($c$$src$List$$mapRes)((($0) => {
            return ($u$$src$Compiler$MakeCanonical$$translateArgument)($env, $0);
          }), $0);
        }))(($c$$src$Core$$Cons)($left, ($c$$src$Core$$Cons)($right, $c$$src$Core$$Nil))));
      }))()
      : (true
        ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("mutops can't be chained", $c$$src$Core$$Nil))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1200:4', (sp_toHuman)($chainTail)))));
});

const $u$$src$Compiler$MakeCanonical$$translateTupleExpression = (($env, $pos, $1) => {
  const $one = $1.first;
  const $chainTail = $1.second;
  return ((($chainTail)[0] === "$Nil")
    ? ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $one)
    : (((($chainTail)[0] === "$Cons") && ((($chainTail)[2])[0] === "$Nil"))
      ? ((() => {
        const $two = ($chainTail)[1].second;
        return (($c$$src$Result$$onOk)((($first) => {
          return (($c$$src$Result$$onOk)((($second) => {
            return ($c$$src$Result$$Ok)(((($0) => {
              return ($c$$src$Compiler$CanonicalAst$$Record)($pos, $c$$src$Maybe$$Nothing, $0);
            }))(((($0) => {
              return ($c$$src$Dict$$insert)("second", $second, $0);
            }))(((($0) => {
              return ($c$$src$Dict$$insert)("first", $first, $0);
            }))($c$$src$Dict$$empty))));
          })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $two));
        })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $one));
      }))()
      : (((($chainTail)[0] === "$Cons") && (((($chainTail)[2])[0] === "$Cons") && (((($chainTail)[2])[2])[0] === "$Nil")))
        ? ((() => {
          const $two = ($chainTail)[1].second;
          const $three = (($chainTail)[2])[1].second;
          return (($c$$src$Result$$onOk)((($first) => {
            return (($c$$src$Result$$onOk)((($second) => {
              return (($c$$src$Result$$onOk)((($third) => {
                return ($c$$src$Result$$Ok)(((($0) => {
                  return ($c$$src$Compiler$CanonicalAst$$Record)($pos, $c$$src$Maybe$$Nothing, $0);
                }))(((($0) => {
                  return ($c$$src$Dict$$insert)("third", $third, $0);
                }))(((($0) => {
                  return ($c$$src$Dict$$insert)("second", $second, $0);
                }))(((($0) => {
                  return ($c$$src$Dict$$insert)("first", $first, $0);
                }))($c$$src$Dict$$empty)))));
              })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $three));
            })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $two));
          })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $one));
        }))()
        : (true
          ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Tuples can't have more than 3 items, use a record instead.", $c$$src$Core$$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1134:4', (sp_toHuman)($chainTail))))));
});

const $u$$src$Compiler$MakeCanonical$$translateBinopChain = (($env, $pos, $group, $opChain) => {
  const $toExpression = (($0) => {
    return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $pos, $0);
  });
  const $5 = (($u$$src$Compiler$MakeCanonical$$isPlaceholder)($opChain.first)
    ? ({
      first: 1,
      second: ($toExpression)(($c$$src$Compiler$FormattableAst$$ResolvedArgumentPlaceholder)(0)),
    })
    : ({
      first: 0,
      second: $opChain.first,
    }));
  const $head = $5.second;
  const $cnt0 = $5.first;
  const $6 = ($c$$src$List$$for)(({
    first: $cnt0,
    second: $c$$src$Core$$Nil,
  }), $opChain.second, (($8, $7) => {
    const $op = $8.first;
    const $exp = $8.second;
    const $cnt = $7.first;
    const $rev = $7.second;
    return (($u$$src$Compiler$MakeCanonical$$isPlaceholder)($exp)
      ? ((() => {
        const $9 = $exp;
        const $p = ($9)[2];
        const $c = ($9)[1];
        return ({
          first: ($cnt + 1),
          second: ($c$$src$Core$$Cons)(({
            first: $op,
            second: ($c$$src$Compiler$FormattableAst$$Expression)($c, $p, ($c$$src$Compiler$FormattableAst$$ResolvedArgumentPlaceholder)($cnt)),
          }), $rev),
        });
      }))()
      : ({
        first: $cnt,
        second: ($c$$src$Core$$Cons)(({
          first: $op,
          second: $exp,
        }), $rev),
      }));
  }));
  const $reversedChainTail = $6.second;
  const $placeholdersCount = $6.first;
  return (($placeholdersCount > 0)
    ? ((($0) => {
      return ($u$$src$Compiler$MakeCanonical$$makePartiallyAppliedFunction)($env, $pos, $placeholdersCount, $0);
    }))(($c$$src$Compiler$FormattableAst$$BinopChain)($group, ({
      first: $head,
      second: ($c$$src$List$$reverse)($reversedChainTail),
    })))
    : ((sp_equal)($group, $c$$src$Compiler$Op$$precedence_pipe)
      ? (($c$$src$Result$$onOk)((($0) => {
        return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
      })))(($u$$src$Compiler$MakeCanonical$$resolvePipe)($env, $pos, $opChain))
      : ((sp_equal)($group, $c$$src$Compiler$Op$$precedence_tuple)
        ? ($u$$src$Compiler$MakeCanonical$$translateTupleExpression)($env, $pos, $opChain)
        : ((sp_equal)($group, $c$$src$Compiler$Op$$precedence_comparison)
          ? ($u$$src$Compiler$MakeCanonical$$translateComparison)($env, $pos, $opChain)
          : ((sp_equal)($group, $c$$src$Compiler$Op$$precedence_logical)
            ? ($u$$src$Compiler$MakeCanonical$$translateLogical)($env, $pos, $opChain)
            : ((sp_equal)($group, $c$$src$Compiler$Op$$precedence_mutop)
              ? ($u$$src$Compiler$MakeCanonical$$translateMutop)($env, $pos, $opChain)
              : ($u$$src$Compiler$MakeCanonical$$translateRightAssociativeBinopChain)($env, $pos, $opChain)))))));
});

const $u$$src$Compiler$MakeCanonical$$translateNumber = (($ro, $isPercent, $constructor, $pos, $numberAsText) => {
  const $6 = (text_toNumber)(($c$$src$Text$$replace)("_", "", $numberAsText));
  return ((($6)[0] === "$Nothing")
    ? ($u$$src$Compiler$MakeCanonical$$erroro)($ro, $pos, ($c$$src$Core$$Cons)(("invalid number: `" + ($numberAsText + "`")), ($c$$src$Core$$Cons)("TODO link to documentation on valid number formats", $c$$src$Core$$Nil)))
    : ((($6)[0] === "$Just")
      ? ((() => {
        const $n = ($6)[1];
        return ($c$$src$Result$$Ok)(($constructor)($pos, ($isPercent
          ? (sp_divide)($n, 100)
          : $n)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 942:4', (sp_toHuman)($6))));
});

const $u$$src$Compiler$MakeCanonical$$translateMaybeAnnotation = (($env, $maybeFaType) => {
  return ((($maybeFaType)[0] === "$Nothing")
    ? ($c$$src$Result$$Ok)($c$$src$Maybe$$Nothing)
    : ((($maybeFaType)[0] === "$Just")
      ? ((() => {
        const $faType = ($maybeFaType)[1];
        return (($c$$src$Result$$onOk)((($raw) => {
          const $tyvars = ((($0) => {
            return ($c$$src$Dict$$map)((($tyvarName, $pos) => {
              return ({
                nonFn: ($c$$src$Dict$$get)($tyvarName, $env.nonFn),
              });
            }), $0);
          }))(($c$$src$Compiler$CanonicalAst$$typeTyvars)($raw));
          return ($c$$src$Result$$Ok)(($c$$src$Maybe$$Just)(({
            raw: $raw,
            tyvars: $tyvars,
            univars: ($c$$src$Compiler$CanonicalAst$$typeUnivars)($raw),
          })));
        })))(($u$$src$Compiler$MakeCanonical$$translateRawType)($env.ro, $faType));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 319:4', (sp_toHuman)($maybeFaType))));
});

const $u$$src$Compiler$MakeCanonical$$translatePatternAny = (($env, $pos, $maybeType, $maybeModule, $name, $attrPath) => {
  return ((sp_not_equal)($attrPath, $c$$src$Core$$Nil)
    ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("pattern names can't have type attributes", $c$$src$Core$$Nil))
    : (($c$$src$Result$$onOk)((($maybeAnnotation) => {
      const $maybeName = ((sp_equal)($name, "_")
        ? $c$$src$Maybe$$Nothing
        : ($c$$src$Maybe$$Just)($name));
      return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$PatternAny)($pos, $maybeName, $maybeAnnotation));
    })))(($u$$src$Compiler$MakeCanonical$$translateMaybeAnnotation)($env, $maybeType)));
});

const $u$$src$Compiler$MakeCanonical$$translatePatternConstructor = (($env, $pos, $maybeModule, $name, $args) => {
  return (($c$$src$Result$$onOk)((($usr) => {
    return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$PatternConstructor)($pos, $usr, $args));
  })))(($u$$src$Compiler$MakeCanonical$$resolveToUsr)($env.ro, $pos, $maybeModule, $name));
});

const $u$$src$Compiler$MakeCanonical$$insertPatternRecordAttribute = (($env, $attr, $caAttrs) => {
  return (($c$$src$Result$$onOk)((($4) => {
    const $pos = $4.first;
    const $caName = $4.second;
    const $maybeFaType = $4.third;
    return (($c$$src$Dict$$member)($caName, $caAttrs)
      ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)(("duplicate attribute name in pattern: " + $caName), $c$$src$Core$$Nil))
      : ((() => {
        const $5 = ({
          first: $attr.maybeExpr,
          second: $maybeFaType,
        });
        return (((($5.first)[0] === "$Just") && ((($5.second)[0] === "$Just") && ((($5.second)[1])[0] === "$Expression")))
          ? ((() => {
            const $typePos = (($5.second)[1])[2];
            return ($u$$src$Compiler$MakeCanonical$$error)($env, $typePos, ($c$$src$Core$$Cons)("if you want to annotate the attribute, use { x = y as TheType }", $c$$src$Core$$Nil));
          }))()
          : (((($5.first)[0] === "$Nothing") && (($5.second)[0] === "$Just"))
            ? ((() => {
              const $faType = ($5.second)[1];
              return ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("TODO annotating record attributes needs more thinking", $c$$src$Core$$Nil));
            }))()
            : (((($5.first)[0] === "$Just") && (($5.second)[0] === "$Nothing"))
              ? ((() => {
                const $faPattern = ($5.first)[1];
                return (($c$$src$Result$$onOk)((($caPattern) => {
                  return ($c$$src$Result$$Ok)(((($0) => {
                    return ($c$$src$Dict$$insert)($caName, $caPattern, $0);
                  }))($caAttrs));
                })))(((($0) => {
                  return ($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $0);
                }))($faPattern));
              }))()
              : (((($5.first)[0] === "$Nothing") && (($5.second)[0] === "$Nothing"))
                ? ($c$$src$Result$$Ok)(((($0) => {
                  return ($c$$src$Dict$$insert)($caName, ($c$$src$Compiler$CanonicalAst$$PatternAny)($pos, ($c$$src$Maybe$$Just)($caName), $c$$src$Maybe$$Nothing), $0);
                }))($caAttrs))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 346:8', (sp_toHuman)($5))))));
      }))());
  })))(($u$$src$Compiler$MakeCanonical$$translateAttributeName)($env.ro, $attr.name));
});

const $u$$src$Compiler$MakeCanonical$$translatePatternRecord = (($env, $pos, $maybeMaybeExt, $attrs) => {
  return (($c$$src$Result$$onOk)((($completeness) => {
    return ((($0) => {
      return ($c$$src$Result$$map)((($x) => {
        return ($c$$src$Compiler$CanonicalAst$$PatternRecord)($pos, $completeness, $x);
      }), $0);
    }))(((($0) => {
      return ($c$$src$List$$forRes)($0, $attrs, (($0, $1) => {
        return ($u$$src$Compiler$MakeCanonical$$insertPatternRecordAttribute)($env, $0, $1);
      }));
    }))($c$$src$Dict$$empty));
  })))((((($maybeMaybeExt)[0] === "$Just") && (((($maybeMaybeExt)[1])[0] === "$Just") && (((($maybeMaybeExt)[1])[1])[0] === "$Expression")))
    ? ((() => {
      const $p = ((($maybeMaybeExt)[1])[1])[2];
      const $expr_ = ((($maybeMaybeExt)[1])[1])[3];
      return ($u$$src$Compiler$MakeCanonical$$error)($env, $p, ($c$$src$Core$$Cons)("Can't extend patterns", $c$$src$Core$$Nil));
    }))()
    : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Nothing"))
      ? ($c$$src$Result$$Ok)($c$$src$Compiler$CanonicalAst$$Partial)
      : ((($maybeMaybeExt)[0] === "$Nothing")
        ? ($c$$src$Result$$Ok)($c$$src$Compiler$CanonicalAst$$Complete)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 378:4', (sp_toHuman)($maybeMaybeExt))))));
});

const $u$$src$Compiler$MakeCanonical$$translateRawPattern = (($env, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Constructor")
    ? ((() => {
      const $maybeModule = ($expr_)[1].maybeModule;
      const $name = ($expr_)[1].name;
      return ($u$$src$Compiler$MakeCanonical$$translatePatternConstructor)($env, $pos, $maybeModule, $name, $c$$src$Core$$Nil);
    }))()
    : ((($expr_)[0] === "$Lowercase")
      ? ((() => {
        const $attrPath = ($expr_)[1].attrPath;
        const $maybeModule = ($expr_)[1].maybeModule;
        const $maybeType = ($expr_)[1].maybeType;
        const $name = ($expr_)[1].name;
        return ($u$$src$Compiler$MakeCanonical$$translatePatternAny)($env, $pos, $maybeType, $maybeModule, $name, $attrPath);
      }))()
      : (((($expr_)[0] === "$Call") && ((($expr_)[1])[0] === "$Expression"))
        ? ((() => {
          const $p = (($expr_)[1])[2];
          const $ref = (($expr_)[1])[3];
          const $faArgs = ($expr_)[2];
          return ((($ref)[0] === "$Constructor")
            ? ((() => {
              const $maybeModule = ($ref)[1].maybeModule;
              const $name = ($ref)[1].name;
              return (($c$$src$Result$$onOk)((($caPars) => {
                return ($u$$src$Compiler$MakeCanonical$$translatePatternConstructor)($env, $pos, $maybeModule, $name, $caPars);
              })))(((($0) => {
                return ($c$$src$List$$mapRes)((($0) => {
                  return ($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $0);
                }), $0);
              }))($faArgs));
            }))()
            : (true
              ? ($u$$src$Compiler$MakeCanonical$$error)($env, $p, ($c$$src$Core$$Cons)("I need 'constructor name here", $c$$src$Core$$Nil))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 447:12', (sp_toHuman)($ref))));
        }))()
        : ((($expr_)[0] === "$List")
          ? ((() => {
            const $faItems = ($expr_)[2];
            const $reversedFaItems = ($c$$src$List$$reverse)($faItems);
            const $pushItem = (($pattern, $last) => {
              return ($c$$src$Compiler$CanonicalAst$$PatternConstructor)(($c$$src$Compiler$CanonicalAst$$patternPos)($pattern), $u$$src$Compiler$CoreDefs$$consUsr, ($c$$src$Core$$Cons)($pattern, ($c$$src$Core$$Cons)($last, $c$$src$Core$$Nil)));
            });
            return ((($reversedFaItems)[0] === "$Nil")
              ? ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$PatternConstructor)($pos, $u$$src$Compiler$CoreDefs$$nilUsr, $c$$src$Core$$Nil))
              : (((($reversedFaItems)[0] === "$Cons") && ((($reversedFaItems)[1].second)[0] === "$Expression"))
                ? ((() => {
                  const $lastHasDots = ($reversedFaItems)[1].first;
                  const $p = (($reversedFaItems)[1].second)[2];
                  const $lastFaExpr = (($reversedFaItems)[1].second)[3];
                  const $reversedFaRest = ($reversedFaItems)[2];
                  return (($c$$src$List$$any)($c$$src$Tuple$$first, $reversedFaRest)
                    ? ($u$$src$Compiler$MakeCanonical$$error)($env, $p, ($c$$src$Core$$Cons)("only the last item in a list can have ... triple dots", $c$$src$Core$$Nil))
                    : (($c$$src$Basics$$not)($lastHasDots)
                      ? (($c$$src$Result$$onOk)((($reversedCaItems) => {
                        return ($c$$src$Result$$Ok)(($c$$src$List$$for)(($c$$src$Compiler$CanonicalAst$$PatternConstructor)($p, $u$$src$Compiler$CoreDefs$$nilUsr, $c$$src$Core$$Nil), $reversedCaItems, $pushItem));
                      })))(((($0) => {
                        return ($c$$src$List$$mapRes)((($4) => {
                          const $hasDots = $4.first;
                          const $expr = $4.second;
                          return ($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $expr);
                        }), $0);
                      }))($reversedFaItems))
                      : (($c$$src$Result$$onOk)((($reversedCaRest) => {
                        return ((($lastFaExpr)[0] === "$Lowercase")
                          ? ((() => {
                            const $attrPath = ($lastFaExpr)[1].attrPath;
                            const $maybeModule = ($lastFaExpr)[1].maybeModule;
                            const $maybeType = ($lastFaExpr)[1].maybeType;
                            const $name = ($lastFaExpr)[1].name;
                            return (($c$$src$Result$$onOk)((($caInit) => {
                              return ($c$$src$Result$$Ok)(($c$$src$List$$for)($caInit, $reversedCaRest, $pushItem));
                            })))(($u$$src$Compiler$MakeCanonical$$translatePatternAny)($env, $pos, $maybeType, $maybeModule, $name, $attrPath));
                          }))()
                          : (true
                            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $p, ($c$$src$Core$$Cons)("sorry, I don't understand the dots here...", $c$$src$Core$$Nil))
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 483:24', (sp_toHuman)($lastFaExpr))));
                      })))(((($0) => {
                        return ($c$$src$List$$mapRes)((($4) => {
                          const $hasDots = $4.first;
                          const $expr = $4.second;
                          return ($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $expr);
                        }), $0);
                      }))($reversedFaRest))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 466:12', (sp_toHuman)($reversedFaItems))));
          }))()
          : ((($expr_)[0] === "$Record")
            ? ((() => {
              const $attrs = ($expr_)[1].attrs;
              const $maybeExtension = ($expr_)[1].maybeExtension;
              return ($u$$src$Compiler$MakeCanonical$$translatePatternRecord)($env, $pos, $maybeExtension, $attrs);
            }))()
            : ((($expr_)[0] === "$BinopChain")
              ? ((() => {
                const $precedence = ($expr_)[1];
                const $chain = ($expr_)[2];
                return ((sp_equal)($precedence, $c$$src$Compiler$Op$$precedence_tuple)
                  ? (($c$$src$Result$$onOk)((($recordAttrs) => {
                    return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$PatternRecord)($pos, $c$$src$Compiler$CanonicalAst$$Complete, $recordAttrs));
                  })))(((($0) => {
                    return ($u$$src$Compiler$MakeCanonical$$translateTuple)($env.ro, (($0) => {
                      return ($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $0);
                    }), $0);
                  }))($chain))
                  : ((sp_equal)($precedence, $c$$src$Compiler$Op$$precedence_cons)
                    ? (($c$$src$Result$$onOk)((($caPas) => {
                      const $4 = ($c$$src$List$$reverse)($caPas);
                      return ((($4)[0] === "$Cons")
                        ? ((() => {
                          const $last = ($4)[1];
                          const $rest = ($4)[2];
                          return ($c$$src$Result$$Ok)(((($0) => {
                            return ($c$$src$List$$for)($0, $rest, (($item, $list) => {
                              return ($c$$src$Compiler$CanonicalAst$$PatternConstructor)($pos, $u$$src$Compiler$CoreDefs$$consUsr, ($c$$src$Core$$Cons)($item, ($c$$src$Core$$Cons)($list, $c$$src$Core$$Nil)));
                            }));
                          }))($last));
                        }))()
                        : ((($4)[0] === "$Nil")
                          ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("should not happen: empty cons pattern", $c$$src$Core$$Nil))
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 507:16', (sp_toHuman)($4))));
                    })))(((($0) => {
                      return ($c$$src$List$$mapRes)((($0) => {
                        return ($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $0);
                      }), $0);
                    }))(($c$$src$Compiler$FormattableAst$$binopChainExpressions)($chain)))
                    : ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("This binop can't be used in pattern matching", $c$$src$Core$$Nil))));
              }))()
              : ((($expr_)[0] === "$LiteralText")
                ? ((() => {
                  const $singleOrTriple = ($expr_)[1];
                  const $l = ($expr_)[2];
                  return ($c$$src$Result$$Ok)(((($0) => {
                    return ($c$$src$Compiler$CanonicalAst$$PatternLiteralText)($pos, $0);
                  }))(((($0) => {
                    return ($u$$src$Compiler$MakeCanonical$$escapeLiteralText)($singleOrTriple, $0);
                  }))($l)));
                }))()
                : ((($expr_)[0] === "$LiteralNumber")
                  ? ((() => {
                    const $isPercent = ($expr_)[1];
                    const $l = ($expr_)[2];
                    return ($u$$src$Compiler$MakeCanonical$$translateNumber)($env.ro, $isPercent, $c$$src$Compiler$CanonicalAst$$PatternLiteralNumber, $pos, $l);
                  }))()
                  : ((($expr_)[0] === "$Uppercase")
                    ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("WUT", $c$$src$Core$$Nil))
                    : ((($expr_)[0] === "$Statements")
                      ? ((() => {
                        const $stats = ($expr_)[1];
                        return ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("WAT", $c$$src$Core$$Nil));
                      }))()
                      : ((($expr_)[0] === "$Fn")
                        ? ((() => {
                          const $args = ($expr_)[2];
                          const $body = ($expr_)[3];
                          return ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Can't pattern match on functions. =(", $c$$src$Core$$Nil));
                        }))()
                        : ((($expr_)[0] === "$UnopCall")
                          ? ((() => {
                            const $unop = ($expr_)[1];
                            const $expr = ($expr_)[2];
                            return ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("This op can't be used in pattern matching", $c$$src$Core$$Nil));
                          }))()
                          : ((($expr_)[0] === "$If")
                            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("if..then can't be used in pattern matching", $c$$src$Core$$Nil))
                            : ((($expr_)[0] === "$Try")
                              ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("try..as can't be used in pattern matching", $c$$src$Core$$Nil))
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 438:4', (sp_toHuman)($expr_))))))))))))))));
});

const $u$$src$Compiler$MakeCanonical$$translateFullPattern = (($env, $expr) => {
  return (($c$$src$Result$$onOk)((($3) => {
    const $uni = $3.first;
    const $e = $3.second;
    return (($c$$src$Result$$onOk)((($caPa) => {
      return ($c$$src$Result$$Ok)(({
        first: $uni,
        second: $caPa,
      }));
    })))(($u$$src$Compiler$MakeCanonical$$translateRawPattern)($env, $e));
  })))(((($0) => {
    return ($u$$src$Compiler$MakeCanonical$$translatePoly)($env.ro, $0);
  }))($expr));
});

const $u$$src$Compiler$MakeCanonical$$translateLowercase = (($env, $pos, $1) => {
  const $attrPath = $1.attrPath;
  const $maybeModule = $1.maybeModule;
  const $maybeType = $1.maybeType;
  const $name = $1.name;
  return ((sp_not_equal)($maybeType, $c$$src$Maybe$$Nothing)
    ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("no annotations on var reference", $c$$src$Core$$Nil))
    : ((() => {
      const $isLocal = ((sp_equal)($maybeModule, $c$$src$Maybe$$Nothing) && ((() => {
        const $4 = ($c$$src$Dict$$get)($name, $env.values);
        return ((($4)[0] === "$Nothing")
          ? false
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $paName = ($4)[1];
              return ($c$$src$Basics$$not)($paName.isRoot);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 878:16', (sp_toHuman)($4))));
      }))());
      return (($c$$src$Result$$onOk)((($ref) => {
        return ($c$$src$Result$$Ok)(((($0) => {
          return ($c$$src$List$$for)($0, $attrPath, (($0, $1) => {
            return ($c$$src$Compiler$CanonicalAst$$RecordAccess)($pos, $0, $1);
          }));
        }))(($c$$src$Compiler$CanonicalAst$$Variable)($pos, $ref)));
      })))(($isLocal
        ? ($c$$src$Result$$Ok)(($c$$src$Compiler$Ast$$RefLocal)($name))
        : ((($0) => {
          return ($c$$src$Result$$map)($c$$src$Compiler$Ast$$RefGlobal, $0);
        }))(($u$$src$Compiler$MakeCanonical$$resolveToUsr)($env.ro, $pos, $maybeModule, $name))));
    }))());
});

const $u$$src$Compiler$MakeCanonical$$translateParameter = (($env, $fa) => {
  const $3 = $fa;
  const $faExpr = ($3)[3];
  const $pos = ($3)[2];
  return (((($faExpr)[0] === "$UnopCall") && (((($faExpr)[1])[0] === "$UnopRecycle") && ((($faExpr)[2])[0] === "$Expression")))
    ? ((() => {
      const $p = (($faExpr)[2])[2];
      const $faOperand = (($faExpr)[2])[3];
      return (((($faOperand)[0] === "$Lowercase") && ((($faOperand)[1].maybeType)[0] === "$Nothing"))
        ? ((() => {
          const $attrPath = ($faOperand)[1].attrPath;
          const $maybeModule = ($faOperand)[1].maybeModule;
          const $name = ($faOperand)[1].name;
          return (((sp_not_equal)($maybeModule, $c$$src$Maybe$$Nothing) || (sp_not_equal)($attrPath, $c$$src$Core$$Nil))
            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("I need a lowercase local variable name here... =|", $c$$src$Core$$Nil))
            : ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$ParameterRecycle)($pos, $name)));
        }))()
        : (true
          ? ($u$$src$Compiler$MakeCanonical$$error)($env, $p, ($c$$src$Core$$Cons)("@ should be followed by a variable name to recycle!", $c$$src$Core$$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 920:12', (sp_toHuman)($faOperand))));
    }))()
    : ((($faExpr)[0] === "$ResolvedArgumentPlaceholder")
      ? ((() => {
        const $n = ($faExpr)[1];
        return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)($n));
      }))()
      : (true
        ? (($c$$src$Result$$onOk)((($4) => {
          const $uni = $4.first;
          const $ca = $4.second;
          return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$ParameterPattern)($uni, $ca));
        })))(($u$$src$Compiler$MakeCanonical$$translateFullPattern)($env, $fa))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 917:4', (sp_toHuman)($faExpr)))));
});

const $u$$src$Compiler$MakeCanonical$$translateAndInsertRecordAttribute = (($env, $attr, $caAttrsAccum) => {
  return (($c$$src$Result$$onOk)((($4) => {
    const $pos = $4.first;
    const $caName = $4.second;
    const $maybeFaType = $4.third;
    return (($c$$src$Dict$$member)($caName, $caAttrsAccum)
      ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)(("duplicate attribute: " + $caName), $c$$src$Core$$Nil))
      : (($c$$src$Result$$onOk)((($caExpr) => {
        return ($c$$src$Result$$Ok)(((($0) => {
          return ($c$$src$Dict$$insert)($caName, $caExpr, $0);
        }))($caAttrsAccum));
      })))(((($0) => {
        return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
      }))(((($0) => {
        return ($c$$src$Maybe$$withDefault)($attr.name, $0);
      }))($attr.maybeExpr))));
  })))(($u$$src$Compiler$MakeCanonical$$translateAttributeName)($env.ro, $attr.name));
});

const $u$$src$Compiler$MakeCanonical$$translateRecord = (($env, $pos, $maybeMaybeExtension, $attrs) => {
  const $zzz = (((($maybeMaybeExtension)[0] === "$Just") && ((($maybeMaybeExtension)[1])[0] === "$Just"))
    ? ((() => {
      const $ext = (($maybeMaybeExtension)[1])[1];
      return ((($0) => {
        return ($c$$src$Result$$map)($c$$src$Maybe$$Just, $0);
      }))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $ext));
    }))()
    : (((($maybeMaybeExtension)[0] === "$Just") && ((($maybeMaybeExtension)[1])[0] === "$Nothing"))
      ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("I need to know what record you are updating", $c$$src$Core$$Nil))
      : ((($maybeMaybeExtension)[0] === "$Nothing")
        ? ($c$$src$Result$$Ok)($c$$src$Maybe$$Nothing)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 960:8', (sp_toHuman)($maybeMaybeExtension)))));
  return (($c$$src$Result$$onOk)((($maybeCaExt) => {
    return ((($maybeCaExt)[0] === "$Nothing")
      ? (($c$$src$Result$$onOk)((($caAttrs) => {
        return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Record)($pos, $c$$src$Maybe$$Nothing, $caAttrs));
      })))(((($0) => {
        return ($c$$src$List$$forRes)($0, $attrs, (($0, $1) => {
          return ($u$$src$Compiler$MakeCanonical$$translateAndInsertRecordAttribute)(((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              maybeShorthandTarget: $c$$src$Maybe$$Nothing,
            }));
          }))(), $0, $1);
        }));
      }))($c$$src$Dict$$empty))
      : ((($maybeCaExt)[0] === "$Just")
        ? ((() => {
          const $caExt = ($maybeCaExt)[1];
          const $varName = (text_fromNumber)($env.nextGeneratedVariableName);
          const $var = ($c$$src$Compiler$CanonicalAst$$Variable)($c$$src$Compiler$Pos$$G, ($c$$src$Compiler$Ast$$RefLocal)($varName));
          const $newEnv = ((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              maybeShorthandTarget: ($c$$src$Maybe$$Just)($var),
              nextGeneratedVariableName: ($0.nextGeneratedVariableName + 1),
            }));
          }))();
          return (($c$$src$Result$$onOk)((($caAttrs) => {
            const $def = ({
              body: $caExt,
              pattern: ($c$$src$Compiler$CanonicalAst$$PatternAny)($c$$src$Compiler$Pos$$G, ($c$$src$Maybe$$Just)($varName), $c$$src$Maybe$$Nothing),
              uni: $c$$src$Compiler$Ast$$Imm,
            });
            return ($c$$src$Result$$Ok)(((($0) => {
              return ($c$$src$Compiler$CanonicalAst$$LetIn)($def, $0);
            }))(((($0) => {
              return ($c$$src$Compiler$CanonicalAst$$Record)($pos, ($c$$src$Maybe$$Just)($var), $0);
            }))($caAttrs)));
          })))(((($0) => {
            return ($c$$src$List$$forRes)($0, $attrs, (($0, $1) => {
              return ($u$$src$Compiler$MakeCanonical$$translateAndInsertRecordAttribute)($newEnv, $0, $1);
            }));
          }))($c$$src$Dict$$empty));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 967:4', (sp_toHuman)($maybeCaExt))));
  })))($zzz);
});

const $u$$src$Compiler$MakeCanonical$$translateRecordShorthand = (($env, $pos, $attrPath, $name) => {
  const $5 = $env.maybeShorthandTarget;
  return ((($5)[0] === "$Nothing")
    ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Record update shorthands must be used inside a record update such as", ($c$$src$Core$$Cons)(("    { aRecord with anAttribute = doSomethingWith ." + (($c$$src$Text$$join)(".", $attrPath) + " }")), ($c$$src$Core$$Cons)("but we are not inside a record update!", $c$$src$Core$$Nil))))
    : ((($5)[0] === "$Just")
      ? ((() => {
        const $shorthandTarget = ($5)[1];
        return ($c$$src$Result$$Ok)(((($0) => {
          return ($c$$src$List$$for)($0, (sp_cons)($name, $attrPath), (($attrName, $expr) => {
            return ($c$$src$Compiler$CanonicalAst$$RecordAccess)($pos, $attrName, $expr);
          }));
        }))($shorthandTarget));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 894:8', (sp_toHuman)($5))));
});

const $u$$src$Compiler$MakeCanonical$$translateLocalDefinition = (($env, $fa) => {
  const $nonFn = ($c$$src$Dict$$fromList)(((($0) => {
    return ($c$$src$List$$map)((($4) => {
      const $pos = $4.first;
      const $name = $4.second;
      return ({
        first: $name,
        second: $pos,
      });
    }), $0);
  }))($fa.nonFn));
  return (($c$$src$Result$$onOk)((($3) => {
    const $uni = $3.first;
    const $pattern = $3.second;
    return (($c$$src$Result$$onOk)((($localEnv) => {
      return (($c$$src$Result$$onOk)((($body) => {
        return ($c$$src$Result$$Ok)(({
          first: $localEnv,
          second: ({
            body: $body,
            pattern: $pattern,
            uni: $uni,
          }),
        }));
      })))(((($0) => {
        return ($u$$src$Compiler$MakeCanonical$$translateExpression)($localEnv, $0);
      }))($fa.body));
    })))(((($0) => {
      return ($u$$src$Compiler$MakeCanonical$$insertPatternNames)(false, $pattern, $0);
    }))($env));
  })))(((($0) => {
    return ($u$$src$Compiler$MakeCanonical$$translateFullPattern)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        nonFn: $nonFn,
      }));
    }))(), $0);
  }))($fa.pattern));
});

const $u$$src$Compiler$MakeCanonical$$translateStatements = (($env, $stats) => {
  return ((($stats)[0] === "$Nil")
    ? ($c$$src$Result$$Ok)(((($0) => {
      return ($c$$src$Compiler$CanonicalAst$$Constructor)($c$$src$Compiler$Pos$$G, $0);
    }))($u$$src$Compiler$CoreDefs$$noneConsUsr))
    : (((($stats)[0] === "$Cons") && (((($stats)[1])[0] === "$Evaluation") && ((($stats)[2])[0] === "$Nil")))
      ? ((() => {
        const $faExpression = (($stats)[1])[1];
        return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $faExpression);
      }))()
      : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$CommentStatement"))
        ? ((() => {
          const $tail = ($stats)[2];
          return ($u$$src$Compiler$MakeCanonical$$translateStatements)($env, $tail);
        }))()
        : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$Evaluation"))
          ? ((() => {
            const $faExpr = (($stats)[1])[1];
            const $tail = ($stats)[2];
            return (($c$$src$Result$$onOk)((($caExpr) => {
              const $caDef = ({
                body: $caExpr,
                pattern: ($c$$src$Compiler$CanonicalAst$$PatternAny)($c$$src$Compiler$Pos$$G, $c$$src$Maybe$$Nothing, $c$$src$Maybe$$Nothing),
                uni: $c$$src$Compiler$Ast$$Imm,
              });
              return (($c$$src$Result$$onOk)((($acc) => {
                return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$LetIn)($caDef, $acc));
              })))(((($0) => {
                return ($u$$src$Compiler$MakeCanonical$$translateStatements)($env, $0);
              }))($tail));
            })))(((($0) => {
              return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
            }))($faExpr));
          }))()
          : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$ValueDef"))
            ? ((() => {
              const $fa = (($stats)[1])[1];
              const $tail = ($stats)[2];
              return (($c$$src$Result$$onOk)((($3) => {
                const $newEnv = $3.first;
                const $caDef = $3.second;
                return (($c$$src$Result$$onOk)((($acc) => {
                  return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$LetIn)($caDef, $acc));
                })))(((($0) => {
                  return ($u$$src$Compiler$MakeCanonical$$translateStatements)($newEnv, $0);
                }))($tail));
              })))(((($0) => {
                return ($u$$src$Compiler$MakeCanonical$$translateLocalDefinition)($env, $0);
              }))($fa));
            }))()
            : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$AliasDef"))
              ? ((() => {
                const $fa = (($stats)[1])[1];
                const $tail = ($stats)[2];
                return ($u$$src$Compiler$MakeCanonical$$error)($env, $fa.name.first, ($c$$src$Core$$Cons)("Aliases can be declared only in the root scope", $c$$src$Core$$Nil));
              }))()
              : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$UnionDef"))
                ? ((() => {
                  const $fa = (($stats)[1])[1];
                  const $tail = ($stats)[2];
                  return ($u$$src$Compiler$MakeCanonical$$error)($env, $fa.name.first, ($c$$src$Core$$Cons)("Types can be declared only in the root scope", $c$$src$Core$$Nil));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 567:4', (sp_toHuman)($stats)))))))));
});

const $u$$src$Compiler$MakeCanonical$$translateExpression = (($env, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$LiteralNumber")
    ? ((() => {
      const $isPercent = ($expr_)[1];
      const $str = ($expr_)[2];
      return ($u$$src$Compiler$MakeCanonical$$translateNumber)($env.ro, $isPercent, $c$$src$Compiler$CanonicalAst$$LiteralNumber, $pos, $str);
    }))()
    : ((($expr_)[0] === "$LiteralText")
      ? ((() => {
        const $singleOrTriple = ($expr_)[1];
        const $l = ($expr_)[2];
        return ($c$$src$Result$$Ok)(((($0) => {
          return ($c$$src$Compiler$CanonicalAst$$LiteralText)($pos, $0);
        }))(((($0) => {
          return ($u$$src$Compiler$MakeCanonical$$escapeLiteralText)($singleOrTriple, $0);
        }))($l)));
      }))()
      : ((($expr_)[0] === "$Statements")
        ? ((() => {
          const $stats = ($expr_)[1];
          return ($u$$src$Compiler$MakeCanonical$$translateStatements)($env, $stats);
        }))()
        : ((($expr_)[0] === "$Lowercase")
          ? ((() => {
            const $pas = ($expr_)[1];
            return ($u$$src$Compiler$MakeCanonical$$translateLowercase)($env, $pos, $pas);
          }))()
          : ((($expr_)[0] === "$Uppercase")
            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Can't reference a type or module here...?", $c$$src$Core$$Nil))
            : ((($expr_)[0] === "$Constructor")
              ? ((() => {
                const $maybeModule = ($expr_)[1].maybeModule;
                const $name = ($expr_)[1].name;
                return (($c$$src$Result$$onOk)((($usr) => {
                  return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Constructor)($pos, $usr));
                })))(($u$$src$Compiler$MakeCanonical$$resolveToUsr)($env.ro, $pos, $maybeModule, $name));
              }))()
              : ((($expr_)[0] === "$Fn")
                ? ((() => {
                  const $faParams = ($expr_)[2];
                  const $faBody = ($expr_)[3];
                  return (($c$$src$Result$$onOk)((($caParams) => {
                    return (($c$$src$Result$$onOk)((($localEnv) => {
                      return (($c$$src$Result$$onOk)((($caBody) => {
                        return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Fn)($pos, $caParams, $caBody));
                      })))(((($0) => {
                        return ($u$$src$Compiler$MakeCanonical$$translateExpression)($localEnv, $0);
                      }))($faBody));
                    })))(((($0) => {
                      return ($c$$src$List$$forRes)($0, $caParams, (($par, $envX) => {
                        return ((($par)[0] === "$ParameterPattern")
                          ? ((() => {
                            const $uni = ($par)[1];
                            const $pa = ($par)[2];
                            return ($u$$src$Compiler$MakeCanonical$$insertPatternNames)(false, $pa, $envX);
                          }))()
                          : ((($par)[0] === "$ParameterRecycle")
                            ? ((() => {
                              const $p = ($par)[1];
                              const $name = ($par)[2];
                              return ((($0) => {
                                return ($u$$src$Compiler$MakeCanonical$$insertPatternNames)(false, $0, $envX);
                              }))(($c$$src$Compiler$CanonicalAst$$PatternAny)($p, ($c$$src$Maybe$$Just)($name), $c$$src$Maybe$$Nothing));
                            }))()
                            : ((($par)[0] === "$ParameterPlaceholder")
                              ? ((() => {
                                const $n = ($par)[1];
                                return ($c$$src$Result$$Ok)(((() => {
                                  const $0 = $envX;
                                  return (Object.assign)({}, $0, ({
                                    values: ($c$$src$Dict$$insert)((text_fromNumber)($n), ({
                                      isRoot: false,
                                      pos: $pos,
                                    }), $0.values),
                                  }));
                                }))());
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 648:16', (sp_toHuman)($par)))));
                      }));
                    }))($env));
                  })))(((($0) => {
                    return ($c$$src$List$$mapRes)((($0) => {
                      return ($u$$src$Compiler$MakeCanonical$$translateParameter)($env, $0);
                    }), $0);
                  }))($faParams));
                }))()
                : ((($expr_)[0] === "$ResolvedArgumentPlaceholder")
                  ? ((() => {
                    const $n = ($expr_)[1];
                    return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Variable)($pos, ($c$$src$Compiler$Ast$$RefPlaceholder)($n)));
                  }))()
                  : ((($expr_)[0] === "$Call")
                    ? ((() => {
                      const $faRef = ($expr_)[1];
                      const $faArgs = ($expr_)[2];
                      const $3 = ($c$$src$List$$for)(({
                        first: 0,
                        second: $c$$src$Core$$Nil,
                      }), $faArgs, (($exp, $4) => {
                        const $cnt = $4.first;
                        const $rev = $4.second;
                        return (($u$$src$Compiler$MakeCanonical$$isPlaceholder)($exp)
                          ? ((() => {
                            const $6 = $exp;
                            const $p = ($6)[2];
                            const $c = ($6)[1];
                            return ({
                              first: ($cnt + 1),
                              second: ($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$Expression)($c, $p, ($c$$src$Compiler$FormattableAst$$ResolvedArgumentPlaceholder)($cnt)), $rev),
                            });
                          }))()
                          : ({
                            first: $cnt,
                            second: ($c$$src$Core$$Cons)($exp, $rev),
                          }));
                      }));
                      const $reversedArgs = $3.second;
                      const $placeholdersCount = $3.first;
                      return (($placeholdersCount > 0)
                        ? ((($0) => {
                          return ($u$$src$Compiler$MakeCanonical$$makePartiallyAppliedFunction)($env, $pos, $placeholdersCount, $0);
                        }))(($c$$src$Compiler$FormattableAst$$Call)($faRef, ($c$$src$List$$reverse)($reversedArgs)))
                        : (($c$$src$Result$$onOk)((($caRef) => {
                          return (($c$$src$Result$$onOk)((($caArgs) => {
                            return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Call)($pos, $caRef, $caArgs));
                          })))(((($0) => {
                            return ($c$$src$List$$mapRes)((($0) => {
                              return ($u$$src$Compiler$MakeCanonical$$translateArgument)($env, $0);
                            }), $0);
                          }))($faArgs));
                        })))(((($0) => {
                          return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
                        }))($faRef)));
                    }))()
                    : ((($expr_)[0] === "$If")
                      ? ((() => {
                        const $condition = ($expr_)[1].condition;
                        const $false = ($expr_)[1].false;
                        const $true = ($expr_)[1].true;
                        return (($c$$src$Result$$onOk)((($c) => {
                          return (($c$$src$Result$$onOk)((($t) => {
                            return (($c$$src$Result$$onOk)((($f) => {
                              return ($c$$src$Result$$Ok)(((($0) => {
                                return ($c$$src$Compiler$CanonicalAst$$If)($pos, $0);
                              }))(({
                                condition: $c,
                                false: $f,
                                true: $t,
                              })));
                            })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $false));
                          })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $true));
                        })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $condition));
                      }))()
                      : ((($expr_)[0] === "$UnopCall")
                        ? ((() => {
                          const $opId = ($expr_)[1];
                          const $faOperand = ($expr_)[2];
                          return ((($opId)[0] === "$UnopUnique")
                            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("can't use ! here because REASONS", $c$$src$Core$$Nil))
                            : ((($opId)[0] === "$UnopRecycle")
                              ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("can recycle only in function calls!", $c$$src$Core$$Nil))
                              : ((($opId)[0] === "$UnopPlus")
                                ? ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $faOperand)
                                : ((($opId)[0] === "$UnopMinus")
                                  ? (($c$$src$Result$$onOk)((($caOperand) => {
                                    return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Call)($pos, ($c$$src$Compiler$CanonicalAst$$Variable)($pos, ($c$$src$Compiler$Ast$$RefGlobal)($u$$src$Compiler$CoreDefs$$unaryMinus.usr)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)($caOperand), $c$$src$Core$$Nil)));
                                  })))(((($0) => {
                                    return ($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $0);
                                  }))($faOperand))
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 716:12', (sp_toHuman)($opId))))));
                        }))()
                        : ((($expr_)[0] === "$BinopChain")
                          ? ((() => {
                            const $group = ($expr_)[1];
                            const $chain = ($expr_)[2];
                            return ($u$$src$Compiler$MakeCanonical$$translateBinopChain)($env, $pos, $group, $chain);
                          }))()
                          : ((($expr_)[0] === "$Record")
                            ? ((() => {
                              const $attrs = ($expr_)[1].attrs;
                              const $maybeExtension = ($expr_)[1].maybeExtension;
                              return ($u$$src$Compiler$MakeCanonical$$translateRecord)($env, $pos, $maybeExtension, $attrs);
                            }))()
                            : ((($expr_)[0] === "$RecordShorthand")
                              ? ((() => {
                                const $attrPath = ($expr_)[1].attrPath;
                                const $name = ($expr_)[1].name;
                                return ($u$$src$Compiler$MakeCanonical$$translateRecordShorthand)($env, $pos, $attrPath, $name);
                              }))()
                              : ((($expr_)[0] === "$List")
                                ? ((() => {
                                  const $faDotsAndItems = ($expr_)[2];
                                  const $rev = ($c$$src$List$$reverse)($faDotsAndItems);
                                  return ((($rev)[0] === "$Nil")
                                    ? ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Constructor)($pos, $u$$src$Compiler$CoreDefs$$nilUsr))
                                    : ((($rev)[0] === "$Cons")
                                      ? ((() => {
                                        const $hasDots = ($rev)[1].first;
                                        const $head = ($rev)[1].second;
                                        const $rest = ($rev)[2];
                                        return (($c$$src$List$$any)($c$$src$Tuple$$first, $rest)
                                          ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("can use dots only on the last element (for now?)", $c$$src$Core$$Nil))
                                          : ((() => {
                                            const $3 = ($hasDots
                                              ? ({
                                                first: $head,
                                                second: $rest,
                                              })
                                              : ({
                                                first: ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $pos, ($c$$src$Compiler$FormattableAst$$List)(false, $c$$src$Core$$Nil)),
                                                second: $rev,
                                              }));
                                            const $revItems = $3.second;
                                            const $init = $3.first;
                                            return (($c$$src$Result$$onOk)((($caInit) => {
                                              return ((($0) => {
                                                return ($c$$src$List$$forRes)($0, $revItems, (($7, $acc) => {
                                                  const $faItem = $7.second;
                                                  return (($c$$src$Result$$onOk)((($caItem) => {
                                                    return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Call)($pos, ($c$$src$Compiler$CanonicalAst$$Constructor)($pos, $u$$src$Compiler$CoreDefs$$consUsr), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)($caItem), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)($acc), $c$$src$Core$$Nil))));
                                                  })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $faItem));
                                                }));
                                              }))($caInit);
                                            })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $init));
                                          }))());
                                      }))()
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 746:12', (sp_toHuman)($rev))));
                                }))()
                                : ((($expr_)[0] === "$Try")
                                  ? ((() => {
                                    const $patterns = ($expr_)[1].patterns;
                                    const $value = ($expr_)[1].value;
                                    return (($u$$src$Compiler$MakeCanonical$$isPlaceholder)($value)
                                      ? ((($0) => {
                                        return ($u$$src$Compiler$MakeCanonical$$makePartiallyAppliedFunction)($env, $pos, 1, $0);
                                      }))(($c$$src$Compiler$FormattableAst$$Try)(({
                                        patterns: $patterns,
                                        value: ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $pos, ($c$$src$Compiler$FormattableAst$$ResolvedArgumentPlaceholder)(0)),
                                      })))
                                      : ((() => {
                                        const $translatePatternAndStatements = (($3) => {
                                          const $faPattern = $3.first;
                                          const $faExpression = $3.second;
                                          return (($c$$src$Result$$onOk)((($4) => {
                                            const $uni = $4.first;
                                            const $caPattern = $4.second;
                                            return (($c$$src$Result$$onOk)((($localEnv) => {
                                              return (($c$$src$Result$$onOk)((($block) => {
                                                return ($c$$src$Result$$Ok)(({
                                                  first: $uni,
                                                  second: $caPattern,
                                                  third: $block,
                                                }));
                                              })))(((($0) => {
                                                return ($u$$src$Compiler$MakeCanonical$$translateExpression)($localEnv, $0);
                                              }))($faExpression));
                                            })))(((($0) => {
                                              return ($u$$src$Compiler$MakeCanonical$$insertPatternNames)(false, $caPattern, $0);
                                            }))($env));
                                          })))(((($0) => {
                                            return ($u$$src$Compiler$MakeCanonical$$translateFullPattern)($env, $0);
                                          }))($faPattern));
                                        });
                                        return (($c$$src$Result$$onOk)((($caValue) => {
                                          return (($c$$src$Result$$onOk)((($patternsAndExpressions) => {
                                            return ($c$$src$Result$$Ok)(($c$$src$Compiler$CanonicalAst$$Try)($pos, ({
                                              patternsAndExpressions: $patternsAndExpressions,
                                              value: $caValue,
                                            })));
                                          })))(((($0) => {
                                            return ($c$$src$List$$mapRes)($translatePatternAndStatements, $0);
                                          }))($patterns));
                                        })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($env, $value));
                                      }))());
                                  }))()
                                  : ((($expr_)[0] === "$Native")
                                    ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("`this_is_sp_native` can be used only for root level value defs", $c$$src$Core$$Nil))
                                    : (true
                                      ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("something's wrong here...", ($c$$src$Core$$Cons)((sp_toHuman)($expr_), $c$$src$Core$$Nil)))
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 617:4', (sp_toHuman)($expr_))))))))))))))))))));
});

const $u$$src$Compiler$MakeCanonical$$translateRootDefinition = (($env, $fa) => {
  const $nonFn = ($c$$src$Dict$$fromList)(((($0) => {
    return ($c$$src$List$$map)((($4) => {
      const $pos = $4.first;
      const $name = $4.second;
      return ({
        first: $name,
        second: $pos,
      });
    }), $0);
  }))($fa.nonFn));
  return (($c$$src$Result$$onOk)((($3) => {
    const $uni = $3.first;
    const $pattern = $3.second;
    return (($c$$src$Result$$onOk)(((_0) => {
      return (($c$$src$Result$$onOk)((($5) => {
        const $namePos = $5.first;
        const $name = $5.second;
        const $maybeAnnotation = $5.third;
        return (($c$$src$Result$$onOk)((($localEnv) => {
          return (($c$$src$Result$$onOk)((($7) => {
            const $maybeBody = $7.first;
            const $bodyDeps = $7.second;
            const $directDeps = ($u$$src$Compiler$MakeCanonical$$patternDeps)($pattern, $bodyDeps);
            return ($c$$src$Result$$Ok)(({
              first: $localEnv,
              second: ({
                directDeps: $directDeps,
                maybeAnnotation: $maybeAnnotation,
                maybeBody: $maybeBody,
                name: $name,
                namePos: $namePos,
              }),
            }));
          })))(((() => {
            const $7 = $fa.body;
            return (((($7)[0] === "$Expression") && ((($7)[3])[0] === "$Native"))
              ? ($c$$src$Result$$Ok)(({
                first: $c$$src$Maybe$$Nothing,
                second: $c$$src$Dict$$empty,
              }))
              : (true
                ? (($c$$src$Result$$onOk)((($body) => {
                  return ($c$$src$Result$$Ok)(({
                    first: ($c$$src$Maybe$$Just)($body),
                    second: ($u$$src$Compiler$MakeCanonical$$expressionDeps)($body, $c$$src$Dict$$empty),
                  }));
                })))(($u$$src$Compiler$MakeCanonical$$translateExpression)($localEnv, $fa.body))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 260:4', (sp_toHuman)($7))));
          }))());
        })))(((($0) => {
          return ($u$$src$Compiler$MakeCanonical$$insertPatternNames)(true, $pattern, $0);
        }))($env));
      })))((((($pattern)[0] === "$PatternAny") && ((($pattern)[2])[0] === "$Just"))
        ? ((() => {
          const $pos = ($pattern)[1];
          const $name = (($pattern)[2])[1];
          const $maybeAnnotation = ($pattern)[3];
          return ($c$$src$Result$$Ok)(({
            first: $pos,
            second: $name,
            third: $maybeAnnotation,
          }));
        }))()
        : (true
          ? ($u$$src$Compiler$MakeCanonical$$error)($env, ($c$$src$Compiler$CanonicalAst$$patternPos)($pattern), ($c$$src$Core$$Cons)("Root-level patterns are not (yet?) supported.", $c$$src$Core$$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 253:4', (sp_toHuman)($pattern)))));
    })))(((sp_not_equal)($uni, $c$$src$Compiler$Ast$$Imm)
      ? ($u$$src$Compiler$MakeCanonical$$error)($env, ($c$$src$Compiler$CanonicalAst$$patternPos)($pattern), ($c$$src$Core$$Cons)("Unique values can be declared only inside functions.", $c$$src$Core$$Nil))
      : ($c$$src$Result$$Ok)(null)));
  })))(((($0) => {
    return ($u$$src$Compiler$MakeCanonical$$translateFullPattern)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        nonFn: $nonFn,
      }));
    }))(), $0);
  }))($fa.pattern));
});

const $u$$src$Compiler$MakeCanonical$$insertRootStatement = (($faStatement, $1) => {
  const $caModule = $1.first;
  const $env = $1.second;
  return (((($faStatement)[0] === "$Evaluation") && ((($faStatement)[1])[0] === "$Expression"))
    ? ((() => {
      const $pos = (($faStatement)[1])[2];
      return ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)("Root Evaluations don't really do much =|", $c$$src$Core$$Nil));
    }))()
    : ((($faStatement)[0] === "$ValueDef")
      ? ((() => {
        const $d = ($faStatement)[1];
        return (($c$$src$Result$$onOk)((($3) => {
          const $newEnv = $3.first;
          const $def = $3.second;
          return ($c$$src$Result$$Ok)(({
            first: ((() => {
              const $0 = $caModule;
              return (Object.assign)({}, $0, ({
                valueDefs: ($c$$src$Dict$$insert)($def.name, $def, $0.valueDefs),
              }));
            }))(),
            second: $newEnv,
          }));
        })))(((($0) => {
          return ($u$$src$Compiler$MakeCanonical$$translateRootDefinition)($env, $0);
        }))($d));
      }))()
      : ((($faStatement)[0] === "$AliasDef")
        ? ((() => {
          const $fa = ($faStatement)[1];
          const $3 = $fa.name;
          const $name = $3.second;
          const $pos = $3.first;
          return ((($c$$src$Dict$$member)($name, $caModule.aliasDefs) || ($c$$src$Dict$$member)($name, $caModule.variantTypeDefs))
            ? ($u$$src$Compiler$MakeCanonical$$error)($env, $fa.name.first, ($c$$src$Core$$Cons)(($name + " declared twice!"), $c$$src$Core$$Nil))
            : (($c$$src$Result$$onOk)((($type) => {
              const $aliasDef = ({
                directDeps: ($u$$src$Compiler$MakeCanonical$$typeDeps)($type, $c$$src$Dict$$empty),
                pars: ($c$$src$List$$map)((($5) => {
                  const $p = $5.first;
                  const $n = $5.second;
                  return ({
                    first: $n,
                    second: $p,
                  });
                }), $fa.args),
                type: $type,
                usr: ($c$$src$Compiler$Meta$$USR)($env.ro.umr, $name),
              });
              return ($c$$src$Result$$Ok)(({
                first: ((() => {
                  const $0 = $caModule;
                  return (Object.assign)({}, $0, ({
                    aliasDefs: ($c$$src$Dict$$insert)($name, $aliasDef, $0.aliasDefs),
                  }));
                }))(),
                second: $env,
              }));
            })))(((($0) => {
              return ($u$$src$Compiler$MakeCanonical$$translateRawType)($env.ro, $0);
            }))($fa.type)));
        }))()
        : ((($faStatement)[0] === "$UnionDef")
          ? ((() => {
            const $fa = ($faStatement)[1];
            const $3 = $fa.name;
            const $name = $3.second;
            const $pos = $3.first;
            return ((($c$$src$Dict$$member)($name, $caModule.aliasDefs) || ($c$$src$Dict$$member)($name, $caModule.variantTypeDefs))
              ? ($u$$src$Compiler$MakeCanonical$$error)($env, $pos, ($c$$src$Core$$Cons)(($name + " declared twice!"), $c$$src$Core$$Nil))
              : ((() => {
                const $caPars = ($c$$src$List$$map)((($4) => {
                  const $p = $4.first;
                  const $n = $4.second;
                  return ({
                    first: $n,
                    second: $p,
                  });
                }), $fa.args);
                const $usr = ($c$$src$Compiler$Meta$$USR)($env.ro.umr, $name);
                const $type = ((($0) => {
                  return ($c$$src$Compiler$CanonicalAst$$TypeNamed)($pos, $usr, $0);
                }))(((($0) => {
                  return ($c$$src$List$$map)((($5) => {
                    const $n = $5.first;
                    const $p = $5.second;
                    return ($c$$src$Compiler$CanonicalAst$$TypeAnnotationVariable)($p, $n);
                  }), $0);
                }))($caPars));
                return (($c$$src$Result$$onOk)((($4) => {
                  const $constructors = $4.first;
                  const $newEnv = $4.second;
                  const $varDef = ({
                    constructors: $constructors,
                    pars: $caPars,
                    usr: $usr,
                  });
                  const $newModule = ((() => {
                    const $0 = $caModule;
                    return (Object.assign)({}, $0, ({
                      constructorDefs: ($c$$src$Dict$$for)($0.constructorDefs, $constructors, $c$$src$Dict$$insert),
                      variantTypeDefs: ($c$$src$Dict$$insert)($name, $varDef, $0.variantTypeDefs),
                    }));
                  }))();
                  return ($c$$src$Result$$Ok)(({
                    first: $newModule,
                    second: $newEnv,
                  }));
                })))(((($0) => {
                  return ($c$$src$List$$forRes)($0, $fa.constructors, (($0, $1) => {
                    return ($u$$src$Compiler$MakeCanonical$$translateConstructor)($type, $usr, ($c$$src$Dict$$fromList)($caPars), $0, $1);
                  }));
                }))(({
                  first: $c$$src$Dict$$empty,
                  second: $env,
                })));
              }))());
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1487:4', (sp_toHuman)($faStatement))))));
});

const $u$$src$Compiler$MakeCanonical$$translateModule = (($ro, $faModule) => {
  (sp_benchStart)(null);
  const $module = ($c$$src$Compiler$CanonicalAst$$initModule)($ro.errorModule.fsPath, $ro.umr, $ro.errorModule.content);
  return ((($0) => {
    return ($c$$src$Basics$$btw)(sp_benchStop, "translateModule", $0);
  }))(((($0) => {
    return ($c$$src$Result$$map)($c$$src$Tuple$$first, $0);
  }))(((($0) => {
    return ($c$$src$List$$forRes)($0, $faModule, (($0, $1) => {
      return ($u$$src$Compiler$MakeCanonical$$insertRootStatement)($0, $1);
    }));
  }))(({
    first: $module,
    second: ($u$$src$Compiler$MakeCanonical$$initEnv)($ro),
  }))));
});

const $u$$src$Compiler$Lexer$$getPos = (($state) => {
  return ([
    ((__re__ = (basics_cloneUni)($state.nextPos)), ($state.nextPos = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$closeOpenBlocks = (($state) => {
  const $pos = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $s = ((__re__ = (array_toList)($state.indentStack)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
  ($c$$src$List$$each)($s, ((_0) => {
    return ((__re__ = (array_push)($state.tokens, ($c$$src$Compiler$Token$$Token)($pos, $pos, $c$$src$Compiler$Token$$BlockEnd))), ($state.tokens = (__re__)[1]), (__re__)[0]);
  }));
  return ([
    ((__re__ = (array_push)($state.sections, ((__re__ = (array_toList)($state.tokens)), ($state.tokens = (__re__)[1]), (__re__)[0]))), ($state.sections = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addCommentTokenAbs = (($start, $end, $kind, $state) => {
  (((__re__ = (basics_cloneUni)($state.keepComments)), ($state.keepComments = (__re__)[1]), (__re__)[0])
    ? ((__re__ = (array_push)($state.tokens, ($c$$src$Compiler$Token$$Token)($start, $end, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0])
    : null);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addIndentToken = (($pos, $kind, $state) => {
  return ([
    ((__re__ = (array_push)($state.tokens, ($c$$src$Compiler$Token$$Token)($pos, $pos, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$updateIndent = (($start, $end, $kind, $state) => {
  const $manageIndent = (($head) => {
    const $lineIndent = ((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]);
    return (($lineIndent > $head.indent)
      ? ((() => {
        const $newIndent = ({
          indent: $lineIndent,
          isBlock: ((__re__ = (basics_cloneUni)($state.indentStartsABlock)), ($state.indentStartsABlock = (__re__)[1]), (__re__)[0]),
        });
        ((__re__ = (array_push)($state.indentStack, $newIndent)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
        return (((__re__ = (basics_cloneUni)($state.indentStartsABlock)), ($state.indentStartsABlock = (__re__)[1]), (__re__)[0])
          ? ((__re__ = ($u$$src$Compiler$Lexer$$addIndentToken)($start, $c$$src$Compiler$Token$$BlockStart, $state)), ($state = (__re__)[1]), (__re__)[0])
          : null);
      }))()
      : ($head.isBlock
        ? ((() => {
          const $list = ((__re__ = (array_toList)($state.tokens)), ($state.tokens = (__re__)[1]), (__re__)[0]);
          (((sp_not_equal)(((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]), 0) || (sp_equal)($list, $c$$src$Core$$Nil))
            ? null
            : ((() => {
              ((__re__ = (array_push)($state.sections, $list)), ($state.sections = (__re__)[1]), (__re__)[0]);
              return ($state.tokens = (array_fromList)($c$$src$Core$$Nil));
            }))());
          return ((__re__ = ($u$$src$Compiler$Lexer$$addIndentToken)($start, $c$$src$Compiler$Token$$NewSiblingLine, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : null));
  });
  const $5 = ((__re__ = (array_pop)($state.indentStack)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
  return ([
    ((($5)[0] === "$Nothing")
      ? ($manageIndent)(({
        indent: 0,
        isBlock: true,
      }))
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $head = ($5)[1];
          return ((((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]) < $head.indent)
            ? ((() => {
              ($head.isBlock
                ? ((__re__ = ($u$$src$Compiler$Lexer$$addIndentToken)($start, $c$$src$Compiler$Token$$BlockEnd, $state)), ($state = (__re__)[1]), (__re__)[0])
                : null);
              return ((__re__ = ($u$$src$Compiler$Lexer$$updateIndent)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((() => {
              ((__re__ = (array_push)($state.indentStack, $head)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
              return ($manageIndent)($head);
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 155:4', (sp_toHuman)($5)))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addContentTokenAbs = (($start, $end, $kind, $state) => {
  (((__re__ = (basics_cloneUni)($state.soFarThereAreNoTokensInThisLine)), ($state.soFarThereAreNoTokensInThisLine = (__re__)[1]), (__re__)[0])
    ? ((() => {
      ($state.soFarThereAreNoTokensInThisLine = false);
      return ((__re__ = ($u$$src$Compiler$Lexer$$updateIndent)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
    }))()
    : null);
  let $indentStartsABlock = ((($kind)[0] === "$Then")
    ? true
    : ((($kind)[0] === "$Else")
      ? true
      : ((($kind)[0] === "$As")
        ? true
        : ((($kind)[0] === "$Colon")
          ? true
          : ((($kind)[0] === "$Defop")
            ? true
            : (true
              ? false
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 185:8', (sp_toHuman)($kind))))))));
  ($state.indentStartsABlock = $indentStartsABlock);
  ((__re__ = (array_push)($state.tokens, ($c$$src$Compiler$Token$$Token)($start, $end, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addContentTokenRel = (($ds, $de, $kind, $state) => {
  const $pos = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)(($pos + $ds), ($pos + $de), $kind, $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addError = (($message, $state) => {
  const $end = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $error = (($0) => {
    return ($u$$src$Compiler$Error$$Simple)($0, ($c$$src$Compiler$Pos$$P)($start, $end), ($c$$src$Core$$Cons)($message, $c$$src$Core$$Nil));
  });
  ((__re__ = (array_push)($state.errors, $error)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$getChunk = (($buffer, $state) => {
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $end = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ({
      first: $start,
      second: $end,
      third: (text_slice)($start, $end, $buffer),
    }),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addNumberToken = (($isPercent, $buffer, $state) => {
  const $4 = ((__re__ = ($u$$src$Compiler$Lexer$$getChunk)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = $4.third;
  const $end = $4.second;
  const $start = $4.first;
  return ([
    ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)($start, $end, ($c$$src$Compiler$Token$$NumberLiteral)($isPercent, $chunk), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addParenOrCommaToken = (($char, $state) => {
  const $add = (($0) => {
    return ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenRel)(0, 1, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  });
  const $line = ((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]);
  return ([
    (("(" === $char)
      ? ($add)(($c$$src$Compiler$Token$$RoundParen)($c$$src$Compiler$Token$$Open))
      : ((")" === $char)
        ? ($add)(($c$$src$Compiler$Token$$RoundParen)($c$$src$Compiler$Token$$Closed))
        : (("[" === $char)
          ? ($add)(($c$$src$Compiler$Token$$SquareBracket)($line, $c$$src$Compiler$Token$$Open))
          : (("]" === $char)
            ? ($add)(($c$$src$Compiler$Token$$SquareBracket)($line, $c$$src$Compiler$Token$$Closed))
            : (("{" === $char)
              ? ($add)(($c$$src$Compiler$Token$$CurlyBrace)($line, $c$$src$Compiler$Token$$Open))
              : (("}" === $char)
                ? ($add)(($c$$src$Compiler$Token$$CurlyBrace)($line, $c$$src$Compiler$Token$$Closed))
                : (("," === $char)
                  ? ($add)($c$$src$Compiler$Token$$Comma)
                  : (true
                    ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)(("I can't make sense of this piece of text: `" + ($char + "`")), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 561:4', (sp_toHuman)($char)))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$CoreDefs$$binopsBySymbol = ($c$$src$List$$for)($c$$src$Dict$$empty, $u$$src$Compiler$CoreDefs$$binops, (($bop, $d) => {
  return ($c$$src$Dict$$insert)($bop.symbol, $bop, $d);
}));

const $u$$src$Compiler$Lexer$$addSquiggleToken = (($buffer, $nextIsSpace, $state) => {
  const $4 = ((__re__ = ($u$$src$Compiler$Lexer$$getChunk)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = $4.third;
  const $end = $4.second;
  const $start = $4.first;
  const $add = (($0) => {
    return ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)($start, $end, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((":" === $chunk)
      ? ($add)($c$$src$Compiler$Token$$Colon)
      : (("=" === $chunk)
        ? ($add)($c$$src$Compiler$Token$$Defop)
        : (("?" === $chunk)
          ? ($add)($c$$src$Compiler$Token$$UniquenessPolymorphismBinop)
          : (("!" === $chunk)
            ? ($add)(($c$$src$Compiler$Token$$Unop)($c$$src$Compiler$Op$$UnopUnique))
            : (("@" === $chunk)
              ? ($add)(($c$$src$Compiler$Token$$Unop)($c$$src$Compiler$Op$$UnopRecycle))
              : (("-" === $chunk)
                ? ($add)(($nextIsSpace
                  ? ($c$$src$Compiler$Token$$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $u$$src$Compiler$CoreDefs$$subtract)
                  : ($c$$src$Compiler$Token$$Unop)($c$$src$Compiler$Op$$UnopMinus)))
                : (("+" === $chunk)
                  ? ($add)(($nextIsSpace
                    ? ($c$$src$Compiler$Token$$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $u$$src$Compiler$CoreDefs$$add)
                    : ($c$$src$Compiler$Token$$Unop)($c$$src$Compiler$Op$$UnopPlus)))
                  : (true
                    ? ((() => {
                      const $op = $chunk;
                      const $5 = ($c$$src$Dict$$get)($chunk, $u$$src$Compiler$CoreDefs$$binopsBySymbol);
                      return ((($5)[0] === "$Just")
                        ? ((() => {
                          const $binop = ($5)[1];
                          return ($add)(($c$$src$Compiler$Token$$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $binop));
                        }))()
                        : ((($5)[0] === "$Nothing")
                          ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)(("Invalid operator: `" + ($chunk + "`")), $state)), ($state = (__re__)[1]), (__re__)[0])
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 545:12', (sp_toHuman)($5))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 521:4', (sp_toHuman)($chunk)))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addErrorIf = (($isError, $state, $message) => {
  return ([
    ($isError
      ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)($message, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$parseAttr = (($state, $text) => {
  ((__re__ = ($u$$src$Compiler$Lexer$$addErrorIf)(($u$$src$Compiler$Lexer$$startsWithUpperChar)($text), $state, "record attributes must start with a lowercase letter")), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    $text,
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$parseAttrs = (($state, $ts) => {
  return ([
    ($c$$src$List$$map)((($0) => {
      return ((__re__ = ($u$$src$Compiler$Lexer$$parseAttr)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
    }), $ts),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$parseModule = (($state, $text) => {
  return ([
    $text,
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$parseNameToWord = (($state, $1) => {
  const $attrPath = $1.attrPath;
  const $main = $1.main;
  const $maybeModule = $1.maybeModule;
  const $3 = (text_split)("'", $main);
  return ([
    (((($3)[0] === "$Cons") && (("" === ($3)[1]) && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $raw = (($3)[2])[1];
        ((__re__ = ($u$$src$Compiler$Lexer$$addErrorIf)((sp_not_equal)($attrPath, $c$$src$Core$$Nil), $state, "Constructors don't have any attribute to access")), ($state = (__re__)[1]), (__re__)[0]);
        return ($c$$src$Compiler$Token$$Constructor)(({
          maybeModule: $maybeModule,
          name: $main,
        }));
      }))()
      : (((($3)[0] === "$Cons") && ((($3)[2])[0] === "$Nil"))
        ? ((() => {
          const $name = ($3)[1];
          return (($u$$src$Compiler$Lexer$$startsWithUpperChar)($name)
            ? ((() => {
              ((__re__ = ($u$$src$Compiler$Lexer$$addErrorIf)((sp_not_equal)($attrPath, $c$$src$Core$$Nil), $state, "WAT... Type names don't have attributes to access. =|")), ($state = (__re__)[1]), (__re__)[0]);
              return ($c$$src$Compiler$Token$$Uppercase)(({
                maybeModule: $maybeModule,
                name: $name,
              }));
            }))()
            : ($c$$src$Compiler$Token$$Lowercase)(({
              attrPath: $attrPath,
              maybeModule: $maybeModule,
              name: $name,
            })));
        }))()
        : (true
          ? ((() => {
            ((__re__ = ($u$$src$Compiler$Lexer$$addError)("apostrophes can be used only at the beginning of a constructor name", $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ($c$$src$Compiler$Token$$Constructor)(({
              maybeModule: $c$$src$Maybe$$Nothing,
              name: $main,
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 323:4', (sp_toHuman)($3))))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addWord = (($start, $end, $chunk0, $state) => {
  const $5 = ((() => {
    const $6 = (text_split)("...", $chunk0);
    return (((($6)[0] === "$Cons") && (((($6)[2])[0] === "$Cons") && (("" === (($6)[2])[1]) && (((($6)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $c = ($6)[1];
        return ({
          first: $c,
          second: true,
        });
      }))()
      : (((($6)[0] === "$Cons") && ((($6)[2])[0] === "$Nil"))
        ? ((() => {
          const $c = ($6)[1];
          return ({
            first: $c,
            second: false,
          });
        }))()
        : (true
          ? ({
            first: $chunk0,
            second: false,
          })
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 366:8', (sp_toHuman)($6)))));
  }))();
  const $trailingThreeDots = $5.second;
  const $chunk1 = $5.first;
  const $snips = (text_split)(".", $chunk1);
  ((($0) => {
    return ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)($start, $end, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }))(((($snips)[0] === "$Nil")
    ? ($c$$src$Compiler$Token$$Lowercase)(({
      attrPath: $c$$src$Core$$Nil,
      maybeModule: $c$$src$Maybe$$Nothing,
      name: "THIS IS NOT SUPPOSED TO HAPPEN",
    }))
    : (((($snips)[0] === "$Cons") && ((($snips)[2])[0] === "$Nil"))
      ? ((() => {
        const $main = ($snips)[1];
        return ((__re__ = ($u$$src$Compiler$Lexer$$parseNameToWord)($state, ({
          attrPath: $c$$src$Core$$Nil,
          main: $main,
          maybeModule: $c$$src$Maybe$$Nothing,
        }))), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : (((($snips)[0] === "$Cons") && (("" === ($snips)[1]) && ((($snips)[2])[0] === "$Cons")))
        ? ((() => {
          const $two = (($snips)[2])[1];
          const $rest = (($snips)[2])[2];
          ((__re__ = ($u$$src$Compiler$Lexer$$addErrorIf)(($c$$src$List$$any)((($0) => {
            return (sp_equal)($0, "");
          }), (sp_cons)($two, $rest)), $state, "use spaces around `..` to concatenate Text")), ($state = (__re__)[1]), (__re__)[0]);
          return ($c$$src$Compiler$Token$$RecordShorthand)(({
            attrPath: ((__re__ = ($u$$src$Compiler$Lexer$$parseAttrs)($state, $rest)), ($state = (__re__)[1]), (__re__)[0]),
            name: ((__re__ = ($u$$src$Compiler$Lexer$$parseAttr)($state, $two)), ($state = (__re__)[1]), (__re__)[0]),
          }));
        }))()
        : (((($snips)[0] === "$Cons") && ((($snips)[2])[0] === "$Cons"))
          ? ((() => {
            const $one = ($snips)[1];
            const $two = (($snips)[2])[1];
            const $rest = (($snips)[2])[2];
            ((__re__ = ($u$$src$Compiler$Lexer$$addErrorIf)(($c$$src$List$$any)((($0) => {
              return (sp_equal)($0, "");
            }), $snips), $state, "use spaces around `..` to concatenate Text")), ($state = (__re__)[1]), (__re__)[0]);
            return (($u$$src$Compiler$Lexer$$startsWithUpperChar)($one)
              ? ((() => {
                const $module = ((__re__ = ($u$$src$Compiler$Lexer$$parseModule)($state, $one)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = ($u$$src$Compiler$Lexer$$parseNameToWord)($state, ({
                  attrPath: ((__re__ = ($u$$src$Compiler$Lexer$$parseAttrs)($state, $rest)), ($state = (__re__)[1]), (__re__)[0]),
                  main: $two,
                  maybeModule: ($c$$src$Maybe$$Just)($module),
                }))), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((__re__ = ($u$$src$Compiler$Lexer$$parseNameToWord)($state, ({
                attrPath: ((__re__ = ($u$$src$Compiler$Lexer$$parseAttrs)($state, (sp_cons)($two, $rest))), ($state = (__re__)[1]), (__re__)[0]),
                main: $one,
                maybeModule: $c$$src$Maybe$$Nothing,
              }))), ($state = (__re__)[1]), (__re__)[0]));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 374:4', (sp_toHuman)($snips)))))));
  return ([
    ($trailingThreeDots
      ? ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)(($end - 3), $end, $c$$src$Compiler$Token$$ThreeDots, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$addWordToken = (($buffer, $state) => {
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $end = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = (text_slice)($start, $end, $buffer);
  const $maybeKeywordKind = (("fn" === $chunk)
    ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$Fn)
    : (("if" === $chunk)
      ? ($c$$src$Maybe$$Just)(($c$$src$Compiler$Token$$If)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0])))
      : (("then" === $chunk)
        ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$Then)
        : (("else" === $chunk)
          ? ($c$$src$Maybe$$Just)(($c$$src$Compiler$Token$$Else)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0])))
          : (("try" === $chunk)
            ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$Try)
            : (("as" === $chunk)
              ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$As)
              : (("with" === $chunk)
                ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$With)
                : (("and" === $chunk)
                  ? ($c$$src$Maybe$$Just)(($c$$src$Compiler$Token$$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $u$$src$Compiler$CoreDefs$$and_))
                  : (("or" === $chunk)
                    ? ($c$$src$Maybe$$Just)(($c$$src$Compiler$Token$$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $u$$src$Compiler$CoreDefs$$or_))
                    : (("__" === $chunk)
                      ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$ArgumentPlaceholder)
                      : (("this_is_sp_native" === $chunk)
                        ? ($c$$src$Maybe$$Just)($c$$src$Compiler$Token$$Native)
                        : (true
                          ? $c$$src$Maybe$$Nothing
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 445:8', (sp_toHuman)($chunk))))))))))))));
  return ([
    ((($maybeKeywordKind)[0] === "$Just")
      ? ((() => {
        const $kind = ($maybeKeywordKind)[1];
        return ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : (true
        ? ((__re__ = ($u$$src$Compiler$Lexer$$addWord)($start, $end, $chunk, $state)), ($state = (__re__)[1]), (__re__)[0])
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 459:4', (sp_toHuman)($maybeKeywordKind)))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$isNumber = ((() => {
  const $re = (text_startsWithRegex)("[0-9_.]");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const $u$$src$Compiler$Lexer$$isSquiggle = (($char) => {
  return (("=" === $char)
    ? true
    : ((":" === $char)
      ? true
      : (("*" === $char)
        ? true
        : (("+" === $char)
          ? true
          : (("-" === $char)
            ? true
            : (("/" === $char)
              ? true
              : ((">" === $char)
                ? true
                : (("<" === $char)
                  ? true
                  : (("!" === $char)
                    ? true
                    : (("?" === $char)
                      ? true
                      : (("&" === $char)
                        ? true
                        : (("^" === $char)
                          ? true
                          : (("@" === $char)
                            ? true
                            : (("$" === $char)
                              ? true
                              : (true
                                ? false
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 495:4', (sp_toHuman)($char)))))))))))))))));
});

const $u$$src$Compiler$Lexer$$isWordBody = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z./_0-9']");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const $u$$src$Compiler$Lexer$$isWordStart = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z._']");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const $u$$src$Compiler$Lexer$$setMode = (($mode, $state) => {
  return ([
    ($state.mode = (basics_cloneImm)($mode)),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$thereIsABlankAhead = (($offset, $buffer, $state) => {
  const $start = (text_fromNumber)((((__re__ = (basics_cloneUni)($state.nextPos)), ($state.nextPos = (__re__)[1]), (__re__)[0]) + $offset));
  const $regex = (".{" + ($start + "}\n[ ]*(\n|$)"));
  return ([
    (sp_not_equal)(((text_startsWithRegex)($regex))($buffer), ""),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$tryIndent = (($buffer, $indentChar, $char, $state) => {
  return ([
    (((sp_equal)($char, $indentChar) || (sp_equal)($char, ""))
      ? null
      : (((sp_equal)($char, " ") || (sp_equal)($char, "\t"))
        ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)("mixing tabs and spaces!", $state)), ($state = (__re__)[1]), (__re__)[0])
        : ((sp_equal)($char, "\n")
          ? ((() => {
            ($state.tokenStart = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1));
            return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Indent, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : ((sp_equal)($char, "#")
            ? ((() => {
              const $start = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
              const $column = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]);
              return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$LineComment)(({
                column: $column,
                start: $start,
              })), $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((() => {
              ($state.lineIndent = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]));
              ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))())))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$unindent = (($raw) => {
  return (($c$$src$Basics$$not)((text_startsWith)("\n", $raw))
    ? $raw
    : ((() => {
      const $multilineText = (text_dropLeft)(1, $raw);
      const $lines = (text_split)("\n", $multilineText);
      const $countLeadingSpaces = ((() => {
        const $re = (text_startsWithRegex)("[ ]*");
        return (($line) => {
          return (text_length)(($re)($line));
        });
      }))();
      const $minLead = ((($0) => {
        return ($c$$src$Maybe$$withDefault)(0, $0);
      }))(($c$$src$List$$minimum)(((($0) => {
        return ($c$$src$List$$map)($countLeadingSpaces, $0);
      }))(((($0) => {
        return ($c$$src$List$$filter)((($s) => {
          return (sp_not_equal)((text_trimLeft)($s), "");
        }), $0);
      }))($lines))));
      return ((($0) => {
        return ((text_replaceRegex)("\n[ ]*$"))("", $0);
      }))(((($0) => {
        return ($c$$src$Text$$join)("\n", $0);
      }))(((($0) => {
        return ($c$$src$List$$map)((($0) => {
          return (text_dropLeft)($minLead, $0);
        }), $0);
      }))($lines)));
    }))());
});

const $u$$src$Compiler$Lexer$$lexOne = (($buffer, $char, $state) => {
  const $pos = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  let $4 = ((__re__ = (basics_cloneUni)($state.mode)), ($state.mode = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Indent")
      ? ((() => {
        let $5 = ((__re__ = (basics_cloneUni)($state.tabsOrSpaces)), ($state.tabsOrSpaces = (__re__)[1]), (__re__)[0]);
        return ((($5)[0] === "$Tabs")
          ? ((__re__ = ($u$$src$Compiler$Lexer$$tryIndent)($buffer, "\t", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
          : ((($5)[0] === "$Spaces")
            ? ((__re__ = ($u$$src$Compiler$Lexer$$tryIndent)($buffer, " ", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
            : ((($5)[0] === "$NoTabsOrSpacesYet")
              ? ((" " === $char)
                ? ((() => {
                  ($state.tabsOrSpaces = $u$$src$Compiler$Lexer$$Spaces);
                  return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (("\t" === $char)
                  ? ((() => {
                    ($state.tabsOrSpaces = $u$$src$Compiler$Lexer$$Tabs);
                    return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = ($u$$src$Compiler$Lexer$$tryIndent)($buffer, " ", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 610:20', (sp_toHuman)($char)))))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 601:12', (sp_toHuman)($5)))));
      }))()
      : ((($4)[0] === "$Default")
        ? (("" === $char)
          ? null
          : (("." === $char)
            ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Dot_One, $state)), ($state = (__re__)[1]), (__re__)[0])
            : (("#" === $char)
              ? ((() => {
                const $start = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $column = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]);
                return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$LineComment)(({
                  column: $column,
                  start: $start,
                })), $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (("[" === $char)
                ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$ContentOpeningBlockComment, $state)), ($state = (__re__)[1]), (__re__)[0])
                : (("\"" === $char)
                  ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$ContentOpeningQuotes_One, $state)), ($state = (__re__)[1]), (__re__)[0])
                  : (("\n" === $char)
                    ? ((() => {
                      ($state.tokenStart = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1));
                      ($state.soFarThereAreNoTokensInThisLine = true);
                      return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Indent, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : ((" " === $char)
                      ? ($state.tokenStart = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1))
                      : (true
                        ? ((() => {
                          ($state.tokenStart = ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]));
                          return (($u$$src$Compiler$Lexer$$isWordStart)($char)
                            ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Word, $state)), ($state = (__re__)[1]), (__re__)[0])
                            : (($u$$src$Compiler$Lexer$$isNumber)($char)
                              ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$NumberLiteral, $state)), ($state = (__re__)[1]), (__re__)[0])
                              : (($u$$src$Compiler$Lexer$$isSquiggle)($char)
                                ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Squiggles, $state)), ($state = (__re__)[1]), (__re__)[0])
                                : ((__re__ = ($u$$src$Compiler$Lexer$$addParenOrCommaToken)($char, $state)), ($state = (__re__)[1]), (__re__)[0]))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 626:12', (sp_toHuman)($char))))))))))
        : ((($4)[0] === "$Dot_One")
          ? ((sp_equal)($char, ".")
            ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Dot_Two, $state)), ($state = (__re__)[1]), (__re__)[0])
            : (($u$$src$Compiler$Lexer$$isWordStart)($char)
              ? ((() => {
                ($state.tokenStart = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1));
                return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Word, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (($u$$src$Compiler$Lexer$$isNumber)($char)
                ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$NumberLiteral, $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((__re__ = ($u$$src$Compiler$Lexer$$addError)("no idea what this is", $state)), ($state = (__re__)[1]), (__re__)[0]))))
          : ((($4)[0] === "$Dot_Two")
            ? ((sp_equal)($char, ".")
              ? ((() => {
                ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenRel)(-(1), 1, $c$$src$Compiler$Token$$ThreeDots, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((() => {
                ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenRel)(-(1), 1, ($c$$src$Compiler$Token$$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $u$$src$Compiler$CoreDefs$$textConcat), $state)), ($state = (__re__)[1]), (__re__)[0]);
                ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))())
            : ((($4)[0] === "$Mutable")
              ? (($u$$src$Compiler$Lexer$$isSquiggle)($char)
                ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Squiggles, $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((__re__ = ($u$$src$Compiler$Lexer$$addError)("no idea what this is", $state)), ($state = (__re__)[1]), (__re__)[0]))
              : ((($4)[0] === "$Word")
                ? (($u$$src$Compiler$Lexer$$isWordBody)($char)
                  ? null
                  : ((() => {
                    ((__re__ = ($u$$src$Compiler$Lexer$$addWordToken)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))())
                : ((($4)[0] === "$NumberLiteral")
                  ? (($u$$src$Compiler$Lexer$$isNumber)($char)
                    ? null
                    : ((sp_equal)($char, "%")
                      ? ((() => {
                        ((__re__ = ($u$$src$Compiler$Lexer$$addNumberToken)(true, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : ((() => {
                        ((__re__ = ($u$$src$Compiler$Lexer$$addNumberToken)(false, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()))
                  : ((($4)[0] === "$Squiggles")
                    ? (($u$$src$Compiler$Lexer$$isSquiggle)($char)
                      ? null
                      : ((() => {
                        ((__re__ = ($u$$src$Compiler$Lexer$$addSquiggleToken)($buffer, (sp_equal)($char, " "), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))())
                    : ((($4)[0] === "$ContentOpeningQuotes_One")
                      ? ((sp_equal)($char, "\"")
                        ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$ContentOpeningQuotes_Two, $state)), ($state = (__re__)[1]), (__re__)[0])
                        : ((sp_equal)($char, "")
                          ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)("there's no closing quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                          : ((() => {
                            ($state.tokenStart = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1));
                            ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$SingleQuote)(({
                              lastEscape: -(1),
                            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()))
                      : ((($4)[0] === "$ContentOpeningQuotes_Two")
                        ? ((sp_equal)($char, "\"")
                          ? ((() => {
                            ($state.tokenStart = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 2));
                            return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$TripleQuote)(({
                              closingQuotes: 0,
                              lastEscape: -(1),
                            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : ((() => {
                            ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenRel)(-(2), 0, ($c$$src$Compiler$Token$$TextLiteral)($c$$src$Compiler$Token$$SingleQuote, ""), $state)), ($state = (__re__)[1]), (__re__)[0]);
                            ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))())
                        : ((($4)[0] === "$SingleQuote")
                          ? ((() => {
                            const $lastEscape = ($4)[1].lastEscape;
                            const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                            return ((sp_equal)($char, "")
                              ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)("there's no closing quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                              : ($previousIsEscape
                                ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$SingleQuote)(({
                                  lastEscape: $lastEscape,
                                })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                : (("\"" === $char)
                                  ? ((() => {
                                    const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
                                    const $end = ($pos + 1);
                                    const $value = ((($0) => {
                                      return (text_slice)(($start + 1), ($end - 1), $0);
                                    }))($buffer);
                                    ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)($start, $end, ($c$$src$Compiler$Token$$TextLiteral)($c$$src$Compiler$Token$$SingleQuote, $value), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : (("\\" === $char)
                                    ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$SingleQuote)(({
                                      lastEscape: $pos,
                                    })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                    : (true
                                      ? null
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 775:16', (sp_toHuman)($char)))))));
                          }))()
                          : ((($4)[0] === "$TripleQuote")
                            ? ((() => {
                              const $closingQuotes = ($4)[1].closingQuotes;
                              const $lastEscape = ($4)[1].lastEscape;
                              const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                              return ((sp_equal)($char, "")
                                ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)("unterminated triple quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                                : ($previousIsEscape
                                  ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$TripleQuote)(({
                                    closingQuotes: 0,
                                    lastEscape: $lastEscape,
                                  })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                  : (("\"" === $char)
                                    ? ((sp_equal)($closingQuotes, 2)
                                      ? ((() => {
                                        const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
                                        const $end = ($pos + 1);
                                        ((($0) => {
                                          return ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenAbs)($start, $end, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                        }))(((($0) => {
                                          return ($c$$src$Compiler$Token$$TextLiteral)($c$$src$Compiler$Token$$TripleQuote, $0);
                                        }))(($u$$src$Compiler$Lexer$$unindent)(((($0) => {
                                          return (text_slice)(($start + 3), ($end - 3), $0);
                                        }))($buffer))));
                                        return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                      }))()
                                      : ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$TripleQuote)(({
                                        closingQuotes: ($closingQuotes + 1),
                                        lastEscape: $lastEscape,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0]))
                                    : (("\\" === $char)
                                      ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$TripleQuote)(({
                                        closingQuotes: 0,
                                        lastEscape: $pos,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                      : (true
                                        ? ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$TripleQuote)(({
                                          closingQuotes: 0,
                                          lastEscape: $lastEscape,
                                        })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 818:16', (sp_toHuman)($char)))))));
                            }))()
                            : ((($4)[0] === "$LineComment")
                              ? ((() => {
                                const $column = ($4)[1].column;
                                const $start = ($4)[1].start;
                                return (((sp_equal)($char, "\n") || (sp_equal)($char, ""))
                                  ? ((() => {
                                    ((($0) => {
                                      return ((__re__ = ($u$$src$Compiler$Lexer$$addCommentTokenAbs)($start, ((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]), $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    }))(($c$$src$Compiler$Token$$Comment)(({
                                      indent: $column,
                                      isBlock: false,
                                      isFollowedByBlank: ((__re__ = ($u$$src$Compiler$Lexer$$thereIsABlankAhead)(0, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]),
                                    })));
                                    ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : null);
                              }))()
                              : ((($4)[0] === "$ContentOpeningBlockComment")
                                ? ((sp_equal)($char, "#")
                                  ? ((() => {
                                    const $start = (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1);
                                    const $column = (((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]) - 1);
                                    return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$BlockComment)(({
                                      column: $column,
                                      nesting: 1,
                                      previous: "",
                                      start: $start,
                                    })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : ((() => {
                                    ((__re__ = ($u$$src$Compiler$Lexer$$addContentTokenRel)(-(1), 0, ($c$$src$Compiler$Token$$SquareBracket)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $c$$src$Compiler$Token$$Open), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))())
                                : ((($4)[0] === "$BlockComment")
                                  ? ((() => {
                                    const $column = ($4)[1].column;
                                    const $nesting = ($4)[1].nesting;
                                    const $previous = ($4)[1].previous;
                                    const $start = ($4)[1].start;
                                    const $continueWithDeltaNesting = (($dn) => {
                                      return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)(($u$$src$Compiler$Lexer$$BlockComment)(({
                                        column: $column,
                                        nesting: ($nesting + $dn),
                                        previous: $char,
                                        start: $start,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    });
                                    const $5 = ({
                                      first: $previous,
                                      second: $char,
                                    });
                                    return ((("[" === $5.first) && ("#" === $5.second))
                                      ? ($continueWithDeltaNesting)(1)
                                      : ((("#" === $5.first) && ("]" === $5.second))
                                        ? (($nesting > 1)
                                          ? ($continueWithDeltaNesting)(-(1))
                                          : ((() => {
                                            ((($0) => {
                                              return ((__re__ = ($u$$src$Compiler$Lexer$$addCommentTokenAbs)($start, (((__re__ = ($u$$src$Compiler$Lexer$$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1), $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                            }))(($c$$src$Compiler$Token$$Comment)(({
                                              indent: $column,
                                              isBlock: true,
                                              isFollowedByBlank: ((__re__ = ($u$$src$Compiler$Lexer$$thereIsABlankAhead)(1, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]),
                                            })));
                                            return ((__re__ = ($u$$src$Compiler$Lexer$$setMode)($u$$src$Compiler$Lexer$$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                          }))())
                                        : (("" === $5.second)
                                          ? ((__re__ = ($u$$src$Compiler$Lexer$$addError)("unterminated block comment", $state)), ($state = (__re__)[1]), (__re__)[0])
                                          : (true
                                            ? ($continueWithDeltaNesting)(0)
                                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 882:12', (sp_toHuman)($5))))));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 598:4', (sp_toHuman)($4))))))))))))))))),
    $state,
  ]);
});

const $u$$src$Compiler$Lexer$$readStateInit = (($keepComments) => {
  return ({
    column: 0,
    errors: (array_fromList)($c$$src$Core$$Nil),
    indentStack: (array_fromList)($c$$src$Core$$Nil),
    indentStartsABlock: true,
    keepComments: (basics_cloneImm)($keepComments),
    line: 0,
    lineIndent: 0,
    mode: $u$$src$Compiler$Lexer$$Indent,
    nextPos: 0,
    sections: (array_fromList)($c$$src$Core$$Nil),
    soFarThereAreNoTokensInThisLine: true,
    tabsOrSpaces: $u$$src$Compiler$Lexer$$NoTabsOrSpacesYet,
    tokenStart: 0,
    tokens: (array_fromList)($c$$src$Core$$Nil),
  });
});

const $u$$src$Compiler$Lexer$$lexer = (($keepComments, $module) => {
  const $moduleCode = $module.content;
  let $state = ($u$$src$Compiler$Lexer$$readStateInit)($keepComments);
  (text_forEach)($moduleCode, (($char) => {
    ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($moduleCode, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
    ($state.nextPos += 1);
    return ((sp_equal)($char, "\n")
      ? ((() => {
        ($state.line += 1);
        return ($state.column = 0);
      }))()
      : ($state.column += 1));
  }));
  ((__re__ = ($u$$src$Compiler$Lexer$$lexOne)($moduleCode, "", $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $3 = ((__re__ = (array_toList)($state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ((($3)[0] === "$Nil")
    ? ((() => {
      ((__re__ = ($u$$src$Compiler$Lexer$$closeOpenBlocks)($state)), ($state = (__re__)[1]), (__re__)[0]);
      return ($c$$src$Result$$Ok)(((__re__ = (array_toList)($state.sections)), ($state.sections = (__re__)[1]), (__re__)[0]));
    }))()
    : (true
      ? ((() => {
        const $errors = $3;
        return ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Nested)(((($0) => {
          return ($c$$src$List$$map)((($e) => {
            return ($e)($module);
          }), $0);
        }))($errors)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 990:4', (sp_toHuman)($3))));
});

const $u$$src$Compiler$Parser$$makeError = (($env, $farthestParsed, $message) => {
  return ((($0) => {
    return ($u$$src$Compiler$Error$$res)($env.errorModule, $0, ($c$$src$Core$$Cons)($message, $c$$src$Core$$Nil));
  }))(((($farthestParsed)[0] === "$Nil")
    ? ($c$$src$Compiler$Pos$$P)(0, 1)
    : (((($farthestParsed)[0] === "$Cons") && ((($farthestParsed)[1])[0] === "$Token"))
      ? ((() => {
        const $start = (($farthestParsed)[1])[1];
        const $end = (($farthestParsed)[1])[2];
        const $k = (($farthestParsed)[1])[3];
        const $rest = ($farthestParsed)[2];
        return ($c$$src$Compiler$Pos$$P)($start, $end);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 860:4', (sp_toHuman)($farthestParsed)))));
});

const $u$$src$Compiler$Parser$$eatComments = (($readState) => {
  const $2 = $readState.tokens;
  return (((($2)[0] === "$Cons") && (((($2)[1])[0] === "$Token") && (((($2)[1])[3])[0] === "$Comment")))
    ? ((() => {
      const $start = (($2)[1])[1];
      const $end = (($2)[1])[2];
      const $indent = ((($2)[1])[3])[1].indent;
      const $isBlock = ((($2)[1])[3])[1].isBlock;
      const $isFollowedByBlank = ((($2)[1])[3])[1].isFollowedByBlank;
      const $tail = ($2)[2];
      return ($u$$src$Compiler$Parser$$eatComments)(({
        commentsReversed: ($c$$src$Core$$Cons)(({
          end: $end,
          indent: $indent,
          isBlock: $isBlock,
          isFollowedByBlank: $isFollowedByBlank,
          start: $start,
        }), $readState.commentsReversed),
        tokens: $tail,
      }));
    }))()
    : (true
      ? $readState
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 24:4', (sp_toHuman)($2))));
});

const $u$$src$SPLib$Parser$$accept = (($a) => {
  return (($rejections, $readState) => {
    return ({
      first: $rejections,
      second: ($u$$src$SPLib$Parser$$Accepted)($readState, $a),
    });
  });
});

const $u$$src$Compiler$Parser$$ok = $u$$src$SPLib$Parser$$accept;

const $u$$src$SPLib$Parser$$thenWithDefault = (($fallbackParser, $chainedParser) => {
  return (($firstParser) => {
    return (($re0, $readState) => {
      const $6 = ($firstParser)($re0, $readState);
      return ((($6.second)[0] === "$Aborted")
        ? ((() => {
          const $re1 = $6.first;
          const $rs = ($6.second)[1];
          const $reason = ($6.second)[2];
          return ({
            first: $re1,
            second: ($u$$src$SPLib$Parser$$Aborted)($rs, $reason),
          });
        }))()
        : ((($6.second)[0] === "$Rejected")
          ? ((() => {
            const $re1 = $6.first;
            return ($fallbackParser)($re1, $readState);
          }))()
          : ((($6.second)[0] === "$Accepted")
            ? ((() => {
              const $re1 = $6.first;
              const $nextReadState = ($6.second)[1];
              const $a = ($6.second)[2];
              return (($chainedParser)($a))($re1, $nextReadState);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 86:4', (sp_toHuman)($6)))));
    });
  });
});

const $u$$src$Compiler$Parser$$forZeroOrMore = (($init, $getParser) => {
  return (($u$$src$SPLib$Parser$$thenWithDefault)(($u$$src$Compiler$Parser$$ok)($init), (($0) => {
    return ($u$$src$Compiler$Parser$$forZeroOrMore)($0, $getParser);
  })))(($getParser)($init));
});

const $u$$src$SPLib$Parser$$andThen = (($chainedParser) => {
  return (($firstParser) => {
    return (($re0, $readState) => {
      const $5 = ($firstParser)($re0, $readState);
      return ((($5.second)[0] === "$Accepted")
        ? ((() => {
          const $re1 = $5.first;
          const $nextReadState = ($5.second)[1];
          const $a = ($5.second)[2];
          return (($chainedParser)($a))($re1, $nextReadState);
        }))()
        : ((($5.second)[0] === "$Rejected")
          ? ((() => {
            const $re1 = $5.first;
            return ({
              first: $re1,
              second: $u$$src$SPLib$Parser$$Rejected,
            });
          }))()
          : ((($5.second)[0] === "$Aborted")
            ? ((() => {
              const $re1 = $5.first;
              const $rs = ($5.second)[1];
              const $e = ($5.second)[2];
              return ({
                first: $re1,
                second: ($u$$src$SPLib$Parser$$Aborted)($rs, $e),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 75:4', (sp_toHuman)($5)))));
    });
  });
});

const $u$$src$Compiler$Parser$$on = $u$$src$SPLib$Parser$$andThen;

const $u$$src$Compiler$Parser$$oneToken = (($rejections, $rs) => {
  const $readState = ($u$$src$Compiler$Parser$$eatComments)($rs);
  const $3 = $readState.tokens;
  return ((($3)[0] === "$Nil")
    ? ({
      first: ($c$$src$Core$$Cons)($readState, $rejections),
      second: $u$$src$SPLib$Parser$$Rejected,
    })
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $token = ($3)[1];
        const $tail = ($3)[2];
        return ({
          first: $rejections,
          second: ($u$$src$SPLib$Parser$$Accepted)(((() => {
            const $0 = $readState;
            return (Object.assign)({}, $0, ({
              tokens: $tail,
            }));
          }))(), $token),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 46:4', (sp_toHuman)($3))));
});

const $u$$src$SPLib$Parser$$reject = (($rejections, $readState) => {
  return ({
    first: (sp_cons)($readState, $rejections),
    second: $u$$src$SPLib$Parser$$Rejected,
  });
});

const $u$$src$Compiler$Parser$$kind = (($targetKind) => {
  return (($u$$src$Compiler$Parser$$on)((($token) => {
    const $3 = $token;
    const $k = ($3)[3];
    return ((sp_equal)($targetKind, $k)
      ? ($u$$src$Compiler$Parser$$ok)($token)
      : $u$$src$SPLib$Parser$$reject);
  })))($u$$src$Compiler$Parser$$oneToken);
});

const $u$$src$Compiler$Parser$$stackCommentsReversedAsStatements = (($comments, $acc) => {
  return ($c$$src$List$$forReversed)($acc, $comments, (($comment, $accN) => {
    return (sp_cons)(($c$$src$Compiler$FormattableAst$$CommentStatement)($comment), $accN);
  }));
});

const $u$$src$Compiler$Parser$$mkLine = (($env, $line) => {
  return ($env.stripLocations
    ? -(1)
    : $line);
});

const $u$$src$Compiler$Parser$$pos = (($env, $start, $end) => {
  return ($env.stripLocations
    ? $c$$src$Compiler$Pos$$T
    : ($c$$src$Compiler$Pos$$P)($start, $end));
});

const $u$$src$Compiler$Parser$$pullCommentsReversed = (($rejections, $rs) => {
  const $readState = ($u$$src$Compiler$Parser$$eatComments)($rs);
  return ({
    first: $rejections,
    second: ($u$$src$SPLib$Parser$$Accepted)(((() => {
      const $0 = $readState;
      return (Object.assign)({}, $0, ({
        commentsReversed: $c$$src$Core$$Nil,
      }));
    }))(), $readState.commentsReversed),
  });
});

const $u$$src$Compiler$Parser$$binop = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($2) => {
    const $start = ($2)[1];
    const $end = ($2)[2];
    const $k = ($2)[3];
    return ((($k)[0] === "$Binop")
      ? ((() => {
        const $line = ($k)[1];
        const $precedence = ($k)[2].precedence;
        const $symbol = ($k)[2].symbol;
        const $usr = ($k)[2].usr;
        return (($u$$src$Compiler$Parser$$on)((($commentsReversed) => {
          return ($u$$src$Compiler$Parser$$ok)(({
            comments: ($c$$src$List$$reverse)($commentsReversed),
            line: ($u$$src$Compiler$Parser$$mkLine)($env, $line),
            pos: ($u$$src$Compiler$Parser$$pos)($env, $start, $end),
            precedence: $precedence,
            symbol: $symbol,
            usr: $usr,
          }));
        })))($u$$src$Compiler$Parser$$pullCommentsReversed);
      }))()
      : (true
        ? $u$$src$SPLib$Parser$$reject
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 634:4', (sp_toHuman)($k))));
  })))($u$$src$Compiler$Parser$$oneToken);
});

const $u$$src$SPLib$Parser$$surroundWith = (($left, $right, $parser) => {
  return (($u$$src$SPLib$Parser$$andThen)(((_0) => {
    return (($u$$src$SPLib$Parser$$andThen)((($p) => {
      return (($u$$src$SPLib$Parser$$andThen)(((_0) => {
        return ($u$$src$SPLib$Parser$$accept)($p);
      })))($right);
    })))($parser);
  })))($left);
});

const $u$$src$Compiler$Parser$$surroundStrict = (($left, $right, $p) => {
  return ($u$$src$SPLib$Parser$$surroundWith)(($u$$src$Compiler$Parser$$kind)($left), ($u$$src$Compiler$Parser$$kind)($right), $p);
});

const $u$$src$Compiler$Parser$$block = (($0) => {
  return ($u$$src$Compiler$Parser$$surroundStrict)($c$$src$Compiler$Token$$BlockStart, $c$$src$Compiler$Token$$BlockEnd, $0);
});

const $u$$src$Compiler$Parser$$discardFirst = (($a, $b) => {
  return (($u$$src$Compiler$Parser$$on)(((_0) => {
    return $b;
  })))($a);
});

const $u$$src$Compiler$Parser$$sib = (($0) => {
  return ($u$$src$Compiler$Parser$$discardFirst)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$NewSiblingLine), $0);
});

const $u$$src$SPLib$Parser$$here = (($rejections, $readState) => {
  return ({
    first: $rejections,
    second: ($u$$src$SPLib$Parser$$Accepted)($readState, $readState),
  });
});

const $u$$src$Compiler$Parser$$here = (($u$$src$Compiler$Parser$$on)((($readState) => {
  return ($u$$src$Compiler$Parser$$ok)(((() => {
    const $2 = $readState.tokens;
    return (((($2)[0] === "$Cons") && ((($2)[1])[0] === "$Token"))
      ? ((() => {
        const $start = (($2)[1])[1];
        const $end = (($2)[1])[2];
        const $rest = ($2)[2];
        return $start;
      }))()
      : ((($2)[0] === "$Nil")
        ? 0
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 77:4', (sp_toHuman)($2))));
  }))());
})))($u$$src$SPLib$Parser$$here);

const $u$$src$Compiler$Parser$$siblingStatements = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($start) => {
    return (($u$$src$Compiler$Parser$$on)((($acc) => {
      return (($u$$src$Compiler$Parser$$on)((($reversedStatements) => {
        return (($u$$src$Compiler$Parser$$on)((($end) => {
          return (((($reversedStatements)[0] === "$Cons") && (((($reversedStatements)[1])[0] === "$Evaluation") && ((($reversedStatements)[2])[0] === "$Nil")))
            ? ((() => {
              const $e = (($reversedStatements)[1])[1];
              return ($u$$src$Compiler$Parser$$ok)($e);
            }))()
            : (true
              ? ((() => {
                const $many = $reversedStatements;
                return ($u$$src$Compiler$Parser$$ok)(((($0) => {
                  return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, ($u$$src$Compiler$Parser$$pos)($env, $start, $end), $0);
                }))(($c$$src$Compiler$FormattableAst$$Statements)(($c$$src$List$$reverse)($many))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 275:4', (sp_toHuman)($reversedStatements))));
        })))($u$$src$Compiler$Parser$$here);
      })))(($u$$src$Compiler$Parser$$forZeroOrMore)($acc, (($a) => {
        return ($u$$src$Compiler$Parser$$discardFirst)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$NewSiblingLine), ($u$$src$Compiler$Parser$$statementParser)($env, $a));
      })));
    })))(($u$$src$Compiler$Parser$$statementParser)($env, $c$$src$Core$$Nil));
  })))($u$$src$Compiler$Parser$$here);
});

const $u$$src$SPLib$Parser$$oneOf = (($ps) => {
  return (($rejections, $readState) => {
    return ((($ps)[0] === "$Nil")
      ? ({
        first: $rejections,
        second: $u$$src$SPLib$Parser$$Rejected,
      })
      : ((($ps)[0] === "$Cons")
        ? ((() => {
          const $headParser = ($ps)[1];
          const $tailParsers = ($ps)[2];
          const $4 = ($headParser)($rejections, $readState);
          return ((($4.second)[0] === "$Rejected")
            ? ((() => {
              const $re1 = $4.first;
              return (($u$$src$SPLib$Parser$$oneOf)($tailParsers))($re1, $readState);
            }))()
            : (true
              ? ((() => {
                const $acceptedOrAborted = $4;
                return $acceptedOrAborted;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 144:12', (sp_toHuman)($4))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 138:4', (sp_toHuman)($ps))));
  });
});

const $u$$src$Compiler$Parser$$alignedOrInlineStatements = (($env) => {
  return ($u$$src$SPLib$Parser$$oneOf)(($c$$src$Core$$Cons)((($u$$src$Compiler$Parser$$on)((($e) => {
    return ($u$$src$Compiler$Parser$$ok)(({
      first: $c$$src$Compiler$FormattableAst$$Indented,
      second: $e,
    }));
  })))(($u$$src$Compiler$Parser$$block)(($u$$src$Compiler$Parser$$siblingStatements)($env))), ($c$$src$Core$$Cons)((($u$$src$Compiler$Parser$$on)((($e) => {
    return ($u$$src$Compiler$Parser$$ok)(({
      first: $c$$src$Compiler$FormattableAst$$Aligned,
      second: $e,
    }));
  })))(($u$$src$Compiler$Parser$$sib)(($u$$src$Compiler$Parser$$siblingStatements)($env))), ($c$$src$Core$$Cons)((($u$$src$Compiler$Parser$$on)((($e) => {
    return ($u$$src$Compiler$Parser$$ok)(({
      first: $c$$src$Compiler$FormattableAst$$Inline,
      second: $e,
    }));
  })))(($u$$src$Compiler$Parser$$expr)($env)), $c$$src$Core$$Nil))));
});

const $u$$src$Compiler$Parser$$discardSecond = (($a, $b) => {
  return (($u$$src$Compiler$Parser$$on)((($aa) => {
    return (($u$$src$Compiler$Parser$$on)(((_0) => {
      return ($u$$src$Compiler$Parser$$ok)($aa);
    })))($b);
  })))($a);
});

const $u$$src$Compiler$Parser$$indentedOrInlineStatements = (($env) => {
  return ($u$$src$SPLib$Parser$$oneOf)(($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$block)(($u$$src$Compiler$Parser$$siblingStatements)($env)), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$expr)($env), $c$$src$Core$$Nil)));
});

const $u$$src$Compiler$Parser$$inlineOrBelowOrIndented = (($p) => {
  return ($u$$src$SPLib$Parser$$oneOf)(($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$block)($p), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$sib)($p), ($c$$src$Core$$Cons)($p, $c$$src$Core$$Nil))));
});

const $u$$src$SPLib$Parser$$maybe = (($p) => {
  return (($u$$src$SPLib$Parser$$thenWithDefault)(($u$$src$SPLib$Parser$$accept)($c$$src$Maybe$$Nothing), (($x) => {
    return ($u$$src$SPLib$Parser$$accept)(($c$$src$Maybe$$Just)($x));
  })))($p);
});

const $u$$src$Compiler$Parser$$maybe = $u$$src$SPLib$Parser$$maybe;

const $u$$src$Compiler$Parser$$maybeNewLine = (($0) => {
  return ($u$$src$Compiler$Parser$$discardFirst)(($u$$src$SPLib$Parser$$maybe)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$NewSiblingLine)), $0);
});

const $u$$src$SPLib$Parser$$zeroOrMore = (($p) => {
  return (($u$$src$SPLib$Parser$$thenWithDefault)(($u$$src$SPLib$Parser$$accept)($c$$src$Core$$Nil), (($head) => {
    return (($u$$src$SPLib$Parser$$andThen)((($tail) => {
      return ($u$$src$SPLib$Parser$$accept)((sp_cons)($head, $tail));
    })))(($u$$src$SPLib$Parser$$zeroOrMore)($p));
  })))($p);
});

const $u$$src$Compiler$Parser$$oomSeparatedBy = (($sep, $pa) => {
  return (($u$$src$Compiler$Parser$$on)((($head) => {
    return (($u$$src$Compiler$Parser$$on)((($tail) => {
      return ($u$$src$Compiler$Parser$$ok)((sp_cons)($head, $tail));
    })))(($u$$src$SPLib$Parser$$zeroOrMore)(($u$$src$Compiler$Parser$$discardFirst)($sep, $pa)));
  })))($pa);
});

const $u$$src$Compiler$Parser$$rawList = (($item) => {
  const $sibsep = ($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Comma));
  return ($u$$src$Compiler$Parser$$discardFirst)(($u$$src$SPLib$Parser$$maybe)($sibsep), ($u$$src$Compiler$Parser$$oomSeparatedBy)($sibsep, $item));
});

const $u$$src$Compiler$Parser$$expressionWithUnambiguousStart = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($commentsReversed) => {
    return (($u$$src$Compiler$Parser$$on)((($3) => {
      const $start = ($3)[1];
      const $end = ($3)[2];
      const $kk = ($3)[3];
      const $expressionOk = (($e) => {
        return ($u$$src$Compiler$Parser$$ok)(($u$$src$Compiler$Parser$$E_under)($e));
      });
      const $b = ((($kk)[0] === "$Lowercase")
        ? ((() => {
          const $attrPath = ($kk)[1].attrPath;
          const $maybeModule = ($kk)[1].maybeModule;
          const $name = ($kk)[1].name;
          return (($u$$src$Compiler$Parser$$on)((($maybeType) => {
            return ($expressionOk)(($c$$src$Compiler$FormattableAst$$Lowercase)(({
              attrPath: $attrPath,
              maybeModule: $maybeModule,
              maybeType: $maybeType,
              name: $name,
            })));
          })))(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$discardFirst)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$As), ($u$$src$Compiler$Parser$$expr)($env))));
        }))()
        : ((($kk)[0] === "$Constructor")
          ? ((() => {
            const $pas = ($kk)[1];
            return ($expressionOk)(($c$$src$Compiler$FormattableAst$$Constructor)($pas));
          }))()
          : ((($kk)[0] === "$Uppercase")
            ? ((() => {
              const $pas = ($kk)[1];
              return ($expressionOk)(($c$$src$Compiler$FormattableAst$$Uppercase)($pas));
            }))()
            : ((($kk)[0] === "$RecordShorthand")
              ? ((() => {
                const $pas = ($kk)[1];
                return ($expressionOk)(($c$$src$Compiler$FormattableAst$$RecordShorthand)($pas));
              }))()
              : ((($kk)[0] === "$ArgumentPlaceholder")
                ? ($expressionOk)($c$$src$Compiler$FormattableAst$$ArgumentPlaceholder)
                : ((($kk)[0] === "$NumberLiteral")
                  ? ((() => {
                    const $isPercent = ($kk)[1];
                    const $s = ($kk)[2];
                    return (($u$$src$Compiler$Parser$$on)((($maybeUniPoly) => {
                      return ($expressionOk)(((($maybeUniPoly)[0] === "$Nothing")
                        ? ($c$$src$Compiler$FormattableAst$$LiteralNumber)($isPercent, $s)
                        : ((($maybeUniPoly)[0] === "$Just")
                          ? ((() => {
                            const $exp = ($maybeUniPoly)[1];
                            return ($c$$src$Compiler$FormattableAst$$Poly)($s, $exp);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 389:16', (sp_toHuman)($maybeUniPoly)))));
                    })))(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$discardFirst)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$UniquenessPolymorphismBinop), ($u$$src$Compiler$Parser$$expr)($env))));
                  }))()
                  : ((($kk)[0] === "$TextLiteral")
                    ? ((() => {
                      const $singleOrTriple = ($kk)[1];
                      const $s = ($kk)[2];
                      return ($expressionOk)(($c$$src$Compiler$FormattableAst$$LiteralText)($singleOrTriple, $s));
                    }))()
                    : (((($kk)[0] === "$RoundParen") && ((($kk)[1])[0] === "$Open"))
                      ? (($u$$src$Compiler$Parser$$on)((($e) => {
                        return ($u$$src$Compiler$Parser$$ok)(($u$$src$Compiler$Parser$$E_full)($e));
                      })))(($u$$src$Compiler$Parser$$discardSecond)(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$expr)($env)), ($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$kind)(($c$$src$Compiler$Token$$RoundParen)($c$$src$Compiler$Token$$Closed)))))
                      : (((($kk)[0] === "$SquareBracket") && ((($kk)[2])[0] === "$Open"))
                        ? ((() => {
                          const $openRow = ($kk)[1];
                          const $item = (($u$$src$Compiler$Parser$$on)((($exp) => {
                            return (($u$$src$Compiler$Parser$$on)((($maybeDots) => {
                              return ($u$$src$Compiler$Parser$$ok)(({
                                first: (sp_not_equal)($maybeDots, $c$$src$Maybe$$Nothing),
                                second: $exp,
                              }));
                            })))(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$ThreeDots)));
                          })))(($u$$src$Compiler$Parser$$expr)($env));
                          const $closeBracket = (($u$$src$Compiler$Parser$$on)((($4) => {
                            const $k = ($4)[3];
                            return (((($k)[0] === "$SquareBracket") && ((($k)[2])[0] === "$Closed"))
                              ? ((() => {
                                const $line = ($k)[1];
                                return ($u$$src$Compiler$Parser$$ok)($line);
                              }))()
                              : (true
                                ? $u$$src$SPLib$Parser$$reject
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 415:20', (sp_toHuman)($k))));
                          })))($u$$src$Compiler$Parser$$oneToken);
                          return (($u$$src$Compiler$Parser$$on)((($exps) => {
                            return (($u$$src$Compiler$Parser$$on)((($closeRow) => {
                              return ($expressionOk)(($c$$src$Compiler$FormattableAst$$List)(($closeRow > $openRow), ($c$$src$Maybe$$withDefault)($c$$src$Core$$Nil, $exps)));
                            })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)($closeBracket));
                          })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$rawList)($item))));
                        }))()
                        : (((($kk)[0] === "$CurlyBrace") && ((($kk)[2])[0] === "$Open"))
                          ? ((() => {
                            const $openRow = ($kk)[1];
                            const $extension = ($u$$src$Compiler$Parser$$discardSecond)(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$expr)($env)), ($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$With));
                            const $attribute = (($u$$src$Compiler$Parser$$on)(((_0) => {
                              return (($u$$src$Compiler$Parser$$on)((($name) => {
                                return (($u$$src$Compiler$Parser$$on)((($maybeExpr) => {
                                  return ($u$$src$Compiler$Parser$$ok)(({
                                    maybeExpr: $maybeExpr,
                                    name: $name,
                                  }));
                                })))(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$discardFirst)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Defop), ($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$expr)($env)))));
                              })))(($u$$src$Compiler$Parser$$expr)($env));
                            })))(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$NewSiblingLine)));
                            const $closeBrace = (($u$$src$Compiler$Parser$$on)((($4) => {
                              const $k = ($4)[3];
                              return (((($k)[0] === "$CurlyBrace") && ((($k)[2])[0] === "$Closed"))
                                ? ((() => {
                                  const $line = ($k)[1];
                                  return ($u$$src$Compiler$Parser$$ok)($line);
                                }))()
                                : (true
                                  ? $u$$src$SPLib$Parser$$reject
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 441:20', (sp_toHuman)($k))));
                            })))($u$$src$Compiler$Parser$$oneToken);
                            return (($u$$src$Compiler$Parser$$on)((($maybeExtension) => {
                              return (($u$$src$Compiler$Parser$$on)((($attrs) => {
                                return (($u$$src$Compiler$Parser$$on)((($closeRow) => {
                                  return ($expressionOk)(($c$$src$Compiler$FormattableAst$$Record)(({
                                    attrs: ($c$$src$Maybe$$withDefault)($c$$src$Core$$Nil, $attrs),
                                    isMultiline: ($closeRow > $openRow),
                                    maybeExtension: $maybeExtension,
                                  })));
                                })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)($closeBrace));
                              })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$rawList)($attribute))));
                            })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$maybe)($extension)));
                          }))()
                          : ((($kk)[0] === "$Fn")
                            ? (($u$$src$Compiler$Parser$$on)((($args) => {
                              return (($u$$src$Compiler$Parser$$on)(((_0) => {
                                return (($u$$src$Compiler$Parser$$on)((($6) => {
                                  const $isMultiline = $6.first;
                                  const $body = $6.second;
                                  return ($expressionOk)(($c$$src$Compiler$FormattableAst$$Fn)($isMultiline, $args, $body));
                                })))(($u$$src$Compiler$Parser$$alignedOrInlineStatements)($env));
                              })))(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Colon));
                            })))(($u$$src$Compiler$Parser$$rawList)(($u$$src$Compiler$Parser$$expr)($env)))
                            : ((($kk)[0] === "$If")
                              ? ((() => {
                                const $ifLine = ($kk)[1];
                                const $elseParser = (($u$$src$Compiler$Parser$$on)((($4) => {
                                  const $k = ($4)[3];
                                  return ((($k)[0] === "$Else")
                                    ? ((() => {
                                      const $line = ($k)[1];
                                      return ($u$$src$Compiler$Parser$$ok)($line);
                                    }))()
                                    : (true
                                      ? $u$$src$SPLib$Parser$$reject
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 472:20', (sp_toHuman)($k))));
                                })))($u$$src$Compiler$Parser$$oneToken);
                                return (($u$$src$Compiler$Parser$$on)((($condition) => {
                                  return (($u$$src$Compiler$Parser$$on)(((_0) => {
                                    return (($u$$src$Compiler$Parser$$on)((($6) => {
                                      const $true = $6.second;
                                      return (($u$$src$Compiler$Parser$$on)((($elseLine) => {
                                        return (($u$$src$Compiler$Parser$$on)((($8) => {
                                          const $false = $8.second;
                                          return ($expressionOk)(($c$$src$Compiler$FormattableAst$$If)(({
                                            condition: $condition,
                                            false: $false,
                                            isMultiline: ($elseLine > $ifLine),
                                            true: $true,
                                          })));
                                        })))(($u$$src$Compiler$Parser$$alignedOrInlineStatements)($env));
                                      })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)($elseParser));
                                    })))(($u$$src$Compiler$Parser$$alignedOrInlineStatements)($env));
                                  })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Then)));
                                })))(($u$$src$Compiler$Parser$$expr)($env));
                              }))()
                              : ((($kk)[0] === "$Try")
                                ? ((() => {
                                  const $maybeNewLineKind = (($k) => {
                                    return ($u$$src$Compiler$Parser$$maybeNewLine)(($u$$src$Compiler$Parser$$kind)($k));
                                  });
                                  const $patternAndValue = (($u$$src$Compiler$Parser$$on)((($p) => {
                                    return (($u$$src$Compiler$Parser$$on)(((_0) => {
                                      return (($u$$src$Compiler$Parser$$on)((($value) => {
                                        return ($u$$src$Compiler$Parser$$ok)(({
                                          first: $p,
                                          second: $value,
                                        }));
                                      })))(($u$$src$Compiler$Parser$$indentedOrInlineStatements)($env));
                                    })))(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Colon));
                                  })))(($u$$src$Compiler$Parser$$expr)($env));
                                  return (($u$$src$Compiler$Parser$$on)((($value) => {
                                    return (($u$$src$Compiler$Parser$$on)(((_0) => {
                                      return (($u$$src$Compiler$Parser$$on)((($patterns) => {
                                        return ($expressionOk)(($c$$src$Compiler$FormattableAst$$Try)(({
                                          patterns: $patterns,
                                          value: $value,
                                        })));
                                      })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$oomSeparatedBy)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$NewSiblingLine), $patternAndValue)));
                                    })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$As)));
                                  })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$expr)($env)));
                                }))()
                                : ((($kk)[0] === "$Unop")
                                  ? ((() => {
                                    const $op = ($kk)[1];
                                    return (($u$$src$Compiler$Parser$$on)((($e) => {
                                      return ($expressionOk)(($c$$src$Compiler$FormattableAst$$UnopCall)($op, $e));
                                    })))(($u$$src$Compiler$Parser$$expressionWithUnambiguousStart)($env));
                                  }))()
                                  : ((($kk)[0] === "$Native")
                                    ? ($expressionOk)($c$$src$Compiler$FormattableAst$$Native)
                                    : (true
                                      ? $u$$src$SPLib$Parser$$reject
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 360:8', (sp_toHuman)($kk))))))))))))))))));
      return (($u$$src$Compiler$Parser$$on)((($ee) => {
        return ((($ee)[0] === "$E_under")
          ? ((() => {
            const $expr_ = ($ee)[1];
            return ($u$$src$Compiler$Parser$$ok)(($c$$src$Compiler$FormattableAst$$Expression)(($c$$src$List$$reverse)($commentsReversed), ($u$$src$Compiler$Parser$$pos)($env, $start, $end), $expr_));
          }))()
          : ((($ee)[0] === "$E_full")
            ? ((() => {
              const $expression = ($ee)[1];
              return ((sp_equal)($commentsReversed, $c$$src$Core$$Nil)
                ? ($u$$src$Compiler$Parser$$ok)($expression)
                : ($u$$src$Compiler$Parser$$ok)(((($0) => {
                  return ($c$$src$Compiler$FormattableAst$$Expression)(($c$$src$List$$reverse)($commentsReversed), ($u$$src$Compiler$Parser$$pos)($env, $start, $end), $0);
                }))(($c$$src$Compiler$FormattableAst$$Statements)(($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$Evaluation)($expression), $c$$src$Core$$Nil)))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 528:4', (sp_toHuman)($ee))));
      })))($b);
    })))($u$$src$Compiler$Parser$$oneToken);
  })))($u$$src$Compiler$Parser$$pullCommentsReversed);
});

const $u$$src$Compiler$Parser$$posRange = (($exprs) => {
  return ((($exprs)[0] === "$Nil")
    ? $c$$src$Compiler$Pos$$G
    : (((($exprs)[0] === "$Cons") && ((($exprs)[1])[0] === "$Expression"))
      ? ((() => {
        const $start = (($exprs)[1])[2];
        const $tail = ($exprs)[2];
        const $2 = ($c$$src$List$$last)($tail);
        return (((($2)[0] === "$Just") && ((($2)[1])[0] === "$Expression"))
          ? ((() => {
            const $end = (($2)[1])[2];
            return ($c$$src$Compiler$Pos$$range)($start, $end);
          }))()
          : ((($2)[0] === "$Nothing")
            ? $start
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 754:12', (sp_toHuman)($2))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 748:4', (sp_toHuman)($exprs))));
});

const $u$$src$Compiler$Parser$$functionApplication = (($env) => {
  const $term = ($u$$src$Compiler$Parser$$expressionWithUnambiguousStart)($env);
  return (($u$$src$Compiler$Parser$$on)((($ref) => {
    return (($u$$src$Compiler$Parser$$on)((($inlineArgs) => {
      return (($u$$src$Compiler$Parser$$on)((($indentedArgs) => {
        const $args = ($c$$src$List$$concat)(($c$$src$Core$$Cons)($inlineArgs, ($c$$src$Core$$Cons)(($c$$src$Maybe$$withDefault)($c$$src$Core$$Nil, $indentedArgs), $c$$src$Core$$Nil)));
        return ((sp_equal)($args, $c$$src$Core$$Nil)
          ? ($u$$src$Compiler$Parser$$ok)($ref)
          : ((() => {
            const $p = ($u$$src$Compiler$Parser$$posRange)(($c$$src$Core$$Cons)($ref, $args));
            return (((($ref)[0] === "$Expression") && ((($ref)[3])[0] === "$UnopCall"))
              ? ((() => {
                const $comments = ($ref)[1];
                const $p1 = ($ref)[2];
                const $op = (($ref)[3])[1];
                const $unoped = (($ref)[3])[2];
                return ($u$$src$Compiler$Parser$$ok)(((($0) => {
                  return ($c$$src$Compiler$FormattableAst$$Expression)($comments, $p1, $0);
                }))(((($0) => {
                  return ($c$$src$Compiler$FormattableAst$$UnopCall)($op, $0);
                }))(((($0) => {
                  return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $p, $0);
                }))(($c$$src$Compiler$FormattableAst$$Call)($unoped, $args)))));
              }))()
              : (true
                ? ($u$$src$Compiler$Parser$$ok)(((($0) => {
                  return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $p, $0);
                }))(($c$$src$Compiler$FormattableAst$$Call)($ref, $args)))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 615:8', (sp_toHuman)($ref))));
          }))());
      })))(($u$$src$SPLib$Parser$$maybe)(($u$$src$Compiler$Parser$$block)(($u$$src$SPLib$Parser$$zeroOrMore)(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)($term)))));
    })))(($u$$src$SPLib$Parser$$zeroOrMore)($term));
  })))($term);
});

const $u$$src$Compiler$Parser$$binopChain = (($env) => {
  const $app = ($u$$src$Compiler$Parser$$functionApplication)($env);
  return (($u$$src$Compiler$Parser$$on)((($left) => {
    const $binopAndApp = (($u$$src$Compiler$Parser$$on)((($b) => {
      return (($u$$src$Compiler$Parser$$on)((($a) => {
        return ($u$$src$Compiler$Parser$$ok)(({
          first: $b,
          second: $a,
        }));
      })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)($app));
    })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$binop)($env)));
    return (($u$$src$Compiler$Parser$$on)((($rights) => {
      return ($u$$src$Compiler$Parser$$ok)(({
        first: $left,
        second: $rights,
      }));
    })))(($u$$src$SPLib$Parser$$zeroOrMore)($binopAndApp));
  })))($app);
});

const $u$$src$Compiler$Parser$$chain_append = (($binopAndExpr, $1) => {
  const $left = $1.first;
  const $rights = $1.second;
  return ({
    first: $left,
    second: ($c$$src$List$$reverse)((sp_cons)($binopAndExpr, ($c$$src$List$$reverse)($rights))),
  });
});

const $u$$src$Compiler$Parser$$blah = (($lowestPrecedence, $remainingChain, $accChain, $accOp) => {
  const $5 = ($c$$src$List$$partitionWhile)((($6) => {
    const $op = $6.first;
    const $exp = $6.second;
    return ($op.precedence > $lowestPrecedence);
  }), $remainingChain.second);
  const $rest = $5.second;
  const $abovePrecedence = $5.first;
  const $ee = ($u$$src$Compiler$Parser$$reorderAccordingToBinopPrecedence)(({
    first: $remainingChain.first,
    second: $abovePrecedence,
  }));
  const $updatedChain = ($u$$src$Compiler$Parser$$chain_append)(({
    first: $accOp,
    second: $ee,
  }), $accChain);
  return ((($rest)[0] === "$Nil")
    ? ((() => {
      const $p = ($u$$src$Compiler$Parser$$posRange)((sp_cons)($updatedChain.first, ($c$$src$List$$map)((($x) => {
        return $x.second;
      }), $updatedChain.second)));
      return ((($0) => {
        return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $p, $0);
      }))(((($0) => {
        return ($c$$src$Compiler$FormattableAst$$BinopChain)($lowestPrecedence, $0);
      }))($updatedChain));
    }))()
    : ((($rest)[0] === "$Cons")
      ? ((() => {
        const $op = ($rest)[1].first;
        const $e = ($rest)[1].second;
        const $rem = ($rest)[2];
        return ($u$$src$Compiler$Parser$$blah)($lowestPrecedence, ({
          first: $e,
          second: $rem,
        }), $updatedChain, $op);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 710:4', (sp_toHuman)($rest))));
});

const $u$$src$Compiler$Parser$$findLowestPrecedence = ((() => {
  const $rec = (($lowest, $exprs) => {
    return ((($exprs)[0] === "$Nil")
      ? $lowest
      : ((($exprs)[0] === "$Cons")
        ? ((() => {
          const $b = ($exprs)[1].first;
          const $tail = ($exprs)[2];
          return ($rec)(($c$$src$Basics$$min)($lowest, $b.precedence), $tail);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 686:8', (sp_toHuman)($exprs))));
  });
  return (($chain) => {
    return ($rec)(1000, $chain.second);
  });
}))();

const $u$$src$Compiler$Parser$$reorderAccordingToBinopPrecedence = (($chain) => {
  const $2 = ($u$$src$Compiler$Parser$$findLowestPrecedence)($chain);
  return ((1000 === $2)
    ? $chain.first
    : (true
      ? ((() => {
        const $lowestPrecedence = $2;
        const $3 = ($c$$src$List$$partitionWhile)((($4) => {
          const $op = $4.first;
          const $exp = $4.second;
          return ($op.precedence > $lowestPrecedence);
        }), $chain.second);
        const $rest = $3.second;
        const $abovePrecedence = $3.first;
        const $left = ($u$$src$Compiler$Parser$$reorderAccordingToBinopPrecedence)(({
          first: $chain.first,
          second: $abovePrecedence,
        }));
        return ((($rest)[0] === "$Nil")
          ? $left
          : ((($rest)[0] === "$Cons")
            ? ((() => {
              const $op = ($rest)[1].first;
              const $ee = ($rest)[1].second;
              const $tail = ($rest)[2];
              return ($u$$src$Compiler$Parser$$blah)($lowestPrecedence, ({
                first: $ee,
                second: $tail,
              }), ({
                first: $left,
                second: $c$$src$Core$$Nil,
              }), $op);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 741:12', (sp_toHuman)($rest))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 728:4', (sp_toHuman)($2))));
});

const $u$$src$Compiler$Parser$$expr = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($x) => {
    return ($u$$src$Compiler$Parser$$ok)(($u$$src$Compiler$Parser$$reorderAccordingToBinopPrecedence)($x));
  })))(($u$$src$Compiler$Parser$$binopChain)($env));
});

const $u$$src$Compiler$Parser$$lowerName = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($2) => {
    const $start = ($2)[1];
    const $end = ($2)[2];
    const $k = ($2)[3];
    return (((($k)[0] === "$Lowercase") && (((($k)[1].attrPath)[0] === "$Nil") && ((($k)[1].maybeModule)[0] === "$Nothing")))
      ? ((() => {
        const $name = ($k)[1].name;
        return ($u$$src$Compiler$Parser$$ok)(({
          first: ($u$$src$Compiler$Parser$$pos)($env, $start, $end),
          second: $name,
        }));
      }))()
      : (true
        ? $u$$src$SPLib$Parser$$reject
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 185:4', (sp_toHuman)($k))));
  })))($u$$src$Compiler$Parser$$oneToken);
});

const $u$$src$Compiler$Parser$$upperName = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($2) => {
    const $start = ($2)[1];
    const $end = ($2)[2];
    const $k = ($2)[3];
    return (((($k)[0] === "$Uppercase") && ((($k)[1].maybeModule)[0] === "$Nothing"))
      ? ((() => {
        const $name = ($k)[1].name;
        return ($u$$src$Compiler$Parser$$ok)(({
          first: ($u$$src$Compiler$Parser$$pos)($env, $start, $end),
          second: $name,
        }));
      }))()
      : (true
        ? $u$$src$SPLib$Parser$$reject
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 194:4', (sp_toHuman)($k))));
  })))($u$$src$Compiler$Parser$$oneToken);
});

const $u$$src$Compiler$Parser$$aliasDef = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($name) => {
    return (($u$$src$Compiler$Parser$$on)((($args) => {
      return (($u$$src$Compiler$Parser$$on)(((_0) => {
        return (($u$$src$Compiler$Parser$$on)((($type) => {
          return ($u$$src$Compiler$Parser$$ok)(($c$$src$Compiler$FormattableAst$$AliasDef)(({
            args: $args,
            name: $name,
            type: $type,
          })));
        })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$expr)($env)));
      })))(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Defop));
    })))(($u$$src$SPLib$Parser$$zeroOrMore)(($u$$src$Compiler$Parser$$lowerName)($env)));
  })))(($u$$src$Compiler$Parser$$upperName)($env));
});

const $u$$src$SPLib$Parser$$abort = (($error) => {
  return (($rejections, $readState) => {
    return ({
      first: $rejections,
      second: ($u$$src$SPLib$Parser$$Aborted)($readState, $error),
    });
  });
});

const $u$$src$Compiler$Parser$$nonFunction = (($env) => {
  return (($u$$src$Compiler$Parser$$on)(((_0) => {
    return (($u$$src$Compiler$Parser$$on)((($names) => {
      return (($u$$src$Compiler$Parser$$on)((($4) => {
        const $name = $4.second;
        return ((sp_not_equal)($name, "NonFunction")
          ? ($u$$src$SPLib$Parser$$abort)("Only NonFunction is supported for now")
          : ($u$$src$Compiler$Parser$$ok)($names));
      })))(($u$$src$Compiler$Parser$$upperName)($env));
    })))(($u$$src$Compiler$Parser$$rawList)(($u$$src$Compiler$Parser$$lowerName)($env)));
  })))(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$With));
});

const $u$$src$Compiler$Parser$$definitionOrEvaluation = (($env) => {
  return (($u$$src$Compiler$Parser$$on)((($ex) => {
    const $definitionTail = (($u$$src$Compiler$Parser$$on)((($maybeNf) => {
      return (($u$$src$Compiler$Parser$$on)(((_0) => {
        return (($u$$src$Compiler$Parser$$on)((($body) => {
          return ($u$$src$Compiler$Parser$$ok)(({
            first: $maybeNf,
            second: $body,
          }));
        })))(($u$$src$Compiler$Parser$$indentedOrInlineStatements)($env));
      })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Defop)));
    })))(($u$$src$Compiler$Parser$$maybe)(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$nonFunction)($env))));
    return (($u$$src$Compiler$Parser$$on)((($maybeDefTail) => {
      return ($u$$src$Compiler$Parser$$ok)(((($maybeDefTail)[0] === "$Nothing")
        ? ($c$$src$Compiler$FormattableAst$$Evaluation)($ex)
        : ((($maybeDefTail)[0] === "$Just")
          ? ((() => {
            const $maybeNf = ($maybeDefTail)[1].first;
            const $body = ($maybeDefTail)[1].second;
            return ($c$$src$Compiler$FormattableAst$$ValueDef)(({
              body: $body,
              nonFn: ($c$$src$Maybe$$withDefault)($c$$src$Core$$Nil, $maybeNf),
              pattern: $ex,
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 803:4', (sp_toHuman)($maybeDefTail)))));
    })))(($u$$src$Compiler$Parser$$maybe)($definitionTail));
  })))(($u$$src$Compiler$Parser$$expr)($env));
});

const $u$$src$Compiler$Parser$$unionDef = (($env) => {
  const $variantKind = ($c$$src$Compiler$Token$$Lowercase)(({
    attrPath: $c$$src$Core$$Nil,
    maybeModule: $c$$src$Maybe$$Nothing,
    name: "var",
  }));
  return (($u$$src$Compiler$Parser$$on)(((_0) => {
    return (($u$$src$Compiler$Parser$$on)((($name) => {
      return (($u$$src$Compiler$Parser$$on)((($args) => {
        return (($u$$src$Compiler$Parser$$on)(((_0) => {
          return (($u$$src$Compiler$Parser$$on)((($constructors) => {
            return ($u$$src$Compiler$Parser$$ok)(($c$$src$Compiler$FormattableAst$$UnionDef)(({
              args: $args,
              constructors: $constructors,
              name: $name,
            })));
          })))(($u$$src$Compiler$Parser$$inlineOrBelowOrIndented)(($u$$src$Compiler$Parser$$rawList)(($u$$src$Compiler$Parser$$expr)($env))));
        })))(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$Defop));
      })))(($u$$src$SPLib$Parser$$zeroOrMore)(($u$$src$Compiler$Parser$$lowerName)($env)));
    })))(($u$$src$Compiler$Parser$$upperName)($env));
  })))(($u$$src$Compiler$Parser$$kind)($variantKind));
});

const $u$$src$SPLib$Parser$$breakCircularDefinition = (($a) => {
  return (($u$$src$SPLib$Parser$$andThen)($a))(($u$$src$SPLib$Parser$$accept)(null));
});

const $u$$src$Compiler$Parser$$statementParser = (($env, $acc0) => {
  return ($u$$src$SPLib$Parser$$breakCircularDefinition)(((_0) => {
    return (($u$$src$Compiler$Parser$$on)(((_0) => {
      return (($u$$src$Compiler$Parser$$on)((($commentsReversed) => {
        return (($u$$src$Compiler$Parser$$on)((($statement) => {
          return ($u$$src$Compiler$Parser$$ok)(($c$$src$Core$$Cons)($statement, ($u$$src$Compiler$Parser$$stackCommentsReversedAsStatements)($commentsReversed, $acc0)));
        })))(($u$$src$SPLib$Parser$$oneOf)(($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$aliasDef)($env), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$unionDef)($env), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser$$definitionOrEvaluation)($env), $c$$src$Core$$Nil)))));
      })))($u$$src$Compiler$Parser$$pullCommentsReversed);
    })))(($u$$src$SPLib$Parser$$zeroOrMore)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$NewSiblingLine)));
  }));
});

const $u$$src$Compiler$Parser$$rootStatement = (($env, $acc0) => {
  return (($u$$src$Compiler$Parser$$on)((($acc1) => {
    return (($u$$src$Compiler$Parser$$on)(((_0) => {
      return (($u$$src$Compiler$Parser$$on)((($rs) => {
        const $readState = ($u$$src$Compiler$Parser$$eatComments)($rs);
        return ((sp_equal)($readState.tokens, $c$$src$Core$$Nil)
          ? ($u$$src$Compiler$Parser$$ok)(((($0) => {
            return ($u$$src$Compiler$Parser$$stackCommentsReversedAsStatements)($readState.commentsReversed, $0);
          }))($acc1))
          : $u$$src$SPLib$Parser$$reject);
      })))($u$$src$SPLib$Parser$$here);
    })))(($u$$src$SPLib$Parser$$zeroOrMore)(($u$$src$Compiler$Parser$$kind)($c$$src$Compiler$Token$$BlockEnd)));
  })))(($u$$src$Compiler$Parser$$forZeroOrMore)($acc0, (($0) => {
    return ($u$$src$Compiler$Parser$$statementParser)($env, $0);
  })));
});

const $u$$src$SPLib$Parser$$runParser = (($parser, $readState) => {
  return ($parser)(($c$$src$Core$$Cons)($readState, $c$$src$Core$$Nil), $readState);
});

const $u$$src$Compiler$Parser$$parse = (($env, $allTokens, $acc) => {
  const $initState = ({
    commentsReversed: $c$$src$Core$$Nil,
    tokens: $allTokens,
  });
  const $4 = ($u$$src$SPLib$Parser$$runParser)(($u$$src$Compiler$Parser$$rootStatement)($env, $acc), $initState);
  const $outcome = $4.second;
  const $failureStates = $4.first;
  return ((($outcome)[0] === "$Accepted")
    ? ((() => {
      const $readState = ($outcome)[1];
      const $output = ($outcome)[2];
      return ($c$$src$Result$$Ok)($output);
    }))()
    : ((($outcome)[0] === "$Aborted")
      ? ((() => {
        const $readState = ($outcome)[1];
        const $message = ($outcome)[2];
        return ($u$$src$Compiler$Parser$$makeError)($env, $readState.tokens, $message);
      }))()
      : ((($outcome)[0] === "$Rejected")
        ? ((() => {
          const $findMin = (($6, $best) => {
            const $tokens = $6.tokens;
            return ((($c$$src$List$$length)($tokens) < ($c$$src$List$$length)($best))
              ? $tokens
              : $best);
          });
          const $farthestParsed = ($c$$src$List$$for)($allTokens, $failureStates, $findMin);
          const $5 = ({
            first: $farthestParsed,
            second: $allTokens,
          });
          return (((($5.first)[0] === "$Cons") && ((($5.first)[1])[0] === "$Token"))
            ? ((() => {
              const $start = (($5.first)[1])[1];
              const $end = (($5.first)[1])[2];
              const $rest = ($5.first)[2];
              return ($u$$src$Compiler$Error$$res)($env.errorModule, ($c$$src$Compiler$Pos$$P)($start, $end), ($c$$src$Core$$Cons)("I got stuck parsing here. =(", $c$$src$Core$$Nil));
            }))()
            : (((($5.first)[0] === "$Nil") && ((($5.second)[0] === "$Cons") && ((($5.second)[1])[0] === "$Token")))
              ? ((() => {
                const $start = (($5.second)[1])[1];
                const $end0 = (($5.second)[1])[2];
                const $rest = ($5.second)[2];
                const $end = ($c$$src$List$$for)($end0, $rest, (($7, _1) => {
                  const $endX = ($7)[2];
                  return $endX;
                }));
                return ($u$$src$Compiler$Error$$res)($env.errorModule, ($c$$src$Compiler$Pos$$P)($start, $end), ($c$$src$Core$$Cons)("I got to the end of the statement and I can't make sense of it. =(", $c$$src$Core$$Nil));
              }))()
              : (((($5.first)[0] === "$Nil") && (($5.second)[0] === "$Nil"))
                ? ($c$$src$Result$$Ok)($c$$src$Core$$Nil)
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 896:12', (sp_toHuman)($5)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 880:4', (sp_toHuman)($outcome)))));
});

const $u$$src$Compiler$Parser$$textToFormattableModule = (($env) => {
  const $tokensResult = ($u$$src$Compiler$Lexer$$lexer)($env.keepComments, $env.errorModule);
  return (($c$$src$Result$$onOk)((($tokenChunks) => {
    const $3 = ($c$$src$List$$for)(({
      first: $c$$src$Core$$Nil,
      second: $c$$src$Core$$Nil,
    }), $tokenChunks, (($tokens, $4) => {
      const $es = $4.first;
      const $revStats = $4.second;
      const $6 = ($u$$src$Compiler$Parser$$parse)($env, $tokens, $revStats);
      return ((($6)[0] === "$Ok")
        ? ((() => {
          const $newReversedStatements = ($6)[1];
          return ({
            first: $es,
            second: $newReversedStatements,
          });
        }))()
        : ((($6)[0] === "$Err")
          ? ((() => {
            const $e = ($6)[1];
            return ({
              first: ($c$$src$Core$$Cons)($e, $es),
              second: $revStats,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 922:12', (sp_toHuman)($6))));
    }));
    const $reversedStatements = $3.second;
    const $errors = $3.first;
    return ((sp_not_equal)($errors, $c$$src$Core$$Nil)
      ? ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Nested)($errors))
      : ($c$$src$Result$$Ok)(($c$$src$List$$reverse)($reversedStatements)));
  })))($tokensResult);
});

const $u$$src$Compiler$MakeCanonical$$textToCanonicalModule = (($stripLocations, $ro) => {
  return (($c$$src$Result$$onOk)((($faModule) => {
    return ($u$$src$Compiler$MakeCanonical$$translateModule)($ro, $faModule);
  })))(($u$$src$Compiler$Parser$$textToFormattableModule)(({
    errorModule: $ro.errorModule,
    keepComments: false,
    stripLocations: $stripLocations,
  })));
});

const $u$$src$Compiler$TestHelpers$$errorModule = (($content) => {
  return ({
    content: $content,
    fsPath: "<Test>",
  });
});

const $u$$src$Compiler$TestHelpers$$importsPath = ($c$$src$Compiler$Meta$$ImportsPath)($c$$src$Compiler$Meta$$User, "<testImportsPath/>");

const $u$$src$Compiler$TestHelpers$$moduleUmr = ($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$TestHelpers$$importsPath, "<testSourceDir/>", "<TestModulePath>");

const $u$$src$Compiler$Error$$breakDownText = (($text) => {
  const $formatSnippet = (($index, $snippet) => {
    return ((sp_equal)((basics_modBy)(2, $index), 0)
      ? ($u$$src$Compiler$Error$$FormattedText_Default)($snippet)
      : ((() => {
        const $4 = (text_split)($u$$src$Compiler$Error$$formatSuffix, $snippet);
        return (((($4)[0] === "$Cons") && (("emphasys" === ($4)[1]) && (((($4)[2])[0] === "$Cons") && (((($4)[2])[2])[0] === "$Nil"))))
          ? ((() => {
            const $s = (($4)[2])[1];
            return ($u$$src$Compiler$Error$$FormattedText_Emphasys)($s);
          }))()
          : (((($4)[0] === "$Cons") && (("warning" === ($4)[1]) && (((($4)[2])[0] === "$Cons") && (((($4)[2])[2])[0] === "$Nil"))))
            ? ((() => {
              const $s = (($4)[2])[1];
              return ($u$$src$Compiler$Error$$FormattedText_Warning)($s);
            }))()
            : (((($4)[0] === "$Cons") && (("decoration" === ($4)[1]) && (((($4)[2])[0] === "$Cons") && (((($4)[2])[2])[0] === "$Nil"))))
              ? ((() => {
                const $s = (($4)[2])[1];
                return ($u$$src$Compiler$Error$$FormattedText_Decoration)($s);
              }))()
              : (true
                ? ($u$$src$Compiler$Error$$FormattedText_Default)($snippet)
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 68:12', (sp_toHuman)($4))))));
      }))());
  });
  return ((($0) => {
    return ($c$$src$List$$indexedMap)($formatSnippet, $0);
  }))(((($0) => {
    return (text_split)($u$$src$Compiler$Error$$formatSeparator, $0);
  }))($text));
});

const $u$$src$Compiler$Error$$rawToText = (($desc) => {
  const $description = ((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($s) => {
      return ("  " + $s);
    }), $0);
  }))(((($0) => {
    return ($c$$src$List$$concatMap)((($0) => {
      return (text_split)("\n", $0);
    }), $0);
  }))($desc)));
  return ($u$$src$Compiler$Error$$breakDownText)(((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)($description, ($c$$src$Core$$Cons)("", $c$$src$Core$$Nil))))));
});

const $u$$src$Compiler$Error$$deco = (($0) => {
  return ($u$$src$Compiler$Error$$formatWrap)("decoration", $0);
});

const $u$$src$Compiler$Error$$simpleToText = (($mod, $pos, $desc) => {
  const $4 = ($u$$src$Compiler$Error$$posToHuman)($mod, $pos);
  const $location = $4.location;
  const $block = $4.block;
  const $description = ((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($s) => {
      return ("  " + $s);
    }), $0);
  }))(((($0) => {
    return ($c$$src$List$$concatMap)((($0) => {
      return (text_split)("\n", $0);
    }), $0);
  }))(($c$$src$Core$$Cons)($block, $desc))));
  return ($u$$src$Compiler$Error$$breakDownText)(((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)(($u$$src$Compiler$Error$$deco)(($c$$src$Text$$padRight)(50, "-", ($location + " "))), ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)($description, ($c$$src$Core$$Cons)("", $c$$src$Core$$Nil))))))));
});

const $u$$src$Compiler$Error$$flatten = (($e, $accum) => {
  return ((($e)[0] === "$Simple")
    ? ((() => {
      const $mod = ($e)[1];
      const $pos = ($e)[2];
      const $desc = ($e)[3];
      return ($c$$src$List$$concat)(($c$$src$Core$$Cons)($accum, ($c$$src$Core$$Cons)(($u$$src$Compiler$Error$$simpleToText)($mod, $pos, $desc), $c$$src$Core$$Nil)));
    }))()
    : ((($e)[0] === "$Raw")
      ? ((() => {
        const $desc = ($e)[1];
        return ($c$$src$List$$concat)(($c$$src$Core$$Cons)($accum, ($c$$src$Core$$Cons)(($u$$src$Compiler$Error$$rawToText)($desc), $c$$src$Core$$Nil)));
      }))()
      : ((($e)[0] === "$Nested")
        ? ((() => {
          const $ls = ($e)[1];
          return ($c$$src$List$$for)($accum, $ls, $u$$src$Compiler$Error$$flatten);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 39:4', (sp_toHuman)($e)))));
});

const $u$$src$Compiler$Error$$toFormattedText = (($0) => {
  return ($u$$src$Compiler$Error$$flatten)($0, $c$$src$Core$$Nil);
});

const $u$$src$Compiler$TestHelpers$$formattedToStrippedText = (($formatted) => {
  const $strip = (($fmt) => {
    return ((($fmt)[0] === "$FormattedText_Default")
      ? ((() => {
        const $t = ($fmt)[1];
        return $t;
      }))()
      : ((($fmt)[0] === "$FormattedText_Emphasys")
        ? ((() => {
          const $t = ($fmt)[1];
          return $t;
        }))()
        : ((($fmt)[0] === "$FormattedText_Warning")
          ? ((() => {
            const $t = ($fmt)[1];
            return $t;
          }))()
          : ((($fmt)[0] === "$FormattedText_Decoration")
            ? ((() => {
              const $t = ($fmt)[1];
              return $t;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 37:8', (sp_toHuman)($fmt))))));
  });
  return ((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(((($0) => {
    return ($c$$src$List$$map)($strip, $0);
  }))($formatted));
});

const $u$$src$Compiler$TestHelpers$$errorToStrippedText = (($0) => {
  return ($u$$src$Compiler$TestHelpers$$formattedToStrippedText)(($u$$src$Compiler$Error$$toFormattedText)($0));
});

const $u$$src$Compiler$TestHelpers$$resErrorToStrippedText = (($0) => {
  return ($c$$src$Result$$mapError)($u$$src$Compiler$TestHelpers$$errorToStrippedText, $0);
});

const $u$$src$DefaultImports$$mod = (($path, $globals) => {
  return ({
    globals: $globals,
    path: $path,
    visibleAs: $path,
  });
});

const $u$$src$DefaultImports$$defaultImportsFile = ({
  libraries: ($c$$src$Core$$Cons)(({
    modules: ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Core", ($c$$src$Core$$Cons)("None", ($c$$src$Core$$Cons)("Bool", ($c$$src$Core$$Cons)("Text", ($c$$src$Core$$Cons)("Number", ($c$$src$Core$$Cons)("'none", ($c$$src$Core$$Cons)("'true", ($c$$src$Core$$Cons)("'false", ($c$$src$Core$$Cons)("mut", $c$$src$Core$$Nil))))))))), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Basics", ($c$$src$Core$$Cons)("Int", ($c$$src$Core$$Cons)("assert", ($c$$src$Core$$Cons)("clamp", ($c$$src$Core$$Cons)("identity", ($c$$src$Core$$Cons)("modBy", ($c$$src$Core$$Cons)("min", ($c$$src$Core$$Cons)("max", ($c$$src$Core$$Cons)("cloneImm", ($c$$src$Core$$Cons)("cloneUni", $c$$src$Core$$Nil)))))))))), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Text", $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Tuple", $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Debug", ($c$$src$Core$$Cons)("log", ($c$$src$Core$$Cons)("todo", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Self", $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("List", $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Dict", ($c$$src$Core$$Cons)("Dict", $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Array", ($c$$src$Core$$Cons)("Array", $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Hash", ($c$$src$Core$$Cons)("Hash", $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Set", ($c$$src$Core$$Cons)("Set", $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Maybe", ($c$$src$Core$$Cons)("Maybe", ($c$$src$Core$$Cons)("'just", ($c$$src$Core$$Cons)("'nothing", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$DefaultImports$$mod)("Result", ($c$$src$Core$$Cons)("Result", ($c$$src$Core$$Cons)("'ok", ($c$$src$Core$$Cons)("'err", $c$$src$Core$$Nil)))), $c$$src$Core$$Nil))))))))))))),
    source: "core",
  }), $c$$src$Core$$Nil),
  sourceDirs: ($c$$src$Core$$Cons)(({
    modules: $c$$src$Core$$Nil,
    path: ".",
  }), ($c$$src$Core$$Cons)(({
    modules: $c$$src$Core$$Nil,
    path: "src/",
  }), $c$$src$Core$$Nil)),
});

const $u$$src$ImportsFile$$insertModules = (($getModulePathToLocation, $errors, $modules, $imports) => {
  return ([
    ($c$$src$List$$for)($imports, $modules, (($module, $imp) => {
      const $location = ($getModulePathToLocation)($module.path);
      const $moduleAliasToLocation = ($c$$src$Dict$$insert)($module.visibleAs, $location, $imp.moduleAliasToLocation);
      const $modulePathToLocation = ($c$$src$Dict$$insert)($module.path, $location, $imp.modulePathToLocation);
      const $globalNameToLocation = ($c$$src$List$$for)($imp.globalNameToLocation, $module.globals, (($globalName, $dict) => {
        return ($c$$src$Dict$$insert)($globalName, $location, $dict);
      }));
      return ({
        globalNameToLocation: $globalNameToLocation,
        moduleAliasToLocation: $moduleAliasToLocation,
        modulePathToLocation: $modulePathToLocation,
      });
    })),
    $errors,
  ]);
});

const $u$$src$ImportsFile$$parseLibrarySource = (($sourceAsText) => {
  const $2 = (text_split)(":", $sourceAsText);
  return (((($2)[0] === "$Cons") && (("core" === ($2)[1]) && ((($2)[2])[0] === "$Nil")))
    ? ($c$$src$Result$$Ok)($u$$src$ImportsFile$$Core)
    : (((($2)[0] === "$Cons") && (("local" === ($2)[1]) && (((($2)[2])[0] === "$Cons") && (((($2)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $path = (($2)[2])[1];
        return ($c$$src$Result$$Ok)(($u$$src$ImportsFile$$Local)($path));
      }))()
      : (((($2)[0] === "$Cons") && ((($2)[2])[0] === "$Cons"))
        ? ((() => {
          const $protocol = ($2)[1];
          const $address = (($2)[2])[1];
          const $more = (($2)[2])[2];
          return ($c$$src$Result$$Ok)(($u$$src$ImportsFile$$Installed)(({
            address: ($c$$src$Text$$join)(":", ($c$$src$Core$$Cons)($address, $more)),
            protocol: $protocol,
          })));
        }))()
        : (true
          ? ($c$$src$Result$$Err)(("invalid library source: " + $sourceAsText))
          : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 46:4', (sp_toHuman)($2))))));
});

const $u$$src$ImportsFile$$insertLibrary = (($pars, $errors, $library, $imports) => {
  const $5 = ($u$$src$ImportsFile$$parseLibrarySource)($library.source);
  return ([
    ((($5)[0] === "$Err")
      ? ((() => {
        const $msg = ($5)[1];
        ((__re__ = (array_push)($errors, $msg)), ($errors = (__re__)[1]), (__re__)[0]);
        return $imports;
      }))()
      : ((($5)[0] === "$Ok")
        ? ((() => {
          const $librarySource = ($5)[1];
          return ((($0) => {
            return ((__re__ = ($u$$src$ImportsFile$$insertModules)($0, $errors, $library.modules, $imports)), ($errors = (__re__)[1]), (__re__)[0]);
          }))(((($librarySource)[0] === "$Core")
            ? (($0) => {
              return ($c$$src$Compiler$Meta$$LocationLibrary)($u$$src$Compiler$CoreDefs$$importsPath, $0);
            })
            : ((($librarySource)[0] === "$Local")
              ? ((() => {
                const $libraryDir = ($librarySource)[1];
                const $6 = $pars.importsPath;
                const $currentImportsDir = ($6)[2];
                const $rootDirectory = ($6)[1];
                const $importsDir = ($pars.joinPath)(($c$$src$Core$$Cons)($currentImportsDir, ($c$$src$Core$$Cons)($libraryDir, $c$$src$Core$$Nil)));
                return (($0) => {
                  return ($c$$src$Compiler$Meta$$LocationLibrary)(($c$$src$Compiler$Meta$$ImportsPath)($rootDirectory, $importsDir), $0);
                });
              }))()
              : ((($librarySource)[0] === "$Installed")
                ? ((() => {
                  const $address = ($librarySource)[1].address;
                  const $protocol = ($librarySource)[1].protocol;
                  const $importsDir = ($pars.joinPath)(($c$$src$Core$$Cons)($protocol, ($c$$src$Core$$Cons)($address, $c$$src$Core$$Nil)));
                  return (($0) => {
                    return ($c$$src$Compiler$Meta$$LocationLibrary)(($c$$src$Compiler$Meta$$ImportsPath)($c$$src$Compiler$Meta$$Installed, $importsDir), $0);
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 107:12', (sp_toHuman)($librarySource))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 99:4', (sp_toHuman)($5)))),
    $errors,
  ]);
});

const $u$$src$ImportsFile$$insertSourceDir = (($pars, $errors, $sourceDir, $imports) => {
  const $modulePathToLocation = (($0) => {
    return ($c$$src$Compiler$Meta$$LocationSourceDir)(((($0) => {
      return ($c$$src$Compiler$Meta$$UMR)($pars.importsPath, $sourceDir.path, $0);
    }))($0));
  });
  return ([
    ((__re__ = ($u$$src$ImportsFile$$insertModules)($modulePathToLocation, $errors, $sourceDir.modules, $imports)), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const $u$$src$ImportsFile$$toImports = (($pars, $importsFile) => {
  let $errors = (array_fromList)($c$$src$Core$$Nil);
  const $meta = ((($0) => {
    return ($c$$src$List$$for)($0, $importsFile.sourceDirs, (($0, $1) => {
      return ((__re__ = ($u$$src$ImportsFile$$insertSourceDir)($pars, $errors, $0, $1)), ($errors = (__re__)[1]), (__re__)[0]);
    }));
  }))(((($0) => {
    return ($c$$src$List$$for)($0, $importsFile.libraries, (($0, $1) => {
      return ((__re__ = ($u$$src$ImportsFile$$insertLibrary)($pars, $errors, $0, $1)), ($errors = (__re__)[1]), (__re__)[0]);
    }));
  }))($c$$src$Compiler$Meta$$initImports));
  const $errs = ((($0) => {
    return ($c$$src$List$$map)((($msg) => {
      return ($u$$src$Compiler$Error$$Raw)(($c$$src$Core$$Cons)($msg, $c$$src$Core$$Nil));
    }), $0);
  }))(((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]));
  return ((sp_equal)($errs, $c$$src$Core$$Nil)
    ? ($c$$src$Result$$Ok)($meta)
    : ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Nested)($errs)));
});

const $u$$src$Compiler$TestHelpers$$imports = ((() => {
  const $pars = ({
    importsPath: $u$$src$Compiler$TestHelpers$$importsPath,
    joinPath: path_join,
  });
  const $1 = ($u$$src$ImportsFile$$toImports)($pars, $u$$src$DefaultImports$$defaultImportsFile);
  return ((($1)[0] === "$Err")
    ? ((() => {
      const $e = ($1)[1];
      (sp_log)("Error in DefaultImports.sp: ", $e);
      return (sp_todo)("error loading DefaultImports.sp");
    }))()
    : ((($1)[0] === "$Ok")
      ? ((() => {
        const $m = ($1)[1];
        return $m;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 68:4', (sp_toHuman)($1))));
}))();

const $u$$src$Compiler$TestHelpers$$exports = ((() => {
  const $isOpen = false;
  return ((($0) => {
    return ($c$$src$Dict$$ofOne)("Core", $0);
  }))(($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
    first: "None",
    second: ({
      isOpen: true,
      usr: $u$$src$Compiler$CoreDefs$$noneTypeUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "'none",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$noneConsUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "Bool",
    second: ({
      isOpen: true,
      usr: $u$$src$Compiler$CoreDefs$$boolUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "'true",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$trueUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "'false",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$falseUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "List",
    second: ({
      isOpen: true,
      usr: $u$$src$Compiler$CoreDefs$$listUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "'nil",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$nilUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "'cons",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$consUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "Text",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$textUsr,
    }),
  }), ($c$$src$Core$$Cons)(({
    first: "Number",
    second: ({
      isOpen: $isOpen,
      usr: $u$$src$Compiler$CoreDefs$$numberUsr,
    }),
  }), $c$$src$Core$$Nil))))))))))));
}))();

const $u$$src$Compiler$TestHelpers$$loadExports = (($ip) => {
  return (((($ip)[0] === "$ImportsPath") && (((($ip)[1])[0] === "$Core") && ("" === ($ip)[2])))
    ? ($c$$src$Result$$Ok)($u$$src$Compiler$TestHelpers$$exports)
    : (true
      ? ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Raw)(($c$$src$Core$$Cons)("TestHelpers: trying to load an unknown export:", ($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)((sp_toHuman)($ip), ($c$$src$Core$$Cons)("", $c$$src$Core$$Nil))))))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 108:4', (sp_toHuman)($ip))));
});

const $u$$src$Compiler$TestHelpers$$resolvePars = ({
  currentImports: $u$$src$Compiler$TestHelpers$$imports,
  currentModule: $u$$src$Compiler$TestHelpers$$moduleUmr,
  loadExports: $u$$src$Compiler$TestHelpers$$loadExports,
  makeError: (($0) => {
    return ($u$$src$Compiler$Error$$Raw)($0);
  }),
});

const $u$$src$Compiler$TestHelpers$$caFunction = (($from, $to) => {
  return ($c$$src$Compiler$CanonicalAst$$TypeFn)($c$$src$Compiler$Pos$$T, ($c$$src$List$$map)((($t) => {
    return ($c$$src$Compiler$CanonicalAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($t));
  }), $from), ($c$$src$Compiler$Ast$$toImm)($to));
});

const $u$$src$Compiler$TestHelpers$$caNumber = ($c$$src$Compiler$CanonicalAst$$TypeNamed)($c$$src$Compiler$Pos$$T, ($u$$src$Compiler$CoreDefs$$usr)("Number"), $c$$src$Core$$Nil);

const $u$$src$Compiler$TypeCheck_Test$$add = ({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: ($c$$src$Maybe$$Just)(({
    raw: ($u$$src$Compiler$TestHelpers$$caFunction)(($c$$src$Core$$Cons)($u$$src$Compiler$TestHelpers$$caNumber, ($c$$src$Core$$Cons)($u$$src$Compiler$TestHelpers$$caNumber, $c$$src$Core$$Nil)), $u$$src$Compiler$TestHelpers$$caNumber),
    tyvars: $c$$src$Dict$$empty,
    univars: $c$$src$Dict$$empty,
  })),
  maybeBody: $c$$src$Maybe$$Nothing,
  name: "add",
  namePos: $c$$src$Compiler$Pos$$T,
});

const $u$$src$Compiler$TestHelpers$$caNone = ($c$$src$Compiler$CanonicalAst$$TypeNamed)($c$$src$Compiler$Pos$$T, ($u$$src$Compiler$CoreDefs$$usr)("None"), $c$$src$Core$$Nil);

const $u$$src$Compiler$TypeCheck_Test$$reset = ({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: ($c$$src$Maybe$$Just)(({
    raw: ($u$$src$Compiler$TestHelpers$$caFunction)(($c$$src$Core$$Cons)($u$$src$Compiler$TestHelpers$$caNumber, $c$$src$Core$$Nil), $u$$src$Compiler$TestHelpers$$caNone),
    tyvars: $c$$src$Dict$$empty,
    univars: $c$$src$Dict$$empty,
  })),
  maybeBody: $c$$src$Maybe$$Nothing,
  name: "reset",
  namePos: $c$$src$Compiler$Pos$$T,
});

const $u$$src$Compiler$TypeCheck_Test$$infer = (($targetName) => {
  return (($code) => {
    const $params = ({
      errorModule: ($u$$src$Compiler$TestHelpers$$errorModule)($code),
      resolvePars: (($pos) => {
        return $u$$src$Compiler$TestHelpers$$resolvePars;
      }),
      umr: $u$$src$Compiler$TestHelpers$$moduleUmr,
    });
    return (($c$$src$Result$$onOk)((($caModuleRaw) => {
      const $caModule = ((() => {
        const $0 = $caModuleRaw;
        return (Object.assign)({}, $0, ({
          valueDefs: ((($0) => {
            return ($c$$src$Dict$$insert)("reset", $u$$src$Compiler$TypeCheck_Test$$reset, $0);
          }))(((($0) => {
            return ($c$$src$Dict$$insert)("add", $u$$src$Compiler$TypeCheck_Test$$add, $0);
          }))($0.valueDefs)),
        }));
      }))();
      const $keysToUsrs = (($0) => {
        return ((($0) => {
          return ($c$$src$List$$map)((($0) => {
            return ($c$$src$Compiler$Meta$$USR)($u$$src$Compiler$TestHelpers$$moduleUmr, $0);
          }), $0);
        }))(($c$$src$Dict$$keys)($0));
      });
      const $requiredUsrs = ($c$$src$List$$concat)(($c$$src$Core$$Cons)(($keysToUsrs)($caModule.valueDefs), ($c$$src$Core$$Cons)(($keysToUsrs)($caModule.constructorDefs), ($c$$src$Core$$Cons)(($keysToUsrs)($caModule.variantTypeDefs), ($c$$src$Core$$Cons)(($keysToUsrs)($caModule.aliasDefs), $c$$src$Core$$Nil)))));
      const $loadCaModule = (($umr) => {
        return ((sp_equal)($umr, $u$$src$Compiler$TestHelpers$$moduleUmr)
          ? ($c$$src$Result$$Ok)($caModule)
          : ((sp_equal)($umr, $u$$src$Compiler$CoreDefs$$umr)
            ? ($c$$src$Result$$Ok)($u$$src$Compiler$CoreDefs$$coreModule)
            : ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Raw)(($c$$src$Core$$Cons)(("no module " + (sp_toHuman)($umr)), $c$$src$Core$$Nil)))));
      });
      return (($c$$src$Result$$onOk)((($4) => {
        const $constructors = $4.constructors;
        const $rootValues = $4.rootValues;
        return (($c$$src$Result$$onOk)((($def) => {
          let $hash = (hash_fromList)($c$$src$Core$$Nil);
          const $ft = ($c$$src$Dict$$for)($c$$src$Dict$$empty, $def.freeTyvars, (($id, $tc, $d) => {
            return ($c$$src$Dict$$insert)(((__re__ = ($c$$src$Compiler$TypedAst$$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]), $tc, $d);
          }));
          const $type = ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $def.type)), ($hash = (__re__)[1]), (__re__)[0]);
          return ($c$$src$Result$$Ok)(({
            freeTyvars: $ft,
            type: $type,
          }));
        })))(((() => {
          const $5 = ($c$$src$List$$find)((($rv) => {
            return (sp_equal)($rv.usr, ($c$$src$Compiler$Meta$$USR)($u$$src$Compiler$TestHelpers$$moduleUmr, $targetName));
          }), $rootValues);
          return ((($5)[0] === "$Nothing")
            ? ($c$$src$Result$$Err)("find fail")
            : ((($5)[0] === "$Just")
              ? ((() => {
                const $def = ($5)[1];
                return ($c$$src$Result$$Ok)($def);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck_Test.sp 164:4', (sp_toHuman)($5))));
        }))());
      })))(($u$$src$Compiler$TestHelpers$$resErrorToStrippedText)(($u$$src$Compiler$LazyBuild$$build)(({
        loadCaModule: $loadCaModule,
        requiredUsrs: $requiredUsrs,
      }))));
    })))(($u$$src$Compiler$TestHelpers$$resErrorToStrippedText)(((($0) => {
      return ($u$$src$Compiler$MakeCanonical$$textToCanonicalModule)(true, $0);
    }))($params)));
  });
});

const $u$$specs$Uniqueness$$infer = $u$$src$Compiler$TypeCheck_Test$$infer;

const $u$$specs$Uniqueness$$howDoesItLookLike = ($i$test$$Test$$Group)("How does mutability look like?", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Example: maintaining mutable state", "someFunction = this_is_sp_native\n\naverage as fn [Number]: Number =\n    fn numbers:\n\n    # Unique values can be changed in place, ie, \"mutated\"\n    !total as Number =\n        0\n\n    !count as Number =\n        0\n\n    someFunction numbers fn number:\n        @total += number\n        @count += 1\n\n    # In Squarepants division by 0 yields 0\n    total / count", ($u$$specs$Uniqueness$$infer)("average"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("SKIP (needs IO in the test env) Example: File IO", "logToFile as fn @IO, Text: Result IO.Error None =\n    fn @io, content:\n\n    IO.openFile @io IO.Append \"blah.log\"\n    >> isOk fn @fileDescriptor:\n\n    IO.writeFile @io content @fileDescriptor\n\n    # fileDescriptor is automatically closed here", ($u$$specs$Uniqueness$$infer)("logToFile"), $i$test$$Test$$isOk), $c$$src$Core$$Nil)));

const $u$$specs$Uniqueness$$mutation = ($i$test$$Test$$Group)("Mutation", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("Uniques can be mutated in place", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Mutation does NOT consume the unique", "scope =\n    !x = 1\n    @x += 1\n    @x += 1", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Recycling requires the unique not to be spent", "someFunction = this_is_sp_native\n\nscope =\n    !x = 1\n    someFunction x\n    @x += 1", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("used again here", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("A function can be defined to mutate its arguments", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("base", "funz as fn @Number: None =\n    fn @a:\n    @a += 3\n\nscope =\n    !x = 0\n    funz @x\n    funz @x", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("Calling a function that recycles a unique variable temporarily consumes the variable.", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("base", "someFunction = this_is_sp_native\nscope =\n    !x = 0\n    someFunction @x @x", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("twice", $c$$src$Core$$Nil))), $c$$src$Core$$Nil)), $c$$src$Core$$Nil))));

const $u$$specs$Uniqueness$$parentScope = ($i$test$$Test$$Group)("Recycling a variable in the parent scope", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("A function that recycles any unique belonging to an ancestor scope \"requires\" that unique.", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("LetIns cannot return functions with requirements", "scope =\n    !x =\n        1\n\n    f =\n        fn n:\n        @x += n\n        'none\n\n    f", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("x", ($c$$src$Core$$Cons)("from outside", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Functions cannot return functions with UNIQUE requirements", "f =\n    fn !x:\n    fn n:\n    @x += n\n    'none", ($u$$specs$Uniqueness$$infer)("f"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("x", ($c$$src$Core$$Cons)("from outside", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Functions cannot return functions with RECYCLED requirements", "f =\n    fn @x:\n    fn n:\n    @x += n\n    'none", ($u$$specs$Uniqueness$$infer)("f"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("x", ($c$$src$Core$$Cons)("from outside", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("The Array Test", "var Array_ a = 'meh\n\narray_push as fn a, @Array_ a: None =\n    this_is_sp_native\n\naddFunctions as fn @Array_ (fn Number: Number): None =\n    fn @functions:\n\n    !x =\n        1\n\n    f as fn Number: Number =\n        fn n:\n        @x += 1\n        n\n\n    array_push f @functions\n    'none", ($u$$specs$Uniqueness$$infer)("addFunctions"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("x", ($c$$src$Core$$Cons)("outside", $c$$src$Core$$Nil)))), $c$$src$Core$$Nil))))), $c$$src$Core$$Nil));

const $u$$specs$Uniqueness$$polymorphism = ($i$test$$Test$$Group)("Polymorphism", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Basic syntax", "fun as fn (fn 1?a: 2?b), 1?a: 2?b =\n    fn f, 1?a:\n\n    f a", ($u$$specs$Uniqueness$$infer)("fun"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("A function that returns a Uni can be used in place of a function that returns an Imm", "meh as fn (fn None: Number): Number =\n    fn f: f 'none\n\nblah = meh (fn 'none: 1)", ($u$$specs$Uniqueness$$infer)("blah"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("A function that returns an Imm CANNOT be used in place of a function that returns an Uni", "meh as fn (fn None: !Number): !Number =\n    fn f: f 'none\n\nx as Number = 1\n\nblah = meh (fn 'none: x)", ($u$$specs$Uniqueness$$infer)("blah"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("return", ($c$$src$Core$$Cons)("uniqueness", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("a Uni, b Uni", "var Re error payload = 'er error, 'okk payload\nisOkk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = this_is_sp_native\n\nscope =\n    !v = isOkk (fn !a: 'okk 0) ('okk 0)", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("a Uni, b Imm", "var Result_ error payload = 'err_ error, 'ok_ payload\nisOk_ as fn (fn 1?a: 2?Result_ error b), 1?Result_ error a: 2?Result_ error b = this_is_sp_native\nimmB as Number = 1\n\nv = isOk_ (fn !a: 'ok_ immB) ('ok_ 0)", ($u$$specs$Uniqueness$$infer)("v"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("No annotation", "na = fn 0?x: x", ($u$$specs$Uniqueness$$infer)("na"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($c$$src$Dict$$ofOne)(1, ({
    maybeAnnotated: $c$$src$Maybe$$Nothing,
  })),
  type: ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$ParSp)(({
    raw: ($c$$src$Compiler$TypedAst$$TypeVar)(1),
    uni: ($c$$src$Compiler$Ast$$Depends)(0),
  })), $c$$src$Core$$Nil), ({
    raw: ($c$$src$Compiler$TypedAst$$TypeVar)(1),
    uni: ($c$$src$Compiler$Ast$$Depends)(0),
  })),
}))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Generalization", "na as fn 1?a: 1?a =\n    fn 1?x: x\n\nscope as None =\n    !uni = na 0\n\nnone as None =\n    na scope", ($u$$specs$Uniqueness$$infer)("na"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("[rec] variable without any uniqueness flag should be imm", "scope =\n    num = 1\n\n    x as Number = num + 1\n    y as Number = num + 2", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), $c$$src$Core$$Nil)))))))));

const $u$$specs$Uniqueness$$records = ($i$test$$Test$$Group)("Records", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("The attribute of a mutable record can be accessed as a mutable:", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Simple case", "scope =\n    !record = { x = 0, y = 0 }\n    @record.x += 3", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Reject double reference", "someFunction =\n    this_is_sp_native\n\nscope =\n    !record = { x = 0, y = 0 }\n    someFunction @record.x @record.y", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("same unique twice in the same function call", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil));

const $u$$src$Compiler$TestHelpers$$moduleUsr = (($0) => {
  return ($c$$src$Compiler$Meta$$USR)($u$$src$Compiler$TestHelpers$$moduleUmr, $0);
});

const $u$$src$Compiler$TestHelpers$$taNumber = ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$CoreDefs$$usr)("Number"), $c$$src$Core$$Nil);

const $u$$specs$Uniqueness$$unions = ($i$test$$Test$$Group)("Unions", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Uniques inside immutables are converted to immutables", "var Z a = 'z a\nx = 'z 0", ($u$$specs$Uniqueness$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$TestHelpers$$moduleUsr)("Z"), ($c$$src$Core$$Cons)($u$$src$Compiler$TestHelpers$$taNumber, $c$$src$Core$$Nil)),
}))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("[reg] Lists of immutables", "i as Number = 1\nx = [ i, i ]", ($u$$specs$Uniqueness$$infer)("x"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("[reg] solveOneEquality can receive switched given/required when evaluating a cast?", "z as [fn None: None] = (fn 'none: 'none) :: []", ($u$$specs$Uniqueness$$infer)("z"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("LetIn: Unpack immutable to immutable", "var Z a = 'z a\nscope =\n    x = 'z 0\n    ('z y) = x", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("LetIn: Unpack unique to immutable", "var Z a = 'z a\nscope =\n    !x = 'z 0\n    ('z y) = x", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("LetIn: Unpack unique to unique", "var Z a = 'z a\nscope =\n    !x = 'z 0\n    !('z y) = x\n    @y += 1", ($u$$specs$Uniqueness$$infer)("scope"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("LetIn: Unpack immutable to unique", "var Z a = 'z a\nscope =\n    x = 'z 0\n    !('z y) = x", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("y", ($c$$src$Core$$Cons)("Unique", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Fn: Unpack immutable to immutable", "var Z a = 'z a\nf as fn Z a: Z a =\n     fn 'z a: 'z a", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Fn: Unpack unique to immutable", "var Z a = 'z a\nf as fn !(Z a): Z a =\n     fn !('z a): 'z a", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Fn: Unpack unique to unique", "var Z a = 'z a\nf as fn !(Z a): !(Z a) =\n     fn !('z a): 'z a", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Fn: Unpack immutable to unique", "var Z a = 'z a\nf as fn Z a: !(Z a) =\n     fn 'z a: 'z a", ($u$$specs$Uniqueness$$infer)("f"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Unique", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))))))))))));

const $u$$specs$Uniqueness$$uniquenessTyping = ($i$test$$Test$$Group)("Uniqueness Typing", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("All literal expressions allow uniqueness", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("failure", "f as fn Number: !Number = fn x: x", ($u$$specs$Uniqueness$$infer)("f"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("ErrorUniquenessDoesNotMatch", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Number", "f as fn a: !Number = fn _: 1", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Text", "f as fn a: !Text = fn _: \"meh\"", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Record", "f as fn a: !{} = fn _: {}", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Constructor 1", "f as fn a: !Bool = fn _: 'true", ($u$$specs$Uniqueness$$infer)("f"), $i$test$$Test$$isOk), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("Conversions", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Immutables cannot be used in place of uniques 2", "scope =\n    x = 1\n    @x += 1", ($u$$specs$Uniqueness$$infer)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("ErrorShouldBeUnique", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("Uniques can be implicitly transformed in immutables", "a as Number = 1", ($u$$specs$Uniqueness$$infer)("a"), $i$test$$Test$$isOk), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("A variable with mutable type must be explicitly declared as mutable with `!`", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("1", "z =\n    !a as Number = 1", ($u$$specs$Uniqueness$$infer)("z"), $i$test$$Test$$isOk), $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("Referencing a mutable variable \"spends\" it", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("base", "scope =\n    !x =\n        1\n\n    !y =\n        # The first time we do it it works!\n        x\n\n    !z =\n        # But here `x` is now spent, so we get a compiler error!\n        x", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("used already here", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("tuple", "scope =\n    !x =\n        1\n\n    !y =\n        x & x", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("used already here", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("A function cannot consume uniques outside its own scope.", ($c$$src$Core$$Cons)(($u$$specs$Uniqueness$$codeTest)("base", "scope =\n    !x = 1\n    fn z: x", ($u$$specs$Uniqueness$$infer)("scope"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("outside their body", ($c$$src$Core$$Cons)("x", $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)), $c$$src$Core$$Nil))))));

const $u$$specs$Uniqueness$$specs = ($i$test$$Test$$Group)("Uniqueness", ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$howDoesItLookLike, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$uniquenessTyping, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$mutation, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$parentScope, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$polymorphism, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$unions, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$records, $c$$src$Core$$Nil))))))));

const $u$$src$BuildMain$$asModule = (($tuple) => {
  const $2 = $tuple;
  const $name = $2.second;
  const $isDirectory = $2.first;
  return (($isDirectory || (sp_not_equal)(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$"))($name), $name))
    ? $c$$src$Maybe$$Nothing
    : ($c$$src$Maybe$$Just)(((($0) => {
      return ($c$$src$Text$$replace)(".sp", "", $0);
    }))($name)));
});

const $u$$src$BuildMain$$asModuleDirectory = (($tuple) => {
  const $2 = $tuple;
  const $name = $2.second;
  const $isDirectory = $2.first;
  return (($isDirectory && (sp_equal)(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$"))($name), $name))
    ? ($c$$src$Maybe$$Just)($name)
    : $c$$src$Maybe$$Nothing);
});

const $u$$src$BuildMain$$defaultCorelibDir = "corelib";

const $u$$src$BuildMain$$getEntryUsr = (($projectImports, $entryModule) => {
  return ($c$$src$Compiler$Meta$$resolve)(({
    currentImports: $projectImports,
    currentModule: $u$$src$Compiler$CoreDefs$$umr,
    loadExports: (($importsPath) => {
      return ($c$$src$Result$$Err)(($u$$src$Compiler$Error$$Raw)(($c$$src$Core$$Cons)("Entry point can't be in an installed library!", $c$$src$Core$$Nil)));
    }),
    makeError: $u$$src$Compiler$Error$$Raw,
  }), ($c$$src$Maybe$$Just)($entryModule), "main");
});

const $u$$src$BuildMain$$importsFileName = "imports.sp";

const $u$$src$BuildMain$$installedDir = "installedLibraries";

const $u$$src$BuildMain$$ioToRes = (($0) => {
  return ($c$$src$Result$$mapError)((($err) => {
    return ($u$$src$Compiler$Error$$Raw)(($c$$src$Core$$Cons)($err, $c$$src$Core$$Nil));
  }), $0);
});

const $u$$src$BuildMain$$loadCaModule = (($pars, $umr) => {
  return ((sp_equal)($umr, $u$$src$Compiler$CoreDefs$$umr)
    ? ($c$$src$Result$$Ok)($u$$src$Compiler$CoreDefs$$coreModule)
    : ((() => {
      const $3 = $umr;
      const $modulePath = ($3)[3];
      const $sourceDir = ($3)[2];
      const $importsPath = ($3)[1];
      const $4 = $importsPath;
      const $importsDir = ($4)[2];
      const $rootDirectory = ($4)[1];
      return (($c$$src$Result$$onOk)((($imports) => {
        const $rootPath = ($c$$src$Compiler$Meta$$rootDirectoryToPath)($pars.rootPaths, $rootDirectory);
        const $fileName = ((($0) => {
          return ($0 + ".sp");
        }))((path_join)(($c$$src$Core$$Cons)($rootPath, ($c$$src$Core$$Cons)($importsDir, ($c$$src$Core$$Cons)($sourceDir, ($c$$src$Core$$Cons)($modulePath, $c$$src$Core$$Nil))))));
        return (($c$$src$Result$$onOk)((($moduleAsText) => {
          const $errorModule = ({
            content: $moduleAsText,
            fsPath: $fileName,
          });
          const $resolvePars = (($pos) => {
            return ({
              currentImports: $imports,
              currentModule: $umr,
              loadExports: $pars.loadExports,
              makeError: (($0) => {
                return ($u$$src$Compiler$Error$$Simple)($errorModule, $pos, $0);
              }),
            });
          });
          const $params = ({
            errorModule: $errorModule,
            resolvePars: $resolvePars,
            umr: $umr,
          });
          return ($u$$src$Compiler$MakeCanonical$$textToCanonicalModule)(false, $params);
        })))(($u$$src$BuildMain$$ioToRes)(($pars.readFile)($fileName)));
      })))(($pars.loadImports)($importsPath));
    }))());
});

const $u$$src$BuildMain$$exportsFileName = "exports.sp";

const $u$$src$BuildMain$$listSourceDir = (($io, $sourceDirRoot, $modulePathWithTrailingSlash) => {
  const $path = ($sourceDirRoot + ("/" + $modulePathWithTrailingSlash));
  return ([
    (($c$$src$Result$$onOk)((($dirContents) => {
      const $directChildren = ((($0) => {
        return ($c$$src$List$$map)((($fileName) => {
          return ($modulePathWithTrailingSlash + $fileName);
        }), $0);
      }))(((($0) => {
        return ($c$$src$List$$filterMap)($u$$src$BuildMain$$asModule, $0);
      }))($dirContents));
      return (($c$$src$Result$$onOk)((($descendants) => {
        const $x = ($c$$src$List$$concat)(($c$$src$Core$$Cons)($directChildren, ($c$$src$Core$$Cons)(($c$$src$List$$concat)($descendants), $c$$src$Core$$Nil)));
        return ($c$$src$Result$$Ok)($x);
      })))(((($0) => {
        return ($c$$src$List$$mapRes)((($subDir) => {
          return ((__re__ = ($u$$src$BuildMain$$listSourceDir)($io, $sourceDirRoot, ($modulePathWithTrailingSlash + ($subDir + "/")))), ($io = (__re__)[1]), (__re__)[0]);
        }), $0);
      }))(((($0) => {
        return ($c$$src$List$$filterMap)($u$$src$BuildMain$$asModuleDirectory, $0);
      }))($dirContents)));
    })))(((__re__ = (io_readDir)($io, $path)), ($io = (__re__)[1]), (__re__)[0])),
    $io,
  ]);
});

const $u$$src$BuildMain$$updateSourceDir = (($fileNames, $orig) => {
  const $insertModuleName = (($name, $sd) => {
    const $5 = ($c$$src$List$$find)((($m) => {
      return (sp_equal)($m.path, $name);
    }), $sd.modules);
    return ((($5)[0] === "$Just")
      ? $sd
      : ((($5)[0] === "$Nothing")
        ? ((() => {
          const $0 = $sd;
          return (Object.assign)({}, $0, ({
            modules: (sp_cons)(({
              globals: $c$$src$Core$$Nil,
              path: $name,
              visibleAs: $name,
            }), $0.modules),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 160:8', (sp_toHuman)($5))));
  });
  return ($c$$src$List$$for)($orig, $fileNames, $insertModuleName);
});

const $u$$src$BuildMain$$scanSourceDirs = (($io, $rootPaths, $importsPath, $importsFile) => {
  const $5 = $importsPath;
  const $importsDir = ($5)[2];
  const $root = ($5)[1];
  const $rootPath = ($c$$src$Compiler$Meta$$rootDirectoryToPath)($rootPaths, $root);
  return ([
    (($c$$src$Result$$onOk)((($allSourceDirLists) => {
      const $updatedSourceDirs = ($c$$src$List$$map2)($u$$src$BuildMain$$updateSourceDir, $allSourceDirLists, $importsFile.sourceDirs);
      return ($u$$src$ImportsFile$$toImports)(({
        importsPath: $importsPath,
        joinPath: path_join,
      }), ((() => {
        const $0 = $importsFile;
        return (Object.assign)({}, $0, ({
          sourceDirs: $updatedSourceDirs,
        }));
      }))());
    })))(($u$$src$BuildMain$$ioToRes)(((($0) => {
      return ($c$$src$List$$mapRes)((($sd) => {
        return ((__re__ = ($u$$src$BuildMain$$listSourceDir)($io, (path_join)(($c$$src$Core$$Cons)($rootPath, ($c$$src$Core$$Cons)($importsDir, ($c$$src$Core$$Cons)($sd.path, $c$$src$Core$$Nil)))), "")), ($io = (__re__)[1]), (__re__)[0]);
      }), $0);
    }))($importsFile.sourceDirs))),
    $io,
  ]);
});

const $u$$src$ImportsFile$$init = ({
  libraries: $c$$src$Core$$Nil,
  sourceDirs: $c$$src$Core$$Nil,
});

const $u$$src$SPLib$SPON$$expr = (($aWhat, $getA) => {
  return (($0) => {
    return (((($0)[0] === "$Cons") && (((($0)[1])[0] === "$Evaluation") && (((($0)[1])[1])[0] === "$Expression")))
      ? ((() => {
        const $p = ((($0)[1])[1])[2];
        const $e = ((($0)[1])[1])[3];
        const $tail = ($0)[2];
        const $4 = ($getA)($e);
        return ((($4)[0] === "$Just")
          ? ((() => {
            const $a = ($4)[1];
            return ($u$$src$SPLib$SPON$$Accepted)($tail, $a);
          }))()
          : ((($4)[0] === "$Nothing")
            ? ($u$$src$SPLib$SPON$$Rejected)(((($0) => {
              return ($c$$src$Compiler$Pos$$At)($p, $0);
            }))(("Expecting " + $aWhat)))
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 91:12', (sp_toHuman)($4))));
      }))()
      : (((($0)[0] === "$Cons") && ((($0)[2])[0] === "$Nil"))
        ? ((() => {
          const $s = ($0)[1];
          return ($u$$src$SPLib$SPON$$Rejected)(((($0) => {
            return ($c$$src$Compiler$Pos$$At)(($c$$src$Compiler$FormattableAst$$statementPos)($s), $0);
          }))(("Expecting " + $aWhat)));
        }))()
        : (true
          ? ($u$$src$SPLib$SPON$$Failed)(($c$$src$Compiler$Pos$$At)($c$$src$Compiler$Pos$$End, "Expecting a statement"))
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 88:4', (sp_toHuman)($0)))));
  });
});

const $u$$src$SPLib$SPON$$anyName = ((($0) => {
  return ($u$$src$SPLib$SPON$$expr)("a name", $0);
}))((($0) => {
  return (((($0)[0] === "$Lowercase") && (((($0)[1].attrPath)[0] === "$Nil") && (((($0)[1].maybeModule)[0] === "$Nothing") && ((($0)[1].maybeType)[0] === "$Nothing"))))
    ? ((() => {
      const $name = ($0)[1].name;
      return ($c$$src$Maybe$$Just)($name);
    }))()
    : (((($0)[0] === "$Uppercase") && ((($0)[1].maybeModule)[0] === "$Nothing"))
      ? ((() => {
        const $name = ($0)[1].name;
        return ($c$$src$Maybe$$Just)($name);
      }))()
      : (((($0)[0] === "$Constructor") && ((($0)[1].maybeModule)[0] === "$Nothing"))
        ? ((() => {
          const $name = ($0)[1].name;
          return ($c$$src$Maybe$$Just)($name);
        }))()
        : (true
          ? $c$$src$Maybe$$Nothing
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 139:4', (sp_toHuman)($0))))));
}));

const $u$$src$SPLib$SPON$$expressionToStatements = (($e) => {
  return (((($e)[0] === "$Expression") && (((($e)[3])[0] === "$Statements") && ((((($e)[3])[1])[0] === "$Cons") && (((((($e)[3])[1])[1])[0] === "$Evaluation") && ((((($e)[3])[1])[2])[0] === "$Nil")))))
    ? ((() => {
      const $nested = (((($e)[3])[1])[1])[1];
      return ($u$$src$SPLib$SPON$$expressionToStatements)($nested);
    }))()
    : (((($e)[0] === "$Expression") && ((($e)[3])[0] === "$Statements"))
      ? ((() => {
        const $stats = (($e)[3])[1];
        return $stats;
      }))()
      : (true
        ? ($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$Evaluation)($e), $c$$src$Core$$Nil)
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 207:4', (sp_toHuman)($e)))));
});

const $u$$src$SPLib$SPON$$field = (($fieldName, $fieldReader) => {
  return (($0) => {
    return (((($0)[0] === "$Cons") && (((($0)[1])[0] === "$ValueDef") && ((((($0)[1])[1].pattern)[0] === "$Expression") && (((((($0)[1])[1].pattern)[3])[0] === "$Lowercase") && ((((((($0)[1])[1].pattern)[3])[1].attrPath)[0] === "$Nil") && ((((((($0)[1])[1].pattern)[3])[1].maybeModule)[0] === "$Nothing") && (((((($0)[1])[1].pattern)[3])[1].maybeType)[0] === "$Nothing")))))))
      ? ((() => {
        const $body = (($0)[1])[1].body;
        const $nonFn = (($0)[1])[1].nonFn;
        const $pos = ((($0)[1])[1].pattern)[2];
        const $name = (((($0)[1])[1].pattern)[3])[1].name;
        const $tail = ($0)[2];
        return ((sp_equal)($name, $fieldName)
          ? ((() => {
            const $4 = ($fieldReader)(($u$$src$SPLib$SPON$$expressionToStatements)($body));
            return ((($4)[0] === "$Accepted")
              ? ((() => {
                const $unreadStatements = ($4)[1];
                const $a = ($4)[2];
                return ((($unreadStatements)[0] === "$Nil")
                  ? ($u$$src$SPLib$SPON$$Accepted)($tail, $a)
                  : ((($unreadStatements)[0] === "$Cons")
                    ? ((() => {
                      const $head = ($unreadStatements)[1];
                      return ($u$$src$SPLib$SPON$$Failed)(((($0) => {
                        return ($c$$src$Compiler$Pos$$At)(($c$$src$Compiler$FormattableAst$$statementPos)($head), $0);
                      }))(("Could not make sense of all the statements in field `" + ($fieldName + "`."))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 239:24', (sp_toHuman)($unreadStatements))));
              }))()
              : (true
                ? ((() => {
                  const $otherwise = $4;
                  return $otherwise;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 236:16', (sp_toHuman)($4))));
          }))()
          : ($u$$src$SPLib$SPON$$Rejected)(((($0) => {
            return ($c$$src$Compiler$Pos$$At)($pos, $0);
          }))(("expecting `" + ($fieldName + " =`")))));
      }))()
      : ((($0)[0] === "$Cons")
        ? ((() => {
          const $head = ($0)[1];
          const $tail = ($0)[2];
          return ($u$$src$SPLib$SPON$$Rejected)(($c$$src$Compiler$Pos$$At)(($c$$src$Compiler$FormattableAst$$statementPos)($head), "missing a simple assignment (ie `something = `)"));
        }))()
        : ((($0)[0] === "$Nil")
          ? ($u$$src$SPLib$SPON$$Rejected)(($c$$src$Compiler$Pos$$At)($c$$src$Compiler$Pos$$End, "unexpected end of file"))
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 215:4', (sp_toHuman)($0)))));
  });
});

const $u$$src$SPLib$SPON$$many = (($readerA) => {
  const $rec = (($accum) => {
    return (($statements) => {
      return ((sp_equal)($statements, $c$$src$Core$$Nil)
        ? ($u$$src$SPLib$SPON$$Accepted)($c$$src$Core$$Nil, ($c$$src$List$$reverse)($accum))
        : ((() => {
          const $4 = ($readerA)($statements);
          return ((($4)[0] === "$Accepted")
            ? ((() => {
              const $tail = ($4)[1];
              const $a = ($4)[2];
              return (($rec)((sp_cons)($a, $accum)))($tail);
            }))()
            : ((($4)[0] === "$Rejected")
              ? ((() => {
                const $e = ($4)[1];
                return ($u$$src$SPLib$SPON$$Rejected)($e);
              }))()
              : ((($4)[0] === "$Failed")
                ? ((() => {
                  const $e = ($4)[1];
                  return ($u$$src$SPLib$SPON$$Failed)($e);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 187:12', (sp_toHuman)($4)))));
        }))());
    });
  });
  return ($rec)($c$$src$Core$$Nil);
});

const $u$$src$SPLib$SPON$$maybe = (($readerA) => {
  return (($statements) => {
    const $3 = ($readerA)($statements);
    return ((($3)[0] === "$Accepted")
      ? ((() => {
        const $tail = ($3)[1];
        const $a = ($3)[2];
        return ($u$$src$SPLib$SPON$$Accepted)($tail, ($c$$src$Maybe$$Just)($a));
      }))()
      : ((($3)[0] === "$Rejected")
        ? ($u$$src$SPLib$SPON$$Accepted)($statements, $c$$src$Maybe$$Nothing)
        : ((($3)[0] === "$Failed")
          ? ((() => {
            const $r = ($3)[1];
            return ($u$$src$SPLib$SPON$$Failed)($r);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 198:4', (sp_toHuman)($3)))));
  });
});

const $u$$src$SPLib$SPON$$onAcc = (($chainedReaderB) => {
  return (($readerA) => {
    return (($statements) => {
      const $4 = ($readerA)($statements);
      return ((($4)[0] === "$Accepted")
        ? ((() => {
          const $newStatements = ($4)[1];
          const $a = ($4)[2];
          return (($chainedReaderB)($a))($newStatements);
        }))()
        : ((($4)[0] === "$Rejected")
          ? ((() => {
            const $reason = ($4)[1];
            return ($u$$src$SPLib$SPON$$Rejected)($reason);
          }))()
          : ((($4)[0] === "$Failed")
            ? ((() => {
              const $reason = ($4)[1];
              return ($u$$src$SPLib$SPON$$Failed)($reason);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 20:4', (sp_toHuman)($4)))));
    });
  });
});

const $u$$src$SPLib$SPON$$return = (($a) => {
  return (($statements) => {
    return ($u$$src$SPLib$SPON$$Accepted)($statements, $a);
  });
});

const $u$$src$SPLib$SPON$$upperName = ((($0) => {
  return ($u$$src$SPLib$SPON$$expr)("a simple Uppercase name", $0);
}))((($0) => {
  return (((($0)[0] === "$Uppercase") && ((($0)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($0)[1].name;
      return ($c$$src$Maybe$$Just)($name);
    }))()
    : (true
      ? $c$$src$Maybe$$Nothing
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 125:4', (sp_toHuman)($0))));
}));

const $u$$src$ImportsFile$$moduleReader = (($u$$src$SPLib$SPON$$onAcc)((($path) => {
  return (($u$$src$SPLib$SPON$$onAcc)((($visibleAs) => {
    return (($u$$src$SPLib$SPON$$onAcc)((($globals) => {
      return ($u$$src$SPLib$SPON$$return)(({
        globals: ($c$$src$Maybe$$withDefault)($c$$src$Core$$Nil, $globals),
        path: $path,
        visibleAs: ($c$$src$Maybe$$withDefault)($path, $visibleAs),
      }));
    })))(($u$$src$SPLib$SPON$$maybe)(($u$$src$SPLib$SPON$$field)("globals", ($u$$src$SPLib$SPON$$many)($u$$src$SPLib$SPON$$anyName))));
  })))(($u$$src$SPLib$SPON$$maybe)(($u$$src$SPLib$SPON$$field)("importAs", $u$$src$SPLib$SPON$$upperName)));
})))(($u$$src$SPLib$SPON$$field)("path", $u$$src$SPLib$SPON$$upperName));

const $u$$src$SPLib$SPON$$text = ((($0) => {
  return ($u$$src$SPLib$SPON$$expr)("a text literal", $0);
}))((($0) => {
  return ((($0)[0] === "$LiteralText")
    ? ((() => {
      const $t = ($0)[2];
      return ($c$$src$Maybe$$Just)($t);
    }))()
    : (true
      ? $c$$src$Maybe$$Nothing
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 111:4', (sp_toHuman)($0))));
}));

const $u$$src$ImportsFile$$libraryReader = (($u$$src$SPLib$SPON$$onAcc)((($source) => {
  return (($u$$src$SPLib$SPON$$onAcc)((($modules) => {
    return ($u$$src$SPLib$SPON$$return)(({
      modules: $modules,
      source: $source,
    }));
  })))(($u$$src$SPLib$SPON$$many)(($u$$src$SPLib$SPON$$field)("module", $u$$src$ImportsFile$$moduleReader)));
})))(($u$$src$SPLib$SPON$$field)("source", $u$$src$SPLib$SPON$$text));

const $u$$src$ImportsFile$$sourceDirectoryReader = (($u$$src$SPLib$SPON$$onAcc)((($path) => {
  return (($u$$src$SPLib$SPON$$onAcc)((($modules) => {
    return ($u$$src$SPLib$SPON$$return)(({
      modules: $modules,
      path: $path,
    }));
  })))(($u$$src$SPLib$SPON$$many)(($u$$src$SPLib$SPON$$field)("module", $u$$src$ImportsFile$$moduleReader)));
})))(($u$$src$SPLib$SPON$$field)("path", $u$$src$SPLib$SPON$$text));

const $u$$src$SPLib$SPON$$oneOf = (($readers) => {
  return (($statements) => {
    return ((($readers)[0] === "$Nil")
      ? ((() => {
        const $pos = ((($statements)[0] === "$Cons")
          ? ((() => {
            const $head = ($statements)[1];
            return ($c$$src$Compiler$FormattableAst$$statementPos)($head);
          }))()
          : (true
            ? $c$$src$Compiler$Pos$$End
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 159:16', (sp_toHuman)($statements))));
        return ($u$$src$SPLib$SPON$$Rejected)(($c$$src$Compiler$Pos$$At)($pos, "options exhausted"));
      }))()
      : ((($readers)[0] === "$Cons")
        ? ((() => {
          const $headReader = ($readers)[1];
          const $tail = ($readers)[2];
          const $3 = ($headReader)($statements);
          return ((($3)[0] === "$Rejected")
            ? (($u$$src$SPLib$SPON$$oneOf)($tail))($statements)
            : (true
              ? ((() => {
                const $otherwise = $3;
                return $otherwise;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 166:12', (sp_toHuman)($3))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 155:4', (sp_toHuman)($readers))));
  });
});

const $u$$src$ImportsFile$$modulesFileReader = ($u$$src$SPLib$SPON$$many)(($u$$src$SPLib$SPON$$oneOf)(($c$$src$Core$$Cons)((($u$$src$SPLib$SPON$$onAcc)((($lib) => {
  return ($u$$src$SPLib$SPON$$return)(($u$$src$ImportsFile$$Lib)($lib));
})))(($u$$src$SPLib$SPON$$field)("library", $u$$src$ImportsFile$$libraryReader)), ($c$$src$Core$$Cons)((($u$$src$SPLib$SPON$$onAcc)((($dir) => {
  return ($u$$src$SPLib$SPON$$return)(($u$$src$ImportsFile$$Dir)($dir));
})))(($u$$src$SPLib$SPON$$field)("sourceDir", $u$$src$ImportsFile$$sourceDirectoryReader)), $c$$src$Core$$Nil))));

const $u$$src$SPLib$SPON$$run = (($readerA, $errorModule, $statements) => {
  const $4 = ($readerA)($statements);
  return (((($4)[0] === "$Accepted") && ((($4)[1])[0] === "$Nil"))
    ? ((() => {
      const $a = ($4)[2];
      return ($c$$src$Result$$Ok)($a);
    }))()
    : (((($4)[0] === "$Accepted") && ((($4)[1])[0] === "$Cons"))
      ? ((() => {
        const $head = (($4)[1])[1];
        const $tail = (($4)[1])[2];
        const $a = ($4)[2];
        return ($u$$src$Compiler$Error$$res)($errorModule, ($c$$src$Compiler$FormattableAst$$statementPos)($head), ($c$$src$Core$$Cons)("unread statements", $c$$src$Core$$Nil));
      }))()
      : (((($4)[0] === "$Rejected") && ((($4)[1])[0] === "$At"))
        ? ((() => {
          const $pos = (($4)[1])[1];
          const $r = (($4)[1])[2];
          return ($u$$src$Compiler$Error$$res)($errorModule, $pos, ($c$$src$Core$$Cons)($r, $c$$src$Core$$Nil));
        }))()
        : (((($4)[0] === "$Failed") && ((($4)[1])[0] === "$At"))
          ? ((() => {
            const $pos = (($4)[1])[1];
            const $r = (($4)[1])[2];
            return ($u$$src$Compiler$Error$$res)($errorModule, $pos, ($c$$src$Core$$Cons)($r, $c$$src$Core$$Nil));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 50:4', (sp_toHuman)($4))))));
});

const $u$$src$SPLib$SPON$$read = (($reader, $fsPath, $content) => {
  const $errorModule = ({
    content: $content,
    fsPath: $fsPath,
  });
  return (($c$$src$Result$$onOk)((($0) => {
    return ($u$$src$SPLib$SPON$$run)($reader, $errorModule, $0);
  })))(($u$$src$Compiler$Parser$$textToFormattableModule)(({
    errorModule: $errorModule,
    keepComments: false,
    stripLocations: false,
  })));
});

const $u$$src$ImportsFile$$textToModulesFile = (($sponName, $sponContent) => {
  const $insert = (($rootEntry, $mf) => {
    return ((($rootEntry)[0] === "$Lib")
      ? ((() => {
        const $lib = ($rootEntry)[1];
        const $0 = $mf;
        return (Object.assign)({}, $0, ({
          libraries: (sp_cons)($lib, $mf.libraries),
        }));
      }))()
      : ((($rootEntry)[0] === "$Dir")
        ? ((() => {
          const $dir = ($rootEntry)[1];
          const $0 = $mf;
          return (Object.assign)({}, $0, ({
            sourceDirs: (sp_cons)($dir, $mf.sourceDirs),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 217:8', (sp_toHuman)($rootEntry))));
  });
  return ((($0) => {
    return ($c$$src$Result$$map)((($0) => {
      return ($c$$src$List$$for)($u$$src$ImportsFile$$init, $0, $insert);
    }), $0);
  }))(((($0) => {
    return ($u$$src$SPLib$SPON$$read)($u$$src$ImportsFile$$modulesFileReader, $sponName, $0);
  }))($sponContent));
});

const $u$$src$BuildMain$$loadImports = (($io, $loadedImports, $rootPaths, $importsPath) => {
  const $5 = ((__re__ = (hash_get)($loadedImports, $importsPath)), ($loadedImports = (__re__)[1]), (__re__)[0]);
  return ([
    ((($5)[0] === "$Just")
      ? ((() => {
        const $imports = ($5)[1];
        return ($c$$src$Result$$Ok)($imports);
      }))()
      : ((($5)[0] === "$Nothing")
        ? ((() => {
          const $6 = $importsPath;
          const $importsDir = ($6)[2];
          const $rootDirectory = ($6)[1];
          const $filePath = (path_resolve)(($c$$src$Core$$Cons)(($c$$src$Compiler$Meta$$rootDirectoryToPath)($rootPaths, $rootDirectory), ($c$$src$Core$$Cons)($importsDir, ($c$$src$Core$$Cons)($u$$src$BuildMain$$importsFileName, $c$$src$Core$$Nil))));
          return (($c$$src$Result$$onOk)((($fileContent) => {
            return (($c$$src$Result$$onOk)((($importsFile) => {
              return (($c$$src$Result$$onOk)((($imports) => {
                ((__re__ = (hash_insert)($loadedImports, $importsPath, $imports)), ($loadedImports = (__re__)[1]), (__re__)[0]);
                return ($c$$src$Result$$Ok)($imports);
              })))(((__re__ = ($u$$src$BuildMain$$scanSourceDirs)($io, $rootPaths, $importsPath, $importsFile)), ($io = (__re__)[1]), (__re__)[0]));
            })))(($u$$src$ImportsFile$$textToModulesFile)($filePath, $fileContent));
          })))(($u$$src$BuildMain$$ioToRes)(((__re__ = (io_readFile)($io, $filePath)), ($io = (__re__)[1]), (__re__)[0])));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 222:4', (sp_toHuman)($5)))),
    $io,
    $loadedImports,
  ]);
});

const $u$$src$ExportsFile$$exposesReader = (($u$$src$SPLib$SPON$$onAcc)((($name) => {
  return ($u$$src$SPLib$SPON$$return)(({
    name: $name,
    open: true,
  }));
})))($u$$src$SPLib$SPON$$anyName);

const $u$$src$ExportsFile$$moduleReader = (($u$$src$SPLib$SPON$$onAcc)((($path) => {
  return (($u$$src$SPLib$SPON$$onAcc)((($maybeExposes) => {
    return ($u$$src$SPLib$SPON$$return)(({
      exposes: ($c$$src$List$$for)($c$$src$Dict$$empty, ($c$$src$Maybe$$withDefault)($c$$src$Core$$Nil, $maybeExposes), (($e, $d) => {
        return ($c$$src$Dict$$insert)($e.name, $e.open, $d);
      })),
      path: $path,
    }));
  })))(($u$$src$SPLib$SPON$$maybe)(($u$$src$SPLib$SPON$$field)("exposes", ($u$$src$SPLib$SPON$$many)($u$$src$ExportsFile$$exposesReader))));
})))(($u$$src$SPLib$SPON$$field)("path", $u$$src$SPLib$SPON$$upperName));

const $u$$src$ExportsFile$$exportsFileReader = (($u$$src$SPLib$SPON$$onAcc)((($modules) => {
  return ($u$$src$SPLib$SPON$$return)(($c$$src$List$$for)($c$$src$Dict$$empty, $modules, (($module, $d) => {
    return ($c$$src$Dict$$insert)($module.path, $module.exposes, $d);
  })));
})))(($u$$src$SPLib$SPON$$many)(($u$$src$SPLib$SPON$$field)("module", $u$$src$ExportsFile$$moduleReader)));

const $u$$src$ExportsFile$$fromText = (($0, $1) => {
  return ($u$$src$SPLib$SPON$$read)($u$$src$ExportsFile$$exportsFileReader, $0, $1);
});

const $u$$src$ExportsFile$$result_withAddError = (($groupErrors, $collectErrors) => {
  let $errors = (array_fromList)($c$$src$Core$$Nil);
  const $addError = (($0) => {
    return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
  });
  const $payload = ($collectErrors)($addError);
  const $errorList = ((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]);
  return ((sp_equal)($errorList, $c$$src$Core$$Nil)
    ? ($c$$src$Result$$Ok)($payload)
    : ($c$$src$Result$$Err)(($groupErrors)($errorList)));
});

const $u$$src$ExportsFile$$toExports = (($imports, $exportsFile) => {
  return ($u$$src$ExportsFile$$result_withAddError)($u$$src$Compiler$Error$$Nested, (($addError_) => {
    const $addError = (($0) => {
      return ($addError_)(($u$$src$Compiler$Error$$Raw)($0));
    });
    return ($c$$src$Dict$$for)($c$$src$Dict$$empty, $exportsFile, (($modulePath, $exposedNames, $d) => {
      const $7 = ($c$$src$Dict$$get)($modulePath, $imports.modulePathToLocation);
      return ((($7)[0] === "$Nothing")
        ? ((() => {
          ($addError)(($c$$src$Core$$Cons)(("TODO exports refers to a module with path " + ($modulePath + " but that is not in imports.")), ($c$$src$Core$$Cons)(((($0) => {
            return ($c$$src$Text$$join)(", ", $0);
          }))(($c$$src$Dict$$keys)($imports.modulePathToLocation)), $c$$src$Core$$Nil)));
          return $d;
        }))()
        : (((($7)[0] === "$Just") && ((($7)[1])[0] === "$LocationLibrary"))
          ? ((() => {
            const $importsPath = (($7)[1])[1];
            const $modulePath_ = (($7)[1])[2];
            ($addError)(($c$$src$Core$$Cons)("TODO you can't export modules from a library", $c$$src$Core$$Nil));
            return $d;
          }))()
          : (((($7)[0] === "$Just") && ((($7)[1])[0] === "$LocationSourceDir"))
            ? ((() => {
              const $umr = (($7)[1])[1];
              return ($c$$src$Dict$$for)($d, $exposedNames, (($name, $isOpen, $dd) => {
                const $usr = ($c$$src$Compiler$Meta$$USR)($umr, $name);
                const $addNameToModule = (($0) => {
                  return ($c$$src$Maybe$$Just)(((($0) => {
                    return ($c$$src$Dict$$insert)($name, ({
                      isOpen: $isOpen,
                      usr: $usr,
                    }), $0);
                  }))(((($0) => {
                    return ($c$$src$Maybe$$withDefault)($c$$src$Dict$$empty, $0);
                  }))($0)));
                });
                return ($c$$src$Dict$$update)($modulePath, $addNameToModule, $dd);
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/ExportsFile.sp 53:12', (sp_toHuman)($7)))));
    }));
  }));
});

const $u$$src$BuildMain$$loadExports = (($io, $loadedImports, $loadedExports, $rootPaths, $importsPath) => {
  const $6 = ((__re__ = (hash_get)($loadedExports, $importsPath)), ($loadedExports = (__re__)[1]), (__re__)[0]);
  return ([
    ((($6)[0] === "$Just")
      ? ((() => {
        const $exports = ($6)[1];
        return ($c$$src$Result$$Ok)($exports);
      }))()
      : ((($6)[0] === "$Nothing")
        ? (($c$$src$Result$$onOk)((($imports) => {
          const $8 = $importsPath;
          const $importsDir = ($8)[2];
          const $rootDirectory = ($8)[1];
          const $filePath = (path_resolve)(($c$$src$Core$$Cons)(($c$$src$Compiler$Meta$$rootDirectoryToPath)($rootPaths, $rootDirectory), ($c$$src$Core$$Cons)($importsDir, ($c$$src$Core$$Cons)($u$$src$BuildMain$$exportsFileName, $c$$src$Core$$Nil))));
          return (($c$$src$Result$$onOk)((($fileContent) => {
            return (($c$$src$Result$$onOk)((($exportsFile) => {
              return (($c$$src$Result$$onOk)((($exports) => {
                ((__re__ = (hash_insert)($loadedExports, $importsPath, $exports)), ($loadedExports = (__re__)[1]), (__re__)[0]);
                return ($c$$src$Result$$Ok)($exports);
              })))(($u$$src$ExportsFile$$toExports)($imports, $exportsFile));
            })))(($u$$src$ExportsFile$$fromText)($filePath, $fileContent));
          })))(($u$$src$BuildMain$$ioToRes)(((__re__ = (io_readFile)($io, $filePath)), ($io = (__re__)[1]), (__re__)[0])));
        })))(((__re__ = ($u$$src$BuildMain$$loadImports)($io, $loadedImports, $rootPaths, $importsPath)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), (__re__)[0]))
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 195:4', (sp_toHuman)($6)))),
    $io,
    $loadedImports,
    $loadedExports,
  ]);
});

const $u$$src$BuildMain$$searchAncestorDirectories = (($io, $isWantedFile, $searchDir) => {
  const $4 = ((__re__ = (io_readDir)($io, $searchDir)), ($io = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Err")
      ? $c$$src$Maybe$$Nothing
      : ((($4)[0] === "$Ok")
        ? ((() => {
          const $dirContents = ($4)[1];
          return (($c$$src$List$$any)($isWantedFile, $dirContents)
            ? ($c$$src$Maybe$$Just)($searchDir)
            : ((() => {
              const $parent = (path_resolve)(($c$$src$Core$$Cons)($searchDir, ($c$$src$Core$$Cons)("..", $c$$src$Core$$Nil)));
              return ((sp_equal)($parent, $searchDir)
                ? $c$$src$Maybe$$Nothing
                : ((__re__ = ($u$$src$BuildMain$$searchAncestorDirectories)($io, $isWantedFile, $parent)), ($io = (__re__)[1]), (__re__)[0]));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 248:4', (sp_toHuman)($4)))),
    $io,
  ]);
});

const $u$$src$BuildMain$$compileMain = (($io, $pars) => {
  const $projectRoot = ((($0) => {
    return ($c$$src$Maybe$$withDefault)(".", $0);
  }))(((__re__ = ($u$$src$BuildMain$$searchAncestorDirectories)($io, (($3) => {
    const $isDirectory = $3.first;
    const $fileName = $3.second;
    return (($c$$src$Basics$$not)($isDirectory) && (sp_equal)($fileName, $u$$src$BuildMain$$importsFileName));
  }), ".")), ($io = (__re__)[1]), (__re__)[0]));
  ((($0) => {
    return ((__re__ = (io_writeStdout)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
  }))(("Project root is " + ((path_resolve)(($c$$src$Core$$Cons)($projectRoot, $c$$src$Core$$Nil)) + "\n")));
  const $importsPath = ($c$$src$Compiler$Meta$$ImportsPath)($c$$src$Compiler$Meta$$User, "");
  const $corelibPath = ((() => {
    const $3 = $pars.corelib;
    return ((($3)[0] === "$Just")
      ? ((() => {
        const $corelib = ($3)[1];
        return $corelib;
      }))()
      : ((($3)[0] === "$Nothing")
        ? ((() => {
          const $executablePath = (path_dirname)((path_resolve)(($c$$src$Core$$Cons)($pars.selfPath, $c$$src$Core$$Nil)));
          return (path_join)(($c$$src$Core$$Cons)($executablePath, ($c$$src$Core$$Cons)($u$$src$BuildMain$$defaultCorelibDir, $c$$src$Core$$Nil)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 300:8', (sp_toHuman)($3))));
  }))();
  const $rootPaths = ({
    core: $corelibPath,
    installed: (path_join)(($c$$src$Core$$Cons)($projectRoot, ($c$$src$Core$$Cons)($u$$src$BuildMain$$installedDir, $c$$src$Core$$Nil))),
    project: $projectRoot,
  });
  let $loadedImports = (hash_fromList)($c$$src$Core$$Nil);
  let $loadedExports = (hash_fromList)($c$$src$Core$$Nil);
  return ([
    (($c$$src$Result$$onOk)((($projectImports) => {
      return (($c$$src$Result$$onOk)((($entryUsr) => {
        const $loadCaModulePars = ({
          loadExports: (($0) => {
            return ((__re__ = ($u$$src$BuildMain$$loadExports)($io, $loadedImports, $loadedExports, $rootPaths, $0)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), ($loadedExports = (__re__)[3]), (__re__)[0]);
          }),
          loadImports: (($0) => {
            return ((__re__ = ($u$$src$BuildMain$$loadImports)($io, $loadedImports, $rootPaths, $0)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), (__re__)[0]);
          }),
          readFile: (($0) => {
            return ((__re__ = (io_readFile)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
          }),
          rootPaths: $rootPaths,
        });
        return (($c$$src$Result$$onOk)((($5) => {
          const $constructors = $5.constructors;
          const $rootValues = $5.rootValues;
          const $outputFile = ($c$$src$Maybe$$withDefault)($pars.platform.defaultOutputName, $pars.maybeOutputPath);
          const $type = ((() => {
            const $6 = ($c$$src$List$$find)((($rv) => {
              return (sp_equal)($rv.usr, $entryUsr);
            }), $rootValues);
            return ((($6)[0] === "$Just")
              ? ((() => {
                const $rv = ($6)[1];
                return $rv.type;
              }))()
              : ((($6)[0] === "$Nothing")
                ? (sp_todo)("no type!?")
                : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 371:8', (sp_toHuman)($6))));
          }))();
          return (($c$$src$Result$$onOk)(((_0) => {
            return ($u$$src$BuildMain$$ioToRes)(((__re__ = (io_writeStdout)($io, ("---> " + ($outputFile + " written. =)")))), ($io = (__re__)[1]), (__re__)[0]));
          })))(($u$$src$BuildMain$$ioToRes)(((($0) => {
            return ((__re__ = (io_writeFile)($io, $outputFile, $0)), ($io = (__re__)[1]), (__re__)[0]);
          }))(($pars.platform.makeExecutable)(({
            constructors: $constructors,
            defs: $rootValues,
            entryUsr: $entryUsr,
            type: $type,
          })))));
        })))(($u$$src$Compiler$LazyBuild$$build)(({
          loadCaModule: (($0) => {
            return ($u$$src$BuildMain$$loadCaModule)($loadCaModulePars, $0);
          }),
          requiredUsrs: ($c$$src$Core$$Cons)($entryUsr, $c$$src$Core$$Nil),
        })));
      })))(($u$$src$BuildMain$$getEntryUsr)($projectImports, $pars.entryPoint));
    })))(((__re__ = ($u$$src$BuildMain$$loadImports)($io, $loadedImports, $rootPaths, $importsPath)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), (__re__)[0])),
    $io,
  ]);
});

const $u$$src$Compiler$Lexer_Test$$codeTest = (($0, $1, $2, $3) => {
  return ($i$test$$Test$$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const $u$$src$Compiler$Lexer_Test$$lexTokens = (($s) => {
  return ($u$$src$Compiler$TestHelpers$$resErrorToStrippedText)(((($0) => {
    return ($u$$src$Compiler$Lexer$$lexer)(true, $0);
  }))(($u$$src$Compiler$TestHelpers$$errorModule)($s)));
});

const $u$$src$Compiler$Lexer_Test$$lexTokensAndDrop = (($name) => {
  return (($s) => {
    return ((($0) => {
      return ($c$$src$Result$$map)((($0) => {
        return ($c$$src$List$$map)((($0) => {
          return ($c$$src$List$$drop)($name, $0);
        }), $0);
      }), $0);
    }))(($u$$src$Compiler$Lexer_Test$$lexTokens)($s));
  });
});

const $u$$src$Compiler$Lexer_Test$$lowerName = (($name) => {
  return ($c$$src$Compiler$Token$$Lowercase)(({
    attrPath: $c$$src$Core$$Nil,
    maybeModule: $c$$src$Maybe$$Nothing,
    name: $name,
  }));
});

const $u$$src$Compiler$Lexer_Test$$comments = ($i$test$$Test$$Group)("Comments", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] statement after comment", "\n#\na = 1\n", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)($c$$src$Core$$Nil, ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(3, 4, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(5, 6, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(7, 8, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(false, "1")), $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] nested comments allow a spurious newline?", "\n[#[##]#]\na = 1\n", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 9, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: false,
}))), $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($c$$src$Compiler$Token$$Token)(10, 10, $c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(10, 11, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(12, 13, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(14, 15, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(false, "1")), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("Single line", "# hello", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 7, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 0,
  isBlock: false,
  isFollowedByBlank: false,
}))), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("Multi line", "[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 17, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: true,
}))), $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(19, 19, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(19, 20, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(21, 33, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 2,
  isBlock: true,
  isFollowedByBlank: false,
}))), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(34, 35, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(36, 37, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(false, "1")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(39, 59, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: true,
}))), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(61, 79, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: false,
}))), $c$$src$Core$$Nil))))))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("brackets", "[]", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 1, $0);
}))(($c$$src$Compiler$Token$$SquareBracket)(0, $c$$src$Compiler$Token$$Open)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 2, $0);
}))(($c$$src$Compiler$Token$$SquareBracket)(0, $c$$src$Compiler$Token$$Closed)), $c$$src$Core$$Nil)), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] Inline comments should not break a block", "allTests = [\n    , a\n#\n    ]", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 0, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 8, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("allTests")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(9, 10, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(11, 12, $0);
}))(($c$$src$Compiler$Token$$SquareBracket)(0, $c$$src$Compiler$Token$$Open)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(17, 18, $0);
}))($c$$src$Compiler$Token$$Comma), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(19, 20, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(21, 22, $0);
}))(($c$$src$Compiler$Token$$Comment)(({
  indent: 0,
  isBlock: false,
  isFollowedByBlank: false,
}))), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(27, 28, $0);
}))(($c$$src$Compiler$Token$$SquareBracket)(3, $c$$src$Compiler$Token$$Closed)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(28, 28, $0);
}))($c$$src$Compiler$Token$$BlockEnd), $c$$src$Core$$Nil))))))))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))))));

const $u$$src$Compiler$Lexer_Test$$upperName = (($name) => {
  return ($c$$src$Compiler$Token$$Uppercase)(({
    maybeModule: $c$$src$Maybe$$Nothing,
    name: $name,
  }));
});

const $u$$src$Compiler$Lexer_Test$$indentation = ($i$test$$Test$$Group)("Blocks, sibling lines, indentation", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("1", "\na =\n 1\nb = 1", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 1, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 2, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(3, 4, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(6, 6, $0);
}))($c$$src$Compiler$Token$$BlockStart), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(6, 7, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(false, "1")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(8, 8, $0);
}))($c$$src$Compiler$Token$$BlockEnd), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(8, 8, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(8, 9, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("b")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(10, 11, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(12, 13, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(false, "1")), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] spurious spaces in front of field name", "module =\n   importAs =\n      SPCore\n   globalTypes =\n      None", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 0, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 6, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("module")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(7, 8, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(12, 12, $0);
}))($c$$src$Compiler$Token$$BlockStart), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(12, 20, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("importAs")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(21, 22, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(29, 29, $0);
}))($c$$src$Compiler$Token$$BlockStart), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(29, 35, $0);
}))(($u$$src$Compiler$Lexer_Test$$upperName)("SPCore")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(39, 39, $0);
}))($c$$src$Compiler$Token$$BlockEnd), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(39, 39, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(39, 50, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("globalTypes")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(51, 52, $0);
}))($c$$src$Compiler$Token$$Defop), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(59, 59, $0);
}))($c$$src$Compiler$Token$$BlockStart), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(59, 63, $0);
}))(($u$$src$Compiler$Lexer_Test$$upperName)("None")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(63, 63, $0);
}))($c$$src$Compiler$Token$$BlockEnd), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(63, 63, $0);
}))($c$$src$Compiler$Token$$BlockEnd), $c$$src$Core$$Nil)))))))))))))))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$Lexer_Test$$names = ($i$test$$Test$$Group)("Names", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] Simple record access", "a.b", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 3, $0);
}))(($c$$src$Compiler$Token$$Lowercase)(({
  attrPath: ($c$$src$Core$$Cons)("b", $c$$src$Core$$Nil),
  maybeModule: $c$$src$Maybe$$Nothing,
  name: "a",
}))), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] Nested record access", "a.b.c", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 5, $0);
}))(($c$$src$Compiler$Token$$Lowercase)(({
  attrPath: ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("c", $c$$src$Core$$Nil)),
  maybeModule: $c$$src$Maybe$$Nothing,
  name: "a",
}))), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$Lexer_Test$$numberLiterals = ($i$test$$Test$$Group)("Number literals", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("Percent", "10%", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 2, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(true, "10")), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), $c$$src$Core$$Nil));

const $u$$src$Compiler$Lexer_Test$$ops = ($i$test$$Test$$Group)("Operators", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] .. set Default", ".. []", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 3, $0);
}))(($c$$src$Compiler$Token$$Binop)(0, $u$$src$Compiler$CoreDefs$$textConcat)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(3, 4, $0);
}))(($c$$src$Compiler$Token$$SquareBracket)(0, $c$$src$Compiler$Token$$Open)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(4, 5, $0);
}))(($c$$src$Compiler$Token$$SquareBracket)(0, $c$$src$Compiler$Token$$Closed)), $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil));

const $u$$src$Compiler$Lexer_Test$$position = ($i$test$$Test$$Group)("Position", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] ops position", "blah <>", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("blah <>", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] ops position, with newline", "blah <>\n", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("blah <>", $c$$src$Core$$Nil))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$Lexer_Test$$recordLiterals = ($i$test$$Test$$Group)("Record literals", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("[reg] .shorthand should work on its own line", "x =\n  .b", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(3), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($c$$src$Compiler$Token$$Token)(6, 6, $c$$src$Compiler$Token$$BlockStart), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(6, 8, $0);
}))(($c$$src$Compiler$Token$$RecordShorthand)(({
  attrPath: $c$$src$Core$$Nil,
  name: "b",
}))), ($c$$src$Core$$Cons)(($c$$src$Compiler$Token$$Token)(8, 8, $c$$src$Compiler$Token$$BlockEnd), $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil));

const $u$$src$Compiler$Lexer_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $u$$src$Compiler$Lexer_Test$$textLiterals = ($i$test$$Test$$Group)("Text literals", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("Empty Text", "\"\"", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 0, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 2, $0);
}))(($c$$src$Compiler$Token$$TextLiteral)($c$$src$Compiler$Token$$SingleQuote, "")), $c$$src$Core$$Nil)), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("Followed by colon", "\"n\":\n", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 0, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 3, $0);
}))(($c$$src$Compiler$Token$$TextLiteral)($c$$src$Compiler$Token$$SingleQuote, "n")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(3, 4, $0);
}))($c$$src$Compiler$Token$$Colon), $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$valueTest)("Unindent function", ((_0) => {
  return ((($0) => {
    return ($u$$src$Compiler$Lexer$$unindent)($0);
  }))(((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(($c$$src$Core$$Cons)("\n", ($c$$src$Core$$Cons)("  a\n", ($c$$src$Core$$Cons)("      \n", ($c$$src$Core$$Cons)("\n", ($c$$src$Core$$Cons)("  b\n", ($c$$src$Core$$Cons)("  ", $c$$src$Core$$Nil))))))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Text$$join)("", ($c$$src$Core$$Cons)("a\n", ($c$$src$Core$$Cons)("    \n", ($c$$src$Core$$Cons)("\n", ($c$$src$Core$$Cons)("b", $c$$src$Core$$Nil))))))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$Lexer_Test$$unaryAddittiveOps = ($i$test$$Test$$Group)("Unary addittive ops", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("-a", "-a", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 1, $0);
}))(($c$$src$Compiler$Token$$Unop)($c$$src$Compiler$Op$$UnopMinus)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 2, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), $c$$src$Core$$Nil)), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("a - -a", "a - -a", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 1, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(2, 3, $0);
}))(($c$$src$Compiler$Token$$Binop)(0, $u$$src$Compiler$CoreDefs$$subtract)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(4, 5, $0);
}))(($c$$src$Compiler$Token$$Unop)($c$$src$Compiler$Op$$UnopMinus)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(5, 6, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("SKIP a-a", "a-a", $u$$src$Compiler$Lexer_Test$$lexTokens, ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 0, $0);
}))($c$$src$Compiler$Token$$NewSiblingLine), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 1, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(1, 2, $0);
}))(($c$$src$Compiler$Token$$Binop)(1, $u$$src$Compiler$CoreDefs$$subtract)), ($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(2, 3, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("a")), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("-=", "-=", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 2, $0);
}))(($c$$src$Compiler$Token$$Binop)(0, $u$$src$Compiler$CoreDefs$$mutableSubtract)), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))));

const $u$$src$Compiler$Lexer_Test$$underscores = ($i$test$$Test$$Group)("Underscores", ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("'_' as a Name", "_", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 1, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("_")), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("'_10_20' as a Name", "_10_20", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 6, $0);
}))(($u$$src$Compiler$Lexer_Test$$lowerName)("_10_20")), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Lexer_Test$$codeTest)("'10_20' as a Number", "10_20", ($u$$src$Compiler$Lexer_Test$$lexTokensAndDrop)(1), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(((($0) => {
  return ($c$$src$Compiler$Token$$Token)(0, 5, $0);
}))(($c$$src$Compiler$Token$$NumberLiteral)(false, "10_20")), $c$$src$Core$$Nil), $c$$src$Core$$Nil))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$Lexer_Test$$tests = ($i$test$$Test$$Group)("Lexer", ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$names, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$ops, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$unaryAddittiveOps, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$indentation, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$comments, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$underscores, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$position, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$textLiterals, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$numberLiterals, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$recordLiterals, $c$$src$Core$$Nil)))))))))));

const $u$$src$Compiler$MakeCanonical_Test$$codeTest = (($0, $1, $2, $3) => {
  return ($i$test$$Test$$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const $u$$src$Compiler$MakeCanonical_Test$$params = (($errorModule) => {
  return ({
    errorModule: $errorModule,
    resolvePars: (($pos) => {
      return $u$$src$Compiler$TestHelpers$$resolvePars;
    }),
    umr: $u$$src$Compiler$TestHelpers$$moduleUmr,
  });
});

const $u$$src$Compiler$MakeCanonical_Test$$textToModule = (($code) => {
  return ($u$$src$Compiler$TestHelpers$$resErrorToStrippedText)(((($0) => {
    return ($u$$src$Compiler$MakeCanonical$$textToCanonicalModule)(true, $0);
  }))(($u$$src$Compiler$MakeCanonical_Test$$params)(($u$$src$Compiler$TestHelpers$$errorModule)($code))));
});

const $u$$src$Compiler$MakeCanonical_Test$$firstDefinition = (($code) => {
  return (($c$$src$Result$$onOk)((($mod) => {
    return ((($0) => {
      return ($c$$src$Result$$fromMaybe)("firstDefinition fail", $0);
    }))(($c$$src$List$$head)(($c$$src$Dict$$values)($mod.valueDefs)));
  })))(($u$$src$Compiler$MakeCanonical_Test$$textToModule)($code));
});

const $u$$src$Compiler$MakeCanonical_Test$$firstEvaluation = (($name) => {
  return (($code) => {
    return (($c$$src$Result$$onOk)((($def) => {
      return ($c$$src$Maybe$$toResult)("body is 'nothing", $def.maybeBody);
    })))(($u$$src$Compiler$MakeCanonical_Test$$firstDefinition)($code));
  });
});

const $u$$src$Compiler$MakeCanonical_Test$$annotations = ($i$test$$Test$$Group)("Annotations", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("annotation on unique value", "x =\n  !a as Number =\n    3\n  a", $u$$src$Compiler$MakeCanonical_Test$$firstDefinition, $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("annotation on immutable value", "b as Number =\n  3", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("annotation of recycling function", "b as fn @List a: !List a =\n  3", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), $i$test$$Test$$isOk), $c$$src$Core$$Nil))));

const $u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps = (($0) => {
  return ((($0) => {
    return ($c$$src$Result$$map)((($v) => {
      const $0 = $v;
      return (Object.assign)({}, $0, ({
        directDeps: $c$$src$Dict$$empty,
      }));
    }), $0);
  }))(($u$$src$Compiler$MakeCanonical_Test$$firstDefinition)($0));
});

const $u$$src$Compiler$MakeCanonical_Test$$p = $c$$src$Compiler$Pos$$T;

const $u$$src$Compiler$MakeCanonical_Test$$argumentPlaceholders = ($i$test$$Test$$Group)("Argument placeholders", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Base", "f = f __ __", $u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps, ($i$test$$Test$$isOkAndEqualTo)(({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: $c$$src$Maybe$$Nothing,
  maybeBody: ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(0), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(1), $c$$src$Core$$Nil)), ($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefGlobal)(($u$$src$Compiler$TestHelpers$$moduleUsr)("f"))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(0))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(1))), $c$$src$Core$$Nil))))),
  name: "f",
  namePos: $u$$src$Compiler$MakeCanonical_Test$$p,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Pipelines work with placeholders", "f = __ >> a >> b", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("f"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(0), $c$$src$Core$$Nil), ($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefGlobal)(($u$$src$Compiler$TestHelpers$$moduleUsr)("b"))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefGlobal)(($u$$src$Compiler$TestHelpers$$moduleUsr)("a"))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(0))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("try..as", "f = try __ as \"\": 1", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("f"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(0), $c$$src$Core$$Nil), ($c$$src$Compiler$CanonicalAst$$Try)($u$$src$Compiler$MakeCanonical_Test$$p, ({
  patternsAndExpressions: ($c$$src$Core$$Cons)(({
    first: $c$$src$Compiler$Ast$$Imm,
    second: ($c$$src$Compiler$CanonicalAst$$PatternLiteralText)($u$$src$Compiler$MakeCanonical_Test$$p, ""),
    third: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1),
  }), $c$$src$Core$$Nil),
  value: ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(0)),
}))))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$MakeCanonical_Test$$shouldHaveSameAB = (($getter) => {
  return ($i$test$$Test$$freeform)((($2) => {
    const $a = $2.first;
    const $b = $2.second;
    return ((sp_equal)(($getter)($a), ($getter)($b))
      ? $c$$src$Maybe$$Nothing
      : ($c$$src$Maybe$$Just)(((($0) => {
        return ($c$$src$Text$$join)("\n", $0);
      }))(($c$$src$Core$$Cons)("The two don't match:", ($c$$src$Core$$Cons)((sp_toHuman)(($getter)($a)), ($c$$src$Core$$Cons)((sp_toHuman)(($getter)($b)), $c$$src$Core$$Nil))))));
  }));
});

const $u$$src$Compiler$MakeCanonical_Test$$transformAB = (($code) => {
  const $findAB = (($mod) => {
    const $3 = ((($0) => {
      return (list_sortBy)((($def) => {
        return $def.pattern;
      }), $0);
    }))(($c$$src$Dict$$values)($mod.valueDefs));
    return (((($3)[0] === "$Cons") && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil")))
      ? ((() => {
        const $a = ($3)[1];
        const $b = (($3)[2])[1];
        return ($c$$src$Maybe$$Just)(({
          first: $a,
          second: $b,
        }));
      }))()
      : (true
        ? $c$$src$Maybe$$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical_Test.sp 81:8', (sp_toHuman)($3))));
  });
  return (($c$$src$Result$$onOk)((($x) => {
    return ((($0) => {
      return ($c$$src$Result$$fromMaybe)("findAB fail", $0);
    }))(($findAB)($x));
  })))(($u$$src$Compiler$MakeCanonical_Test$$textToModule)($code));
});

const $u$$src$Compiler$MakeCanonical_Test$$binops = ($i$test$$Test$$Group)("Binops", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("left associativity", "a = v >> f >> g\nb = (v >> f) >> g", $u$$src$Compiler$MakeCanonical_Test$$transformAB, ($u$$src$Compiler$MakeCanonical_Test$$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("right associativity", "a = v :: f :: g\nb = v :: (f :: g)", $u$$src$Compiler$MakeCanonical_Test$$transformAB, ($u$$src$Compiler$MakeCanonical_Test$$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("precedence", "a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4", $u$$src$Compiler$MakeCanonical_Test$$transformAB, ($u$$src$Compiler$MakeCanonical_Test$$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("SKIP (burned out) Pipe optimization 1", "a = b >> a __\nb = a b", $u$$src$Compiler$MakeCanonical_Test$$transformAB, ($u$$src$Compiler$MakeCanonical_Test$$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("SKIP (burned out) Pipe optimization 2", "a = (__ >> __ >> __) a b c\nb = a >> b >> c", $u$$src$Compiler$MakeCanonical_Test$$transformAB, ($u$$src$Compiler$MakeCanonical_Test$$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Op chain definition and optimization", "a = __ + __ + 3 + __", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(0), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(1), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPlaceholder)(2), $c$$src$Core$$Nil))), ($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefGlobal)($u$$src$Compiler$CoreDefs$$add.usr)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(0))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefGlobal)($u$$src$Compiler$CoreDefs$$add.usr)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(1))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefGlobal)($u$$src$Compiler$CoreDefs$$add.usr)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 3)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefPlaceholder)(2))), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))))), $c$$src$Core$$Nil)))))));

const $u$$src$Compiler$TestHelpers$$rootLocal = (($name) => {
  return ($c$$src$Compiler$Ast$$RefGlobal)(($c$$src$Compiler$Meta$$USR)($u$$src$Compiler$TestHelpers$$moduleUmr, $name));
});

const $u$$src$Compiler$MakeCanonical_Test$$functions = ($i$test$$Test$$Group)("Functions", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("[rec] function with call", "a =\n    fn x:\n        add x 1", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("f"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPattern)($c$$src$Compiler$Ast$$Imm, ($c$$src$Compiler$CanonicalAst$$PatternAny)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)("x"), $c$$src$Maybe$$Nothing)), $c$$src$Core$$Nil), ($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("add")), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefLocal)("x"))), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1)), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("[rec] function with two arguments", "f =\n  fn a, b: 1", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("f"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPattern)($c$$src$Compiler$Ast$$Imm, ($c$$src$Compiler$CanonicalAst$$PatternAny)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)("a"), $c$$src$Maybe$$Nothing)), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPattern)($c$$src$Compiler$Ast$$Imm, ($c$$src$Compiler$CanonicalAst$$PatternAny)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)("b"), $c$$src$Maybe$$Nothing)), $c$$src$Core$$Nil)), ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1)))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$TestHelpers$$caBool = ($c$$src$Compiler$CanonicalAst$$TypeNamed)($c$$src$Compiler$Pos$$T, ($u$$src$Compiler$CoreDefs$$usr)("Bool"), $c$$src$Core$$Nil);

const $u$$src$Compiler$MakeCanonical_Test$$lists = ($i$test$$Test$$Group)("Lists", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("list type sugar", "l as [ Bool ] =\n  l", $u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps, ($i$test$$Test$$isOkAndEqualTo)(({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: ($c$$src$Maybe$$Just)(({
    raw: ($u$$src$Compiler$CoreDefs$$listType)($u$$src$Compiler$TestHelpers$$caBool),
    tyvars: $c$$src$Dict$$empty,
    univars: $c$$src$Dict$$empty,
  })),
  maybeBody: ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("l"))),
  name: "l",
  namePos: $u$$src$Compiler$MakeCanonical_Test$$p,
}))), $c$$src$Core$$Nil));

const $u$$src$Compiler$MakeCanonical_Test$$localDef = (($name, $body) => {
  return ({
    body: $body,
    pattern: ($c$$src$Compiler$CanonicalAst$$PatternAny)($c$$src$Compiler$Pos$$G, ($c$$src$Maybe$$Just)($name), $c$$src$Maybe$$Nothing),
    uni: $c$$src$Compiler$Ast$$Imm,
  });
});

const $u$$src$Compiler$MakeCanonical_Test$$moduleAndAttributePaths = ((() => {
  const $accept = (($s) => {
    return ($u$$src$Compiler$MakeCanonical_Test$$codeTest)($s, ("a = " + $s), $u$$src$Compiler$MakeCanonical_Test$$firstDefinition, $i$test$$Test$$isOk);
  });
  const $reject = (($s, $m) => {
    return ($u$$src$Compiler$MakeCanonical_Test$$codeTest)($s, ("a = " + $s), $u$$src$Compiler$MakeCanonical_Test$$firstDefinition, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)($m, $c$$src$Core$$Nil)));
  });
  return ($i$test$$Test$$Group)("Module and Attribute Paths", ($c$$src$Core$$Cons)(($accept)("blah.blah.blah"), ($c$$src$Core$$Cons)(($reject)("Blah.Blah.blah", "attribute"), ($c$$src$Core$$Cons)(($reject)("List.blah.Blah", "lower"), ($c$$src$Core$$Cons)(($reject)("List..blah", "space"), ($c$$src$Core$$Cons)(($reject)(".Blah", "must start with a lowercase"), ($c$$src$Core$$Cons)(($reject)(".blah.blah", "shorthand"), ($c$$src$Core$$Cons)(($reject)(".blah", "shorthand"), ($c$$src$Core$$Cons)(($reject)("...", ""), ($c$$src$Core$$Cons)(($accept)("x .. y"), $c$$src$Core$$Nil))))))))));
}))();

const $u$$src$Compiler$MakeCanonical_Test$$nonFunction = ($i$test$$Test$$Group)("NonFunction", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("one", "funz as a with a NonFunction =\n    1", $u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps, ($i$test$$Test$$isOkAndEqualTo)(({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: ($c$$src$Maybe$$Just)(({
    raw: ($c$$src$Compiler$CanonicalAst$$TypeAnnotationVariable)($u$$src$Compiler$MakeCanonical_Test$$p, "a"),
    tyvars: ($c$$src$Dict$$ofOne)("a", ({
      nonFn: ($c$$src$Maybe$$Just)($c$$src$Compiler$Pos$$T),
    })),
    univars: $c$$src$Dict$$empty,
  })),
  maybeBody: ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1)),
  name: "funz",
  namePos: $u$$src$Compiler$MakeCanonical_Test$$p,
}))), $c$$src$Core$$Nil));

const $u$$src$Compiler$MakeCanonical_Test$$numbers = ($i$test$$Test$$Group)("Numbers", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Percent", "a = 1%", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 0.01))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Underscore", "a = 1_000_000", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, (1000 * 1000)))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$MakeCanonical_Test$$patterns = ($i$test$$Test$$Group)("Patterns", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Record patterns can be partial", "a =\n  { with c } = d", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("[reg] record patterns are NOT extensible", "a =\n  { b with c } = d", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("extend pattern", $c$$src$Core$$Nil))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$MakeCanonical_Test$$pipes = ($i$test$$Test$$Group)("Pipes", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("sendLeft is inlined", "a = thing >> function", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("function")), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("thing"))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("sendRight is inlined", "a = function << thing", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Call)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("function")), ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ArgumentExpression)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("thing"))), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$MakeCanonical_Test$$polymorphicUniques = ($i$test$$Test$$Group)("Polymorphic Uniques", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("In pattern", "f =\n    fn 1?a:\n    1?b = a\n    b", $u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps, ($i$test$$Test$$isOkAndEqualTo)(({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: $c$$src$Maybe$$Nothing,
  maybeBody: ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$Fn)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Core$$Cons)(($c$$src$Compiler$CanonicalAst$$ParameterPattern)(($c$$src$Compiler$Ast$$Depends)(1), ($c$$src$Compiler$CanonicalAst$$PatternAny)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)("a"), $c$$src$Maybe$$Nothing)), $c$$src$Core$$Nil), ($c$$src$Compiler$CanonicalAst$$LetIn)(({
    body: ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefLocal)("a")),
    pattern: ($c$$src$Compiler$CanonicalAst$$PatternAny)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)("b"), $c$$src$Maybe$$Nothing),
    uni: ($c$$src$Compiler$Ast$$Depends)(1),
  }), ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Compiler$Ast$$RefLocal)("b"))))),
  name: "f",
  namePos: $u$$src$Compiler$MakeCanonical_Test$$p,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("In annotation", "isOk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = meh", (($t) => {
  return (($c$$src$Result$$onOk)((($def) => {
    const $3 = $def.maybeAnnotation;
    return ((($3)[0] === "$Just")
      ? ((() => {
        const $ann = ($3)[1];
        return ($c$$src$Result$$Ok)($ann.univars);
      }))()
      : (true
        ? ($c$$src$Result$$Err)("no ann")
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical_Test.sp 782:17', (sp_toHuman)($3))));
  })))(($u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps)($t));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Set$$fromList)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, $c$$src$Core$$Nil))))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$MakeCanonical_Test$$records = ($i$test$$Test$$Group)("Records", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("functional update", "a = { m with b, c = 1 }", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$LetIn)(($u$$src$Compiler$MakeCanonical_Test$$localDef)("0", ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("m"))), ($c$$src$Compiler$CanonicalAst$$Record)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$Variable)($c$$src$Compiler$Pos$$G, ($c$$src$Compiler$Ast$$RefLocal)("0"))), ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
  first: "c",
  second: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1),
}), ($c$$src$Core$$Cons)(({
  first: "b",
  second: ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("b")),
}), $c$$src$Core$$Nil))))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Update shorthand", "b = { a with y = .x }", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$LetIn)(($u$$src$Compiler$MakeCanonical_Test$$localDef)("0", ($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("a"))), ($c$$src$Compiler$CanonicalAst$$Record)($u$$src$Compiler$MakeCanonical_Test$$p, ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$Variable)($c$$src$Compiler$Pos$$G, ($c$$src$Compiler$Ast$$RefLocal)("0"))), ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
  first: "y",
  second: ($c$$src$Compiler$CanonicalAst$$RecordAccess)($u$$src$Compiler$MakeCanonical_Test$$p, "x", ($c$$src$Compiler$CanonicalAst$$Variable)($c$$src$Compiler$Pos$$G, ($c$$src$Compiler$Ast$$RefLocal)("0"))),
}), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("annotation, extensible", "a as { b with x as Bool } =\n  a", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("disabled", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$MakeCanonical_Test$$shadowing = ($i$test$$Test$$Group)("Shadowing", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Root", "a = 0\na = 0", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("`a`", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Local", "a = 0\nb =\n    a = 0\n    a + a", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("`a`", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Function parameter", "a = 0\nb = fn a: a + a", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("`a`", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("try..as", "a = 0\nb = try x as\n     a: 0", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("`a`", ($c$$src$Core$$Cons)("already been defined", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Types", "var X = 'meh\nX = {}\nb = 0", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("X", ($c$$src$Core$$Cons)("twice", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Constructors", "var A = 'meh\nvar B = 'meh\nb = 0", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("b"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("meh", ($c$$src$Core$$Cons)("already been defined", $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))))));

const $u$$src$Compiler$MakeCanonical_Test$$tuples = ($i$test$$Test$$Group)("Tuples", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("tuple2", "a = 1 & 2", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Record)($u$$src$Compiler$MakeCanonical_Test$$p, $c$$src$Maybe$$Nothing, ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
  first: "first",
  second: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1),
}), ($c$$src$Core$$Cons)(({
  first: "second",
  second: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 2),
}), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("tuple3", "a = 1 & 2 & 3", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Compiler$CanonicalAst$$Record)($u$$src$Compiler$MakeCanonical_Test$$p, $c$$src$Maybe$$Nothing, ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
  first: "first",
  second: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 1),
}), ($c$$src$Core$$Cons)(({
  first: "second",
  second: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 2),
}), ($c$$src$Core$$Cons)(({
  first: "third",
  second: ($c$$src$Compiler$CanonicalAst$$LiteralNumber)($u$$src$Compiler$MakeCanonical_Test$$p, 3),
}), $c$$src$Core$$Nil))))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("tuple4", "a = 1 & 2 & 3 & 4", ($u$$src$Compiler$MakeCanonical_Test$$firstEvaluation)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("use a record", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Tuple2 type", "a as Number & Number =\n  a", $u$$src$Compiler$MakeCanonical_Test$$firstDefinitionStripDeps, ($i$test$$Test$$isOkAndEqualTo)(({
  directDeps: $c$$src$Dict$$empty,
  maybeAnnotation: ($c$$src$Maybe$$Just)(({
    raw: ((($0) => {
      return ($c$$src$Compiler$CanonicalAst$$TypeRecord)($u$$src$Compiler$MakeCanonical_Test$$p, $0);
    }))(((($0) => {
      return ($c$$src$Dict$$insert)("second", $u$$src$Compiler$TestHelpers$$caNumber, $0);
    }))(((($0) => {
      return ($c$$src$Dict$$insert)("first", $u$$src$Compiler$TestHelpers$$caNumber, $0);
    }))($c$$src$Dict$$empty))),
    tyvars: $c$$src$Dict$$empty,
    univars: $c$$src$Dict$$empty,
  })),
  maybeBody: ($c$$src$Maybe$$Just)(($c$$src$Compiler$CanonicalAst$$Variable)($u$$src$Compiler$MakeCanonical_Test$$p, ($u$$src$Compiler$TestHelpers$$rootLocal)("a"))),
  name: "a",
  namePos: $u$$src$Compiler$MakeCanonical_Test$$p,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("tuple4, type", "a as Blah & Blah & Blah & Blah =\n  a", $u$$src$Compiler$MakeCanonical_Test$$firstDefinition, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("use a record", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))))));

const $u$$src$Compiler$MakeCanonical_Test$$varTypes = ($i$test$$Test$$Group)("Variant types", ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Tuples op precedence", "var A = 'x Bool & Bool", $u$$src$Compiler$MakeCanonical_Test$$textToModule, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("I need a 'constructor", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("Tuples op precedence works with parens", "var A = 'x (Bool & Bool)", $u$$src$Compiler$MakeCanonical_Test$$textToModule, $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$MakeCanonical_Test$$codeTest)("SKIP (make `var` a keyword?) [reg] Should reject uppercase arg name", "var Outcome Token output = 'a", $u$$src$Compiler$MakeCanonical_Test$$textToModule, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("must start with a lowercase", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$MakeCanonical_Test$$tests = ($i$test$$Test$$Group)("MakeCanonical", ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$varTypes, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$binops, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$tuples, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$lists, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$moduleAndAttributePaths, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$records, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$patterns, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$annotations, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$pipes, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$functions, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$nonFunction, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$argumentPlaceholders, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$polymorphicUniques, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$numbers, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$shadowing, $c$$src$Core$$Nil))))))))))))))));

const $u$$src$Compiler$Parser_Test$$e = (($0) => {
  return ($c$$src$Compiler$FormattableAst$$Expression)($c$$src$Core$$Nil, $c$$src$Compiler$Pos$$T, $0);
});

const $u$$src$Compiler$Parser_Test$$annotatedVariable = (($name, $type) => {
  return ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Lowercase)(({
    attrPath: $c$$src$Core$$Nil,
    maybeModule: $c$$src$Maybe$$Nothing,
    maybeType: ($c$$src$Maybe$$Just)($type),
    name: $name,
  })));
});

const $u$$src$Compiler$Parser_Test$$codeTest = (($0, $1, $2, $3) => {
  return ($i$test$$Test$$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const $u$$src$Compiler$Parser_Test$$asDefinition = (($s) => {
  return ((($s)[0] === "$ValueDef")
    ? ((() => {
      const $a = ($s)[1];
      return ($c$$src$Result$$Ok)($a);
    }))()
    : (true
      ? ($c$$src$Result$$Err)("Test says: no def")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 32:4', (sp_toHuman)($s))));
});

const $u$$src$Compiler$Parser_Test$$firstStatement = (($code) => {
  const $grabFirst = (($stats) => {
    return ((($stats)[0] === "$Nil")
      ? ($c$$src$Result$$Err)("Test says: no statements")
      : ((($stats)[0] === "$Cons")
        ? ((() => {
          const $head = ($stats)[1];
          const $tail = ($stats)[2];
          return ($c$$src$Result$$Ok)($head);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 48:8', (sp_toHuman)($stats))));
  });
  return (($c$$src$Result$$onOk)($grabFirst))(($u$$src$Compiler$TestHelpers$$resErrorToStrippedText)(($u$$src$Compiler$Parser$$textToFormattableModule)(({
    errorModule: ({
      content: $code,
      fsPath: "Test",
    }),
    keepComments: true,
    stripLocations: true,
  }))));
});

const $u$$src$Compiler$Parser_Test$$firstDefinition = (($code) => {
  return (($c$$src$Result$$onOk)($u$$src$Compiler$Parser_Test$$asDefinition))(($u$$src$Compiler$Parser_Test$$firstStatement)($code));
});

const $u$$src$Compiler$Parser_Test$$lowercase = (($name) => {
  return ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Lowercase)(({
    attrPath: $c$$src$Core$$Nil,
    maybeModule: $c$$src$Maybe$$Nothing,
    maybeType: $c$$src$Maybe$$Nothing,
    name: $name,
  })));
});

const $u$$src$Compiler$Parser_Test$$faBinop = (($op) => {
  return ({
    comments: $c$$src$Core$$Nil,
    line: -(1),
    pos: $c$$src$Compiler$Pos$$T,
    precedence: $op.precedence,
    symbol: $op.symbol,
    usr: $op.usr,
  });
});

const $u$$src$Compiler$Parser_Test$$tuple = (($a, $b) => {
  return ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$BinopChain)($c$$src$Compiler$Op$$precedence_tuple, ({
    first: $a,
    second: ($c$$src$Core$$Cons)(({
      first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$tuple),
      second: $b,
    }), $c$$src$Core$$Nil),
  })));
});

const $u$$src$Compiler$Parser_Test$$annotations = ($i$test$$Test$$Group)("Annotations", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Trivial case", "a as b =\n    z", $u$$src$Compiler$Parser_Test$$firstDefinition, ($i$test$$Test$$isOkAndEqualTo)(({
  body: ($u$$src$Compiler$Parser_Test$$lowercase)("z"),
  nonFn: $c$$src$Core$$Nil,
  pattern: ($u$$src$Compiler$Parser_Test$$annotatedVariable)("a", ($u$$src$Compiler$Parser_Test$$lowercase)("b")),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Tuple precedence", "a as fn int & int: bool =\n    b", $u$$src$Compiler$Parser_Test$$firstDefinition, ($i$test$$Test$$isOkAndEqualTo)(({
  body: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
  nonFn: $c$$src$Core$$Nil,
  pattern: ($u$$src$Compiler$Parser_Test$$annotatedVariable)("a", ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Inline, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$tuple)(($u$$src$Compiler$Parser_Test$$lowercase)("int"), ($u$$src$Compiler$Parser_Test$$lowercase)("int")), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$lowercase)("bool")))),
}))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$Parser_Test$$asEvaluation = (($s) => {
  return ((($s)[0] === "$Evaluation")
    ? ((() => {
      const $a = ($s)[1];
      return ($c$$src$Result$$Ok)($a);
    }))()
    : (true
      ? ($c$$src$Result$$Err)("Test says: no eval")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 39:4', (sp_toHuman)($s))));
});

const $u$$src$Compiler$Parser_Test$$firstEvaluation = (($code) => {
  return (($c$$src$Result$$onOk)($u$$src$Compiler$Parser_Test$$asEvaluation))(($u$$src$Compiler$Parser_Test$$firstStatement)($code));
});

const $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition = (($code) => {
  return (($c$$src$Result$$onOk)((($def) => {
    return ($c$$src$Result$$Ok)($def.body);
  })))((($c$$src$Result$$onOk)($u$$src$Compiler$Parser_Test$$asDefinition))(($u$$src$Compiler$Parser_Test$$firstStatement)($code)));
});

const $u$$src$Compiler$Parser_Test$$binops = ((() => {
  const $sendBtoC = ($u$$src$Compiler$Parser_Test$$e)(((($0) => {
    return ($c$$src$Compiler$FormattableAst$$BinopChain)($c$$src$Compiler$Op$$precedence_pipe, $0);
  }))(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
    second: ($c$$src$Core$$Cons)(({
      first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$sendRight),
      second: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
    }), $c$$src$Core$$Nil),
  })));
  const $sendBtoCtoD = ($u$$src$Compiler$Parser_Test$$e)(((($0) => {
    return ($c$$src$Compiler$FormattableAst$$BinopChain)($c$$src$Compiler$Op$$precedence_pipe, $0);
  }))(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
    second: ($c$$src$Core$$Cons)(({
      first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$sendRight),
      second: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
    }), ($c$$src$Core$$Cons)(({
      first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$sendRight),
      second: ($u$$src$Compiler$Parser_Test$$lowercase)("d"),
    }), $c$$src$Core$$Nil)),
  })));
  return ($i$test$$Test$$Group)("Binops", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("no indent", "b >> c", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)($sendBtoC)), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("pipe indent 1", "b\n  >> c", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)($sendBtoC)), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("pipe indent 2", "b\n  >> c\n  >> d", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)($sendBtoCtoD)), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("pyramid indent", "b\n  >> c\n    >> d", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)($sendBtoCtoD)), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("no indent", "x =\n    b\n    >>\n    c", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)($sendBtoC)), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("SKIP (I'm tired) Starting", "x = >> c", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("TODO", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("SKIP (I'm tired) Double", "x = a >> >> c", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("TODO", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("SKIP (I'm tired) Ending", "x = a >>", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("TODO", $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))))))));
}))();

const $u$$src$Compiler$Parser_Test$$comments = ($i$test$$Test$$Group)("Comments", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] trailing", "a =\n  b\n  # c", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), $c$$src$Core$$Nil));

const $u$$src$Compiler$Parser_Test$$constructor = (($name) => {
  return ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Constructor)(({
    maybeModule: $c$$src$Maybe$$Nothing,
    name: $name,
  })));
});

const $u$$src$Compiler$Parser_Test$$functions = ($i$test$$Test$$Group)("functions", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Inline body", "fn a, b: 3", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Inline, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), $c$$src$Core$$Nil)), ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$LiteralNumber)(false, "3")))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Indented body", "fn a:\n    3", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Indented, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$LiteralNumber)(false, "3")))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Sibling nesting", "z =\n  fn a:\n  fn b:\n  3", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Aligned, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Aligned, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$LiteralNumber)(false, "3")))))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Tuple vs lambda precedence", "fn a & b: a", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Inline, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$tuple)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), ($u$$src$Compiler$Parser_Test$$lowercase)("b")), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$lowercase)("a"))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] Pass to function without parens", "xxx fn y: y", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("xxx"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Inline, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("y"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$lowercase)("y"))), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Pass to function without parens, below", "z =\n  xxx fn y:\n  y", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("xxx"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Aligned, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("y"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$lowercase)("y"))), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("SKIP Function should not swallow pipeline", "value\n>> map fn x: blah\n>> sblorp", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(((($0) => {
  return ($c$$src$Compiler$FormattableAst$$BinopChain)($c$$src$Compiler$Op$$precedence_pipe, $0);
}))(({
  first: ($u$$src$Compiler$Parser_Test$$lowercase)("value"),
  second: ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$sendRight),
    second: ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("map"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Aligned, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("x"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$lowercase)("blah"))), $c$$src$Core$$Nil))),
  }), ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$sendRight),
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("sblorp"),
  }), $c$$src$Core$$Nil)),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] Fn with multiple indented statements", "fn x:\n  x\n  x", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Indented, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("x"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Statements)(($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$Evaluation)(($u$$src$Compiler$Parser_Test$$lowercase)("x")), ($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$Evaluation)(($u$$src$Compiler$Parser_Test$$lowercase)("x")), $c$$src$Core$$Nil)))))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] Fn with definition", "a =\n    fn x:\n    y = 1\n    x", $u$$src$Compiler$Parser_Test$$firstDefinition, ($i$test$$Test$$isOkAndEqualTo)(({
  body: ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Aligned, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("x"), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Statements)(($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$ValueDef)(({
    body: ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$LiteralNumber)(false, "1")),
    nonFn: $c$$src$Core$$Nil,
    pattern: ($u$$src$Compiler$Parser_Test$$lowercase)("y"),
  })), ($c$$src$Core$$Cons)(($c$$src$Compiler$FormattableAst$$Evaluation)(($u$$src$Compiler$Parser_Test$$lowercase)("x")), $c$$src$Core$$Nil)))))),
  nonFn: $c$$src$Core$$Nil,
  pattern: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] argument not being recognized?", "@b += 1", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(((($0) => {
  return ($c$$src$Compiler$FormattableAst$$BinopChain)($c$$src$Compiler$Op$$precedence_mutop, $0);
}))(({
  first: ($u$$src$Compiler$Parser_Test$$e)(((($0) => {
    return ($c$$src$Compiler$FormattableAst$$UnopCall)($c$$src$Compiler$Op$$UnopRecycle, $0);
  }))(($u$$src$Compiler$Parser_Test$$lowercase)("b"))),
  second: ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$faBinop)($u$$src$Compiler$CoreDefs$$mutableAdd),
    second: ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$LiteralNumber)(false, "1")),
  }), $c$$src$Core$$Nil),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] multiple lines, compact", "x =\n    a = pop a\n    b = 1", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), $c$$src$Core$$Nil))))))))))));

const $u$$src$Compiler$Parser_Test$$ifs = ($i$test$$Test$$Group)("Ifs", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Inline", "if a then b else c", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$If)(({
  condition: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
  false: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
  isMultiline: false,
  true: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Multiline, formatted", "z =\n  if a then\n      b\n  else\n      c", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$If)(({
  condition: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
  false: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
  isMultiline: true,
  true: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Multiline, compact", "z =\n  if a then b\n  else c", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$If)(({
  condition: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
  false: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
  isMultiline: true,
  true: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}))))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$Parser_Test$$lists = ($i$test$$Test$$Group)("Lists", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Empty", "[]", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(false, $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Inline", "[a, b]", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(false, ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}), ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Multiline", "z =\n  [\n  , a\n  , b\n  ]", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(true, ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}), ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}), $c$$src$Core$$Nil)))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Ancient egyptian", "z =\n  blah [\n  , a\n  , b\n  ]", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("blah"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(true, ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}), ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Dots", "[a..., b, c...]", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(false, ($c$$src$Core$$Cons)(({
  first: true,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}), ($c$$src$Core$$Cons)(({
  first: false,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
}), ($c$$src$Core$$Cons)(({
  first: true,
  second: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
}), $c$$src$Core$$Nil))))))), $c$$src$Core$$Nil))))));

const $u$$src$Compiler$Parser_Test$$parens = ($i$test$$Test$$Group)("Parens", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Can exist on multiple lines even when useless", "tests =\n    (Ok\n    )", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Can exist on multiple lines", "tests =\n    blah\n        (Ok\n        )", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), $c$$src$Core$$Nil)));

const $u$$src$Compiler$Parser_Test$$uppercase = (($name) => {
  return ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Uppercase)(({
    maybeModule: $c$$src$Maybe$$Nothing,
    name: $name,
  })));
});

const $u$$src$Compiler$Parser_Test$$patterns = ($i$test$$Test$$Group)("Patterns", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("List unpacking", "[a as Int, b] = x", $u$$src$Compiler$Parser_Test$$firstDefinition, ($i$test$$Test$$isOkAndEqualTo)(({
  body: ($u$$src$Compiler$Parser_Test$$lowercase)("x"),
  nonFn: $c$$src$Core$$Nil,
  pattern: ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(false, ($c$$src$Core$$Cons)(({
    first: false,
    second: ($u$$src$Compiler$Parser_Test$$annotatedVariable)("a", ($u$$src$Compiler$Parser_Test$$uppercase)("Int")),
  }), ($c$$src$Core$$Cons)(({
    first: false,
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
  }), $c$$src$Core$$Nil)))),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Record argument unpacking", "fn { with a, b }:\n  x", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Fn)($c$$src$Compiler$FormattableAst$$Indented, ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: $c$$src$Maybe$$Nothing,
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
  }), ($c$$src$Core$$Cons)(({
    maybeExpr: $c$$src$Maybe$$Nothing,
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
  }), $c$$src$Core$$Nil)),
  isMultiline: false,
  maybeExtension: ($c$$src$Maybe$$Just)($c$$src$Maybe$$Nothing),
}))), $c$$src$Core$$Nil), ($u$$src$Compiler$Parser_Test$$lowercase)("x"))))), $c$$src$Core$$Nil)));

const $u$$src$Compiler$Parser_Test$$records = ($i$test$$Test$$Group)("Records", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Empty", "{}", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: $c$$src$Core$$Nil,
  isMultiline: false,
  maybeExtension: $c$$src$Maybe$$Nothing,
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Inline", "{ x = b }", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("b")),
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("x"),
  }), $c$$src$Core$$Nil),
  isMultiline: false,
  maybeExtension: $c$$src$Maybe$$Nothing,
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Multiline", "z =\n  {\n  , x = a\n  , y = b\n  }", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("a")),
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("x"),
  }), ($c$$src$Core$$Cons)(({
    maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("b")),
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("y"),
  }), $c$$src$Core$$Nil)),
  isMultiline: true,
  maybeExtension: $c$$src$Maybe$$Nothing,
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Pattern extension", "z =\n  { with\n  , x = a\n  }", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("a")),
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("x"),
  }), $c$$src$Core$$Nil),
  isMultiline: true,
  maybeExtension: ($c$$src$Maybe$$Just)($c$$src$Maybe$$Nothing),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Expression extension", "q =\n  { z with\n  , x = a\n  }", $u$$src$Compiler$Parser_Test$$firstEvaluationOfDefinition, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("a")),
    name: ($u$$src$Compiler$Parser_Test$$lowercase)("x"),
  }), $c$$src$Core$$Nil),
  isMultiline: true,
  maybeExtension: ($c$$src$Maybe$$Just)(($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("z"))),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Type or annotated implicit value", "{ x as Bool }", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: $c$$src$Maybe$$Nothing,
    name: ($u$$src$Compiler$Parser_Test$$annotatedVariable)("x", ($u$$src$Compiler$Parser_Test$$uppercase)("Bool")),
  }), $c$$src$Core$$Nil),
  isMultiline: false,
  maybeExtension: $c$$src$Maybe$$Nothing,
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Type or annotated explicit value", "{ x as Bool = y }", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Record)(({
  attrs: ($c$$src$Core$$Cons)(({
    maybeExpr: ($c$$src$Maybe$$Just)(($u$$src$Compiler$Parser_Test$$lowercase)("y")),
    name: ($u$$src$Compiler$Parser_Test$$annotatedVariable)("x", ($u$$src$Compiler$Parser_Test$$uppercase)("Bool")),
  }), $c$$src$Core$$Nil),
  isMultiline: false,
  maybeExtension: $c$$src$Maybe$$Nothing,
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] real-world use", "a =\n  { state with\n      , pos = endPos\n      , code = rest\n      , accum =\n          [\n          , { kind = Token.Comment\n            , start = startPos\n            , end = endPos\n            }\n          , state.accum...\n          ]\n  }", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), $c$$src$Core$$Nil)))))))));

const $u$$src$Compiler$Parser_Test$$tries = ($i$test$$Test$$Group)("Try", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Multiline, formatted", "try a as\n   b:\n    c\n   d:\n    e", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Try)(({
  patterns: ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
  }), ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("d"),
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("e"),
  }), $c$$src$Core$$Nil)),
  value: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Multiline, compact", "try a as\n   b: c\n   d: e", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Try)(({
  patterns: ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
  }), ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("d"),
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("e"),
  }), $c$$src$Core$$Nil)),
  value: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Nested", "try a as\n   b:\n    try c as\n         q:\n            q\n   d:\n    e", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Try)(({
  patterns: ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("b"),
    second: ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Try)(({
      patterns: ($c$$src$Core$$Cons)(({
        first: ($u$$src$Compiler$Parser_Test$$lowercase)("q"),
        second: ($u$$src$Compiler$Parser_Test$$lowercase)("q"),
      }), $c$$src$Core$$Nil),
      value: ($u$$src$Compiler$Parser_Test$$lowercase)("c"),
    }))),
  }), ($c$$src$Core$$Cons)(({
    first: ($u$$src$Compiler$Parser_Test$$lowercase)("d"),
    second: ($u$$src$Compiler$Parser_Test$$lowercase)("e"),
  }), $c$$src$Core$$Nil)),
  value: ($u$$src$Compiler$Parser_Test$$lowercase)("a"),
}))))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$Parser_Test$$word = (($name) => {
  return ({
    first: $c$$src$Compiler$Pos$$T,
    second: $name,
  });
});

const $u$$src$Compiler$Parser_Test$$unionDefs = ((() => {
  const $asTypeDef = (($s) => {
    return ((($s)[0] === "$UnionDef")
      ? ((() => {
        const $a = ($s)[1];
        return ($c$$src$Result$$Ok)($a);
      }))()
      : (true
        ? ($c$$src$Result$$Err)("no type def")
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 442:8', (sp_toHuman)($s))));
  });
  const $firstTypeDef = (($x) => {
    return (($c$$src$Result$$onOk)($asTypeDef))(($u$$src$Compiler$Parser_Test$$firstStatement)($x));
  });
  return ($i$test$$Test$$Group)("Type Definitions", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Parse inline def", "var A b c = 'v1 b, 'v2 c, 'v3, 'v4 b c", $firstTypeDef, ($i$test$$Test$$isOkAndEqualTo)(({
    args: ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$word)("b"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$word)("c"), $c$$src$Core$$Nil)),
    constructors: ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'v1"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'v2"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("c"), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$constructor)("'v3"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'v4"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("c"), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))),
    name: ($u$$src$Compiler$Parser_Test$$word)("A"),
  }))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Parse multiline def", "var A b c =\n    , 'v1 b\n    , 'v2 c\n    , 'v3\n    , 'v4 b c", $firstTypeDef, ($i$test$$Test$$isOkAndEqualTo)(({
    args: ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$word)("b"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$word)("c"), $c$$src$Core$$Nil)),
    constructors: ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'v1"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'v2"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("c"), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$constructor)("'v3"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'v4"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("c"), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))),
    name: ($u$$src$Compiler$Parser_Test$$word)("A"),
  }))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("List argument", "var A = 'a [Int]", $firstTypeDef, ($i$test$$Test$$isOkAndEqualTo)(({
    args: $c$$src$Core$$Nil,
    constructors: ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$constructor)("'a"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$List)(false, ($c$$src$Core$$Cons)(({
      first: false,
      second: ($u$$src$Compiler$Parser_Test$$uppercase)("Int"),
    }), $c$$src$Core$$Nil))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil),
    name: ($u$$src$Compiler$Parser_Test$$word)("A"),
  }))), $c$$src$Core$$Nil))));
}))();

const $u$$src$Compiler$Parser_Test$$unops = ($i$test$$Test$$Group)("Unops", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] Unop", "a = f -n", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Precedence 1", "-a b", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$UnopCall)($c$$src$Compiler$Op$$UnopMinus, ($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("b"), $c$$src$Core$$Nil))))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Precedence 2", "a -b", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$UnopCall)($c$$src$Compiler$Op$$UnopMinus, ($u$$src$Compiler$Parser_Test$$lowercase)("b"))), $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("Precedence 3", "a -b c", $u$$src$Compiler$Parser_Test$$firstEvaluation, ($i$test$$Test$$isOkAndEqualTo)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$Call)(($u$$src$Compiler$Parser_Test$$lowercase)("a"), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$e)(($c$$src$Compiler$FormattableAst$$UnopCall)($c$$src$Compiler$Op$$UnopMinus, ($u$$src$Compiler$Parser_Test$$lowercase)("b"))), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$lowercase)("c"), $c$$src$Core$$Nil)))))), $c$$src$Core$$Nil)))));

const $u$$src$Compiler$Parser_Test$$values = ($i$test$$Test$$Group)("Values", ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] Parse root comments", "# blank\na = 1", $u$$src$Compiler$Parser_Test$$firstStatement, $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] deal with spurious NewSiblingLine introduced by inline comments", "library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\"", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$Parser_Test$$codeTest)("[reg] SPON", "library =\n    source = \"core:prelude\"\n\n    module =\n        path = Core\n        importAs = Core", $u$$src$Compiler$Parser_Test$$firstDefinition, $i$test$$Test$$isOk), $c$$src$Core$$Nil))));

const $u$$src$Compiler$Parser_Test$$tests = ($i$test$$Test$$Group)("Parser", ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$values, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$parens, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$functions, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$annotations, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$unionDefs, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$lists, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$records, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$ifs, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$tries, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$patterns, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$binops, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$unops, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$comments, $c$$src$Core$$Nil))))))))))))));

const $u$$src$Compiler$TestHelpers$$taBool = ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$CoreDefs$$usr)("Bool"), $c$$src$Core$$Nil);

const $u$$src$Compiler$TestHelpers$$taFunction = (($from, $to) => {
  return ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$List$$map)((($t) => {
    return ($c$$src$Compiler$TypedAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($t));
  }), $from), ($c$$src$Compiler$Ast$$toImm)($to));
});

const $u$$src$Compiler$TestHelpers$$taList = (($item) => {
  return ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$CoreDefs$$usr)("List"), ($c$$src$Core$$Cons)($item, $c$$src$Core$$Nil));
});

const $u$$src$Compiler$TestHelpers$$taNone = ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$CoreDefs$$usr)("None"), $c$$src$Core$$Nil);

const $u$$src$Compiler$TestHelpers$$taTyvar = (($0) => {
  return ($c$$src$Compiler$TypedAst$$TypeVar)($0);
});

const $u$$src$Compiler$TypeCheck_Test$$outToHuman = (($out) => {
  const $env = ($u$$src$Compiler$TypeCheck$$initEnv)($c$$src$Dict$$empty);
  const $type = ($u$$src$SPLib$Format$$render)(((($0) => {
    return ($u$$src$Human$Format$$formatExpression)(({
      isRoot: true,
      originalContent: "",
    }), $0);
  }))(((($0) => {
    return ($u$$src$Human$Type$$doRawType)($env, $0);
  }))($out.type)));
  return ((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(($c$$src$Core$$Cons)(("  tyvars = " + (sp_toHuman)(($c$$src$Dict$$toList)($out.freeTyvars))), ($c$$src$Core$$Cons)(("  type = " + $type), $c$$src$Core$$Nil)));
});

const $u$$src$Compiler$TypeCheck_Test$$codeTest = (($0, $1, $2, $3) => {
  return ($i$test$$Test$$codeTest)($u$$src$Compiler$TypeCheck_Test$$outToHuman, $0, $1, $2, $3);
});

const $u$$src$Compiler$TypeCheck_Test$$freeTyvars = (($ids) => {
  return ($c$$src$List$$for)($c$$src$Dict$$empty, $ids, (($id, $d) => {
    return ($c$$src$Dict$$insert)($id, ({
      maybeAnnotated: $c$$src$Maybe$$Nothing,
    }), $d);
  }));
});

const $u$$src$Compiler$TypeCheck_Test$$freeTyvarsAnnotated = (($ids) => {
  return ((($0) => {
    return ($c$$src$List$$for)($0, $ids, (($4, $d) => {
      const $id = $4.first;
      const $name = $4.second;
      return ($c$$src$Dict$$insert)($id, ({
        maybeAnnotated: ($c$$src$Maybe$$Just)(({
          allowFunctions: true,
          name: $name,
        })),
      }), $d);
    }));
  }))($c$$src$Dict$$empty);
});

const $u$$src$Compiler$TypeCheck_Test$$tyvar = $u$$src$Compiler$TestHelpers$$taTyvar;

const $u$$src$Compiler$TypeCheck_Test$$functions = ($i$test$$Test$$Group)("functions", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Known function with correct params", "a = add 3 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: $u$$src$Compiler$TestHelpers$$taNumber,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Known function with wrong *number* of args", "a = add 'false", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Number", ($c$$src$Core$$Cons)("Arguments", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Known function with wrong params", "a = add 'false 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Bool", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Function inference 1", "a = fn x: add x 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)($u$$src$Compiler$TestHelpers$$taNumber, $c$$src$Core$$Nil), $u$$src$Compiler$TestHelpers$$taNumber),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Function inference 2: same as 1, but with swapped args", "a = fn x: add 1 x", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)($u$$src$Compiler$TestHelpers$$taNumber, $c$$src$Core$$Nil), $u$$src$Compiler$TestHelpers$$taNumber),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] fn had type None", "a = fn x: 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1))), $c$$src$Core$$Nil), ($c$$src$Compiler$Ast$$toUni)($u$$src$Compiler$TestHelpers$$taNumber)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Multiple arguments are correctly inferred", "a = fn x, y, z: x + y + z", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Annotation should be consistent with mutability", "f as fn @Number: Number = fn a:\n  a", ($u$$src$Compiler$TypeCheck_Test$$infer)("f"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("RecyclingDoesNotMatch", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Free tyvar should not be compatible with constructor", "listCons as fn item: item =\n    fn item:\n    []", ($u$$src$Compiler$TypeCheck_Test$$infer)("listCons"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Incompatible", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Annotations that are too general should be rejected", "f as fn a: b =\n    fn a: a", ($u$$src$Compiler$TypeCheck_Test$$infer)("f"), ($i$test$$Test$$errorContains)($c$$src$Core$$Nil)), $c$$src$Core$$Nil)))))))))));

const $u$$src$Compiler$TypeCheck_Test$$higherOrderTypes = ($i$test$$Test$$Group)("higher order types", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Parse precedence", "var T a = 't a\n\na as fn T a: T a =\n    fn l: l", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvarsAnnotated)(($c$$src$Core$$Cons)(({
    first: 1,
    second: "a",
  }), $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$TestHelpers$$moduleUsr)("T"), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1), $c$$src$Core$$Nil)), $c$$src$Core$$Nil), ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$TestHelpers$$moduleUsr)("T"), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1), $c$$src$Core$$Nil))),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Variant type constructors", "var X a = 'l\nl = 'l", ($u$$src$Compiler$TypeCheck_Test$$infer)("l"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($c$$src$Compiler$TypedAst$$TypeExact)(($u$$src$Compiler$TestHelpers$$moduleUsr)("X"), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1), $c$$src$Core$$Nil)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] type check mistakes a variant type with free tyvars for a free tyvar?", "var O r e o = 'o r e o\n\nrun as fn (fn r: O r e o), r: O r e o =\n   fn rToOreo, r:\n   rToOreo r", ($u$$src$Compiler$TypeCheck_Test$$infer)("run"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Wrong should be Text", "var O o = 'o Text o\n\nfun as Number: Text: O wrong = _: a:\n    'o a a", ($u$$src$Compiler$TypeCheck_Test$$infer)("fun"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("wrong", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Should complain about undefined type argument", "var O a = 'o Text output\nx = 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("output", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Named vars can't be refined?", "var Wrap a = 'w a\n\nf as fn a: Wrap a =\n    fn a: a", ($u$$src$Compiler$TypeCheck_Test$$infer)("f"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Wrap", $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))))));

const $u$$src$Compiler$TypeCheck_Test$$if_else = ($i$test$$Test$$Group)("if..else", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("basic functionality", "x =\n    fn q:\n    if q then 1\n    else 2", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($u$$src$Compiler$TestHelpers$$taBool)), $c$$src$Core$$Nil), ($c$$src$Compiler$Ast$$toUni)($u$$src$Compiler$TestHelpers$$taNumber)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("rejects non-bool conditions", "x =\n    fn q:\n    if 1 then 1\n    else 2", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Bool", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("rejects non-matching blocks", "x =\n    fn q:\n    if q then 2\n    else 'false", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Number", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$TypeCheck_Test$$misc = ($i$test$$Test$$Group)("Misc", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Undefined types should be rejected", "v as ThisTypeIsNotDefined = this_is_sp_native", ($u$$src$Compiler$TypeCheck_Test$$infer)("v"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("ThisTypeIsNotDefined", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Placeholder works with unique args", "stuff as fn !Number: Number = this_is_sp_native\nv =\n    1 >> stuff __", ($u$$src$Compiler$TypeCheck_Test$$infer)("v"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: $u$$src$Compiler$TestHelpers$$taNumber,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] named tyvars should not \"bleed\" to other definitions", "var DD q =\n    , 'RBEmpty_elm_builtin\n\nempty as DD key =\n    'RBEmpty_elm_builtin\n\nmerge as fn (fn key, b, res: res), res: res =\n  fn rightStep, initialResult:\n\n  stepState as fn key, b, [key & a] & res: [key & a] & res =\n    fn rKey, rValue, q:\n    try q.first as\n       []: q\n\n  initialResult", ($u$$src$Compiler$TypeCheck_Test$$infer)("merge"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Constructors not being generalized led to tyvar bleed", "var DD a b = 'Blah\n\nddget as fn a, DD a b: DD a b =\n    fn a, b:\n    'Blah\n\nformatSnippet as Text =\n    try [\"\"] as\n         [\"emphasys\", s]: s\n\nfmtBlock as Text =\n    try ddget 1 'Blah as\n         'Blah:\n            \"\"", ($u$$src$Compiler$TypeCheck_Test$$infer)("formatSnippet"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Non-annotated variables are not correctly inserted", "n = 3\n\nz as Number = n + 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("z"), $i$test$$Test$$isOk), $c$$src$Core$$Nil))))));

const $u$$src$Compiler$TypeCheck_Test$$nonFunction = ($i$test$$Test$$Group)("NonFunction", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("SKIP (burnedout) Basic functionality", "blah as fn [a]: [a] with a NonFunction =\n  fn a:\n  a\n\nmeh =\n    blah [fn x: x]", ($u$$src$Compiler$TypeCheck_Test$$infer)("meh"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("ErrorTypeAllowsFunctions", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("SKIP (burnedout) Constraint is enforced with annotation", "blah as fn [a]: [a] with a NonFunction =\n  fn a: a\n\nmeh as fn b: b =\n    fn a: blah a", ($u$$src$Compiler$TypeCheck_Test$$infer)("meh"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("ErrorTypeAllowsFunctions", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("SKIP (burnedout) Constraint is enforced without annotation", "blah as fn [a]: [a] with a NonFunction =\n    fn a: a\n\nmeh =\n    fn a: blah a", ($u$$src$Compiler$TypeCheck_Test$$infer)("meh"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($c$$src$Dict$$ofOne)(1, ({
    maybeAnnotated: $c$$src$Maybe$$Nothing,
  })),
  type: $u$$src$Compiler$TestHelpers$$taNumber,
}))), $c$$src$Core$$Nil))));

const $u$$src$Compiler$TypeCheck_Test$$patterns = ($i$test$$Test$$Group)("Patterns", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Constructor unpacking", "var Z a = 'z a\n\nidentityFunction =\n   fn a:\n   'z b = 'z a\n   b", ($u$$src$Compiler$TypeCheck_Test$$infer)("identityFunction"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("List unpacking", "x =\n   fn q:\n   [ first, second ] = q\n   first", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($u$$src$Compiler$TestHelpers$$taList)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Complete records are correctly unpacked", "x =\n    fn q:\n    { first } = q\n    first", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$TypeRecord)($c$$src$Maybe$$Nothing, ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
    first: "first",
    second: ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1),
  }), $c$$src$Core$$Nil))), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Incomplete records are correctly unpacked", "x =\n    fn q:\n    { with first } = q\n    first", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, $c$$src$Core$$Nil))),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(2), ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
    first: "first",
    second: ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1),
  }), $c$$src$Core$$Nil))), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Constructors should instantiate their variable types", "each as fn [a], (fn a: b): None =\n    fn ls, f:\n    try ls as\n         Core.'nil: 'none\n\nresult =\n    1 :: Core.'nil = Core.'nil", ($u$$src$Compiler$TypeCheck_Test$$infer)("result"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Trying to check against an inferred value?", "tuple as Text & Number =\n    \"\" & 1\n\nx =\n    (a as Text) & (b as Number) =\n        tuple", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), $i$test$$Test$$isOk), $c$$src$Core$$Nil)))))));

const $u$$src$Compiler$TypeCheck_Test$$records = ($i$test$$Test$$Group)("Records", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Attribute access", "a = fn b: b.meh.blah", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, ($c$$src$Core$$Cons)(3, $c$$src$Core$$Nil)))),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(1), ($c$$src$Dict$$ofOne)("meh", ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(2), ($c$$src$Dict$$ofOne)("blah", ($u$$src$Compiler$TypeCheck_Test$$tyvar)(3))))), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(3)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Attribute mutation", "a = fn @b: @b.meh.blah += 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, $c$$src$Core$$Nil))),
  type: ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$ParRe)(($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(1), ($c$$src$Dict$$ofOne)("meh", ($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(2), ($c$$src$Dict$$ofOne)("blah", $u$$src$Compiler$TestHelpers$$taNumber))))), $c$$src$Core$$Nil), ($c$$src$Compiler$Ast$$toImm)($u$$src$Compiler$TestHelpers$$taNone)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Tuple3 direct item mutability", "x =\n    !a = 3 & 'false & 2\n\n    @a.third += 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Tuple2 direct item mutability, annotated", "x =\n   fn _:\n   !a as Number & Number =\n     1 & 2\n\n   @a.first += 1", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("functional update", "a = fn b: { b with x = 1 }", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
    type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)($re, $c$$src$Core$$Nil), $re),
  });
}))(($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(1), ($c$$src$Dict$$ofOne)("x", $u$$src$Compiler$TestHelpers$$taNumber))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("SKIP(needs reordering) instantiate and refine inferred records", "a = fn t: { t with x = 1 }\nc = a", ($u$$src$Compiler$TypeCheck_Test$$infer)("c"), ($i$test$$Test$$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: $c$$src$Dict$$empty,
    type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)($re, $c$$src$Core$$Nil), $re),
  });
}))(($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(1), ($c$$src$Dict$$ofOne)("x", $u$$src$Compiler$TestHelpers$$taNumber))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] excessive forallness in records", "x =\n  fn q:\n  a = q.first\n  a", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, ($c$$src$Core$$Cons)(2, $c$$src$Core$$Nil))),
    type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)($re, $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(2)),
  });
}))(($c$$src$Compiler$TypedAst$$TypeRecord)(($c$$src$Maybe$$Just)(1), ($c$$src$Dict$$ofOne)("first", ($u$$src$Compiler$TypeCheck_Test$$tyvar)(2)))))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] refineType when the record has a non-extensible alias", "A = { c as Number, d as Number }\n\nupd as fn A: A = fn a:\n  { a with c = .c + 1 }", ($u$$src$Compiler$TypeCheck_Test$$infer)("upd"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] infinite recursion on addSubstitution/unify_", "B = { l as [Text] }\n\nreadOne as fn B: (Text & B) =\n    fn b:\n    try b.l as\n         []: \"\" & b\n         [h, t...]: h & { b with l = t }", ($u$$src$Compiler$TypeCheck_Test$$infer)("readOne"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] unifyToNonExtensibleRecord correctly substitutes the record extension", "R = { x as Number, y as Number }\n\nrec as fn R: R =\n    fn s:\n\n    if 'true then\n        { s with y = .y }\n    else\n        rec { s with y = .y }", ($u$$src$Compiler$TypeCheck_Test$$infer)("rec"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Record missing attributes", "R = { x as Number, y as Number }\n\nr as R = {\n  , x = 3\n  }", ($u$$src$Compiler$TypeCheck_Test$$infer)("r"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Missing", $c$$src$Core$$Nil))), $c$$src$Core$$Nil))))))))))));

const $u$$src$Compiler$TypeCheck_Test$$recursiveTypes = ($i$test$$Test$$Group)("Recursive types", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Normal types cannot be self recursive", "A = { a as A }\na as A = this_is_sp_native", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Circular", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Normal types cannot be mutually recursive", "A = { b as B }\nB = { a as A }\na as A = this_is_sp_native", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Circular", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Variant types can be recursive", "var A = 'a2 B\nB = { a as A }\na as A = this_is_sp_native\nb as B = this_is_sp_native", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), $i$test$$Test$$isOk), $c$$src$Core$$Nil))));

const $u$$src$Compiler$TypeCheck_Test$$statements = ($i$test$$Test$$Group)("statements", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Statement blocks should return the last statement's type", "a =\n  3\n  'false", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: $u$$src$Compiler$TestHelpers$$taBool,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Definition statements return type None", "a =\n  f = fn x: 3", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: $u$$src$Compiler$TestHelpers$$taNone,
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Definition statement with annotation return type None", "a as None =\n  f = 3", ($u$$src$Compiler$TypeCheck_Test$$infer)("a"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Annotated declarations are actually typechecked", "x as None =\n    q = 1 + \"\"", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)($c$$src$Core$$Nil)), $c$$src$Core$$Nil)))));

const $u$$src$Compiler$TypeCheck_Test$$try_as = ($i$test$$Test$$Group)("try..as", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("basic functionality", "x =\n    fn q:\n    try q as\n         'true: 2\n         _: 3", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: $c$$src$Dict$$empty,
  type: ($c$$src$Compiler$TypedAst$$TypeFn)(($c$$src$Core$$Cons)(($c$$src$Compiler$TypedAst$$ParSp)(($c$$src$Compiler$Ast$$toImm)($u$$src$Compiler$TestHelpers$$taBool)), $c$$src$Core$$Nil), ($c$$src$Compiler$Ast$$toUni)($u$$src$Compiler$TestHelpers$$taNumber)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("rejects non-matching patterns", "x =\n    fn q:\n    try q as\n         'true: 2\n         []: 3", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("List", ($c$$src$Core$$Cons)("Bool", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("rejects non-matching blocks", "x =\n    fn q:\n    try q as\n         'true: 2\n         'false: 'false", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("Number", ($c$$src$Core$$Cons)("Bool", $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] actually infers blocks", "x as Number =\n    try \"\" as\n         \"\": y", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("y", $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))));

const $u$$src$Compiler$TypeCheck_Test$$variableTypes = ($i$test$$Test$$Group)("Variable types", ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Identity, annotated", "id as fn a: a =\n  fn a: a", ($u$$src$Compiler$TypeCheck_Test$$infer)("id"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvarsAnnotated)(($c$$src$Core$$Cons)(({
    first: 1,
    second: "a",
  }), $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Identity, inferred", "id =\n  fn a: a", ($u$$src$Compiler$TypeCheck_Test$$infer)("id"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taFunction)(($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1), $c$$src$Core$$Nil), ($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("Annotated vars are instantiated when referenced", "q as [item] =\n  Core.'nil\n\nr as [Text] =\n      q", ($u$$src$Compiler$TypeCheck_Test$$infer)("r"), $i$test$$Test$$isOk), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] on is missing tyvars", "andThen as [a] = []\n\non = andThen", ($u$$src$Compiler$TypeCheck_Test$$infer)("on"), ($i$test$$Test$$isOkAndEqualTo)(({
  freeTyvars: ($u$$src$Compiler$TypeCheck_Test$$freeTyvars)(($c$$src$Core$$Cons)(1, $c$$src$Core$$Nil)),
  type: ($u$$src$Compiler$TestHelpers$$taList)(($u$$src$Compiler$TypeCheck_Test$$tyvar)(1)),
}))), ($c$$src$Core$$Cons)(($u$$src$Compiler$TypeCheck_Test$$codeTest)("[reg] Unifying functions does not unfiy their args", "var Dict_ k v = 'empty\ndict_member as fn k, Dict_ k v: Bool = this_is_sp_native\ndict_filter as fn (fn k, v: Bool), Dict_ k v: Dict_ k v = this_is_sp_native\n\nfreeTyvars as Dict_ Number {} = this_is_sp_native\ntypeTyvars as Dict_ Number None = this_is_sp_native\n\nx = dict_filter (fn k, v: dict_member v typeTyvars) freeTyvars", ($u$$src$Compiler$TypeCheck_Test$$infer)("x"), ($i$test$$Test$$errorContains)(($c$$src$Core$$Cons)("{}", ($c$$src$Core$$Cons)("Number", $c$$src$Core$$Nil)))), $c$$src$Core$$Nil))))));

const $u$$src$Compiler$TypeCheck_Test$$tests = ($i$test$$Test$$Group)("TypeCheck", ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$functions, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$statements, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$recursiveTypes, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$variableTypes, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$higherOrderTypes, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$records, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$patterns, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$try_as, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$if_else, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$nonFunction, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$misc, $c$$src$Core$$Nil))))))))))));

const $u$$src$DefaultImports$$platformDefaultImportsFile = (($modules) => {
  const $platform = ({
    modules: ($c$$src$List$$map)((($2) => {
      const $path = $2.first;
      const $globals = $2.second;
      return ($u$$src$DefaultImports$$mod)($path, $globals);
    }), $modules),
    source: "platform",
  });
  const $0 = $u$$src$DefaultImports$$defaultImportsFile;
  return (Object.assign)({}, $0, ({
    libraries: ($c$$src$Core$$Cons)($platform, $0.libraries),
  }));
});

const $u$$src$Human$Format_Test$$format = (($input) => {
  return (($c$$src$Result$$onOk)((($faStatements) => {
    const $env = ({
      isRoot: true,
      originalContent: $input,
    });
    return ($c$$src$Result$$Ok)(($u$$src$SPLib$Format$$render)(((($0) => {
      return ($u$$src$Human$Format$$formatStatements)($env, $0);
    }))($faStatements)));
  })))(((($0) => {
    return ($c$$src$Result$$mapError)(sp_toHuman, $0);
  }))(($u$$src$Compiler$Parser$$textToFormattableModule)(({
    errorModule: ({
      content: $input,
      fsPath: "test",
    }),
    keepComments: true,
    stripLocations: false,
  }))));
});

const $u$$src$Human$Format_Test$$formatTest = (($title, $input, $expectedOutput) => {
  const $quote = (($0) => {
    return ("```\n" + ($0 + "\n```"));
  });
  const $4 = ($i$test$$Test$$isOkAndEqualTo)($expectedOutput);
  const $toMaybeError = ($4)[1];
  return ($i$test$$Test$$Single)($title, "", ((_0) => {
    return ($i$test$$Test$$maybeToOutcome)(((($0) => {
      return ($toMaybeError)($quote, $0);
    }))(($u$$src$Human$Format_Test$$format)($input)));
  }));
});

const $u$$src$Human$Format_Test$$calls = ($i$test$$Test$$Group)("Calls", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Arguments indentation", "a =\n   fun\n      #comment1\n      a\n        #comment2\n        b", "a =\n    fun\n        #comment1\n        a\n        #comment2\n        b\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("precedence", "a (b  c)", "a (b c)\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("With multiline args", "a =\n    (x >> y)\n       fn _:\n          a\n          b\n      (assert blah)\n      (zak meh)", "a =\n    (x >> y)\n        (fn _:\n             a\n\n             b\n        )\n        (assert blah)\n        (zak meh)\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve aligned", "a =\n    x fn _:\n    y", "a =\n    x fn _:\n    y\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve indent", "a =\n    x fn _:\n      y", "a =\n    x fn _:\n        y\n"), $c$$src$Core$$Nil))))));

const $u$$src$Human$Format_Test$$comments = ($i$test$$Test$$Group)("Comments", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] Should not add indent to empty lines", "if a then\n    [#\n\n        comment\n\n    #]\n    b\n  else\n    c", "if a then\n    [#\n\n        comment\n\n    #]\n    b\nelse\n    c\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve whether a comment has a trailing blank, line", "# blank\n\na = 1\n\n# no blank\nb = 1", "# blank\n\na =\n    1\n\n\n# no blank\nb =\n    1\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve whether a comment has a trailing blank, block", "[# blank #]\n\na = 1\n\n[# no blank #]\nb = 1", "[# blank #]\n\na =\n    1\n\n\n[# no blank #]\nb =\n    1\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Comment order is preserved", "# a\n# b\n# c\naaaaa =\n# d\n# e\n# f\n      bbbbb\n\n      #g\n      #h\n      #i\n      ccccc", "# a\n# b\n# c\naaaaa =\n# d\n# e\n# f\n    bbbbb\n\n    #g\n    #h\n    #i\n    ccccc\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Normal comments get indented, line", "a =\n # b\n    1", "a =\n    # b\n    1\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("\"Quick\" comments remain untouched, line", "a =\n# b\n  1", "a =\n# b\n    1\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Normal comments get indented, block", "a =\n [# b\nblah#]\n    1", "a =\n    [# b\n    blah#]\n    1\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("\"Quick\" comments remain untouched, block", "a =\n[# b\n#]\n  1", "a =\n[# b\n#]\n    1\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] Section comment should stay before the if", "f =\n    a = 1\n\n# comment\n\n    if a then\n        b\n      else\n        c", "f =\n    a =\n        1\n\n# comment\n\n    if a then\n        b\n    else\n        c\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] Block comment internal indent should remain consistent", "x =\n    [#\n        comment\n    #]\n    d", "x =\n    [#\n        comment\n    #]\n    d\n"), $c$$src$Core$$Nil)))))))))));

const $u$$src$Human$Format_Test$$definitions = ($i$test$$Test$$Group)("Definitions", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Alias", "Meh a b = Int", "Meh a b =\n    Int\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Unions 1", "var Meh = 'meh z", "var Meh =\n    , 'meh z\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Unions 2", "var Meh a b = 'blah, 'meh x y z", "var Meh a b =\n    , 'blah\n    , 'meh x y z\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Annotated values", "(x as Type) & (y as Kind) = thing", "(x as Type) & (y as Kind) =\n    thing\n"), $c$$src$Core$$Nil)))));

const $u$$src$Human$Format_Test$$functions = ($i$test$$Test$$Group)("Functions", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("SKIP (low priority) Named functions should always have their body below", "f =\n    fn a: fn b: c", "f =\n    fn a:\n    fn b:\n    c"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Named functions should always have their body below", "x =\n  a\n  >> onOk fn b:\n\n  c\n  >> onOk fn d:\n\n  e", "x =\n    a\n    >> onOk fn b:\n    c\n    >> onOk fn d:\n    e\n"), $c$$src$Core$$Nil)));

const $u$$src$Human$Format_Test$$ifs = ($i$test$$Test$$Group)("if..then", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Single line", "x = if blah   then a  else b", "x =\n    if blah then a else b\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Make multiline", "x = if blah then\n      a = 1\n      a + b\n  else  b", "x =\n    if blah then\n        a =\n            1\n\n        a + b\n    else\n        b\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve multiline", "x =\n    if blah then\n        a\n    else b", "x =\n    if blah then\n        a\n    else\n        b\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("if else", "x = if blah then a else if o then b else q", "x =\n    if blah then\n        a\n    else if o then\n        b\n    else\n        q\n"), $c$$src$Core$$Nil)))));

const $u$$src$Human$Format_Test$$lists = ($i$test$$Test$$Group)("Lists", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve one-liners", "a = [1, 2, 3]", "a =\n    [ 1, 2, 3 ]\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve multilines", "a = [1\n  , 2, 3]", "a =\n    [\n    , 1\n    , 2\n    , 3\n    ]\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] weird shit happening when a definition is preceded by a blank line?", "\nll as [Int] = []", "ll as [ Int ] =\n    []\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Expansion", "\nll = [a..., b, fun arg..., (pas)...]", "ll =\n    [ a..., b, fun arg..., pas... ]\n"), $c$$src$Core$$Nil)))));

const $u$$src$Human$Format_Test$$operators = ($i$test$$Test$$Group)("Operators", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Precedence", "a = (1 + 2 * 3 + 4)\nb = 5*(6+ 7)*8", "a =\n    1 + 2 * 3 + 4\n\n\nb =\n    5 * (6 + 7) * 8\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Pipe on a single line stays on a single line", "a = b >> c >> d >> e", "a =\n    b >> c >> d >> e\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Pipe right gets indented if there is at least one line break", "a = b >> c\n  >> d >> e", "a =\n    b\n    >> c\n    >> d\n    >> e\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] Preserve comment", "escape =\n    x\n    # comment\n    >> replace\n    >> replace", "escape =\n    x\n    # comment\n    >> replace\n    >> replace\n"), $c$$src$Core$$Nil)))));

const $u$$src$Human$Format_Test$$records = ($i$test$$Test$$Group)("Records", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Reorder attributes", "a = { z, e, r }", "a =\n    { e, r, z }\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Comments", "a = {\n    , z = 1\n    # AAA\n    , e = 2\n    , r =\n      # BBB\n       3\n   }", "a =\n    {\n    # AAA\n    , e =\n        2\n    , r =\n        # BBB\n        3\n    , z = 1\n    }\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Extension", "{ z with e }", "{ z with e }\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Shorthands", "a = { b with c = .d }", "a =\n    { b with c = .d }\n"), $c$$src$Core$$Nil)))));

const $u$$src$Human$Format_Test$$textLiterals = ($i$test$$Test$$Group)("Text literals", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Single quotes escape quotes and backspaces", "a = \"\\\"\\\\\"", "a =\n    \"\\\"\\\\\"\n"), $c$$src$Core$$Nil));

const $u$$src$Human$Format_Test$$tryAs = ($i$test$$Test$$Group)("try..as", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Compact", "x = try blah as\n  Just a: a\n  Nothing:  b", "x =\n    try blah as\n        Just a: a\n        Nothing: b\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Long", "x = try blah as\n  Just a:\n        b = 1\n        b + a\n  Nothing:  b", "x =\n    try blah as\n\n        Just a:\n            b =\n                1\n\n            b + a\n\n        Nothing:\n            b\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("SKIP (low priority) Preserves comments (compact)", "try e  as\n    T: 9\n    # comment\n    _:  10", "try e as\n    T: 9\n    # comment\n    _: 10\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserves comments (long, inline comments)", "try e as\n    # AAA\n    T:\n    # BBB\n        9\n    _: 10", "try e as\n\n    # AAA\n    T:\n        # BBB\n        9\n\n    _:\n        10\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserves comments (long, block comments)", "try e as\n    [# AAA #]\n    T:\n    [# BBB #]\n        9\n    _: 10", "try e as\n\n    [# AAA #]\n    T:\n        [# BBB #]\n        9\n\n    _:\n        10\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Comments", "x =\n          try char as\n            \"\":\n                None\n\n#            \"@\":\n\n            \"#\":\n                start\n", "x =\n    try char as\n\n        \"\":\n            None\n\n#            \"@\":\n\n        \"#\":\n            start\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] Should not move a comma inside a multi-line comment", "try char as\n  a: b\n\n  [#\n  comment\n  #]\n\n  d: c", "try char as\n\n    a:\n        b\n\n    [#\n    comment\n    #]\n\n    d:\n        c\n"), ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("[reg] Comments should not cause content to multiline", "try value as\n\n    # TODO restore `None` here once it doesn't break JS any more\n    Err _:\n        formatIndented", "try value as\n\n    # TODO restore `None` here once it doesn't break JS any more\n    Err _:\n        formatIndented\n"), $c$$src$Core$$Nil)))))))));

const $u$$src$Human$Format_Test$$uniqueness = ($i$test$$Test$$Group)("Uniqueness", ($c$$src$Core$$Cons)(($u$$src$Human$Format_Test$$formatTest)("Preserve uniqueness annotations", "f as fn !a, 2?b, @c: !d = fn !a, 2?b, @c: blah", "f as fn !a, 2?b, @c: !d =\n    fn !a, 2?b, @c: blah\n"), $c$$src$Core$$Nil));

const $u$$src$Human$Format_Test$$tests = ($i$test$$Test$$Group)("Formatter", ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$definitions, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$operators, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$functions, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$calls, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$lists, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$records, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$comments, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$textLiterals, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$uniqueness, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$tryAs, ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$ifs, $c$$src$Core$$Nil))))))))))));

const $u$$src$SPLib$Format$$spaceSeparatedOrIndentForce = (($force, $blocks) => {
  return ($u$$src$SPLib$Format$$rowOrIndentForce)($force, ($c$$src$Maybe$$Just)($u$$src$SPLib$Format$$space), $blocks);
});

const $u$$src$SPLib$Format_Test$$format1 = (($breakFirst, $breakRest, $f, $1) => {
  const $arg0 = ($1)[1];
  const $args = ($1)[2];
  return ((($0) => {
    return ($c$$src$List$$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))(($u$$src$SPLib$Format$$render)(($u$$src$SPLib$Format$$spaceSeparatedOrIndentForce)($breakRest, (sp_cons)(($u$$src$SPLib$Format$$spaceSeparatedOrIndentForce)($breakFirst, ($c$$src$Core$$Cons)($f, ($c$$src$Core$$Cons)($arg0, $c$$src$Core$$Nil))), $args)))));
});

const $u$$src$SPLib$Format_Test$$format2 = (($break, $1) => {
  const $first = ($1)[1];
  const $rest = ($1)[2];
  const $formatEntry = (($open, $block) => {
    return ($u$$src$SPLib$Format$$prefix)(2, ($u$$src$SPLib$Format$$Row)(($u$$src$SPLib$Format$$Text_)($open), $u$$src$SPLib$Format$$space), $block);
  });
  return ((($0) => {
    return ($c$$src$List$$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))(($u$$src$SPLib$Format$$render)(($u$$src$SPLib$Format$$spaceSeparatedOrStackForce)($break, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$rowOrStackForce)($break, $c$$src$Maybe$$Nothing, (sp_cons)(($formatEntry)("[", $first), ($c$$src$List$$map)((($0) => {
    return ($formatEntry)(",", $0);
  }), $rest))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("]"), $c$$src$Core$$Nil))))));
});

const $u$$src$SPLib$Format_Test$$format3 = (($1) => {
  const $first = ($1)[1];
  const $rest = ($1)[2];
  const $formatEntry = (($open, $2) => {
    const $key = $2.first;
    const $break = $2.second;
    const $value = $2.third;
    return ($u$$src$SPLib$Format$$spaceSeparatedOrIndentForce)($break, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$spaceSeparatedOrStack)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)($open), ($c$$src$Core$$Cons)($key, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("="), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)($value, $c$$src$Core$$Nil)));
  });
  return ((($0) => {
    return ($c$$src$List$$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))(($u$$src$SPLib$Format$$render)(($u$$src$SPLib$Format$$stack)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($formatEntry)("{", $first), $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($c$$src$List$$map)((($0) => {
    return ($formatEntry)(",", $0);
  }), $rest), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("}"), $c$$src$Core$$Nil), $c$$src$Core$$Nil))))))));
});

const $u$$src$SPLib$Format_Test$$format4 = (($breakCond, $breakBodies, $2, $elseBody) => {
  const $ifCond = $2.first;
  const $ifBody = $2.second;
  return ((($0) => {
    return ($c$$src$List$$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))(($u$$src$SPLib$Format$$render)(($u$$src$SPLib$Format$$spaceSeparatedOrStack)(($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$spaceSeparatedOrIndentForce)($breakBodies, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$rowOrStack)($c$$src$Maybe$$Nothing, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$rowOrIndentForce)($breakCond, $c$$src$Maybe$$Nothing, ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("if ("), ($c$$src$Core$$Cons)($ifCond, $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)(") {"), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)($ifBody, $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$spaceSeparatedOrIndentForce)(($breakBodies || $breakCond), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("} else {"), ($c$$src$Core$$Cons)($elseBody, $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format$$textToBlock)("}"), $c$$src$Core$$Nil)))))));
});

const $u$$src$SPLib$Format_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $u$$src$SPLib$Format_Test$$tests = ($i$test$$Test$$Group)("Block examples", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("Elm-like examples", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("function application", ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("Formats on a single line", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format1)(false, false, ($u$$src$SPLib$Format$$textToBlock)("f"), ($c$$src$List$$map)($u$$src$SPLib$Format$$textToBlock, ($c$$src$Core$$Cons)("a", ($c$$src$Core$$Cons)("b", $c$$src$Core$$Nil))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("f a b", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats with all arguments split", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format1)(true, false, ($u$$src$SPLib$Format$$textToBlock)("f"), ($c$$src$List$$map)($u$$src$SPLib$Format$$textToBlock, ($c$$src$Core$$Cons)("a", ($c$$src$Core$$Cons)("b", $c$$src$Core$$Nil))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("f", ($c$$src$Core$$Cons)("    a", ($c$$src$Core$$Cons)("    b", $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats with first argument joined", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format1)(false, true, ($u$$src$SPLib$Format$$textToBlock)("f"), ($c$$src$List$$map)($u$$src$SPLib$Format$$textToBlock, ($c$$src$Core$$Cons)("a", ($c$$src$Core$$Cons)("b", $c$$src$Core$$Nil))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("f a", ($c$$src$Core$$Cons)("    b", $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("list", ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats single-line", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format2)(false, ($c$$src$List$$map)($u$$src$SPLib$Format$$textToBlock, ($c$$src$Core$$Cons)("a", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("c", $c$$src$Core$$Nil)))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("[ a, b, c ]", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats multiline", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format2)(true, ($c$$src$List$$map)($u$$src$SPLib$Format$$textToBlock, ($c$$src$Core$$Cons)("a", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("c", $c$$src$Core$$Nil)))));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("[ a", ($c$$src$Core$$Cons)(", b", ($c$$src$Core$$Cons)(", c", ($c$$src$Core$$Cons)("]", $c$$src$Core$$Nil)))))), $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("record", ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats single-line entries", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format3)(($c$$src$Core$$Cons)(({
    first: ($u$$src$SPLib$Format$$textToBlock)("a"),
    second: false,
    third: ($u$$src$SPLib$Format$$textToBlock)("1"),
  }), ($c$$src$Core$$Cons)(({
    first: ($u$$src$SPLib$Format$$textToBlock)("b"),
    second: false,
    third: ($u$$src$SPLib$Format$$textToBlock)("2"),
  }), $c$$src$Core$$Nil)));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("{ a = 1", ($c$$src$Core$$Cons)(", b = 2", ($c$$src$Core$$Cons)("}", $c$$src$Core$$Nil))))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats multiline entries", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format3)(($c$$src$Core$$Cons)(({
    first: ($u$$src$SPLib$Format$$textToBlock)("a"),
    second: true,
    third: ($u$$src$SPLib$Format$$textToBlock)("1"),
  }), ($c$$src$Core$$Cons)(({
    first: ($u$$src$SPLib$Format$$textToBlock)("b"),
    second: false,
    third: ($u$$src$SPLib$Format$$textToBlock)("2"),
  }), $c$$src$Core$$Nil)));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("{ a =", ($c$$src$Core$$Cons)("    1", ($c$$src$Core$$Cons)(", b = 2", ($c$$src$Core$$Cons)("}", $c$$src$Core$$Nil)))))), $c$$src$Core$$Nil))), $c$$src$Core$$Nil)))), ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("Javascript-like examples", ($c$$src$Core$$Cons)(($i$test$$Test$$Group)("if-else", ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats single-line", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format4)(false, false, ({
    first: ($u$$src$SPLib$Format$$textToBlock)("p"),
    second: ($u$$src$SPLib$Format$$textToBlock)("a"),
  }), ($u$$src$SPLib$Format$$textToBlock)("b"));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("if (p) { a } else { b }", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats multiline", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format4)(false, true, ({
    first: ($u$$src$SPLib$Format$$textToBlock)("p"),
    second: ($u$$src$SPLib$Format$$textToBlock)("a"),
  }), ($u$$src$SPLib$Format$$textToBlock)("b"));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("if (p) {", ($c$$src$Core$$Cons)("    a", ($c$$src$Core$$Cons)("} else {", ($c$$src$Core$$Cons)("    b", ($c$$src$Core$$Cons)("}", $c$$src$Core$$Nil))))))), ($c$$src$Core$$Cons)(($u$$src$SPLib$Format_Test$$valueTest)("formats multiline condition", ((_0) => {
  return ($u$$src$SPLib$Format_Test$$format4)(true, false, ({
    first: ($u$$src$SPLib$Format$$textToBlock)("p"),
    second: ($u$$src$SPLib$Format$$textToBlock)("a"),
  }), ($u$$src$SPLib$Format$$textToBlock)("b"));
}), ($i$test$$Test$$isOkAndEqualTo)(($c$$src$Core$$Cons)("if (", ($c$$src$Core$$Cons)("    p", ($c$$src$Core$$Cons)(") {", ($c$$src$Core$$Cons)("    a", ($c$$src$Core$$Cons)("} else {", ($c$$src$Core$$Cons)("    b", ($c$$src$Core$$Cons)("}", $c$$src$Core$$Nil))))))))), $c$$src$Core$$Nil)))), $c$$src$Core$$Nil)), $c$$src$Core$$Nil)));

const $u$$src$SPLib$RefHierarchy_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $u$$src$SPLib$RefHierarchy_Test$$canonicalJsTest = ($u$$src$SPLib$RefHierarchy_Test$$valueTest)("[reg] THIS SHOULD BE IN CANONICALTOJS", ((_0) => {
  return (basics_compare)(null, null);
}), ($i$test$$Test$$isOkAndEqualTo)(0));

const $u$$src$SPLib$RefHierarchy_Test$$graph1 = ((() => {
  const $x = (($k, $l) => {
    return ({
      first: $k,
      second: ({
        first: $k,
        second: ($c$$src$Set$$fromList)($l),
      }),
    });
  });
  return ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(($x)("a", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("d", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($x)("b", ($c$$src$Core$$Cons)("c", ($c$$src$Core$$Cons)("e", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($x)("c", ($c$$src$Core$$Cons)("e", ($c$$src$Core$$Cons)("d", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($x)("d", $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(($x)("e", $c$$src$Core$$Nil), $c$$src$Core$$Nil))))));
}))();

const $u$$src$SPLib$RefHierarchy_Test$$graph2 = ((() => {
  const $x = (($k, $l) => {
    return ({
      first: $k,
      second: ({
        first: $k,
        second: ($c$$src$Set$$fromList)($l),
      }),
    });
  });
  return ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(($x)("a", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("d", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($x)("b", ($c$$src$Core$$Cons)("c", ($c$$src$Core$$Cons)("e", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($x)("c", ($c$$src$Core$$Cons)("e", ($c$$src$Core$$Cons)("d", $c$$src$Core$$Nil))), ($c$$src$Core$$Cons)(($x)("d", ($c$$src$Core$$Cons)("b", $c$$src$Core$$Nil)), ($c$$src$Core$$Cons)(($x)("e", $c$$src$Core$$Nil), $c$$src$Core$$Nil))))));
}))();

const $u$$src$SPLib$RefHierarchy_Test$$tests = ($i$test$$Test$$Group)("RefHierarchy", ($c$$src$Core$$Cons)($u$$src$SPLib$RefHierarchy_Test$$canonicalJsTest, ($c$$src$Core$$Cons)(($u$$src$SPLib$RefHierarchy_Test$$valueTest)("Basic", ((_0) => {
  return ($u$$src$SPLib$RefHierarchy$$reorder)($c$$src$Tuple$$second, $u$$src$SPLib$RefHierarchy_Test$$graph1);
}), ($i$test$$Test$$isOkAndEqualTo)(({
  first: $c$$src$Core$$Nil,
  second: ($c$$src$Core$$Cons)("d", ($c$$src$Core$$Cons)("e", ($c$$src$Core$$Cons)("c", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil))))),
}))), ($c$$src$Core$$Cons)(($u$$src$SPLib$RefHierarchy_Test$$valueTest)("Circular", ((_0) => {
  return ($u$$src$SPLib$RefHierarchy$$reorder)($c$$src$Tuple$$second, $u$$src$SPLib$RefHierarchy_Test$$graph2);
}), ($i$test$$Test$$isOkAndEqualTo)(({
  first: ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("d", ($c$$src$Core$$Cons)("c", $c$$src$Core$$Nil))), $c$$src$Core$$Nil),
  second: ($c$$src$Core$$Cons)("d", ($c$$src$Core$$Cons)("e", ($c$$src$Core$$Cons)("c", ($c$$src$Core$$Cons)("b", ($c$$src$Core$$Cons)("a", $c$$src$Core$$Nil))))),
}))), $c$$src$Core$$Nil))));

const $u$$src$Targets$Emitted_Test$$valueTest = (($0, $1, $2) => {
  return ($i$test$$Test$$valueTest)(sp_toHuman, $0, $1, $2);
});

const $u$$src$Targets$Emitted_Test$$javascript = ($i$test$$Test$$Group)("JavaScript", ($c$$src$Core$$Cons)(($u$$src$Targets$Emitted_Test$$valueTest)("[reg] Imperative try..as should not force the function to return prematurely", ((_0) => {
  let $2 = false;
  return (!($2)
    ? 1
    : ($2
      ? 2
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Emitted_Test.sp 32:17', (sp_toHuman)($2))));
  return "abc";
}), ($i$test$$Test$$isOkAndEqualTo)("abc")), ($c$$src$Core$$Cons)(($u$$src$Targets$Emitted_Test$$valueTest)("[reg] Pattern matching fails on None", ((_0) => {
  let $2 = null;
  return (true
    ? 1
    : (sp_throw)('Missing pattern in try..as', 'src/Targets/Emitted_Test.sp 44:17', (sp_toHuman)($2)));
}), ($i$test$$Test$$isOkAndEqualTo)(1)), $c$$src$Core$$Nil)));

const $u$$src$Targets$Emitted_Test$$tests = ($i$test$$Test$$Group)("Emitted", ($c$$src$Core$$Cons)($u$$src$Targets$Emitted_Test$$javascript, $c$$src$Core$$Nil));

const $u$$src$Main$$allTests = ($c$$src$Core$$Cons)($u$$src$Human$Format_Test$$tests, ($c$$src$Core$$Cons)($u$$src$Compiler$Lexer_Test$$tests, ($c$$src$Core$$Cons)($u$$src$Compiler$Parser_Test$$tests, ($c$$src$Core$$Cons)($u$$src$Compiler$MakeCanonical_Test$$tests, ($c$$src$Core$$Cons)($u$$src$Compiler$TypeCheck_Test$$tests, ($c$$src$Core$$Cons)($u$$src$Targets$Emitted_Test$$tests, ($c$$src$Core$$Cons)($c$$src$Hash_Test$$tests, ($c$$src$Core$$Cons)($c$$src$Array_Test$$tests, ($c$$src$Core$$Cons)($c$$src$List_Test$$tests, ($c$$src$Core$$Cons)($c$$src$Dict_Test$$tests, ($c$$src$Core$$Cons)($u$$specs$Uniqueness$$specs, ($c$$src$Core$$Cons)($u$$src$SPLib$Format_Test$$tests, ($c$$src$Core$$Cons)($u$$src$SPLib$RefHierarchy_Test$$tests, $c$$src$Core$$Nil)))))))))))));

const $u$$src$Platforms$Posix$$defaultImportsFile = ($u$$src$DefaultImports$$platformDefaultImportsFile)(($c$$src$Core$$Cons)(({
  first: "IO",
  second: ($c$$src$Core$$Cons)("IO", $c$$src$Core$$Nil),
}), ($c$$src$Core$$Cons)(({
  first: "Path",
  second: $c$$src$Core$$Nil,
}), $c$$src$Core$$Nil)));

const $u$$src$Platforms$Posix$$header = "#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096\n\n//Error.stackTraceLimit = 100;\n\nconst { performance } = require('perf_hooks');\n\n";

const $u$$src$Platforms$Posix$$overrides = (($platformImportsPath) => {
  const $ioModule = (($0) => {
    return ($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($platformImportsPath, "", "IO"), $0);
  });
  const $pathModule = (($0) => {
    return ($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($platformImportsPath, "", "Path"), $0);
  });
  return ($c$$src$Core$$Cons)(({
    first: ($ioModule)("parallel"),
    second: "io_parallel",
  }), ($c$$src$Core$$Cons)(({
    first: ($ioModule)("readDir"),
    second: "io_readDir",
  }), ($c$$src$Core$$Cons)(({
    first: ($ioModule)("readFile"),
    second: "io_readFile",
  }), ($c$$src$Core$$Cons)(({
    first: ($ioModule)("writeFile"),
    second: "io_writeFile",
  }), ($c$$src$Core$$Cons)(({
    first: ($ioModule)("readStdin"),
    second: "io_readStdin",
  }), ($c$$src$Core$$Cons)(({
    first: ($ioModule)("writeStdout"),
    second: "io_writeStdout",
  }), ($c$$src$Core$$Cons)(({
    first: ($ioModule)("writeStderr"),
    second: "io_writeStderr",
  }), ($c$$src$Core$$Cons)(({
    first: ($pathModule)("dirname"),
    second: "path_dirname",
  }), ($c$$src$Core$$Cons)(({
    first: ($pathModule)("resolve"),
    second: "path_resolve",
  }), ($c$$src$Core$$Cons)(({
    first: ($pathModule)("join"),
    second: "path_join",
  }), $c$$src$Core$$Nil))))))))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$sanitizePath = (($path) => {
  return (((sp_not_equal)($path, "") && (sp_equal)(((text_startsWithRegex)("[A-Za-z_$/]*$"))($path), ""))
    ? (sp_todo)(("Invalid character in path: " + ($path + " (hopefully at some point this limit will be fixed)")))
    : ($c$$src$Text$$replace)("/", "$", $path));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateName = (($name) => {
  return ((text_startsWith)("'", $name)
    ? ((() => {
      const $head = (text_slice)(1, 2, $name);
      const $rest = (text_slice)(2, 9999, $name);
      return ("$" + ((text_toUpper)($head) + $rest));
    }))()
    : ("$" + $name));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateRoot = (($0) => {
  return ((($0)[0] === "$Core")
    ? "c"
    : ((($0)[0] === "$User")
      ? "u"
      : ((($0)[0] === "$Installed")
        ? "i"
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 636:4', (sp_toHuman)($0)))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateUsr = (($1) => {
  const $root = ((($1)[1])[1])[1];
  const $importsDir = ((($1)[1])[1])[2];
  const $sourceDir = (($1)[1])[2];
  const $modulePath = (($1)[1])[3];
  const $name = ($1)[2];
  return ((($0) => {
    return ($c$$src$Text$$join)("$", $0);
  }))(($c$$src$Core$$Cons)("", ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$translateRoot)($root), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$sanitizePath)($importsDir), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$sanitizePath)($sourceDir), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$sanitizePath)($modulePath), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name), $c$$src$Core$$Nil)))))));
});

const $u$$src$Platforms$Posix$$makeErr = ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)(($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$CoreDefs$$importsPath, "src", "Result"), "'ok"));

const $u$$src$Platforms$Posix$$makeOk = ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)(($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$CoreDefs$$importsPath, "src", "Result"), "'ok"));

const $u$$src$Platforms$Posix$$runtime = ("\n//\n// Platform: IO\n//\nconst fs = require('fs');\nconst path = require('path');\n\nconst io_readDir = (io, dirPath) => {\n    // as @IO, Text: Re [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return [" + ($u$$src$Platforms$Posix$$makeErr + ("(e.message), null];\n        }\n\n        return [" + ($u$$src$Platforms$Posix$$makeOk + ("(arrayToListLow(entries.map((dirent) => ({\n            first: dirent.isDirectory(),\n            second: dirent.name,\n        })))), null];\n    };\n\n\n    const io_readFile = (io, path) => {\n        // as @IO, Text: Re Text\n\n        var content;\n        try {\n            content = fs.readFileSync(path, 'utf8');\n        } catch (e) {\n            return [" + ($u$$src$Platforms$Posix$$makeErr + ("(e.message), null];\n        }\n\n        return [" + ($u$$src$Platforms$Posix$$makeOk + ("(content), null];\n    };\n\n\n    const io_writeFile = (io, path, content) => {\n        // as @IO, Text, Text: Re Int\n\n        try {\n            fs.writeFileSync(path, content);\n        } catch (e) {\n            return [" + ($u$$src$Platforms$Posix$$makeErr + ("(e.message), null];\n        }\n\n        return [" + ($u$$src$Platforms$Posix$$makeOk + ("(0), null];\n    };\n\n\n    const io_readStdin = (io) => {\n        // as @IO: Re Text\n\n        try {\n            return [" + ($u$$src$Platforms$Posix$$makeOk + ("(fs.readFileSync(0, 'utf8')), null];\n        } catch (e) {\n            return [" + ($u$$src$Platforms$Posix$$makeErr + ("(e.message), null];\n        }\n    };\n\n\n    const io_writeStdout = (io, content) => {\n        // as @IO, Text: Re None\n\n        try {\n            fs.writeFileSync(1, content);\n        } catch (e) {\n            return [" + ($u$$src$Platforms$Posix$$makeErr + ("(e.message), null];\n        }\n\n        return [" + ($u$$src$Platforms$Posix$$makeOk + ("(null), null];\n    };\n\n\n    const io_writeStderr = (io, content) => {\n        // as @IO, Text: Re Int\n\n        try {\n            fs.writeFileSync(2, content);\n        } catch (e) {\n            return [" + ($u$$src$Platforms$Posix$$makeErr + ("(e.message), null];\n        }\n\n        return [" + ($u$$src$Platforms$Posix$$makeOk + "(null), null];\n    };\n\n\n    const path_resolve = (p) => path.resolve(...arrayFromListLow(p));\n\n    const path_join = (p) => path.join(...arrayFromListLow(p));\n\n    const path_dirname = path.dirname;\n\n"))))))))))))))))))))))));

const $u$$src$Targets$Javascript$EmittableToJs$$accessAttrs = (($attrPath, $e) => {
  return ($c$$src$List$$for)($e, $attrPath, $u$$src$Targets$Javascript$Ast$$AccessWithDot);
});

const $u$$src$Targets$Javascript$EmittableToJs$$accessArrayIndex = (($index, $j) => {
  return ((($0) => {
    return ($u$$src$Targets$Javascript$Ast$$AccessWithBrackets)($0, $j);
  }))(($u$$src$Targets$Javascript$Ast$$Literal)((text_fromNumber)($index)));
});

const $u$$src$Targets$Javascript$EmittableToJs$$literalString = (($str) => {
  const $escaped = $str;
  return ($u$$src$Targets$Javascript$Ast$$Literal)(("\"" + ($escaped + "\"")));
});

const $u$$src$Targets$Javascript$EmittableToJs$$recycleTempVariable = ($u$$src$Targets$Javascript$Ast$$Var)("__re__");

const $u$$src$Targets$Javascript$EmittableToJs$$makeCall = (($env, $jaRef, $args) => {
  const $call = ((($0) => {
    return ($u$$src$Targets$Javascript$Ast$$Call)($jaRef, $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($0) => {
      return ($u$$src$Targets$Javascript$EmittableToJs$$translateArg)(({
        nativeBinop: false,
      }), $env, $0);
    }), $0);
  }))($args));
  const $asRecycled = (($arg) => {
    return ((($arg)[0] === "$ArgumentSpend")
      ? $c$$src$Maybe$$Nothing
      : ((($arg)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $rawType = ($arg)[1];
          const $attrPath = ($arg)[2];
          const $name = ($arg)[3];
          return ($c$$src$Maybe$$Just)(((($0) => {
            return ($u$$src$Targets$Javascript$EmittableToJs$$accessAttrs)($attrPath, $0);
          }))(($u$$src$Targets$Javascript$Ast$$Var)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 365:8', (sp_toHuman)($arg))));
  });
  const $recycledArgs = ($c$$src$List$$filterMap)($asRecycled, $args);
  return ((sp_equal)($recycledArgs, $c$$src$Core$$Nil)
    ? $call
    : ((() => {
      const $zzz = (($index, $arg) => {
        const $bracketIndex = ($u$$src$Targets$Javascript$Ast$$Literal)((text_fromNumber)(($index + 1)));
        return ($u$$src$Targets$Javascript$Ast$$Binop)("=", $arg, ($u$$src$Targets$Javascript$Ast$$AccessWithBrackets)($bracketIndex, $u$$src$Targets$Javascript$EmittableToJs$$recycleTempVariable));
      });
      return ($u$$src$Targets$Javascript$Ast$$Comma)(($c$$src$List$$concat)(($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Binop)("=", $u$$src$Targets$Javascript$EmittableToJs$$recycleTempVariable, $call), $c$$src$Core$$Nil), ($c$$src$Core$$Cons)(((($0) => {
        return ($c$$src$List$$indexedMap)($zzz, $0);
      }))($recycledArgs), ($c$$src$Core$$Cons)(($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$AccessWithBrackets)(($u$$src$Targets$Javascript$Ast$$Literal)("0"), $u$$src$Targets$Javascript$EmittableToJs$$recycleTempVariable), $c$$src$Core$$Nil), $c$$src$Core$$Nil)))));
    }))());
});

const $u$$src$Targets$Javascript$EmittableToJs$$maybeOverrideUsr = (($env, $usr) => {
  const $3 = ($c$$src$Dict$$get)($usr, $env.overrides);
  return (((($3)[0] === "$Just") && ((($3)[1])[0] === "$Override"))
    ? ((() => {
      const $call = (($3)[1])[1].call;
      const $value = (($3)[1])[1].value;
      return ($value)($env);
    }))()
    : ((($3)[0] === "$Nothing")
      ? ($u$$src$Targets$Javascript$Ast$$Var)(($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)($usr))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 251:4', (sp_toHuman)($3))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$maybeOverrideUsrForConstructor = (($env, $usr) => {
  const $3 = ($c$$src$Dict$$get)($usr, $env.overrides);
  return (((($3)[0] === "$Just") && ((($3)[1])[0] === "$Override"))
    ? ((() => {
      const $call = (($3)[1])[1].call;
      const $value = (($3)[1])[1].value;
      return ($value)($env);
    }))()
    : ((($3)[0] === "$Nothing")
      ? ($u$$src$Targets$Javascript$Ast$$Var)(($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)($usr))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 258:4', (sp_toHuman)($3))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateExpression = (($env, $eaExpression) => {
  return (((($eaExpression)[0] === "$Variable") && ((($eaExpression)[1])[0] === "$RefLocal"))
    ? ((() => {
      const $name = (($eaExpression)[1])[1];
      return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Var)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name)));
    }))()
    : (((($eaExpression)[0] === "$Variable") && ((($eaExpression)[1])[0] === "$RefPlaceholder"))
      ? ((() => {
        const $n = (($eaExpression)[1])[1];
        return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Var)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)((text_fromNumber)($n))));
      }))()
      : (((($eaExpression)[0] === "$Variable") && ((($eaExpression)[1])[0] === "$RefGlobal"))
        ? ((() => {
          const $usr = (($eaExpression)[1])[1];
          return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$EmittableToJs$$maybeOverrideUsr)($env, $usr));
        }))()
        : ((($eaExpression)[0] === "$Call")
          ? ((() => {
            const $ref = ($eaExpression)[1];
            const $args = ($eaExpression)[2];
            const $maybeNativeOverride = (((($ref)[0] === "$Variable") && ((($ref)[1])[0] === "$RefGlobal"))
              ? ((() => {
                const $usr = (($ref)[1])[1];
                return ($c$$src$Dict$$get)($usr, $env.overrides);
              }))()
              : (true
                ? $c$$src$Maybe$$Nothing
                : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 433:16', (sp_toHuman)($ref))));
            return (((($maybeNativeOverride)[0] === "$Just") && ((($maybeNativeOverride)[1])[0] === "$Override"))
              ? ((() => {
                const $call = (($maybeNativeOverride)[1])[1].call;
                return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($call)($env, $args));
              }))()
              : ((($maybeNativeOverride)[0] === "$Nothing")
                ? ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$EmittableToJs$$makeCall)($env, ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $ref), $args))
                : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 437:12', (sp_toHuman)($maybeNativeOverride))));
          }))()
          : ((($eaExpression)[0] === "$Fn")
            ? ((() => {
              const $eaArgs = ($eaExpression)[1];
              const $body = ($eaExpression)[2];
              const $argsWithNames = ((() => {
                const $zzz = (($index, $3) => {
                  const $re = $3.first;
                  const $maybeName = $3.second;
                  return ((($maybeName)[0] === "$Just")
                    ? ((() => {
                      const $name = ($maybeName)[1];
                      return ({
                        first: $re,
                        second: ($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name),
                      });
                    }))()
                    : ((($maybeName)[0] === "$Nothing")
                      ? ({
                        first: $re,
                        second: ("_" + (text_fromNumber)($index)),
                      })
                      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 445:20', (sp_toHuman)($maybeName))));
                });
                return ($c$$src$List$$indexedMap)($zzz, $eaArgs);
              }))();
              const $recycledPars = ((($0) => {
                return ($c$$src$List$$map)((($4) => {
                  const $name = $4.second;
                  return ($u$$src$Targets$Javascript$Ast$$Var)($name);
                }), $0);
              }))(((($0) => {
                return ($c$$src$List$$filter)($c$$src$Tuple$$first, $0);
              }))($argsWithNames));
              const $statementsRaw = ((() => {
                const $3 = ($u$$src$Targets$Javascript$EmittableToJs$$translateExpression)($env, $body);
                return ((($3)[0] === "$Inline")
                  ? ((() => {
                    const $expr = ($3)[1];
                    return ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Return)($expr), $c$$src$Core$$Nil);
                  }))()
                  : ((($3)[0] === "$Block")
                    ? ((() => {
                      const $block = ($3)[1];
                      return $block;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 457:16', (sp_toHuman)($3))));
              }))();
              const $statementsFinal = ((sp_equal)($recycledPars, $c$$src$Core$$Nil)
                ? $statementsRaw
                : ((() => {
                  const $addRecycled = (($stat) => {
                    return ((($stat)[0] === "$Return")
                      ? ((() => {
                        const $e = ($stat)[1];
                        return ($u$$src$Targets$Javascript$Ast$$Return)(($u$$src$Targets$Javascript$Ast$$Array)((sp_cons)($e, $recycledPars)));
                      }))()
                      : (true
                        ? $stat
                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 471:24', (sp_toHuman)($stat))));
                  });
                  return ($c$$src$List$$map)($addRecycled, $statementsRaw);
                }))());
              return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$BlockLambda)(($c$$src$List$$map)($c$$src$Tuple$$second, $argsWithNames), $statementsFinal));
            }))()
            : ((($eaExpression)[0] === "$LetIn")
              ? ((() => {
                const $inExpression = ($eaExpression)[1].inExpression;
                const $letExpression = ($eaExpression)[1].letExpression;
                const $maybeName = ($eaExpression)[1].maybeName;
                const $type = ($eaExpression)[1].type;
                const $inStatements = ((() => {
                  const $3 = ($u$$src$Targets$Javascript$EmittableToJs$$translateExpression)($env, $inExpression);
                  return ((($3)[0] === "$Block")
                    ? ((() => {
                      const $stats = ($3)[1];
                      return $stats;
                    }))()
                    : ((($3)[0] === "$Inline")
                      ? ((() => {
                        const $jaExpression = ($3)[1];
                        return ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Return)($jaExpression), $c$$src$Core$$Nil);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 481:16', (sp_toHuman)($3))));
                }))();
                return ((($maybeName)[0] === "$Nothing")
                  ? ((() => {
                    const $3 = ($u$$src$Targets$Javascript$EmittableToJs$$translateExpression)($env, $letExpression);
                    return ((($3)[0] === "$Inline")
                      ? ((() => {
                        const $expr = ($3)[1];
                        return ($u$$src$Targets$Javascript$EmittableToJs$$Block)((sp_cons)(($u$$src$Targets$Javascript$Ast$$Eval)($expr), $inStatements));
                      }))()
                      : ((($3)[0] === "$Block")
                        ? ((() => {
                          const $stats = ($3)[1];
                          return ($u$$src$Targets$Javascript$EmittableToJs$$Block)(($c$$src$List$$concat)(($c$$src$Core$$Cons)($stats, ($c$$src$Core$$Cons)($inStatements, $c$$src$Core$$Nil))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 488:20', (sp_toHuman)($3))));
                  }))()
                  : ((($maybeName)[0] === "$Just")
                    ? ((() => {
                      const $name = ($maybeName)[1];
                      const $letStatement = ((($0) => {
                        return ($u$$src$Targets$Javascript$Ast$$Define)((sp_equal)($type.uni, $c$$src$Compiler$Ast$$Uni), ($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name), $0);
                      }))(((($0) => {
                        return ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $0);
                      }))($letExpression));
                      return ($u$$src$Targets$Javascript$EmittableToJs$$Block)((sp_cons)($letStatement, $inStatements));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 485:12', (sp_toHuman)($maybeName))));
              }))()
              : ((($eaExpression)[0] === "$LiteralText")
                ? ((() => {
                  const $string = ($eaExpression)[1];
                  return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$EmittableToJs$$literalString)($string));
                }))()
                : ((($eaExpression)[0] === "$LiteralNumber")
                  ? ((() => {
                    const $num = ($eaExpression)[1];
                    return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Literal)((text_fromNumber)($num)));
                  }))()
                  : ((($eaExpression)[0] === "$Conditional")
                    ? ((() => {
                      const $test = ($eaExpression)[1];
                      const $true = ($eaExpression)[2];
                      const $false = ($eaExpression)[3];
                      return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Conditional)(($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $test), ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $true), ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $false)));
                    }))()
                    : ((($eaExpression)[0] === "$And")
                      ? ((() => {
                        const $eaTests = ($eaExpression)[1];
                        const $jaTests = ($c$$src$List$$map)((($0) => {
                          return ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $0);
                        }), $eaTests);
                        const $3 = ($c$$src$List$$reverse)($jaTests);
                        return ((($3)[0] === "$Nil")
                          ? ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Literal)("true"))
                          : ((($3)[0] === "$Cons")
                            ? ((() => {
                              const $head = ($3)[1];
                              const $tail = ($3)[2];
                              return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(((($0) => {
                                return ($c$$src$List$$for)($0, $tail, (($test, $expr) => {
                                  return ($u$$src$Targets$Javascript$Ast$$Binop)("&&", $test, $expr);
                                }));
                              }))($head));
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 515:12', (sp_toHuman)($3))));
                      }))()
                      : ((($eaExpression)[0] === "$ShallowEqual")
                        ? ((() => {
                          const $a = ($eaExpression)[1];
                          const $b = ($eaExpression)[2];
                          return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Binop)("===", ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $a), ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $b)));
                        }))()
                        : ((($eaExpression)[0] === "$LiteralArray")
                          ? ((() => {
                            const $items = ($eaExpression)[1];
                            return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Array)(((($0) => {
                              return ($c$$src$List$$map)((($0) => {
                                return ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $0);
                              }), $0);
                            }))($items)));
                          }))()
                          : ((($eaExpression)[0] === "$ArrayAccess")
                            ? ((() => {
                              const $index = ($eaExpression)[1];
                              const $array = ($eaExpression)[2];
                              return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(((($0) => {
                                return ($u$$src$Targets$Javascript$EmittableToJs$$accessArrayIndex)($index, $0);
                              }))(((($0) => {
                                return ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $0);
                              }))($array)));
                            }))()
                            : ((($eaExpression)[0] === "$Constructor")
                              ? ((() => {
                                const $usr = ($eaExpression)[1];
                                return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$EmittableToJs$$maybeOverrideUsrForConstructor)($env, $usr));
                              }))()
                              : ((($eaExpression)[0] === "$ConstructorAccess")
                                ? ((() => {
                                  const $argIndex = ($eaExpression)[1];
                                  const $value = ($eaExpression)[2];
                                  return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$EmittableToJs$$accessArrayIndex)(($argIndex + 1), ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $value)));
                                }))()
                                : ((($eaExpression)[0] === "$IsConstructor")
                                  ? ((() => {
                                    const $usr = ($eaExpression)[1];
                                    const $eaValue = ($eaExpression)[2];
                                    const $jaValue = ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $eaValue);
                                    return ((sp_equal)($usr, $u$$src$Compiler$CoreDefs$$noneConsUsr)
                                      ? ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Var)("true"))
                                      : ((sp_equal)($usr, $u$$src$Compiler$CoreDefs$$trueUsr)
                                        ? ($u$$src$Targets$Javascript$EmittableToJs$$Inline)($jaValue)
                                        : ((sp_equal)($usr, $u$$src$Compiler$CoreDefs$$falseUsr)
                                          ? ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Unop)("!", $jaValue))
                                          : ((() => {
                                            const $3 = $usr;
                                            const $name = ($3)[2];
                                            return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(((($0) => {
                                              return ($u$$src$Targets$Javascript$Ast$$Binop)("===", ($u$$src$Targets$Javascript$EmittableToJs$$accessArrayIndex)(0, $jaValue), $0);
                                            }))(($u$$src$Targets$Javascript$EmittableToJs$$literalString)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name))));
                                          }))())));
                                  }))()
                                  : ((($eaExpression)[0] === "$LiteralRecord")
                                    ? ((() => {
                                      const $maybeExtend = ($eaExpression)[1];
                                      const $attrNamesAndValues = ($eaExpression)[2];
                                      const $obj = ($u$$src$Targets$Javascript$Ast$$Record)(((($0) => {
                                        return ($c$$src$List$$for)($0, $attrNamesAndValues, (($5, $d) => {
                                          const $name = $5.first;
                                          const $value = $5.second;
                                          return ($c$$src$Dict$$insert)($name, ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $value), $d);
                                        }));
                                      }))($c$$src$Dict$$empty));
                                      return ((($maybeExtend)[0] === "$Nothing")
                                        ? ($u$$src$Targets$Javascript$EmittableToJs$$Inline)($obj)
                                        : ((($maybeExtend)[0] === "$Just")
                                          ? ((() => {
                                            const $extend = ($maybeExtend)[1];
                                            return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$Call)(($u$$src$Targets$Javascript$Ast$$Var)("Object.assign"), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Record)($c$$src$Dict$$empty), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $extend), ($c$$src$Core$$Cons)($obj, $c$$src$Core$$Nil)))));
                                          }))()
                                          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 573:12', (sp_toHuman)($maybeExtend))));
                                    }))()
                                    : ((($eaExpression)[0] === "$RecordAccess")
                                      ? ((() => {
                                        const $attrName = ($eaExpression)[1];
                                        const $value = ($eaExpression)[2];
                                        return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(($u$$src$Targets$Javascript$Ast$$AccessWithDot)($attrName, ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $value)));
                                      }))()
                                      : ((($eaExpression)[0] === "$MissingPattern")
                                        ? ((() => {
                                          const $location = ($eaExpression)[1];
                                          const $value = ($eaExpression)[2];
                                          return ($u$$src$Targets$Javascript$EmittableToJs$$Inline)(((($0) => {
                                            return ($u$$src$Targets$Javascript$Ast$$Call)(($u$$src$Targets$Javascript$Ast$$Literal)("sp_throw"), $0);
                                          }))(($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Literal)("'Missing pattern in try..as'"), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Literal)(("'" + ($location + "'"))), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$Ast$$Call)(($u$$src$Targets$Javascript$Ast$$Literal)("sp_toHuman"), ($c$$src$Core$$Cons)(($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $value), $c$$src$Core$$Nil)), $c$$src$Core$$Nil)))));
                                        }))()
                                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 413:4', (sp_toHuman)($eaExpression)))))))))))))))))))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression = (($env, $expr) => {
  const $3 = ($u$$src$Targets$Javascript$EmittableToJs$$translateExpression)($env, $expr);
  return ((($3)[0] === "$Inline")
    ? ((() => {
      const $e = ($3)[1];
      return $e;
    }))()
    : ((($3)[0] === "$Block")
      ? ((() => {
        const $block = ($3)[1];
        return ($u$$src$Targets$Javascript$Ast$$Call)(($u$$src$Targets$Javascript$Ast$$BlockLambda)($c$$src$Core$$Nil, $block), $c$$src$Core$$Nil);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 351:4', (sp_toHuman)($3))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateArg = (($stuff, $env, $eaExpression) => {
  return ((($eaExpression)[0] === "$ArgumentSpend")
    ? ((() => {
      const $fullType = ($eaExpression)[1];
      const $e = ($eaExpression)[2];
      return ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $e);
    }))()
    : ((($eaExpression)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $rawType = ($eaExpression)[1];
        const $attrPath = ($eaExpression)[2];
        const $name = ($eaExpression)[3];
        return ($u$$src$Targets$Javascript$EmittableToJs$$accessAttrs)($attrPath, ($u$$src$Targets$Javascript$Ast$$Var)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)($name)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 276:4', (sp_toHuman)($eaExpression))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$binop = (($jsOp) => {
  return ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
    call: (($env, $arguments) => {
      return (((($arguments)[0] === "$Cons") && (((($arguments)[2])[0] === "$Cons") && (((($arguments)[2])[2])[0] === "$Nil")))
        ? ((() => {
          const $right = ($arguments)[1];
          const $left = (($arguments)[2])[1];
          return ($u$$src$Targets$Javascript$Ast$$Binop)($jsOp, ($u$$src$Targets$Javascript$EmittableToJs$$translateArg)(({
            nativeBinop: true,
          }), $env, $right), ($u$$src$Targets$Javascript$EmittableToJs$$translateArg)(({
            nativeBinop: true,
          }), $env, $left));
        }))()
        : (true
          ? (sp_todo)(("compiler bug: wrong number of arguments for binop" + (sp_toHuman)(({
            arguments: $arguments,
            jsOp: $jsOp,
          }))))
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 144:8', (sp_toHuman)($arguments))));
    }),
    value: (($env) => {
      return (sp_todo)(("binop " + ($jsOp + " has no raw value")));
    }),
  }));
});

const $u$$src$Targets$Javascript$EmittableToJs$$constructor = (($jsValue) => {
  return ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
    call: (($env, $args) => {
      return ($u$$src$Targets$Javascript$EmittableToJs$$makeCall)($env, ($u$$src$Targets$Javascript$Ast$$Var)($jsValue), $args);
    }),
    value: (($env) => {
      return ($u$$src$Targets$Javascript$Ast$$Var)($jsValue);
    }),
  }));
});

const $u$$src$Targets$Javascript$EmittableToJs$$function = (($jaName) => {
  return ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
    call: (($env, $args) => {
      return ($u$$src$Targets$Javascript$EmittableToJs$$makeCall)($env, ($u$$src$Targets$Javascript$Ast$$Var)($jaName), $args);
    }),
    value: (($env) => {
      return ($u$$src$Targets$Javascript$Ast$$Var)($jaName);
    }),
  }));
});

const $u$$src$Targets$Javascript$EmittableToJs$$introspectOverride = ((() => {
  const $call = (($env, $eaArgs) => {
    return (((($eaArgs)[0] === "$Cons") && (((($eaArgs)[1])[0] === "$ArgumentSpend") && ((($eaArgs)[2])[0] === "$Nil")))
      ? ((() => {
        const $raw = (($eaArgs)[1])[1].raw;
        const $e = (($eaArgs)[1])[2];
        const $expression = ($u$$src$Targets$Javascript$Ast$$Literal)((JSON.stringify)($e));
        const $type = ($u$$src$Targets$Javascript$Ast$$Literal)((JSON.stringify)($raw));
        const $nonFn = ($u$$src$Targets$Javascript$Ast$$Array)($c$$src$Core$$Nil);
        const $value = ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $e);
        return ($u$$src$Targets$Javascript$Ast$$Record)(($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
          first: "expression",
          second: $expression,
        }), ($c$$src$Core$$Cons)(({
          first: "raw",
          second: $type,
        }), ($c$$src$Core$$Cons)(({
          first: "nonFn",
          second: $nonFn,
        }), ($c$$src$Core$$Cons)(({
          first: "value",
          second: $value,
        }), $c$$src$Core$$Nil))))));
      }))()
      : (true
        ? (sp_todo)("introspectOverride BUG?!")
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 176:8', (sp_toHuman)($eaArgs))));
  });
  return ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
    call: $call,
    value: (($env) => {
      return (sp_todo)("TODO: monomorphization is not yet implemented so `introspect` can only be called directly");
    }),
  }));
}))();

const $u$$src$Targets$Javascript$EmittableToJs$$loadOverride = ((() => {
  const $call = (($env, $eaArgs) => {
    const $jaArgs = ($c$$src$List$$map)((($0) => {
      return ($u$$src$Targets$Javascript$EmittableToJs$$translateArg)(({
        nativeBinop: false,
      }), $env, $0);
    }), $eaArgs);
    const $requestedTypeHumanized = (((($eaArgs)[0] === "$Cons") && (((($eaArgs)[2])[0] === "$Cons") && ((((($eaArgs)[2])[1])[0] === "$ArgumentSpend") && (((((($eaArgs)[2])[1])[1].raw)[0] === "$TypeFn") && ((((((($eaArgs)[2])[1])[1].raw)[1])[0] === "$Cons") && (((((((($eaArgs)[2])[1])[1].raw)[1])[1])[0] === "$ParSp") && (((((((($eaArgs)[2])[1])[1].raw)[1])[2])[0] === "$Nil") && (((($eaArgs)[2])[2])[0] === "$Nil"))))))))
      ? ((() => {
        const $compiledProgram = ($eaArgs)[1];
        const $compiledType = (((((($eaArgs)[2])[1])[1].raw)[1])[1])[1].raw;
        let $hash = (hash_fromList)($c$$src$Core$$Nil);
        return ($u$$src$Targets$Javascript$EmittableToJs$$literalString)((sp_toHuman)(((($0) => {
          return ((__re__ = ($c$$src$Compiler$TypedAst$$normalizeType)($hash, $0)), ($hash = (__re__)[1]), (__re__)[0]);
        }))($compiledType)));
      }))()
      : (true
        ? (sp_todo)("loadOverride BUG?!")
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 222:12', (sp_toHuman)($eaArgs))));
    return ($u$$src$Targets$Javascript$Ast$$Call)(($u$$src$Targets$Javascript$Ast$$Var)("self_load"), ($c$$src$Core$$Cons)($requestedTypeHumanized, $jaArgs));
  });
  return ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
    call: $call,
    value: (($env) => {
      return (sp_todo)("TODO: load as value... I guess we need monomorphization?");
    }),
  }));
}))();

const $u$$src$Targets$Javascript$EmittableToJs$$unaryMinus = ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
  call: (($env, $arguments) => {
    return (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentSpend") && ((($arguments)[2])[0] === "$Nil")))
      ? ((() => {
        const $fullType = (($arguments)[1])[1];
        const $arg = (($arguments)[1])[2];
        return ($u$$src$Targets$Javascript$Ast$$Unop)("-", ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $arg));
      }))()
      : (true
        ? (sp_todo)("compiler bug: wrong number of arguments for unop")
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 126:8', (sp_toHuman)($arguments))));
  }),
  value: (($env) => {
    return (sp_todo)("unaryMinus has no raw value");
  }),
}));

const $u$$src$Targets$Javascript$EmittableToJs$$unaryPlus = ($u$$src$Targets$Javascript$EmittableToJs$$Override)(({
  call: (($env, $arguments) => {
    return (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentSpend") && ((($arguments)[2])[0] === "$Nil")))
      ? ((() => {
        const $fullType = (($arguments)[1])[1];
        const $arg = (($arguments)[1])[2];
        return ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $arg);
      }))()
      : (true
        ? (sp_todo)("compiler bug: wrong number of arguments for unop")
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 109:8', (sp_toHuman)($arguments))));
  }),
  value: (($env) => {
    return (sp_todo)("unaryPlus has no raw value");
  }),
}));

const $u$$src$Targets$Javascript$EmittableToJs$$coreOverrides = ((_0) => {
  const $corelib = (($module, $name) => {
    return ($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$CoreDefs$$importsPath, "src", $module), $name);
  });
  return ($c$$src$Dict$$fromList)(($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$unaryPlus.usr,
    second: $u$$src$Targets$Javascript$EmittableToJs$$unaryPlus,
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$unaryMinus.usr,
    second: $u$$src$Targets$Javascript$EmittableToJs$$unaryMinus,
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$add.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("+"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$multiply.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("*"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$subtract.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("-"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$mutableAssign.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("="),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$mutableAdd.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("+="),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$mutableSubtract.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("-="),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$textConcat.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("+"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$greaterThan.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)(">"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$lesserThan.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("<"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$greaterOrEqualThan.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)(">="),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$lesserOrEqualThan.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("<="),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$or_.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("||"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$and_.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$binop)("&&"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$trueUsr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$constructor)("true"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$falseUsr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$constructor)("false"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$noneConsUsr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$constructor)("null"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$divide.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_divide"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$listCons.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_cons"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$equal.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_equal"),
  }), ($c$$src$Core$$Cons)(({
    first: $u$$src$Compiler$CoreDefs$$notEqual.usr,
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_not_equal"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Basics", "modBy"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("basics_modBy"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Basics", "round"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("Math.round"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Basics", "cloneImm"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("basics_cloneImm"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Basics", "cloneUni"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("basics_cloneUni"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Basics", "compare"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("basics_compare"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Debug", "log"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_log"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Debug", "todo"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_todo"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Debug", "toHuman"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_toHuman"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Debug", "benchStart"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_benchStart"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Debug", "benchStop"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("sp_benchStop"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "fromNumber"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_fromNumber"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "toLower"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_toLower"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "toUpper"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_toUpper"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "toNumber"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_toNumber"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "split"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_split"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "length"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_length"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "slice"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_slice"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "startsWith"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_startsWith"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "startsWithRegex"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_startsWithRegex"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "replaceRegex"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_replaceRegex"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "trimLeft"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_trimLeft"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "dropLeft"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_dropLeft"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Text", "forEach"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("text_forEach"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "fromList"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_fromList"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "insert"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_insert"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "remove"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_remove"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "get"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_get"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "for"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_for"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "each"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_each"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Hash", "pop"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("hash_pop"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "each"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_each"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "push"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_push"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "pop"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_pop"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "get"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_get"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "set"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_set"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "sortBy"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_sortBy"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "fromList"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_fromList"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Array", "toList"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("array_toList"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("List", "sortBy"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("list_sortBy"),
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Self", "load"),
    second: $u$$src$Targets$Javascript$EmittableToJs$$loadOverride,
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Self", "introspect"),
    second: $u$$src$Targets$Javascript$EmittableToJs$$introspectOverride,
  }), ($c$$src$Core$$Cons)(({
    first: ($corelib)("Self", "internalRepresentation"),
    second: ($u$$src$Targets$Javascript$EmittableToJs$$function)("JSON.stringify"),
  }), $c$$src$Core$$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$constructorArgumentName = (($i) => {
  return ("$" + (text_fromNumber)($i));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateConstructorDef = (($1) => {
  const $usr = $1.first;
  const $taType = $1.second;
  const $2 = $usr;
  const $nameWithApostrophe = ($2)[2];
  const $umr = ($2)[1];
  const $arrayHead = ($u$$src$Targets$Javascript$EmittableToJs$$literalString)(($u$$src$Targets$Javascript$EmittableToJs$$translateName)($nameWithApostrophe));
  const $definitionBody = ((($taType)[0] === "$TypeFn")
    ? ((() => {
      const $pars = ($taType)[1];
      const $out = ($taType)[2];
      const $argNames = ((($0) => {
        return ($c$$src$List$$indexedMap)((($index, $name) => {
          return ($u$$src$Targets$Javascript$EmittableToJs$$constructorArgumentName)(($index + 1));
        }), $0);
      }))($pars);
      return ((($0) => {
        return ($u$$src$Targets$Javascript$Ast$$SimpleLambda)($argNames, $0);
      }))(($u$$src$Targets$Javascript$Ast$$Array)((sp_cons)($arrayHead, ($c$$src$List$$map)($u$$src$Targets$Javascript$Ast$$Var, $argNames))));
    }))()
    : (true
      ? ($u$$src$Targets$Javascript$Ast$$Array)(($c$$src$Core$$Cons)($arrayHead, $c$$src$Core$$Nil))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 612:8', (sp_toHuman)($taType))));
  return ($u$$src$Targets$Javascript$Ast$$Define)(false, ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)($usr), $definitionBody);
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateDef = (($env, $def) => {
  const $3 = ($c$$src$Dict$$get)($def.usr, $env.overrides);
  return ((($3)[0] === "$Just")
    ? $c$$src$Maybe$$Nothing
    : ((($3)[0] === "$Nothing")
      ? ($c$$src$Maybe$$Just)(($u$$src$Targets$Javascript$Ast$$Define)(false, ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)($def.usr), ($u$$src$Targets$Javascript$EmittableToJs$$translateExpressionToExpression)($env, $def.expr)))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 630:4', (sp_toHuman)($3))));
});

const $u$$src$Targets$Javascript$EmittableToJs$$translateAll = (($pars) => {
  const $2 = $pars;
  const $platformOverrides = $2.platformOverrides;
  const $eaDefs = $2.eaDefs;
  const $constructors = $2.constructors;
  const $jaConstructors = ($c$$src$List$$map)((($0) => {
    return ($u$$src$Targets$Javascript$EmittableToJs$$translateConstructorDef)($0);
  }), $constructors);
  const $env = ({
    overrides: ($c$$src$List$$for)(($u$$src$Targets$Javascript$EmittableToJs$$coreOverrides)(null), $platformOverrides, (($4, $d) => {
      const $usr = $4.first;
      const $runtimeName = $4.second;
      return ($c$$src$Dict$$insert)($usr, ($u$$src$Targets$Javascript$EmittableToJs$$function)($runtimeName), $d);
    })),
  });
  const $jaStatements = ($c$$src$List$$filterMap)((($0) => {
    return ($u$$src$Targets$Javascript$EmittableToJs$$translateDef)($env, $0);
  }), $eaDefs);
  return ($c$$src$List$$concat)(($c$$src$Core$$Cons)($jaConstructors, ($c$$src$Core$$Cons)($jaStatements, $c$$src$Core$$Nil)));
});

const $u$$src$Targets$Javascript$JsToText$$id = (($level) => {
  return ($c$$src$Text$$repeat)($level, "  ");
});

const $u$$src$Targets$Javascript$JsToText$$emitBlock = (($l, $block) => {
  const $lines = ((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($0) => {
      return ($u$$src$Targets$Javascript$JsToText$$emitStatement)(($l + 1), $0);
    }), $0);
  }))($block));
  return ("{\n" + ($lines + ("\n" + (($u$$src$Targets$Javascript$JsToText$$id)($l) + "}"))));
});

const $u$$src$Targets$Javascript$JsToText$$emitExpr = (($l, $expression) => {
  return ((($expression)[0] === "$Literal")
    ? ((() => {
      const $s = ($expression)[1];
      return $s;
    }))()
    : ((($expression)[0] === "$Var")
      ? ((() => {
        const $n = ($expression)[1];
        return $n;
      }))()
      : ((($expression)[0] === "$Call")
        ? ((() => {
          const $ref = ($expression)[1];
          const $args = ($expression)[2];
          return ("(" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $ref) + (")(" + (($c$$src$Text$$join)(", ", ($c$$src$List$$map)((($0) => {
            return ($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $0);
          }), $args)) + ")"))));
        }))()
        : ((($expression)[0] === "$Unop")
          ? ((() => {
            const $op = ($expression)[1];
            const $left = ($expression)[2];
            return ($op + ("(" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $left) + ")")));
          }))()
          : ((($expression)[0] === "$Binop")
            ? ((() => {
              const $op = ($expression)[1];
              const $left = ($expression)[2];
              const $right = ($expression)[3];
              return ("(" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $left) + (" " + ($op + (" " + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $right) + ")"))))));
            }))()
            : ((($expression)[0] === "$Mutop")
              ? ((() => {
                const $op = ($expression)[1];
                const $yield = ($expression)[2];
                const $left = ($expression)[3];
                const $right = ($expression)[4];
                return ("(" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $left) + (" " + ($op + (" " + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $right) + (", " + ($yield + ")"))))))));
              }))()
              : ((($expression)[0] === "$SimpleLambda")
                ? ((() => {
                  const $params = ($expression)[1];
                  const $expr = ($expression)[2];
                  return ("((" + (($c$$src$Text$$join)(", ", $params) + (") => " + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $expr) + ")"))));
                }))()
                : ((($expression)[0] === "$BlockLambda")
                  ? ((() => {
                    const $params = ($expression)[1];
                    const $stats = ($expression)[2];
                    return ("((" + (($c$$src$Text$$join)(", ", $params) + (") => " + (($u$$src$Targets$Javascript$JsToText$$emitBlock)($l, $stats) + ")"))));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $attrs = ($expression)[1];
                      return ((sp_equal)($attrs, $c$$src$Dict$$empty)
                        ? "{}"
                        : ((($a) => {
                          return ("({\n" + (($c$$src$Text$$join)("\n", $a) + ("\n" + (($u$$src$Targets$Javascript$JsToText$$id)($l) + "})"))));
                        }))(((($0) => {
                          return ($c$$src$List$$map)((($4) => {
                            const $key = $4.first;
                            const $value = $4.second;
                            return (($u$$src$Targets$Javascript$JsToText$$id)(($l + 1)) + ($key + (": " + (($u$$src$Targets$Javascript$JsToText$$emitExpr)(($l + 1), $value) + ","))));
                          }), $0);
                        }))(((($0) => {
                          return (list_sortBy)($c$$src$Tuple$$first, $0);
                        }))(($c$$src$Dict$$toList)($attrs)))));
                    }))()
                    : ((($expression)[0] === "$AccessWithDot")
                      ? ((() => {
                        const $name = ($expression)[1];
                        const $e = ($expression)[2];
                        return (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $e) + ("." + $name));
                      }))()
                      : ((($expression)[0] === "$AccessWithBrackets")
                        ? ((() => {
                          const $i = ($expression)[1];
                          const $expr = ($expression)[2];
                          return ("(" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $expr) + (")[" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $i) + "]"))));
                        }))()
                        : ((($expression)[0] === "$Conditional")
                          ? ((() => {
                            const $p = ($expression)[1];
                            const $true = ($expression)[2];
                            const $false = ($expression)[3];
                            return (("(" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $p) + "\n")) + ((($u$$src$Targets$Javascript$JsToText$$id)(($l + 1)) + ("? " + ($u$$src$Targets$Javascript$JsToText$$emitExpr)(($l + 1), $true))) + ("\n" + ((($u$$src$Targets$Javascript$JsToText$$id)(($l + 1)) + (": " + ($u$$src$Targets$Javascript$JsToText$$emitExpr)(($l + 1), $false))) + ")"))));
                          }))()
                          : ((($expression)[0] === "$Array")
                            ? ((() => {
                              const $items = ($expression)[1];
                              return ((sp_equal)($items, $c$$src$Core$$Nil)
                                ? "[]"
                                : ((($0) => {
                                  return ((($a) => {
                                    return ("([\n" + (($c$$src$Text$$join)("\n", $a) + ("\n" + (($u$$src$Targets$Javascript$JsToText$$id)($l) + "])"))));
                                  }))($0);
                                }))(((($0) => {
                                  return ($c$$src$List$$map)((($i) => {
                                    return (($u$$src$Targets$Javascript$JsToText$$id)(($l + 1)) + (($u$$src$Targets$Javascript$JsToText$$emitExpr)(($l + 1), $i) + ","));
                                  }), $0);
                                }))($items)));
                            }))()
                            : ((($expression)[0] === "$Comma")
                              ? ((() => {
                                const $expr = ($expression)[1];
                                return ("(" + (($c$$src$Text$$join)(", ", ($c$$src$List$$map)((($0) => {
                                  return ($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $0);
                                }), $expr)) + ")"));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/JsToText.sp 43:4', (sp_toHuman)($expression))))))))))))))));
});

const $u$$src$Targets$Javascript$JsToText$$emitStatement = (($l, $stat) => {
  const $std = (($mid, $expr) => {
    return (($u$$src$Targets$Javascript$JsToText$$id)($l) + ($mid + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $expr) + ";")));
  });
  return ((($stat)[0] === "$Eval")
    ? ((() => {
      const $e = ($stat)[1];
      return ($std)("", $e);
    }))()
    : ((($stat)[0] === "$Return")
      ? ((() => {
        const $e = ($stat)[1];
        return ($std)("return ", $e);
      }))()
      : ((($stat)[0] === "$Define")
        ? ((() => {
          const $isReassignable = ($stat)[1];
          const $name = ($stat)[2];
          const $e = ($stat)[3];
          const $modifier = ($isReassignable
            ? "let"
            : "const");
          return ($std)(($modifier + (" " + ($name + " = "))), $e);
        }))()
        : ((($stat)[0] === "$If")
          ? ((() => {
            const $condition = ($stat)[1];
            const $block = ($stat)[2];
            return (($u$$src$Targets$Javascript$JsToText$$id)($l) + ("if (" + (($u$$src$Targets$Javascript$JsToText$$emitExpr)($l, $condition) + (") " + ($u$$src$Targets$Javascript$JsToText$$emitBlock)($l, $block)))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/JsToText.sp 12:4', (sp_toHuman)($stat))))));
});

const $u$$src$Targets$Javascript$Runtime$$justRef = ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)(($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$CoreDefs$$importsPath, "src", "Maybe"), "'just"));

const $u$$src$Targets$Javascript$Runtime$$listConsName = ($u$$src$Targets$Javascript$EmittableToJs$$translateName)($u$$src$Compiler$CoreDefs$$consName);

const $u$$src$Targets$Javascript$Runtime$$listNilName = ($u$$src$Targets$Javascript$EmittableToJs$$translateName)($u$$src$Compiler$CoreDefs$$nilName);

const $u$$src$Targets$Javascript$Runtime$$nothingRef = ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)(($c$$src$Compiler$Meta$$USR)(($c$$src$Compiler$Meta$$UMR)($u$$src$Compiler$CoreDefs$$importsPath, "src", "Maybe"), "'nothing"));

const $u$$src$Targets$Javascript$Runtime$$nativeDefinitions = ("let __re__;\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a, b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i], b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k], b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a, b) => {\n  return !sp_equal(a, b);\n}\n\n\nconst basics_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = basics_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = basics_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (left, right) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\n// TODO remove this and handle it like any other op?\nconst basics_modBy = (a, b) => b % a;\n\n\nconst basics_cloneImm = sp_clone;\n\n\nconst basics_cloneUni = (uni) =>\n    [ sp_clone(uni), uni ];\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message, thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\n// TODO how should benchmark work in a browser?\ntypeof process !== 'undefined' && process.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.error(\"\");\n        console.error(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.error(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst id = (n) => '    '.repeat(n);\n\n\nconst sp_toHuman = (a, l = 0) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a, l) || sp_toHumanAsDict(a, l) || sp_toHumanAsUnion(a, l);\n\n  if (typeof a === 'function') {\n    return '<fn ' + a.length + '>';\n  }\n\n  if (typeof a === 'object') {\n    let acc = '{\\n';\n    for (let key in a)\n        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\\n';\n\n    return acc + id(l) + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a, l) => {\n\n  if (a.length === 1) {\n      return a[0];\n  }\n\n  let acc = a[0] + '\\n';\n\n  a.slice(1).forEach(arg => {\n\n      const sub = sp_toHuman(arg, l + 1);\n      if (!sub.startsWith('{') && sub.indexOf('\\n') > -1)\n          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\\n';\n      else\n          acc += id(l + 1) + sub + '\\n';\n\n  })\n\n  return acc;\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list, l) => {\n  if (list[0] === '" + ($u$$src$Targets$Javascript$Runtime$$listConsName + ("' && list.length === 3) {\n    arrayAccum.push(sp_toHuman(list[1], l));\n    return sp_toHumanAsList(arrayAccum, list[2], l);\n  }\n\n  if (list[0] === '" + ($u$$src$Targets$Javascript$Runtime$$listNilName + ("')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\nconst sp_toHumanAsDict = (dict, l) => {\n  if (dict[0] === 'RBNode_elm_builtin') {\n      return 'DICT' + sp_toHumanAsList([], $core$Dict$toList(dict), l);\n  }\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ? " + ($u$$src$Targets$Javascript$Runtime$$nothingRef + (" : " + ($u$$src$Targets$Javascript$Runtime$$justRef + ("(n);\n    }\n\n    const text_toLower = (s) => s.toLowerCase()\n\n    const text_toUpper = (s) => s.toUpperCase()\n\n    const text_split = (separator, target) => arrayToListLow(target.split(separator));\n\n    const text_length = (s) => s.length;\n\n    const text_slice = (start, end, s) => s.slice(start, end);\n\n    const text_startsWith = (sub, s) => s.startsWith(sub);\n\n    const text_startsWithRegex = (regex) => {\n      let re;\n      try {\n        re = new RegExp('^' + regex, 's');\n      } catch (e) {\n        return () => \"\"\n      }\n\n      return (s) => {\n        let m = s.match(re);\n        return m ? m[0] : \"\";\n      }\n    }\n\n    const text_replaceRegex = (regex) => {\n      let re;\n      try {\n        re = new RegExp(regex, 'g');\n      } catch (e) {\n        return () => \"\"\n      }\n\n      return (replacer, s) => s.replace(re, replacer);\n    }\n\n    const text_trimLeft = (s) => s.trimLeft();\n\n    const text_dropLeft = (n, s) => s.slice(n);\n\n    const text_forEach = (s, f) => {\n      for (let i of s) f(i);\n      return null;\n    }\n\n\n    //\n    // Hashes\n    //\n\n    const hash_pop = (hash) => {\n        for (let key in hash) {\n            const [actualKey, value] = hash[key];\n            delete hash[key];\n            return [ " + ($u$$src$Targets$Javascript$Runtime$$justRef + ("({ first: actualKey, second: value }), hash ];\n        }\n\n        return [ " + ($u$$src$Targets$Javascript$Runtime$$nothingRef + (", hash ];\n    }\n\n\n    const hash_fromList = (list) => {\n      const hash = {};\n\n      // TODO iteration instead of recursion\n      const rec = (ls) => {\n        if (ls[0] === '" + ($u$$src$Targets$Javascript$Runtime$$listNilName + ("')\n          return hash;\n\n        const { first, second } = ls[1];\n\n        hash[JSON.stringify(first)] = [first, second];\n\n        return rec(ls[2]);\n      };\n\n      return rec(list);\n    }\n\n\n    const hash_insert = (hash, key, value) => {\n        hash[JSON.stringify(key)] = [key, value];\n        return [null, hash];\n    }\n\n\n    const hash_remove = (hash, key) => {\n        delete hash[JSON.stringify(key)];\n        return [null, hash];\n    }\n\n\n    const hash_get = (hash, key) => {\n        const r = hash[JSON.stringify(key)];\n        return [r === undefined ? " + ($u$$src$Targets$Javascript$Runtime$$nothingRef + (" : " + ($u$$src$Targets$Javascript$Runtime$$justRef + ("(r[1]), hash];\n    }\n\n\n    const hash_for = (hash, f, acc) => {\n        for (let k in hash) {\n            const kv = hash[k];\n            acc = f(kv[0], kv[1], acc);\n        }\n        return [acc, hash];\n    }\n\n\n    const hash_each = (hash, f) => {\n        for (let k in hash) {\n            const kv = hash[k];\n            f(kv[0], kv[1]);\n        }\n        return [null, hash];\n    }\n\n\n    //\n    // Arrays\n    //\n\n    const array_each = (array, f) => {\n        array.forEach(f);\n        return [null, array];\n    }\n\n    const array_push = (array, item) => {\n        array.push(item);\n        return [null, array];\n    }\n\n    const array_pop = (a) => {\n        return [a.length ? " + ($u$$src$Targets$Javascript$Runtime$$justRef + ("(a.pop()) : " + ($u$$src$Targets$Javascript$Runtime$$nothingRef + (", a];\n    }\n\n    const array_get = (array, index) => {\n        const r = array[index];\n        return [r === undefined ? " + ($u$$src$Targets$Javascript$Runtime$$nothingRef + (" : " + ($u$$src$Targets$Javascript$Runtime$$justRef + ("(r), array];\n    }\n\n    const array_set = (a, index, item) => {\n        if (index < 0) return false;\n        if (index >= a.length) return [false, a];\n        a[index] = item;\n        return [true, a];\n    }\n\n    const array_sortBy = (arr, f) => {\n        arr.sort((a, b) => basics_compare(f(a), f(b)));\n        return [null, arr];\n    }\n\n    const arrayToListLow = (arr) => {\n      const length = arr.length;\n      let list = [ '" + ($u$$src$Targets$Javascript$Runtime$$listNilName + ("' ];\n      for (let i = length - 1; i >= 0; i--) {\n          list = [ '" + ($u$$src$Targets$Javascript$Runtime$$listConsName + ("', arr[i], list ];\n      }\n      return list;\n    }\n\n    const array_toList = (arr) => [arrayToListLow(arr), arr];\n\n\n    const arrayFromListLow = (list) => {\n      const array = [];\n      const rec = (ls) => {\n        if (ls[0] === '" + ($u$$src$Targets$Javascript$Runtime$$listNilName + ("')\n          return array;\n\n        array.push(ls[1]);\n        return rec(ls[2]);\n      };\n\n      return rec(list);\n    }\n\n    const array_fromList = arrayFromListLow;\n\n\n    //\n    // Lists\n    //\n\n\n    const sp_cons = (item, list) => {\n      return [ '" + ($u$$src$Targets$Javascript$Runtime$$listConsName + "', item, list];\n    }\n\n    const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f(a), f(b))));\n\n\n    //\n    // Dynamic loading\n    //\n    const self_load = (requestedTypeHumanized, pars, variantConstructor) => {\n\n        const actualTypeHumanized = sp_toHuman(pars.type);\n        if (actualTypeHumanized !== requestedTypeHumanized) {\n            return [ 'Err', pars.type ];\n        }\n\n        // TODO using directly the source name sd1 is super fragile: must revisit this as soon as I have `Load.expose`\n        // TODO hoping that the state won't be mutated, once we have `Load.expose` maybe we don't need to lug the state around any more?\n        const translateUsr = $sd1$Targets$Javascript$EmittableToJs$translateUsr;\n        const js = $sd1$Platforms$Browser$compile(pars);\n\n        //   { name1, name2, name3, ... } = externals;\n        const unpackExterns = 'const { ' + pars.externalValues.map((e) => translateUsr(e.usr)).join(', ') + ' } = externs;';\n\n        const body = `{ ${unpackExterns}\n${js}; return ${translateUsr(pars.entryUsr)}; }`;\n\n        const arg = {};\n        pars.externalValues.forEach((e) => arg[translateUsr(e.usr)] = e.self.value);\n\n        return [ 'wwwwok', variantConstructor(Function('externs', body)(arg)) ];\n    };\n\n    "))))))))))))))))))))))))))))))))));

const $u$$src$Platforms$Posix$$makeExecutable = (($platformImportsPath) => {
  return (($out) => {
    const $entryName = ($u$$src$Targets$Javascript$EmittableToJs$$translateUsr)($out.entryUsr);
    const $callMain = ("\n\nconst args = arrayToListLow(process.argv.slice(1));\nprocess.exitCode =" + ($entryName + "(null, process.env, args)[0];"));
    const $compiledStatements = ((() => {
      (sp_log)("Creating JS AST...", "");
      const $jaStatements = ($u$$src$Targets$Javascript$EmittableToJs$$translateAll)(({
        constructors: $out.constructors,
        eaDefs: $out.defs,
        platformOverrides: ($u$$src$Platforms$Posix$$overrides)($platformImportsPath),
      }));
      (sp_log)("Emitting JS...", "");
      return ((($0) => {
        return ($c$$src$Text$$join)("\n\n", $0);
      }))(((($0) => {
        return ($c$$src$List$$map)((($0) => {
          return ($u$$src$Targets$Javascript$JsToText$$emitStatement)(0, $0);
        }), $0);
      }))($jaStatements));
    }))();
    return ($u$$src$Platforms$Posix$$header + ($u$$src$Targets$Javascript$Runtime$$nativeDefinitions + ($u$$src$Platforms$Posix$$runtime + ($compiledStatements + $callMain))));
  });
});

const $u$$src$Platforms$Posix$$platform = (($platformImportsPath) => {
  return ({
    defaultImportsFile: $u$$src$Platforms$Posix$$defaultImportsFile,
    defaultOutputName: "nodeExecutable.js",
    makeExecutable: ($u$$src$Platforms$Posix$$makeExecutable)($platformImportsPath),
    name: "posix",
    quickstart: "TODO",
  });
});

const $u$$src$Main$$platformBrowser = ($u$$src$Platforms$Posix$$platform)(($c$$src$Compiler$Meta$$ImportsPath)($c$$src$Compiler$Meta$$Installed, "browser"));

const $u$$src$Main$$platformPosix = ($u$$src$Platforms$Posix$$platform)(($c$$src$Compiler$Meta$$ImportsPath)($c$$src$Compiler$Meta$$Installed, "posix"));

const $u$$src$Main$$availablePlatforms = ($c$$src$Core$$Cons)($u$$src$Main$$platformPosix, ($c$$src$Core$$Cons)($u$$src$Main$$platformBrowser, $c$$src$Core$$Nil));

const $u$$src$Main$$cliDefaults = ({
  corelib: $c$$src$Maybe$$Nothing,
  platform: $u$$src$Main$$platformPosix,
});

const $u$$src$Main$$parseCorelibPath = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "$Nothing")
    ? ($c$$src$Result$$Err)("Please specify the path where your corelib is.")
    : ((($maybeValue)[0] === "$Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        return ($c$$src$Result$$Ok)(((() => {
          const $0 = $cliState;
          return (Object.assign)({}, $0, ({
            corelib: ($c$$src$Maybe$$Just)($value),
          }));
        }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 255:4', (sp_toHuman)($maybeValue))));
});

const $u$$src$Main$$parsePlatformName = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "$Nothing")
    ? ($c$$src$Result$$Err)("Please specify a platform name, for example: `--platform=posix`")
    : ((($maybeValue)[0] === "$Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        const $3 = ($c$$src$List$$find)((($p) => {
          return (sp_equal)($p.name, $value);
        }), $u$$src$Main$$availablePlatforms);
        return ((($3)[0] === "$Nothing")
          ? ($c$$src$Result$$Err)(("I don't know this platform name: `" + ($value + ("`\n\n                    Valid platform names are:\n\n" + ((($0) => {
            return ($c$$src$Text$$join)("\n", $0);
          }))(($c$$src$List$$map)((($p) => {
            return ("    " + $p.name);
          }), $u$$src$Main$$availablePlatforms))))))
          : ((($3)[0] === "$Just")
            ? ((() => {
              const $platform = ($3)[1];
              return ($c$$src$Result$$Ok)(((() => {
                const $0 = $cliState;
                return (Object.assign)({}, $0, ({
                  platform: $platform,
                }));
              }))());
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 233:12', (sp_toHuman)($3))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 227:4', (sp_toHuman)($maybeValue))));
});

const $u$$src$Main$$cliOptions = ($c$$src$Core$$Cons)(({
  info: "select build platform",
  name: "--platform",
  parser: $u$$src$Main$$parsePlatformName,
}), ($c$$src$Core$$Cons)(({
  info: "specify the path for for the corelib",
  name: "--corelib",
  parser: $u$$src$Main$$parseCorelibPath,
}), $c$$src$Core$$Nil));

const $u$$src$Term$$color = (($code) => {
  return (($text) => {
    return ($code + ($text + "\x1b[0m"));
  });
});

const $u$$src$Term$$blue = ($u$$src$Term$$color)("\x1b[34m");

const $u$$src$Term$$red = ($u$$src$Term$$color)("\x1b[31m");

const $u$$src$Term$$yellow = ($u$$src$Term$$color)("\x1b[33m");

const $u$$src$Main$$formattedToConsoleColoredText = (($formattedText) => {
  return ((($formattedText)[0] === "$FormattedText_Default")
    ? ((() => {
      const $t = ($formattedText)[1];
      return $t;
    }))()
    : ((($formattedText)[0] === "$FormattedText_Emphasys")
      ? ((() => {
        const $t = ($formattedText)[1];
        return ($u$$src$Term$$yellow)($t);
      }))()
      : ((($formattedText)[0] === "$FormattedText_Warning")
        ? ((() => {
          const $t = ($formattedText)[1];
          return ($u$$src$Term$$red)($t);
        }))()
        : ((($formattedText)[0] === "$FormattedText_Decoration")
          ? ((() => {
            const $t = ($formattedText)[1];
            return ($u$$src$Term$$blue)($t);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 25:4', (sp_toHuman)($formattedText))))));
});

const $u$$src$Main$$errorToText = (($0) => {
  return ((($0) => {
    return ($c$$src$Text$$join)("", $0);
  }))(((($0) => {
    return ($c$$src$List$$map)($u$$src$Main$$formattedToConsoleColoredText, $0);
  }))(($u$$src$Compiler$Error$$toFormattedText)($0)));
});

const $u$$src$Main$$resToIo = (($res) => {
  return ((($res)[0] === "$Ok")
    ? ((() => {
      const $a = ($res)[1];
      return ($c$$src$Result$$Ok)($a);
    }))()
    : ((($res)[0] === "$Err")
      ? ((() => {
        const $e = ($res)[1];
        return ($c$$src$Result$$Err)(($u$$src$Main$$errorToText)($e));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 42:4', (sp_toHuman)($res))));
});

const $u$$src$Main$$formatMain = (($io, $targets) => {
  const $formatText = (($fsPath, $content) => {
    return (($c$$src$Result$$onOk)((($formattableAst) => {
      return ($c$$src$Result$$Ok)(($u$$src$SPLib$Format$$render)(((($0) => {
        return ($u$$src$Human$Format$$formatStatements)(({
          isRoot: true,
          originalContent: $content,
        }), $0);
      }))($formattableAst)));
    })))(($u$$src$Main$$resToIo)(($u$$src$Compiler$Parser$$textToFormattableModule)(({
      errorModule: ({
        content: $content,
        fsPath: $fsPath,
      }),
      keepComments: true,
      stripLocations: false,
    }))));
  });
  const $formatFile = (($name) => {
    return (($c$$src$Result$$onOk)((($moduleAsText) => {
      return (($c$$src$Result$$onOk)((($formatted) => {
        return ((__re__ = (io_writeFile)($io, $name, $formatted)), ($io = (__re__)[1]), (__re__)[0]);
      })))(($formatText)($name, $moduleAsText));
    })))(((__re__ = (io_readFile)($io, $name)), ($io = (__re__)[1]), (__re__)[0]));
  });
  return ([
    ((sp_equal)($targets, $c$$src$Core$$Nil)
      ? (($c$$src$Result$$onOk)((($moduleAsText) => {
        return (($c$$src$Result$$onOk)((($formatted) => {
          return ((__re__ = (io_writeStdout)($io, $formatted)), ($io = (__re__)[1]), (__re__)[0]);
        })))(($formatText)("<stdin>", $moduleAsText));
      })))(((__re__ = (io_readStdin)($io)), ($io = (__re__)[1]), (__re__)[0]))
      : (($c$$src$Result$$onOk)(((_0) => {
        return ($c$$src$Result$$Ok)(null);
      })))(($c$$src$List$$mapRes)($formatFile, $targets))),
    $io,
  ]);
});

const $u$$src$Main$$indent = (($s) => {
  return ((($0) => {
    return ($c$$src$Text$$join)("\n", $0);
  }))(((($0) => {
    return ($c$$src$List$$map)((($l) => {
      return ("  " + $l);
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))($s)));
});

const $u$$src$Main$$parseArguments = (($options, $args, $initState) => {
  const $4 = ($c$$src$List$$partition)((($0) => {
    return (text_startsWith)("--", $0);
  }), $args);
  const $others = $4.second;
  const $optionTexts = $4.first;
  const $findOption = (($optionText, $state) => {
    const $7 = (text_split)("=", $optionText);
    return ((($7)[0] === "$Nil")
      ? ($c$$src$Result$$Ok)($state)
      : ((($7)[0] === "$Cons")
        ? ((() => {
          const $optionName = ($7)[1];
          const $rest = ($7)[2];
          const $8 = ($c$$src$List$$find)((($o) => {
            return (sp_equal)($o.name, $optionName);
          }), $options);
          return ((($8)[0] === "$Nothing")
            ? ($c$$src$Result$$Err)(("Unknown option " + $optionName))
            : ((($8)[0] === "$Just")
              ? ((() => {
                const $option = ($8)[1];
                const $value = ((sp_equal)($rest, $c$$src$Core$$Nil)
                  ? $c$$src$Maybe$$Nothing
                  : ($c$$src$Maybe$$Just)(($c$$src$Text$$join)("=", $rest)));
                return ($option.parser)($value, $state);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 77:16', (sp_toHuman)($8))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 71:8', (sp_toHuman)($7))));
  });
  return ((($0) => {
    return ($c$$src$Result$$map)((($0) => {
      return ($c$$src$Tuple$$pair)($others, $0);
    }), $0);
  }))(((($0) => {
    return ($c$$src$List$$forRes)($0, $optionTexts, $findOption);
  }))($initState));
});

const $u$$src$Main$$order = (($outcome) => {
  return ((($outcome)[0] === "$Success")
    ? 0
    : ((($outcome)[0] === "$Skipped")
      ? 1
      : ((($outcome)[0] === "$Error")
        ? 2
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 115:4', (sp_toHuman)($outcome)))));
});

const $u$$src$Term$$green = ($u$$src$Term$$color)("\x1b[32m");

const $u$$src$Main$$testOutcomeToText = (($name, $code, $outcome) => {
  return ((($outcome)[0] === "$Success")
    ? ($u$$src$Term$$green)(("* PASS: " + $name))
    : ((($outcome)[0] === "$Skipped")
      ? ($u$$src$Term$$yellow)(("* skip: " + $name))
      : ((($outcome)[0] === "$Error")
        ? ((() => {
          const $error = ($outcome)[1];
          return (($u$$src$Term$$red)(("FAIL ! " + $name)) + ("\n" + (($u$$src$Main$$indent)($code) + ("\n" + ($u$$src$Main$$indent)($error)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 107:4', (sp_toHuman)($outcome)))));
});

const $u$$src$Main$$selftestMain = (($io) => {
  return ([
    ((($0) => {
      return ((__re__ = (io_writeStdout)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
    }))(((($0) => {
      return ($0 + "\n");
    }))(((($0) => {
      return ($c$$src$Text$$join)("\n", $0);
    }))(((($0) => {
      return ($c$$src$List$$map)((($x) => {
        return ($u$$src$Main$$testOutcomeToText)($x.name, $x.code, $x.outcome);
      }), $0);
    }))(((($0) => {
      return (list_sortBy)((($x) => {
        return ({
          first: ($u$$src$Main$$order)($x.outcome),
          second: $x.name,
        });
      }), $0);
    }))(($i$test$$Test$$flattenAndRun)($u$$src$Main$$allTests)))))),
    $io,
  ]);
});

const $u$$src$Main$$main = (($io, $env, $rawArgs) => {
  return ([
    ((($0) => {
      return ((__re__ = ($i$posix$$IO$$reToStderr)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
    }))(((() => {
      const $4 = ($u$$src$Main$$parseArguments)($u$$src$Main$$cliOptions, $rawArgs, $u$$src$Main$$cliDefaults);
      return ((($4)[0] === "$Err")
        ? ((() => {
          const $message = ($4)[1];
          return ((__re__ = (io_writeStderr)($io, ($message + "\n"))), ($io = (__re__)[1]), (__re__)[0]);
        }))()
        : ((($4)[0] === "$Ok")
          ? ((() => {
            const $args = ($4)[1].first;
            const $cliState = ($4)[1].second;
            return (((($args)[0] === "$Cons") && (((($args)[2])[0] === "$Cons") && ("selftest" === (($args)[2])[1])))
              ? ((() => {
                const $self = ($args)[1];
                const $tail = (($args)[2])[2];
                return ((__re__ = ($u$$src$Main$$selftestMain)($io)), ($io = (__re__)[1]), (__re__)[0]);
              }))()
              : (((($args)[0] === "$Cons") && (((($args)[2])[0] === "$Cons") && ("format" === (($args)[2])[1])))
                ? ((() => {
                  const $self = ($args)[1];
                  const $tail = (($args)[2])[2];
                  return ((__re__ = ($u$$src$Main$$formatMain)($io, $tail)), ($io = (__re__)[1]), (__re__)[0]);
                }))()
                : (((($args)[0] === "$Cons") && ((($args)[2])[0] === "$Cons"))
                  ? ((() => {
                    const $self = ($args)[1];
                    const $entryPoint = (($args)[2])[1];
                    const $tail = (($args)[2])[2];
                    const $maybeOutputPath = ($c$$src$List$$head)($tail);
                    return ($u$$src$Main$$resToIo)(((__re__ = ($u$$src$BuildMain$$compileMain)($io, ({
                      corelib: $cliState.corelib,
                      entryPoint: $entryPoint,
                      maybeOutputPath: $maybeOutputPath,
                      platform: $cliState.platform,
                      selfPath: $self,
                    }))), ($io = (__re__)[1]), (__re__)[0]));
                  }))()
                  : (true
                    ? ((($0) => {
                      return ((__re__ = (io_writeStdout)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
                    }))("\nHi! This is the Squarepants compiler!\n\nTo compile something, write:\n\n    squarepants pathToMainModule.sp\n\n")
                    : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 290:12', (sp_toHuman)($args))))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 284:4', (sp_toHuman)($4))));
    }))()),
    $io,
    $env,
  ]);
});

const args = arrayToListLow(process.argv.slice(1));
process.exitCode =$u$$src$Main$$main(null, process.env, args)[0];