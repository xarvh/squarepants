#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096

//Error.stackTraceLimit = 100;

const { performance } = require('perf_hooks');

let __re__;


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


//
// Basic ops
//


const sp_equal = (a, b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i], b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k], b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a, b) => {
  return !sp_equal(a, b);
}


const basics_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = basics_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = basics_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (left, right) => {
  if (right === 0) return 0;
  return left / right;
}


// TODO remove this and handle it like any other op?
const basics_modBy = (a, b) => b % a;


const basics_cloneImm = sp_clone;


const basics_cloneUni = (uni) =>
    [ sp_clone(uni), uni ];


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message, thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


// TODO how should benchmark work in a browser?
typeof process !== 'undefined' && process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.error("");
        console.error("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.error(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const id = (n) => '    '.repeat(n);


const sp_toHuman = (a, l = 0) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a, l) || sp_toHumanAsDict(a, l) || sp_toHumanAsUnion(a, l);

  if (typeof a === 'function') {
    return '<fn ' + a.length + '>';
  }

  if (typeof a === 'object') {
    let acc = '{\n';
    for (let key in a)
        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\n';

    return acc + id(l) + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a, l) => {

  if (a.length === 1) {
      return a[0];
  }

  let acc = a[0] + '\n';

  a.slice(1).forEach(arg => {

      const sub = sp_toHuman(arg, l + 1);
      if (!sub.startsWith('{') && sub.indexOf('\n') > -1)
          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\n';
      else
          acc += id(l + 1) + sub + '\n';

  })

  return acc;
}


const sp_toHumanAsList = (arrayAccum, list, l) => {
  if (list[0] === '$Cons' && list.length === 3) {
    arrayAccum.push(sp_toHuman(list[1], l));
    return sp_toHumanAsList(arrayAccum, list[2], l);
  }

  if (list[0] === '$Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}

const sp_toHumanAsDict = (dict, l) => {
  if (dict[0] === 'RBNode_elm_builtin') {
      return 'DICT' + sp_toHumanAsList([], $core$Dict$toList(dict), l);
  }

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ?c0Maybe$Nothing:c0Maybe$Just(n);
    }

    const text_toLower = (s) => s.toLowerCase()

    const text_toUpper = (s) => s.toUpperCase()

    const text_split = (separator, target) => arrayToListLow(target.split(separator));

    const text_length = (s) => s.length;

    const text_slice = (start, end, s) => s.slice(start, end);

    const text_startsWith = (sub, s) => s.startsWith(sub);

    const text_startsWithRegex = (regex) => {
      let re;
      try {
        re = new RegExp('^' + regex, 's');
      } catch (e) {
        return () => ""
      }

      return (s) => {
        let m = s.match(re);
        return m ? m[0] : "";
      }
    }

    const text_replaceRegex = (regex) => {
      let re;
      try {
        re = new RegExp(regex, 'g');
      } catch (e) {
        return () => ""
      }

      return (replacer, s) => s.replace(re, replacer);
    }

    const text_trimLeft = (s) => s.trimLeft();

    const text_dropLeft = (n, s) => s.slice(n);

    const text_forEach = (s, f) => {
      for (let i of s) f(i);
      return null;
    }


    //
    // Hashes
    //

    const hash_pop = (hash) => {
        for (let key in hash) {
            const [actualKey, value] = hash[key];
            delete hash[key];
            return [c0Maybe$Just({ first: actualKey, second: value }), hash ];
        }

        return [c0Maybe$Nothing, hash ];
    }


    const hash_fromList = (list) => {
      const hash = {};

      // TODO iteration instead of recursion
      const rec = (ls) => {
        if (ls[0] === '$Nil')
          return hash;

        const { first, second } = ls[1];

        hash[JSON.stringify(first)] = [first, second];

        return rec(ls[2]);
      };

      return rec(list);
    }


    const hash_insert = (hash, key, value) => {
        hash[JSON.stringify(key)] = [key, value];
        return [null, hash];
    }


    const hash_remove = (hash, key) => {
        delete hash[JSON.stringify(key)];
        return [null, hash];
    }


    const hash_get = (hash, key) => {
        const r = hash[JSON.stringify(key)];
        return [r === undefined ?c0Maybe$Nothing:c0Maybe$Just(r[1]), hash];
    }


    const hash_for = (hash, f, acc) => {
        for (let k in hash) {
            const kv = hash[k];
            acc = f(kv[0], kv[1], acc);
        }
        return [acc, hash];
    }


    const hash_each = (hash, f) => {
        for (let k in hash) {
            const kv = hash[k];
            f(kv[0], kv[1]);
        }
        return [null, hash];
    }


    //
    // Arrays
    //

    const array_each = (array, f) => {
        array.forEach(f);
        return [null, array];
    }

    const array_push = (array, item) => {
        array.push(item);
        return [null, array];
    }

    const array_pop = (a) => {
        return [a.length ?c0Maybe$Just(a.pop()) :c0Maybe$Nothing, a];
    }

    const array_get = (array, index) => {
        const r = array[index];
        return [r === undefined ?c0Maybe$Nothing:c0Maybe$Just(r), array];
    }

    const array_set = (a, index, item) => {
        if (index < 0) return false;
        if (index >= a.length) return [false, a];
        a[index] = item;
        return [true, a];
    }

    const array_sortBy = (arr, f) => {
        arr.sort((a, b) => basics_compare(f(a), f(b)));
        return [null, arr];
    }

    const arrayToListLow = (arr) => {
      const length = arr.length;
      let list = [ '$Nil' ];
      for (let i = length - 1; i >= 0; i--) {
          list = [ '$Cons', arr[i], list ];
      }
      return list;
    }

    const array_toList = (arr) => [arrayToListLow(arr), arr];


    const arrayFromListLow = (list) => {
      const array = [];
      const rec = (ls) => {
        if (ls[0] === '$Nil')
          return array;

        array.push(ls[1]);
        return rec(ls[2]);
      };

      return rec(list);
    }

    const array_fromList = arrayFromListLow;


    //
    // Lists
    //


    const sp_cons = (item, list) => {
      return [ '$Cons', item, list];
    }

    const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f(a), f(b))));


    //
    // Dynamic loading
    //
    const self_load = (requestedTypeHumanized, pars, variantConstructor) => {

        const actualTypeHumanized = sp_toHuman(pars.type);
        if (actualTypeHumanized !== requestedTypeHumanized) {
            return [ 'Err', pars.type ];
        }

        // TODO using directly the source name sd1 is super fragile: must revisit this as soon as I have `Load.expose`
        // TODO hoping that the state won't be mutated, once we have `Load.expose` maybe we don't need to lug the state around any more?
        const translateUsr = $sd1$Targets$Javascript$EmittableToJs$translateUsr;
        const js = $sd1$Platforms$Browser$compile(pars);

        //   { name1, name2, name3, ... } = externals;
        const unpackExterns = 'const { ' + pars.externalValues.map((e) => translateUsr(e.usr)).join(', ') + ' } = externs;';

        const body = `{ ${unpackExterns}
${js}; return ${translateUsr(pars.entryUsr)}; }`;

        const arg = {};
        pars.externalValues.forEach((e) => arg[translateUsr(e.usr)] = e.self.value);

        return [ 'wwwwok', variantConstructor(Function('externs', body)(arg)) ];
    };


//
// Platform: IO
//
const fs = require('fs');
const path = require('path');

const io_readDir = (io, dirPath) => {
    // as @IO, Text: Re [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return [c0Result$Ok(e.message), null];
        }

        return [c0Result$Ok(arrayToListLow(entries.map((dirent) => ({
            first: dirent.isDirectory(),
            second: dirent.name,
        })))), null];
    };


    const io_readFile = (io, path) => {
        // as @IO, Text: Re Text

        var content;
        try {
            content = fs.readFileSync(path, 'utf8');
        } catch (e) {
            return [c0Result$Ok(e.message), null];
        }

        return [c0Result$Ok(content), null];
    };


    const io_writeFile = (io, path, content) => {
        // as @IO, Text, Text: Re Int

        try {
            fs.writeFileSync(path, content);
        } catch (e) {
            return [c0Result$Ok(e.message), null];
        }

        return [c0Result$Ok(0), null];
    };


    const io_readStdin = (io) => {
        // as @IO: Re Text

        try {
            return [c0Result$Ok(fs.readFileSync(0, 'utf8')), null];
        } catch (e) {
            return [c0Result$Ok(e.message), null];
        }
    };


    const io_writeStdout = (io, content) => {
        // as @IO, Text: Re None

        try {
            fs.writeFileSync(1, content);
        } catch (e) {
            return [c0Result$Ok(e.message), null];
        }

        return [c0Result$Ok(null), null];
    };


    const io_writeStderr = (io, content) => {
        // as @IO, Text: Re Int

        try {
            fs.writeFileSync(2, content);
        } catch (e) {
            return [c0Result$Ok(e.message), null];
        }

        return [c0Result$Ok(null), null];
    };


    const path_resolve = (p) => path.resolve(...arrayFromListLow(p));

    const path_join = (p) => path.join(...arrayFromListLow(p));

    const path_dirname = path.dirname;

const c0Compiler$Ast$Depends = (($1) => ([
  "$Depends",
  $1,
]));

const c0Compiler$Ast$Imm = ([
  "$Imm",
]);

const c0Compiler$Ast$RefGlobal = (($1) => ([
  "$RefGlobal",
  $1,
]));

const c0Compiler$Ast$RefLocal = (($1) => ([
  "$RefLocal",
  $1,
]));

const c0Compiler$Ast$RefPlaceholder = (($1) => ([
  "$RefPlaceholder",
  $1,
]));

const c0Compiler$Ast$Uni = ([
  "$Uni",
]);

const c0Compiler$CanonicalAst$ArgumentExpression = (($1) => ([
  "$ArgumentExpression",
  $1,
]));

const c0Compiler$CanonicalAst$ArgumentRecycle = (($1, $2, $3) => ([
  "$ArgumentRecycle",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$Call = (($1, $2, $3) => ([
  "$Call",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$Complete = ([
  "$Complete",
]);

const c0Compiler$CanonicalAst$Constructor = (($1, $2) => ([
  "$Constructor",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$Fn = (($1, $2, $3) => ([
  "$Fn",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$If = (($1, $2) => ([
  "$If",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$LetIn = (($1, $2) => ([
  "$LetIn",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$LiteralNumber = (($1, $2) => ([
  "$LiteralNumber",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$LiteralText = (($1, $2) => ([
  "$LiteralText",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$ParRe = (($1) => ([
  "$ParRe",
  $1,
]));

const c0Compiler$CanonicalAst$ParSp = (($1) => ([
  "$ParSp",
  $1,
]));

const c0Compiler$CanonicalAst$ParameterPattern = (($1, $2) => ([
  "$ParameterPattern",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$ParameterPlaceholder = (($1) => ([
  "$ParameterPlaceholder",
  $1,
]));

const c0Compiler$CanonicalAst$ParameterRecycle = (($1, $2) => ([
  "$ParameterRecycle",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$Partial = ([
  "$Partial",
]);

const c0Compiler$CanonicalAst$PatternAny = (($1, $2, $3) => ([
  "$PatternAny",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$PatternConstructor = (($1, $2, $3) => ([
  "$PatternConstructor",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$PatternLiteralNumber = (($1, $2) => ([
  "$PatternLiteralNumber",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$PatternLiteralText = (($1, $2) => ([
  "$PatternLiteralText",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$PatternRecord = (($1, $2, $3) => ([
  "$PatternRecord",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$Record = (($1, $2, $3) => ([
  "$Record",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$RecordAccess = (($1, $2, $3) => ([
  "$RecordAccess",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$Try = (($1, $2) => ([
  "$Try",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$TypeAnnotationVariable = (($1, $2) => ([
  "$TypeAnnotationVariable",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$TypeError = (($1) => ([
  "$TypeError",
  $1,
]));

const c0Compiler$CanonicalAst$TypeFn = (($1, $2, $3) => ([
  "$TypeFn",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$TypeNamed = (($1, $2, $3) => ([
  "$TypeNamed",
  $1,
  $2,
  $3,
]));

const c0Compiler$CanonicalAst$TypeRecord = (($1, $2) => ([
  "$TypeRecord",
  $1,
  $2,
]));

const c0Compiler$CanonicalAst$Variable = (($1, $2) => ([
  "$Variable",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$And = (($1) => ([
  "$And",
  $1,
]));

const c0Compiler$EmittableAst$ArgumentRecycle = (($1, $2, $3) => ([
  "$ArgumentRecycle",
  $1,
  $2,
  $3,
]));

const c0Compiler$EmittableAst$ArgumentSpend = (($1, $2) => ([
  "$ArgumentSpend",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$ArrayAccess = (($1, $2) => ([
  "$ArrayAccess",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$Call = (($1, $2) => ([
  "$Call",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$Conditional = (($1, $2, $3) => ([
  "$Conditional",
  $1,
  $2,
  $3,
]));

const c0Compiler$EmittableAst$Constructor = (($1) => ([
  "$Constructor",
  $1,
]));

const c0Compiler$EmittableAst$ConstructorAccess = (($1, $2) => ([
  "$ConstructorAccess",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$Fn = (($1, $2) => ([
  "$Fn",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$IsConstructor = (($1, $2) => ([
  "$IsConstructor",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$LetIn = (($1) => ([
  "$LetIn",
  $1,
]));

const c0Compiler$EmittableAst$LiteralArray = (($1) => ([
  "$LiteralArray",
  $1,
]));

const c0Compiler$EmittableAst$LiteralNumber = (($1) => ([
  "$LiteralNumber",
  $1,
]));

const c0Compiler$EmittableAst$LiteralRecord = (($1, $2) => ([
  "$LiteralRecord",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$LiteralText = (($1) => ([
  "$LiteralText",
  $1,
]));

const c0Compiler$EmittableAst$MissingPattern = (($1, $2) => ([
  "$MissingPattern",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$RecordAccess = (($1, $2) => ([
  "$RecordAccess",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$ShallowEqual = (($1, $2) => ([
  "$ShallowEqual",
  $1,
  $2,
]));

const c0Compiler$EmittableAst$Variable = (($1) => ([
  "$Variable",
  $1,
]));

const c0Compiler$FormattableAst$AliasDef = (($1) => ([
  "$AliasDef",
  $1,
]));

const c0Compiler$FormattableAst$Aligned = ([
  "$Aligned",
]);

const c0Compiler$FormattableAst$ArgumentPlaceholder = ([
  "$ArgumentPlaceholder",
]);

const c0Compiler$FormattableAst$BinopChain = (($1, $2) => ([
  "$BinopChain",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$Call = (($1, $2) => ([
  "$Call",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$CommentStatement = (($1) => ([
  "$CommentStatement",
  $1,
]));

const c0Compiler$FormattableAst$Constructor = (($1) => ([
  "$Constructor",
  $1,
]));

const c0Compiler$FormattableAst$Evaluation = (($1) => ([
  "$Evaluation",
  $1,
]));

const c0Compiler$FormattableAst$Expression = (($1, $2, $3) => ([
  "$Expression",
  $1,
  $2,
  $3,
]));

const c0Compiler$FormattableAst$Fn = (($1, $2, $3) => ([
  "$Fn",
  $1,
  $2,
  $3,
]));

const c0Compiler$FormattableAst$If = (($1) => ([
  "$If",
  $1,
]));

const c0Compiler$FormattableAst$Indented = ([
  "$Indented",
]);

const c0Compiler$FormattableAst$Inline = ([
  "$Inline",
]);

const c0Compiler$FormattableAst$List = (($1, $2) => ([
  "$List",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$LiteralNumber = (($1, $2) => ([
  "$LiteralNumber",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$LiteralText = (($1, $2) => ([
  "$LiteralText",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$Lowercase = (($1) => ([
  "$Lowercase",
  $1,
]));

const c0Compiler$FormattableAst$Native = ([
  "$Native",
]);

const c0Compiler$FormattableAst$Poly = (($1, $2) => ([
  "$Poly",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$Record = (($1) => ([
  "$Record",
  $1,
]));

const c0Compiler$FormattableAst$RecordShorthand = (($1) => ([
  "$RecordShorthand",
  $1,
]));

const c0Compiler$FormattableAst$ResolvedArgumentPlaceholder = (($1) => ([
  "$ResolvedArgumentPlaceholder",
  $1,
]));

const c0Compiler$FormattableAst$Statements = (($1) => ([
  "$Statements",
  $1,
]));

const c0Compiler$FormattableAst$Try = (($1) => ([
  "$Try",
  $1,
]));

const c0Compiler$FormattableAst$UnionDef = (($1) => ([
  "$UnionDef",
  $1,
]));

const c0Compiler$FormattableAst$UnopCall = (($1, $2) => ([
  "$UnopCall",
  $1,
  $2,
]));

const c0Compiler$FormattableAst$Uppercase = (($1) => ([
  "$Uppercase",
  $1,
]));

const c0Compiler$FormattableAst$ValueDef = (($1) => ([
  "$ValueDef",
  $1,
]));

const c0Compiler$Meta$UMR = (($1, $2, $3) => ([
  "$UMR",
  $1,
  $2,
  $3,
]));

const c0Compiler$Meta$USR = (($1, $2) => ([
  "$USR",
  $1,
  $2,
]));

const c0Compiler$Meta$ConstructorDependency = ([
  "$ConstructorDependency",
]);

const c0Compiler$Meta$Core = ([
  "$Core",
]);

const c0Compiler$Meta$ImportsPath = (($1, $2) => ([
  "$ImportsPath",
  $1,
  $2,
]));

const c0Compiler$Meta$Installed = ([
  "$Installed",
]);

const c0Compiler$Meta$LocationLibrary = (($1, $2) => ([
  "$LocationLibrary",
  $1,
  $2,
]));

const c0Compiler$Meta$LocationSourceDir = (($1) => ([
  "$LocationSourceDir",
  $1,
]));

const c0Compiler$Meta$TypeDependency = ([
  "$TypeDependency",
]);

const c0Compiler$Meta$User = ([
  "$User",
]);

const c0Compiler$Meta$ValueDependency = ([
  "$ValueDependency",
]);

const c0Compiler$Op$Left = ([
  "$Left",
]);

const c0Compiler$Op$NonAssociative = ([
  "$NonAssociative",
]);

const c0Compiler$Op$Right = ([
  "$Right",
]);

const c0Compiler$Op$UnopMinus = ([
  "$UnopMinus",
]);

const c0Compiler$Op$UnopPlus = ([
  "$UnopPlus",
]);

const c0Compiler$Op$UnopRecycle = ([
  "$UnopRecycle",
]);

const c0Compiler$Op$UnopUnique = ([
  "$UnopUnique",
]);

const c0Compiler$Pos$At = (($1, $2) => ([
  "$At",
  $1,
  $2,
]));

const c0Compiler$Pos$End = ([
  "$End",
]);

const c0Compiler$Pos$G = ([
  "$G",
]);

const c0Compiler$Pos$I = (($1) => ([
  "$I",
  $1,
]));

const c0Compiler$Pos$N = ([
  "$N",
]);

const c0Compiler$Pos$P = (($1, $2) => ([
  "$P",
  $1,
  $2,
]));

const c0Compiler$Pos$S = ([
  "$S",
]);

const c0Compiler$Pos$T = ([
  "$T",
]);

const c0Compiler$Token$ArgumentPlaceholder = ([
  "$ArgumentPlaceholder",
]);

const c0Compiler$Token$As = ([
  "$As",
]);

const c0Compiler$Token$Binop = (($1, $2) => ([
  "$Binop",
  $1,
  $2,
]));

const c0Compiler$Token$BlockEnd = ([
  "$BlockEnd",
]);

const c0Compiler$Token$BlockStart = ([
  "$BlockStart",
]);

const c0Compiler$Token$Closed = ([
  "$Closed",
]);

const c0Compiler$Token$Colon = ([
  "$Colon",
]);

const c0Compiler$Token$Comma = ([
  "$Comma",
]);

const c0Compiler$Token$Comment = (($1) => ([
  "$Comment",
  $1,
]));

const c0Compiler$Token$Constructor = (($1) => ([
  "$Constructor",
  $1,
]));

const c0Compiler$Token$CurlyBrace = (($1, $2) => ([
  "$CurlyBrace",
  $1,
  $2,
]));

const c0Compiler$Token$Defop = ([
  "$Defop",
]);

const c0Compiler$Token$Else = (($1) => ([
  "$Else",
  $1,
]));

const c0Compiler$Token$Fn = ([
  "$Fn",
]);

const c0Compiler$Token$If = (($1) => ([
  "$If",
  $1,
]));

const c0Compiler$Token$Lowercase = (($1) => ([
  "$Lowercase",
  $1,
]));

const c0Compiler$Token$Native = ([
  "$Native",
]);

const c0Compiler$Token$NewSiblingLine = ([
  "$NewSiblingLine",
]);

const c0Compiler$Token$NumberLiteral = (($1, $2) => ([
  "$NumberLiteral",
  $1,
  $2,
]));

const c0Compiler$Token$Open = ([
  "$Open",
]);

const c0Compiler$Token$RecordShorthand = (($1) => ([
  "$RecordShorthand",
  $1,
]));

const c0Compiler$Token$RoundParen = (($1) => ([
  "$RoundParen",
  $1,
]));

const c0Compiler$Token$SingleQuote = ([
  "$SingleQuote",
]);

const c0Compiler$Token$SquareBracket = (($1, $2) => ([
  "$SquareBracket",
  $1,
  $2,
]));

const c0Compiler$Token$TextLiteral = (($1, $2) => ([
  "$TextLiteral",
  $1,
  $2,
]));

const c0Compiler$Token$Then = ([
  "$Then",
]);

const c0Compiler$Token$ThreeDots = ([
  "$ThreeDots",
]);

const c0Compiler$Token$Token = (($1, $2, $3) => ([
  "$Token",
  $1,
  $2,
  $3,
]));

const c0Compiler$Token$TripleQuote = ([
  "$TripleQuote",
]);

const c0Compiler$Token$Try = ([
  "$Try",
]);

const c0Compiler$Token$UniquenessPolymorphismBinop = ([
  "$UniquenessPolymorphismBinop",
]);

const c0Compiler$Token$Unop = (($1) => ([
  "$Unop",
  $1,
]));

const c0Compiler$Token$Uppercase = (($1) => ([
  "$Uppercase",
  $1,
]));

const c0Compiler$Token$With = ([
  "$With",
]);

const c0Compiler$TypedAst$ArgumentExpression = (($1, $2) => ([
  "$ArgumentExpression",
  $1,
  $2,
]));

const c0Compiler$TypedAst$ArgumentRecycle = (($1, $2, $3, $4) => ([
  "$ArgumentRecycle",
  $1,
  $2,
  $3,
  $4,
]));

const c0Compiler$TypedAst$Call = (($1, $2, $3) => ([
  "$Call",
  $1,
  $2,
  $3,
]));

const c0Compiler$TypedAst$Constructor = (($1, $2) => ([
  "$Constructor",
  $1,
  $2,
]));

const c0Compiler$TypedAst$DestroyIn = (($1, $2) => ([
  "$DestroyIn",
  $1,
  $2,
]));

const c0Compiler$TypedAst$Error = (($1) => ([
  "$Error",
  $1,
]));

const c0Compiler$TypedAst$Fn = (($1, $2, $3, $4) => ([
  "$Fn",
  $1,
  $2,
  $3,
  $4,
]));

const c0Compiler$TypedAst$If = (($1, $2) => ([
  "$If",
  $1,
  $2,
]));

const c0Compiler$TypedAst$LetIn = (($1, $2, $3) => ([
  "$LetIn",
  $1,
  $2,
  $3,
]));

const c0Compiler$TypedAst$LiteralNumber = (($1, $2) => ([
  "$LiteralNumber",
  $1,
  $2,
]));

const c0Compiler$TypedAst$LiteralText = (($1, $2) => ([
  "$LiteralText",
  $1,
  $2,
]));

const c0Compiler$TypedAst$ParRe = (($1) => ([
  "$ParRe",
  $1,
]));

const c0Compiler$TypedAst$ParSp = (($1) => ([
  "$ParSp",
  $1,
]));

const c0Compiler$TypedAst$ParameterPattern = (($1, $2) => ([
  "$ParameterPattern",
  $1,
  $2,
]));

const c0Compiler$TypedAst$ParameterPlaceholder = (($1, $2) => ([
  "$ParameterPlaceholder",
  $1,
  $2,
]));

const c0Compiler$TypedAst$ParameterRecycle = (($1, $2, $3) => ([
  "$ParameterRecycle",
  $1,
  $2,
  $3,
]));

const c0Compiler$TypedAst$PatternAny = (($1, $2) => ([
  "$PatternAny",
  $1,
  $2,
]));

const c0Compiler$TypedAst$PatternConstructor = (($1, $2, $3) => ([
  "$PatternConstructor",
  $1,
  $2,
  $3,
]));

const c0Compiler$TypedAst$PatternLiteralNumber = (($1, $2) => ([
  "$PatternLiteralNumber",
  $1,
  $2,
]));

const c0Compiler$TypedAst$PatternLiteralText = (($1, $2) => ([
  "$PatternLiteralText",
  $1,
  $2,
]));

const c0Compiler$TypedAst$PatternRecord = (($1, $2) => ([
  "$PatternRecord",
  $1,
  $2,
]));

const c0Compiler$TypedAst$Record = (($1, $2, $3) => ([
  "$Record",
  $1,
  $2,
  $3,
]));

const c0Compiler$TypedAst$RecordAccess = (($1, $2, $3) => ([
  "$RecordAccess",
  $1,
  $2,
  $3,
]));

const c0Compiler$TypedAst$Try = (($1, $2) => ([
  "$Try",
  $1,
  $2,
]));

const c0Compiler$TypedAst$TypeError = ([
  "$TypeError",
]);

const c0Compiler$TypedAst$TypeExact = (($1, $2) => ([
  "$TypeExact",
  $1,
  $2,
]));

const c0Compiler$TypedAst$TypeFn = (($1, $2) => ([
  "$TypeFn",
  $1,
  $2,
]));

const c0Compiler$TypedAst$TypeRecord = (($1, $2) => ([
  "$TypeRecord",
  $1,
  $2,
]));

const c0Compiler$TypedAst$TypeVar = (($1) => ([
  "$TypeVar",
  $1,
]));

const c0Compiler$TypedAst$Variable = (($1, $2) => ([
  "$Variable",
  $1,
  $2,
]));

const c0Core$Cons = (($1, $2) => ([
  "$Cons",
  $1,
  $2,
]));

const c0Core$False = ([
  "$False",
]);

const c0Core$Nil = ([
  "$Nil",
]);

const c0Core$None = ([
  "$None",
]);

const c0Core$True = ([
  "$True",
]);

const c0Dict$RBEmpty_elm_builtin = ([
  "$RBEmpty_elm_builtin",
]);

const c0Dict$RBNode_elm_builtin = (($1, $2, $3, $4, $5) => ([
  "$RBNode_elm_builtin",
  $1,
  $2,
  $3,
  $4,
  $5,
]));

const c0Dict$Black = ([
  "$Black",
]);

const c0Dict$Red = ([
  "$Red",
]);

const c0Maybe$Just = (($1) => ([
  "$Just",
  $1,
]));

const c0Maybe$Nothing = ([
  "$Nothing",
]);

const c0Result$Err = (($1) => ([
  "$Err",
  $1,
]));

const c0Result$Ok = (($1) => ([
  "$Ok",
  $1,
]));

const i1Test$CodeExpectation = (($1) => ([
  "$CodeExpectation",
  $1,
]));

const i1Test$Error = (($1) => ([
  "$Error",
  $1,
]));

const i1Test$Group = (($1, $2) => ([
  "$Group",
  $1,
  $2,
]));

const i1Test$NotNow = (($1) => ([
  "$NotNow",
  $1,
]));

const i1Test$Single = (($1, $2, $3) => ([
  "$Single",
  $1,
  $2,
  $3,
]));

const i1Test$Skipped = ([
  "$Skipped",
]);

const i1Test$Success = ([
  "$Success",
]);

const u0Compiler$Error$FormattedText_Decoration = (($1) => ([
  "$FormattedText_Decoration",
  $1,
]));

const u0Compiler$Error$FormattedText_Default = (($1) => ([
  "$FormattedText_Default",
  $1,
]));

const u0Compiler$Error$FormattedText_Emphasys = (($1) => ([
  "$FormattedText_Emphasys",
  $1,
]));

const u0Compiler$Error$FormattedText_Warning = (($1) => ([
  "$FormattedText_Warning",
  $1,
]));

const u0Compiler$Error$HighlightBlock = (($1) => ([
  "$HighlightBlock",
  $1,
]));

const u0Compiler$Error$HighlightWord = (($1) => ([
  "$HighlightWord",
  $1,
]));

const u0Compiler$Error$Nested = (($1) => ([
  "$Nested",
  $1,
]));

const u0Compiler$Error$Raw = (($1) => ([
  "$Raw",
  $1,
]));

const u0Compiler$Error$Simple = (($1, $2, $3) => ([
  "$Simple",
  $1,
  $2,
  $3,
]));

const u0Compiler$LazyBuild$AliasDef = (($1) => ([
  "$AliasDef",
  $1,
]));

const u0Compiler$LazyBuild$ConstructorDef = (($1) => ([
  "$ConstructorDef",
  $1,
]));

const u0Compiler$LazyBuild$MissingDef = ([
  "$MissingDef",
]);

const u0Compiler$LazyBuild$ValueDef = (($1) => ([
  "$ValueDef",
  $1,
]));

const u0Compiler$LazyBuild$VariantTypeDef = (($1) => ([
  "$VariantTypeDef",
  $1,
]));

const u0Compiler$Lexer$BlockComment = (($1) => ([
  "$BlockComment",
  $1,
]));

const u0Compiler$Lexer$ContentOpeningBlockComment = ([
  "$ContentOpeningBlockComment",
]);

const u0Compiler$Lexer$ContentOpeningQuotes_One = ([
  "$ContentOpeningQuotes_One",
]);

const u0Compiler$Lexer$ContentOpeningQuotes_Two = ([
  "$ContentOpeningQuotes_Two",
]);

const u0Compiler$Lexer$Default = ([
  "$Default",
]);

const u0Compiler$Lexer$Dot_One = ([
  "$Dot_One",
]);

const u0Compiler$Lexer$Dot_Two = ([
  "$Dot_Two",
]);

const u0Compiler$Lexer$Indent = ([
  "$Indent",
]);

const u0Compiler$Lexer$LineComment = (($1) => ([
  "$LineComment",
  $1,
]));

const u0Compiler$Lexer$Mutable = ([
  "$Mutable",
]);

const u0Compiler$Lexer$NoTabsOrSpacesYet = ([
  "$NoTabsOrSpacesYet",
]);

const u0Compiler$Lexer$NumberLiteral = ([
  "$NumberLiteral",
]);

const u0Compiler$Lexer$SingleQuote = (($1) => ([
  "$SingleQuote",
  $1,
]));

const u0Compiler$Lexer$Spaces = ([
  "$Spaces",
]);

const u0Compiler$Lexer$Squiggles = ([
  "$Squiggles",
]);

const u0Compiler$Lexer$Tabs = ([
  "$Tabs",
]);

const u0Compiler$Lexer$TripleQuote = (($1) => ([
  "$TripleQuote",
  $1,
]));

const u0Compiler$Lexer$Word = ([
  "$Word",
]);

const u0Compiler$MakeEmittable$GenerateName = ([
  "$GenerateName",
]);

const u0Compiler$MakeEmittable$NoNamedVariables = ([
  "$NoNamedVariables",
]);

const u0Compiler$MakeEmittable$TrivialPattern = (($1, $2) => ([
  "$TrivialPattern",
  $1,
  $2,
]));

const u0Compiler$Parser$E_full = (($1) => ([
  "$E_full",
  $1,
]));

const u0Compiler$Parser$E_under = (($1) => ([
  "$E_under",
  $1,
]));

const u0Compiler$TypeCheck$CanBeCastNo = (($1) => ([
  "$CanBeCastNo",
  $1,
]));

const u0Compiler$TypeCheck$CanBeCastYes = ([
  "$CanBeCastYes",
]);

const u0Compiler$TypeCheck$Context_Argument = (($1, $2) => ([
  "$Context_Argument",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$Context_AttributeName = (($1, $2) => ([
  "$Context_AttributeName",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$Context_FnBody = (($1, $2) => ([
  "$Context_FnBody",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$Context_FnPar = (($1, $2) => ([
  "$Context_FnPar",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$Context_Global = ([
  "$Context_Global",
]);

const u0Compiler$TypeCheck$Context_IfCondition = ([
  "$Context_IfCondition",
]);

const u0Compiler$TypeCheck$Context_IfFalse = ([
  "$Context_IfFalse",
]);

const u0Compiler$TypeCheck$Context_IfTrue = ([
  "$Context_IfTrue",
]);

const u0Compiler$TypeCheck$Context_LetInBody = (($1) => ([
  "$Context_LetInBody",
  $1,
]));

const u0Compiler$TypeCheck$Context_TryBranch = ([
  "$Context_TryBranch",
]);

const u0Compiler$TypeCheck$ErrorCallingANonFunction = (($1) => ([
  "$ErrorCallingANonFunction",
  $1,
]));

const u0Compiler$TypeCheck$ErrorConstructorNotFound = (($1) => ([
  "$ErrorConstructorNotFound",
  $1,
]));

const u0Compiler$TypeCheck$ErrorIncompatiblePattern = (($1, $2) => ([
  "$ErrorIncompatiblePattern",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$ErrorIncompatibleTypes = (($1, $2) => ([
  "$ErrorIncompatibleTypes",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$ErrorNotCompatibleWithRecord = ([
  "$ErrorNotCompatibleWithRecord",
]);

const u0Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute = (($1) => ([
  "$ErrorRecordDoesNotHaveAttribute",
  $1,
]));

const u0Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation = (($1) => ([
  "$ErrorRecordHasAttributesNotInAnnotation",
  $1,
]));

const u0Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation = (($1) => ([
  "$ErrorRecordIsMissingAttibutesInAnnotation",
  $1,
]));

const u0Compiler$TypeCheck$ErrorRecyclingDoesNotMatch = ([
  "$ErrorRecyclingDoesNotMatch",
]);

const u0Compiler$TypeCheck$ErrorShouldBeUnique = ([
  "$ErrorShouldBeUnique",
]);

const u0Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord = (($1, $2) => ([
  "$ErrorTryingToAccessAttributeOfNonRecord",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$ErrorTypeNotFound = (($1) => ([
  "$ErrorTypeNotFound",
  $1,
]));

const u0Compiler$TypeCheck$ErrorTyvarNotIndependent = (($1) => ([
  "$ErrorTyvarNotIndependent",
  $1,
]));

const u0Compiler$TypeCheck$ErrorUndefinedTypeVariable = (($1) => ([
  "$ErrorUndefinedTypeVariable",
  $1,
]));

const u0Compiler$TypeCheck$ErrorUniquenessDoesNotMatch = (($1) => ([
  "$ErrorUniquenessDoesNotMatch",
  $1,
]));

const u0Compiler$TypeCheck$ErrorUniquenessDoesNotMatchArgument = ([
  "$ErrorUniquenessDoesNotMatchArgument",
]);

const u0Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter = (($1, $2) => ([
  "$ErrorUniquenessDoesNotMatchParameter",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$ErrorUnresolvableUniqueness = (($1, $2) => ([
  "$ErrorUnresolvableUniqueness",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$ErrorVariableNotFound = (($1) => ([
  "$ErrorVariableNotFound",
  $1,
]));

const u0Compiler$TypeCheck$ErrorWrongNumberOfArguments = (($1) => ([
  "$ErrorWrongNumberOfArguments",
  $1,
]));

const u0Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments = ([
  "$ErrorWrongNumberOfConstructorArguments",
]);

const u0Compiler$TypeCheck$ErrorWrongNumberOfParameters = ([
  "$ErrorWrongNumberOfParameters",
]);

const u0Compiler$TypeCheck$ErrorWrongNumberOfTypeArguments = (($1, $2, $3) => ([
  "$ErrorWrongNumberOfTypeArguments",
  $1,
  $2,
  $3,
]));

const u0Compiler$TypeCheck$Why_Annotation = ([
  "$Why_Annotation",
]);

const u0Compiler$TypeCheck$Why_Argument = (($1) => ([
  "$Why_Argument",
  $1,
]));

const u0Compiler$TypeCheck$Why_Attribute = (($1) => ([
  "$Why_Attribute",
  $1,
]));

const u0Compiler$TypeCheck$Why_CalledAsFunction = ([
  "$Why_CalledAsFunction",
]);

const u0Compiler$TypeCheck$Why_FunctionInput = (($1, $2) => ([
  "$Why_FunctionInput",
  $1,
  $2,
]));

const u0Compiler$TypeCheck$Why_FunctionOutput = (($1) => ([
  "$Why_FunctionOutput",
  $1,
]));

const u0Compiler$TypeCheck$Why_IfBranches = ([
  "$Why_IfBranches",
]);

const u0Compiler$TypeCheck$Why_IfCondition = ([
  "$Why_IfCondition",
]);

const u0Compiler$TypeCheck$Why_LetIn = ([
  "$Why_LetIn",
]);

const u0Compiler$TypeCheck$Why_Record = ([
  "$Why_Record",
]);

const u0Compiler$TypeCheck$Why_RecordAccess = ([
  "$Why_RecordAccess",
]);

const u0Compiler$TypeCheck$Why_RecordExt = ([
  "$Why_RecordExt",
]);

const u0Compiler$TypeCheck$Why_TryExpression = ([
  "$Why_TryExpression",
]);

const u0Compiler$TypeCheck$Why_TryPattern = ([
  "$Why_TryPattern",
]);

const u0Compiler$TypeCheck$Why_TypeArgument = (($1, $2, $3) => ([
  "$Why_TypeArgument",
  $1,
  $2,
  $3,
]));

const u0Compiler$UniquenessCheck$Available = ([
  "$Available",
]);

const u0Compiler$UniquenessCheck$ConsumedAt = (($1) => ([
  "$ConsumedAt",
  $1,
]));

const u0Compiler$UniquenessCheck$Immutable = ([
  "$Immutable",
]);

const u0Compiler$UniquenessCheck$Unique = (($1) => ([
  "$Unique",
  $1,
]));

const u0ImportsFile$Core = ([
  "$Core",
]);

const u0ImportsFile$Dir = (($1) => ([
  "$Dir",
  $1,
]));

const u0ImportsFile$Installed = (($1) => ([
  "$Installed",
  $1,
]));

const u0ImportsFile$Lib = (($1) => ([
  "$Lib",
  $1,
]));

const u0ImportsFile$Local = (($1) => ([
  "$Local",
  $1,
]));

const u0SPLib$Format$Blank = ([
  "$Blank",
]);

const u0SPLib$Format$CommentIgnoreIndent = (($1) => ([
  "$CommentIgnoreIndent",
  $1,
]));

const u0SPLib$Format$CommentWithIndent = (($1) => ([
  "$CommentWithIndent",
  $1,
]));

const u0SPLib$Format$Empty = ([
  "$Empty",
]);

const u0SPLib$Format$Indented = (($1, $2) => ([
  "$Indented",
  $1,
  $2,
]));

const u0SPLib$Format$MustBreakAtEnd = ([
  "$MustBreakAtEnd",
]);

const u0SPLib$Format$NoRequiredBreaks = ([
  "$NoRequiredBreaks",
]);

const u0SPLib$Format$Row = (($1, $2) => ([
  "$Row",
  $1,
  $2,
]));

const u0SPLib$Format$SingleLine = (($1, $2) => ([
  "$SingleLine",
  $1,
  $2,
]));

const u0SPLib$Format$Space = ([
  "$Space",
]);

const u0SPLib$Format$Stack = (($1, $2) => ([
  "$Stack",
  $1,
  $2,
]));

const u0SPLib$Format$Text_ = (($1) => ([
  "$Text_",
  $1,
]));

const u0SPLib$Parser$Aborted = (($1, $2) => ([
  "$Aborted",
  $1,
  $2,
]));

const u0SPLib$Parser$Accepted = (($1, $2) => ([
  "$Accepted",
  $1,
  $2,
]));

const u0SPLib$Parser$Rejected = ([
  "$Rejected",
]);

const u0SPLib$SPON$Accepted = (($1, $2) => ([
  "$Accepted",
  $1,
  $2,
]));

const u0SPLib$SPON$Failed = (($1) => ([
  "$Failed",
  $1,
]));

const u0SPLib$SPON$Rejected = (($1) => ([
  "$Rejected",
  $1,
]));

const u0Targets$Javascript$Ast$AccessWithBrackets = (($1, $2) => ([
  "$AccessWithBrackets",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$AccessWithDot = (($1, $2) => ([
  "$AccessWithDot",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$Array = (($1) => ([
  "$Array",
  $1,
]));

const u0Targets$Javascript$Ast$Binop = (($1, $2, $3) => ([
  "$Binop",
  $1,
  $2,
  $3,
]));

const u0Targets$Javascript$Ast$BlockLambda = (($1, $2) => ([
  "$BlockLambda",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$Call = (($1, $2) => ([
  "$Call",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$Comma = (($1) => ([
  "$Comma",
  $1,
]));

const u0Targets$Javascript$Ast$Conditional = (($1, $2, $3) => ([
  "$Conditional",
  $1,
  $2,
  $3,
]));

const u0Targets$Javascript$Ast$Define = (($1, $2, $3) => ([
  "$Define",
  $1,
  $2,
  $3,
]));

const u0Targets$Javascript$Ast$Eval = (($1) => ([
  "$Eval",
  $1,
]));

const u0Targets$Javascript$Ast$If = (($1, $2) => ([
  "$If",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$Literal = (($1) => ([
  "$Literal",
  $1,
]));

const u0Targets$Javascript$Ast$Mutop = (($1, $2, $3, $4) => ([
  "$Mutop",
  $1,
  $2,
  $3,
  $4,
]));

const u0Targets$Javascript$Ast$Record = (($1) => ([
  "$Record",
  $1,
]));

const u0Targets$Javascript$Ast$Return = (($1) => ([
  "$Return",
  $1,
]));

const u0Targets$Javascript$Ast$SimpleLambda = (($1, $2) => ([
  "$SimpleLambda",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$Unop = (($1, $2) => ([
  "$Unop",
  $1,
  $2,
]));

const u0Targets$Javascript$Ast$Var = (($1) => ([
  "$Var",
  $1,
]));

const u0Targets$Javascript$EmittableToJs$Block = (($1) => ([
  "$Block",
  $1,
]));

const u0Targets$Javascript$EmittableToJs$Inline = (($1) => ([
  "$Inline",
  $1,
]));

const u0Targets$Javascript$EmittableToJs$Override = (($1) => ([
  "$Override",
  $1,
]));

const i1Test$maybeToOutcome = (($m) => {
  return ((($m)[0] === "$Just")
    ? ((() => {
      const $e = ($m)[1];
      return (i1Test$Error)($e);
    }))()
    : ((($m)[0] === "$Nothing")
      ? i1Test$Success
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 15:4', (sp_toHuman)($m))));
});

const i1Test$valueTest = (($toText, $title, $generateValue, $ce) => {
  const $5 = $ce;
  const $toMaybeError = ($5)[1];
  return (i1Test$Single)($title, "", ((_0) => {
    return (i1Test$maybeToOutcome)(((($0) => {
      return ($toMaybeError)($toText, $0);
    }))((c0Result$Ok)(($generateValue)(null))));
  }));
});

const c0Array_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const c0Text$join = (($sep, $listOfText) => {
  return ((($listOfText)[0] === "$Nil")
    ? ""
    : ((($listOfText)[0] === "$Cons")
      ? ((() => {
        const $head = ($listOfText)[1];
        const $tail = ($listOfText)[2];
        const $rec = (($ls, $acc) => {
          return ((($ls)[0] === "$Nil")
            ? $acc
            : ((($ls)[0] === "$Cons")
              ? ((() => {
                const $h = ($ls)[1];
                const $t = ($ls)[2];
                return ($rec)($t, ($acc + ($sep + $h)));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 139:16', (sp_toHuman)($ls))));
        });
        return ($rec)($tail, $head);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 131:4', (sp_toHuman)($listOfText))));
});

const i1Test$isOkAndEqualTo = (($expectedOk) => {
  return (i1Test$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        return (c0Maybe$Just)($e);
      }))()
      : ((($result)[0] === "$Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return ((sp_equal)($actualOk, $expectedOk)
            ? c0Maybe$Nothing
            : (c0Maybe$Just)(((($0) => {
              return (c0Text$join)("\n", $0);
            }))((c0Core$Cons)("expected = ", (c0Core$Cons)(($toText)($expectedOk), (c0Core$Cons)("", (c0Core$Cons)("actual = ", (c0Core$Cons)(($toText)($actualOk), c0Core$Nil))))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 73:8', (sp_toHuman)($result))));
  }));
});

const c0Array_Test$tests = (i1Test$Group)("Array", (c0Core$Cons)((c0Array_Test$valueTest)("push", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)("a", c0Core$Nil));
  ((__re__ = (array_push)($a, "b")), ($a = (__re__)[1]), (__re__)[0]);
  ((__re__ = (array_push)($a, "c")), ($a = (__re__)[1]), (__re__)[0]);
  return ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("a", (c0Core$Cons)("b", (c0Core$Cons)("c", c0Core$Nil))))), (c0Core$Cons)((c0Array_Test$valueTest)("pop 1", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)("x", (c0Core$Cons)("y", (c0Core$Cons)("z", c0Core$Nil))));
  const $b = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $c = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
}), (i1Test$isOkAndEqualTo)(({
  b: (c0Maybe$Just)("z"),
  c: (c0Maybe$Just)("y"),
  l: (c0Core$Cons)("x", c0Core$Nil),
}))), (c0Core$Cons)((c0Array_Test$valueTest)("pop empty", ((_0) => {
  let $a = (array_fromList)(c0Core$Nil);
  const $b = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    b: $b,
    l: $l,
  });
}), (i1Test$isOkAndEqualTo)(({
  b: c0Maybe$Nothing,
  l: c0Core$Nil,
}))), (c0Core$Cons)((c0Array_Test$valueTest)("get Just", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)("p", (c0Core$Cons)("q", c0Core$Nil)));
  return ((__re__ = (array_get)($a, 1)), ($a = (__re__)[1]), (__re__)[0]);
}), (i1Test$isOkAndEqualTo)((c0Maybe$Just)("q"))), (c0Core$Cons)((c0Array_Test$valueTest)("get Nothing", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)("p", (c0Core$Cons)("q", c0Core$Nil)));
  return ((__re__ = (array_get)($a, 3)), ($a = (__re__)[1]), (__re__)[0]);
}), (i1Test$isOkAndEqualTo)(c0Maybe$Nothing)), (c0Core$Cons)((c0Array_Test$valueTest)("set success", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)(8, (c0Core$Cons)(9, c0Core$Nil)));
  const $r = ((__re__ = (array_set)($a, 0, 10)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    l: $l,
    r: $r,
  });
}), (i1Test$isOkAndEqualTo)(({
  l: (c0Core$Cons)(10, (c0Core$Cons)(9, c0Core$Nil)),
  r: true,
}))), (c0Core$Cons)((c0Array_Test$valueTest)("set fail", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)(8, (c0Core$Cons)(9, c0Core$Nil)));
  const $r = ((__re__ = (array_set)($a, 3, 10)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    l: $l,
    r: $r,
  });
}), (i1Test$isOkAndEqualTo)(({
  l: (c0Core$Cons)(8, (c0Core$Cons)(9, c0Core$Nil)),
  r: false,
}))), (c0Core$Cons)((c0Array_Test$valueTest)("sortBy", ((_0) => {
  let $a = (array_fromList)((c0Core$Cons)(55, (c0Core$Cons)(99, (c0Core$Cons)(22, c0Core$Nil))));
  ((__re__ = (array_sortBy)($a, (($x) => {
    return -($x);
  }))), ($a = (__re__)[1]), (__re__)[0]);
  return ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)(99, (c0Core$Cons)(55, (c0Core$Cons)(22, c0Core$Nil))))), c0Core$Nil)))))))));

const c0Basics$identity = (($a) => {
  return $a;
});

const c0Basics$applyIf = (($condition, $f) => {
  return ($condition
    ? $f
    : c0Basics$identity);
});

const c0Basics$btw = (($f, $a, $c) => {
  ($f)($a);
  return $c;
});

const c0Basics$clamp = (($low, $high, $n) => {
  return (($n < $low)
    ? $low
    : (($n > $high)
      ? $high
      : $n));
});

const c0Basics$max = (($a, $b) => {
  return (($a > $b)
    ? $a
    : $b);
});

const c0Basics$min = (($a, $b) => {
  return (($a < $b)
    ? $a
    : $b);
});

const c0Basics$not = (($b) => {
  return ($b
    ? false
    : true);
});

const c0Compiler$Ast$toImm = (($raw) => {
  return ({
    raw: $raw,
    uni: c0Compiler$Ast$Imm,
  });
});

const c0Compiler$Ast$toUni = (($raw) => {
  return ({
    raw: $raw,
    uni: c0Compiler$Ast$Uni,
  });
});

const c0Compiler$CanonicalAst$expressionPos = (($exp) => {
  return ((($exp)[0] === "$LiteralNumber")
    ? ((() => {
      const $p = ($exp)[1];
      return $p;
    }))()
    : ((($exp)[0] === "$LiteralText")
      ? ((() => {
        const $p = ($exp)[1];
        return $p;
      }))()
      : ((($exp)[0] === "$Variable")
        ? ((() => {
          const $p = ($exp)[1];
          return $p;
        }))()
        : ((($exp)[0] === "$Constructor")
          ? ((() => {
            const $p = ($exp)[1];
            return $p;
          }))()
          : ((($exp)[0] === "$Fn")
            ? ((() => {
              const $p = ($exp)[1];
              return $p;
            }))()
            : ((($exp)[0] === "$Call")
              ? ((() => {
                const $p = ($exp)[1];
                return $p;
              }))()
              : ((($exp)[0] === "$Record")
                ? ((() => {
                  const $p = ($exp)[1];
                  return $p;
                }))()
                : ((($exp)[0] === "$RecordAccess")
                  ? ((() => {
                    const $p = ($exp)[1];
                    return $p;
                  }))()
                  : ((($exp)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($exp)[1];
                      const $e = ($exp)[2];
                      return (c0Compiler$CanonicalAst$expressionPos)($e);
                    }))()
                    : ((($exp)[0] === "$If")
                      ? ((() => {
                        const $p = ($exp)[1];
                        return $p;
                      }))()
                      : ((($exp)[0] === "$Try")
                        ? ((() => {
                          const $p = ($exp)[1];
                          return $p;
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 280:4', (sp_toHuman)($exp)))))))))))));
});

const c0Dict$empty = c0Dict$RBEmpty_elm_builtin;

const c0Compiler$CanonicalAst$initModule = (($fsPath, $umr, $asText) => {
  return ({
    aliasDefs: c0Dict$empty,
    asText: $asText,
    constructorDefs: c0Dict$empty,
    fsPath: $fsPath,
    umr: $umr,
    valueDefs: c0Dict$empty,
    variantTypeDefs: c0Dict$empty,
  });
});

const c0Compiler$CanonicalAst$parTypeToRaw = (($p) => {
  return ((($p)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($p)[1];
      return $raw;
    }))()
    : ((($p)[0] === "$ParSp")
      ? ((() => {
        const $full = ($p)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 169:4', (sp_toHuman)($p))));
});

const c0Dict$for = (($acc, $dict, $func) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? $acc
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (c0Dict$for)(($func)($key, $value, (c0Dict$for)($acc, $left, $func)), $right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 361:4', (sp_toHuman)($dict))));
});

const c0List$for = (($init, $aList, $function) => {
  return ((($aList)[0] === "$Nil")
    ? $init
    : ((($aList)[0] === "$Cons")
      ? ((() => {
        const $h = ($aList)[1];
        const $tail = ($aList)[2];
        return (c0List$for)(($function)($h, $init), $tail, $function);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 80:4', (sp_toHuman)($aList))));
});

const c0Compiler$CanonicalAst$patternNames = ((() => {
  const $rec = (($p, $acc) => {
    return (((($p)[0] === "$PatternAny") && ((($p)[2])[0] === "$Nothing"))
      ? ((() => {
        const $pos = ($p)[1];
        return $acc;
      }))()
      : (((($p)[0] === "$PatternAny") && ((($p)[2])[0] === "$Just"))
        ? ((() => {
          const $pos = ($p)[1];
          const $name = (($p)[2])[1];
          const $maybeAnnotation = ($p)[3];
          return (c0Core$Cons)(({
            maybeAnnotation: $maybeAnnotation,
            name: $name,
            pos: $pos,
          }), $acc);
        }))()
        : ((($p)[0] === "$PatternLiteralNumber")
          ? ((() => {
            const $pos = ($p)[1];
            return $acc;
          }))()
          : ((($p)[0] === "$PatternLiteralText")
            ? ((() => {
              const $pos = ($p)[1];
              return $acc;
            }))()
            : ((($p)[0] === "$PatternConstructor")
              ? ((() => {
                const $pos = ($p)[1];
                const $path = ($p)[2];
                const $ps = ($p)[3];
                return (c0List$for)($acc, $ps, $rec);
              }))()
              : ((($p)[0] === "$PatternRecord")
                ? ((() => {
                  const $pos = ($p)[1];
                  const $ps = ($p)[3];
                  return (c0Dict$for)($acc, $ps, (($k, $v, $a) => {
                    return ($rec)($v, $a);
                  }));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 267:8', (sp_toHuman)($p))))))));
  });
  return (($0) => {
    return ($rec)($0, c0Core$Nil);
  });
}))();

const c0Compiler$CanonicalAst$patternPos = (($pa) => {
  return ((($pa)[0] === "$PatternAny")
    ? ((() => {
      const $p = ($pa)[1];
      return $p;
    }))()
    : ((($pa)[0] === "$PatternLiteralText")
      ? ((() => {
        const $p = ($pa)[1];
        return $p;
      }))()
      : ((($pa)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $p = ($pa)[1];
          return $p;
        }))()
        : ((($pa)[0] === "$PatternConstructor")
          ? ((() => {
            const $p = ($pa)[1];
            return $p;
          }))()
          : ((($pa)[0] === "$PatternRecord")
            ? ((() => {
              const $p = ($pa)[1];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 234:4', (sp_toHuman)($pa)))))));
});

const c0Dict$balance = (($color, $key, $value, $left, $right) => {
  return (((($right)[0] === "$RBNode_elm_builtin") && ((($right)[1])[0] === "$Red"))
    ? ((() => {
      const $rK = ($right)[2];
      const $rV = ($right)[3];
      const $rLeft = ($right)[4];
      const $rRight = ($right)[5];
      return (((($left)[0] === "$RBNode_elm_builtin") && ((($left)[1])[0] === "$Red"))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $lLeft = ($left)[4];
          const $lRight = ($left)[5];
          return (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $key, $value, (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $lK, $lV, $lLeft, $lRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $rK, $rV, $rLeft, $rRight));
        }))()
        : (true
          ? (c0Dict$RBNode_elm_builtin)($color, $rK, $rV, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $key, $value, $left, $rLeft), $rRight)
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 84:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? (((($left)[0] === "$RBNode_elm_builtin") && (((($left)[1])[0] === "$Red") && (((($left)[4])[0] === "$RBNode_elm_builtin") && (((($left)[4])[1])[0] === "$Red"))))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $llK = (($left)[4])[2];
          const $llV = (($left)[4])[3];
          const $llLeft = (($left)[4])[4];
          const $llRight = (($left)[4])[5];
          const $lRight = ($left)[5];
          return (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $llK, $llV, $llLeft, $llRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $key, $value, $lRight, $right));
        }))()
        : (true
          ? (c0Dict$RBNode_elm_builtin)($color, $key, $value, $left, $right)
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 89:12', (sp_toHuman)($left))))
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 81:4', (sp_toHuman)($right))));
});

const c0Dict$insertHelp = (($key, $value, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $key, $value, c0Dict$RBEmpty_elm_builtin, c0Dict$RBEmpty_elm_builtin)
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $nColor = ($dict)[1];
        const $nKey = ($dict)[2];
        const $nValue = ($dict)[3];
        const $nLeft = ($dict)[4];
        const $nRight = ($dict)[5];
        const $4 = (basics_compare)($key, $nKey);
        return ((1 === $4)
          ? (c0Dict$balance)($nColor, $nKey, $nValue, $nLeft, (c0Dict$insertHelp)($key, $value, $nRight))
          : ((0 === $4)
            ? (c0Dict$RBNode_elm_builtin)($nColor, $nKey, $value, $nLeft, $nRight)
            : (true
              ? (c0Dict$balance)($nColor, $nKey, $nValue, (c0Dict$insertHelp)($key, $value, $nLeft), $nRight)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 73:12', (sp_toHuman)($4)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 65:4', (sp_toHuman)($dict))));
});

const c0Dict$insert = (($key, $value, $dict) => {
  const $4 = (c0Dict$insertHelp)($key, $value, $dict);
  return (((($4)[0] === "$RBNode_elm_builtin") && ((($4)[1])[0] === "$Red"))
    ? ((() => {
      const $k = ($4)[2];
      const $v = ($4)[3];
      const $l = ($4)[4];
      const $r = ($4)[5];
      return (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $4;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 58:4', (sp_toHuman)($4))));
});

const c0Dict$join = (($0, $1) => {
  return (c0Dict$for)($0, $1, c0Dict$insert);
});

const c0Dict$ofOne = (($key, $value) => {
  return (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $key, $value, c0Dict$RBEmpty_elm_builtin, c0Dict$RBEmpty_elm_builtin);
});

const c0Dict$forReversed = (($acc, $t, $func) => {
  return ((($t)[0] === "$RBEmpty_elm_builtin")
    ? $acc
    : ((($t)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($t)[2];
        const $value = ($t)[3];
        const $left = ($t)[4];
        const $right = ($t)[5];
        return (c0Dict$forReversed)(($func)($key, $value, (c0Dict$forReversed)($acc, $right, $func)), $left, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 383:4', (sp_toHuman)($t))));
});

const c0Dict$values = (($0) => {
  return (c0Dict$forReversed)(c0Core$Nil, $0, (($key, $value, $valueList) => {
    return (c0Core$Cons)($value, $valueList);
  }));
});

const c0List$reverse = (($aList) => {
  return (c0List$for)(c0Core$Nil, $aList, c0Core$Cons);
});

const c0List$forReversed = (($init, $list, $f) => {
  const $foldrHelper = (($acc, $ctr, $ls) => {
    return ((($ls)[0] === "$Nil")
      ? $acc
      : ((($ls)[0] === "$Cons")
        ? ((() => {
          const $a = ($ls)[1];
          const $r1 = ($ls)[2];
          return ((($r1)[0] === "$Nil")
            ? ($f)($a, $acc)
            : ((($r1)[0] === "$Cons")
              ? ((() => {
                const $b = ($r1)[1];
                const $r2 = ($r1)[2];
                return ((($r2)[0] === "$Nil")
                  ? ($f)($a, ($f)($b, $acc))
                  : ((($r2)[0] === "$Cons")
                    ? ((() => {
                      const $c = ($r2)[1];
                      const $r3 = ($r2)[2];
                      return ((($r3)[0] === "$Nil")
                        ? ($f)($a, ($f)($b, ($f)($c, $acc)))
                        : ((($r3)[0] === "$Cons")
                          ? ((() => {
                            const $d = ($r3)[1];
                            const $r4 = ($r3)[2];
                            const $res = (($ctr > 500)
                              ? (c0List$for)($acc, (c0List$reverse)($r4), $f)
                              : ($foldrHelper)($acc, ($ctr + 1), $r4));
                            return ($f)($a, ($f)($b, ($f)($c, ($f)($d, $res))));
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 125:32', (sp_toHuman)($r3))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 119:24', (sp_toHuman)($r2))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 113:16', (sp_toHuman)($r1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 107:8', (sp_toHuman)($ls))));
  });
  return ($foldrHelper)($init, 0, $list);
});

const c0List$map = (($f, $list) => {
  return (c0List$forReversed)(c0Core$Nil, $list, (($x, $acc) => {
    return (sp_cons)(($f)($x), $acc);
  }));
});

const c0Compiler$CanonicalAst$typeTyvars = (($raw) => {
  const $fromList = (($list) => {
    return (c0List$for)(c0Dict$empty, $list, (($item, $acc) => {
      return (c0Dict$join)($acc, (c0Compiler$CanonicalAst$typeTyvars)($item));
    }));
  });
  return ((($raw)[0] === "$TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList)($args);
    }))()
    : ((($raw)[0] === "$TypeFn")
      ? ((() => {
        const $pars = ($raw)[2];
        const $to = ($raw)[3];
        return ($fromList)((sp_cons)($to.raw, (c0List$map)(c0Compiler$CanonicalAst$parTypeToRaw, $pars)));
      }))()
      : ((($raw)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($raw)[2];
          return ($fromList)((c0Dict$values)($attrs));
        }))()
        : ((($raw)[0] === "$TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($raw)[1];
            const $name = ($raw)[2];
            return (c0Dict$ofOne)($name, $pos);
          }))()
          : ((($raw)[0] === "$TypeError")
            ? c0Dict$empty
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 180:4', (sp_toHuman)($raw)))))));
});

const c0Compiler$CanonicalAst$typeUnivars = (($raw) => {
  const $fromList = (($list) => {
    return (c0List$for)(c0Dict$empty, $list, (($item, $acc) => {
      return (c0Dict$join)($acc, (c0Compiler$CanonicalAst$typeUnivars)($item));
    }));
  });
  const $insertUni = (($uni, $acc) => {
    return ((($uni)[0] === "$Depends")
      ? ((() => {
        const $uid = ($uni)[1];
        return (c0Dict$insert)($uid, null, $acc);
      }))()
      : (true
        ? $acc
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 196:8', (sp_toHuman)($uni))));
  });
  const $parUnivars = (($par, $acc) => {
    return ((($par)[0] === "$ParRe")
      ? $acc
      : ((($par)[0] === "$ParSp")
        ? ((() => {
          const $full = ($par)[1];
          return ((($0) => {
            return ($insertUni)($full.uni, $0);
          }))(((($0) => {
            return (c0Dict$join)($0, (c0Compiler$CanonicalAst$typeUnivars)($full.raw));
          }))($acc));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 202:8', (sp_toHuman)($par))));
  });
  return ((($raw)[0] === "$TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList)($args);
    }))()
    : ((($raw)[0] === "$TypeRecord")
      ? ((() => {
        const $attrs = ($raw)[2];
        return ($fromList)((c0Dict$values)($attrs));
      }))()
      : ((($raw)[0] === "$TypeAnnotationVariable")
        ? ((() => {
          const $pos = ($raw)[1];
          const $name = ($raw)[2];
          return c0Dict$empty;
        }))()
        : ((($raw)[0] === "$TypeError")
          ? c0Dict$empty
          : ((($raw)[0] === "$TypeFn")
            ? ((() => {
              const $pars = ($raw)[2];
              const $to = ($raw)[3];
              return ((($0) => {
                return (c0List$for)($0, $pars, $parUnivars);
              }))(((($0) => {
                return ($insertUni)($to.uni, $0);
              }))(c0Dict$empty));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 212:4', (sp_toHuman)($raw)))))));
});

const c0Compiler$FormattableAst$binopChainAllBinops = (($f, $ls) => {
  const $3 = $ls.second;
  return ((($3)[0] === "$Nil")
    ? true
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $sep = ($3)[1].first;
        const $item = ($3)[1].second;
        const $tail = ($3)[2];
        return (($f)($sep)
          ? (c0Compiler$FormattableAst$binopChainAllBinops)($f, ({
            first: $item,
            second: $tail,
          }))
          : false);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 172:4', (sp_toHuman)($3))));
});

const c0Tuple$second = (($t) => {
  return $t.second;
});

const c0Compiler$FormattableAst$binopChainExpressions = (($1) => {
  const $head = $1.first;
  const $tuples = $1.second;
  return (sp_cons)($head, (c0List$map)(c0Tuple$second, $tuples));
});

const c0Compiler$FormattableAst$binopChainReverse = ((() => {
  const $rec = (($acc, $1) => {
    const $oddItem = $1.first;
    const $remainder = $1.second;
    return ((($remainder)[0] === "$Nil")
      ? ({
        first: $oddItem,
        second: $acc,
      })
      : ((($remainder)[0] === "$Cons")
        ? ((() => {
          const $sep = ($remainder)[1].first;
          const $item = ($remainder)[1].second;
          const $tail = ($remainder)[2];
          return ($rec)((c0Core$Cons)(({
            first: $sep,
            second: $oddItem,
          }), $acc), ({
            first: $item,
            second: $tail,
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 163:8', (sp_toHuman)($remainder))));
  });
  return (($0) => {
    return ($rec)(c0Core$Nil, $0);
  });
}))();

const c0Compiler$FormattableAst$statementPos = (($statement) => {
  return ((($statement)[0] === "$CommentStatement")
    ? ((() => {
      const $end = ($statement)[1].end;
      const $start = ($statement)[1].start;
      return (c0Compiler$Pos$P)($start, $end);
    }))()
    : (((($statement)[0] === "$Evaluation") && ((($statement)[1])[0] === "$Expression"))
      ? ((() => {
        const $pos = (($statement)[1])[2];
        const $expr_ = (($statement)[1])[3];
        return $pos;
      }))()
      : (((($statement)[0] === "$ValueDef") && ((($statement)[1].pattern)[0] === "$Expression"))
        ? ((() => {
          const $body = ($statement)[1].body;
          const $nonFn = ($statement)[1].nonFn;
          const $pos = (($statement)[1].pattern)[2];
          const $expr_ = (($statement)[1].pattern)[3];
          return $pos;
        }))()
        : ((($statement)[0] === "$AliasDef")
          ? ((() => {
            const $args = ($statement)[1].args;
            const $name = ($statement)[1].name;
            const $type = ($statement)[1].type;
            return $name.first;
          }))()
          : ((($statement)[0] === "$UnionDef")
            ? ((() => {
              const $args = ($statement)[1].args;
              const $constructors = ($statement)[1].constructors;
              const $name = ($statement)[1].name;
              return $name.first;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 186:4', (sp_toHuman)($statement)))))));
});

const c0Compiler$Meta$initImports = ({
  globalNameToLocation: c0Dict$empty,
  moduleAliasToLocation: c0Dict$empty,
  modulePathToLocation: c0Dict$empty,
});

const c0Dict$get = (($targetKey, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? c0Maybe$Nothing
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        const $3 = (basics_compare)($targetKey, $key);
        return ((1 === $3)
          ? (c0Dict$get)($targetKey, $right)
          : ((0 === $3)
            ? (c0Maybe$Just)($value)
            : (true
              ? (c0Dict$get)($targetKey, $left)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 25:12', (sp_toHuman)($3)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 19:4', (sp_toHuman)($dict))));
});

const c0List$filterMap = (($f, $la) => {
  const $update = (($a, $acc) => {
    const $5 = ($f)($a);
    return ((($5)[0] === "$Just")
      ? ((() => {
        const $b = ($5)[1];
        return (sp_cons)($b, $acc);
      }))()
      : ((($5)[0] === "$Nothing")
        ? $acc
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 347:8', (sp_toHuman)($5))));
  });
  return (c0List$forReversed)(c0Core$Nil, $la, $update);
});

const c0Result$onOk = (($f) => {
  return (($result) => {
    return ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        return (c0Result$Err)($e);
      }))()
      : ((($result)[0] === "$Ok")
        ? ((() => {
          const $a = ($result)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 16:4', (sp_toHuman)($result))));
  });
});

const c0Compiler$Meta$resolveLocation = (($pars, $location, $maybeReferencedModuleAlias, $referencedName) => {
  return ((($location)[0] === "$LocationSourceDir")
    ? ((() => {
      const $umr = ($location)[1];
      return (c0Result$Ok)((c0Compiler$Meta$USR)($umr, $referencedName));
    }))()
    : ((($location)[0] === "$LocationLibrary")
      ? ((() => {
        const $importsPath = ($location)[1];
        const $modulePath = ($location)[2];
        return ((c0Result$onOk)((($modulesByPath) => {
          const $6 = (c0Dict$get)($modulePath, $modulesByPath);
          return ((($6)[0] === "$Nothing")
            ? ((($maybeReferencedModuleAlias)[0] === "$Just")
              ? ((() => {
                const $referencedModuleAlias = ($maybeReferencedModuleAlias)[1];
                return (c0Result$Err)(($pars.makeError)(((($0) => {
                  return (c0List$filterMap)(c0Basics$identity, $0);
                }))((c0Core$Cons)(((sp_equal)($referencedModuleAlias, $modulePath)
                  ? c0Maybe$Nothing
                  : (c0Maybe$Just)(("imports.sp translates `" + ($referencedModuleAlias + ("` as `" + ($modulePath + "`")))))), (c0Core$Cons)((c0Maybe$Just)(("However, library $directoryPathOfLibrary does not expose any " + ($modulePath + " module."))), c0Core$Nil)))));
              }))()
              : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
                ? (c0Result$Err)(($pars.makeError)((c0Core$Cons)(("Library cannot find: " + ($modulePath + (" which contains " + $referencedName))), c0Core$Nil)))
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 259:24', (sp_toHuman)($maybeReferencedModuleAlias))))
            : ((($6)[0] === "$Just")
              ? ((() => {
                const $moduleUsrByName = ($6)[1];
                const $7 = (c0Dict$get)($referencedName, $moduleUsrByName);
                return ((($7)[0] === "$Just")
                  ? ((() => {
                    const $exportOptions = ($7)[1];
                    return (c0Result$Ok)($exportOptions.usr);
                  }))()
                  : ((($7)[0] === "$Nothing")
                    ? ((($maybeReferencedModuleAlias)[0] === "$Just")
                      ? ((() => {
                        const $referencedModuleAlias = ($maybeReferencedModuleAlias)[1];
                        return (c0Result$Err)(($pars.makeError)(((sp_equal)($referencedModuleAlias, $modulePath)
                          ? (c0Core$Cons)(($modulePath + (" in library $directoryPathOfLibrary does not expose any `" + ($referencedName + "`."))), c0Core$Nil)
                          : (c0Core$Cons)(("imports.sp translates `" + ($referencedModuleAlias + ("` as `" + ($modulePath + "`")))), (c0Core$Cons)(("However, " + ($modulePath + (" in library $directoryPathOfLibrary does not expose any `" + ($referencedName + "`.")))), c0Core$Nil)))));
                      }))()
                      : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
                        ? (c0Result$Err)(($pars.makeError)((c0Core$Cons)(($referencedName + (" is not in " + $modulePath)), c0Core$Nil)))
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 287:32', (sp_toHuman)($maybeReferencedModuleAlias))))
                    : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 281:24', (sp_toHuman)($7))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 256:16', (sp_toHuman)($6))));
        })))(($pars.loadExports)($importsPath));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 240:4', (sp_toHuman)($location))));
});

const c0Compiler$Meta$resolve = (($pars, $maybeReferencedModuleAlias, $referencedName) => {
  return ((($maybeReferencedModuleAlias)[0] === "$Just")
    ? ((() => {
      const $alias = ($maybeReferencedModuleAlias)[1];
      const $4 = (c0Dict$get)($alias, $pars.currentImports.moduleAliasToLocation);
      return ((($4)[0] === "$Nothing")
        ? (c0Result$Err)(($pars.makeError)((c0Core$Cons)(("I cannot find the module: " + $alias), c0Core$Nil)))
        : ((($4)[0] === "$Just")
          ? ((() => {
            const $location = ($4)[1];
            return (c0Compiler$Meta$resolveLocation)($pars, $location, $maybeReferencedModuleAlias, $referencedName);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 220:12', (sp_toHuman)($4))));
    }))()
    : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
      ? ((() => {
        const $4 = (c0Dict$get)($referencedName, $pars.currentImports.globalNameToLocation);
        return ((($4)[0] === "$Nothing")
          ? (c0Result$Ok)((c0Compiler$Meta$USR)($pars.currentModule, $referencedName))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $location = ($4)[1];
              return (c0Compiler$Meta$resolveLocation)($pars, $location, $maybeReferencedModuleAlias, $referencedName);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 233:12', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 217:4', (sp_toHuman)($maybeReferencedModuleAlias))));
});

const c0Compiler$Meta$rootDirectoryToPath = (($paths, $rootDirectory) => {
  return ((($rootDirectory)[0] === "$Core")
    ? $paths.core
    : ((($rootDirectory)[0] === "$User")
      ? $paths.project
      : ((($rootDirectory)[0] === "$Installed")
        ? $paths.installed
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 118:4', (sp_toHuman)($rootDirectory)))));
});

const c0Compiler$Op$precedence_addittive = 7;

const c0Compiler$Op$precedence_application = 9;

const c0Compiler$Op$precedence_comparison = 6;

const c0Compiler$Op$precedence_cons = 3;

const c0Compiler$Op$precedence_function = 0;

const c0Compiler$Op$precedence_logical = 5;

const c0Compiler$Op$precedence_multiplicative = 8;

const c0Compiler$Op$precedence_mutop = 1;

const c0Compiler$Op$precedence_pipe = 2;

const c0Compiler$Op$precedence_tuple = 4;

const c0Compiler$Pos$range = (($a, $b) => {
  const $3 = ({
    first: $a,
    second: $b,
  });
  return (((($3.first)[0] === "$P") && (($3.second)[0] === "$P"))
    ? ((() => {
      const $sa = ($3.first)[1];
      const $ea = ($3.first)[2];
      const $sb = ($3.second)[1];
      const $eb = ($3.second)[2];
      return (c0Compiler$Pos$P)((c0Basics$min)($sa, $sb), (c0Basics$max)($ea, $eb));
    }))()
    : ((($3.first)[0] === "$P")
      ? $a
      : (true
        ? $b
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Pos.sp 46:4', (sp_toHuman)($3)))));
});

const c0Compiler$TypedAst$mapPars = (($f, $pars) => {
  const $zzz = (($par) => {
    return ((($par)[0] === "$ParRe")
      ? ((() => {
        const $raw = ($par)[1];
        return (c0Compiler$TypedAst$ParRe)(($f)($raw));
      }))()
      : ((($par)[0] === "$ParSp")
        ? ((() => {
          const $full = ($par)[1];
          return (c0Compiler$TypedAst$ParSp)(((() => {
            const $0 = $full;
            return (Object.assign)({}, $0, ({
              raw: ($f)($0.raw),
            }));
          }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 309:8', (sp_toHuman)($par))));
  });
  return (c0List$map)($zzz, $pars);
});

const c0Compiler$TypedAst$normalizeTyvarId = (($hash, $id) => {
  const $3 = ((__re__ = (hash_get)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]);
  return ([
    ((($3)[0] === "$Just")
      ? ((() => {
        const $nid = ($3)[1];
        return $nid;
      }))()
      : ((($3)[0] === "$Nothing")
        ? ((() => {
          let $maxId = 0;
          ((__re__ = (hash_each)($hash, (($k, $v) => {
            return (($v > ((__re__ = (basics_cloneUni)($maxId)), ($maxId = (__re__)[1]), (__re__)[0]))
              ? ($maxId = (basics_cloneImm)($v))
              : null);
          }))), ($hash = (__re__)[1]), (__re__)[0]);
          const $nid = ($maxId + 1);
          ((__re__ = (hash_insert)($hash, $id, $nid)), ($hash = (__re__)[1]), (__re__)[0]);
          return $nid;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 350:4', (sp_toHuman)($3)))),
    $hash,
  ]);
});

const c0Dict$map = (($func, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? c0Dict$RBEmpty_elm_builtin
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (c0Dict$RBNode_elm_builtin)($color, $key, ($func)($key, $value), (c0Dict$map)($func, $left), (c0Dict$map)($func, $right));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 317:4', (sp_toHuman)($dict))));
});

const c0Compiler$TypedAst$normalizeType = (($hash, $type) => {
  return ([
    ((($type)[0] === "$TypeExact")
      ? ((() => {
        const $usr = ($type)[1];
        const $args = ($type)[2];
        return (c0Compiler$TypedAst$TypeExact)($usr, (c0List$map)((($0) => {
          return ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $0)), ($hash = (__re__)[1]), (__re__)[0]);
        }), $args));
      }))()
      : ((($type)[0] === "$TypeFn")
        ? ((() => {
          const $pars = ($type)[1];
          const $out = ($type)[2];
          return (c0Compiler$TypedAst$TypeFn)((c0Compiler$TypedAst$mapPars)((($0) => {
            return ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $0)), ($hash = (__re__)[1]), (__re__)[0]);
          }), $pars), ((() => {
            const $0 = $out;
            return (Object.assign)({}, $0, ({
              raw: ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $0.raw)), ($hash = (__re__)[1]), (__re__)[0]),
            }));
          }))());
        }))()
        : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Nothing"))
          ? ((() => {
            const $attrs = ($type)[2];
            return (c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, (c0Dict$map)((($k, $v) => {
              return ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $v)), ($hash = (__re__)[1]), (__re__)[0]);
            }), $attrs));
          }))()
          : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Just"))
            ? ((() => {
              const $id = (($type)[1])[1];
              const $attrs = ($type)[2];
              return (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(((__re__ = (c0Compiler$TypedAst$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0])), (c0Dict$map)((($k, $v) => {
                return ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $v)), ($hash = (__re__)[1]), (__re__)[0]);
              }), $attrs));
            }))()
            : ((($type)[0] === "$TypeVar")
              ? ((() => {
                const $id = ($type)[1];
                return (c0Compiler$TypedAst$TypeVar)(((__re__ = (c0Compiler$TypedAst$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]));
              }))()
              : ((($type)[0] === "$TypeError")
                ? c0Compiler$TypedAst$TypeError
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 375:4', (sp_toHuman)($type)))))))),
    $hash,
  ]);
});

const c0Compiler$TypedAst$patternNames = (($p) => {
  return (((($p)[0] === "$PatternAny") && ((($p)[2].maybeName)[0] === "$Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return c0Dict$empty;
    }))()
    : (((($p)[0] === "$PatternAny") && ((($p)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $n = (($p)[2].maybeName)[1];
        const $type = ($p)[2].type;
        return (c0Dict$ofOne)($n, ({
          pos: $pos,
          type: $type,
        }));
      }))()
      : ((($p)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return c0Dict$empty;
        }))()
        : ((($p)[0] === "$PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return c0Dict$empty;
          }))()
          : ((($p)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $usr = ($p)[2];
              const $ps = ($p)[3];
              return (c0List$for)(c0Dict$empty, $ps, (($x, $a) => {
                return ((($0) => {
                  return (c0Dict$join)($0, $a);
                }))((c0Compiler$TypedAst$patternNames)($x));
              }));
            }))()
            : ((($p)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[2];
                return (c0Dict$for)(c0Dict$empty, $ps, (($k, $3, $a) => {
                  const $pa = $3.first;
                  const $ty = $3.second;
                  return ((($0) => {
                    return (c0Dict$join)($a, $0);
                  }))((c0Compiler$TypedAst$patternNames)($pa));
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 318:4', (sp_toHuman)($p))))))));
});

const c0Compiler$TypedAst$resolveParType = (($saf, $par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return (c0Compiler$TypedAst$ParRe)((c0Compiler$TypedAst$resolveRaw)($saf, $raw));
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return (c0Compiler$TypedAst$ParSp)((c0Compiler$TypedAst$resolveFull)($saf, $full));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 163:4', (sp_toHuman)($par))));
});

const c0Compiler$TypedAst$resolveRaw = (($saf, $raw) => {
  const $rec = (($0) => {
    return (c0Compiler$TypedAst$resolveRaw)($saf, $0);
  });
  return ((($raw)[0] === "$TypeVar")
    ? ((() => {
      const $id = ($raw)[1];
      const $3 = ($saf.ty)($id);
      return ((($3)[0] === "$Nothing")
        ? $raw
        : ((($3)[0] === "$Just")
          ? ((() => {
            const $replacement = ($3)[1];
            return $replacement;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 184:12', (sp_toHuman)($3))));
    }))()
    : ((($raw)[0] === "$TypeExact")
      ? ((() => {
        const $usr = ($raw)[1];
        const $pars = ($raw)[2];
        return (c0Compiler$TypedAst$TypeExact)($usr, (c0List$map)($rec, $pars));
      }))()
      : ((($raw)[0] === "$TypeFn")
        ? ((() => {
          const $pars = ($raw)[1];
          const $out = ($raw)[2];
          return (c0Compiler$TypedAst$TypeFn)((c0List$map)((($0) => {
            return (c0Compiler$TypedAst$resolveParType)($saf, $0);
          }), $pars), (c0Compiler$TypedAst$resolveFull)($saf, $out));
        }))()
        : (((($raw)[0] === "$TypeRecord") && ((($raw)[1])[0] === "$Nothing"))
          ? ((() => {
            const $attrs = ($raw)[2];
            return (c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, (c0Dict$map)((($k, $v) => {
              return ($rec)($v);
            }), $attrs));
          }))()
          : (((($raw)[0] === "$TypeRecord") && ((($raw)[1])[0] === "$Just"))
            ? ((() => {
              const $id = (($raw)[1])[1];
              const $attrs = ($raw)[2];
              const $3 = ($saf.ty)($id);
              return ((($3)[0] === "$Just")
                ? ((() => {
                  const $replacement = ($3)[1];
                  return $replacement;
                }))()
                : ((($3)[0] === "$Nothing")
                  ? (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($id), (c0Dict$map)((($k, $v) => {
                    return ($rec)($v);
                  }), $attrs))
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 198:12', (sp_toHuman)($3))));
            }))()
            : ((($raw)[0] === "$TypeError")
              ? c0Compiler$TypedAst$TypeError
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 181:4', (sp_toHuman)($raw))))))));
});

const c0Compiler$TypedAst$resolveUni = (($uniSub, $uni) => {
  return ((($uni)[0] === "$Depends")
    ? ((() => {
      const $id = ($uni)[1];
      const $3 = ($uniSub)($id);
      return ((($3)[0] === "$Nothing")
        ? $uni
        : ((($3)[0] === "$Just")
          ? ((() => {
            const $u = ($3)[1];
            return $u;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 153:12', (sp_toHuman)($3))));
    }))()
    : (true
      ? $uni
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 150:4', (sp_toHuman)($uni))));
});

const c0Compiler$TypedAst$resolveFull = (($saf, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return ({
    raw: (c0Compiler$TypedAst$resolveRaw)($saf, $raw),
    uni: (c0Compiler$TypedAst$resolveUni)($saf.uni, $uni),
  });
});

const c0Compiler$TypedAst$resolvePattern = (($saf, $pattern) => {
  return ((($pattern)[0] === "$PatternLiteralNumber")
    ? ((() => {
      const $pos = ($pattern)[1];
      return $pattern;
    }))()
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $pos = ($pattern)[1];
        return $pattern;
      }))()
      : ((($pattern)[0] === "$PatternAny")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $stuff = ($pattern)[2];
          return (c0Compiler$TypedAst$PatternAny)($pos, ((() => {
            const $0 = $stuff;
            return (Object.assign)({}, $0, ({
              type: (c0Compiler$TypedAst$resolveFull)($saf, $0.type),
            }));
          }))());
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $usr = ($pattern)[2];
            const $ps = ($pattern)[3];
            return (c0Compiler$TypedAst$PatternConstructor)($pos, $usr, (c0List$map)((($0) => {
              return (c0Compiler$TypedAst$resolvePattern)($saf, $0);
            }), $ps));
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $ps = ($pattern)[2];
              return (c0Compiler$TypedAst$PatternRecord)($pos, (c0Dict$map)((($k, $3) => {
                const $p = $3.first;
                const $t = $3.second;
                return ({
                  first: (c0Compiler$TypedAst$resolvePattern)($saf, $p),
                  second: (c0Compiler$TypedAst$resolveRaw)($saf, $t),
                });
              }), $ps));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 276:4', (sp_toHuman)($pattern)))))));
});

const c0Compiler$TypedAst$resolvePar = (($saf, $par) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $full = ($par)[1];
      const $pa = ($par)[2];
      return (c0Compiler$TypedAst$ParameterPattern)((c0Compiler$TypedAst$resolveFull)($saf, $full), (c0Compiler$TypedAst$resolvePattern)($saf, $pa));
    }))()
    : ((($par)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $full = ($par)[1];
        const $n = ($par)[2];
        return (c0Compiler$TypedAst$ParameterPlaceholder)((c0Compiler$TypedAst$resolveFull)($saf, $full), $n);
      }))()
      : ((($par)[0] === "$ParameterRecycle")
        ? ((() => {
          const $p = ($par)[1];
          const $raw = ($par)[2];
          const $name = ($par)[3];
          return (c0Compiler$TypedAst$ParameterRecycle)($p, (c0Compiler$TypedAst$resolveRaw)($saf, $raw), $name);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 215:4', (sp_toHuman)($par)))));
});

const c0Compiler$TypedAst$resolveValueDef = (($saf, $def) => {
  const $0 = $def;
  return (Object.assign)({}, $0, ({
    body: (c0Compiler$TypedAst$resolveExpression)($saf, $0.body),
    pattern: (c0Compiler$TypedAst$resolvePattern)($saf, $0.pattern),
    type: (c0Compiler$TypedAst$resolveFull)($saf, $0.type),
  }));
});

const c0Maybe$map = (($f, $m) => {
  return ((($m)[0] === "$Nothing")
    ? c0Maybe$Nothing
    : ((($m)[0] === "$Just")
      ? ((() => {
        const $v = ($m)[1];
        return (c0Maybe$Just)(($f)($v));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 16:4', (sp_toHuman)($m))));
});

const c0Tuple$mapBoth = (($fa, $fb, $t) => {
  return ({
    first: ($fa)($t.first),
    second: ($fb)($t.second),
  });
});

const c0Compiler$TypedAst$resolveExpression = (($saf, $expression) => {
  const $rec = (($0) => {
    return (c0Compiler$TypedAst$resolveExpression)($saf, $0);
  });
  return ((($expression)[0] === "$LiteralNumber")
    ? $expression
    : ((($expression)[0] === "$LiteralText")
      ? $expression
      : ((($expression)[0] === "$Variable")
        ? $expression
        : ((($expression)[0] === "$Constructor")
          ? $expression
          : ((($expression)[0] === "$Fn")
            ? ((() => {
              const $p = ($expression)[1];
              const $pars = ($expression)[2];
              const $body = ($expression)[3];
              const $bodyType = ($expression)[4];
              return (c0Compiler$TypedAst$Fn)($p, (c0List$map)((($0) => {
                return (c0Compiler$TypedAst$resolvePar)($saf, $0);
              }), $pars), ($rec)($body), (c0Compiler$TypedAst$resolveFull)($saf, $bodyType));
            }))()
            : ((($expression)[0] === "$Call")
              ? ((() => {
                const $p = ($expression)[1];
                const $ref = ($expression)[2];
                const $args = ($expression)[3];
                return (c0Compiler$TypedAst$Call)($p, ($rec)($ref), (c0List$map)((($0) => {
                  return (c0Compiler$TypedAst$resolveArg)($saf, $0);
                }), $args));
              }))()
              : ((($expression)[0] === "$Record")
                ? ((() => {
                  const $p = ($expression)[1];
                  const $maybeExt = ($expression)[2];
                  const $attrs = ($expression)[3];
                  return (c0Compiler$TypedAst$Record)($p, (c0Maybe$map)($rec, $maybeExt), (c0Dict$map)((($k, $v) => {
                    return ($rec)($v);
                  }), $attrs));
                }))()
                : ((($expression)[0] === "$RecordAccess")
                  ? ((() => {
                    const $p = ($expression)[1];
                    const $name = ($expression)[2];
                    const $exp = ($expression)[3];
                    return (c0Compiler$TypedAst$RecordAccess)($p, $name, ($rec)($exp));
                  }))()
                  : ((($expression)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($expression)[1];
                      const $rest = ($expression)[2];
                      const $restType = ($expression)[3];
                      return (c0Compiler$TypedAst$LetIn)((c0Compiler$TypedAst$resolveValueDef)($saf, $def), ($rec)($rest), (c0Compiler$TypedAst$resolveFull)($saf, $restType));
                    }))()
                    : ((($expression)[0] === "$If")
                      ? ((() => {
                        const $p = ($expression)[1];
                        const $condition = ($expression)[2].condition;
                        const $false = ($expression)[2].false;
                        const $true = ($expression)[2].true;
                        return (c0Compiler$TypedAst$If)($p, ({
                          condition: ($rec)($condition),
                          false: ($rec)($false),
                          true: ($rec)($true),
                        }));
                      }))()
                      : ((($expression)[0] === "$Try")
                        ? ((() => {
                          const $p = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          return (c0Compiler$TypedAst$Try)($p, ({
                            patternsAndExpressions: (c0List$map)((($0) => {
                              return (c0Tuple$mapBoth)((($0) => {
                                return (c0Compiler$TypedAst$resolvePattern)($saf, $0);
                              }), $rec, $0);
                            }), $patternsAndExpressions),
                            value: ($rec)($value),
                            valueType: (c0Compiler$TypedAst$resolveFull)($saf, $valueType),
                          }));
                        }))()
                        : ((($expression)[0] === "$DestroyIn")
                          ? ((() => {
                            const $n = ($expression)[1];
                            const $e = ($expression)[2];
                            return (c0Compiler$TypedAst$DestroyIn)($n, ($rec)($e));
                          }))()
                          : ((($expression)[0] === "$Error")
                            ? ((() => {
                              const $p = ($expression)[1];
                              return $expression;
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 226:4', (sp_toHuman)($expression)))))))))))))));
});

const c0Compiler$TypedAst$resolveArg = (($saf, $arg) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $full = ($arg)[1];
      const $expr = ($arg)[2];
      return (c0Compiler$TypedAst$ArgumentExpression)((c0Compiler$TypedAst$resolveFull)($saf, $full), (c0Compiler$TypedAst$resolveExpression)($saf, $expr));
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $attrPath = ($arg)[3];
        const $name = ($arg)[4];
        return (c0Compiler$TypedAst$ArgumentRecycle)($p, (c0Compiler$TypedAst$resolveRaw)($saf, $raw), $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 208:4', (sp_toHuman)($arg))));
});

const c0Compiler$TypedAst$toRaw = (($par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return $raw;
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 300:4', (sp_toHuman)($par))));
});

const c0Dict$any = (($f, $dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $v = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return (($f)($key, $v)
        ? true
        : ((c0Dict$any)($f, $left) || (c0Dict$any)($f, $right)));
    }))()
    : ((($dict)[0] === "$RBEmpty_elm_builtin")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 412:4', (sp_toHuman)($dict))));
});

const c0List$any = (($fun, $list) => {
  return ((($list)[0] === "$Nil")
    ? false
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($fun)($h)
          ? true
          : (c0List$any)($fun, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 3:4', (sp_toHuman)($list))));
});

const c0Compiler$TypedAst$typeAllowsFunctions = (($testId, $type) => {
  return ((($type)[0] === "$TypeFn")
    ? ((() => {
      const $ins = ($type)[1];
      const $out = ($type)[2];
      return true;
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return ($testId)($id);
      }))()
      : ((($type)[0] === "$TypeExact")
        ? ((() => {
          const $usr = ($type)[1];
          const $args = ($type)[2];
          return (c0List$any)((($0) => {
            return (c0Compiler$TypedAst$typeAllowsFunctions)($testId, $0);
          }), $args);
        }))()
        : ((($type)[0] === "$TypeRecord")
          ? ((() => {
            const $attrs = ($type)[2];
            return (c0Dict$any)((($k, $v) => {
              return (c0Compiler$TypedAst$typeAllowsFunctions)($testId, $v);
            }), $attrs);
          }))()
          : ((($type)[0] === "$TypeError")
            ? true
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 340:4', (sp_toHuman)($type)))))));
});

const c0Compiler$TypedAst$typeTyvars = (($type) => {
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($type)[1];
      const $args = ($type)[2];
      return (c0List$for)(c0Dict$empty, $args, (($a, $acc) => {
        return (c0Dict$join)((c0Compiler$TypedAst$typeTyvars)($a), $acc);
      }));
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return (c0Dict$ofOne)($id, null);
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Nothing"))
        ? ((() => {
          const $attrs = ($type)[2];
          return (c0Dict$for)(c0Dict$empty, $attrs, (($k, $a, $d) => {
            return (c0Dict$join)((c0Compiler$TypedAst$typeTyvars)($a), $d);
          }));
        }))()
        : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Just"))
          ? ((() => {
            const $id = (($type)[1])[1];
            const $attrs = ($type)[2];
            return ((($0) => {
              return (c0Dict$for)($0, $attrs, (($k, $a, $d) => {
                return (c0Dict$join)((c0Compiler$TypedAst$typeTyvars)($a), $d);
              }));
            }))((c0Dict$ofOne)($id, null));
          }))()
          : ((($type)[0] === "$TypeError")
            ? c0Dict$empty
            : ((($type)[0] === "$TypeFn")
              ? ((() => {
                const $ins = ($type)[1];
                const $out = ($type)[2];
                return ((($0) => {
                  return (c0List$for)($0, $ins, (($in, $a) => {
                    return (c0Dict$join)((c0Compiler$TypedAst$typeTyvars)((c0Compiler$TypedAst$toRaw)($in)), $a);
                  }));
                }))((c0Compiler$TypedAst$typeTyvars)($out.raw));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 329:4', (sp_toHuman)($type))))))));
});

const c0Dict$moveRedLeft = (($dict) => {
  return (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && (((($dict)[5])[0] === "$RBNode_elm_builtin") && ((((($dict)[5])[4])[0] === "$RBNode_elm_builtin") && ((((($dict)[5])[4])[1])[0] === "$Red")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $lLeft = (($dict)[4])[4];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rlK = ((($dict)[5])[4])[2];
      const $rlV = ((($dict)[5])[4])[3];
      const $rlL = ((($dict)[5])[4])[4];
      const $rlR = ((($dict)[5])[4])[5];
      const $rRight = (($dict)[5])[5];
      return (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $rlK, $rlV, (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, $lLeft, $lRight), $rlL), (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $rK, $rV, $rlR, $rRight));
    }))()
    : (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && ((($dict)[5])[0] === "$RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "$Black")
          ? (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, $lLeft, $lRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "$Red")
            ? (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, $lLeft, $lRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 212:12', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 206:4', (sp_toHuman)($dict)))));
});

const c0Dict$getMin = (($dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $left = ($dict)[4];
      return ((($left)[0] === "$RBNode_elm_builtin")
        ? (c0Dict$getMin)($left)
        : (true
          ? $dict
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 165:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? $dict
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 162:4', (sp_toHuman)($dict))));
});

const c0Dict$removeMin = (($dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((($left)[0] === "$RBNode_elm_builtin")
        ? ((() => {
          const $lColor = ($left)[1];
          const $lLeft = ($left)[4];
          return ((($lColor)[0] === "$Black")
            ? (((($lLeft)[0] === "$RBNode_elm_builtin") && ((($lLeft)[1])[0] === "$Red"))
              ? (c0Dict$RBNode_elm_builtin)($color, $key, $value, (c0Dict$removeMin)($left), $right)
              : (true
                ? ((() => {
                  const $2 = (c0Dict$moveRedLeft)($dict);
                  return ((($2)[0] === "$RBNode_elm_builtin")
                    ? ((() => {
                      const $nColor = ($2)[1];
                      const $nKey = ($2)[2];
                      const $nValue = ($2)[3];
                      const $nLeft = ($2)[4];
                      const $nRight = ($2)[5];
                      return (c0Dict$balance)($nColor, $nKey, $nValue, (c0Dict$removeMin)($nLeft), $nRight);
                    }))()
                    : ((($2)[0] === "$RBEmpty_elm_builtin")
                      ? c0Dict$RBEmpty_elm_builtin
                      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 190:36', (sp_toHuman)($2))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 184:28', (sp_toHuman)($lLeft))))
            : (true
              ? (c0Dict$RBNode_elm_builtin)($color, $key, $value, (c0Dict$removeMin)($left), $right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 181:20', (sp_toHuman)($lColor))));
        }))()
        : (true
          ? c0Dict$RBEmpty_elm_builtin
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 178:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? c0Dict$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 175:4', (sp_toHuman)($dict))));
});

const c0Dict$removeHelpEQGT = (($targetKey, $dict) => {
  return ((($dict)[0] === "$RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((sp_equal)($targetKey, $key)
        ? ((() => {
          const $3 = (c0Dict$getMin)($right);
          return ((($3)[0] === "$RBNode_elm_builtin")
            ? ((() => {
              const $minKey = ($3)[2];
              const $minValue = ($3)[3];
              return (c0Dict$balance)($color, $minKey, $minValue, $left, (c0Dict$removeMin)($right));
            }))()
            : ((($3)[0] === "$RBEmpty_elm_builtin")
              ? c0Dict$RBEmpty_elm_builtin
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 150:16', (sp_toHuman)($3))));
        }))()
        : (c0Dict$balance)($color, $key, $value, $left, (c0Dict$removeHelp)($targetKey, $right)));
    }))()
    : ((($dict)[0] === "$RBEmpty_elm_builtin")
      ? c0Dict$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 146:4', (sp_toHuman)($dict))));
});

const c0Dict$moveRedRight = (($dict) => {
  return (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && ((((($dict)[4])[4])[0] === "$RBNode_elm_builtin") && (((((($dict)[4])[4])[1])[0] === "$Red") && ((($dict)[5])[0] === "$RBNode_elm_builtin")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $llK = ((($dict)[4])[4])[2];
      const $llV = ((($dict)[4])[4])[3];
      const $llLeft = ((($dict)[4])[4])[4];
      const $llRight = ((($dict)[4])[4])[5];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rLeft = (($dict)[5])[4];
      const $rRight = (($dict)[5])[5];
      return (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $llK, $llV, $llLeft, $llRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, $lRight, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $rK, $rV, $rLeft, $rRight)));
    }))()
    : (((($dict)[0] === "$RBNode_elm_builtin") && (((($dict)[4])[0] === "$RBNode_elm_builtin") && ((($dict)[5])[0] === "$RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "$Black")
          ? (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, $lLeft, $lRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "$Red")
            ? (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $lK, $lV, $lLeft, $lRight), (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 228:12', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 222:4', (sp_toHuman)($dict)))));
});

const c0Dict$removeHelpPrepEQGT = (($targetKey, $dict, $color, $key, $value, $left, $right) => {
  return (((($left)[0] === "$RBNode_elm_builtin") && ((($left)[1])[0] === "$Red"))
    ? ((() => {
      const $lK = ($left)[2];
      const $lV = ($left)[3];
      const $lLeft = ($left)[4];
      const $lRight = ($left)[5];
      return (c0Dict$RBNode_elm_builtin)($color, $lK, $lV, $lLeft, (c0Dict$RBNode_elm_builtin)(c0Dict$Red, $key, $value, $lRight, $right));
    }))()
    : (true
      ? (((($right)[0] === "$RBNode_elm_builtin") && (((($right)[1])[0] === "$Black") && (((($right)[4])[0] === "$RBNode_elm_builtin") && (((($right)[4])[1])[0] === "$Black"))))
        ? (c0Dict$moveRedRight)($dict)
        : (((($right)[0] === "$RBNode_elm_builtin") && (((($right)[1])[0] === "$Black") && ((($right)[4])[0] === "$RBEmpty_elm_builtin")))
          ? (c0Dict$moveRedRight)($dict)
          : (true
            ? $dict
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 138:12', (sp_toHuman)($right)))))
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 132:4', (sp_toHuman)($left))));
});

const c0Dict$removeHelp = (($targetKey, $dict) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? c0Dict$RBEmpty_elm_builtin
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ((sp_equal)((basics_compare)($targetKey, $key), (0 - 1))
          ? (((($left)[0] === "$RBNode_elm_builtin") && ((($left)[1])[0] === "$Black"))
            ? ((() => {
              const $lLeft = ($left)[4];
              return (((($lLeft)[0] === "$RBNode_elm_builtin") && ((($lLeft)[1])[0] === "$Red"))
                ? (c0Dict$RBNode_elm_builtin)($color, $key, $value, (c0Dict$removeHelp)($targetKey, $left), $right)
                : (true
                  ? ((() => {
                    const $3 = (c0Dict$moveRedLeft)($dict);
                    return ((($3)[0] === "$RBNode_elm_builtin")
                      ? ((() => {
                        const $nColor = ($3)[1];
                        const $nKey = ($3)[2];
                        const $nValue = ($3)[3];
                        const $nLeft = ($3)[4];
                        const $nRight = ($3)[5];
                        return (c0Dict$balance)($nColor, $nKey, $nValue, (c0Dict$removeHelp)($targetKey, $nLeft), $nRight);
                      }))()
                      : ((($3)[0] === "$RBEmpty_elm_builtin")
                        ? c0Dict$RBEmpty_elm_builtin
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 120:32', (sp_toHuman)($3))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 114:24', (sp_toHuman)($lLeft))));
            }))()
            : (true
              ? (c0Dict$RBNode_elm_builtin)($color, $key, $value, (c0Dict$removeHelp)($targetKey, $left), $right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 111:16', (sp_toHuman)($left))))
          : (c0Dict$removeHelpEQGT)($targetKey, (c0Dict$removeHelpPrepEQGT)($targetKey, $dict, $color, $key, $value, $left, $right)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 104:4', (sp_toHuman)($dict))));
});

const c0Dict$remove = (($key, $dict) => {
  const $3 = (c0Dict$removeHelp)($key, $dict);
  return (((($3)[0] === "$RBNode_elm_builtin") && ((($3)[1])[0] === "$Red"))
    ? ((() => {
      const $k = ($3)[2];
      const $v = ($3)[3];
      const $l = ($3)[4];
      const $r = ($3)[5];
      return (c0Dict$RBNode_elm_builtin)(c0Dict$Black, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $3;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 97:4', (sp_toHuman)($3))));
});

const c0Dict$diff = (($t1, $t2) => {
  return (c0Dict$for)($t1, $t2, (($k, $v, $t) => {
    return (c0Dict$remove)($k, $t);
  }));
});

const c0Dict$each = (($dict, $func) => {
  return ((($dict)[0] === "$RBEmpty_elm_builtin")
    ? null
    : ((($dict)[0] === "$RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        ($func)($key, $value);
        (c0Dict$each)($left, $func);
        return (c0Dict$each)($right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 346:4', (sp_toHuman)($dict))));
});

const c0Dict$filter = (($isGood, $dict) => {
  return (c0Dict$for)(c0Dict$empty, $dict, (($k, $v, $d) => {
    return (($isGood)($k, $v)
      ? (c0Dict$insert)($k, $v, $d)
      : $d);
  }));
});

const c0Dict$fromList = (($0) => {
  return (c0List$for)(c0Dict$empty, $0, (($keyAndValue, $dict) => {
    return (c0Dict$insert)($keyAndValue.first, $keyAndValue.second, $dict);
  }));
});

const c0Dict$member = (($key, $dict) => {
  const $3 = (c0Dict$get)($key, $dict);
  return ((($3)[0] === "$Just")
    ? true
    : ((($3)[0] === "$Nothing")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 33:4', (sp_toHuman)($3))));
});

const c0Dict$intersect = (($t1, $t2) => {
  return (c0Dict$filter)((($k, _1) => {
    return (c0Dict$member)($k, $t2);
  }), $t1);
});

const c0Dict$keys = (($0) => {
  return (c0Dict$forReversed)(c0Core$Nil, $0, (($key, $value, $keyList) => {
    return (c0Core$Cons)($key, $keyList);
  }));
});

const c0Dict$toList = ((() => {
  const $f = (($key, $value, $list) => {
    return (c0Core$Cons)(({
      first: $key,
      second: $value,
    }), $list);
  });
  return (($0) => {
    return (c0Dict$forReversed)(c0Core$Nil, $0, $f);
  });
}))();

const c0Dict$merge = (($leftStep, $bothStep, $rightStep, $leftDict, $rightDict, $initialResult) => {
  const $stepState = (($rKey, $rValue, $q) => {
    const $10 = $q;
    const $res = $10.second;
    const $list = $10.first;
    return ((($list)[0] === "$Nil")
      ? ({
        first: $list,
        second: ($rightStep)($rKey, $rValue, $res),
      })
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $lKey = ($list)[1].first;
          const $lValue = ($list)[1].second;
          const $rest = ($list)[2];
          const $11 = (basics_compare)($lKey, $rKey);
          return ((1 === $11)
            ? ({
              first: $list,
              second: ($rightStep)($rKey, $rValue, $res),
            })
            : ((0 === $11)
              ? ({
                first: $rest,
                second: ($bothStep)($lKey, $lValue, $rValue, $res),
              })
              : (true
                ? ($stepState)($rKey, $rValue, ({
                  first: $rest,
                  second: ($leftStep)($lKey, $lValue, $res),
                }))
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 278:16', (sp_toHuman)($11)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 272:8', (sp_toHuman)($list))));
  });
  const $7 = (c0Dict$for)(({
    first: (c0Dict$toList)($leftDict),
    second: $initialResult,
  }), $rightDict, $stepState);
  const $intermediateResult = $7.second;
  const $leftovers = $7.first;
  const $liftLeftStep = (($t, $res) => {
    const $10 = $t;
    const $v = $10.second;
    const $k = $10.first;
    return ($leftStep)($k, $v, $res);
  });
  return (c0List$for)($intermediateResult, $leftovers, $liftLeftStep);
});

const c0Dict$onlyBothOnly = (($da, $db) => {
  const $onAOnly = (($key, $a, $3) => {
    const $aOnly = $3.first;
    const $both = $3.second;
    const $bOnly = $3.third;
    return ({
      first: (c0Dict$insert)($key, $a, $aOnly),
      second: $both,
      third: $bOnly,
    });
  });
  const $onBOnly = (($key, $b, $3) => {
    const $aOnly = $3.first;
    const $both = $3.second;
    const $bOnly = $3.third;
    return ({
      first: $aOnly,
      second: $both,
      third: (c0Dict$insert)($key, $b, $bOnly),
    });
  });
  const $onBoth = (($key, $a, $b, $3) => {
    const $aOnly = $3.first;
    const $both = $3.second;
    const $bOnly = $3.third;
    return ({
      first: $aOnly,
      second: (c0Dict$insert)($key, ({
        first: $a,
        second: $b,
      }), $both),
      third: $bOnly,
    });
  });
  return (c0Dict$merge)($onAOnly, $onBoth, $onBOnly, $da, $db, ({
    first: c0Dict$empty,
    second: c0Dict$empty,
    third: c0Dict$empty,
  }));
});

const c0Dict$size = ((() => {
  const $sizeHelp = (($n, $dict) => {
    return ((($dict)[0] === "$RBEmpty_elm_builtin")
      ? $n
      : ((($dict)[0] === "$RBNode_elm_builtin")
        ? ((() => {
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          return ($sizeHelp)(($sizeHelp)(($n + 1), $right), $left);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 41:8', (sp_toHuman)($dict))));
  });
  return (($0) => {
    return ($sizeHelp)(0, $0);
  });
}))();

const c0Dict$update = (($targetKey, $alter, $dictionary) => {
  const $4 = ($alter)((c0Dict$get)($targetKey, $dictionary));
  return ((($4)[0] === "$Just")
    ? ((() => {
      const $value = ($4)[1];
      return (c0Dict$insert)($targetKey, $value, $dictionary);
    }))()
    : ((($4)[0] === "$Nothing")
      ? (c0Dict$remove)($targetKey, $dictionary)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 238:4', (sp_toHuman)($4))));
});

const c0Dict_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const c0Dict_Test$insertAndGet = (i1Test$Group)("insertAndGet", (c0Core$Cons)((c0Dict_Test$valueTest)("get, success", ((_0) => {
  return ((($0) => {
    return (c0Dict$get)((c0Maybe$Just)("a"), $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("b"), 2, $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("a"), 1, $0);
  }))(c0Dict$empty)));
}), (i1Test$isOkAndEqualTo)((c0Maybe$Just)(1))), (c0Core$Cons)((c0Dict_Test$valueTest)("get, fail", ((_0) => {
  return ((($0) => {
    return (c0Dict$get)((c0Maybe$Just)("c"), $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("b"), 2, $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("a"), 1, $0);
  }))(c0Dict$empty)));
}), (i1Test$isOkAndEqualTo)(c0Maybe$Nothing)), c0Core$Nil)));

const c0Dict_Test$lists = (i1Test$Group)("lists", (c0Core$Cons)((c0Dict_Test$valueTest)("keys", ((_0) => {
  return ((($0) => {
    return (list_sortBy)(c0Basics$identity, $0);
  }))((c0Dict$keys)(((($0) => {
    return (c0Dict$insert)(c0Maybe$Nothing, 2, $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("b"), 2, $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("a"), 1, $0);
  }))(c0Dict$empty)))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Maybe$Just)("a"), (c0Core$Cons)((c0Maybe$Just)("b"), (c0Core$Cons)(c0Maybe$Nothing, c0Core$Nil))))), (c0Core$Cons)((c0Dict_Test$valueTest)("values", ((_0) => {
  return ((($0) => {
    return (list_sortBy)(c0Basics$identity, $0);
  }))((c0Dict$values)(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("b"), ({
      a: 3,
    }), $0);
  }))(((($0) => {
    return (c0Dict$insert)((c0Maybe$Just)("a"), ({
      a: 1,
    }), $0);
  }))(c0Dict$empty))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)(({
  a: 1,
}), (c0Core$Cons)(({
  a: 3,
}), c0Core$Nil)))), c0Core$Nil)));

const c0Dict_Test$tests = (i1Test$Group)("Dict", (c0Core$Cons)(c0Dict_Test$insertAndGet, (c0Core$Cons)(c0Dict_Test$lists, c0Core$Nil)));

const c0Hash$for_ = (($a, $h, $f) => {
  return ([
    ((__re__ = (hash_for)($h, $f, $a)), ($h = (__re__)[1]), (__re__)[0]),
    $h,
  ]);
});

const c0Hash$toList = (($h) => {
  return ([
    ((__re__ = (hash_for)($h, (($k, $v, $l) => {
      return (c0Core$Cons)(({
        first: $k,
        second: $v,
      }), $l);
    }), c0Core$Nil)), ($h = (__re__)[1]), (__re__)[0]),
    $h,
  ]);
});

const c0Hash_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const c0List$each = (($ls, $f) => {
  return ((($ls)[0] === "$Nil")
    ? null
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $tail = ($ls)[2];
        ($f)($h);
        return (c0List$each)($tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 372:4', (sp_toHuman)($ls))));
});

const c0List$range = (($low, $high) => {
  const $rec = (($accum, $up) => {
    return (($up > $low)
      ? ($rec)((sp_cons)($up, $accum), ($up - 1))
      : ((sp_equal)($up, $low)
        ? (sp_cons)($up, $accum)
        : $accum));
  });
  return ($rec)(c0Core$Nil, $high);
});

const c0Tuple$first = (($t) => {
  return $t.first;
});

const c0Hash_Test$tests = (i1Test$Group)("Hash", (c0Core$Cons)((c0Hash_Test$valueTest)("insert", ((_0) => {
  let $h = (hash_fromList)((c0Core$Cons)(({
    first: 1,
    second: 2,
  }), c0Core$Nil));
  ((__re__ = (hash_insert)($h, 2, 3)), ($h = (__re__)[1]), (__re__)[0]);
  return $h;
}), (i1Test$isOkAndEqualTo)((hash_fromList)((c0Core$Cons)(({
  first: 1,
  second: 2,
}), (c0Core$Cons)(({
  first: 2,
  second: 3,
}), c0Core$Nil))))), (c0Core$Cons)((c0Hash_Test$valueTest)("remove", ((_0) => {
  let $h = (hash_fromList)((c0Core$Cons)(({
    first: 1,
    second: 2,
  }), (c0Core$Cons)(({
    first: 3,
    second: 4,
  }), c0Core$Nil)));
  ((__re__ = (hash_remove)($h, 1)), ($h = (__re__)[1]), (__re__)[0]);
  return $h;
}), (i1Test$isOkAndEqualTo)((hash_fromList)((c0Core$Cons)(({
  first: 3,
  second: 4,
}), c0Core$Nil)))), (c0Core$Cons)((c0Hash_Test$valueTest)("get Just", ((_0) => {
  let $h = (hash_fromList)((c0Core$Cons)(({
    first: 1,
    second: 2,
  }), (c0Core$Cons)(({
    first: 3,
    second: 4,
  }), c0Core$Nil)));
  return ((__re__ = (hash_get)($h, 1)), ($h = (__re__)[1]), (__re__)[0]);
}), (i1Test$isOkAndEqualTo)((c0Maybe$Just)(2))), (c0Core$Cons)((c0Hash_Test$valueTest)("get Nothing", ((_0) => {
  let $h = (hash_fromList)((c0Core$Cons)(({
    first: 1,
    second: 2,
  }), (c0Core$Cons)(({
    first: 3,
    second: 4,
  }), c0Core$Nil)));
  return ((__re__ = (hash_get)($h, 66)), ($h = (__re__)[1]), (__re__)[0]);
}), (i1Test$isOkAndEqualTo)(c0Maybe$Nothing)), (c0Core$Cons)((c0Hash_Test$valueTest)("for", ((_0) => {
  let $hash = (hash_fromList)((c0Core$Cons)(({
    first: (c0Maybe$Just)(true),
    second: 2,
  }), (c0Core$Cons)(({
    first: c0Maybe$Nothing,
    second: 4,
  }), c0Core$Nil)));
  return ((($0) => {
    return (list_sortBy)(c0Tuple$first, $0);
  }))(((($0) => {
    return ((__re__ = (hash_for)($hash, (($k, $v, $a) => {
      return (c0Core$Cons)(({
        first: $v,
        second: $k,
      }), $a);
    }), $0)), ($hash = (__re__)[1]), (__re__)[0]);
  }))(c0Core$Nil));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)(({
  first: 2,
  second: (c0Maybe$Just)(true),
}), (c0Core$Cons)(({
  first: 4,
  second: c0Maybe$Nothing,
}), c0Core$Nil)))), (c0Core$Cons)((c0Hash_Test$valueTest)("each", ((_0) => {
  let $a = (array_fromList)(c0Core$Nil);
  let $hash = (hash_fromList)((c0Core$Cons)(({
    first: (c0Maybe$Just)(true),
    second: 2,
  }), (c0Core$Cons)(({
    first: c0Maybe$Nothing,
    second: 1,
  }), c0Core$Nil)));
  ((__re__ = (hash_each)($hash, (($k, $v) => {
    return (c0List$each)((c0List$range)(1, $v), ((_0) => {
      return ((__re__ = (array_push)($a, $k)), ($a = (__re__)[1]), (__re__)[0]);
    }));
  }))), ($hash = (__re__)[1]), (__re__)[0]);
  ((__re__ = (array_sortBy)($a, c0Basics$identity)), ($a = (__re__)[1]), (__re__)[0]);
  return $a;
}), (i1Test$isOkAndEqualTo)((array_fromList)((c0Core$Cons)((c0Maybe$Just)(true), (c0Core$Cons)((c0Maybe$Just)(true), (c0Core$Cons)(c0Maybe$Nothing, c0Core$Nil)))))), (c0Core$Cons)((c0Hash_Test$valueTest)("pop (empty)", ((_0) => {
  let $h = (hash_fromList)(c0Core$Nil);
  const $r = ((__re__ = (hash_pop)($h)), ($h = (__re__)[1]), (__re__)[0]);
  return ({
    first: $r,
    second: $h,
  });
}), (i1Test$isOkAndEqualTo)(({
  first: c0Maybe$Nothing,
  second: (hash_fromList)(c0Core$Nil),
}))), (c0Core$Cons)((c0Hash_Test$valueTest)("pop (one element)", ((_0) => {
  let $h = (hash_fromList)((c0Core$Cons)(({
    first: ({
      b: c0Maybe$Nothing,
    }),
    second: 2,
  }), c0Core$Nil));
  const $r = ((__re__ = (hash_pop)($h)), ($h = (__re__)[1]), (__re__)[0]);
  return ({
    first: $r,
    second: $h,
  });
}), (i1Test$isOkAndEqualTo)(({
  first: (c0Maybe$Just)(({
    first: ({
      b: c0Maybe$Nothing,
    }),
    second: 2,
  })),
  second: (hash_fromList)(c0Core$Nil),
}))), (c0Core$Cons)((c0Hash_Test$valueTest)("pop (several element)", ((_0) => {
  let $h = (hash_fromList)((c0Core$Cons)(({
    first: ({
      b: c0Maybe$Nothing,
    }),
    second: 2,
  }), (c0Core$Cons)(({
    first: ({
      b: (c0Maybe$Just)(4),
    }),
    second: 8,
  }), c0Core$Nil)));
  const $r = ((__re__ = (hash_pop)($h)), ($h = (__re__)[1]), (__re__)[0]);
  return ({
    first: $r,
    second: $h,
  });
}), (i1Test$isOkAndEqualTo)(({
  first: (c0Maybe$Just)(({
    first: ({
      b: c0Maybe$Nothing,
    }),
    second: 2,
  })),
  second: (hash_fromList)((c0Core$Cons)(({
    first: ({
      b: (c0Maybe$Just)(4),
    }),
    second: 8,
  }), c0Core$Nil)),
}))), c0Core$Nil))))))))));

const c0List$append = (($xs, $ys) => {
  return ((($ys)[0] === "$Nil")
    ? $xs
    : (true
      ? (c0List$forReversed)($ys, $xs, c0Core$Cons)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 228:4', (sp_toHuman)($ys))));
});

const c0List$concat = (($lists) => {
  return (c0List$forReversed)(c0Core$Nil, $lists, c0List$append);
});

const c0List$concatMap = (($f, $list) => {
  return (c0List$concat)((c0List$map)($f, $list));
});

const c0List$drop = (($n, $ls) => {
  return ((sp_equal)($n, 0)
    ? $ls
    : ((($ls)[0] === "$Nil")
      ? c0Core$Nil
      : ((($ls)[0] === "$Cons")
        ? ((() => {
          const $h = ($ls)[1];
          const $tail = ($ls)[2];
          return (c0List$drop)(($n - 1), $tail);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 418:8', (sp_toHuman)($ls)))));
});

const c0List$filter = (($f, $ls) => {
  return (c0List$forReversed)(c0Core$Nil, $ls, (($item, $acc) => {
    return (($f)($item)
      ? (sp_cons)($item, $acc)
      : $acc);
  }));
});

const c0List$find = (($test, $list) => {
  return ((($list)[0] === "$Nil")
    ? c0Maybe$Nothing
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($test)($h)
          ? (c0Maybe$Just)($h)
          : (c0List$find)($test, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 24:4', (sp_toHuman)($list))));
});

const c0List$forRes = (($accum, $ls, $f) => {
  return ((($ls)[0] === "$Nil")
    ? (c0Result$Ok)($accum)
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $t = ($ls)[2];
        const $4 = ($f)($h, $accum);
        return ((($4)[0] === "$Err")
          ? ((() => {
            const $x = ($4)[1];
            return (c0Result$Err)($x);
          }))()
          : ((($4)[0] === "$Ok")
            ? ((() => {
              const $newAccum = ($4)[1];
              return (c0List$forRes)($newAccum, $t, $f);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 185:12', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 179:4', (sp_toHuman)($ls))));
});

const c0List$head = (($list) => {
  return ((($list)[0] === "$Nil")
    ? c0Maybe$Nothing
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (c0Maybe$Just)($h);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 255:4', (sp_toHuman)($list))));
});

const c0List$indexBy = (($getIndex, $list) => {
  return (c0List$for)(c0Dict$empty, $list, (($i, $a) => {
    return (c0Dict$insert)(($getIndex)($i), $i, $a);
  }));
});

const c0List$indexedEach2 = ((() => {
  const $rec = (($index, $aa, $bb, $f) => {
    const $5 = ({
      first: $aa,
      second: $bb,
    });
    return (((($5.first)[0] === "$Cons") && (($5.second)[0] === "$Cons"))
      ? ((() => {
        const $a = ($5.first)[1];
        const $at = ($5.first)[2];
        const $b = ($5.second)[1];
        const $bt = ($5.second)[2];
        ($f)($index, $a, $b);
        return ($rec)(($index + 1), $at, $bt, $f);
      }))()
      : (true
        ? null
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 386:8', (sp_toHuman)($5))));
  });
  return (($0, $1, $2) => {
    return ($rec)(0, $0, $1, $2);
  });
}))();

const c0List$indexedFor = (($init, $aList, $function) => {
  return (c0Tuple$second)((c0List$for)(({
    first: 0,
    second: $init,
  }), $aList, (($item, $4) => {
    const $index = $4.first;
    const $accum = $4.second;
    return ({
      first: ($index + 1),
      second: ($function)($index, $item, $accum),
    });
  })));
});

const c0List$indexedMap = (($f, $aa) => {
  const $rec = (($accum, $n, $list) => {
    return ((($list)[0] === "$Nil")
      ? (c0List$reverse)($accum)
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return ($rec)((sp_cons)(($f)($n, $h), $accum), ($n + 1), $t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 208:8', (sp_toHuman)($list))));
  });
  return ($rec)(c0Core$Nil, 0, $aa);
});

const c0List$intersperse = ((() => {
  const $rec = (($separator, $items, $acc) => {
    return ((($items)[0] === "$Nil")
      ? (c0List$reverse)($acc)
      : (((($items)[0] === "$Cons") && ((($items)[2])[0] === "$Nil"))
        ? ((() => {
          const $last_ = ($items)[1];
          return (c0List$reverse)((sp_cons)($last_, $acc));
        }))()
        : ((($items)[0] === "$Cons")
          ? ((() => {
            const $h = ($items)[1];
            const $tail = ($items)[2];
            return ($rec)($separator, $tail, (sp_cons)($separator, (sp_cons)($h, $acc)));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 460:8', (sp_toHuman)($items)))));
  });
  return (($0, $1) => {
    return ($rec)($0, $1, c0Core$Nil);
  });
}))();

const c0List$last = (($list) => {
  return ((($list)[0] === "$Nil")
    ? c0Maybe$Nothing
    : (((($list)[0] === "$Cons") && ((($list)[2])[0] === "$Nil"))
      ? ((() => {
        const $h = ($list)[1];
        return (c0Maybe$Just)($h);
      }))()
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return (c0List$last)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 262:4', (sp_toHuman)($list)))));
});

const c0List$length = (($list) => {
  return (c0List$for)(0, $list, ((_0, $a) => {
    return ($a + 1);
  }));
});

const c0List$map2 = (($f, $aa, $bb) => {
  const $rec = (($accum, $ax, $bx) => {
    const $7 = ({
      first: $ax,
      second: $bx,
    });
    return (((($7.first)[0] === "$Cons") && (($7.second)[0] === "$Cons"))
      ? ((() => {
        const $ahead = ($7.first)[1];
        const $atail = ($7.first)[2];
        const $bhead = ($7.second)[1];
        const $btail = ($7.second)[2];
        return ($rec)((c0Core$Cons)(($f)($ahead, $bhead), $accum), $atail, $btail);
      }))()
      : (true
        ? (c0List$reverse)($accum)
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 162:8', (sp_toHuman)($7))));
  });
  return ($rec)(c0Core$Nil, $aa, $bb);
});

const c0Result$map = (($f, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0Result$Err)($e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $a = ($result)[1];
        return (c0Result$Ok)(($f)($a));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 8:4', (sp_toHuman)($result))));
});

const c0List$mapRes = (($f, $list) => {
  const $fun = (($a, $acc) => {
    return (c0Result$map)((($b) => {
      return (c0Core$Cons)($b, $acc);
    }), ($f)($a));
  });
  return ((($0) => {
    return (c0Result$map)(c0List$reverse, $0);
  }))((c0List$forRes)(c0Core$Nil, $list, $fun));
});

const c0List$member = (($a, $list) => {
  return ((($list)[0] === "$Nil")
    ? false
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ((sp_equal)($a, $h)
          ? true
          : (c0List$member)($a, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 52:4', (sp_toHuman)($list))));
});

const c0List$minimum = (($list) => {
  return ((($list)[0] === "$Cons")
    ? ((() => {
      const $x = ($list)[1];
      const $xs = ($list)[2];
      return (c0Maybe$Just)((c0List$for)($x, $xs, c0Basics$min));
    }))()
    : (true
      ? c0Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 425:4', (sp_toHuman)($list))));
});

const c0List$partition = (($f, $ls) => {
  return ((($0) => {
    return (c0List$forReversed)($0, $ls, (($item, $4) => {
      const $true = $4.first;
      const $false = $4.second;
      return (($f)($item)
        ? ({
          first: (sp_cons)($item, $true),
          second: $false,
        })
        : ({
          first: $true,
          second: (sp_cons)($item, $false),
        }));
    }));
  }))(({
    first: c0Core$Nil,
    second: c0Core$Nil,
  }));
});

const c0List$partitionWhile = (($f, $xs) => {
  const $rec = (($acc, $rest) => {
    return ((($rest)[0] === "$Nil")
      ? ({
        first: $xs,
        second: c0Core$Nil,
      })
      : ((($rest)[0] === "$Cons")
        ? ((() => {
          const $h = ($rest)[1];
          const $tail = ($rest)[2];
          return (($f)($h)
            ? ($rec)((sp_cons)($h, $acc), $tail)
            : ({
              first: (c0List$reverse)($acc),
              second: $rest,
            }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 472:8', (sp_toHuman)($rest))));
  });
  return ($rec)(c0Core$Nil, $xs);
});

const c0List$repeat = (($n, $a) => {
  const $rec = (($c, $acc) => {
    return (($c > 0)
      ? ($rec)(($c - 1), (sp_cons)($a, $acc))
      : $acc);
  });
  return ($rec)($n, c0Core$Nil);
});

const c0List$takeReverse = (($n, $list, $kept) => {
  return (($n < 1)
    ? $kept
    : ((($list)[0] === "$Nil")
      ? $kept
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $x = ($list)[1];
          const $xs = ($list)[2];
          return (c0List$takeReverse)(($n - 1), $xs, (c0Core$Cons)($x, $kept));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 315:8', (sp_toHuman)($list)))));
});

const c0List$takeTailRec = (($n, $list) => {
  return (c0List$reverse)((c0List$takeReverse)($n, $list, c0Core$Nil));
});

const c0List$takeFast = (($ctr, $n, $list) => {
  return (($n < 1)
    ? c0Core$Nil
    : ((() => {
      const $4 = ({
        first: $n,
        second: $list,
      });
      return ((($4.second)[0] === "$Nil")
        ? $list
        : (((1 === $4.first) && (($4.second)[0] === "$Cons"))
          ? ((() => {
            const $x = ($4.second)[1];
            return (c0Core$Cons)($x, c0Core$Nil);
          }))()
          : (((2 === $4.first) && ((($4.second)[0] === "$Cons") && ((($4.second)[2])[0] === "$Cons")))
            ? ((() => {
              const $x = ($4.second)[1];
              const $y = (($4.second)[2])[1];
              return (c0Core$Cons)($x, (c0Core$Cons)($y, c0Core$Nil));
            }))()
            : (((3 === $4.first) && ((($4.second)[0] === "$Cons") && (((($4.second)[2])[0] === "$Cons") && (((($4.second)[2])[2])[0] === "$Cons"))))
              ? ((() => {
                const $x = ($4.second)[1];
                const $y = (($4.second)[2])[1];
                const $z = ((($4.second)[2])[2])[1];
                return (c0Core$Cons)($x, (c0Core$Cons)($y, (c0Core$Cons)($z, c0Core$Nil)));
              }))()
              : (((($4.second)[0] === "$Cons") && (((($4.second)[2])[0] === "$Cons") && ((((($4.second)[2])[2])[0] === "$Cons") && ((((($4.second)[2])[2])[2])[0] === "$Cons"))))
                ? ((() => {
                  const $x = ($4.second)[1];
                  const $y = (($4.second)[2])[1];
                  const $z = ((($4.second)[2])[2])[1];
                  const $w = (((($4.second)[2])[2])[2])[1];
                  const $tl = (((($4.second)[2])[2])[2])[2];
                  const $cons = c0Core$Cons;
                  return (($ctr > 1000)
                    ? ($cons)($x, ($cons)($y, ($cons)($z, ($cons)($w, (c0List$takeTailRec)(($n - 4), $tl)))))
                    : ($cons)($x, ($cons)($y, ($cons)($z, ($cons)($w, (c0List$takeFast)(($ctr + 1), ($n - 4), $tl))))));
                }))()
                : (true
                  ? $list
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 278:8', (sp_toHuman)($4))))))));
    }))());
});

const c0List$take = (($0, $1) => {
  return (c0List$takeFast)(0, $0, $1);
});

const c0List$takeWhile = (($test, $its) => {
  const $rec = (($accum, $list) => {
    return ((($list)[0] === "$Nil")
      ? (c0List$reverse)($accum)
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $tail = ($list)[2];
          return (($test)($h)
            ? ($rec)((sp_cons)($h, $accum), $tail)
            : (c0List$reverse)($accum));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 324:8', (sp_toHuman)($list))));
  });
  return ($rec)(c0Core$Nil, $its);
});

const c0List_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const c0List_Test$concat = (i1Test$Group)("concat", (c0Core$Cons)((c0List_Test$valueTest)("concats two lists", ((_0) => {
  return (c0List$concat)((c0Core$Cons)((c0Core$Cons)(1, (c0Core$Cons)(2, c0Core$Nil)), (c0Core$Cons)((c0Core$Cons)(3, (c0Core$Cons)(4, c0Core$Nil)), c0Core$Nil)));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)(1, (c0Core$Cons)(2, (c0Core$Cons)(3, (c0Core$Cons)(4, c0Core$Nil)))))), c0Core$Nil));

const c0List_Test$sortBy = (i1Test$Group)("sortBy", (c0Core$Cons)((c0List_Test$valueTest)("Can actually sort stuff", ((_0) => {
  return ((($0) => {
    return (list_sortBy)(c0Basics$identity, $0);
  }))((c0Core$Cons)((c0Maybe$Just)(23), (c0Core$Cons)(c0Maybe$Nothing, (c0Core$Cons)((c0Maybe$Just)(11), c0Core$Nil))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Maybe$Just)(11), (c0Core$Cons)((c0Maybe$Just)(23), (c0Core$Cons)(c0Maybe$Nothing, c0Core$Nil))))), (c0Core$Cons)((c0List_Test$valueTest)("Correctly orders tuple-2", ((_0) => {
  return ((($0) => {
    return (list_sortBy)(c0Basics$identity, $0);
  }))((c0Core$Cons)(({
    first: 23,
    second: 1,
  }), (c0Core$Cons)(({
    first: 1,
    second: 2,
  }), (c0Core$Cons)(({
    first: 11,
    second: 3,
  }), c0Core$Nil))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)(({
  first: 1,
  second: 2,
}), (c0Core$Cons)(({
  first: 11,
  second: 3,
}), (c0Core$Cons)(({
  first: 23,
  second: 1,
}), c0Core$Nil))))), (c0Core$Cons)((c0List_Test$valueTest)("Correctly orders tuple-3", ((_0) => {
  return ((($0) => {
    return (list_sortBy)(c0Basics$identity, $0);
  }))((c0Core$Cons)(({
    first: "z",
    second: "a",
    third: "2",
  }), (c0Core$Cons)(({
    first: "a",
    second: "b",
    third: "33",
  }), (c0Core$Cons)(({
    first: "z",
    second: "a",
    third: "1",
  }), (c0Core$Cons)(({
    first: "z",
    second: "b",
    third: "3",
  }), c0Core$Nil)))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)(({
  first: "a",
  second: "b",
  third: "33",
}), (c0Core$Cons)(({
  first: "z",
  second: "a",
  third: "1",
}), (c0Core$Cons)(({
  first: "z",
  second: "a",
  third: "2",
}), (c0Core$Cons)(({
  first: "z",
  second: "b",
  third: "3",
}), c0Core$Nil)))))), c0Core$Nil))));

const c0List_Test$tests = (i1Test$Group)("List", (c0Core$Cons)(c0List_Test$sortBy, (c0Core$Cons)(c0List_Test$concat, c0Core$Nil)));

const c0Maybe$onJust = (($f) => {
  return (($ma) => {
    return ((($ma)[0] === "$Nothing")
      ? c0Maybe$Nothing
      : ((($ma)[0] === "$Just")
        ? ((() => {
          const $a = ($ma)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 9:4', (sp_toHuman)($ma))));
  });
});

const c0Maybe$toResult = (($e, $maybeA) => {
  return ((($maybeA)[0] === "$Just")
    ? ((() => {
      const $a = ($maybeA)[1];
      return (c0Result$Ok)($a);
    }))()
    : ((($maybeA)[0] === "$Nothing")
      ? (c0Result$Err)($e)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 36:4', (sp_toHuman)($maybeA))));
});

const c0Maybe$withDefault = (($default, $maybe) => {
  return ((($maybe)[0] === "$Just")
    ? ((() => {
      const $v = ($maybe)[1];
      return $v;
    }))()
    : ((($maybe)[0] === "$Nothing")
      ? $default
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 50:4', (sp_toHuman)($maybe))));
});

const c0Result$fromMaybe = (($err, $maybe) => {
  return ((($maybe)[0] === "$Nothing")
    ? (c0Result$Err)($err)
    : ((($maybe)[0] === "$Just")
      ? ((() => {
        const $a = ($maybe)[1];
        return (c0Result$Ok)($a);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 38:4', (sp_toHuman)($maybe))));
});

const c0Result$mapError = (($f, $result) => {
  return ((($result)[0] === "$Ok")
    ? ((() => {
      const $a = ($result)[1];
      return (c0Result$Ok)($a);
    }))()
    : ((($result)[0] === "$Err")
      ? ((() => {
        const $e1 = ($result)[1];
        return (c0Result$Err)(($f)($e1));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 31:4', (sp_toHuman)($result))));
});

const c0Set$empty = c0Dict$empty;

const c0Set$for = (($init, $set, $f) => {
  return (c0Dict$for)($init, $set, (($k, _1, $d) => {
    return ($f)($k, $d);
  }));
});

const c0Set$insert = (($0, $1) => {
  return (c0Dict$insert)($0, null, $1);
});

const c0Set$fromList = (($0) => {
  return (c0List$for)(c0Set$empty, $0, c0Set$insert);
});

const c0Set$member = c0Dict$member;

const c0Text$contains = (($sub, $str) => {
  const $3 = (text_split)($sub, $str);
  return (((($3)[0] === "$Cons") && ((($3)[2])[0] === "$Nil"))
    ? false
    : (true
      ? true
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 120:4', (sp_toHuman)($3))));
});

const c0Text$repeat = (($n, $s) => {
  return (c0Text$join)("", (c0List$repeat)($n, $s));
});

const c0Text$padLeft = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($textLength - $minLength), (text_length)($pad));
      return ((c0Text$repeat)($times, $pad) + $s);
    }))()
    : $s);
});

const c0Text$padRight = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($textLength - $minLength), (text_length)($pad));
      return ($s + (c0Text$repeat)($times, $pad));
    }))()
    : $s);
});

const c0Text$replace = (($toRemove, $toPut, $s) => {
  return ((($0) => {
    return (c0Text$join)($toPut, $0);
  }))(((($0) => {
    return (text_split)($toRemove, $0);
  }))($s));
});

const c0Text$trimRight = ((() => {
  const $re = (text_replaceRegex)("[ ]*$");
  return (($0) => {
    return ($re)("", $0);
  });
}))();

const c0Tuple$mapFirst = (($f, $t) => {
  return ({
    first: ($f)($t.first),
    second: $t.second,
  });
});

const c0Tuple$mapSecond = (($f, $t) => {
  return ({
    first: $t.first,
    second: ($f)($t.second),
  });
});

const c0Tuple$pair = (($a, $b) => {
  return ({
    first: $a,
    second: $b,
  });
});

const i2IO$reToStderr = (($io, $re) => {
  return ([
    ((($re)[0] === "$Ok")
      ? 0
      : ((($re)[0] === "$Err")
        ? ((() => {
          const $error = ($re)[1];
          ((__re__ = (io_writeStderr)($io, ($error + "\n"))), ($io = (__re__)[1]), (__re__)[0]);
          return 1;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/posix/IO.sp 19:4', (sp_toHuman)($re)))),
    $io,
  ]);
});

const i1Test$codeTest = (($toText, $title, $code, $functionToTest, $ce) => {
  const $6 = $ce;
  const $toMaybeError = ($6)[1];
  return (i1Test$Single)($title, $code, ((_0) => {
    return (i1Test$maybeToOutcome)(((($0) => {
      return ($toMaybeError)($toText, $0);
    }))(($functionToTest)($code)));
  }));
});

const i1Test$errorContains = (($snippets) => {
  return (i1Test$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "$Ok")
      ? ((() => {
        const $ok = ($result)[1];
        return (c0Maybe$Just)(("I was expecting an error, but got: Ok " + ($toText)($ok)));
      }))()
      : ((($result)[0] === "$Err")
        ? ((() => {
          const $e = ($result)[1];
          const $missing = ((($0) => {
            return (c0List$filter)((($sn) => {
              return (c0Basics$not)((c0Text$contains)($sn, $e));
            }), $0);
          }))($snippets);
          return ((sp_equal)($missing, c0Core$Nil)
            ? c0Maybe$Nothing
            : ((() => {
              const $indentedError = ((($0) => {
                return (c0Text$join)("\n", $0);
              }))(((($0) => {
                return (c0List$map)((($l) => {
                  return ("    " + $l);
                }), $0);
              }))(((($0) => {
                return (text_split)("\n", $0);
              }))($e)));
              return (c0Maybe$Just)(("Error message:\n\n" + ($indentedError + ("\n\nis missing snippets: " + (c0Text$join)(", ", $missing)))));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 96:8', (sp_toHuman)($result))));
  }));
});

const i1Test$getName = (($test) => {
  return ((($test)[0] === "$Single")
    ? ((() => {
      const $n = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return $n;
    }))()
    : ((($test)[0] === "$Group")
      ? ((() => {
        const $n = ($test)[1];
        const $ls = ($test)[2];
        return $n;
      }))()
      : ((($test)[0] === "$NotNow")
        ? ((() => {
          const $t = ($test)[1];
          return (i1Test$getName)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 145:4', (sp_toHuman)($test)))));
});

const i1Test$outcomesRec = (($path, $test, $accum) => {
  return ((($test)[0] === "$Single")
    ? ((() => {
      const $name = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return (sp_cons)(({
        code: $code,
        getOutcome: $f,
        name: ($path + $name),
      }), $accum);
    }))()
    : ((($test)[0] === "$NotNow")
      ? ((() => {
        const $t = ($test)[1];
        const $thing = ({
          code: "",
          getOutcome: ((_0) => {
            return i1Test$Skipped;
          }),
          name: ($path + (i1Test$getName)($t)),
        });
        return (sp_cons)($thing, $accum);
      }))()
      : ((($test)[0] === "$Group")
        ? ((() => {
          const $pathSegment = ($test)[1];
          const $ts = ($test)[2];
          return (c0List$for)($accum, $ts, (($0, $1) => {
            return (i1Test$outcomesRec)(($path + ($pathSegment + " / ")), $0, $1);
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 128:4', (sp_toHuman)($test)))));
});

const i1Test$flattenAndRun = (($tests) => {
  const $flattened = ((($0) => {
    return (c0List$map)((($r) => {
      return ((c0Text$contains)("SKIP", $r.name)
        ? ((() => {
          const $0 = $r;
          return (Object.assign)({}, $0, ({
            getOutcome: ((_0) => {
              return i1Test$Skipped;
            }),
          }));
        }))()
        : $r);
    }), $0);
  }))((i1Test$outcomesRec)("", (i1Test$Group)("", $tests), c0Core$Nil));
  const $onlies = ((($0) => {
    return (c0List$filter)((($r) => {
      return (c0Text$contains)("ONLY", $r.name);
    }), $0);
  }))($flattened);
  const $runnable = ((sp_not_equal)($onlies, c0Core$Nil)
    ? $onlies
    : $flattened);
  const $runTest = (($r) => {
    const $3 = $r;
    const $name = $3.name;
    const $getOutcome = $3.getOutcome;
    const $code = $3.code;
    return ({
      code: $code,
      name: $name,
      outcome: ($getOutcome)(null),
    });
  });
  return (c0List$map)($runTest, $runnable);
});

const i1Test$freeform = (($test) => {
  return (i1Test$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        return (c0Maybe$Just)($e);
      }))()
      : ((($result)[0] === "$Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return ($test)($actualOk);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 57:5', (sp_toHuman)($result))));
  }));
});

const i1Test$isOk = (i1Test$CodeExpectation)((($toText, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0Maybe$Just)($e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $actualOk = ($result)[1];
        return c0Maybe$Nothing;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 65:8', (sp_toHuman)($result))));
}));

const u3Uniqueness$codeTest = (($0, $1, $2, $3) => {
  return (i1Test$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const u0Compiler$CoreDefs$defToType = (($def, $pars) => {
  return (c0Compiler$CanonicalAst$TypeNamed)(c0Compiler$Pos$N, $def.usr, $pars);
});

const u0Compiler$CoreDefs$importsPath = (c0Compiler$Meta$ImportsPath)(c0Compiler$Meta$Core, "");

const u0Compiler$CoreDefs$umr = (c0Compiler$Meta$UMR)(u0Compiler$CoreDefs$importsPath, "src", "Core");

const u0Compiler$CoreDefs$usr = (($0) => {
  return (c0Compiler$Meta$USR)(u0Compiler$CoreDefs$umr, $0);
});

const u0Compiler$CoreDefs$numberUsr = (u0Compiler$CoreDefs$usr)("Number");

const u0Compiler$CoreDefs$numberDef = ({
  constructors: c0Dict$empty,
  pars: c0Core$Nil,
  usr: u0Compiler$CoreDefs$numberUsr,
});

const u0Compiler$CoreDefs$number = (u0Compiler$CoreDefs$defToType)(u0Compiler$CoreDefs$numberDef, c0Core$Nil);

const u0Compiler$CoreDefs$typeBinopUnique = (($ty) => {
  return (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$N, (c0Core$Cons)((c0Compiler$CanonicalAst$ParSp)((c0Compiler$Ast$toImm)($ty)), (c0Core$Cons)((c0Compiler$CanonicalAst$ParSp)((c0Compiler$Ast$toImm)($ty)), c0Core$Nil)), (c0Compiler$Ast$toUni)($ty));
});

const u0Compiler$CoreDefs$add = ({
  associativity: c0Compiler$Op$Left,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_addittive,
  symbol: "+",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$number),
  usr: (u0Compiler$CoreDefs$usr)("add"),
});

const u0Compiler$CoreDefs$boolName = "Bool";

const u0Compiler$CoreDefs$nameToType = (($name, $args) => {
  return (c0Compiler$CanonicalAst$TypeNamed)(c0Compiler$Pos$N, (u0Compiler$CoreDefs$usr)($name), $args);
});

const u0Compiler$CoreDefs$boolType = (u0Compiler$CoreDefs$nameToType)(u0Compiler$CoreDefs$boolName, c0Core$Nil);

const u0Compiler$CoreDefs$and_ = ({
  associativity: c0Compiler$Op$Right,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_logical,
  symbol: "and",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("and_"),
});

const u0Compiler$CoreDefs$divide = ({
  associativity: c0Compiler$Op$Left,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_multiplicative,
  symbol: "/",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$number),
  usr: (u0Compiler$CoreDefs$usr)("divide"),
});

const u0Compiler$CoreDefs$tyVar = (($0) => {
  return (c0Compiler$CanonicalAst$TypeAnnotationVariable)(c0Compiler$Pos$N, $0);
});

const u0Compiler$CoreDefs$tyFn = (($pars, $to) => {
  return (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$N, (c0List$map)((($p) => {
    return (c0Compiler$CanonicalAst$ParSp)((c0Compiler$Ast$toImm)($p));
  }), $pars), (c0Compiler$Ast$toImm)($to));
});

const u0Compiler$CoreDefs$typeBinop = (($left, $right, $return) => {
  return (u0Compiler$CoreDefs$tyFn)((c0Core$Cons)($left, (c0Core$Cons)($right, c0Core$Nil)), $return);
});

const u0Compiler$CoreDefs$equal = ({
  associativity: c0Compiler$Op$Left,
  nonFn: (c0Core$Cons)("a", c0Core$Nil),
  precedence: c0Compiler$Op$precedence_comparison,
  symbol: "==",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("a"), u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("equal"),
});

const u0Compiler$CoreDefs$greaterOrEqualThan = ({
  associativity: c0Compiler$Op$Left,
  nonFn: (c0Core$Cons)("a", c0Core$Nil),
  precedence: c0Compiler$Op$precedence_comparison,
  symbol: ">=",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("a"), u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("greaterOrEqualThan"),
});

const u0Compiler$CoreDefs$greaterThan = ({
  associativity: c0Compiler$Op$Left,
  nonFn: (c0Core$Cons)("a", c0Core$Nil),
  precedence: c0Compiler$Op$precedence_comparison,
  symbol: ">",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("a"), u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("greaterThan"),
});

const u0Compiler$CoreDefs$lesserOrEqualThan = ({
  associativity: c0Compiler$Op$Left,
  nonFn: (c0Core$Cons)("a", c0Core$Nil),
  precedence: c0Compiler$Op$precedence_comparison,
  symbol: "<=",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("a"), u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("lesserOrEqualThan"),
});

const u0Compiler$CoreDefs$lesserThan = ({
  associativity: c0Compiler$Op$Left,
  nonFn: (c0Core$Cons)("a", c0Core$Nil),
  precedence: c0Compiler$Op$precedence_comparison,
  symbol: "<",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("a"), u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("lesserThan"),
});

const u0Compiler$CoreDefs$listName = "List";

const u0Compiler$CoreDefs$listType = (($item) => {
  return (u0Compiler$CoreDefs$nameToType)(u0Compiler$CoreDefs$listName, (c0Core$Cons)($item, c0Core$Nil));
});

const u0Compiler$CoreDefs$listCons = ((() => {
  const $item = (u0Compiler$CoreDefs$tyVar)("item");
  return ({
    associativity: c0Compiler$Op$Right,
    nonFn: c0Core$Nil,
    precedence: c0Compiler$Op$precedence_cons,
    symbol: "::",
    type: (u0Compiler$CoreDefs$typeBinop)($item, (u0Compiler$CoreDefs$listType)($item), (u0Compiler$CoreDefs$listType)($item)),
    usr: (u0Compiler$CoreDefs$usr)("stack"),
  });
}))();

const u0Compiler$CoreDefs$multiply = ({
  associativity: c0Compiler$Op$Left,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_multiplicative,
  symbol: "*",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$number),
  usr: (u0Compiler$CoreDefs$usr)("multiply"),
});

const u0Compiler$CoreDefs$noneTypeName = "None";

const u0Compiler$CoreDefs$noneType = (u0Compiler$CoreDefs$nameToType)(u0Compiler$CoreDefs$noneTypeName, c0Core$Nil);

const u0Compiler$CoreDefs$mutableAdd = ({
  associativity: c0Compiler$Op$NonAssociative,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_mutop,
  symbol: "+=",
  type: (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$N, (c0Core$Cons)((c0Compiler$CanonicalAst$ParRe)(u0Compiler$CoreDefs$number), (c0Core$Cons)((c0Compiler$CanonicalAst$ParSp)(({
    raw: u0Compiler$CoreDefs$number,
    uni: c0Compiler$Ast$Imm,
  })), c0Core$Nil)), ({
    raw: u0Compiler$CoreDefs$noneType,
    uni: c0Compiler$Ast$Imm,
  })),
  usr: (u0Compiler$CoreDefs$usr)("mutableAdd"),
});

const u0Compiler$CoreDefs$mutableAssign = ({
  associativity: c0Compiler$Op$Left,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_mutop,
  symbol: ":=",
  type: (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$N, (c0Core$Cons)((c0Compiler$CanonicalAst$ParRe)((u0Compiler$CoreDefs$tyVar)("a")), (c0Core$Cons)((c0Compiler$CanonicalAst$ParSp)(({
    raw: (u0Compiler$CoreDefs$tyVar)("a"),
    uni: c0Compiler$Ast$Uni,
  })), c0Core$Nil)), ({
    raw: u0Compiler$CoreDefs$noneType,
    uni: c0Compiler$Ast$Imm,
  })),
  usr: (u0Compiler$CoreDefs$usr)("mutableAssign"),
});

const u0Compiler$CoreDefs$mutableSubtract = ({
  associativity: c0Compiler$Op$NonAssociative,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_mutop,
  symbol: "-=",
  type: (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$N, (c0Core$Cons)((c0Compiler$CanonicalAst$ParRe)(u0Compiler$CoreDefs$number), (c0Core$Cons)((c0Compiler$CanonicalAst$ParSp)(({
    raw: u0Compiler$CoreDefs$number,
    uni: c0Compiler$Ast$Imm,
  })), c0Core$Nil)), ({
    raw: u0Compiler$CoreDefs$noneType,
    uni: c0Compiler$Ast$Imm,
  })),
  usr: (u0Compiler$CoreDefs$usr)("mutableSubtract"),
});

const u0Compiler$CoreDefs$notEqual = ({
  associativity: c0Compiler$Op$Left,
  nonFn: (c0Core$Cons)("a", c0Core$Nil),
  precedence: c0Compiler$Op$precedence_comparison,
  symbol: "/=",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("a"), u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("notEqual"),
});

const u0Compiler$CoreDefs$or_ = ({
  associativity: c0Compiler$Op$Right,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_logical,
  symbol: "or",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$boolType),
  usr: (u0Compiler$CoreDefs$usr)("or_"),
});

const u0Compiler$CoreDefs$sendLeft = ({
  associativity: c0Compiler$Op$Right,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_pipe,
  symbol: "<<",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyFn)((c0Core$Cons)((u0Compiler$CoreDefs$tyVar)("a"), c0Core$Nil), (u0Compiler$CoreDefs$tyVar)("b")), (u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("b")),
  usr: (u0Compiler$CoreDefs$usr)("sendLeft"),
});

const u0Compiler$CoreDefs$sendRight = ({
  associativity: c0Compiler$Op$Left,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_pipe,
  symbol: ">>",
  type: (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyFn)((c0Core$Cons)((u0Compiler$CoreDefs$tyVar)("a"), c0Core$Nil), (u0Compiler$CoreDefs$tyVar)("b")), (u0Compiler$CoreDefs$tyVar)("b")),
  usr: (u0Compiler$CoreDefs$usr)("sendRight"),
});

const u0Compiler$CoreDefs$subtract = ({
  associativity: c0Compiler$Op$Left,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_addittive,
  symbol: "-",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$number),
  usr: (u0Compiler$CoreDefs$usr)("subtract"),
});

const u0Compiler$CoreDefs$textUsr = (u0Compiler$CoreDefs$usr)("Text");

const u0Compiler$CoreDefs$textDef = ({
  constructors: c0Dict$empty,
  pars: c0Core$Nil,
  usr: u0Compiler$CoreDefs$textUsr,
});

const u0Compiler$CoreDefs$text = (u0Compiler$CoreDefs$defToType)(u0Compiler$CoreDefs$textDef, c0Core$Nil);

const u0Compiler$CoreDefs$textConcat = ({
  associativity: c0Compiler$Op$Right,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_addittive,
  symbol: "..",
  type: (u0Compiler$CoreDefs$typeBinopUnique)(u0Compiler$CoreDefs$text),
  usr: (u0Compiler$CoreDefs$usr)("concat"),
});

const u0Compiler$CoreDefs$tuple = ({
  associativity: c0Compiler$Op$NonAssociative,
  nonFn: c0Core$Nil,
  precedence: c0Compiler$Op$precedence_tuple,
  symbol: "&",
  type: ((($0) => {
    return (u0Compiler$CoreDefs$typeBinop)((u0Compiler$CoreDefs$tyVar)("a"), (u0Compiler$CoreDefs$tyVar)("b"), $0);
  }))(((($0) => {
    return (c0Compiler$CanonicalAst$TypeRecord)(c0Compiler$Pos$N, $0);
  }))(((($0) => {
    return (c0Dict$insert)("second", (u0Compiler$CoreDefs$tyVar)("b"), $0);
  }))(((($0) => {
    return (c0Dict$insert)("first", (u0Compiler$CoreDefs$tyVar)("a"), $0);
  }))(c0Dict$empty)))),
  usr: (u0Compiler$CoreDefs$usr)("<& is just sugar>"),
});

const u0Compiler$CoreDefs$binops = (c0Core$Cons)(u0Compiler$CoreDefs$and_, (c0Core$Cons)(u0Compiler$CoreDefs$or_, (c0Core$Cons)(u0Compiler$CoreDefs$textConcat, (c0Core$Cons)(u0Compiler$CoreDefs$listCons, (c0Core$Cons)(u0Compiler$CoreDefs$tuple, (c0Core$Cons)(u0Compiler$CoreDefs$add, (c0Core$Cons)(u0Compiler$CoreDefs$subtract, (c0Core$Cons)(u0Compiler$CoreDefs$multiply, (c0Core$Cons)(u0Compiler$CoreDefs$divide, (c0Core$Cons)(u0Compiler$CoreDefs$mutableAssign, (c0Core$Cons)(u0Compiler$CoreDefs$mutableAdd, (c0Core$Cons)(u0Compiler$CoreDefs$mutableSubtract, (c0Core$Cons)(u0Compiler$CoreDefs$equal, (c0Core$Cons)(u0Compiler$CoreDefs$notEqual, (c0Core$Cons)(u0Compiler$CoreDefs$lesserThan, (c0Core$Cons)(u0Compiler$CoreDefs$greaterThan, (c0Core$Cons)(u0Compiler$CoreDefs$lesserOrEqualThan, (c0Core$Cons)(u0Compiler$CoreDefs$greaterOrEqualThan, (c0Core$Cons)(u0Compiler$CoreDefs$sendRight, (c0Core$Cons)(u0Compiler$CoreDefs$sendLeft, c0Core$Nil))))))))))))))))))));

const u0Compiler$CoreDefs$boolUsr = (u0Compiler$CoreDefs$usr)("Bool");

const u0Compiler$CoreDefs$falseName = "'false";

const u0Compiler$CoreDefs$falseUsr = (u0Compiler$CoreDefs$usr)(u0Compiler$CoreDefs$falseName);

const u0Compiler$CoreDefs$falseDef = ({
  constructorUsr: u0Compiler$CoreDefs$falseUsr,
  directDeps: (c0Dict$ofOne)(u0Compiler$CoreDefs$boolUsr, c0Compiler$Meta$TypeDependency),
  ins: c0Core$Nil,
  name: u0Compiler$CoreDefs$falseName,
  out: u0Compiler$CoreDefs$boolType,
  pos: c0Compiler$Pos$N,
  variantTypeUsr: u0Compiler$CoreDefs$boolUsr,
});

const u0Compiler$CoreDefs$trueName = "'true";

const u0Compiler$CoreDefs$trueUsr = (u0Compiler$CoreDefs$usr)(u0Compiler$CoreDefs$trueName);

const u0Compiler$CoreDefs$trueDef = ({
  constructorUsr: u0Compiler$CoreDefs$trueUsr,
  directDeps: (c0Dict$ofOne)(u0Compiler$CoreDefs$boolUsr, c0Compiler$Meta$TypeDependency),
  ins: c0Core$Nil,
  name: u0Compiler$CoreDefs$trueName,
  out: u0Compiler$CoreDefs$boolType,
  pos: c0Compiler$Pos$N,
  variantTypeUsr: u0Compiler$CoreDefs$boolUsr,
});

const u0Compiler$CoreDefs$boolDef = ({
  constructors: ((($0) => {
    return (c0Dict$insert)(u0Compiler$CoreDefs$falseName, u0Compiler$CoreDefs$falseDef, $0);
  }))(((($0) => {
    return (c0Dict$insert)(u0Compiler$CoreDefs$trueName, u0Compiler$CoreDefs$trueDef, $0);
  }))(c0Dict$empty)),
  pars: c0Core$Nil,
  usr: u0Compiler$CoreDefs$boolUsr,
});

const u0Compiler$CoreDefs$consName = "'cons";

const u0Compiler$CoreDefs$consUsr = (u0Compiler$CoreDefs$usr)(u0Compiler$CoreDefs$consName);

const u0Compiler$CoreDefs$listItem = (c0Compiler$CanonicalAst$TypeAnnotationVariable)(c0Compiler$Pos$N, "item");

const u0Compiler$CoreDefs$listUsr = (u0Compiler$CoreDefs$usr)("List");

const u0Compiler$CoreDefs$consDef = ({
  constructorUsr: u0Compiler$CoreDefs$consUsr,
  directDeps: (c0Dict$ofOne)(u0Compiler$CoreDefs$listUsr, c0Compiler$Meta$TypeDependency),
  ins: (c0Core$Cons)(u0Compiler$CoreDefs$listItem, (c0Core$Cons)((u0Compiler$CoreDefs$listType)(u0Compiler$CoreDefs$listItem), c0Core$Nil)),
  name: u0Compiler$CoreDefs$consName,
  out: (u0Compiler$CoreDefs$listType)(u0Compiler$CoreDefs$listItem),
  pos: c0Compiler$Pos$N,
  variantTypeUsr: u0Compiler$CoreDefs$listUsr,
});

const u0Compiler$MakeCanonical$typeDeps = (($type, $acc) => {
  return ((($type)[0] === "$TypeNamed")
    ? ((() => {
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return ((($0) => {
        return (c0List$for)($0, $args, u0Compiler$MakeCanonical$typeDeps);
      }))(((($0) => {
        return (c0Dict$insert)($usr, c0Compiler$Meta$TypeDependency, $0);
      }))($acc));
    }))()
    : ((($type)[0] === "$TypeAnnotationVariable")
      ? $acc
      : ((($type)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($type)[2];
          return (c0Dict$for)($acc, $attrs, (($k, $v, $a) => {
            return (u0Compiler$MakeCanonical$typeDeps)($v, $a);
          }));
        }))()
        : ((($type)[0] === "$TypeError")
          ? $acc
          : ((($type)[0] === "$TypeFn")
            ? ((() => {
              const $params = ($type)[2];
              const $to = ($type)[3];
              return ((($0) => {
                return (c0List$for)($0, $params, (($par, $z) => {
                  return ((($par)[0] === "$ParRe")
                    ? ((() => {
                      const $raw = ($par)[1];
                      return (u0Compiler$MakeCanonical$typeDeps)($raw, $z);
                    }))()
                    : ((($par)[0] === "$ParSp")
                      ? ((() => {
                        const $full = ($par)[1];
                        return (u0Compiler$MakeCanonical$typeDeps)($full.raw, $z);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 97:16', (sp_toHuman)($par))));
                }));
              }))(((($0) => {
                return (u0Compiler$MakeCanonical$typeDeps)($to.raw, $0);
              }))($acc));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 79:4', (sp_toHuman)($type)))))));
});

const u0Compiler$CoreDefs$insert = (($4, $raw, $nonFnAsList, $dict) => {
  const $name = ($4)[2];
  const $nonFn = (c0Set$fromList)($nonFnAsList);
  const $tyvars = ((($0) => {
    return (c0Dict$map)((($n, $pos) => {
      return ({
        nonFn: ((c0Set$member)($n, $nonFn)
          ? (c0Maybe$Just)(c0Compiler$Pos$N)
          : c0Maybe$Nothing),
      });
    }), $0);
  }))(((($0) => {
    return (c0Compiler$CanonicalAst$typeTyvars)($0);
  }))($raw));
  return ((($0) => {
    return (c0Dict$insert)($name, $0, $dict);
  }))(({
    directDeps: (u0Compiler$MakeCanonical$typeDeps)($raw, c0Dict$empty),
    maybeAnnotation: (c0Maybe$Just)(({
      raw: $raw,
      tyvars: $tyvars,
      univars: c0Dict$empty,
    })),
    maybeBody: c0Maybe$Nothing,
    name: $name,
    namePos: c0Compiler$Pos$N,
  }));
});

const u0Compiler$CoreDefs$nilName = "'nil";

const u0Compiler$CoreDefs$nilUsr = (u0Compiler$CoreDefs$usr)(u0Compiler$CoreDefs$nilName);

const u0Compiler$CoreDefs$nilDef = ({
  constructorUsr: u0Compiler$CoreDefs$nilUsr,
  directDeps: (c0Dict$ofOne)(u0Compiler$CoreDefs$listUsr, c0Compiler$Meta$TypeDependency),
  ins: c0Core$Nil,
  name: u0Compiler$CoreDefs$nilName,
  out: (u0Compiler$CoreDefs$listType)(u0Compiler$CoreDefs$listItem),
  pos: c0Compiler$Pos$N,
  variantTypeUsr: u0Compiler$CoreDefs$listUsr,
});

const u0Compiler$CoreDefs$listDef = ({
  constructors: ((($0) => {
    return (c0Dict$insert)(u0Compiler$CoreDefs$consName, u0Compiler$CoreDefs$consDef, $0);
  }))(((($0) => {
    return (c0Dict$insert)(u0Compiler$CoreDefs$nilName, u0Compiler$CoreDefs$nilDef, $0);
  }))(c0Dict$empty)),
  pars: (c0Core$Cons)(({
    first: "item",
    second: c0Compiler$Pos$N,
  }), c0Core$Nil),
  usr: u0Compiler$CoreDefs$listUsr,
});

const u0Compiler$CoreDefs$noneConsName = "'none";

const u0Compiler$CoreDefs$noneConsUsr = (u0Compiler$CoreDefs$usr)(u0Compiler$CoreDefs$noneConsName);

const u0Compiler$CoreDefs$noneTypeUsr = (u0Compiler$CoreDefs$usr)(u0Compiler$CoreDefs$noneTypeName);

const u0Compiler$CoreDefs$noneConsDef = ({
  constructorUsr: u0Compiler$CoreDefs$noneConsUsr,
  directDeps: (c0Dict$ofOne)(u0Compiler$CoreDefs$noneTypeUsr, c0Compiler$Meta$TypeDependency),
  ins: c0Core$Nil,
  name: u0Compiler$CoreDefs$noneConsName,
  out: u0Compiler$CoreDefs$noneType,
  pos: c0Compiler$Pos$N,
  variantTypeUsr: u0Compiler$CoreDefs$noneTypeUsr,
});

const u0Compiler$CoreDefs$noneTypeDef = ({
  constructors: (c0Dict$ofOne)(u0Compiler$CoreDefs$noneConsName, u0Compiler$CoreDefs$noneConsDef),
  pars: c0Core$Nil,
  usr: u0Compiler$CoreDefs$noneTypeUsr,
});

const u0Compiler$CoreDefs$unaryMinus = ({
  symbol: "0 -",
  type: (u0Compiler$CoreDefs$tyFn)((c0Core$Cons)(u0Compiler$CoreDefs$number, c0Core$Nil), u0Compiler$CoreDefs$number),
  usr: (u0Compiler$CoreDefs$usr)("unaryMinus"),
});

const u0Compiler$CoreDefs$unaryPlus = ({
  symbol: "0 +",
  type: (u0Compiler$CoreDefs$tyFn)((c0Core$Cons)(u0Compiler$CoreDefs$number, c0Core$Nil), u0Compiler$CoreDefs$number),
  usr: (u0Compiler$CoreDefs$usr)("unaryPlus"),
});

const u0Compiler$CoreDefs$coreModule = ((() => {
  const $variantTypeDefs = ((($0) => {
    return (c0List$for)(c0Dict$empty, $0, (($def, $dict) => {
      const $4 = $def.usr;
      const $name = ($4)[2];
      return (c0Dict$insert)($name, $def, $dict);
    }));
  }))((c0Core$Cons)(u0Compiler$CoreDefs$textDef, (c0Core$Cons)(u0Compiler$CoreDefs$numberDef, (c0Core$Cons)(u0Compiler$CoreDefs$noneTypeDef, (c0Core$Cons)(u0Compiler$CoreDefs$boolDef, (c0Core$Cons)(u0Compiler$CoreDefs$listDef, c0Core$Nil))))));
  const $constructorDefs = ((($0) => {
    return (c0List$for)(c0Dict$empty, $0, (($def, $dict) => {
      return (c0Dict$insert)($def.name, $def, $dict);
    }));
  }))((c0Core$Cons)(u0Compiler$CoreDefs$noneConsDef, (c0Core$Cons)(u0Compiler$CoreDefs$trueDef, (c0Core$Cons)(u0Compiler$CoreDefs$falseDef, (c0Core$Cons)(u0Compiler$CoreDefs$nilDef, (c0Core$Cons)(u0Compiler$CoreDefs$consDef, c0Core$Nil))))));
  const $valueDefs = ((($0) => {
    return (c0List$for)($0, u0Compiler$CoreDefs$binops, (($binop, $dict) => {
      return (u0Compiler$CoreDefs$insert)($binop.usr, $binop.type, $binop.nonFn, $dict);
    }));
  }))(((($0) => {
    return (c0List$for)($0, (c0Core$Cons)(u0Compiler$CoreDefs$unaryPlus, (c0Core$Cons)(u0Compiler$CoreDefs$unaryMinus, c0Core$Nil)), (($unop, $dict) => {
      return (u0Compiler$CoreDefs$insert)($unop.usr, $unop.type, c0Core$Nil, $dict);
    }));
  }))(c0Dict$empty));
  return ({
    aliasDefs: c0Dict$empty,
    asText: "<core module>",
    constructorDefs: $constructorDefs,
    fsPath: "<core module>",
    umr: u0Compiler$CoreDefs$umr,
    valueDefs: $valueDefs,
    variantTypeDefs: $variantTypeDefs,
  });
}))();

const u0Compiler$LazyBuild$collectUsrDependencies = (($env, $state, $usr, $depType) => {
  const $5 = $usr;
  const $name = ($5)[2];
  const $umr = ($5)[1];
  return ([
    ((c0Result$onOk)((($caModule) => {
      const $7 = ((($depType)[0] === "$TypeDependency")
        ? ((() => {
          const $8 = (c0Dict$get)($name, $caModule.aliasDefs);
          return ((($8)[0] === "$Just")
            ? ((() => {
              const $d = ($8)[1];
              return ({
                first: (u0Compiler$LazyBuild$AliasDef)($d),
                second: $d.directDeps,
              });
            }))()
            : ((($8)[0] === "$Nothing")
              ? ((() => {
                const $9 = (c0Dict$get)($name, $caModule.variantTypeDefs);
                return ((($9)[0] === "$Just")
                  ? ((() => {
                    const $d = ($9)[1];
                    return ({
                      first: (u0Compiler$LazyBuild$VariantTypeDef)($d),
                      second: c0Dict$empty,
                    });
                  }))()
                  : ((($9)[0] === "$Nothing")
                    ? ({
                      first: u0Compiler$LazyBuild$MissingDef,
                      second: c0Dict$empty,
                    })
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 78:24', (sp_toHuman)($9))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 72:16', (sp_toHuman)($8))));
        }))()
        : ((($depType)[0] === "$ConstructorDependency")
          ? ((() => {
            const $8 = (c0Dict$get)($name, $caModule.constructorDefs);
            return ((($8)[0] === "$Just")
              ? ((() => {
                const $d = ($8)[1];
                return ({
                  first: (u0Compiler$LazyBuild$ConstructorDef)($d),
                  second: $d.directDeps,
                });
              }))()
              : ((($8)[0] === "$Nothing")
                ? ({
                  first: u0Compiler$LazyBuild$MissingDef,
                  second: c0Dict$empty,
                })
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 88:16', (sp_toHuman)($8))));
          }))()
          : ((($depType)[0] === "$ValueDependency")
            ? ((() => {
              const $8 = (c0Dict$get)($name, $caModule.valueDefs);
              return ((($8)[0] === "$Just")
                ? ((() => {
                  const $d = ($8)[1];
                  return ({
                    first: (u0Compiler$LazyBuild$ValueDef)($d),
                    second: $d.directDeps,
                  });
                }))()
                : ((($8)[0] === "$Nothing")
                  ? ({
                    first: u0Compiler$LazyBuild$MissingDef,
                    second: c0Dict$empty,
                  })
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 93:16', (sp_toHuman)($8))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 69:8', (sp_toHuman)($depType)))));
      const $deps = $7.second;
      const $def = $7.first;
      ((__re__ = (hash_insert)($state.done, $usr, ({
        def: $def,
        deps: $deps,
      }))), ($state.done = (__re__)[1]), (__re__)[0]);
      (c0Dict$each)($deps, (($u, $c) => {
        return ((sp_equal)(((__re__ = (hash_get)($state.done, $u)), ($state.done = (__re__)[1]), (__re__)[0]), c0Maybe$Nothing)
          ? ((__re__ = (hash_insert)($state.pending, $u, $c)), ($state.pending = (__re__)[1]), (__re__)[0])
          : null);
      }));
      return (c0Result$Ok)(null);
    })))(((() => {
      const $6 = ((__re__ = (hash_get)($state.loadedModulesByUmr, $umr)), ($state.loadedModulesByUmr = (__re__)[1]), (__re__)[0]);
      return ((($6)[0] === "$Just")
        ? ((() => {
          const $caModule = ($6)[1];
          return (c0Result$Ok)($caModule);
        }))()
        : ((($6)[0] === "$Nothing")
          ? ((c0Result$onOk)((($caModule) => {
            ((__re__ = (hash_insert)($state.loadedModulesByUmr, $umr, $caModule)), ($state.loadedModulesByUmr = (__re__)[1]), (__re__)[0]);
            return (c0Result$Ok)($caModule);
          })))(($env.loadCaModule)($umr))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 56:4', (sp_toHuman)($6))));
    }))()),
    $state,
  ]);
});

const u0Compiler$LazyBuild$collectRequiredUsrs = (($env, $state) => {
  const $3 = ((__re__ = (hash_pop)($state.pending)), ($state.pending = (__re__)[1]), (__re__)[0]);
  return ([
    ((($3)[0] === "$Nothing")
      ? (c0Result$Ok)(null)
      : ((($3)[0] === "$Just")
        ? ((() => {
          const $usr = ($3)[1].first;
          const $depType = ($3)[1].second;
          return ((c0Result$onOk)(((_0) => {
            return ((__re__ = (u0Compiler$LazyBuild$collectRequiredUsrs)($env, $state)), ($state = (__re__)[1]), (__re__)[0]);
          })))(((__re__ = (u0Compiler$LazyBuild$collectUsrDependencies)($env, $state, $usr, $depType)), ($state = (__re__)[1]), (__re__)[0]));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 110:4', (sp_toHuman)($3)))),
    $state,
  ]);
});

const u0Compiler$Lexer$startsWithUpperChar = ((() => {
  const $re = (text_startsWithRegex)("[A-Z]");
  return (($s) => {
    const $2 = ($re)($s);
    return (("" === $2)
      ? false
      : (true
        ? true
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 316:4', (sp_toHuman)($2))));
  });
}))();

const u0Compiler$LazyBuild$usrToDependencyType = (($1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return ((u0Compiler$Lexer$startsWithUpperChar)($name)
    ? c0Compiler$Meta$TypeDependency
    : ((text_startsWith)("'", $name)
      ? c0Compiler$Meta$ConstructorDependency
      : c0Compiler$Meta$ValueDependency));
});

const u0Compiler$TypeCheck$initState = (($lastUnificationVarId) => {
  return ({
    boundTyvars: (hash_fromList)(c0Core$Nil),
    errors: (array_fromList)(c0Core$Nil),
    lastUnificationVarId: $lastUnificationVarId,
    tyvarSubs: (hash_fromList)(c0Core$Nil),
    tyvarsById: (hash_fromList)(c0Core$Nil),
    univarSubs: (hash_fromList)(c0Core$Nil),
    univarsById: (hash_fromList)(c0Core$Nil),
  });
});

const u0Compiler$TypeCheck$newTyvarId = (($state) => {
  ($state.lastUnificationVarId += 1);
  return ([
    ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$TypeCheck$getErrorModule = (($env) => {
  const $2 = $env.currentRootUsr;
  const $umr = ($2)[1];
  const $3 = (c0Dict$get)($umr, $env.modulesByUmr);
  return ((($3)[0] === "$Nothing")
    ? ({
      content: "",
      fsPath: "N/A",
    })
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $content = ($3)[1].asText;
        const $fsPath = ($3)[1].fsPath;
        return ({
          content: $content,
          fsPath: $fsPath,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 290:4', (sp_toHuman)($3))));
});

const u0Compiler$TypeCheck$addErrorE = (($env, $pos, $error, $errors) => {
  return ([
    ((($0) => {
      return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
    }))(((($0) => {
      return (u0Compiler$Error$Simple)((u0Compiler$TypeCheck$getErrorModule)($env), $pos, $0);
    }))((c0Core$Cons)((sp_toHuman)($error), (c0Core$Cons)((sp_toHuman)($env.context), c0Core$Nil)))),
    $errors,
  ]);
});

const u0Compiler$TypeCheck$bug = (($msg) => {
  return (sp_todo)(("Compiler bug: " + $msg));
});

const u0Compiler$TypeCheck$expandTyvarsInType = (($tyvarIdsToType, $type) => {
  const $rec = (($0) => {
    return (u0Compiler$TypeCheck$expandTyvarsInType)($tyvarIdsToType, $0);
  });
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($type)[1];
      const $args = ($type)[2];
      return (c0Compiler$TypedAst$TypeExact)($usr, (c0List$map)($rec, $args));
    }))()
    : ((($type)[0] === "$TypeFn")
      ? ((() => {
        const $ins = ($type)[1];
        const $out = ($type)[2];
        return (c0Compiler$TypedAst$TypeFn)((c0Compiler$TypedAst$mapPars)($rec, $ins), ((() => {
          const $0 = $out;
          return (Object.assign)({}, $0, ({
            raw: ($rec)($0.raw),
          }));
        }))());
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Nothing"))
        ? ((() => {
          const $attrs = ($type)[2];
          return (c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, (c0Dict$map)((($k, $v) => {
            return ($rec)($v);
          }), $attrs));
        }))()
        : ((($type)[0] === "$TypeVar")
          ? ((() => {
            const $id = ($type)[1];
            const $3 = (c0Dict$get)($id, $tyvarIdsToType);
            return ((($3)[0] === "$Nothing")
              ? (u0Compiler$TypeCheck$bug)("this is not supposed to happen")
              : ((($3)[0] === "$Just")
                ? ((() => {
                  const $ty = ($3)[1];
                  return $ty;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 430:12', (sp_toHuman)($3))));
          }))()
          : (((($type)[0] === "$TypeRecord") && ((($type)[1])[0] === "$Just"))
            ? ((() => {
              const $id = (($type)[1])[1];
              const $attrs = ($type)[2];
              return (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($id), (c0Dict$map)((($k, $v) => {
                return ($rec)($v);
              }), $attrs));
            }))()
            : ((($type)[0] === "$TypeError")
              ? c0Compiler$TypedAst$TypeError
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 418:4', (sp_toHuman)($type))))))));
});

const u0Compiler$TypeCheck$translateUni = (($originalIdToNewId, $originalUni) => {
  return ((($originalUni)[0] === "$Depends")
    ? ((() => {
      const $originalId = ($originalUni)[1];
      const $3 = (c0Dict$get)($originalId, $originalIdToNewId);
      return ((($3)[0] === "$Just")
        ? ((() => {
          const $newId = ($3)[1];
          return (c0Compiler$Ast$Depends)($newId);
        }))()
        : ((($3)[0] === "$Nothing")
          ? $originalUni
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 447:12', (sp_toHuman)($3))));
    }))()
    : (true
      ? $originalUni
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 444:4', (sp_toHuman)($originalUni))));
});

const u0Compiler$TypeCheck$translateFullType = (($env, $argsByName, $originalIdToNewId, $errors, $caFull) => {
  return ([
    ({
      raw: ((__re__ = (u0Compiler$TypeCheck$translateRawType)($env, $argsByName, $originalIdToNewId, $errors, $caFull.raw)), ($errors = (__re__)[1]), (__re__)[0]),
      uni: (u0Compiler$TypeCheck$translateUni)($originalIdToNewId, $caFull.uni),
    }),
    $errors,
  ]);
});

const u0Compiler$TypeCheck$translateRawType = (($env, $argsByName, $originalIdToNewId, $errors, $caType) => {
  const $rec = (($0) => {
    return ((__re__ = (u0Compiler$TypeCheck$translateRawType)($env, $argsByName, $originalIdToNewId, $errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((($caType)[0] === "$TypeFn")
      ? ((() => {
        const $pos = ($caType)[1];
        const $caPars = ($caType)[2];
        const $caOut = ($caType)[3];
        const $zzz = (($caPar) => {
          return ((($caPar)[0] === "$ParRe")
            ? ((() => {
              const $caRaw = ($caPar)[1];
              return (c0Compiler$TypedAst$ParRe)(($rec)($caRaw));
            }))()
            : ((($caPar)[0] === "$ParSp")
              ? ((() => {
                const $caFull = ($caPar)[1];
                return (c0Compiler$TypedAst$ParSp)(((__re__ = (u0Compiler$TypeCheck$translateFullType)($env, $argsByName, $originalIdToNewId, $errors, $caFull)), ($errors = (__re__)[1]), (__re__)[0]));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 473:20', (sp_toHuman)($caPar))));
        });
        const $taArgs = (c0List$map)($zzz, $caPars);
        return (c0Compiler$TypedAst$TypeFn)($taArgs, ((__re__ = (u0Compiler$TypeCheck$translateFullType)($env, $argsByName, $originalIdToNewId, $errors, $caOut)), ($errors = (__re__)[1]), (__re__)[0]));
      }))()
      : ((($caType)[0] === "$TypeRecord")
        ? ((() => {
          const $pos = ($caType)[1];
          const $caAttrs = ($caType)[2];
          return (c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, (c0Dict$map)((($name, $v) => {
            return ($rec)($v);
          }), $caAttrs));
        }))()
        : ((($caType)[0] === "$TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($caType)[1];
            const $name = ($caType)[2];
            const $6 = (c0Dict$get)($name, $argsByName);
            return ((($6)[0] === "$Nothing")
              ? ((() => {
                ((__re__ = (u0Compiler$TypeCheck$addErrorE)($env, $pos, (u0Compiler$TypeCheck$ErrorUndefinedTypeVariable)($name), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                return c0Compiler$TypedAst$TypeError;
              }))()
              : ((($6)[0] === "$Just")
                ? ((() => {
                  const $raw = ($6)[1];
                  return $raw;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 486:12', (sp_toHuman)($6))));
          }))()
          : ((($caType)[0] === "$TypeNamed")
            ? ((() => {
              const $pos = ($caType)[1];
              const $usr = ($caType)[2];
              const $pars = ($caType)[3];
              const $expandedPars = (c0List$map)($rec, $pars);
              const $6 = (c0Dict$get)($usr, $env.expandedAliases);
              return ((($6)[0] === "$Nothing")
                ? ((() => {
                  const $7 = (c0Dict$get)($usr, $env.exactTypes);
                  return ((($7)[0] === "$Just")
                    ? ((() => {
                      const $exact = ($7)[1];
                      return (c0Compiler$TypedAst$TypeExact)($usr, $expandedPars);
                    }))()
                    : ((($7)[0] === "$Nothing")
                      ? ((() => {
                        ((__re__ = (u0Compiler$TypeCheck$addErrorE)($env, $pos, (u0Compiler$TypeCheck$ErrorTypeNotFound)($usr), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                        return c0Compiler$TypedAst$TypeError;
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 503:20', (sp_toHuman)($7))));
                }))()
                : ((($6)[0] === "$Just")
                  ? ((() => {
                    const $expandedAlias = ($6)[1];
                    return ((sp_not_equal)((c0List$length)($expandedAlias.pars), (c0List$length)($expandedPars))
                      ? ((() => {
                        ((__re__ = (u0Compiler$TypeCheck$addErrorE)($env, $pos, (u0Compiler$TypeCheck$ErrorWrongNumberOfTypeArguments)($usr, $expandedAlias.pars, $expandedPars), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                        return c0Compiler$TypedAst$TypeError;
                      }))()
                      : ((() => {
                        const $tyvarIdsToType = (c0Dict$fromList)((c0List$map2)(c0Tuple$pair, $expandedAlias.pars, $expandedPars));
                        return (u0Compiler$TypeCheck$expandTyvarsInType)($tyvarIdsToType, $expandedAlias.type);
                      }))());
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 500:12', (sp_toHuman)($6))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 468:4', (sp_toHuman)($caType)))))),
    $errors,
  ]);
});

const u0Compiler$TypeCheck$addInstance = (($lastUnificationVarId, $errors, $umr, $def, $env) => {
  let $state = (u0Compiler$TypeCheck$initState)(((__re__ = (basics_cloneUni)($lastUnificationVarId)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  const $nameToIdAndClasses = ((() => {
    const $zzzz = (($tyvarName, $6) => {
      const $nonFn = $6.nonFn;
      return ({
        first: ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]),
        second: ({
          maybeAnnotated: (c0Maybe$Just)(({
            allowFunctions: (sp_equal)($nonFn, c0Maybe$Nothing),
            name: $tyvarName,
          })),
        }),
      });
    });
    return ((($0) => {
      return (c0Maybe$withDefault)(c0Dict$empty, $0);
    }))(((($0) => {
      return (c0Maybe$map)((($ann) => {
        return (c0Dict$map)($zzzz, $ann.tyvars);
      }), $0);
    }))($def.maybeAnnotation));
  }))();
  const $nameToType = (c0Dict$map)((($k, $6) => {
    const $id = $6.first;
    const $classes = $6.second;
    return (c0Compiler$TypedAst$TypeVar)($id);
  }), $nameToIdAndClasses);
  const $tyvarIdToClasses = (c0Dict$fromList)((c0Dict$values)($nameToIdAndClasses));
  const $originalIdToNewIdAndUnivar = ((() => {
    const $6 = $def.maybeAnnotation;
    return ((($6)[0] === "$Just")
      ? ((() => {
        const $ann = ($6)[1];
        return ((($0) => {
          return (c0Dict$map)((($annotatedId, _1) => {
            return ({
              first: ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]),
              second: ({
                annotatedId: $annotatedId,
              }),
            });
          }), $0);
        }))((c0Compiler$CanonicalAst$typeUnivars)($ann.raw));
      }))()
      : ((($6)[0] === "$Nothing")
        ? c0Dict$empty
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2030:8', (sp_toHuman)($6))));
  }))();
  const $originalIdToUniqueness = ((($0) => {
    return (c0Dict$map)((($annotatedId, $7) => {
      const $newId = $7.first;
      const $univar = $7.second;
      return $newId;
    }), $0);
  }))($originalIdToNewIdAndUnivar);
  const $freeUnivars = (c0Dict$fromList)((c0Dict$values)($originalIdToNewIdAndUnivar));
  const $envF = ((() => {
    const $6 = $def.maybeAnnotation;
    return ((($6)[0] === "$Nothing")
      ? $env
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $annotation = ($6)[1];
          const $raw = ((__re__ = (u0Compiler$TypeCheck$translateRawType)($env, $nameToType, $originalIdToUniqueness, $state.errors, $annotation.raw)), ($state.errors = (__re__)[1]), (__re__)[0]);
          const $instance = ({
            definedAt: $def.namePos,
            freeTyvars: (c0Dict$intersect)($tyvarIdToClasses, (c0Compiler$TypedAst$typeTyvars)($raw)),
            freeUnivars: $freeUnivars,
            type: ({
              raw: $raw,
              uni: c0Compiler$Ast$Imm,
            }),
          });
          const $ref = (c0Compiler$Ast$RefGlobal)(((($0) => {
            return (c0Compiler$Meta$USR)($umr, $0);
          }))($def.name));
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            variables: (c0Dict$insert)($ref, $instance, $0.variables),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2052:8', (sp_toHuman)($6))));
  }))();
  ($lastUnificationVarId = ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  ((__re__ = (array_each)($state.errors, (($err) => {
    return ((__re__ = (array_push)($errors, $err)), ($errors = (__re__)[1]), (__re__)[0]);
  }))), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    $envF,
    $lastUnificationVarId,
    $errors,
  ]);
});

const u0Compiler$LazyBuild$evaluateCircularValues = (($state, $errors, $lastUnificationVarId, $circular, $env0) => {
  return ([
    ((($circular)[0] === "$Cons")
      ? ((() => {
        const $u = ($circular)[1];
        const $others = ($circular)[2];
        return ((sp_equal)((u0Compiler$LazyBuild$usrToDependencyType)($u), c0Compiler$Meta$TypeDependency)
          ? $env0
          : (c0List$for)($env0, $circular, (($usr, $envX) => {
            const $8 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
            return (((($8)[0] === "$Just") && ((($8)[1].def)[0] === "$ValueDef"))
              ? ((() => {
                const $def = (($8)[1].def)[1];
                const $9 = $def.maybeAnnotation;
                return ((($9)[0] === "$Just")
                  ? ((() => {
                    const $ann = ($9)[1];
                    const $10 = $u;
                    const $umr = ($10)[1];
                    return ((__re__ = (u0Compiler$TypeCheck$addInstance)($lastUnificationVarId, $errors, $umr, $def, $envX)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
                  }))()
                  : ((($9)[0] === "$Nothing")
                    ? ((() => {
                      ((($0) => {
                        return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
                      }))((u0Compiler$Error$Raw)(((sp_equal)($others, c0Core$Nil)
                        ? (c0Core$Cons)(("Value " + ($def.name + "  is recursive, so I need a type annotation for it.")), c0Core$Nil)
                        : (c0Core$Cons)(("Value " + ($def.name + (" depends is mutually recursive with " + ((sp_toHuman)($circular) + " so I need it to be annotated.")))), c0Core$Nil))));
                      return $envX;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 176:32', (sp_toHuman)($9))));
              }))()
              : (true
                ? $envX
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 173:24', (sp_toHuman)($8))));
          })));
      }))()
      : (true
        ? $env0
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 165:8', (sp_toHuman)($circular)))),
    $state,
    $errors,
    $lastUnificationVarId,
  ]);
});

const u0Compiler$TypeCheck$namedParsToIdParsAndDict = (($atPars) => {
  const $idPars = ((($0) => {
    return (c0List$indexedMap)((($index, $atName) => {
      return -($index);
    }), $0);
  }))($atPars);
  const $typeByName = (c0Dict$fromList)(((($0) => {
    return (c0List$indexedMap)((($index, $3) => {
      const $name = $3.first;
      const $pos = $3.second;
      return ({
        first: $name,
        second: (c0Compiler$TypedAst$TypeVar)(-($index)),
      });
    }), $0);
  }))($atPars));
  return ({
    first: $idPars,
    second: $typeByName,
  });
});

const u0Compiler$TypeCheck$expandAndInsertAlias = (($errors, $env, $aliasDef, $aliasAccum) => {
  const $5 = (u0Compiler$TypeCheck$namedParsToIdParsAndDict)($aliasDef.pars);
  const $typeByName = $5.second;
  const $pars = $5.first;
  const $originalIdToNewId = c0Dict$empty;
  const $type = ((__re__ = (u0Compiler$TypeCheck$translateRawType)(((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      expandedAliases: $aliasAccum,
    }));
  }))(), $typeByName, $originalIdToNewId, $errors, $aliasDef.type)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    (c0Dict$insert)($aliasDef.usr, ({
      pars: $pars,
      type: $type,
    }), $aliasAccum),
    $errors,
  ]);
});

const u0Compiler$LazyBuild$expandAndInsertType = (($state, $errors, $usr, $env0) => {
  const $5 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
  return ([
    ((($5)[0] === "$Nothing")
      ? (sp_todo)(("compiler bug, missing type usr" + (sp_toHuman)($usr)))
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $def = ($5)[1].def;
          const $deps = ($5)[1].deps;
          return ((($def)[0] === "$VariantTypeDef")
            ? ((() => {
              const $variantTypeDef = ($def)[1];
              const $0 = $env0;
              return (Object.assign)({}, $0, ({
                exactTypes: (c0Dict$insert)($usr, $variantTypeDef.pars, $0.exactTypes),
              }));
            }))()
            : ((($def)[0] === "$AliasDef")
              ? ((() => {
                const $aliasDef = ($def)[1];
                const $0 = $env0;
                return (Object.assign)({}, $0, ({
                  expandedAliases: ((__re__ = (u0Compiler$TypeCheck$expandAndInsertAlias)($errors, ((() => {
                    const $1 = $env0;
                    return (Object.assign)({}, $1, ({
                      currentRootUsr: $usr,
                    }));
                  }))(), $aliasDef, $0.expandedAliases)), ($errors = (__re__)[1]), (__re__)[0]),
                }));
              }))()
              : (true
                ? $env0
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 131:12', (sp_toHuman)($def)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 125:4', (sp_toHuman)($5)))),
    $state,
    $errors,
  ]);
});

const u0Compiler$LazyBuild$initCollectDependenciesState = (($pendingList) => {
  let $pending = (hash_fromList)($pendingList);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$noneTypeUsr, c0Compiler$Meta$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$noneConsUsr, c0Compiler$Meta$ConstructorDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$boolUsr, c0Compiler$Meta$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$trueUsr, c0Compiler$Meta$ConstructorDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$falseUsr, c0Compiler$Meta$ConstructorDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$numberUsr, c0Compiler$Meta$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$textUsr, c0Compiler$Meta$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($pending, u0Compiler$CoreDefs$listUsr, c0Compiler$Meta$TypeDependency)), ($pending = (__re__)[1]), (__re__)[0]);
  return ({
    done: (hash_fromList)(c0Core$Nil),
    loadedModulesByUmr: (hash_fromList)((c0Core$Cons)(({
      first: u0Compiler$CoreDefs$umr,
      second: u0Compiler$CoreDefs$coreModule,
    }), c0Core$Nil)),
    pending: $pending,
  });
});

const u0Compiler$LazyBuild$stopOnError = (($pars, $errors) => {
  const $3 = ((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    ((($3)[0] === "$Nil")
      ? (c0Result$Ok)(null)
      : (true
        ? ((() => {
          const $errorsAsList = $3;
          return (c0Result$Err)((u0Compiler$Error$Nested)($errorsAsList));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 225:4', (sp_toHuman)($3)))),
    $errors,
  ]);
});

const u0Compiler$TypeCheck$addConstructorToGlobalEnv = (($errors, $name, $caConstructor, $env) => {
  const $5 = $caConstructor.variantTypeUsr;
  const $umr = ($5)[1];
  const $ins = ((($0) => {
    return (c0List$map)((($in) => {
      return (c0Compiler$CanonicalAst$ParSp)(({
        raw: $in,
        uni: (c0Compiler$Ast$Depends)(1),
      }));
    }), $0);
  }))($caConstructor.ins);
  const $caRaw = ((sp_equal)($ins, c0Core$Nil)
    ? $caConstructor.out
    : (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$G, $ins, ({
      raw: $caConstructor.out,
      uni: (c0Compiler$Ast$Depends)(1),
    })));
  const $tyvarNamesAndIds = ((($0) => {
    return (c0List$indexedMap)((($index, $n) => {
      return ({
        first: $n,
        second: -($index),
      });
    }), $0);
  }))((c0Dict$keys)((c0Compiler$CanonicalAst$typeTyvars)($caRaw)));
  const $paramsByName = (c0List$for)(c0Dict$empty, $tyvarNamesAndIds, (($7, $d) => {
    const $n = $7.first;
    const $id = $7.second;
    return (c0Dict$insert)($n, (c0Compiler$TypedAst$TypeVar)($id), $d);
  }));
  const $raw = ((__re__ = (u0Compiler$TypeCheck$translateRawType)($env, $paramsByName, c0Dict$empty, $errors, $caRaw)), ($errors = (__re__)[1]), (__re__)[0]);
  const $freeTyvars = (c0List$for)(c0Dict$empty, $tyvarNamesAndIds, (($7, $d) => {
    const $n = $7.first;
    const $id = $7.second;
    return (c0Dict$insert)($id, ({
      maybeAnnotated: (c0Maybe$Just)(({
        allowFunctions: true,
        name: $n,
      })),
    }), $d);
  }));
  const $taConstructor = ({
    definedAt: c0Compiler$Pos$G,
    freeTyvars: $freeTyvars,
    freeUnivars: (c0Dict$ofOne)(1, ({
      annotatedId: 1,
    })),
    type: (c0Compiler$Ast$toImm)($raw),
  });
  const $0 = $env;
  return ([
    (Object.assign)({}, $0, ({
      constructors: (c0Dict$insert)((c0Compiler$Meta$USR)($umr, $name), $taConstructor, $0.constructors),
    })),
    $errors,
  ]);
});

const u0Compiler$TypeCheck$applyAllSubs = (($state, $raw) => {
  const $subsAsFns = ({
    ty: (($id) => {
      return ((__re__ = (hash_get)($state.tyvarSubs, $id)), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
    }),
    uni: (($id) => {
      return ((__re__ = (hash_get)($state.univarSubs, $id)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
    }),
  });
  return ([
    (c0Compiler$TypedAst$resolveRaw)($subsAsFns, $raw),
    $state,
  ]);
});

const u0Human$Format$chainPrecedence = (($ls) => {
  return ((($ls)[0] === "$Nil")
    ? 0
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $op = ($ls)[1].first;
        return $op.precedence;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 113:4', (sp_toHuman)($ls))));
});

const u0Human$Format$expressionPrecedence = (($1) => {
  const $e_ = ($1)[3];
  return ((($e_)[0] === "$Statements")
    ? ((() => {
      const $stats = ($e_)[1];
      return 0;
    }))()
    : ((($e_)[0] === "$BinopChain")
      ? ((() => {
        const $priority = ($e_)[1];
        const $binopChain = ($e_)[2];
        return (u0Human$Format$chainPrecedence)($binopChain.second);
      }))()
      : ((($e_)[0] === "$Poly")
        ? ((() => {
          const $text = ($e_)[1];
          const $expression = ($e_)[2];
          return 9;
        }))()
        : ((($e_)[0] === "$If")
          ? 9
          : ((($e_)[0] === "$Try")
            ? 9
            : ((($e_)[0] === "$Call")
              ? c0Compiler$Op$precedence_application
              : ((($e_)[0] === "$Fn")
                ? ((() => {
                  const $pars = ($e_)[2];
                  const $body = ($e_)[3];
                  return c0Compiler$Op$precedence_function;
                }))()
                : (((($e_)[0] === "$Lowercase") && ((($e_)[1].maybeType)[0] === "$Just"))
                  ? (c0Compiler$Op$precedence_tuple - 1)
                  : (true
                    ? 10
                    : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 129:4', (sp_toHuman)($e_)))))))))));
});

const u0SPLib$Format$indent_map = (($f, $1) => {
  const $indent = ($1)[1];
  const $l = ($1)[2];
  return (u0SPLib$Format$Indented)($indent, ($f)($l));
});

const u0SPLib$Format$indent_spaces = (($n) => {
  return (c0Core$Cons)($n, c0Core$Nil);
});

const u0SPLib$Format$mapFirstLine = (($firstFn, $restFn, $b) => {
  return ((($b)[0] === "$Empty")
    ? u0SPLib$Format$Empty
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $breaks = ($b)[1];
        const $l1 = ($b)[2];
        return (u0SPLib$Format$SingleLine)($breaks, ($firstFn)($l1));
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $ls = ($b)[2];
          return (u0SPLib$Format$Stack)(($firstFn)($l1), (c0List$map)($restFn, $ls));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 245:4', (sp_toHuman)($b)))));
});

const u0SPLib$Format$stripEnd = (($l) => {
  return ((($l)[0] === "$Space")
    ? u0SPLib$Format$Blank
    : ((($l)[0] === "$Row")
      ? ((() => {
        const $r1 = ($l)[1];
        const $r2 = ($l)[2];
        const $2 = (u0SPLib$Format$stripEnd)($r2);
        return ((($2)[0] === "$Blank")
          ? (u0SPLib$Format$stripEnd)($r1)
          : (true
            ? ((() => {
              const $r2_ = $2;
              return (u0SPLib$Format$Row)($r1, $r2_);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 424:12', (sp_toHuman)($2))));
      }))()
      : (true
        ? $l
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 418:4', (sp_toHuman)($l)))));
});

const u0SPLib$Format$prefix = (($prefixLength, $pref, $blocks) => {
  const $padLineWithSpaces = (($4) => {
    const $i = ($4)[1];
    const $l = ($4)[2];
    return (u0SPLib$Format$Indented)((c0List$concat)((c0Core$Cons)((u0SPLib$Format$indent_spaces)($prefixLength), (c0Core$Cons)($i, c0Core$Nil))), $l);
  });
  const $addPrefixToLine = (($x) => {
    return ((($x)[0] === "$Blank")
      ? (u0SPLib$Format$stripEnd)($pref)
      : (true
        ? ((() => {
          const $l = $x;
          return (u0SPLib$Format$Row)($pref, $l);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 409:8', (sp_toHuman)($x))));
  });
  return (u0SPLib$Format$mapFirstLine)((($0) => {
    return (u0SPLib$Format$indent_map)($addPrefixToLine, $0);
  }), $padLineWithSpaces, $blocks);
});

const u0SPLib$Format$for1 = (($items, $f) => {
  return ((($items)[0] === "$Nil")
    ? (sp_todo)("for1 got an empty list....")
    : ((($items)[0] === "$Cons")
      ? ((() => {
        const $head = ($items)[1];
        const $tail = ($items)[2];
        return (c0List$for)($head, $tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 9:4', (sp_toHuman)($items))));
});

const u0SPLib$Format$mkIndentedLine = (($l) => {
  return ((($l)[0] === "$Space")
    ? (u0SPLib$Format$Indented)((u0SPLib$Format$indent_spaces)(1), u0SPLib$Format$Blank)
    : (((($l)[0] === "$Row") && ((($l)[1])[0] === "$Space"))
      ? ((() => {
        const $next = ($l)[2];
        const $2 = (u0SPLib$Format$mkIndentedLine)($next);
        const $rest_ = ($2)[2];
        const $i = ($2)[1];
        return (u0SPLib$Format$Indented)((c0List$concat)((c0Core$Cons)((u0SPLib$Format$indent_spaces)(1), (c0Core$Cons)($i, c0Core$Nil))), $rest_);
      }))()
      : (true
        ? ((() => {
          const $other = $l;
          return (u0SPLib$Format$Indented)(c0Core$Nil, $other);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 192:4', (sp_toHuman)($l)))));
});

const u0SPLib$Format$lineToBlock = (($x) => {
  return (u0SPLib$Format$SingleLine)(u0SPLib$Format$NoRequiredBreaks, (u0SPLib$Format$mkIndentedLine)($x));
});

const u0SPLib$Format$mustBreak = (($x) => {
  return (u0SPLib$Format$SingleLine)(u0SPLib$Format$MustBreakAtEnd, (u0SPLib$Format$mkIndentedLine)($x));
});

const u0SPLib$Format$maybeAllSingleLines = ((() => {
  const $rec = (($blocks, $reversedLines) => {
    return ((($blocks)[0] === "$Nil")
      ? (c0Maybe$Just)(({
        first: $reversedLines,
        second: u0SPLib$Format$lineToBlock,
      }))
      : ((($blocks)[0] === "$Cons")
        ? ((() => {
          const $block = ($blocks)[1];
          const $rest = ($blocks)[2];
          return (((($block)[0] === "$SingleLine") && (((($block)[1])[0] === "$NoRequiredBreaks") && ((($block)[2])[0] === "$Indented")))
            ? ((() => {
              const $l = (($block)[2])[2];
              return ($rec)($rest, (sp_cons)($l, $reversedLines));
            }))()
            : (((($block)[0] === "$SingleLine") && (((($block)[1])[0] === "$MustBreakAtEnd") && ((($block)[2])[0] === "$Indented")))
              ? ((() => {
                const $l = (($block)[2])[2];
                return ((sp_equal)($rest, c0Core$Nil)
                  ? (c0Maybe$Just)(({
                    first: (sp_cons)($l, $reversedLines),
                    second: u0SPLib$Format$mustBreak,
                  }))
                  : c0Maybe$Nothing);
              }))()
              : (true
                ? c0Maybe$Nothing
                : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 347:16', (sp_toHuman)($block)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 341:8', (sp_toHuman)($blocks))));
  });
  return (($0) => {
    return ($rec)($0, c0Core$Nil);
  });
}))();

const u0SPLib$Format$stack = ((() => {
  const $stackForce = (($b1, $b2) => {
    const $toLines = (($b) => {
      return ((($b)[0] === "$Empty")
        ? c0Core$Nil
        : ((($b)[0] === "$SingleLine")
          ? ((() => {
            const $l1 = ($b)[2];
            return (c0Core$Cons)($l1, c0Core$Nil);
          }))()
          : ((($b)[0] === "$Stack")
            ? ((() => {
              const $l1 = ($b)[1];
              const $rest = ($b)[2];
              return (sp_cons)($l1, $rest);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 213:12', (sp_toHuman)($b)))));
    });
    const $3 = ($toLines)($b1);
    return ((($3)[0] === "$Nil")
      ? $b2
      : ((($3)[0] === "$Cons")
        ? ((() => {
          const $line1first = ($3)[1];
          const $line1rest = ($3)[2];
          return (u0SPLib$Format$Stack)($line1first, (c0List$concat)((c0Core$Cons)($line1rest, (c0Core$Cons)(($toLines)($b2), c0Core$Nil))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 227:8', (sp_toHuman)($3))));
  });
  return (($bs) => {
    return ((sp_equal)($bs, c0Core$Nil)
      ? u0SPLib$Format$Empty
      : (u0SPLib$Format$for1)((c0List$reverse)($bs), $stackForce));
  });
}))();

const u0SPLib$Format$rowOrStackForce = (($forceMultiline, $joiner, $blocks) => {
  return (((($blocks)[0] === "$Cons") && ((($blocks)[2])[0] === "$Nil"))
    ? ((() => {
      const $single = ($blocks)[1];
      return $single;
    }))()
    : (true
      ? ($forceMultiline
        ? (u0SPLib$Format$stack)($blocks)
        : ((() => {
          const $4 = (u0SPLib$Format$maybeAllSingleLines)($blocks);
          return ((($4)[0] === "$Just")
            ? ((() => {
              const $lines = ($4)[1].first;
              const $mkLine = ($4)[1].second;
              return ($mkLine)(((($joiner)[0] === "$Nothing")
                ? (u0SPLib$Format$for1)($lines, u0SPLib$Format$Row)
                : ((($joiner)[0] === "$Just")
                  ? ((() => {
                    const $j = ($joiner)[1];
                    return (u0SPLib$Format$for1)((c0List$intersperse)($j, $lines), u0SPLib$Format$Row);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 294:24', (sp_toHuman)($joiner)))));
            }))()
            : (true
              ? (u0SPLib$Format$stack)($blocks)
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 291:16', (sp_toHuman)($4))));
        }))())
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 282:4', (sp_toHuman)($blocks))));
});

const u0SPLib$Format$rowOrStack = (($0, $1) => {
  return (u0SPLib$Format$rowOrStackForce)(false, $0, $1);
});

const u0SPLib$Format$textToBlock = (($f) => {
  return (u0SPLib$Format$lineToBlock)((u0SPLib$Format$Text_)($f));
});

const u0Human$Format$parens = (($block) => {
  return ((($0) => {
    return (u0SPLib$Format$rowOrStack)(c0Maybe$Nothing, $0);
  }))((c0Core$Cons)((u0SPLib$Format$prefix)(1, (u0SPLib$Format$Text_)("("), $block), (c0Core$Cons)((u0SPLib$Format$textToBlock)(")"), c0Core$Nil)));
});

const u0Human$Format$formatExpressionAndMaybeAddParens = (($env, $binopPrecedence, $expression) => {
  const $block = (u0Human$Format$formatExpression)($env, $expression);
  return (((u0Human$Format$expressionPrecedence)($expression) > $binopPrecedence)
    ? $block
    : (u0Human$Format$parens)($block));
});

const u0Human$Format$lineIsNonEmpty = (($s) => {
  return (sp_not_equal)((text_trimLeft)($s), "");
});

const u0Human$Format$unindentBlockComment = (($indent, $content) => {
  const $3 = (text_split)("\n", $content);
  return ((($3)[0] === "$Nil")
    ? c0Core$Nil
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $head = ($3)[1];
        const $tail = ($3)[2];
        const $getLeadingSpaces = (text_startsWithRegex)("[ ]*");
        const $countLeadingSpaces = (($l) => {
          return (text_length)(($getLeadingSpaces)($l));
        });
        const $minLead = ((($0) => {
          return (c0List$for)($indent, $0, (($line, $length) => {
            return (c0Basics$min)(($countLeadingSpaces)($line), $length);
          }));
        }))(((($0) => {
          return (c0List$filter)(u0Human$Format$lineIsNonEmpty, $0);
        }))($tail));
        return (sp_cons)($head, (c0List$map)((($0) => {
          return (text_dropLeft)($minLead, $0);
        }), $tail));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 249:4', (sp_toHuman)($3))));
});

const u0SPLib$Format$blankLine = (u0SPLib$Format$lineToBlock)(u0SPLib$Format$Blank);

const u0Human$Format$formatComment = (($env, $1) => {
  const $end = $1.end;
  const $indent = $1.indent;
  const $isBlock = $1.isBlock;
  const $isFollowedByBlank = $1.isFollowedByBlank;
  const $start = $1.start;
  const $content = (text_slice)($start, $end, $env.originalContent);
  const $blockOrBlank = (($text) => {
    return ((u0Human$Format$lineIsNonEmpty)($text)
      ? (u0SPLib$Format$lineToBlock)((u0SPLib$Format$CommentWithIndent)($text))
      : u0SPLib$Format$blankLine);
  });
  const $comment = ((sp_equal)($indent, 0)
    ? (u0SPLib$Format$stack)(((($0) => {
      return (c0List$map)((($l) => {
        return (u0SPLib$Format$lineToBlock)((u0SPLib$Format$CommentIgnoreIndent)($l));
      }), $0);
    }))(((($0) => {
      return (u0Human$Format$unindentBlockComment)($indent, $0);
    }))($content)))
    : ($isBlock
      ? (u0SPLib$Format$stack)(((($0) => {
        return (c0List$map)($blockOrBlank, $0);
      }))(((($0) => {
        return (u0Human$Format$unindentBlockComment)($indent, $0);
      }))($content)))
      : (u0SPLib$Format$lineToBlock)((u0SPLib$Format$CommentWithIndent)($content))));
  return ($isFollowedByBlank
    ? (u0SPLib$Format$stack)((c0Core$Cons)($comment, (c0Core$Cons)(u0SPLib$Format$blankLine, c0Core$Nil)))
    : $comment);
});

const u0Human$Format$formatComments = (($env, $comments) => {
  return (u0SPLib$Format$stack)(((($0) => {
    return (c0List$map)((($0) => {
      return (u0Human$Format$formatComment)($env, $0);
    }), $0);
  }))($comments));
});

const u0Human$Format$stackWithComments = (($env, $comments, $block) => {
  return ((sp_equal)($comments, c0Core$Nil)
    ? $block
    : (u0SPLib$Format$stack)((c0Core$Cons)((u0Human$Format$formatComments)($env, $comments), (c0Core$Cons)($block, c0Core$Nil))));
});

const u0SPLib$Format$space = u0SPLib$Format$Space;

const u0SPLib$Format$spaceSeparatedOrStackForce = (($force, $blocks) => {
  return (u0SPLib$Format$rowOrStackForce)($force, (c0Maybe$Just)(u0SPLib$Format$space), $blocks);
});

const u0Human$Format$formatBinopChain = (($env, $priority, $1) => {
  const $left = $1.first;
  const $opsAndRights = $1.second;
  const $formatOpAndRight = (($4) => {
    const $binop = $4.first;
    const $expr = $4.second;
    return ((($0) => {
      return (u0Human$Format$stackWithComments)($env, $binop.comments, $0);
    }))(((($0) => {
      return (u0SPLib$Format$prefix)(0, (u0SPLib$Format$Text_)(($binop.symbol + " ")), $0);
    }))((u0Human$Format$formatExpressionAndMaybeAddParens)($env, $binop.precedence, $expr)));
  });
  const $forceMultiline = ((($opsAndRights)[0] === "$Nil")
    ? false
    : ((($opsAndRights)[0] === "$Cons")
      ? ((() => {
        const $first = ($opsAndRights)[1].first;
        const $rest = ($opsAndRights)[2];
        const $last = (c0List$for)($first, $rest, (($5, $acc) => {
          const $opX = $5.first;
          return $opX;
        }));
        return ($last.line > $first.line);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 670:8', (sp_toHuman)($opsAndRights))));
  return ((($0) => {
    return (u0SPLib$Format$spaceSeparatedOrStackForce)($forceMultiline, $0);
  }))((c0Core$Cons)((u0Human$Format$formatExpressionAndMaybeAddParens)($env, (u0Human$Format$chainPrecedence)($opsAndRights), $left), (c0List$map)($formatOpAndRight, $opsAndRights)));
});

const u0Human$Format$extractComments = (($1) => {
  const $comments = ($1)[1];
  const $pos = ($1)[2];
  const $expr = ($1)[3];
  return ({
    first: (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $pos, $expr),
    second: $comments,
  });
});

const u0Human$Format$prefixToFirstNonBlank = (($prefix) => {
  return (($block) => {
    return ((($block)[0] === "$Empty")
      ? $block
      : ((($block)[0] === "$SingleLine")
        ? (u0SPLib$Format$prefix)((text_length)($prefix), (u0SPLib$Format$Text_)($prefix), $block)
        : ((($block)[0] === "$Stack")
          ? ((() => {
            const $head = ($block)[1];
            const $tail = ($block)[2];
            let $done = false;
            const $doLine = (($indentedLine) => {
              return (((__re__ = (basics_cloneUni)($done)), ($done = (__re__)[1]), (__re__)[0])
                ? $indentedLine
                : ((($indentedLine)[0] === "$Indented")
                  ? ((() => {
                    const $i = ($indentedLine)[1];
                    const $line = ($indentedLine)[2];
                    const $isDecoration = ((($line)[0] === "$CommentWithIndent")
                      ? true
                      : ((($line)[0] === "$CommentIgnoreIndent")
                        ? true
                        : ((($line)[0] === "$Blank")
                          ? true
                          : (true
                            ? false
                            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 36:32', (sp_toHuman)($line))))));
                    return ($isDecoration
                      ? $indentedLine
                      : ((() => {
                        ($done = true);
                        return ((($0) => {
                          return (u0SPLib$Format$Indented)($i, $0);
                        }))((u0SPLib$Format$Row)((u0SPLib$Format$Text_)($prefix), $line));
                      }))());
                  }))()
                  : (true
                    ? $indentedLine
                    : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 31:20', (sp_toHuman)($indentedLine)))));
            });
            const $3 = (c0List$reverse)(((($0) => {
              return (c0List$map)($doLine, $0);
            }))((c0List$reverse)((sp_cons)($head, $tail))));
            return ((($3)[0] === "$Nil")
              ? $block
              : ((($3)[0] === "$Cons")
                ? ((() => {
                  const $h = ($3)[1];
                  const $t = ($3)[2];
                  return (((__re__ = (basics_cloneUni)($done)), ($done = (__re__)[1]), (__re__)[0])
                    ? (u0SPLib$Format$Stack)($h, $t)
                    : (u0SPLib$Format$prefix)((text_length)($prefix), (u0SPLib$Format$Text_)($prefix), $block));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 52:12', (sp_toHuman)($3))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 14:4', (sp_toHuman)($block)))));
  });
});

const u0SPLib$Format$mapLastLine = (($lastFn, $b) => {
  return ((($b)[0] === "$Empty")
    ? u0SPLib$Format$Empty
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $breaks = ($b)[1];
        const $l1 = ($b)[2];
        return (u0SPLib$Format$SingleLine)($breaks, ($lastFn)($l1));
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $ls = ($b)[2];
          const $3 = (c0List$reverse)($ls);
          return ((($3)[0] === "$Cons")
            ? ((() => {
              const $last = ($3)[1];
              const $init = ($3)[2];
              return ((($0) => {
                return (u0SPLib$Format$Stack)($l1, $0);
              }))((c0List$reverse)((c0Core$Cons)(($lastFn)($last), $init)));
            }))()
            : (true
              ? (sp_todo)("what")
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 262:12', (sp_toHuman)($3))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 253:4', (sp_toHuman)($b)))));
});

const u0SPLib$Format$addSuffix = (($suffix, $block) => {
  return (u0SPLib$Format$mapLastLine)((($0) => {
    return (u0SPLib$Format$indent_map)((($0) => {
      return (u0SPLib$Format$Row)($0, $suffix);
    }), $0);
  }), $block);
});

const u0Human$Format$commaSeparatedList = (($forceMultiline, $open, $close, $closeHasAPrecedingSpace, $items) => {
  return ((sp_equal)($items, c0Core$Nil)
    ? (u0SPLib$Format$addSuffix)((u0SPLib$Format$Text_)($close), $open)
    : ((() => {
      const $z = ($forceMultiline
        ? c0Maybe$Nothing
        : ((($0) => {
          return (c0Maybe$map)((($0) => {
            return (c0Tuple$mapFirst)(c0List$reverse, $0);
          }), $0);
        }))((u0SPLib$Format$maybeAllSingleLines)((sp_cons)($open, $items))));
      return (((($z)[0] === "$Just") && ((($z)[1].first)[0] === "$Cons"))
        ? ((() => {
          const $openLine = (($z)[1].first)[1];
          const $itemLines = (($z)[1].first)[2];
          const $mkLine = ($z)[1].second;
          const $closeLine = ($closeHasAPrecedingSpace
            ? (u0SPLib$Format$Row)(u0SPLib$Format$Space, (u0SPLib$Format$Text_)($close))
            : (u0SPLib$Format$Text_)($close));
          return ((($0) => {
            return (u0SPLib$Format$addSuffix)($closeLine, $0);
          }))(($mkLine)(((($0) => {
            return (c0List$for)((u0SPLib$Format$Row)($openLine, u0SPLib$Format$Space), $0, (($a, $b) => {
              return (u0SPLib$Format$Row)($b, $a);
            }));
          }))(((($0) => {
            return (c0List$intersperse)((u0SPLib$Format$Text_)(", "), $0);
          }))($itemLines))));
        }))()
        : ((($z)[0] === "$Nothing")
          ? (u0SPLib$Format$stack)((c0List$concat)((c0Core$Cons)((c0Core$Cons)($open, c0Core$Nil), (c0Core$Cons)((c0List$map)((u0Human$Format$prefixToFirstNonBlank)(", "), $items), (c0Core$Cons)((c0Core$Cons)((u0SPLib$Format$textToBlock)($close), c0Core$Nil), c0Core$Nil)))))
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 77:8', (sp_toHuman)($z))));
    }))());
});

const u0Human$Format$formatFunctionHeader = (($env, $pars) => {
  return ((($0) => {
    return (u0Human$Format$commaSeparatedList)(false, (u0SPLib$Format$textToBlock)("fn"), ":", false, $0);
  }))(((($0) => {
    return (c0List$map)((($0) => {
      return (u0Human$Format$formatExpression)($env, $0);
    }), $0);
  }))($pars));
});

const u0SPLib$Format$spacesInTab = 4;

const u0SPLib$Format$indent_tab = (c0Core$Cons)(u0SPLib$Format$spacesInTab, c0Core$Nil);

const u0SPLib$Format$mapLines = (($f, $b) => {
  return (u0SPLib$Format$mapFirstLine)($f, $f, $b);
});

const u0SPLib$Format$indent = (($0) => {
  return (u0SPLib$Format$mapLines)((($2) => {
    const $i = ($2)[1];
    const $l = ($2)[2];
    return (u0SPLib$Format$Indented)((c0List$concat)((c0Core$Cons)(u0SPLib$Format$indent_tab, (c0Core$Cons)($i, c0Core$Nil))), $l);
  }), $0);
});

const u0SPLib$Format$rowOrIndentForce = (($forceMultiline, $joiner, $blocks) => {
  return ((($blocks)[0] === "$Nil")
    ? (sp_todo)("blocks is supposed to be NonEmpty")
    : (((($blocks)[0] === "$Cons") && ((($blocks)[2])[0] === "$Nil"))
      ? ((() => {
        const $single = ($blocks)[1];
        return $single;
      }))()
      : ((($blocks)[0] === "$Cons")
        ? ((() => {
          const $b1 = ($blocks)[1];
          const $rest = ($blocks)[2];
          const $4 = (u0SPLib$Format$maybeAllSingleLines)($blocks);
          return ((($4)[0] === "$Just")
            ? ((() => {
              const $reversedLines = ($4)[1].first;
              const $mkLine = ($4)[1].second;
              return ($forceMultiline
                ? (u0SPLib$Format$stack)((sp_cons)($b1, (c0List$map)(u0SPLib$Format$indent, $rest)))
                : ($mkLine)(((($joiner)[0] === "$Nothing")
                  ? (u0SPLib$Format$for1)($reversedLines, u0SPLib$Format$Row)
                  : ((($joiner)[0] === "$Just")
                    ? ((() => {
                      const $j = ($joiner)[1];
                      return (u0SPLib$Format$for1)((c0List$intersperse)($j, $reversedLines), u0SPLib$Format$Row);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 328:24', (sp_toHuman)($joiner))))));
            }))()
            : (true
              ? (u0SPLib$Format$stack)((sp_cons)($b1, (c0List$map)(u0SPLib$Format$indent, $rest)))
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 321:12', (sp_toHuman)($4))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 312:4', (sp_toHuman)($blocks)))));
});

const u0SPLib$Format$rowOrIndent = (($0, $1) => {
  return (u0SPLib$Format$rowOrIndentForce)(false, $0, $1);
});

const u0SPLib$Format$spaceSeparatedOrIndent = (($0) => {
  return (u0SPLib$Format$rowOrIndent)((c0Maybe$Just)(u0SPLib$Format$space), $0);
});

const u0Human$Format$formatCall = (($env, $ref, $args) => {
  const $lastIndex = ((c0List$length)($args) - 1);
  const $asContinuingFn = (($index, $arg) => {
    return (((($arg)[0] === "$Expression") && ((($arg)[3])[0] === "$Fn"))
      ? ((() => {
        const $layout = (($arg)[3])[1];
        const $params = (($arg)[3])[2];
        const $body = (($arg)[3])[3];
        return (((sp_equal)($index, $lastIndex) && (sp_not_equal)($layout, c0Compiler$FormattableAst$Inline))
          ? (c0Maybe$Just)(({
            first: $layout,
            second: $params,
            third: $body,
          }))
          : c0Maybe$Nothing);
      }))()
      : (true
        ? c0Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 696:8', (sp_toHuman)($arg))));
  });
  const $formatArgument = (($index, $arg) => {
    let $6 = ($asContinuingFn)($index, $arg);
    return ((($6)[0] === "$Nothing")
      ? (u0Human$Format$formatExpressionAndMaybeAddParens)($env, c0Compiler$Op$precedence_application, $arg)
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $layout = ($6)[1].first;
          const $params = ($6)[1].second;
          const $body = ($6)[1].third;
          return (u0Human$Format$formatFunctionHeader)($env, $params);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 709:8', (sp_toHuman)($6))));
  });
  const $maybeContinuing = ((c0Maybe$onJust)((($0) => {
    return ($asContinuingFn)($lastIndex, $0);
  })))((c0List$last)($args));
  const $4 = (u0Human$Format$extractComments)($ref);
  const $refComments = $4.second;
  const $refNoComments = $4.first;
  const $call = (u0SPLib$Format$spaceSeparatedOrIndent)((c0Core$Cons)((u0Human$Format$formatExpressionAndMaybeAddParens)($env, c0Compiler$Op$precedence_application, $refNoComments), (c0List$indexedMap)($formatArgument, $args)));
  return ((($0) => {
    return (u0Human$Format$stackWithComments)($env, $refComments, $0);
  }))(((($maybeContinuing)[0] === "$Nothing")
    ? $call
    : ((($maybeContinuing)[0] === "$Just")
      ? ((() => {
        const $layout = ($maybeContinuing)[1].first;
        const $params = ($maybeContinuing)[1].second;
        const $body = ($maybeContinuing)[1].third;
        return (u0SPLib$Format$stack)((c0Core$Cons)($call, (c0Core$Cons)(((c0Basics$applyIf)((sp_equal)($layout, c0Compiler$FormattableAst$Indented), u0SPLib$Format$indent))((u0Human$Format$formatExpression)($env, $body)), c0Core$Nil)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 728:4', (sp_toHuman)($maybeContinuing)))));
});

const u0Human$Format$formatConstructor = (($env, $maybeModule, $name) => {
  return (u0SPLib$Format$textToBlock)(((($0) => {
    return (c0Text$join)("", $0);
  }))((c0List$concat)((c0Core$Cons)(((($maybeModule)[0] === "$Nothing")
    ? c0Core$Nil
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return (c0Core$Cons)($module, (c0Core$Cons)(".", c0Core$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 601:10', (sp_toHuman)($maybeModule)))), (c0Core$Cons)((c0Core$Cons)($name, c0Core$Nil), c0Core$Nil)))));
});

const u0Human$Format$formatFunction = (($env, $layout, $pars, $body) => {
  const $forceStack = (sp_not_equal)($layout, c0Compiler$FormattableAst$Inline);
  return ((($0) => {
    return (u0SPLib$Format$spaceSeparatedOrStackForce)($forceStack, $0);
  }))((c0Core$Cons)((u0Human$Format$formatFunctionHeader)($env, $pars), (c0Core$Cons)(((c0Basics$applyIf)((sp_equal)($layout, c0Compiler$FormattableAst$Indented), u0SPLib$Format$indent))((u0Human$Format$formatExpression)($env, $body)), c0Core$Nil)));
});

const u0Human$Format$extractIfElses = (($env, $x) => {
  const $rec = (($acc, $expr) => {
    return (((($expr)[0] === "$Expression") && ((($expr)[3])[0] === "$If"))
      ? ((() => {
        const $comments = ($expr)[1];
        const $args = (($expr)[3])[1];
        return ($rec)((c0Core$Cons)(({
          first: $comments,
          second: (u0Human$Format$formatExpression)($env, $args.condition),
          third: (u0Human$Format$formatExpression)($env, $args.true),
        }), $acc), $args.false);
      }))()
      : (true
        ? ({
          first: (c0List$reverse)($acc),
          second: (u0Human$Format$formatExpression)($env, $expr),
        })
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 746:8', (sp_toHuman)($expr))));
  });
  return ($rec)(c0Core$Nil, $x);
});

const u0SPLib$Format$blockAsLine = (($b) => {
  return (((($b)[0] === "$SingleLine") && ((($b)[2])[0] === "$Indented"))
    ? ((() => {
      const $l = (($b)[2])[2];
      return (c0Maybe$Just)($l);
    }))()
    : (true
      ? c0Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 163:4', (sp_toHuman)($b))));
});

const u0SPLib$Format$spaceSeparatedOrStack = (($0) => {
  return (u0SPLib$Format$rowOrStack)((c0Maybe$Just)(u0SPLib$Format$space), $0);
});

const u0Human$Format$formatIf = (($env, $isMultiline, $expr) => {
  const $4 = (u0Human$Format$extractIfElses)($env, $expr);
  const $default = $4.second;
  const $conditionsAndValues = $4.first;
  const $maybeSingleLine = ($isMultiline
    ? c0Maybe$Nothing
    : (((($conditionsAndValues)[0] === "$Cons") && (((($conditionsAndValues)[1].first)[0] === "$Nil") && ((($conditionsAndValues)[2])[0] === "$Nil")))
      ? ((() => {
        const $condition = ($conditionsAndValues)[1].second;
        const $valueIfTrue = ($conditionsAndValues)[1].third;
        const $l = u0SPLib$Format$blockAsLine;
        const $5 = ({
          first: ($l)($condition),
          second: ($l)($valueIfTrue),
          third: ($l)($default),
        });
        return (((($5.first)[0] === "$Just") && ((($5.second)[0] === "$Just") && (($5.third)[0] === "$Just")))
          ? ((() => {
            const $conditionLine = ($5.first)[1];
            const $trueLine = ($5.second)[1];
            const $falseLine = ($5.third)[1];
            return (c0Maybe$Just)(({
              first: $conditionLine,
              second: $trueLine,
              third: $falseLine,
            }));
          }))()
          : (true
            ? c0Maybe$Nothing
            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 768:20', (sp_toHuman)($5))));
      }))()
      : (true
        ? c0Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 762:12', (sp_toHuman)($conditionsAndValues)))));
  return ((($maybeSingleLine)[0] === "$Just")
    ? ((() => {
      const $conditionLine = ($maybeSingleLine)[1].first;
      const $trueLine = ($maybeSingleLine)[1].second;
      const $falseLine = ($maybeSingleLine)[1].third;
      return (u0SPLib$Format$lineToBlock)(((($0) => {
        return (u0SPLib$Format$for1)($0, (($item, $acc) => {
          return (u0SPLib$Format$Row)($acc, $item);
        }));
      }))(((($0) => {
        return (c0List$intersperse)(u0SPLib$Format$Space, $0);
      }))((c0Core$Cons)((u0SPLib$Format$Text_)("if"), (c0Core$Cons)($conditionLine, (c0Core$Cons)((u0SPLib$Format$Text_)("then"), (c0Core$Cons)($trueLine, (c0Core$Cons)((u0SPLib$Format$Text_)("else"), (c0Core$Cons)($falseLine, c0Core$Nil)))))))));
    }))()
    : ((($maybeSingleLine)[0] === "$Nothing")
      ? ((() => {
        const $formatCAndV = (($index, $5) => {
          const $comments = $5.first;
          const $condition = $5.second;
          const $value = $5.third;
          return (u0SPLib$Format$stack)((c0Core$Cons)(((($0) => {
            return (u0Human$Format$stackWithComments)($env, $comments, $0);
          }))((u0SPLib$Format$spaceSeparatedOrStack)((c0Core$Cons)(((sp_equal)($index, 0)
            ? (u0SPLib$Format$textToBlock)("if")
            : (u0SPLib$Format$textToBlock)("else if")), (c0Core$Cons)($condition, (c0Core$Cons)((u0SPLib$Format$textToBlock)("then"), c0Core$Nil))))), (c0Core$Cons)((u0SPLib$Format$indent)($value), c0Core$Nil)));
        });
        return (u0SPLib$Format$stack)((c0Core$Cons)((u0SPLib$Format$stack)(((($0) => {
          return (c0List$indexedMap)($formatCAndV, $0);
        }))($conditionsAndValues)), (c0Core$Cons)((u0SPLib$Format$textToBlock)("else"), (c0Core$Cons)((u0SPLib$Format$indent)($default), c0Core$Nil))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 775:4', (sp_toHuman)($maybeSingleLine))));
});

const u0Human$Format$formatList = (($env, $isMultiline, $unpacksAndExprs) => {
  const $formatListItem = (($4) => {
    const $isUnpacked = $4.first;
    const $expr = $4.second;
    return ($isUnpacked
      ? ((($0) => {
        return (u0SPLib$Format$addSuffix)((u0SPLib$Format$Text_)("..."), $0);
      }))(((($0) => {
        return (u0Human$Format$formatExpression)($env, $0);
      }))($expr))
      : (u0Human$Format$formatExpression)($env, $expr));
  });
  return ((($0) => {
    return (u0Human$Format$commaSeparatedList)($isMultiline, (u0SPLib$Format$textToBlock)("["), "]", true, $0);
  }))(((($0) => {
    return (c0List$map)($formatListItem, $0);
  }))($unpacksAndExprs));
});

const u0Human$Format$formatLiteralNumber = (($hasPercentage, $numberAsText) => {
  return ($hasPercentage
    ? (u0SPLib$Format$textToBlock)(($numberAsText + "%"))
    : (u0SPLib$Format$textToBlock)($numberAsText));
});

const u0Human$Format$formatLiteralText = ((() => {
  const $singleQuote = "\"";
  const $tripleQuote = (u0SPLib$Format$textToBlock)("\"\"\"");
  return (($singleOrTriple, $text) => {
    return ((($singleOrTriple)[0] === "$SingleQuote")
      ? (u0SPLib$Format$textToBlock)(($singleQuote + ($text + $singleQuote)))
      : ((($singleOrTriple)[0] === "$TripleQuote")
        ? ((() => {
          const $rows = ((($0) => {
            return (c0List$map)(u0SPLib$Format$textToBlock, $0);
          }))(((($0) => {
            return (text_split)("\n", $0);
          }))($text));
          return (u0SPLib$Format$stack)((c0List$concat)((c0Core$Cons)((c0Core$Cons)($tripleQuote, c0Core$Nil), (c0Core$Cons)($rows, (c0Core$Cons)((c0Core$Cons)($tripleQuote, c0Core$Nil), c0Core$Nil)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 336:4', (sp_toHuman)($singleOrTriple))));
  });
}))();

const u0Human$Format$formatLowercase = (($env, $maybeType, $maybeModule, $name, $attrPath) => {
  const $word = (u0SPLib$Format$textToBlock)(((($0) => {
    return (c0Text$join)("", $0);
  }))((c0List$concat)((c0Core$Cons)(((($maybeModule)[0] === "$Nothing")
    ? c0Core$Nil
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return (c0Core$Cons)($module, (c0Core$Cons)(".", c0Core$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 562:10', (sp_toHuman)($maybeModule)))), (c0Core$Cons)((c0Core$Cons)($name, c0Core$Nil), (c0Core$Cons)((c0List$map)((($p) => {
    return ("." + $p);
  }), $attrPath), c0Core$Nil))))));
  return ((($maybeType)[0] === "$Nothing")
    ? $word
    : ((($maybeType)[0] === "$Just")
      ? ((() => {
        const $type = ($maybeType)[1];
        return ((($0) => {
          return (u0SPLib$Format$spaceSeparatedOrIndent)($0);
        }))((c0Core$Cons)((u0SPLib$Format$addSuffix)((u0SPLib$Format$Text_)(" as"), $word), (c0Core$Cons)((u0Human$Format$formatExpression)($env, $type), c0Core$Nil)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 572:4', (sp_toHuman)($maybeType))));
});

const u0Human$Format$formatRecord = (($env, $isMultiline, $maybeMaybeExt, $attrs) => {
  const $open = ((($maybeMaybeExt)[0] === "$Nothing")
    ? (u0SPLib$Format$textToBlock)("{")
    : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Nothing"))
      ? (u0SPLib$Format$textToBlock)("{ with ")
      : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Just"))
        ? ((() => {
          const $ext = (($maybeMaybeExt)[1])[1];
          return ((($0) => {
            return (u0SPLib$Format$addSuffix)((u0SPLib$Format$Text_)(" with"), $0);
          }))(((($0) => {
            return (u0SPLib$Format$prefix)(1, (u0SPLib$Format$Text_)("{ "), $0);
          }))(((($0) => {
            return (u0Human$Format$formatExpression)($env, $0);
          }))($ext)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 498:8', (sp_toHuman)($maybeMaybeExt)))));
  const $formatRecordAttribute = (($5) => {
    const $maybeExpr = $5.maybeExpr;
    const $name = $5.name;
    return ((($maybeExpr)[0] === "$Nothing")
      ? (u0Human$Format$formatExpression)($env, $name)
      : ((($maybeExpr)[0] === "$Just")
        ? ((() => {
          const $expr = ($maybeExpr)[1];
          return ((($0) => {
            return (u0SPLib$Format$rowOrIndent)((c0Maybe$Just)(u0SPLib$Format$Space), $0);
          }))((c0Core$Cons)(((($0) => {
            return (u0SPLib$Format$addSuffix)((u0SPLib$Format$Text_)(" ="), $0);
          }))((u0Human$Format$formatExpression)($env, $name)), (c0Core$Cons)((u0Human$Format$formatExpression)($env, $expr), c0Core$Nil)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 514:8', (sp_toHuman)($maybeExpr))));
  });
  const $attributeName = (($nameExpr) => {
    const $6 = $nameExpr.name;
    return (((($6)[0] === "$Expression") && ((($6)[3])[0] === "$Lowercase"))
      ? ((() => {
        const $name = (($6)[3])[1].name;
        return $name;
      }))()
      : (true
        ? ""
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 528:8', (sp_toHuman)($6))));
  });
  return ((($0) => {
    return (u0Human$Format$commaSeparatedList)($isMultiline, $open, "}", true, $0);
  }))(((($0) => {
    return (c0List$map)($formatRecordAttribute, $0);
  }))(((($0) => {
    return (list_sortBy)($attributeName, $0);
  }))($attrs)));
});

const u0Human$Format$formatRecordShorthand = (($env, $name, $attrPath) => {
  return (u0SPLib$Format$textToBlock)(((($0) => {
    return (c0Text$join)("", $0);
  }))((c0List$map)((($p) => {
    return ("." + $p);
  }), (sp_cons)($name, $attrPath))));
});

const u0Human$Format$formatFaWord = (($1) => {
  const $pos = $1.first;
  const $name = $1.second;
  return (u0SPLib$Format$textToBlock)($name);
});

const u0Human$Format$formatDef = (($maybeKeyword, $name, $args) => {
  const $formattedArgs = ((sp_equal)($args, c0Core$Nil)
    ? c0Maybe$Nothing
    : (c0Maybe$Just)((u0SPLib$Format$spaceSeparatedOrIndent)(((($0) => {
      return (c0List$map)(u0Human$Format$formatFaWord, $0);
    }))($args))));
  return (u0SPLib$Format$spaceSeparatedOrIndent)(((($0) => {
    return (c0List$filterMap)(c0Basics$identity, $0);
  }))((c0Core$Cons)((c0Maybe$map)(u0SPLib$Format$textToBlock, $maybeKeyword), (c0Core$Cons)((c0Maybe$Just)((u0Human$Format$formatFaWord)($name)), (c0Core$Cons)($formattedArgs, (c0Core$Cons)((c0Maybe$Just)((u0SPLib$Format$textToBlock)("=")), c0Core$Nil))))));
});

const u0Human$Format$formatAliasDef = (($env, $1) => {
  const $args = $1.args;
  const $name = $1.name;
  const $type = $1.type;
  return (u0SPLib$Format$stack)((c0Core$Cons)((u0Human$Format$formatDef)(c0Maybe$Nothing, $name, $args), (c0Core$Cons)((u0SPLib$Format$indent)((u0Human$Format$formatExpression)($env, $type)), c0Core$Nil)));
});

const u0Human$Format$formatUnionDef = (($env, $1) => {
  const $args = $1.args;
  const $constructors = $1.constructors;
  const $name = $1.name;
  return (u0SPLib$Format$stack)((c0Core$Cons)((u0Human$Format$formatDef)((c0Maybe$Just)("var"), $name, $args), (c0Core$Cons)((u0SPLib$Format$indent)((u0SPLib$Format$stack)(((($0) => {
    return (c0List$map)((($c) => {
      return (u0SPLib$Format$prefix)(2, (u0SPLib$Format$Text_)(", "), (u0Human$Format$formatExpression)($env, $c));
    }), $0);
  }))($constructors))), c0Core$Nil)));
});

const u0Human$Format$formatNonFn = (($words) => {
  return ((($0) => {
    return (u0Human$Format$commaSeparatedList)(false, (u0SPLib$Format$textToBlock)("with"), "NonFunction", true, $0);
  }))(((($0) => {
    return (c0List$map)((($3) => {
      const $pos = $3.first;
      const $name = $3.second;
      return (u0SPLib$Format$textToBlock)($name);
    }), $0);
  }))($words));
});

const u0Human$Format$formatValueDef = (($env, $1) => {
  const $body = $1.body;
  const $nonFn = $1.nonFn;
  const $pattern = $1.pattern;
  return (u0SPLib$Format$stack)((c0Core$Cons)((u0SPLib$Format$spaceSeparatedOrIndent)((c0List$concat)((c0Core$Cons)((c0Core$Cons)((u0Human$Format$formatExpression)($env, $pattern), c0Core$Nil), (c0Core$Cons)(((sp_equal)($nonFn, c0Core$Nil)
    ? c0Core$Nil
    : (c0Core$Cons)((u0Human$Format$formatNonFn)($nonFn), c0Core$Nil)), (c0Core$Cons)((c0Core$Cons)((u0SPLib$Format$textToBlock)("="), c0Core$Nil), c0Core$Nil))))), (c0Core$Cons)((u0SPLib$Format$indent)((u0Human$Format$formatExpression)($env, $body)), c0Core$Nil)));
});

const u0Human$Format$formatStatement = (($env, $stat) => {
  return ((($stat)[0] === "$CommentStatement")
    ? ((() => {
      const $comment = ($stat)[1];
      return (u0Human$Format$formatComment)($env, $comment);
    }))()
    : ((($stat)[0] === "$Evaluation")
      ? ((() => {
        const $expression = ($stat)[1];
        return (u0Human$Format$formatExpression)($env, $expression);
      }))()
      : ((($stat)[0] === "$ValueDef")
        ? ((() => {
          const $valueDef = ($stat)[1];
          return (u0Human$Format$formatValueDef)($env, $valueDef);
        }))()
        : ((($stat)[0] === "$AliasDef")
          ? ((() => {
            const $aliasDef = ($stat)[1];
            return (u0Human$Format$formatAliasDef)($env, $aliasDef);
          }))()
          : ((($stat)[0] === "$UnionDef")
            ? ((() => {
              const $unionDef = ($stat)[1];
              return (u0Human$Format$formatUnionDef)($env, $unionDef);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 407:4', (sp_toHuman)($stat)))))));
});

const u0Human$Format$formatStatements = (($env, $sss) => {
  const $rec = (($maybePrevious, $stats, $acc) => {
    return ((($stats)[0] === "$Nil")
      ? (c0List$reverse)($acc)
      : ((($stats)[0] === "$Cons")
        ? ((() => {
          const $head = ($stats)[1];
          const $tail = ($stats)[2];
          return ((($0) => {
            return ($rec)((c0Maybe$Just)($head), $tail, $0);
          }))(((($0) => {
            return (sp_cons)((u0Human$Format$formatStatement)(((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                isRoot: false,
              }));
            }))(), $head), $0);
          }))(((($maybePrevious)[0] === "$Nothing")
            ? $acc
            : (((($maybePrevious)[0] === "$Just") && ((($maybePrevious)[1])[0] === "$CommentStatement"))
              ? $acc
              : ((($maybePrevious)[0] === "$Just")
                ? ($env.isRoot
                  ? (sp_cons)(u0SPLib$Format$blankLine, (sp_cons)(u0SPLib$Format$blankLine, $acc))
                  : (sp_cons)(u0SPLib$Format$blankLine, $acc))
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 386:16', (sp_toHuman)($maybePrevious)))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 380:8', (sp_toHuman)($stats))));
  });
  return (u0SPLib$Format$stack)(($rec)(c0Maybe$Nothing, $sss, c0Core$Nil));
});

const u0Human$Format$formatTry = (($env, $value, $patterns) => {
  const $formatted = (c0List$map)((($4) => {
    const $pattern = $4.first;
    const $block = $4.second;
    return ({
      first: (u0Human$Format$formatExpression)($env, $pattern),
      second: (u0Human$Format$formatExpression)($env, $block),
    });
  }), $patterns);
  const $tryOneLine = (($4) => {
    const $pa = $4.first;
    const $bl = $4.second;
    return ((c0Result$onOk)((($paLine) => {
      return ((c0Result$onOk)((($blockLine) => {
        return (c0Result$Ok)(({
          first: $paLine,
          second: $blockLine,
        }));
      })))(((($0) => {
        return (c0Maybe$toResult)(null, $0);
      }))((u0SPLib$Format$blockAsLine)($bl)));
    })))(((($0) => {
      return (c0Maybe$toResult)(null, $0);
    }))((u0SPLib$Format$blockAsLine)($pa)));
  });
  const $blocks = ((() => {
    const $4 = (c0List$mapRes)($tryOneLine, $formatted);
    return ((($4)[0] === "$Ok")
      ? ((() => {
        const $lines = ($4)[1];
        const $formatInline = (($5) => {
          const $paLine = $5.first;
          const $blockLine = $5.second;
          return (u0SPLib$Format$lineToBlock)((u0SPLib$Format$Row)($paLine, (u0SPLib$Format$Row)((u0SPLib$Format$Text_)(": "), $blockLine)));
        });
        return (c0List$map)($formatInline, $lines);
      }))()
      : ((($4)[0] === "$Err")
        ? ((() => {
          const $formatIndented = (($5) => {
            const $paBlock = $5.first;
            const $blockBlock = $5.second;
            return (u0SPLib$Format$stack)((c0Core$Cons)(u0SPLib$Format$blankLine, (c0Core$Cons)(((($0) => {
              return (u0SPLib$Format$addSuffix)((u0SPLib$Format$Text_)(":"), $0);
            }))($paBlock), (c0Core$Cons)((u0SPLib$Format$indent)($blockBlock), c0Core$Nil))));
          });
          return (c0List$map)($formatIndented, $formatted);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 831:8', (sp_toHuman)($4))));
  }))();
  return (u0SPLib$Format$stack)((c0Core$Cons)((u0SPLib$Format$spaceSeparatedOrIndent)((c0Core$Cons)((u0SPLib$Format$textToBlock)("try"), (c0Core$Cons)((u0Human$Format$formatExpression)($env, $value), (c0Core$Cons)((u0SPLib$Format$textToBlock)("as"), c0Core$Nil)))), (c0Core$Cons)((u0SPLib$Format$indent)((u0SPLib$Format$stack)($blocks)), c0Core$Nil)));
});

const u0Human$Format$unopToText = (($unopId) => {
  return ((($unopId)[0] === "$UnopPlus")
    ? "+"
    : ((($unopId)[0] === "$UnopMinus")
      ? "-"
      : ((($unopId)[0] === "$UnopUnique")
        ? "!"
        : ((($unopId)[0] === "$UnopRecycle")
          ? "@"
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 639:4', (sp_toHuman)($unopId))))));
});

const u0Human$Format$formatUnopCall = (($env, $unopId, $expr) => {
  const $unop = (u0Human$Format$unopToText)($unopId);
  return ((($0) => {
    return (u0SPLib$Format$prefix)((text_length)($unop), (u0SPLib$Format$Text_)($unop), $0);
  }))(((($0) => {
    return (u0Human$Format$formatExpression)($env, $0);
  }))($expr));
});

const u0Human$Format$formatUppercase = (($env, $maybeModule, $name) => {
  return (u0SPLib$Format$textToBlock)(((($0) => {
    return (c0Text$join)("", $0);
  }))((c0List$concat)((c0Core$Cons)(((($maybeModule)[0] === "$Nothing")
    ? c0Core$Nil
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return (c0Core$Cons)($module, (c0Core$Cons)(".", c0Core$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 588:10', (sp_toHuman)($maybeModule)))), (c0Core$Cons)((c0Core$Cons)($name, c0Core$Nil), c0Core$Nil)))));
});

const u0Human$Format$formatExpression = (($env, $faExpression) => {
  const $3 = $faExpression;
  const $e_ = ($3)[3];
  const $comments = ($3)[1];
  return ((($0) => {
    return (u0Human$Format$stackWithComments)($env, $comments, $0);
  }))(((($e_)[0] === "$LiteralText")
    ? ((() => {
      const $singleOrTriple = ($e_)[1];
      const $text = ($e_)[2];
      return (u0Human$Format$formatLiteralText)($singleOrTriple, $text);
    }))()
    : ((($e_)[0] === "$LiteralNumber")
      ? ((() => {
        const $hasPercentage = ($e_)[1];
        const $text = ($e_)[2];
        return (u0Human$Format$formatLiteralNumber)($hasPercentage, $text);
      }))()
      : ((($e_)[0] === "$ArgumentPlaceholder")
        ? (u0SPLib$Format$textToBlock)("__")
        : ((($e_)[0] === "$Statements")
          ? ((() => {
            const $stats = ($e_)[1];
            return (u0Human$Format$formatStatements)($env, $stats);
          }))()
          : ((($e_)[0] === "$List")
            ? ((() => {
              const $isMultiline = ($e_)[1];
              const $unpacksAndExprs = ($e_)[2];
              return (u0Human$Format$formatList)($env, $isMultiline, $unpacksAndExprs);
            }))()
            : ((($e_)[0] === "$Record")
              ? ((() => {
                const $attrs = ($e_)[1].attrs;
                const $isMultiline = ($e_)[1].isMultiline;
                const $maybeExtension = ($e_)[1].maybeExtension;
                return (u0Human$Format$formatRecord)($env, $isMultiline, $maybeExtension, $attrs);
              }))()
              : ((($e_)[0] === "$Lowercase")
                ? ((() => {
                  const $attrPath = ($e_)[1].attrPath;
                  const $maybeModule = ($e_)[1].maybeModule;
                  const $maybeType = ($e_)[1].maybeType;
                  const $name = ($e_)[1].name;
                  return (u0Human$Format$formatLowercase)($env, $maybeType, $maybeModule, $name, $attrPath);
                }))()
                : ((($e_)[0] === "$Uppercase")
                  ? ((() => {
                    const $maybeModule = ($e_)[1].maybeModule;
                    const $name = ($e_)[1].name;
                    return (u0Human$Format$formatUppercase)($env, $maybeModule, $name);
                  }))()
                  : ((($e_)[0] === "$Constructor")
                    ? ((() => {
                      const $maybeModule = ($e_)[1].maybeModule;
                      const $name = ($e_)[1].name;
                      return (u0Human$Format$formatConstructor)($env, $maybeModule, $name);
                    }))()
                    : ((($e_)[0] === "$RecordShorthand")
                      ? ((() => {
                        const $attrPath = ($e_)[1].attrPath;
                        const $name = ($e_)[1].name;
                        return (u0Human$Format$formatRecordShorthand)($env, $name, $attrPath);
                      }))()
                      : ((($e_)[0] === "$Fn")
                        ? ((() => {
                          const $layout = ($e_)[1];
                          const $pars = ($e_)[2];
                          const $body = ($e_)[3];
                          return (u0Human$Format$formatFunction)($env, $layout, $pars, $body);
                        }))()
                        : ((($e_)[0] === "$UnopCall")
                          ? ((() => {
                            const $unopId = ($e_)[1];
                            const $expr = ($e_)[2];
                            return (u0Human$Format$formatUnopCall)($env, $unopId, $expr);
                          }))()
                          : ((($e_)[0] === "$BinopChain")
                            ? ((() => {
                              const $priority = ($e_)[1];
                              const $binopChain = ($e_)[2];
                              return (u0Human$Format$formatBinopChain)($env, $priority, $binopChain);
                            }))()
                            : ((($e_)[0] === "$Call")
                              ? ((() => {
                                const $ref = ($e_)[1];
                                const $args = ($e_)[2];
                                return (u0Human$Format$formatCall)($env, $ref, $args);
                              }))()
                              : ((($e_)[0] === "$Poly")
                                ? ((() => {
                                  const $text = ($e_)[1];
                                  const $expression = ($e_)[2];
                                  const $prefix = ($text + "?");
                                  return ((($0) => {
                                    return (u0SPLib$Format$prefix)((text_length)($prefix), (u0SPLib$Format$Text_)($prefix), $0);
                                  }))(((($0) => {
                                    return (u0Human$Format$formatExpression)($env, $0);
                                  }))($expression));
                                }))()
                                : ((($e_)[0] === "$If")
                                  ? ((() => {
                                    const $condition = ($e_)[1].condition;
                                    const $false = ($e_)[1].false;
                                    const $isMultiline = ($e_)[1].isMultiline;
                                    const $true = ($e_)[1].true;
                                    return (u0Human$Format$formatIf)($env, $isMultiline, $faExpression);
                                  }))()
                                  : ((($e_)[0] === "$Try")
                                    ? ((() => {
                                      const $patterns = ($e_)[1].patterns;
                                      const $value = ($e_)[1].value;
                                      return (u0Human$Format$formatTry)($env, $value, $patterns);
                                    }))()
                                    : ((($e_)[0] === "$Native")
                                      ? (u0SPLib$Format$textToBlock)("this_is_sp_native")
                                      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 176:4', (sp_toHuman)($e_)))))))))))))))))))));
});

const u0Human$Type$toExpression = (($0) => {
  return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, c0Compiler$Pos$G, $0);
});

const u0Human$Type$uniToText = (($projectImports, $uni) => {
  return ((($uni)[0] === "$Imm")
    ? ""
    : ((($uni)[0] === "$Uni")
      ? "!"
      : ((($uni)[0] === "$Depends")
        ? ((() => {
          const $n = ($uni)[1];
          return ((text_fromNumber)($n) + "?");
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 43:4', (sp_toHuman)($uni)))));
});

const u0Human$Type$doFullType = (($projectImports, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return (u0Human$Type$toExpression)((c0Compiler$FormattableAst$Poly)((u0Human$Type$uniToText)($projectImports, $uni), (u0Human$Type$doRawType)($projectImports, $raw)));
});

const u0Human$Type$doLowercase = (($projectImports, $name) => {
  return (u0Human$Type$toExpression)((c0Compiler$FormattableAst$Lowercase)(({
    attrPath: c0Core$Nil,
    maybeModule: c0Maybe$Nothing,
    maybeType: c0Maybe$Nothing,
    name: $name,
  })));
});

const u0Human$Type$doParType = (($projectImports, $parType) => {
  return ((($parType)[0] === "$ParSp")
    ? ((() => {
      const $full = ($parType)[1];
      return (u0Human$Type$doFullType)($projectImports, $full);
    }))()
    : ((($parType)[0] === "$ParRe")
      ? ((() => {
        const $raw = ($parType)[1];
        return (u0Human$Type$toExpression)(((($0) => {
          return (c0Compiler$FormattableAst$UnopCall)(c0Compiler$Op$UnopRecycle, $0);
        }))(((($0) => {
          return (u0Human$Type$doRawType)($projectImports, $0);
        }))($raw)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 126:4', (sp_toHuman)($parType))));
});

const u0Human$Type$doTyvarId = (($projectImports, $tyvarId) => {
  return (c0Compiler$FormattableAst$Lowercase)(({
    attrPath: c0Core$Nil,
    maybeModule: c0Maybe$Nothing,
    maybeType: c0Maybe$Nothing,
    name: (text_fromNumber)($tyvarId),
  }));
});

const u0Human$Type$rootToPath = (($0) => {
  return ((($0)[0] === "$Core")
    ? "core:"
    : ((($0)[0] === "$User")
      ? "user:"
      : ((($0)[0] === "$Installed")
        ? "installed:"
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 3:4', (sp_toHuman)($0)))));
});

const u0Human$Type$importsPathToText = (($1) => {
  const $root = ($1)[1];
  const $importsDir = ($1)[2];
  return ((u0Human$Type$rootToPath)($root) + $importsDir);
});

const u0Human$Type$umrToText = (($projectImports, $1) => {
  const $importsPath = ($1)[1];
  const $sourceDir = ($1)[2];
  const $modulePath = ($1)[3];
  return ((u0Human$Type$importsPathToText)($importsPath) + ("/" + ($sourceDir + ("/" + $modulePath))));
});

const u0Human$Type$usrToText = (($projectImports, $1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return ((u0Human$Type$umrToText)($projectImports, $umr) + ("." + $name));
});

const u0Human$Type$doUsr = (($projectImports, $usr) => {
  return (u0Human$Type$toExpression)((c0Compiler$FormattableAst$Uppercase)(({
    maybeModule: c0Maybe$Nothing,
    name: (u0Human$Type$usrToText)($projectImports, $usr),
  })));
});

const u0Human$Type$doRawType = (($projectImports, $rawType) => {
  return (u0Human$Type$toExpression)(((($rawType)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($rawType)[1];
      const $args = ($rawType)[2];
      return (c0Compiler$FormattableAst$Call)((u0Human$Type$doUsr)($projectImports, $usr), (c0List$map)((($0) => {
        return (u0Human$Type$doRawType)($projectImports, $0);
      }), $args));
    }))()
    : ((($rawType)[0] === "$TypeFn")
      ? ((() => {
        const $parTypes = ($rawType)[1];
        const $full = ($rawType)[2];
        return (c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Inline, (c0List$map)((($0) => {
          return (u0Human$Type$doParType)($projectImports, $0);
        }), $parTypes), (u0Human$Type$doFullType)($projectImports, $full));
      }))()
      : ((($rawType)[0] === "$TypeVar")
        ? ((() => {
          const $tyvarId = ($rawType)[1];
          return (u0Human$Type$doTyvarId)($projectImports, $tyvarId);
        }))()
        : ((($rawType)[0] === "$TypeRecord")
          ? ((() => {
            const $maybeExtId = ($rawType)[1];
            const $taAttrs = ($rawType)[2];
            const $maybeExtension = ((($maybeExtId)[0] === "$Nothing")
              ? c0Maybe$Nothing
              : ((($maybeExtId)[0] === "$Just")
                ? ((() => {
                  const $id = ($maybeExtId)[1];
                  return (c0Maybe$Just)((c0Maybe$Just)((u0Human$Type$toExpression)((u0Human$Type$doTyvarId)($projectImports, $id))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 71:16', (sp_toHuman)($maybeExtId))));
            const $attrs = ((($0) => {
              return (c0List$map)((($4) => {
                const $name = $4.first;
                const $raw = $4.second;
                return ({
                  maybeExpr: (c0Maybe$Just)((u0Human$Type$doRawType)($projectImports, $raw)),
                  name: (u0Human$Type$doLowercase)($projectImports, $name),
                });
              }), $0);
            }))(((($0) => {
              return (list_sortBy)(c0Tuple$first, $0);
            }))((c0Dict$toList)($taAttrs)));
            return (c0Compiler$FormattableAst$Record)(({
              attrs: $attrs,
              isMultiline: false,
              maybeExtension: $maybeExtension,
            }));
          }))()
          : ((($rawType)[0] === "$TypeError")
            ? (c0Compiler$FormattableAst$LiteralText)(c0Compiler$Token$SingleQuote, "???")
            : (true
              ? ((() => {
                const $wtf = $rawType;
                return (sp_todo)("bug: this should not be a type");
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 58:4', (sp_toHuman)($rawType)))))))));
});

const u0SPLib$Format$indent_combine = (($pos, $i) => {
  return ($pos + $i);
});

const u0SPLib$Format$indent_width = (($0) => {
  return (c0List$for)(0, $0, u0SPLib$Format$indent_combine);
});

const u0SPLib$Format$spaces = (($0) => {
  return (c0Text$repeat)($0, " ");
});

const u0SPLib$Format$renderLine = (($i, $l) => {
  return ((($l)[0] === "$Text_")
    ? ((() => {
      const $text = ($l)[1];
      return ((u0SPLib$Format$spaces)((u0SPLib$Format$indent_width)($i)) + $text);
    }))()
    : ((($l)[0] === "$CommentWithIndent")
      ? ((() => {
        const $text = ($l)[1];
        return ((u0SPLib$Format$spaces)((u0SPLib$Format$indent_width)($i)) + $text);
      }))()
      : ((($l)[0] === "$CommentIgnoreIndent")
        ? ((() => {
          const $text = ($l)[1];
          return $text;
        }))()
        : ((($l)[0] === "$Space")
          ? (u0SPLib$Format$spaces)((1 + (u0SPLib$Format$indent_width)($i)))
          : ((($l)[0] === "$Row")
            ? ((() => {
              const $left = ($l)[1];
              const $right = ($l)[2];
              return ((u0SPLib$Format$renderLine)($i, $left) + (u0SPLib$Format$renderLine)(c0Core$Nil, $right));
            }))()
            : ((($l)[0] === "$Blank")
              ? ""
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 454:4', (sp_toHuman)($l))))))));
});

const u0SPLib$Format$renderIndentedLine = (($1) => {
  const $i = ($1)[1];
  const $line_ = ($1)[2];
  return ((($0) => {
    return ($0 + "\n");
  }))((c0Text$trimRight)(((($0) => {
    return (u0SPLib$Format$renderLine)($i, $0);
  }))((u0SPLib$Format$stripEnd)($line_))));
});

const u0SPLib$Format$render = (($block) => {
  return ((($block)[0] === "$Empty")
    ? ""
    : ((($block)[0] === "$SingleLine")
      ? ((() => {
        const $line_ = ($block)[2];
        return (u0SPLib$Format$renderIndentedLine)($line_);
      }))()
      : ((($block)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($block)[1];
          const $rest = ($block)[2];
          return ((($0) => {
            return (c0Text$join)("", $0);
          }))(((($0) => {
            return (c0List$map)(u0SPLib$Format$renderIndentedLine, $0);
          }))((c0Core$Cons)($l1, $rest)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 469:4', (sp_toHuman)($block)))));
});

const u0Compiler$TypeCheck$typeToHuman = (($env, $raw) => {
  return (u0SPLib$Format$render)(((($0) => {
    return (u0Human$Format$formatExpression)(({
      isRoot: true,
      originalContent: "",
    }), $0);
  }))(((($0) => {
    return (u0Human$Type$doRawType)($env.projectImports, $0);
  }))($raw)));
});

const u0Compiler$TypeCheck$addErError = (($env, $equality, $message, $state) => {
  const $5 = $equality;
  const $why = $5.why;
  const $type2 = $5.type2;
  const $type1 = $5.type1;
  const $pos = $5.pos;
  const $context = $5.context;
  return ([
    ((($0) => {
      return ((__re__ = (array_push)($state.errors, $0)), ($state.errors = (__re__)[1]), (__re__)[0]);
    }))(((($0) => {
      return (u0Compiler$Error$Simple)((u0Compiler$TypeCheck$getErrorModule)($env), $pos, $0);
    }))((c0Core$Cons)($message, (c0Core$Cons)((sp_toHuman)($context), (c0Core$Cons)((sp_toHuman)($why), (c0Core$Cons)("TYPE 1 -----------------------", (c0Core$Cons)((u0Compiler$TypeCheck$typeToHuman)($env, $type1), (c0Core$Cons)("TYPE 2 -----------------------", (c0Core$Cons)((u0Compiler$TypeCheck$typeToHuman)($env, $type2), c0Core$Nil))))))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$addErErrorIf = (($env, $test, $equality, $message, $state) => {
  return ([
    ($test
      ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $equality, $message, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const u0Compiler$TypeCheck$addError = (($env, $pos, $error, $state) => {
  return ([
    ((__re__ = (u0Compiler$TypeCheck$addErrorE)($env, $pos, $error, $state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$TypeCheck$addSub = (($newId, $newUni, $subs) => {
  let $newSubs = (hash_fromList)(c0Core$Nil);
  const $replace = (($uni) => {
    return ((($uni)[0] === "$Depends")
      ? ((() => {
        const $id = ($uni)[1];
        return ((sp_equal)($id, $newId)
          ? $newUni
          : $uni);
      }))()
      : (true
        ? $uni
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2178:8', (sp_toHuman)($uni))));
  });
  ((__re__ = (hash_each)($subs, (($univarId, $uniqueness) => {
    return ((__re__ = (hash_insert)($newSubs, $univarId, ($replace)($uniqueness))), ($newSubs = (__re__)[1]), (__re__)[0]);
  }))), ($subs = (__re__)[1]), (__re__)[0]);
  ((__re__ = (hash_insert)($newSubs, $newId, $newUni)), ($newSubs = (__re__)[1]), (__re__)[0]);
  return ([
    ($subs = $newSubs),
    $subs,
  ]);
});

const u0Compiler$TypeCheck$solveUniquenessConstraint = (($env, $eq, $state) => {
  const $4 = ((__re__ = (hash_get)($state.univarSubs, $eq.id)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Nothing")
      ? ((__re__ = (u0Compiler$TypeCheck$addSub)($eq.id, $eq.uni, $state.univarSubs)), ($state.univarSubs = (__re__)[1]), (__re__)[0])
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $subUni = ($4)[1];
          return ((sp_equal)($subUni, $eq.uni)
            ? null
            : ((() => {
              const $5 = ({
                first: $subUni,
                second: $eq.uni,
              });
              return ((($5.first)[0] === "$Depends")
                ? ((() => {
                  const $subId = ($5.first)[1];
                  return ((__re__ = (u0Compiler$TypeCheck$addSub)($subId, $eq.uni, $state.univarSubs)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
                }))()
                : ((($5.second)[0] === "$Depends")
                  ? ((() => {
                    const $newId = ($5.second)[1];
                    return ((__re__ = (u0Compiler$TypeCheck$addSub)($newId, $subUni, $state.univarSubs)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $eq.pos, (u0Compiler$TypeCheck$ErrorUnresolvableUniqueness)($eq, $subUni), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2202:16', (sp_toHuman)($5)))));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2192:4', (sp_toHuman)($4)))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$uniCanBeCastTo = (($1) => {
  const $given = $1.given;
  const $required = $1.required;
  const $2 = ({
    first: $given,
    second: $required,
  });
  return ((($2.second)[0] === "$Imm")
    ? u0Compiler$TypeCheck$CanBeCastYes
    : ((($2.first)[0] === "$Uni")
      ? u0Compiler$TypeCheck$CanBeCastYes
      : (((($2.first)[0] === "$Imm") && (($2.second)[0] === "$Uni"))
        ? (u0Compiler$TypeCheck$CanBeCastNo)(c0Core$Nil)
        : (((($2.first)[0] === "$Depends") && (($2.second)[0] === "$Uni"))
          ? ((() => {
            const $a = ($2.first)[1];
            return (u0Compiler$TypeCheck$CanBeCastNo)((c0Core$Cons)(({
              first: $a,
              second: c0Compiler$Ast$Uni,
            }), c0Core$Nil));
          }))()
          : (((($2.first)[0] === "$Depends") && (($2.second)[0] === "$Depends"))
            ? ((() => {
              const $a = ($2.first)[1];
              const $b = ($2.second)[1];
              return ((sp_equal)($a, $b)
                ? u0Compiler$TypeCheck$CanBeCastYes
                : (u0Compiler$TypeCheck$CanBeCastNo)((c0Core$Cons)(({
                  first: $a,
                  second: (c0Compiler$Ast$Depends)($b),
                }), (c0Core$Cons)(({
                  first: $b,
                  second: (c0Compiler$Ast$Depends)($a),
                }), c0Core$Nil))));
            }))()
            : (((($2.first)[0] === "$Imm") && (($2.second)[0] === "$Depends"))
              ? ((() => {
                const $b = ($2.second)[1];
                return (u0Compiler$TypeCheck$CanBeCastNo)((c0Core$Cons)(({
                  first: $b,
                  second: c0Compiler$Ast$Imm,
                }), c0Core$Nil));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 545:4', (sp_toHuman)($2))))))));
});

const u0Compiler$TypeCheck$compareParTypes = (($env, $currentEquality, $index, $p1, $p2, $state) => {
  const $7 = $currentEquality;
  const $why = $7.why;
  const $pos = $7.pos;
  const $expandedRecursives = $7.expandedRecursives;
  const $context = $7.context;
  const $8 = ({
    first: $p1,
    second: $p2,
  });
  return ([
    (((($8.first)[0] === "$ParRe") && (($8.second)[0] === "$ParRe"))
      ? ((() => {
        const $raw1 = ($8.first)[1];
        const $raw2 = ($8.second)[1];
        return ((($0) => {
          return ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))(({
          context: $context,
          expandedRecursives: $expandedRecursives,
          pos: $pos,
          type1: $raw1,
          type2: $raw2,
          why: (u0Compiler$TypeCheck$Why_FunctionInput)($index, $why),
        }));
      }))()
      : (((($8.first)[0] === "$ParSp") && (($8.second)[0] === "$ParSp"))
        ? ((() => {
          const $full1 = ($8.first)[1];
          const $full2 = ($8.second)[1];
          ((($0) => {
            return ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))(({
            context: $context,
            expandedRecursives: $expandedRecursives,
            pos: $pos,
            type1: $full1.raw,
            type2: $full2.raw,
            why: (u0Compiler$TypeCheck$Why_FunctionInput)($index, $why),
          }));
          const $9 = (u0Compiler$TypeCheck$uniCanBeCastTo)(({
            given: $full1.uni,
            required: $full2.uni,
          }));
          return ((($9)[0] === "$CanBeCastYes")
            ? null
            : (((($9)[0] === "$CanBeCastNo") && ((($9)[1])[0] === "$Nil"))
              ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $currentEquality, ("Function call par " + ((text_fromNumber)($index) + " with wrong uniqueness")), $state)), ($state = (__re__)[1]), (__re__)[0])
              : (((($9)[0] === "$CanBeCastNo") && ((($9)[1])[0] === "$Cons"))
                ? ((() => {
                  const $id = (($9)[1])[1].first;
                  const $uni = (($9)[1])[1].second;
                  const $tail = (($9)[1])[2];
                  return ((__re__ = (u0Compiler$TypeCheck$solveUniquenessConstraint)($env, ({
                    context: $context,
                    id: $id,
                    pos: $pos,
                    uni: $uni,
                    why: "fn arg",
                  }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2257:12', (sp_toHuman)($9)))));
          return null;
        }))()
        : (true
          ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, ((() => {
            const $0 = $currentEquality;
            return (Object.assign)({}, $0, ({
              why: (u0Compiler$TypeCheck$Why_FunctionInput)($index, $why),
            }));
          }))(), "recycling does not match", $state)), ($state = (__re__)[1]), (__re__)[0])
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2241:4', (sp_toHuman)($8))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$applySubstitutionToType = (($tyvarId, $replacingType, $originalType) => {
  const $subsAsFns = ({
    ty: (($id) => {
      return ((sp_equal)($id, $tyvarId)
        ? (c0Maybe$Just)($replacingType)
        : c0Maybe$Nothing);
    }),
    uni: ((_0) => {
      return c0Maybe$Nothing;
    }),
  });
  return (c0Compiler$TypedAst$resolveRaw)($subsAsFns, $originalType);
});

const u0Compiler$TypeCheck$occurs = (($tyvarId, $type) => {
  const $rec = (($0) => {
    return (u0Compiler$TypeCheck$occurs)($tyvarId, $0);
  });
  return ((($type)[0] === "$TypeFn")
    ? ((() => {
      const $ins = ($type)[1];
      const $out = ($type)[2];
      return ((c0List$any)((($t) => {
        return ($rec)((c0Compiler$TypedAst$toRaw)($t));
      }), $ins) || ($rec)($out.raw));
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return (sp_equal)($id, $tyvarId);
      }))()
      : ((($type)[0] === "$TypeExact")
        ? ((() => {
          const $usr = ($type)[1];
          const $args = ($type)[2];
          return (c0List$any)($rec, $args);
        }))()
        : ((($type)[0] === "$TypeRecord")
          ? ((() => {
            const $attrs = ($type)[2];
            return (c0Dict$any)((($k, $v) => {
              return ($rec)($v);
            }), $attrs);
          }))()
          : ((($type)[0] === "$TypeError")
            ? false
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2417:4', (sp_toHuman)($type)))))));
});

const u0Compiler$TypeCheck$replaceUnificationVariable = (($env, $equality, $tyvarId, $replacingType, $state) => {
  const $isSame = ((($replacingType)[0] === "$TypeVar")
    ? ((() => {
      const $tyvarId2 = ($replacingType)[1];
      return (sp_equal)($tyvarId, $tyvarId2);
    }))()
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2392:8', (sp_toHuman)($replacingType))));
  return ([
    ($isSame
      ? null
      : ((u0Compiler$TypeCheck$occurs)($tyvarId, $replacingType)
        ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $equality, "circular!?", $state)), ($state = (__re__)[1]), (__re__)[0])
        : ((() => {
          let $new = (hash_fromList)(c0Core$Nil);
          ((__re__ = (hash_each)($state.tyvarSubs, (($tId, $rawType) => {
            return ((__re__ = (hash_insert)($new, $tId, (u0Compiler$TypeCheck$applySubstitutionToType)($tyvarId, $replacingType, $rawType))), ($new = (__re__)[1]), (__re__)[0]);
          }))), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
          ((__re__ = (hash_insert)($new, $tyvarId, $replacingType)), ($new = (__re__)[1]), (__re__)[0]);
          return ($state.tyvarSubs = $new);
        }))())),
    $state,
  ]);
});

const u0Compiler$TypeCheck$solveRecordExt = (($env, $equality, $swapEquality, $tyvar1, $attrs1, $attrs2, $state) => {
  const $8 = $equality;
  const $why = $8.why;
  const $pos = $8.pos;
  const $context = $8.context;
  (c0Dict$each)($attrs1, (($name, $type1) => {
    const $11 = (c0Dict$get)($name, $attrs2);
    return ((($11)[0] === "$Nothing")
      ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $equality, ("missing attribute " + $name), $state)), ($state = (__re__)[1]), (__re__)[0])
      : ((($11)[0] === "$Just")
        ? ((() => {
          const $type2 = ($11)[1];
          const $12 = ($swapEquality
            ? ({
              first: $type2,
              second: $type1,
            })
            : ({
              first: $type1,
              second: $type2,
            }));
          const $b = $12.second;
          const $a = $12.first;
          return ((($0) => {
            return ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))(((() => {
            const $0 = $equality;
            return (Object.assign)({}, $0, ({
              context: (u0Compiler$TypeCheck$Context_AttributeName)($name, $context),
              type1: $a,
              type2: $b,
            }));
          }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2370:8', (sp_toHuman)($11))));
  }));
  return ([
    ((__re__ = (u0Compiler$TypeCheck$replaceUnificationVariable)($env, $equality, $tyvar1, (c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, $attrs2), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$TypeCheck$solveEquality = (($env, $head, $state) => {
  const $4 = $head;
  const $why = $4.why;
  const $type2 = $4.type2;
  const $type1 = $4.type1;
  const $pos = $4.pos;
  const $expandedRecursives = $4.expandedRecursives;
  const $context = $4.context;
  const $5 = ({
    first: $type1,
    second: $type2,
  });
  return ([
    ((($5.first)[0] === "$TypeVar")
      ? ((() => {
        const $tyvarId = ($5.first)[1];
        const $t2 = $5.second;
        return ((__re__ = (u0Compiler$TypeCheck$replaceUnificationVariable)($env, $head, $tyvarId, $t2, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($5.second)[0] === "$TypeVar")
        ? ((() => {
          const $t1 = $5.first;
          const $tyvarId = ($5.second)[1];
          return ((__re__ = (u0Compiler$TypeCheck$replaceUnificationVariable)($env, $head, $tyvarId, $t1, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : (((($5.first)[0] === "$TypeExact") && (($5.second)[0] === "$TypeExact"))
          ? ((() => {
            const $usr1 = ($5.first)[1];
            const $args1 = ($5.first)[2];
            const $usr2 = ($5.second)[1];
            const $args2 = ($5.second)[2];
            return ((sp_not_equal)($usr1, $usr2)
              ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $head, "types are incompatible2", $state)), ($state = (__re__)[1]), (__re__)[0])
              : ((() => {
                (c0List$indexedEach2)($args2, $args1, (($index, $raw1, $raw2) => {
                  return ((($0) => {
                    return ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))(((() => {
                    const $0 = $head;
                    return (Object.assign)({}, $0, ({
                      type1: $raw1,
                      type2: $raw2,
                      why: (u0Compiler$TypeCheck$Why_TypeArgument)($usr1, $index, $why),
                    }));
                  }))());
                }));
                return null;
              }))());
          }))()
          : (((($5.first)[0] === "$TypeFn") && (($5.second)[0] === "$TypeFn"))
            ? ((() => {
              const $pars1 = ($5.first)[1];
              const $out1 = ($5.first)[2];
              const $pars2 = ($5.second)[1];
              const $out2 = ($5.second)[2];
              return ((sp_not_equal)((c0List$length)($pars1), (c0List$length)($pars2))
                ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $head, "functions expect a different number of arguments", $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((() => {
                  ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, ((() => {
                    const $0 = $head;
                    return (Object.assign)({}, $0, ({
                      type1: $out1.raw,
                      type2: $out2.raw,
                      why: (u0Compiler$TypeCheck$Why_FunctionOutput)($why),
                    }));
                  }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  const $bleh = ((() => {
                    const $6 = (u0Compiler$TypeCheck$uniCanBeCastTo)(({
                      given: $out2.uni,
                      required: $out1.uni,
                    }));
                    return ((($6)[0] === "$CanBeCastYes")
                      ? null
                      : (((($6)[0] === "$CanBeCastNo") && ((($6)[1])[0] === "$Nil"))
                        ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $head, "the function return type have different uniqueness", $state)), ($state = (__re__)[1]), (__re__)[0])
                        : (((($6)[0] === "$CanBeCastNo") && ((($6)[1])[0] === "$Cons"))
                          ? ((() => {
                            const $id = (($6)[1])[1].first;
                            const $uni = (($6)[1])[1].second;
                            const $tail = (($6)[1])[2];
                            return ((__re__ = (u0Compiler$TypeCheck$solveUniquenessConstraint)($env, ({
                              context: $context,
                              id: $id,
                              pos: $pos,
                              uni: $uni,
                              why: "fn out",
                            }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2306:20', (sp_toHuman)($6)))));
                  }))();
                  return (c0List$indexedEach2)($pars1, $pars2, (($0, $1, $2) => {
                    return ((__re__ = (u0Compiler$TypeCheck$compareParTypes)($env, $head, $0, $1, $2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }));
                }))());
            }))()
            : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
              ? ((() => {
                const $attrs1 = ($5.first)[2];
                const $attrs2 = ($5.second)[2];
                const $6 = (c0Dict$onlyBothOnly)($attrs1, $attrs2);
                const $only2 = $6.third;
                const $both = $6.second;
                const $only1 = $6.first;
                (c0Dict$each)($both, (($attrName, $7) => {
                  const $attrType1 = $7.first;
                  const $attrType2 = $7.second;
                  return ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, ((() => {
                    const $0 = $head;
                    return (Object.assign)({}, $0, ({
                      type1: $attrType1,
                      type2: $attrType2,
                      why: (u0Compiler$TypeCheck$Why_Attribute)($why),
                    }));
                  }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
                }));
                return ((__re__ = (u0Compiler$TypeCheck$addErErrorIf)($env, ((sp_not_equal)($only1, c0Dict$empty) || (sp_not_equal)($only2, c0Dict$empty)), $head, "record attrs don't match", $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
                ? ((() => {
                  const $tyvar1 = (($5.first)[1])[1];
                  const $attrs1 = ($5.first)[2];
                  const $attrs2 = ($5.second)[2];
                  return ((__re__ = (u0Compiler$TypeCheck$solveRecordExt)($env, $head, false, $tyvar1, $attrs1, $attrs2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Just"))))
                  ? ((() => {
                    const $attrs1 = ($5.first)[2];
                    const $tyvar2 = (($5.second)[1])[1];
                    const $attrs2 = ($5.second)[2];
                    return ((__re__ = (u0Compiler$TypeCheck$solveRecordExt)($env, $head, true, $tyvar2, $attrs2, $attrs1, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[1])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Just"))))
                    ? ((() => {
                      const $tyvar1 = (($5.first)[1])[1];
                      const $attrs1 = ($5.first)[2];
                      const $tyvar2 = (($5.second)[1])[1];
                      const $attrs2 = ($5.second)[2];
                      const $6 = (c0Dict$onlyBothOnly)($attrs1, $attrs2);
                      const $only2 = $6.third;
                      const $both = $6.second;
                      const $only1 = $6.first;
                      const $newExtId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $newType = (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($newExtId), (c0Dict$join)($attrs1, $only2));
                      ((__re__ = (u0Compiler$TypeCheck$replaceUnificationVariable)($env, $head, $tyvar1, $newType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      ((__re__ = (u0Compiler$TypeCheck$replaceUnificationVariable)($env, $head, $tyvar2, $newType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return (c0Dict$each)($both, (($name, $7) => {
                        const $t1 = $7.first;
                        const $t2 = $7.second;
                        return ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, ({
                          context: (u0Compiler$TypeCheck$Context_AttributeName)($name, $context),
                          expandedRecursives: $expandedRecursives,
                          pos: $pos,
                          type1: $t1,
                          type2: $t1,
                          why: $why,
                        }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }));
                    }))()
                    : ((($5.first)[0] === "$TypeError")
                      ? null
                      : ((($5.second)[0] === "$TypeError")
                        ? null
                        : (true
                          ? ((__re__ = (u0Compiler$TypeCheck$addErError)($env, $head, "types are incompatible1", $state)), ($state = (__re__)[1]), (__re__)[0])
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2276:4', (sp_toHuman)($5))))))))))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$addEquality = (($env, $pos, $why, $t1, $t2, $state) => {
  return ([
    ((__re__ = (u0Compiler$TypeCheck$solveEquality)($env, ({
      context: $env.context,
      expandedRecursives: c0Set$empty,
      pos: $pos,
      type1: ((__re__ = (u0Compiler$TypeCheck$applyAllSubs)($state, $t1)), ($state = (__re__)[1]), (__re__)[0]),
      type2: ((__re__ = (u0Compiler$TypeCheck$applyAllSubs)($state, $t2)), ($state = (__re__)[1]), (__re__)[0]),
      why: $why,
    }), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$TypeCheck$addErrorIf = (($test, $env, $pos, $error, $state) => {
  return ([
    ($test
      ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, $error, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const u0Compiler$TypeCheck$replaceUnivarRec = (($old, $new, $raw) => {
  const $doRaw = (($0) => {
    return (u0Compiler$TypeCheck$replaceUnivarRec)($old, $new, $0);
  });
  return ((($raw)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($raw)[1];
      const $args = ($raw)[2];
      return (c0Compiler$TypedAst$TypeExact)($usr, (c0List$map)($doRaw, $args));
    }))()
    : ((($raw)[0] === "$TypeRecord")
      ? ((() => {
        const $maybeExt = ($raw)[1];
        const $attrs = ($raw)[2];
        return (c0Compiler$TypedAst$TypeRecord)($maybeExt, (c0Dict$map)((($k, $v) => {
          return ($doRaw)($v);
        }), $attrs));
      }))()
      : ((($raw)[0] === "$TypeError")
        ? c0Compiler$TypedAst$TypeError
        : ((($raw)[0] === "$TypeVar")
          ? ((() => {
            const $id = ($raw)[1];
            return (c0Compiler$TypedAst$TypeVar)($id);
          }))()
          : ((($raw)[0] === "$TypeFn")
            ? ((() => {
              const $ins = ($raw)[1];
              const $out = ($raw)[2];
              const $doUni = (($uni) => {
                return ((($uni)[0] === "$Depends")
                  ? ((() => {
                    const $id = ($uni)[1];
                    return ((sp_equal)($id, $old)
                      ? $new
                      : $uni);
                  }))()
                  : (true
                    ? $uni
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 395:16', (sp_toHuman)($uni))));
              });
              const $mapPar = (($par) => {
                return ((($par)[0] === "$ParRe")
                  ? ((() => {
                    const $r = ($par)[1];
                    return (c0Compiler$TypedAst$ParRe)(($doRaw)($r));
                  }))()
                  : ((($par)[0] === "$ParSp")
                    ? ((() => {
                      const $f = ($par)[1];
                      return (c0Compiler$TypedAst$ParSp)(({
                        raw: ($doRaw)($f.raw),
                        uni: ($doUni)($f.uni),
                      }));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 401:16', (sp_toHuman)($par))));
              });
              return (c0Compiler$TypedAst$TypeFn)((c0List$map)($mapPar, $ins), ({
                raw: ($doRaw)($out.raw),
                uni: ($doUni)($out.uni),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 378:4', (sp_toHuman)($raw)))))));
});

const u0Compiler$TypeCheck$generalize = (($env, $pos, $ref, $instance, $state) => {
  const $replaceUnivar = (($originalUnivarId, _1, $r) => {
    const $newUnivarId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
    return (u0Compiler$TypeCheck$replaceUnivarRec)($originalUnivarId, (c0Compiler$Ast$Depends)($newUnivarId), $r);
  });
  const $raw = ((($0) => {
    return (c0Dict$for)($0, $instance.freeTyvars, (($originalTyvarId, $tyvar, $a) => {
      const $generalizedTyvarId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = (hash_insert)($state.tyvarsById, $generalizedTyvarId, $tyvar)), ($state.tyvarsById = (__re__)[1]), (__re__)[0]);
      return (u0Compiler$TypeCheck$applySubstitutionToType)($originalTyvarId, (c0Compiler$TypedAst$TypeVar)($generalizedTyvarId), $a);
    }));
  }))(((($0) => {
    return (c0Dict$for)($0, $instance.freeUnivars, $replaceUnivar);
  }))($instance.type.raw));
  const $0 = $instance.type;
  return ([
    (Object.assign)({}, $0, ({
      raw: $raw,
    })),
    $state,
  ]);
});

const u0Compiler$TypeCheck$getConstructorByUsr = (($usr, $env) => {
  return (c0Dict$get)($usr, $env.constructors);
});

const u0Compiler$TypeCheck$coreTypeNumber = (c0Compiler$TypedAst$TypeExact)(u0Compiler$CoreDefs$numberDef.usr, c0Core$Nil);

const u0Compiler$TypeCheck$coreTypeText = (c0Compiler$TypedAst$TypeExact)(u0Compiler$CoreDefs$textDef.usr, c0Core$Nil);

const u0Compiler$TypeCheck$newRawType = (($state) => {
  return ([
    (c0Compiler$TypedAst$TypeVar)(((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0])),
    $state,
  ]);
});

const u0Compiler$TypeCheck$translateAnnotationType = (($env, $state, $ca) => {
  const $nameToType = (c0Dict$map)((($k, $v) => {
    return (c0Compiler$TypedAst$TypeVar)($v);
  }), $env.annotatedTyvarsByName);
  return ([
    ((__re__ = (u0Compiler$TypeCheck$translateRawType)($env, $nameToType, $env.annotatedUnivarsByOriginalId, $state.errors, $ca)), ($state.errors = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferPatternAny = (($baseEnv, $pos, $uni, $maybeName, $maybeAnnotation, $state) => {
  const $7 = ((($maybeAnnotation)[0] === "$Nothing")
    ? ({
      first: ((__re__ = (u0Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]),
      second: $baseEnv,
    })
    : ((($maybeAnnotation)[0] === "$Just")
      ? ((() => {
        const $annotation = ($maybeAnnotation)[1];
        const $annotatedTyvarsByName = (c0Dict$for)($baseEnv.annotatedTyvarsByName, $annotation.tyvars, (($name, $9, $acc) => {
          const $nonFn = $9.nonFn;
          return ((c0Dict$member)($name, $acc)
            ? $acc
            : (c0Dict$insert)($name, ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]), $acc));
        }));
        const $annotatedUnivarsByOriginalId = (c0Dict$for)($baseEnv.annotatedUnivarsByOriginalId, $annotation.univars, (($id, _1, $acc) => {
          return ((c0Dict$member)($id, $acc)
            ? $acc
            : (c0Dict$insert)($id, ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]), $acc));
        }));
        const $newEnv = ((() => {
          const $0 = $baseEnv;
          return (Object.assign)({}, $0, ({
            annotatedTyvarsByName: $annotatedTyvarsByName,
            annotatedUnivarsByOriginalId: $annotatedUnivarsByOriginalId,
          }));
        }))();
        return ({
          first: ((__re__ = (u0Compiler$TypeCheck$translateAnnotationType)($newEnv, $state, $annotation.raw)), ($state = (__re__)[1]), (__re__)[0]),
          second: $newEnv,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1709:8', (sp_toHuman)($maybeAnnotation))));
  const $envWithAnnotations = $7.second;
  const $raw = $7.first;
  const $type = ({
    raw: $raw,
    uni: $uni,
  });
  const $envWithVariable = ((($maybeName)[0] === "$Nothing")
    ? $envWithAnnotations
    : ((($maybeName)[0] === "$Just")
      ? ((() => {
        const $name = ($maybeName)[1];
        const $variable = ({
          definedAt: $pos,
          freeTyvars: c0Dict$empty,
          freeUnivars: c0Dict$empty,
          type: $type,
        });
        const $0 = $envWithAnnotations;
        return (Object.assign)({}, $0, ({
          variables: (c0Dict$insert)((c0Compiler$Ast$RefLocal)($name), $variable, $0.variables),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1739:8', (sp_toHuman)($maybeName))));
  const $typedPattern = (c0Compiler$TypedAst$PatternAny)($pos, ({
    maybeName: $maybeName,
    type: $type,
  }));
  return ([
    ({
      env: $envWithVariable,
      maybeFullAnnotation: $maybeAnnotation,
      patternType: $raw,
      typedPattern: $typedPattern,
    }),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferPattern = (($env, $uni, $pattern, $state) => {
  return ([
    ((($pattern)[0] === "$PatternAny")
      ? ((() => {
        const $pos = ($pattern)[1];
        const $maybeName = ($pattern)[2];
        const $maybeAnn = ($pattern)[3];
        return ((__re__ = (u0Compiler$TypeCheck$inferPatternAny)($env, $pos, $uni, $maybeName, $maybeAnn, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($pattern)[0] === "$PatternLiteralText")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $text = ($pattern)[2];
          return ({
            env: $env,
            maybeFullAnnotation: c0Maybe$Nothing,
            patternType: u0Compiler$TypeCheck$coreTypeText,
            typedPattern: (c0Compiler$TypedAst$PatternLiteralText)($pos, $text),
          });
        }))()
        : ((($pattern)[0] === "$PatternLiteralNumber")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $n = ($pattern)[2];
            return ({
              env: $env,
              maybeFullAnnotation: c0Maybe$Nothing,
              patternType: u0Compiler$TypeCheck$coreTypeNumber,
              typedPattern: (c0Compiler$TypedAst$PatternLiteralNumber)($pos, $n),
            });
          }))()
          : ((($pattern)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $usr = ($pattern)[2];
              const $arguments = ($pattern)[3];
              const $5 = ((($0) => {
                return (c0List$forReversed)($0, $arguments, (($arg, $7) => {
                  const $argOuts = $7.first;
                  const $envX = $7.second;
                  const $out = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($envX, $uni, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return ({
                    first: (sp_cons)($out, $argOuts),
                    second: $out.env,
                  });
                }));
              }))(({
                first: c0Core$Nil,
                second: $env,
              }));
              const $newEnv = $5.second;
              const $argumentOuts = $5.first;
              const $typedArguments = (c0List$map)((($out) => {
                return $out.typedPattern;
              }), $argumentOuts);
              const $argumentTypes = (c0List$map)((($out) => {
                return $out.patternType;
              }), $argumentOuts);
              const $finalType = ((() => {
                const $6 = (u0Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
                return ((($6)[0] === "$Nothing")
                  ? ((() => {
                    ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return c0Compiler$TypedAst$TypeError;
                  }))()
                  : ((($6)[0] === "$Just")
                    ? ((() => {
                      const $cons = ($6)[1];
                      const $x = ((__re__ = (u0Compiler$TypeCheck$generalize)($env, $pos, (c0Compiler$Ast$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $7 = ((() => {
                        const $8 = $x.raw;
                        return ((($8)[0] === "$TypeFn")
                          ? ((() => {
                            const $ins = ($8)[1];
                            const $out = ($8)[2];
                            return ({
                              first: $ins,
                              second: $out.raw,
                            });
                          }))()
                          : (true
                            ? ({
                              first: c0Core$Nil,
                              second: $x.raw,
                            })
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1654:28', (sp_toHuman)($8))));
                      }))();
                      const $returnType = $7.second;
                      const $parTypes = $7.first;
                      ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)((c0List$length)($parTypes), (c0List$length)($arguments)), $env, $pos, u0Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      (c0List$indexedEach2)($parTypes, $argumentTypes, (($index, $parType, $argType) => {
                        return ((($parType)[0] === "$ParRe")
                          ? ((() => {
                            const $raw = ($parType)[1];
                            return (u0Compiler$TypeCheck$bug)("cons can't recycle?!");
                          }))()
                          : ((($parType)[0] === "$ParSp")
                            ? ((() => {
                              const $full = ($parType)[1];
                              return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, (u0Compiler$TypeCheck$Why_Argument)($index), $full.raw, $argType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1661:28', (sp_toHuman)($parType))));
                      }));
                      return $returnType;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1642:16', (sp_toHuman)($6))));
              }))();
              return ({
                env: $newEnv,
                maybeFullAnnotation: c0Maybe$Nothing,
                patternType: $finalType,
                typedPattern: (c0Compiler$TypedAst$PatternConstructor)($pos, $usr, $typedArguments),
              });
            }))()
            : ((($pattern)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($pattern)[1];
                const $completeness = ($pattern)[2];
                const $pas = ($pattern)[3];
                const $5 = ((($0) => {
                  return (c0Dict$for)($0, $pas, (($name, $pa, $7) => {
                    const $dict = $7.first;
                    const $envX = $7.second;
                    const $out = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($envX, $uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ({
                      first: (c0Dict$insert)($name, $out, $dict),
                      second: $out.env,
                    });
                  }));
                }))(({
                  first: c0Dict$empty,
                  second: $env,
                }));
                const $newEnv = $5.second;
                const $outs = $5.first;
                const $patternExt = ((($completeness)[0] === "$Complete")
                  ? c0Maybe$Nothing
                  : ((($completeness)[0] === "$Partial")
                    ? (c0Maybe$Just)(((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]))
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1690:16', (sp_toHuman)($completeness))));
                const $raw = (c0Compiler$TypedAst$TypeRecord)($patternExt, ((($0) => {
                  return (c0Dict$map)((($name, $out) => {
                    return $out.patternType;
                  }), $0);
                }))($outs));
                return ({
                  env: $newEnv,
                  maybeFullAnnotation: c0Maybe$Nothing,
                  patternType: $raw,
                  typedPattern: (c0Compiler$TypedAst$PatternRecord)($pos, ((($0) => {
                    return (c0Dict$map)((($k, $o) => {
                      return ({
                        first: $o.typedPattern,
                        second: $o.patternType,
                      });
                    }), $0);
                  }))($outs)),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1605:4', (sp_toHuman)($pattern))))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$fullTypeError = ({
  raw: c0Compiler$TypedAst$TypeError,
  uni: c0Compiler$Ast$Uni,
});

const u0Compiler$TypeCheck$patternError = (($pos) => {
  return (c0Compiler$TypedAst$PatternAny)($pos, ({
    maybeName: c0Maybe$Nothing,
    type: u0Compiler$TypeCheck$fullTypeError,
  }));
});

const u0Compiler$TypeCheck$checkPatternConstructor = (($env, $pos, $expectedType, $usr, $arguments, $state) => {
  const $insertArgsOnError = (($0) => {
    return (c0List$for)($0, $arguments, (($arg, $envX) => {
      const $out = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($envX, $expectedType.uni, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
      return $out.env;
    }));
  });
  const $7 = (u0Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
  return ([
    ((($7)[0] === "$Nothing")
      ? ((() => {
        ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
        return ({
          first: (u0Compiler$TypeCheck$patternError)($pos),
          second: ($insertArgsOnError)($env),
        });
      }))()
      : ((($7)[0] === "$Just")
        ? ((() => {
          const $instance = ($7)[1];
          const $fullType_ = ((__re__ = (u0Compiler$TypeCheck$generalize)($env, $pos, (c0Compiler$Ast$RefGlobal)($usr), ((() => {
            const $0 = $instance;
            return (Object.assign)({}, $0, ({
              freeUnivars: c0Dict$empty,
            }));
          }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $fullType = ((() => {
            const $0 = $fullType_;
            return (Object.assign)({}, $0, ({
              raw: (u0Compiler$TypeCheck$replaceUnivarRec)(1, $expectedType.uni, $0.raw),
            }));
          }))();
          const $8 = ((() => {
            const $9 = $fullType.raw;
            return ((($9)[0] === "$TypeFn")
              ? ((() => {
                const $ax = ($9)[1];
                const $o = ($9)[2];
                return ({
                  first: $ax,
                  second: $o,
                });
              }))()
              : (true
                ? ({
                  first: c0Core$Nil,
                  second: $fullType,
                })
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1889:16', (sp_toHuman)($9))));
          }))();
          const $requiredOut = $8.second;
          const $requiredParTypes = $8.first;
          return ((sp_not_equal)((c0List$length)($arguments), (c0List$length)($requiredParTypes))
            ? ((() => {
              ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, u0Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: (u0Compiler$TypeCheck$patternError)($pos),
                second: ($insertArgsOnError)($env),
              });
            }))()
            : ((() => {
              const $checkArg = (($10, $9) => {
                const $arg = $10.first;
                const $parType = $10.second;
                const $envX = $9.first;
                const $args = $9.second;
                const $11 = ((($parType)[0] === "$ParSp")
                  ? ((() => {
                    const $full = ($parType)[1];
                    return ((__re__ = (u0Compiler$TypeCheck$checkPattern)($envX, $full, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($parType)[0] === "$ParRe")
                    ? ((() => {
                      const $raw = ($parType)[1];
                      return (u0Compiler$TypeCheck$bug)("should not happen???");
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1901:28', (sp_toHuman)($parType))));
                const $envX1 = $11.second;
                const $taArg = $11.first;
                return ({
                  first: $envX1,
                  second: (sp_cons)($taArg, $args),
                });
              });
              const $9 = ((($0) => {
                return (c0List$forReversed)($0, (c0List$map2)(c0Tuple$pair, $arguments, $requiredParTypes), $checkArg);
              }))(({
                first: $env,
                second: c0Core$Nil,
              }));
              const $typedArgs = $9.second;
              const $newEnv = $9.first;
              ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_CalledAsFunction, $requiredOut.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: (c0Compiler$TypedAst$PatternConstructor)($pos, $usr, $typedArgs),
                second: $newEnv,
              });
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1872:4', (sp_toHuman)($7)))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$checkPatternRecord = (($env, $pos, $expectedType, $completeness, $pas, $state) => {
  const $7 = $expectedType;
  const $uni = $7.uni;
  const $8 = $expectedType.raw;
  return ([
    (((($8)[0] === "$TypeRecord") && ((($8)[1])[0] === "$Nothing"))
      ? ((() => {
        const $attrs = ($8)[2];
        const $9 = (c0Dict$onlyBothOnly)($pas, $attrs);
        const $typeOnly = $9.third;
        const $both = $9.second;
        const $paOnly = $9.first;
        ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($paOnly, c0Dict$empty), $env, $pos, (u0Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation)((c0Dict$keys)($paOnly)), $state)), ($state = (__re__)[1]), (__re__)[0]);
        ((__re__ = (u0Compiler$TypeCheck$addErrorIf)(((sp_not_equal)($typeOnly, c0Dict$empty) && (sp_equal)($completeness, c0Compiler$CanonicalAst$Complete)), $env, $pos, (u0Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation)((c0Dict$keys)($typeOnly)), $state)), ($state = (__re__)[1]), (__re__)[0]);
        const $10 = ((($0) => {
          return (c0Dict$for)($0, $both, (($name, $13, $12) => {
            const $pa = $13.first;
            const $raw = $13.second;
            const $acc = $12.first;
            const $envX = $12.second;
            const $15 = ((__re__ = (u0Compiler$TypeCheck$checkPattern)(((() => {
              const $0 = $envX;
              return (Object.assign)({}, $0, ({
                context: (u0Compiler$TypeCheck$Context_AttributeName)($name, $env.context),
              }));
            }))(), ({
              raw: $raw,
              uni: $uni,
            }), $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $envX0 = $15.second;
            const $taPa = $15.first;
            return ({
              first: (c0Dict$insert)($name, ({
                first: $taPa,
                second: $raw,
              }), $acc),
              second: ((() => {
                const $0 = $envX0;
                return (Object.assign)({}, $0, ({
                  context: $env.context,
                }));
              }))(),
            });
          }));
        }))(({
          first: c0Dict$empty,
          second: $env,
        }));
        const $envF = $10.second;
        const $taPas = $10.first;
        return ({
          first: (c0Compiler$TypedAst$PatternRecord)($pos, $taPas),
          second: $envF,
        });
      }))()
      : (((($8)[0] === "$TypeRecord") && ((($8)[1])[0] === "$Just"))
        ? ((() => {
          const $tyvarId = (($8)[1])[1];
          const $a = ($8)[2];
          return (u0Compiler$TypeCheck$bug)("can't annotate extensible types");
        }))()
        : (true
          ? ((() => {
            ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, u0Compiler$TypeCheck$ErrorNotCompatibleWithRecord, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $envF = ((($0) => {
              return (c0Dict$for)($0, $pas, (($name, $pa, $envX) => {
                const $out = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($envX, $expectedType.uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $out.env;
              }));
            }))($env);
            return ({
              first: (u0Compiler$TypeCheck$patternError)($pos),
              second: $envF,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1820:4', (sp_toHuman)($8))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$checkPattern = (($env, $expectedType, $pattern, $state) => {
  const $5 = ({
    first: $pattern,
    second: $expectedType.raw,
  });
  return ([
    ((($5.first)[0] === "$PatternAny")
      ? ((() => {
        const $pos = ($5.first)[1];
        const $maybeName = ($5.first)[2];
        const $maybeAnnotation = ($5.first)[3];
        const $newEnv = ((($maybeName)[0] === "$Nothing")
          ? $env
          : ((($maybeName)[0] === "$Just")
            ? ((() => {
              const $name = ($maybeName)[1];
              const $variable = ({
                definedAt: $pos,
                freeTyvars: c0Dict$empty,
                freeUnivars: c0Dict$empty,
                type: $expectedType,
              });
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: (c0Dict$insert)((c0Compiler$Ast$RefLocal)($name), $variable, $0.variables),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1777:16', (sp_toHuman)($maybeName))));
        return ({
          first: (c0Compiler$TypedAst$PatternAny)($pos, ({
            maybeName: $maybeName,
            type: $expectedType,
          })),
          second: $newEnv,
        });
      }))()
      : (((($5.first)[0] === "$PatternLiteralText") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
        ? ((() => {
          const $pos = ($5.first)[1];
          const $text = ($5.first)[2];
          const $typeUsr = ($5.second)[1];
          ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, u0Compiler$CoreDefs$textDef.usr), $env, $pos, (u0Compiler$TypeCheck$ErrorIncompatiblePattern)($pattern, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
          return ({
            first: (c0Compiler$TypedAst$PatternLiteralText)($pos, $text),
            second: $env,
          });
        }))()
        : (((($5.first)[0] === "$PatternLiteralNumber") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
          ? ((() => {
            const $pos = ($5.first)[1];
            const $text = ($5.first)[2];
            const $typeUsr = ($5.second)[1];
            ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, u0Compiler$CoreDefs$numberDef.usr), $env, $pos, (u0Compiler$TypeCheck$ErrorIncompatiblePattern)($pattern, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: (c0Compiler$TypedAst$PatternLiteralNumber)($pos, $text),
              second: $env,
            });
          }))()
          : ((($5.first)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($5.first)[1];
              const $usr = ($5.first)[2];
              const $arguments = ($5.first)[3];
              return ((__re__ = (u0Compiler$TypeCheck$checkPatternConstructor)($env, $pos, $expectedType, $usr, $arguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((($5.first)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($5.first)[1];
                const $completeness = ($5.first)[2];
                const $pas = ($5.first)[3];
                return ((__re__ = (u0Compiler$TypeCheck$checkPatternRecord)($env, $pos, $expectedType, $completeness, $pas, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1773:4', (sp_toHuman)($5))))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$checkParameter = (($env, $expectedParType, $par, $state) => {
  return ([
    ((($par)[0] === "$ParameterPattern")
      ? ((() => {
        const $originalUni = ($par)[1];
        const $pa = ($par)[2];
        const $5 = ((($expectedParType)[0] === "$ParRe")
          ? ((() => {
            ((__re__ = (u0Compiler$TypeCheck$addError)($env, (c0Compiler$CanonicalAst$patternPos)($pa), u0Compiler$TypeCheck$ErrorRecyclingDoesNotMatch, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $o = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($env, c0Compiler$Ast$Uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: ({
                raw: $o.patternType,
                uni: c0Compiler$Ast$Uni,
              }),
              second: ({
                first: $o.typedPattern,
                second: $o.env,
              }),
            });
          }))()
          : ((($expectedParType)[0] === "$ParSp")
            ? ((() => {
              const $full = ($expectedParType)[1];
              const $uni = (u0Compiler$TypeCheck$translateUni)($env.annotatedUnivarsByOriginalId, $originalUni);
              ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($uni, $full.uni), $env, (c0Compiler$CanonicalAst$patternPos)($pa), (u0Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter)($uni, $full), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: $full,
                second: ((__re__ = (u0Compiler$TypeCheck$checkPattern)($env, $full, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1197:16', (sp_toHuman)($expectedParType))));
        const $env1 = $5.second.second;
        const $typedPa = $5.second.first;
        const $fullType = $5.first;
        return ({
          first: (c0Compiler$TypedAst$ParameterPattern)($fullType, $typedPa),
          second: $env1,
        });
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? ((() => {
          const $num = ($par)[1];
          return ((($expectedParType)[0] === "$ParRe")
            ? (sp_todo)("TA.ParRe")
            : ((($expectedParType)[0] === "$ParSp")
              ? ((() => {
                const $type = ($expectedParType)[1];
                const $variable = ({
                  definedAt: c0Compiler$Pos$G,
                  freeTyvars: c0Dict$empty,
                  freeUnivars: c0Dict$empty,
                  type: $type,
                });
                return ({
                  first: (c0Compiler$TypedAst$ParameterPlaceholder)($type, $num),
                  second: ((() => {
                    const $0 = $env;
                    return (Object.assign)({}, $0, ({
                      variables: (c0Dict$insert)((c0Compiler$Ast$RefPlaceholder)($num), $variable, $0.variables),
                    }));
                  }))(),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1218:12', (sp_toHuman)($expectedParType))));
        }))()
        : ((($par)[0] === "$ParameterRecycle")
          ? ((() => {
            const $pos = ($par)[1];
            const $name = ($par)[2];
            const $expectedRaw = ((($expectedParType)[0] === "$ParSp")
              ? ((() => {
                const $full = ($expectedParType)[1];
                ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, u0Compiler$TypeCheck$ErrorRecyclingDoesNotMatch, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return c0Compiler$TypedAst$TypeError;
              }))()
              : ((($expectedParType)[0] === "$ParRe")
                ? ((() => {
                  const $raw = ($expectedParType)[1];
                  return $raw;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1236:16', (sp_toHuman)($expectedParType))));
            const $variable = ({
              definedAt: $pos,
              freeTyvars: c0Dict$empty,
              freeUnivars: c0Dict$empty,
              type: ({
                raw: $expectedRaw,
                uni: c0Compiler$Ast$Uni,
              }),
            });
            const $localEnv = ((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: (c0Dict$insert)((c0Compiler$Ast$RefLocal)($name), $variable, $0.variables),
              }));
            }))();
            return ({
              first: (c0Compiler$TypedAst$ParameterRecycle)($pos, $expectedRaw, $name),
              second: $localEnv,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1193:4', (sp_toHuman)($par))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$addConstraint = (($env, $pos, $id, $uni, $state) => {
  const $eq = ({
    context: u0Compiler$TypeCheck$Context_Global,
    id: $id,
    pos: $pos,
    uni: $uni,
    why: "-",
  });
  return ([
    ((__re__ = (u0Compiler$TypeCheck$solveUniquenessConstraint)($env, $eq, $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$TypeCheck$checkUni = (($env, $pos, $2, $state) => {
  const $given = $2.given;
  const $required = $2.required;
  const $5 = (u0Compiler$TypeCheck$uniCanBeCastTo)(({
    given: $given,
    required: $required,
  }));
  return ([
    ((($5)[0] === "$CanBeCastYes")
      ? null
      : (((($5)[0] === "$CanBeCastNo") && ((($5)[1])[0] === "$Nil"))
        ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorUniquenessDoesNotMatch)(({
          given: $given,
          required: $required,
        })), $state)), ($state = (__re__)[1]), (__re__)[0])
        : (((($5)[0] === "$CanBeCastNo") && ((($5)[1])[0] === "$Cons"))
          ? ((() => {
            const $univarId = (($5)[1])[1].first;
            const $uni = (($5)[1])[1].second;
            const $tail = (($5)[1])[2];
            return ((__re__ = (u0Compiler$TypeCheck$addConstraint)($env, $pos, $univarId, $uni, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 575:4', (sp_toHuman)($5))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$coreTypeBool = (c0Compiler$TypedAst$TypeExact)(u0Compiler$CoreDefs$boolUsr, c0Core$Nil);

const u0Compiler$TypeCheck$getVariableByRef = (($ref, $env) => {
  return (c0Dict$get)($ref, $env.variables);
});

const u0Compiler$TypeCheck$inferUni = (($a, $b) => {
  const $3 = ({
    first: $a,
    second: $b,
  });
  return ((($3.first)[0] === "$Imm")
    ? c0Compiler$Ast$Imm
    : ((($3.second)[0] === "$Imm")
      ? c0Compiler$Ast$Imm
      : (((($3.first)[0] === "$Depends") && (($3.second)[0] === "$Depends"))
        ? ((() => {
          const $aId = ($3.first)[1];
          const $bId = ($3.second)[1];
          return c0Compiler$Ast$Imm;
        }))()
        : ((($3.second)[0] === "$Depends")
          ? $b
          : (true
            ? c0Compiler$Ast$Uni
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 620:4', (sp_toHuman)($3)))))));
});

const u0Compiler$TypeCheck$doTry = (($env, $pos, $expectedRaw, $value, $caPatternsAndExpressions, $state) => {
  const $7 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $valueType = $7.second;
  const $typedValue = $7.first;
  const $8 = ((($0) => {
    return (c0List$forReversed)($0, $caPatternsAndExpressions, (($11, $10) => {
      const $u = $11.first;
      const $pa = $11.second;
      const $exp = $11.third;
      const $uniX = $10.first;
      const $acc = $10.second;
      const $patternOut = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($env, $u, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_TryPattern, $patternOut.patternType, $valueType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = (u0Compiler$TypeCheck$checkUni)($env, $pos, ({
        given: $valueType.uni,
        required: $u,
      }), $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $newEnv = ((() => {
        const $0 = $patternOut.env;
        return (Object.assign)({}, $0, ({
          context: u0Compiler$TypeCheck$Context_TryBranch,
        }));
      }))();
      const $12 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($newEnv, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $expressionType = $12.second;
      const $typedExpression = $12.first;
      ((__re__ = (u0Compiler$TypeCheck$addEquality)($newEnv, (c0Compiler$CanonicalAst$expressionPos)($exp), u0Compiler$TypeCheck$Why_TryExpression, $expectedRaw, $expressionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $uf = (u0Compiler$TypeCheck$inferUni)($uniX, $expressionType.uni);
      const $l = (sp_cons)(({
        first: $patternOut.typedPattern,
        second: $typedExpression,
      }), $acc);
      return ({
        first: $uf,
        second: $l,
      });
    }));
  }))(({
    first: c0Compiler$Ast$Uni,
    second: c0Core$Nil,
  }));
  const $patternsAndExpressions = $8.second;
  const $uni = $8.first;
  return ([
    ({
      first: (c0Compiler$TypedAst$Try)($pos, ({
        patternsAndExpressions: $patternsAndExpressions,
        value: $typedValue,
        valueType: $valueType,
      })),
      second: ({
        raw: $expectedRaw,
        uni: $uni,
      }),
    }),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferParam = (($env, $parIndex, $par, $state) => {
  return ([
    ((($par)[0] === "$ParameterRecycle")
      ? ((() => {
        const $pos = ($par)[1];
        const $name = ($par)[2];
        const $tyvarId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
        ((__re__ = (hash_insert)($state.boundTyvars, $tyvarId, null)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
        const $raw = (c0Compiler$TypedAst$TypeVar)($tyvarId);
        const $instance = ({
          definedAt: $pos,
          freeTyvars: c0Dict$empty,
          freeUnivars: c0Dict$empty,
          type: ({
            raw: $raw,
            uni: c0Compiler$Ast$Uni,
          }),
        });
        const $newEnv = ((() => {
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            variables: (c0Dict$insert)((c0Compiler$Ast$RefLocal)($name), $instance, $0.variables),
          }));
        }))();
        return ({
          first: (c0Compiler$TypedAst$ParameterRecycle)($pos, $raw, $name),
          second: (c0Compiler$TypedAst$ParRe)($raw),
          third: $newEnv,
        });
      }))()
      : ((($par)[0] === "$ParameterPattern")
        ? ((() => {
          const $uni = ($par)[1];
          const $pa = ($par)[2];
          const $out = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($env, $uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
          (c0Dict$each)((c0Compiler$TypedAst$typeTyvars)($out.patternType), (($tyvarId, _1) => {
            return ((__re__ = (hash_insert)($state.boundTyvars, $tyvarId, null)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
          }));
          const $full = ({
            raw: $out.patternType,
            uni: $uni,
          });
          return ({
            first: (c0Compiler$TypedAst$ParameterPattern)($full, $out.typedPattern),
            second: (c0Compiler$TypedAst$ParSp)($full),
            third: $out.env,
          });
        }))()
        : ((($par)[0] === "$ParameterPlaceholder")
          ? ((() => {
            const $num = ($par)[1];
            const $tyvarId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            ((__re__ = (hash_insert)($state.boundTyvars, $tyvarId, null)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
            const $raw = (c0Compiler$TypedAst$TypeVar)($tyvarId);
            const $univarId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $type = ({
              raw: $raw,
              uni: (c0Compiler$Ast$Depends)($univarId),
            });
            const $instance = ({
              definedAt: c0Compiler$Pos$G,
              freeTyvars: c0Dict$empty,
              freeUnivars: c0Dict$empty,
              type: $type,
            });
            const $newEnv = ((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: (c0Dict$insert)((c0Compiler$Ast$RefPlaceholder)($num), $instance, $0.variables),
              }));
            }))();
            return ({
              first: (c0Compiler$TypedAst$ParameterPlaceholder)($type, $num),
              second: (c0Compiler$TypedAst$ParSp)($type),
              third: $newEnv,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 953:4', (sp_toHuman)($par))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferFn = (($env, $pos, $caPars, $body, $state) => {
  let $typedPars = (array_fromList)(c0Core$Nil);
  let $parTypes = (array_fromList)(c0Core$Nil);
  const $newEnv = (c0List$indexedFor)($env, $caPars, (($index, $par, $envX) => {
    const $9 = ((__re__ = (u0Compiler$TypeCheck$inferParam)($envX, $index, $par, $state)), ($state = (__re__)[1]), (__re__)[0]);
    const $envX1 = $9.third;
    const $parType = $9.second;
    const $typedPar = $9.first;
    ((__re__ = (array_push)($typedPars, $typedPar)), ($typedPars = (__re__)[1]), (__re__)[0]);
    ((__re__ = (array_push)($parTypes, $parType)), ($parTypes = (__re__)[1]), (__re__)[0]);
    return $envX1;
  }));
  const $6 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)(((() => {
    const $0 = $newEnv;
    return (Object.assign)({}, $0, ({
      context: (u0Compiler$TypeCheck$Context_FnBody)($pos, $env.context),
    }));
  }))(), $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $bodyType = $6.second;
  const $typedBody = $6.first;
  const $type = (c0Compiler$TypedAst$TypeFn)(((__re__ = (array_toList)($parTypes)), ($parTypes = (__re__)[1]), (__re__)[0]), $bodyType);
  const $exp = (c0Compiler$TypedAst$Fn)($pos, ((__re__ = (array_toList)($typedPars)), ($typedPars = (__re__)[1]), (__re__)[0]), $typedBody, $bodyType);
  return ([
    ({
      first: $exp,
      second: ({
        raw: $type,
        uni: c0Compiler$Ast$Uni,
      }),
    }),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferRecord = (($env, $pos, $maybeExt, $caAttrs, $state) => {
  const $taAttrs = (c0Dict$map)((($name, $value) => {
    return ((__re__ = (u0Compiler$TypeCheck$inferExpression)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        context: (u0Compiler$TypeCheck$Context_Argument)($name, $0.context),
      }));
    }))(), $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }), $caAttrs);
  const $typedAttrs = (c0Dict$map)((($k, $v) => {
    return (c0Tuple$first)($v);
  }), $taAttrs);
  const $attrTypes = (c0Dict$map)((($k, $6) => {
    const $t = $6.second;
    return $t.raw;
  }), $taAttrs);
  const $uni = ((($0) => {
    return (c0Dict$for)($0, $taAttrs, (($k, $8, $u) => {
      const $full = $8.second;
      return (u0Compiler$TypeCheck$inferUni)($full.uni, $u);
    }));
  }))(c0Compiler$Ast$Uni);
  return ([
    ((($maybeExt)[0] === "$Nothing")
      ? ({
        first: (c0Compiler$TypedAst$Record)($pos, c0Maybe$Nothing, $typedAttrs),
        second: ({
          raw: (c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, $attrTypes),
          uni: $uni,
        }),
      })
      : ((($maybeExt)[0] === "$Just")
        ? ((() => {
          const $caExt = ($maybeExt)[1];
          const $6 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $caExt, $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $extType = $6.second;
          const $typedExt = $6.first;
          const $finalType = ((() => {
            const $7 = $extType.raw;
            return (((($7)[0] === "$TypeRecord") && ((($7)[1])[0] === "$Nothing"))
              ? ((() => {
                const $fixedTypes = ($7)[2];
                (c0Dict$each)($attrTypes, (($name, $valueType) => {
                  const $10 = (c0Dict$get)($name, $fixedTypes);
                  return ((($10)[0] === "$Nothing")
                    ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute)($name), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : ((($10)[0] === "$Just")
                      ? ((() => {
                        const $ty = ($10)[1];
                        return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_Record, $ty, $valueType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1152:28', (sp_toHuman)($10))));
                }));
                return $extType.raw;
              }))()
              : (((($7)[0] === "$TypeRecord") && ((($7)[1])[0] === "$Just"))
                ? ((() => {
                  const $tyvarId = (($7)[1])[1];
                  const $extensionAttrTypes = ($7)[2];
                  const $8 = (c0Dict$onlyBothOnly)($attrTypes, $extensionAttrTypes);
                  const $extensionOnly = $8.third;
                  const $both = $8.second;
                  const $expressionOnly = $8.first;
                  (c0Dict$each)($both, (($name, $9) => {
                    const $inAttr = $9.first;
                    const $extAttr = $9.second;
                    return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_Record, $inAttr, $extAttr, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }));
                  const $newExtId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                  return (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($newExtId), (c0Dict$join)($attrTypes, $extensionOnly));
                }))()
                : ((($7)[0] === "$TypeVar")
                  ? ((() => {
                    const $id = ($7)[1];
                    const $ty = (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0])), $attrTypes);
                    ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_RecordExt, $extType.raw, $ty, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $ty;
                  }))()
                  : (true
                    ? ((() => {
                      ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, u0Compiler$TypeCheck$ErrorNotCompatibleWithRecord, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return c0Compiler$TypedAst$TypeError;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1148:16', (sp_toHuman)($7))))));
          }))();
          return ({
            first: (c0Compiler$TypedAst$Record)($pos, (c0Maybe$Just)($typedExt), $typedAttrs),
            second: ({
              raw: $finalType,
              uni: (u0Compiler$TypeCheck$inferUni)($uni, $extType.uni),
            }),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1138:4', (sp_toHuman)($maybeExt)))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferRecordAccess = (($env, $pos, $attrName, $inferredType, $state) => {
  return ([
    (((($inferredType)[0] === "$TypeRecord") && ((($inferredType)[1])[0] === "$Nothing"))
      ? ((() => {
        const $attrTypes = ($inferredType)[2];
        const $6 = (c0Dict$get)($attrName, $attrTypes);
        return ((($6)[0] === "$Just")
          ? ((() => {
            const $type = ($6)[1];
            return $type;
          }))()
          : ((($6)[0] === "$Nothing")
            ? ((() => {
              ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute)($attrName), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return c0Compiler$TypedAst$TypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1071:12', (sp_toHuman)($6))));
      }))()
      : (((($inferredType)[0] === "$TypeRecord") && ((($inferredType)[1])[0] === "$Just"))
        ? ((() => {
          const $tyvarId = (($inferredType)[1])[1];
          const $extensionAttrTypes = ($inferredType)[2];
          const $6 = (c0Dict$get)($attrName, $extensionAttrTypes);
          return ((($6)[0] === "$Just")
            ? ((() => {
              const $type = ($6)[1];
              return $type;
            }))()
            : ((($6)[0] === "$Nothing")
              ? ((() => {
                const $newExtId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $newAttrType = ((__re__ = (u0Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $type = (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($newExtId), (c0Dict$insert)($attrName, $newAttrType, $extensionAttrTypes));
                ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_RecordAccess, (c0Compiler$TypedAst$TypeVar)($tyvarId), $type, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $newAttrType;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1082:12', (sp_toHuman)($6))));
        }))()
        : ((($inferredType)[0] === "$TypeVar")
          ? ((() => {
            const $id = ($inferredType)[1];
            const $newExtId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $newAttrType = (c0Compiler$TypedAst$TypeVar)(((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]));
            const $type = (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($newExtId), (c0Dict$ofOne)($attrName, $newAttrType));
            ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_RecordAccess, $inferredType, $type, $state)), ($state = (__re__)[1]), (__re__)[0]);
            return $newAttrType;
          }))()
          : (true
            ? ((() => {
              ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord)($attrName, $inferredType), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return c0Compiler$TypedAst$TypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1068:4', (sp_toHuman)($inferredType)))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferExpression = (($env, $caExpression, $state) => {
  return ([
    ((($caExpression)[0] === "$LiteralNumber")
      ? ((() => {
        const $pos = ($caExpression)[1];
        const $n = ($caExpression)[2];
        return ({
          first: (c0Compiler$TypedAst$LiteralNumber)($pos, $n),
          second: ({
            raw: u0Compiler$TypeCheck$coreTypeNumber,
            uni: c0Compiler$Ast$Uni,
          }),
        });
      }))()
      : ((($caExpression)[0] === "$LiteralText")
        ? ((() => {
          const $pos = ($caExpression)[1];
          const $text = ($caExpression)[2];
          return ({
            first: (c0Compiler$TypedAst$LiteralText)($pos, $text),
            second: ({
              raw: u0Compiler$TypeCheck$coreTypeText,
              uni: c0Compiler$Ast$Uni,
            }),
          });
        }))()
        : ((($caExpression)[0] === "$Variable")
          ? ((() => {
            const $pos = ($caExpression)[1];
            const $ref = ($caExpression)[2];
            const $ty = ((() => {
              const $4 = (u0Compiler$TypeCheck$getVariableByRef)($ref, $env);
              return ((($4)[0] === "$Nothing")
                ? ((() => {
                  ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return u0Compiler$TypeCheck$fullTypeError;
                }))()
                : ((($4)[0] === "$Just")
                  ? ((() => {
                    const $var = ($4)[1];
                    const $t = ((__re__ = (u0Compiler$TypeCheck$generalize)($env, $pos, $ref, $var, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $t;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 818:16', (sp_toHuman)($4))));
            }))();
            return ({
              first: (c0Compiler$TypedAst$Variable)($pos, $ref),
              second: $ty,
            });
          }))()
          : ((($caExpression)[0] === "$Constructor")
            ? ((() => {
              const $pos = ($caExpression)[1];
              const $usr = ($caExpression)[2];
              const $ty = ((() => {
                const $4 = (u0Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
                return ((($4)[0] === "$Nothing")
                  ? ((() => {
                    ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return u0Compiler$TypeCheck$fullTypeError;
                  }))()
                  : ((($4)[0] === "$Just")
                    ? ((() => {
                      const $cons = ($4)[1];
                      return ((__re__ = (u0Compiler$TypeCheck$generalize)($env, $pos, (c0Compiler$Ast$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 836:16', (sp_toHuman)($4))));
              }))();
              return ({
                first: (c0Compiler$TypedAst$Constructor)($pos, $usr),
                second: ((() => {
                  const $0 = $ty;
                  return (Object.assign)({}, $0, ({
                    uni: c0Compiler$Ast$Uni,
                  }));
                }))(),
              });
            }))()
            : ((($caExpression)[0] === "$Fn")
              ? ((() => {
                const $pos = ($caExpression)[1];
                const $caPars = ($caExpression)[2];
                const $body = ($caExpression)[3];
                return ((__re__ = (u0Compiler$TypeCheck$inferFn)($env, $pos, $caPars, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((($caExpression)[0] === "$Call")
                ? ((() => {
                  const $pos = ($caExpression)[1];
                  const $reference = ($caExpression)[2];
                  const $args = ($caExpression)[3];
                  return ((__re__ = (u0Compiler$TypeCheck$doCall)($env, $pos, c0Maybe$Nothing, $reference, $args, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : ((($caExpression)[0] === "$Record")
                  ? ((() => {
                    const $pos = ($caExpression)[1];
                    const $maybeExt = ($caExpression)[2];
                    const $attrs = ($caExpression)[3];
                    return ((__re__ = (u0Compiler$TypeCheck$inferRecord)($env, $pos, $maybeExt, $attrs, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($caExpression)[0] === "$RecordAccess")
                    ? ((() => {
                      const $pos = ($caExpression)[1];
                      const $attrName = ($caExpression)[2];
                      const $recordExpression = ($caExpression)[3];
                      const $4 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $recordExpression, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $inferredType = $4.second;
                      const $typedExpr = $4.first;
                      return ({
                        first: (c0Compiler$TypedAst$RecordAccess)($pos, $attrName, $typedExpr),
                        second: ((() => {
                          const $0 = $inferredType;
                          return (Object.assign)({}, $0, ({
                            raw: ((__re__ = (u0Compiler$TypeCheck$inferRecordAccess)($env, $pos, $attrName, $0.raw, $state)), ($state = (__re__)[1]), (__re__)[0]),
                          }));
                        }))(),
                      });
                    }))()
                    : ((($caExpression)[0] === "$LetIn")
                      ? ((() => {
                        const $def = ($caExpression)[1];
                        const $rest = ($caExpression)[2];
                        const $4 = ((($0) => {
                          return ((__re__ = (u0Compiler$TypeCheck$doDefinition)(c0Compiler$Ast$RefLocal, $env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        }))(({
                          directDeps: c0Dict$empty,
                          maybeBody: (c0Maybe$Just)($def.body),
                          pattern: $def.pattern,
                          uni: $def.uni,
                        }));
                        const $defEnv = $4.second;
                        const $typedDef = $4.first;
                        const $5 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($defEnv, $rest, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $restType = $5.second;
                        const $typedRest = $5.first;
                        return ({
                          first: (c0Compiler$TypedAst$LetIn)($typedDef, $typedRest, $restType),
                          second: $restType,
                        });
                      }))()
                      : ((($caExpression)[0] === "$If")
                        ? ((() => {
                          const $pos = ($caExpression)[1];
                          const $condition = ($caExpression)[2].condition;
                          const $false = ($caExpression)[2].false;
                          const $true = ($caExpression)[2].true;
                          const $4 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: u0Compiler$TypeCheck$Context_IfCondition,
                            }));
                          }))(), $condition, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $conditionType = $4.second;
                          const $typedCondition = $4.first;
                          ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_IfCondition, u0Compiler$TypeCheck$coreTypeBool, $conditionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $5 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: u0Compiler$TypeCheck$Context_IfTrue,
                            }));
                          }))(), $true, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $trueType = $5.second;
                          const $typedTrue = $5.first;
                          const $6 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: u0Compiler$TypeCheck$Context_IfFalse,
                            }));
                          }))(), $false, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $falseType = $6.second;
                          const $typedFalse = $6.first;
                          ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_IfBranches, $trueType.raw, $falseType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $expression = (c0Compiler$TypedAst$If)($pos, ({
                            condition: $typedCondition,
                            false: $typedFalse,
                            true: $typedTrue,
                          }));
                          const $uni = (u0Compiler$TypeCheck$inferUni)($trueType.uni, $falseType.uni);
                          return ({
                            first: $expression,
                            second: ({
                              raw: $trueType.raw,
                              uni: $uni,
                            }),
                          });
                        }))()
                        : ((($caExpression)[0] === "$Try")
                          ? ((() => {
                            const $pos = ($caExpression)[1];
                            const $patternsAndExpressions = ($caExpression)[2].patternsAndExpressions;
                            const $value = ($caExpression)[2].value;
                            return ((__re__ = (u0Compiler$TypeCheck$doTry)($env, $pos, ((__re__ = (u0Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]), $value, $patternsAndExpressions, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 808:4', (sp_toHuman)($caExpression))))))))))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$inferArgument = (($env, $arg, $state) => {
  return ([
    ((($arg)[0] === "$ArgumentExpression")
      ? ((() => {
        const $exp = ($arg)[1];
        const $4 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
        const $expType = $4.second;
        const $typedExp = $4.first;
        return (c0Compiler$TypedAst$ArgumentExpression)($expType, $typedExp);
      }))()
      : ((($arg)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $pos = ($arg)[1];
          const $name = ($arg)[2];
          const $attrPath = ($arg)[3];
          const $ref = (c0Compiler$Ast$RefLocal)($name);
          const $raw = ((() => {
            const $4 = (u0Compiler$TypeCheck$getVariableByRef)($ref, $env);
            return ((($4)[0] === "$Nothing")
              ? ((() => {
                ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0]);
                return c0Compiler$TypedAst$TypeError;
              }))()
              : ((($4)[0] === "$Just")
                ? ((() => {
                  const $var = ($4)[1];
                  return ((($0) => {
                    return (c0List$for)($0, $attrPath, (($attrName, $tyAcc) => {
                      return ((__re__ = (u0Compiler$TypeCheck$inferRecordAccess)($env, $pos, $attrName, $tyAcc, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }));
                  }))($var.type.raw);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1572:16', (sp_toHuman)($4))));
          }))();
          return (c0Compiler$TypedAst$ArgumentRecycle)($pos, $raw, $attrPath, $name);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1559:4', (sp_toHuman)($arg)))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$doCall = (($env, $pos, $maybeExpectedType, $reference, $givenArgs, $state) => {
  const $7 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $reference, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $inferredReferenceType = $7.second;
  const $typedReference = $7.first;
  const $typedArguments = ((($0) => {
    return (c0List$map)((($arg) => {
      return ((__re__ = (u0Compiler$TypeCheck$inferArgument)($env, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
    }), $0);
  }))($givenArgs);
  const $toTypeArg = (($arg) => {
    return ((($arg)[0] === "$ArgumentExpression")
      ? ((() => {
        const $full = ($arg)[1];
        return (c0Compiler$TypedAst$ParSp)($full);
      }))()
      : ((($arg)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $raw = ($arg)[2];
          return (c0Compiler$TypedAst$ParRe)($raw);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1473:8', (sp_toHuman)($arg))));
  });
  const $expectedReturnType = ((() => {
    const $8 = $inferredReferenceType.raw;
    return ((($8)[0] === "$TypeFn")
      ? ((() => {
        const $parTypes = ($8)[1];
        const $outType = ($8)[2];
        const $given = (c0List$length)($typedArguments);
        const $expected = (c0List$length)($parTypes);
        return ((sp_not_equal)($expected, $given)
          ? ((() => {
            ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorWrongNumberOfArguments)(({
              expected: $expected,
              given: $given,
              reference: $reference,
            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return u0Compiler$TypeCheck$fullTypeError;
          }))()
          : ((() => {
            (c0List$indexedEach2)($typedArguments, $parTypes, (($index, $givenArg, $parType) => {
              const $12 = ({
                first: $givenArg,
                second: $parType,
              });
              return (((($12.first)[0] === "$ArgumentRecycle") && (($12.second)[0] === "$ParRe"))
                ? ((() => {
                  const $p = ($12.first)[1];
                  const $givenRaw = ($12.first)[2];
                  const $attrPath = ($12.first)[3];
                  const $name = ($12.first)[4];
                  const $inferredRaw = ($12.second)[1];
                  const $13 = (u0Compiler$TypeCheck$getVariableByRef)((c0Compiler$Ast$RefLocal)($name), $env);
                  return ((($13)[0] === "$Nothing")
                    ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $p, (u0Compiler$TypeCheck$ErrorVariableNotFound)((c0Compiler$Ast$RefLocal)($name)), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : ((($13)[0] === "$Just")
                      ? ((() => {
                        const $instance = ($13)[1];
                        ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($instance.type.uni, c0Compiler$Ast$Uni), $env, $p, u0Compiler$TypeCheck$ErrorShouldBeUnique, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, (u0Compiler$TypeCheck$Why_Argument)($index), $givenRaw, $inferredRaw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1496:32', (sp_toHuman)($13))));
                }))()
                : (((($12.first)[0] === "$ArgumentExpression") && (($12.second)[0] === "$ParSp"))
                  ? ((() => {
                    const $givenFull = ($12.first)[1];
                    const $expr = ($12.first)[2];
                    const $inferredFull = ($12.second)[1];
                    ((__re__ = (u0Compiler$TypeCheck$checkUni)($env, $pos, ({
                      given: $givenFull.uni,
                      required: $inferredFull.uni,
                    }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, (u0Compiler$TypeCheck$Why_Argument)($index), $inferredFull.raw, $givenFull.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, u0Compiler$TypeCheck$ErrorUniquenessDoesNotMatchArgument, $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1493:24', (sp_toHuman)($12)))));
            }));
            return ((($maybeExpectedType)[0] === "$Nothing")
              ? $outType
              : ((($maybeExpectedType)[0] === "$Just")
                ? ((() => {
                  const $e = ($maybeExpectedType)[1];
                  ((__re__ = (u0Compiler$TypeCheck$checkUni)($env, $pos, ({
                    given: $outType.uni,
                    required: $e.uni,
                  }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_Annotation, $outType.raw, $e.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return $e;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1516:20', (sp_toHuman)($maybeExpectedType))));
          }))());
      }))()
      : ((($8)[0] === "$TypeVar")
        ? ((() => {
          const $id = ($8)[1];
          const $returnType = ((($maybeExpectedType)[0] === "$Just")
            ? ((() => {
              const $e = ($maybeExpectedType)[1];
              return $e;
            }))()
            : ((($maybeExpectedType)[0] === "$Nothing")
              ? ({
                raw: ((__re__ = (u0Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]),
                uni: c0Compiler$Ast$Imm,
              })
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1530:20', (sp_toHuman)($maybeExpectedType))));
          const $refTy = (c0Compiler$TypedAst$TypeFn)((c0List$map)($toTypeArg, $typedArguments), $returnType);
          ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_CalledAsFunction, $refTy, $inferredReferenceType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
          return $returnType;
        }))()
        : ((($8)[0] === "$TypeError")
          ? u0Compiler$TypeCheck$fullTypeError
          : (true
            ? ((() => {
              const $z = $8;
              ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorCallingANonFunction)($z), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return u0Compiler$TypeCheck$fullTypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1478:8', (sp_toHuman)($8))))));
  }))();
  return ([
    ({
      first: (c0Compiler$TypedAst$Call)($pos, $typedReference, $typedArguments),
      second: $expectedReturnType,
    }),
    $state,
  ]);
});

const u0Compiler$TypeCheck$checkExpression = (($env, $expectedType, $caExpression, $state) => {
  const $5 = ({
    first: $caExpression,
    second: $expectedType.raw,
  });
  return ([
    (((($5.first)[0] === "$LiteralNumber") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
      ? ((() => {
        const $pos = ($5.first)[1];
        const $n = ($5.first)[2];
        const $typeUsr = ($5.second)[1];
        ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, u0Compiler$CoreDefs$numberDef.usr), $env, $pos, (u0Compiler$TypeCheck$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
        return (c0Compiler$TypedAst$LiteralNumber)($pos, $n);
      }))()
      : (((($5.first)[0] === "$LiteralText") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[2])[0] === "$Nil")))
        ? ((() => {
          const $pos = ($5.first)[1];
          const $text = ($5.first)[2];
          const $typeUsr = ($5.second)[1];
          ((__re__ = (u0Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, u0Compiler$CoreDefs$textDef.usr), $env, $pos, (u0Compiler$TypeCheck$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
          return (c0Compiler$TypedAst$LiteralText)($pos, $text);
        }))()
        : ((($5.first)[0] === "$Variable")
          ? ((() => {
            const $pos = ($5.first)[1];
            const $ref = ($5.first)[2];
            const $__bleh__ = ((() => {
              const $6 = (u0Compiler$TypeCheck$getVariableByRef)($ref, $env);
              return ((($6)[0] === "$Nothing")
                ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((($6)[0] === "$Just")
                  ? ((() => {
                    const $var = ($6)[1];
                    const $full = ((__re__ = (u0Compiler$TypeCheck$generalize)($env, $pos, $ref, $var, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    ((__re__ = (u0Compiler$TypeCheck$checkUni)($env, $pos, ({
                      given: $full.uni,
                      required: $expectedType.uni,
                    }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_Annotation, $full.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1277:16', (sp_toHuman)($6))));
            }))();
            return (c0Compiler$TypedAst$Variable)($pos, $ref);
          }))()
          : (((($5.first)[0] === "$Constructor") && (($5.second)[0] === "$TypeExact"))
            ? ((() => {
              const $pos = ($5.first)[1];
              const $usr = ($5.first)[2];
              const $bleh = ((() => {
                const $6 = (u0Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
                return ((($6)[0] === "$Nothing")
                  ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0])
                  : ((($6)[0] === "$Just")
                    ? ((() => {
                      const $cons = ($6)[1];
                      const $full = ((__re__ = (u0Compiler$TypeCheck$generalize)($env, $pos, (c0Compiler$Ast$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_Annotation, $full.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1294:16', (sp_toHuman)($6))));
              }))();
              return (c0Compiler$TypedAst$Constructor)($pos, $usr);
            }))()
            : (((($5.first)[0] === "$Fn") && (($5.second)[0] === "$TypeFn"))
              ? ((() => {
                const $pos = ($5.first)[1];
                const $pars = ($5.first)[2];
                const $body = ($5.first)[3];
                const $parTypes = ($5.second)[1];
                const $out = ($5.second)[2];
                return ((sp_not_equal)((c0List$length)($pars), (c0List$length)($parTypes))
                  ? ((() => {
                    ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, u0Compiler$TypeCheck$ErrorWrongNumberOfParameters, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return (c0Compiler$TypedAst$Error)($pos);
                  }))()
                  : ((() => {
                    let $typedPars = (array_fromList)(c0Core$Nil);
                    let $parIndex = 0;
                    const $localEnv = ((($0) => {
                      return (c0List$for)($0, (c0List$map2)(c0Tuple$pair, $pars, $parTypes), (($8, $envX) => {
                        const $par = $8.first;
                        const $parType = $8.second;
                        const $9 = ((__re__ = (u0Compiler$TypeCheck$checkParameter)(((() => {
                          const $0 = $envX;
                          return (Object.assign)({}, $0, ({
                            context: (u0Compiler$TypeCheck$Context_FnPar)(((__re__ = (basics_cloneUni)($parIndex)), ($parIndex = (__re__)[1]), (__re__)[0]), $0.context),
                          }));
                        }))(), $parType, $par, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $envX1 = $9.second;
                        const $typedPar = $9.first;
                        ((__re__ = (array_push)($typedPars, $typedPar)), ($typedPars = (__re__)[1]), (__re__)[0]);
                        ($parIndex += 1);
                        const $0 = $envX1;
                        return (Object.assign)({}, $0, ({
                          context: $envX.context,
                        }));
                      }));
                    }))($env);
                    const $typedBody = ((__re__ = (u0Compiler$TypeCheck$checkExpression)($localEnv, $out, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return (c0Compiler$TypedAst$Fn)($pos, ((__re__ = (array_toList)($typedPars)), ($typedPars = (__re__)[1]), (__re__)[0]), $typedBody, $out);
                  }))());
              }))()
              : ((($5.first)[0] === "$Call")
                ? ((() => {
                  const $pos = ($5.first)[1];
                  const $reference = ($5.first)[2];
                  const $args = ($5.first)[3];
                  return (c0Tuple$first)(((__re__ = (u0Compiler$TypeCheck$doCall)($env, $pos, (c0Maybe$Just)($expectedType), $reference, $args, $state)), ($state = (__re__)[1]), (__re__)[0]));
                }))()
                : (((($5.first)[0] === "$Record") && (((($5.first)[2])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
                  ? ((() => {
                    const $pos = ($5.first)[1];
                    const $ext = (($5.first)[2])[1];
                    const $valueByName = ($5.first)[3];
                    const $typeByName = ($5.second)[2];
                    const $typedExt = ((__re__ = (u0Compiler$TypeCheck$checkExpression)($env, $expectedType, $ext, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    const $zzz = (($attrName, $attrExpr) => {
                      const $8 = (c0Dict$get)($attrName, $typeByName);
                      return ((($8)[0] === "$Nothing")
                        ? ((() => {
                          ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation)((c0Core$Cons)($attrName, c0Core$Nil)), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          return (c0Tuple$first)(((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $attrExpr, $state)), ($state = (__re__)[1]), (__re__)[0]));
                        }))()
                        : ((($8)[0] === "$Just")
                          ? ((() => {
                            const $attrType = ($8)[1];
                            const $fullAttrType = ({
                              raw: $attrType,
                              uni: $expectedType.uni,
                            });
                            return ((__re__ = (u0Compiler$TypeCheck$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: (u0Compiler$TypeCheck$Context_AttributeName)($attrName, $0.context),
                              }));
                            }))(), $fullAttrType, $attrExpr, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1351:20', (sp_toHuman)($8))));
                    });
                    const $typedValueByName = (c0Dict$map)($zzz, $valueByName);
                    return (c0Compiler$TypedAst$Record)($pos, (c0Maybe$Just)($typedExt), $typedValueByName);
                  }))()
                  : (((($5.first)[0] === "$Record") && (((($5.first)[2])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[1])[0] === "$Nothing"))))
                    ? ((() => {
                      const $pos = ($5.first)[1];
                      const $valueByName = ($5.first)[3];
                      const $typeByName = ($5.second)[2];
                      const $6 = (c0Dict$onlyBothOnly)($valueByName, $typeByName);
                      const $bOnly = $6.third;
                      const $both = $6.second;
                      const $aOnly = $6.first;
                      ((sp_not_equal)($aOnly, c0Dict$empty)
                        ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation)((c0Dict$keys)($aOnly)), $state)), ($state = (__re__)[1]), (__re__)[0])
                        : ((sp_not_equal)($bOnly, c0Dict$empty)
                          ? ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation)((c0Dict$keys)($bOnly)), $state)), ($state = (__re__)[1]), (__re__)[0])
                          : null));
                      const $typedAttrs = ((($0) => {
                        return (c0Dict$map)((($name, $8) => {
                          const $value = $8.first;
                          const $type = $8.second;
                          return ((__re__ = (u0Compiler$TypeCheck$checkExpression)($env, ({
                            raw: $type,
                            uni: $expectedType.uni,
                          }), $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        }), $0);
                      }))($both);
                      return (c0Compiler$TypedAst$Record)($pos, c0Maybe$Nothing, $typedAttrs);
                    }))()
                    : ((($5.first)[0] === "$RecordAccess")
                      ? ((() => {
                        const $pos = ($5.first)[1];
                        const $attrName = ($5.first)[2];
                        const $exp = ($5.first)[3];
                        const $6 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($env, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $expressionType = $6.second;
                        const $typedExpression = $6.first;
                        const $newId = ((__re__ = (u0Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $requiredType = ((($0) => {
                          return (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)($newId), $0);
                        }))(((($0) => {
                          return (c0Dict$ofOne)($attrName, $0);
                        }))($expectedType.raw));
                        ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_RecordAccess, $expressionType.raw, $requiredType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = (u0Compiler$TypeCheck$checkUni)($env, $pos, ({
                          given: $expressionType.uni,
                          required: $expectedType.uni,
                        }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return (c0Compiler$TypedAst$RecordAccess)($pos, $attrName, $typedExpression);
                      }))()
                      : ((($5.first)[0] === "$LetIn")
                        ? ((() => {
                          const $def = ($5.first)[1];
                          const $rest = ($5.first)[2];
                          const $6 = ((($0) => {
                            return ((__re__ = (u0Compiler$TypeCheck$doDefinition)(c0Compiler$Ast$RefLocal, $env, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))(({
                            directDeps: c0Dict$empty,
                            maybeBody: (c0Maybe$Just)($def.body),
                            pattern: $def.pattern,
                            uni: $def.uni,
                          }));
                          const $defEnv = $6.second;
                          const $typedDef = $6.first;
                          const $typedRest = ((__re__ = (u0Compiler$TypeCheck$checkExpression)($defEnv, $expectedType, $rest, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          return (c0Compiler$TypedAst$LetIn)($typedDef, $typedRest, $expectedType);
                        }))()
                        : ((($5.first)[0] === "$If")
                          ? ((() => {
                            const $pos = ($5.first)[1];
                            const $condition = ($5.first)[2].condition;
                            const $false = ($5.first)[2].false;
                            const $true = ($5.first)[2].true;
                            const $6 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: u0Compiler$TypeCheck$Context_IfCondition,
                              }));
                            }))(), $condition, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $conditionType = $6.second;
                            const $typedCondition = $6.first;
                            ((__re__ = (u0Compiler$TypeCheck$addEquality)($env, $pos, u0Compiler$TypeCheck$Why_IfCondition, u0Compiler$TypeCheck$coreTypeBool, $conditionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $typedTrue = ((__re__ = (u0Compiler$TypeCheck$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: u0Compiler$TypeCheck$Context_IfTrue,
                              }));
                            }))(), $expectedType, $true, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $typedFalse = ((__re__ = (u0Compiler$TypeCheck$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: u0Compiler$TypeCheck$Context_IfFalse,
                              }));
                            }))(), $expectedType, $false, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return (c0Compiler$TypedAst$If)($pos, ({
                              condition: $typedCondition,
                              false: $typedFalse,
                              true: $typedTrue,
                            }));
                          }))()
                          : ((($5.first)[0] === "$Try")
                            ? ((() => {
                              const $pos = ($5.first)[1];
                              const $patternsAndExpressions = ($5.first)[2].patternsAndExpressions;
                              const $value = ($5.first)[2].value;
                              const $6 = ((__re__ = (u0Compiler$TypeCheck$doTry)($env, $pos, $expectedType.raw, $value, $patternsAndExpressions, $state)), ($state = (__re__)[1]), (__re__)[0]);
                              const $fullType = $6.second;
                              const $typedExp = $6.first;
                              ((__re__ = (u0Compiler$TypeCheck$checkUni)($env, $pos, ({
                                given: $fullType.uni,
                                required: $expectedType.uni,
                              }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                              return $typedExp;
                            }))()
                            : ((($5.second)[0] === "$TypeError")
                              ? (c0Compiler$TypedAst$Error)((c0Compiler$CanonicalAst$expressionPos)($caExpression))
                              : (true
                                ? ((() => {
                                  const $pos = (c0Compiler$CanonicalAst$expressionPos)($caExpression);
                                  ((__re__ = (u0Compiler$TypeCheck$addError)($env, $pos, (u0Compiler$TypeCheck$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  return (c0Compiler$TypedAst$Error)($pos);
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1263:4', (sp_toHuman)($5)))))))))))))))),
    $state,
  ]);
});

const u0Compiler$TypeCheck$doDefinition = (($nameToRef, $baseEnv, $def, $state) => {
  let $parentBoundTyvars = ((__re__ = (basics_cloneUni)($state.boundTyvars)), ($state.boundTyvars = (__re__)[1]), (__re__)[0]);
  const $patternOut = ((__re__ = (u0Compiler$TypeCheck$inferPattern)($baseEnv, $def.uni, $def.pattern, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $localEnv = ((() => {
    const $0 = $patternOut.env;
    return (Object.assign)({}, $0, ({
      context: (u0Compiler$TypeCheck$Context_LetInBody)((c0Dict$keys)((c0Compiler$TypedAst$patternNames)($patternOut.typedPattern))),
    }));
  }))();
  const $5 = ((() => {
    const $6 = $def.maybeBody;
    return ((($6)[0] === "$Nothing")
      ? ({
        first: (c0Compiler$TypedAst$LiteralText)(c0Compiler$Pos$N, "native"),
        second: ({
          raw: $patternOut.patternType,
          uni: $def.uni,
        }),
      })
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $body = ($6)[1];
          const $7 = $patternOut.maybeFullAnnotation;
          return ((($7)[0] === "$Just")
            ? ((() => {
              const $annotation = ($7)[1];
              const $raw = ((__re__ = (u0Compiler$TypeCheck$translateAnnotationType)($localEnv, $state, $annotation.raw)), ($state = (__re__)[1]), (__re__)[0]);
              const $full = ({
                raw: $raw,
                uni: $def.uni,
              });
              return ({
                first: ((__re__ = (u0Compiler$TypeCheck$checkExpression)($localEnv, $full, $body, $state)), ($state = (__re__)[1]), (__re__)[0]),
                second: $full,
              });
            }))()
            : ((($7)[0] === "$Nothing")
              ? ((() => {
                const $8 = ((__re__ = (u0Compiler$TypeCheck$inferExpression)($localEnv, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
                const $inferredType = $8.second;
                const $typed = $8.first;
                const $pos = (c0Compiler$CanonicalAst$patternPos)($def.pattern);
                ((__re__ = (u0Compiler$TypeCheck$addEquality)($localEnv, $pos, u0Compiler$TypeCheck$Why_LetIn, $patternOut.patternType, $inferredType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                ((__re__ = (u0Compiler$TypeCheck$checkUni)($localEnv, $pos, ({
                  given: $inferredType.uni,
                  required: $def.uni,
                }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ({
                  first: $typed,
                  second: $inferredType,
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 675:16', (sp_toHuman)($7))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 669:8', (sp_toHuman)($6))));
  }))();
  const $bodyType = $5.second;
  const $typedBody = $5.first;
  const $defType = ({
    raw: ((__re__ = (u0Compiler$TypeCheck$applyAllSubs)($state, $bodyType.raw)), ($state = (__re__)[1]), (__re__)[0]),
    uni: $def.uni,
  });
  const $freeUnivars = ((($0) => {
    return (c0Dict$for)(c0Dict$empty, $0, (($annotatedId, _1, $acc) => {
      const $10 = (c0Dict$get)($annotatedId, $localEnv.annotatedUnivarsByOriginalId);
      return ((($10)[0] === "$Nothing")
        ? $acc
        : ((($10)[0] === "$Just")
          ? ((() => {
            const $newId = ($10)[1];
            return (c0Dict$insert)($newId, ({
              annotatedId: $annotatedId,
            }), $acc);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 713:12', (sp_toHuman)($10))));
    }));
  }))(((($0) => {
    return (c0List$for)(c0Dict$empty, $0, (($annotation, $acc) => {
      return (c0Dict$join)($annotation.univars, $acc);
    }));
  }))(((($0) => {
    return (c0List$filterMap)((($entry) => {
      return $entry.maybeAnnotation;
    }), $0);
  }))((c0Compiler$CanonicalAst$patternNames)($def.pattern))));
  const $freeTyvars = ((() => {
    const $allBindableTyvarsIn = (($tyvarId) => {
      const $7 = ((__re__ = (hash_get)($state.tyvarSubs, $tyvarId)), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
      return ((($7)[0] === "$Nothing")
        ? c0Set$empty
        : ((($7)[0] === "$Just")
          ? ((() => {
            const $raw = ($7)[1];
            return (c0Dict$map)((($k, $v) => {
              return null;
            }), (c0Compiler$TypedAst$typeTyvars)($raw));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 723:12', (sp_toHuman)($7))));
    });
    const $resolvedParentBoundTyvars = ((__re__ = (c0Hash$for_)(c0Set$empty, $parentBoundTyvars, (($parentTyvar, _1, $set) => {
      return ((($0) => {
        return (c0Set$for)($0, ($allBindableTyvarsIn)($parentTyvar), c0Set$insert);
      }))(((($0) => {
        return (c0Set$insert)($parentTyvar, $0);
      }))($set));
    }))), ($parentBoundTyvars = (__re__)[1]), (__re__)[0]);
    const $tyvarAnnotatedNameByTyvarId = (c0Dict$for)(c0Dict$empty, $localEnv.annotatedTyvarsByName, (($name, $tyvarId, $acc) => {
      return (c0Dict$insert)($tyvarId, $name, $acc);
    }));
    return ((($0) => {
      return (c0Dict$for)(c0Dict$empty, $0, (($id, _1, $acc) => {
        return ((c0Set$member)($id, $resolvedParentBoundTyvars)
          ? $acc
          : ((($0) => {
            return (c0Dict$insert)($id, $0, $acc);
          }))(((() => {
            const $10 = (c0Dict$get)($id, $tyvarAnnotatedNameByTyvarId);
            return ((($10)[0] === "$Nothing")
              ? ({
                maybeAnnotated: c0Maybe$Nothing,
              })
              : ((($10)[0] === "$Just")
                ? ((() => {
                  const $name = ($10)[1];
                  return ({
                    maybeAnnotated: (c0Maybe$Just)(({
                      allowFunctions: true,
                      name: $name,
                    })),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 742:16', (sp_toHuman)($10))));
          }))()));
      }));
    }))((c0Compiler$TypedAst$typeTyvars)($defType.raw));
  }))();
  const $caNames = ((($0) => {
    return (c0List$indexBy)((($e) => {
      return $e.name;
    }), $0);
  }))((c0Compiler$CanonicalAst$patternNames)($def.pattern));
  const $instance = (($name, $6) => {
    const $pos = $6.pos;
    const $unresolvedType = $6.type;
    const $type = ((() => {
      const $0 = $unresolvedType;
      return (Object.assign)({}, $0, ({
        raw: ((__re__ = (u0Compiler$TypeCheck$applyAllSubs)($state, $0.raw)), ($state = (__re__)[1]), (__re__)[0]),
      }));
    }))();
    const $typeTyvars = (c0Compiler$TypedAst$typeTyvars)($type.raw);
    const $actualTyvars = (c0Dict$filter)((($k, $v) => {
      return (c0Dict$member)($k, $typeTyvars);
    }), $freeTyvars);
    const $tryAsStillBreaksIfUsedImperatively = ((() => {
      const $8 = (c0Dict$get)($name, $caNames);
      return (((($8)[0] === "$Just") && ((($8)[1].maybeAnnotation)[0] === "$Just"))
        ? ((() => {
          const $annotation = (($8)[1].maybeAnnotation)[1];
          const $p = ($8)[1].pos;
          return ((__re__ = (u0Compiler$TypeCheck$addErrorIf)(((c0Dict$size)($annotation.tyvars) > (c0Dict$size)($actualTyvars)), $localEnv, $p, (u0Compiler$TypeCheck$ErrorTyvarNotIndependent)($name), $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : (true
          ? null
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 770:12', (sp_toHuman)($8))));
    }))();
    return ({
      definedAt: $pos,
      freeTyvars: $actualTyvars,
      freeUnivars: $freeUnivars,
      type: $type,
    });
  });
  const $variables = ((($0) => {
    return (c0Dict$for)($0, (c0Compiler$TypedAst$patternNames)($patternOut.typedPattern), (($name, $stuff, $vars) => {
      return (c0Dict$insert)(($nameToRef)($name), ($instance)($name, $stuff), $vars);
    }));
  }))($patternOut.env.variables);
  return ([
    ({
      first: ({
        body: $typedBody,
        directDeps: $def.directDeps,
        freeTyvars: $freeTyvars,
        freeUnivars: $freeUnivars,
        isFullyAnnotated: (sp_not_equal)($patternOut.maybeFullAnnotation, c0Maybe$Nothing),
        native: (sp_equal)($def.maybeBody, c0Maybe$Nothing),
        pattern: $patternOut.typedPattern,
        type: $defType,
      }),
      second: ((() => {
        const $0 = $baseEnv;
        return (Object.assign)({}, $0, ({
          variables: $variables,
        }));
      }))(),
    }),
    $state,
  ]);
});

const u0Compiler$TypeCheck$doRootDefinition = (($lastUnificationVarId, $errors, $usr, $envRaw, $def) => {
  const $env0 = ((() => {
    const $0 = $envRaw;
    return (Object.assign)({}, $0, ({
      currentRootUsr: $usr,
    }));
  }))();
  let $state = (u0Compiler$TypeCheck$initState)(((__re__ = (basics_cloneUni)($lastUnificationVarId)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  const $6 = $usr;
  const $umr = ($6)[1];
  const $nameToRef = (($name) => {
    return (c0Compiler$Ast$RefGlobal)((c0Compiler$Meta$USR)($umr, $name));
  });
  (sp_benchStart)(null);
  const $7 = ((($0) => {
    return ((__re__ = (u0Compiler$TypeCheck$doDefinition)($nameToRef, $env0, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }))(({
    directDeps: $def.directDeps,
    maybeBody: $def.maybeBody,
    pattern: (c0Compiler$CanonicalAst$PatternAny)($def.namePos, (c0Maybe$Just)($def.name), $def.maybeAnnotation),
    uni: c0Compiler$Ast$Imm,
  }));
  const $env1 = $7.second;
  const $typedDef = $7.first;
  (sp_benchStop)("type inference");
  (sp_benchStart)(null);
  const $subsAsFns = ({
    ty: (($tyvarId) => {
      return ((__re__ = (hash_get)($state.tyvarSubs, $tyvarId)), ($state.tyvarSubs = (__re__)[1]), (__re__)[0]);
    }),
    uni: (($univarId) => {
      return ((__re__ = (hash_get)($state.univarSubs, $univarId)), ($state.univarSubs = (__re__)[1]), (__re__)[0]);
    }),
  });
  const $resolvedValueDef = (c0Compiler$TypedAst$resolveValueDef)($subsAsFns, $typedDef);
  (sp_benchStop)("def resolution");
  ($lastUnificationVarId = ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  ((__re__ = (array_each)($state.errors, (($err) => {
    return ((__re__ = (array_push)($errors, $err)), ($errors = (__re__)[1]), (__re__)[0]);
  }))), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    ((($0) => {
      return ((__re__ = (u0Compiler$TypeCheck$addInstance)($lastUnificationVarId, $errors, $umr, $def, $0)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
    }))(((() => {
      const $0 = $env1;
      return (Object.assign)({}, $0, ({
        reversedRootValueDefs: (c0Core$Cons)(({
          first: $usr,
          second: $resolvedValueDef,
        }), $0.reversedRootValueDefs),
      }));
    }))()),
    $lastUnificationVarId,
    $errors,
  ]);
});

const u0Compiler$LazyBuild$typecheckDefinition = (($state, $errors, $lastUnificationVarId, $usr, $env0) => {
  const $6 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
  return ([
    ((($6)[0] === "$Nothing")
      ? (sp_todo)(("compiler bug, missing value usr" + (sp_toHuman)($usr)))
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $def = ($6)[1].def;
          const $deps = ($6)[1].deps;
          return ((($def)[0] === "$ValueDef")
            ? ((() => {
              const $valueDef = ($def)[1];
              return ((__re__ = (u0Compiler$TypeCheck$doRootDefinition)($lastUnificationVarId, $errors, $usr, $env0, $valueDef)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
            }))()
            : ((($def)[0] === "$ConstructorDef")
              ? ((() => {
                const $constructorDef = ($def)[1];
                return ((__re__ = (u0Compiler$TypeCheck$addConstructorToGlobalEnv)($errors, $constructorDef.name, $constructorDef, $env0)), ($errors = (__re__)[1]), (__re__)[0]);
              }))()
              : (true
                ? $env0
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 155:12', (sp_toHuman)($def)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 149:4', (sp_toHuman)($6)))),
    $state,
    $errors,
    $lastUnificationVarId,
  ]);
});

const u0Compiler$MakeEmittable$mkEnv = (($2, $modulesByUmr) => {
  const $umr = ($2)[1];
  const $name = ($2)[2];
  return ({
    genVarCounter: 0,
    module: ((() => {
      const $3 = (c0Dict$get)($umr, $modulesByUmr);
      return ((($3)[0] === "$Just")
        ? ((() => {
          const $m = ($3)[1];
          return $m;
        }))()
        : ((($3)[0] === "$Nothing")
          ? (sp_todo)(("compiler bug: no module for " + $name))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 12:10', (sp_toHuman)($3))));
    }))(),
  });
});

const u0Compiler$Error$positionToLineAndColumn = (($s, $index) => {
  const $before = (text_slice)(0, $index, $s);
  const $lines = (text_split)("\n", $before);
  const $lineNumber = (c0List$length)($lines);
  const $colNumber = ((($0) => {
    return (c0Maybe$withDefault)(0, $0);
  }))(((($0) => {
    return (c0Maybe$map)(text_length, $0);
  }))((c0List$last)($lines)));
  return ({
    col: $colNumber,
    line: $lineNumber,
  });
});

const u0Compiler$Error$highlightSplit = (($h, $x) => {
  const $3 = $x;
  const $lines = $3.second;
  const $words = $3.first;
  return ((($h)[0] === "$HighlightWord")
    ? ((() => {
      const $colEnd = ($h)[1].colEnd;
      const $colStart = ($h)[1].colStart;
      const $line = ($h)[1].line;
      return ({
        first: (c0Dict$insert)($line, ({
          first: $colStart,
          second: $colEnd,
        }), $words),
        second: $lines,
      });
    }))()
    : ((($h)[0] === "$HighlightBlock")
      ? ((() => {
        const $lineEnd = ($h)[1].lineEnd;
        const $lineStart = ($h)[1].lineStart;
        return ({
          first: $words,
          second: (c0List$for)($lines, (c0List$range)($lineStart, $lineEnd), c0Set$insert),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 129:4', (sp_toHuman)($h))));
});

const u0Compiler$Error$formatSeparator = "$|$|$";

const u0Compiler$Error$formatSuffix = "$`$`$";

const u0Compiler$Error$formatWrap = (($fmtName, $text) => {
  return (u0Compiler$Error$formatSeparator + ($fmtName + (u0Compiler$Error$formatSuffix + ($text + u0Compiler$Error$formatSeparator))));
});

const u0Compiler$Error$warn = (($0) => {
  return (u0Compiler$Error$formatWrap)("warning", $0);
});

const u0Compiler$Error$fmtBlock = (($start, $highlights, $ls) => {
  const $4 = (c0List$for)(({
    first: c0Dict$empty,
    second: c0Set$empty,
  }), $highlights, u0Compiler$Error$highlightSplit);
  const $highlightedLines = $4.second;
  const $highlightedWords = $4.first;
  const $pad = (text_length)((text_fromNumber)(($start + (c0List$length)($ls))));
  const $wordHighlight = (($lineNumber) => {
    const $6 = (c0Dict$get)($lineNumber, $highlightedWords);
    return ((($6)[0] === "$Nothing")
      ? ""
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $s = ($6)[1].first;
          const $e = ($6)[1].second;
          return ("\n" + ((c0Text$repeat)($pad, " ") + ("   " + ((c0Text$repeat)(($s - 1), " ") + (u0Compiler$Error$warn)((c0Text$repeat)((c0Basics$max)(1, ($e - $s)), "^"))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 146:8', (sp_toHuman)($6))));
  });
  const $lineDem = (($lineIndex) => {
    return ((c0Set$member)($lineIndex, $highlightedLines)
      ? (u0Compiler$Error$warn)(" > ")
      : " | ");
  });
  const $fmtLine = (($i, $line) => {
    const $index = ($i + $start);
    const $s = ((($0) => {
      return (c0Text$padLeft)($pad, " ", $0);
    }))((text_fromNumber)($index));
    return ($s + (($lineDem)($index) + ($line + ($wordHighlight)($index))));
  });
  return ((($s) => {
    return ($s + "\n");
  }))(((($0) => {
    return (c0Text$join)("\n", $0);
  }))(((($0) => {
    return (c0List$indexedMap)($fmtLine, $0);
  }))($ls)));
});

const u0Compiler$Error$showCodeBlock = (($code, $start, $end) => {
  return (($end.line < 0)
    ? ""
    : ((() => {
      const $highlight = ((sp_not_equal)($start.line, $end.line)
        ? (u0Compiler$Error$HighlightBlock)(({
          lineEnd: $end.line,
          lineStart: $start.line,
        }))
        : (u0Compiler$Error$HighlightWord)(({
          colEnd: $end.col,
          colStart: $start.col,
          line: $start.line,
        })));
      const $extraLines = 2;
      const $lines = (text_split)("\n", $code);
      const $maxLines = (c0List$length)($lines);
      const $startLine = (c0Basics$clamp)(0, ($maxLines - 1), ($start.line - ($extraLines - 1)));
      const $endLine = (c0Basics$clamp)(0, ($maxLines - 1), ($end.line + $extraLines));
      const $size = (c0Basics$max)(1, ($endLine - $startLine));
      return ((($0) => {
        return (u0Compiler$Error$fmtBlock)(($startLine + 1), (c0Core$Cons)($highlight, c0Core$Nil), $0);
      }))(((($0) => {
        return (c0List$take)($size, $0);
      }))(((($0) => {
        return (c0List$drop)($startLine, $0);
      }))($lines)));
    }))());
});

const u0Compiler$Error$posToHuman = (($mod, $pos) => {
  const $noBlock = (($loc) => {
    return ({
      block: "",
      location: $loc,
    });
  });
  return ((($pos)[0] === "$P")
    ? ((() => {
      const $startAsInt = ($pos)[1];
      const $endAsInt = ($pos)[2];
      const $start = (u0Compiler$Error$positionToLineAndColumn)($mod.content, $startAsInt);
      const $end = (u0Compiler$Error$positionToLineAndColumn)($mod.content, $endAsInt);
      return ({
        block: (u0Compiler$Error$showCodeBlock)($mod.content, $start, $end),
        location: ($mod.fsPath + (" " + ((text_fromNumber)($start.line) + (":" + (text_fromNumber)($start.col))))),
      });
    }))()
    : ((($pos)[0] === "$End")
      ? ((() => {
        const $end = (u0Compiler$Error$positionToLineAndColumn)($mod.content, ((text_length)($mod.content) - 1));
        const $start = ({
          col: 0,
          line: ($end.line - 8),
        });
        return ({
          block: (u0Compiler$Error$showCodeBlock)($mod.content, $start, $end),
          location: ($mod.fsPath + (" " + ((text_fromNumber)($end.line) + ":0 (end of file)"))),
        });
      }))()
      : ((($pos)[0] === "$N")
        ? ($noBlock)("<native code>")
        : ((($pos)[0] === "$S")
          ? ($noBlock)("<the location information has been stripped>")
          : ((($pos)[0] === "$T")
            ? ($noBlock)("<defined in test modules>")
            : ((($pos)[0] === "$I")
              ? ((() => {
                const $n = ($pos)[1];
                return ($noBlock)(("<inferred " + ((text_fromNumber)($n) + ">")));
              }))()
              : ((($pos)[0] === "$G")
                ? ($noBlock)("<generated>")
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 230:4', (sp_toHuman)($pos)))))))));
});

const u0Compiler$MakeEmittable$generateName = (($env) => {
  return ({
    first: (text_fromNumber)(($env.genVarCounter + 1)),
    second: ((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        genVarCounter: (1 + $0.genVarCounter),
      }));
    }))(),
  });
});

const u0Compiler$MakeEmittable$pickMainName = (($pattern) => {
  return (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Just"))
    ? ((() => {
      const $pos = ($pattern)[1];
      const $name = (($pattern)[2].maybeName)[1];
      const $type = ($pattern)[2].type;
      return (u0Compiler$MakeEmittable$TrivialPattern)($name, $type);
    }))()
    : (true
      ? ((sp_not_equal)((c0Compiler$TypedAst$patternNames)($pattern), c0Dict$empty)
        ? u0Compiler$MakeEmittable$GenerateName
        : u0Compiler$MakeEmittable$NoNamedVariables)
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 35:4', (sp_toHuman)($pattern))));
});

const u0Compiler$MakeEmittable$testPattern = (($pattern, $valueToTest, $accum) => {
  return ((($pattern)[0] === "$PatternAny")
    ? $accum
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $text = ($pattern)[2];
        return (sp_cons)((c0Compiler$EmittableAst$ShallowEqual)((c0Compiler$EmittableAst$LiteralText)($text), $valueToTest), $accum);
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $num = ($pattern)[2];
          return (sp_cons)((c0Compiler$EmittableAst$ShallowEqual)((c0Compiler$EmittableAst$LiteralNumber)($num), $valueToTest), $accum);
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $usr = ($pattern)[2];
            const $pas = ($pattern)[3];
            return ((($0) => {
              return (c0List$indexedFor)($0, $pas, (($index, $argPattern, $a) => {
                return (u0Compiler$MakeEmittable$testPattern)($argPattern, (c0Compiler$EmittableAst$ConstructorAccess)($index, $valueToTest), $a);
              }));
            }))((sp_cons)((c0Compiler$EmittableAst$IsConstructor)($usr, $valueToTest), $accum));
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $attrs = ($pattern)[2];
              return ((($0) => {
                return (c0Dict$for)($0, $attrs, (($name, $6, $a) => {
                  const $pa = $6.first;
                  const $type = $6.second;
                  return (u0Compiler$MakeEmittable$testPattern)($pa, (c0Compiler$EmittableAst$RecordAccess)($name, $valueToTest), $a);
                }));
              }))($accum);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 86:4', (sp_toHuman)($pattern)))))));
});

const u0Compiler$MakeEmittable$translateArgAndType = (($env, $taArg) => {
  return ((($taArg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $fullType = ($taArg)[1];
      const $exp = ($taArg)[2];
      return (c0Compiler$EmittableAst$ArgumentSpend)($fullType, (u0Compiler$MakeEmittable$translateExpression)($env, $exp));
    }))()
    : ((($taArg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $pos = ($taArg)[1];
        const $rawType = ($taArg)[2];
        const $attrPath = ($taArg)[3];
        const $name = ($taArg)[4];
        return (c0Compiler$EmittableAst$ArgumentRecycle)($rawType, $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 149:4', (sp_toHuman)($taArg))));
});

const u0Compiler$MakeEmittable$translatePatternRec = (($pattern, $accessExpr, $accum) => {
  return (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Nothing"))
    ? ((() => {
      const $type = ($pattern)[2].type;
      return $accum;
    }))()
    : (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $name = (($pattern)[2].maybeName)[1];
        const $type = ($pattern)[2].type;
        return (sp_cons)(({
          first: $type,
          second: $name,
          third: $accessExpr,
        }), $accum);
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? $accum
        : ((($pattern)[0] === "$PatternLiteralText")
          ? $accum
          : ((($pattern)[0] === "$PatternConstructor")
            ? ((() => {
              const $path = ($pattern)[2];
              const $pas = ($pattern)[3];
              return ((($0) => {
                return (c0List$indexedFor)($0, $pas, (($index, $pa, $a) => {
                  return (u0Compiler$MakeEmittable$translatePatternRec)($pa, (c0Compiler$EmittableAst$ConstructorAccess)($index, $accessExpr), $a);
                }));
              }))($accum);
            }))()
            : ((($pattern)[0] === "$PatternRecord")
              ? ((() => {
                const $attrs = ($pattern)[2];
                return ((($0) => {
                  return (c0Dict$for)($0, $attrs, (($name, $6, $a) => {
                    const $pa = $6.first;
                    const $type = $6.second;
                    return (u0Compiler$MakeEmittable$translatePatternRec)($pa, (c0Compiler$EmittableAst$RecordAccess)($name, $accessExpr), $a);
                  }));
                }))($accum);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 59:4', (sp_toHuman)($pattern))))))));
});

const u0Compiler$MakeEmittable$translatePattern = (($pattern, $accessExpr) => {
  return (u0Compiler$MakeEmittable$translatePatternRec)($pattern, $accessExpr, c0Core$Nil);
});

const u0Compiler$MakeEmittable$translateParameter = (($env, $bodyAcc, $param) => {
  return ((($param)[0] === "$ParameterRecycle")
    ? ((() => {
      const $pos = ($param)[1];
      const $rawType = ($param)[2];
      const $name = ($param)[3];
      return ({
        first: $bodyAcc,
        second: ({
          first: true,
          second: (c0Maybe$Just)($name),
        }),
      });
    }))()
    : ((($param)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $fullType = ($param)[1];
        const $n = ($param)[2];
        return ({
          first: $bodyAcc,
          second: ({
            first: false,
            second: (c0Maybe$Just)((text_fromNumber)($n)),
          }),
        });
      }))()
      : ((($param)[0] === "$ParameterPattern")
        ? ((() => {
          const $fullType = ($param)[1];
          const $pa = ($param)[2];
          const $4 = (u0Compiler$MakeEmittable$pickMainName)($pa);
          return ((($4)[0] === "$NoNamedVariables")
            ? ({
              first: $bodyAcc,
              second: ({
                first: false,
                second: c0Maybe$Nothing,
              }),
            })
            : ((($4)[0] === "$TrivialPattern")
              ? ((() => {
                const $argName = ($4)[1];
                const $type = ($4)[2];
                return ({
                  first: $bodyAcc,
                  second: ({
                    first: false,
                    second: (c0Maybe$Just)($argName),
                  }),
                });
              }))()
              : ((($4)[0] === "$GenerateName")
                ? ((() => {
                  const $5 = (u0Compiler$MakeEmittable$generateName)($env);
                  const $newEnv = $5.second;
                  const $mainName = $5.first;
                  const $namesAndExpressions = (u0Compiler$MakeEmittable$translatePattern)($pa, (c0Compiler$EmittableAst$Variable)((c0Compiler$Ast$RefLocal)($mainName)));
                  const $wrapWithArgumentLetIn = (($7, $inExpression) => {
                    const $type = $7.first;
                    const $varName = $7.second;
                    const $letExpression = $7.third;
                    return (c0Compiler$EmittableAst$LetIn)(({
                      inExpression: $inExpression,
                      letExpression: $letExpression,
                      maybeName: (c0Maybe$Just)($varName),
                      type: $type,
                    }));
                  });
                  return ({
                    first: (c0List$for)($bodyAcc, $namesAndExpressions, $wrapWithArgumentLetIn),
                    second: ({
                      first: false,
                      second: (c0Maybe$Just)($mainName),
                    }),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 119:12', (sp_toHuman)($4)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 110:4', (sp_toHuman)($param)))));
});

const u0Compiler$MakeEmittable$translateExpression = (($env, $expression) => {
  return ((($expression)[0] === "$LiteralNumber")
    ? ((() => {
      const $num = ($expression)[2];
      return (c0Compiler$EmittableAst$LiteralNumber)($num);
    }))()
    : ((($expression)[0] === "$LiteralText")
      ? ((() => {
        const $text = ($expression)[2];
        return (c0Compiler$EmittableAst$LiteralText)($text);
      }))()
      : ((($expression)[0] === "$Variable")
        ? ((() => {
          const $ref = ($expression)[2];
          return (c0Compiler$EmittableAst$Variable)($ref);
        }))()
        : ((($expression)[0] === "$Constructor")
          ? ((() => {
            const $usr = ($expression)[2];
            return (c0Compiler$EmittableAst$Constructor)($usr);
          }))()
          : ((($expression)[0] === "$RecordAccess")
            ? ((() => {
              const $attrName = ($expression)[2];
              const $exp = ($expression)[3];
              return (c0Compiler$EmittableAst$RecordAccess)($attrName, (u0Compiler$MakeEmittable$translateExpression)($env, $exp));
            }))()
            : ((($expression)[0] === "$Fn")
              ? ((() => {
                const $pos = ($expression)[1];
                const $taPars = ($expression)[2];
                const $body = ($expression)[3];
                const $bodyT = ($expression)[4];
                const $eaBody = (u0Compiler$MakeEmittable$translateExpression)(((() => {
                  const $0 = $env;
                  return (Object.assign)({}, $0, ({
                    genVarCounter: ((c0List$length)($taPars) + $0.genVarCounter),
                  }));
                }))(), $body);
                const $3 = ((($0) => {
                  return (c0List$forReversed)($0, $taPars, (($taPar, $5) => {
                    const $bodyAcc = $5.first;
                    const $eaParsAcc = $5.second;
                    const $7 = ((() => {
                      const $newEnv = ((() => {
                        const $0 = $env;
                        return (Object.assign)({}, $0, ({
                          genVarCounter: ((c0List$length)($eaParsAcc) + $0.genVarCounter),
                        }));
                      }))();
                      return (u0Compiler$MakeEmittable$translateParameter)($newEnv, $bodyAcc, $taPar);
                    }))();
                    const $eaPar = $7.second;
                    const $bodyX = $7.first;
                    return ({
                      first: $bodyX,
                      second: (sp_cons)($eaPar, $eaParsAcc),
                    });
                  }));
                }))(({
                  first: $eaBody,
                  second: c0Core$Nil,
                }));
                const $eaPars = $3.second;
                const $wrappedBody = $3.first;
                return (c0Compiler$EmittableAst$Fn)($eaPars, $wrappedBody);
              }))()
              : ((($expression)[0] === "$Record")
                ? ((() => {
                  const $extends = ($expression)[2];
                  const $attrs = ($expression)[3];
                  return ((($0) => {
                    return (c0Compiler$EmittableAst$LiteralRecord)((c0Maybe$map)((($0) => {
                      return (u0Compiler$MakeEmittable$translateExpression)($env, $0);
                    }), $extends), $0);
                  }))(((($0) => {
                    return (c0List$map)((($0) => {
                      return (c0Tuple$mapSecond)((($0) => {
                        return (u0Compiler$MakeEmittable$translateExpression)($env, $0);
                      }), $0);
                    }), $0);
                  }))(((($0) => {
                    return (list_sortBy)(c0Tuple$first, $0);
                  }))((c0Dict$toList)($attrs))));
                }))()
                : ((($expression)[0] === "$Call")
                  ? ((() => {
                    const $ref = ($expression)[2];
                    const $argsAndTypes = ($expression)[3];
                    return (c0Compiler$EmittableAst$Call)((u0Compiler$MakeEmittable$translateExpression)($env, $ref), (c0List$map)((($0) => {
                      return (u0Compiler$MakeEmittable$translateArgAndType)($env, $0);
                    }), $argsAndTypes));
                  }))()
                  : ((($expression)[0] === "$If")
                    ? ((() => {
                      const $ar = ($expression)[2];
                      return (c0Compiler$EmittableAst$Conditional)((u0Compiler$MakeEmittable$translateExpression)($env, $ar.condition), (u0Compiler$MakeEmittable$translateExpression)($env, $ar.true), (u0Compiler$MakeEmittable$translateExpression)($env, $ar.false));
                    }))()
                    : ((($expression)[0] === "$Try")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                        const $value = ($expression)[2].value;
                        const $valueType = ($expression)[2].valueType;
                        const $3 = ((() => {
                          const $4 = ({
                            first: $value,
                            second: $valueType.uni,
                          });
                          return (((($4.first)[0] === "$Variable") && (($4.second)[0] === "$Imm"))
                            ? ((() => {
                              const $ref = ($4.first)[2];
                              return ({
                                first: (c0Compiler$EmittableAst$Variable)($ref),
                                second: c0Basics$identity,
                                third: $env,
                              });
                            }))()
                            : (true
                              ? ((() => {
                                const $5 = (u0Compiler$MakeEmittable$generateName)($env);
                                const $env_ = $5.second;
                                const $tryName = $5.first;
                                const $wrap = (($tryExpression) => {
                                  return (c0Compiler$EmittableAst$LetIn)(({
                                    inExpression: $tryExpression,
                                    letExpression: (u0Compiler$MakeEmittable$translateExpression)($env_, $value),
                                    maybeName: (c0Maybe$Just)($tryName),
                                    type: $valueType,
                                  }));
                                });
                                return ({
                                  first: (c0Compiler$EmittableAst$Variable)((c0Compiler$Ast$RefLocal)($tryName)),
                                  second: $wrap,
                                  third: $env_,
                                });
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 206:16', (sp_toHuman)($4))));
                        }))();
                        const $newEnv = $3.third;
                        const $wrapWithLetIn = $3.second;
                        const $valueExpression = $3.first;
                        const $addTryPatternAndBlock = (($5, $nextTryExpression) => {
                          const $pattern = $5.first;
                          const $block = $5.second;
                          const $testIfPatternMatches = (c0Compiler$EmittableAst$And)((c0List$reverse)((u0Compiler$MakeEmittable$testPattern)($pattern, $valueExpression, c0Core$Nil)));
                          const $namesAndExpressions = (u0Compiler$MakeEmittable$translatePattern)($pattern, $valueExpression);
                          const $whenConditionMatches = ((($0) => {
                            return (c0List$for)($0, $namesAndExpressions, (($8, $inExpression) => {
                              const $type = $8.first;
                              const $name = $8.second;
                              const $letExpression = $8.third;
                              return (c0Compiler$EmittableAst$LetIn)(({
                                inExpression: $inExpression,
                                letExpression: $letExpression,
                                maybeName: (c0Maybe$Just)($name),
                                type: $type,
                              }));
                            }));
                          }))((u0Compiler$MakeEmittable$translateExpression)($newEnv, $block));
                          return (c0Compiler$EmittableAst$Conditional)($testIfPatternMatches, $whenConditionMatches, $nextTryExpression);
                        });
                        const $default = ((() => {
                          const $human = (u0Compiler$Error$posToHuman)(({
                            content: $env.module.asText,
                            fsPath: $env.module.fsPath,
                          }), $pos);
                          return (c0Compiler$EmittableAst$MissingPattern)($human.location, $valueExpression);
                        }))();
                        return ($wrapWithLetIn)(((($0) => {
                          return (c0List$forReversed)($0, $patternsAndExpressions, $addTryPatternAndBlock);
                        }))($default));
                      }))()
                      : ((($expression)[0] === "$LetIn")
                        ? ((() => {
                          const $valueDef = ($expression)[1];
                          const $e = ($expression)[2];
                          const $bodyType = ($expression)[3];
                          const $3 = (u0Compiler$MakeEmittable$pickMainName)($valueDef.pattern);
                          return ((($3)[0] === "$NoNamedVariables")
                            ? (c0Compiler$EmittableAst$LetIn)(({
                              inExpression: (u0Compiler$MakeEmittable$translateExpression)($env, $e),
                              letExpression: (u0Compiler$MakeEmittable$translateExpression)($env, $valueDef.body),
                              maybeName: c0Maybe$Nothing,
                              type: $valueDef.type,
                            }))
                            : ((($3)[0] === "$TrivialPattern")
                              ? ((() => {
                                const $defName = ($3)[1];
                                const $type = ($3)[2];
                                return (c0Compiler$EmittableAst$LetIn)(({
                                  inExpression: (u0Compiler$MakeEmittable$translateExpression)($env, $e),
                                  letExpression: (u0Compiler$MakeEmittable$translateExpression)($env, $valueDef.body),
                                  maybeName: (c0Maybe$Just)($defName),
                                  type: $type,
                                }));
                              }))()
                              : ((($3)[0] === "$GenerateName")
                                ? ((() => {
                                  const $4 = (u0Compiler$MakeEmittable$generateName)($env);
                                  const $newEnv = $4.second;
                                  const $mainName = $4.first;
                                  const $namesAndExpressions = (u0Compiler$MakeEmittable$translatePattern)($valueDef.pattern, (c0Compiler$EmittableAst$Variable)((c0Compiler$Ast$RefLocal)($mainName)));
                                  const $wrapWithUnpackedPatternVar = (($6, $inExpression) => {
                                    const $type = $6.first;
                                    const $name = $6.second;
                                    const $letExpression = $6.third;
                                    return (c0Compiler$EmittableAst$LetIn)(({
                                      inExpression: $inExpression,
                                      letExpression: $letExpression,
                                      maybeName: (c0Maybe$Just)($name),
                                      type: $type,
                                    }));
                                  });
                                  const $wrapWithActualLetIn = (($inExpression) => {
                                    return (c0Compiler$EmittableAst$LetIn)(({
                                      inExpression: $inExpression,
                                      letExpression: (u0Compiler$MakeEmittable$translateExpression)($newEnv, $valueDef.body),
                                      maybeName: (c0Maybe$Just)($mainName),
                                      type: $valueDef.type,
                                    }));
                                  });
                                  return ($wrapWithActualLetIn)(((($0) => {
                                    return (c0List$forReversed)($0, $namesAndExpressions, $wrapWithUnpackedPatternVar);
                                  }))((u0Compiler$MakeEmittable$translateExpression)($newEnv, $e)));
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 256:12', (sp_toHuman)($3)))));
                        }))()
                        : ((($expression)[0] === "$DestroyIn")
                          ? ((() => {
                            const $name = ($expression)[1];
                            const $e = ($expression)[2];
                            return (u0Compiler$MakeEmittable$translateExpression)($env, $e);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 156:4', (sp_toHuman)($expression))))))))))))));
});

const u0Compiler$TypeCheck$initEnv = (($projectImports, $modulesByUmr) => {
  return ({
    annotatedTyvarsByName: c0Dict$empty,
    annotatedUnivarsByOriginalId: c0Dict$empty,
    constructors: c0Dict$empty,
    context: u0Compiler$TypeCheck$Context_Global,
    currentRootUsr: (u0Compiler$CoreDefs$usr)("error"),
    exactTypes: c0Dict$empty,
    expandedAliases: c0Dict$empty,
    modulesByUmr: $modulesByUmr,
    projectImports: $projectImports,
    reversedRootValueDefs: c0Core$Nil,
    variables: c0Dict$empty,
  });
});

const u0Compiler$UniquenessCheck$addPatternToEnv = (($errors, $pattern, $env) => {
  const $names = (c0Compiler$TypedAst$patternNames)($pattern);
  const $insertVariable = (($name, $5, $z) => {
    const $pos = $5.pos;
    const $type = $5.type;
    const $mode = ((sp_equal)($type.uni, c0Compiler$Ast$Imm)
      ? u0Compiler$UniquenessCheck$Immutable
      : (u0Compiler$UniquenessCheck$Unique)(u0Compiler$UniquenessCheck$Available));
    const $variable = ({
      definedAt: $pos,
      mode: $mode,
      name: $name,
      required: c0Dict$empty,
      type: $type,
    });
    return (c0Dict$insert)($name, $variable, $z);
  });
  const $localEnv = ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      variables: (c0Dict$for)($0.variables, $names, $insertVariable),
    }));
  }))();
  const $uniques = ((($0) => {
    return (c0Dict$map)((($n, $s) => {
      return $s.pos;
    }), $0);
  }))(((($0) => {
    return (c0Dict$filter)((($n, $s) => {
      return (sp_not_equal)($s.type.uni, c0Compiler$Ast$Imm);
    }), $0);
  }))($names));
  return ([
    ({
      first: (c0Dict$keys)($names),
      second: $uniques,
      third: $localEnv,
    }),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$consumeInEnv = (($spent, $env) => {
  const $translate = (($name, $variable) => {
    const $5 = (c0Dict$get)($name, $spent);
    return ((($5)[0] === "$Nothing")
      ? $variable
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $pos = ($5)[1];
          const $0 = $variable;
          return (Object.assign)({}, $0, ({
            mode: (u0Compiler$UniquenessCheck$Unique)((u0Compiler$UniquenessCheck$ConsumedAt)($pos)),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 290:12', (sp_toHuman)($5))));
  });
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: (c0Dict$map)($translate, $0.variables),
  }));
});

const u0Compiler$UniquenessCheck$getErrorModule = (($env) => {
  const $2 = $env.usr;
  const $umr = ($2)[1];
  const $3 = (c0Dict$get)($umr, $env.modulesByUmr);
  return ((($3)[0] === "$Nothing")
    ? ({
      content: "",
      fsPath: "N/A",
    })
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $content = ($3)[1].asText;
        const $fsPath = ($3)[1].fsPath;
        return ({
          content: $content,
          fsPath: $fsPath,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 48:4', (sp_toHuman)($3))));
});

const u0Compiler$UniquenessCheck$addError = (($env, $pos, $errors, $messageConstructor) => {
  return ([
    ((__re__ = (array_push)($errors, (u0Compiler$Error$Simple)((u0Compiler$UniquenessCheck$getErrorModule)($env), $pos, $messageConstructor))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorMutatingAConsumed = (($env, $name, $p2, $p1, $errors) => {
  const $6 = (u0Compiler$Error$posToHuman)((u0Compiler$UniquenessCheck$getErrorModule)($env), $p2);
  const $location = $6.location;
  const $block = $6.block;
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $p1, $errors, (c0Core$Cons)(("This code spends the unique variable `" + ($name + ("`, but `" + ($name + "` is being used again here:")))), (c0Core$Cons)("", (c0Core$Cons)($block, (c0Core$Cons)("", (c0Core$Cons)("If you want to use a unique more than once, you need to use a function that recycles it.", (c0Core$Cons)("TODO: link to uniqueness wiki page", c0Core$Nil)))))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorMutatingAnImmutable = (($env, $name, $p, $errors) => {
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $p, $errors, (c0Core$Cons)(($name + " is immutable, but you are trying to mutate it"), c0Core$Nil))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorMutatingTwice = (($env, $name, $p1, $p2, $errors) => {
  const $6 = (u0Compiler$Error$posToHuman)((u0Compiler$UniquenessCheck$getErrorModule)($env), $p2);
  const $location = $6.location;
  const $block = $6.block;
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $p1, $errors, (c0Core$Cons)(($name + " is already being mutated here: "), (c0Core$Cons)($block, (c0Core$Cons)("You can't use the same unique twice in the same function call", (c0Core$Cons)("TODO: link to wiki explaining why", c0Core$Nil)))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorReferencingConsumedVariable = (($env, $name, $pos, $consumedPos, $errors) => {
  const $6 = (u0Compiler$Error$posToHuman)((u0Compiler$UniquenessCheck$getErrorModule)($env), $pos);
  const $location = $6.location;
  const $block = $6.block;
  const $cons = (u0Compiler$Error$posToHuman)((u0Compiler$UniquenessCheck$getErrorModule)($env), $consumedPos);
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $pos, $errors, (c0Core$Cons)(("You can't reference again the variable `" + ($name + "` because it was used already here:")), (c0Core$Cons)($cons.block, c0Core$Nil)))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorUndefinedVariable = (($env, $p, $name, $errors) => {
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $p, $errors, (c0Core$Cons)(("undefined variable: " + $name), c0Core$Nil))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$doArgument = (($env, $errors, $pos, $doneSoFar) => {
  const $5 = $doneSoFar.resolved;
  return ([
    ((($5)[0] === "$ArgumentExpression")
      ? ((() => {
        const $fullType = ($5)[1];
        const $expr = ($5)[2];
        const $doneExpression = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $expr)), ($errors = (__re__)[1]), (__re__)[0]);
        (c0Dict$each)($doneExpression.spent, (($name, $p1) => {
          const $8 = (c0Dict$get)($name, $doneSoFar.spent);
          return ((($8)[0] === "$Nothing")
            ? null
            : ((($8)[0] === "$Just")
              ? ((() => {
                const $p2 = ($8)[1];
                return ((__re__ = (u0Compiler$UniquenessCheck$errorReferencingConsumedVariable)($env, $name, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 397:16', (sp_toHuman)($8))));
        }));
        return ({
          recycled: $doneSoFar.recycled,
          required: (c0Dict$join)($doneExpression.required, $doneSoFar.required),
          resolved: (c0Compiler$TypedAst$ArgumentExpression)($fullType, $doneExpression.resolved),
          spent: (c0Dict$join)($doneExpression.spent, $doneSoFar.spent),
        });
      }))()
      : ((($5)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $p1 = ($5)[1];
          const $rawType = ($5)[2];
          const $attrPath = ($5)[3];
          const $name = ($5)[4];
          const $x = ((() => {
            const $6 = (c0Dict$get)($name, $env.variables);
            return ((($6)[0] === "$Nothing")
              ? ((__re__ = (u0Compiler$UniquenessCheck$errorUndefinedVariable)($env, $p1, $name, $errors)), ($errors = (__re__)[1]), (__re__)[0])
              : ((($6)[0] === "$Just")
                ? ((() => {
                  const $variable = ($6)[1];
                  const $7 = $variable.mode;
                  return (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$Available"))
                    ? null
                    : ((($7)[0] === "$Immutable")
                      ? ((__re__ = (u0Compiler$UniquenessCheck$errorMutatingAnImmutable)($env, $name, $p1, $errors)), ($errors = (__re__)[1]), (__re__)[0])
                      : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$ConsumedAt"))
                        ? ((() => {
                          const $p2 = (($7)[1])[1];
                          return ((__re__ = (u0Compiler$UniquenessCheck$errorMutatingAConsumed)($env, $name, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 420:24', (sp_toHuman)($7)))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 414:16', (sp_toHuman)($6))));
          }))();
          const $y = ((() => {
            const $6 = (c0Dict$get)($name, $doneSoFar.recycled);
            return ((($6)[0] === "$Nothing")
              ? null
              : ((($6)[0] === "$Just")
                ? ((() => {
                  const $p2 = ($6)[1];
                  return ((__re__ = (u0Compiler$UniquenessCheck$errorMutatingTwice)($env, $name, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 426:16', (sp_toHuman)($6))));
          }))();
          const $0 = $doneSoFar;
          return (Object.assign)({}, $0, ({
            recycled: (c0Dict$insert)($name, $p1, $doneSoFar.recycled),
            resolved: (c0Compiler$TypedAst$ArgumentRecycle)($p1, $rawType, $attrPath, $name),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 390:4', (sp_toHuman)($5)))),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions = (($env, $callPos, $name, $required, $errors) => {
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $callPos, $errors, (c0Core$Cons)(("This function call could allow some unique values (" + (((($0) => {
      return (c0Text$join)(", ", $0);
    }))((c0Dict$keys)($required)) + ")")), (c0Core$Cons)(("to be recycled by a functions contained in the argument `" + ($name + "` outside of the scope where they were declared.")), (c0Core$Cons)("This would be BAD. [TODO link to wiki]", (c0Core$Cons)("TODO improve this explanation.", c0Core$Nil)))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$uniOutInit = (($a) => {
  return ({
    recycled: c0Dict$empty,
    required: c0Dict$empty,
    resolved: $a,
    spent: c0Dict$empty,
  });
});

const u0Compiler$UniquenessCheck$uniOutMap = (($f, $1) => {
  const $recycled = $1.recycled;
  const $required = $1.required;
  const $resolved = $1.resolved;
  const $spent = $1.spent;
  return ({
    recycled: $recycled,
    required: $required,
    resolved: ($f)($resolved),
    spent: $spent,
  });
});

const u0Compiler$UniquenessCheck$doCall = (($env, $errors, $pos, $reference, $arguments) => {
  const $doneReference = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $reference)), ($errors = (__re__)[1]), (__re__)[0]);
  const $doneArgs = ((($0) => {
    return (c0List$forReversed)($0, $arguments, (($arg, $acc) => {
      return ((($0) => {
        return (u0Compiler$UniquenessCheck$uniOutMap)((($resolvedArg) => {
          return (sp_cons)($resolvedArg, $acc.resolved);
        }), $0);
      }))(((($0) => {
        return ((__re__ = (u0Compiler$UniquenessCheck$doArgument)($env, $errors, $pos, $0)), ($errors = (__re__)[1]), (__re__)[0]);
      }))(((($0) => {
        return (u0Compiler$UniquenessCheck$uniOutMap)(((_0) => {
          return $arg;
        }), $0);
      }))($acc)));
    }));
  }))((u0Compiler$UniquenessCheck$uniOutInit)(c0Core$Nil));
  const $asRecyclingFunction = (($arg) => {
    return ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $path = ($arg)[3];
        const $name = ($arg)[4];
        return ((c0Compiler$TypedAst$typeAllowsFunctions)((($tyvarId) => {
          return false;
        }), $raw)
          ? (c0Maybe$Just)($name)
          : c0Maybe$Nothing);
      }))()
      : ((($arg)[0] === "$ArgumentExpression")
        ? c0Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 354:8', (sp_toHuman)($arg))));
  });
  (((sp_not_equal)($doneArgs.required, c0Dict$empty) || (sp_not_equal)($doneReference.required, c0Dict$empty))
    ? (c0List$each)((c0List$filterMap)($asRecyclingFunction, $arguments), (($name) => {
      return ((__re__ = (u0Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions)($env, $pos, $name, (c0Dict$join)($doneArgs.required, $doneReference.required), $errors)), ($errors = (__re__)[1]), (__re__)[0]);
    }))
    : null);
  return ([
    ({
      recycled: (c0Dict$join)($doneReference.recycled, $doneArgs.recycled),
      required: $doneArgs.required,
      resolved: (c0Compiler$TypedAst$Call)($pos, $doneReference.resolved, $doneArgs.resolved),
      spent: (c0Dict$join)($doneReference.spent, $doneArgs.spent),
    }),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$doParameter = (($errors, $par, $acc) => {
  return ([
    ((($par)[0] === "$ParameterPattern")
      ? ((() => {
        const $fullType = ($par)[1];
        const $pa = ($par)[2];
        const $4 = ((__re__ = (u0Compiler$UniquenessCheck$addPatternToEnv)($errors, $pa, $acc.localEnv)), ($errors = (__re__)[1]), (__re__)[0]);
        const $localEnv = $4.third;
        const $uniques = $4.second;
        const $addedVars = $4.first;
        const $0 = $acc;
        return (Object.assign)({}, $0, ({
          localEnv: $localEnv,
          parsToBeSpent: (c0Dict$join)($uniques, $0.parsToBeSpent),
        }));
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? ((() => {
          const $fullType = ($par)[1];
          const $n = ($par)[2];
          const $pa = (c0Compiler$TypedAst$PatternAny)(c0Compiler$Pos$G, ({
            maybeName: (c0Maybe$Just)((text_fromNumber)($n)),
            type: $fullType,
          }));
          const $4 = ((__re__ = (u0Compiler$UniquenessCheck$addPatternToEnv)($errors, $pa, $acc.localEnv)), ($errors = (__re__)[1]), (__re__)[0]);
          const $localEnv = $4.third;
          const $uniques = $4.second;
          const $addedVars = $4.first;
          const $0 = $acc;
          return (Object.assign)({}, $0, ({
            localEnv: $localEnv,
            parsToBeSpent: (c0Dict$join)($uniques, $0.parsToBeSpent),
          }));
        }))()
        : ((($par)[0] === "$ParameterRecycle")
          ? ((() => {
            const $pos = ($par)[1];
            const $rawType = ($par)[2];
            const $name = ($par)[3];
            const $var = ({
              definedAt: $pos,
              mode: (u0Compiler$UniquenessCheck$Unique)(u0Compiler$UniquenessCheck$Available),
              name: $name,
              required: c0Dict$empty,
              type: ({
                raw: $rawType,
                uni: c0Compiler$Ast$Uni,
              }),
            });
            const $0 = $acc;
            return (Object.assign)({}, $0, ({
              localEnv: ((() => {
                const $1 = $acc.localEnv;
                return (Object.assign)({}, $1, ({
                  variables: (c0Dict$insert)($name, $var, $1.variables),
                }));
              }))(),
              parsToBeRecycled: (c0Dict$insert)($name, $pos, $0.parsToBeRecycled),
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 448:4', (sp_toHuman)($par))))),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorConsumingRecycledParameters = (($env, $pos, $spentThatShouldHaveBeenRecycled, $errors) => {
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $pos, $errors, (c0Core$Cons)("errorConsumingRecycledParameters", (c0Core$Cons)((sp_toHuman)($spentThatShouldHaveBeenRecycled), c0Core$Nil)))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques = (($env, $functionPos, $spentFromParent, $errors) => {
  const $zzz = (($5) => {
    const $name = $5.first;
    const $spentPos = $5.second;
    const $6 = (u0Compiler$Error$posToHuman)((u0Compiler$UniquenessCheck$getErrorModule)($env), $spentPos);
    const $location = $6.location;
    const $block = $6.block;
    return ($block + "\n");
  });
  const $blocks = ((($0) => {
    return (c0List$map)($zzz, $0);
  }))(((($0) => {
    return (list_sortBy)(c0Tuple$second, $0);
  }))((c0Dict$toList)($spentFromParent)));
  return ([
    ((($0) => {
      return ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $functionPos, $errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
    }))((c0List$concat)((c0Core$Cons)((c0Core$Cons)(("This function is spending the unique variable `" + (((($0) => {
      return (c0Text$join)("`, `", $0);
    }))((c0Dict$keys)($spentFromParent)) + "`")), c0Core$Nil), (c0Core$Cons)((c0Core$Cons)("", c0Core$Nil), (c0Core$Cons)($blocks, (c0Core$Cons)((c0Core$Cons)("However, functions cannot spend uniques that were declared outside their body.", c0Core$Nil), c0Core$Nil)))))),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope = (($env, $name, $2, $errors) => {
  const $fnPos = $2.fnPos;
  const $usedAt = $2.usedAt;
  const $5 = (u0Compiler$Error$posToHuman)((u0Compiler$UniquenessCheck$getErrorModule)($env), $usedAt);
  const $location = $5.location;
  const $block = $5.block;
  return ([
    ((__re__ = (u0Compiler$UniquenessCheck$addError)($env, $fnPos, $errors, (c0Core$Cons)(("This expression needs to access the unique variable `" + ($name + "` because it uses it here:")), (c0Core$Cons)("", (c0Core$Cons)($block, (c0Core$Cons)("", (c0Core$Cons)(("The problem is that returning a function from the expression could allow accessing `" + ($name + ("` from outside of where `" + ($name + "` was declared.")))), (c0Core$Cons)("This would be BAD. [TODO link to wiki]", c0Core$Nil)))))))), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$doFn = (($env, $pos, $errors, $pars, $body, $bodyType) => {
  const $7 = ((($0) => {
    return (c0List$for)($0, $pars, (($0, $1) => {
      return ((__re__ = (u0Compiler$UniquenessCheck$doParameter)($errors, $0, $1)), ($errors = (__re__)[1]), (__re__)[0]);
    }));
  }))(({
    localEnv: $env,
    parsToBeRecycled: c0Dict$empty,
    parsToBeSpent: c0Dict$empty,
  }));
  const $parsToBeSpent = $7.parsToBeSpent;
  const $parsToBeRecycled = $7.parsToBeRecycled;
  const $localEnv = $7.localEnv;
  const $doneBody = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($localEnv, $errors, $body)), ($errors = (__re__)[1]), (__re__)[0]);
  const $exprWithDestruction = ((($0) => {
    return (c0Dict$for)($0, $parsToBeSpent, (($name, _1, $exp) => {
      return ((c0Dict$member)($name, $doneBody.spent)
        ? $exp
        : (c0Compiler$TypedAst$DestroyIn)($name, $exp));
    }));
  }))($doneBody.resolved);
  const $spentThatShouldHaveBeenRecycled = (c0Dict$intersect)($doneBody.spent, $parsToBeRecycled);
  ((sp_not_equal)($spentThatShouldHaveBeenRecycled, c0Dict$empty)
    ? ((__re__ = (u0Compiler$UniquenessCheck$errorConsumingRecycledParameters)($env, $pos, $spentThatShouldHaveBeenRecycled, $errors)), ($errors = (__re__)[1]), (__re__)[0])
    : null);
  const $spentFromParent = (c0Dict$diff)($doneBody.spent, $parsToBeSpent);
  (((sp_equal)($spentThatShouldHaveBeenRecycled, c0Dict$empty) && (sp_not_equal)($spentFromParent, c0Dict$empty))
    ? ((__re__ = (u0Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques)($env, $pos, $spentFromParent, $errors)), ($errors = (__re__)[1]), (__re__)[0])
    : null);
  const $required = ((($0) => {
    return (c0Dict$diff)($0, $parsToBeRecycled);
  }))(((($0) => {
    return (c0Dict$join)($doneBody.required, $0);
  }))(((($0) => {
    return (c0Dict$map)((($k, $usedAt) => {
      return ({
        fnPos: $pos,
        usedAt: $usedAt,
      });
    }), $0);
  }))($doneBody.recycled)));
  ((c0Compiler$TypedAst$typeAllowsFunctions)((($tyvarId) => {
    return false;
  }), $bodyType.raw)
    ? (c0Dict$each)((c0Dict$join)($parsToBeRecycled, $parsToBeSpent), (($varName, $parPos) => {
      const $10 = (c0Dict$get)($varName, $doneBody.required);
      return ((($10)[0] === "$Nothing")
        ? null
        : ((($10)[0] === "$Just")
          ? ((() => {
            const $r = ($10)[1];
            return ((__re__ = (u0Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope)($env, $varName, $r, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 810:12', (sp_toHuman)($10))));
    }))
    : null);
  return ([
    ({
      recycled: (c0Dict$diff)($doneBody.recycled, $parsToBeRecycled),
      required: $required,
      resolved: (c0Compiler$TypedAst$Fn)($pos, $pars, $exprWithDestruction, $bodyType),
      spent: c0Dict$empty,
    }),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$doVariable = (($env, $errors, $pos, $name, $e) => {
  const $6 = (c0Dict$get)($name, $env.variables);
  return ([
    ((($6)[0] === "$Nothing")
      ? ((() => {
        ((__re__ = (u0Compiler$UniquenessCheck$errorUndefinedVariable)($env, $pos, $name, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
        return (u0Compiler$UniquenessCheck$uniOutInit)($e);
      }))()
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $variable = ($6)[1];
          const $7 = $variable.mode;
          return ((($7)[0] === "$Immutable")
            ? ({
              recycled: c0Dict$empty,
              required: $variable.required,
              resolved: $e,
              spent: c0Dict$empty,
            })
            : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$Available"))
              ? ({
                recycled: c0Dict$empty,
                required: $variable.required,
                resolved: $e,
                spent: (c0Dict$ofOne)($name, $pos),
              })
              : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$ConsumedAt"))
                ? ((() => {
                  const $consumedPos = (($7)[1])[1];
                  ((__re__ = (u0Compiler$UniquenessCheck$errorReferencingConsumedVariable)($env, $name, $pos, $consumedPos, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                  return ({
                    recycled: c0Dict$empty,
                    required: $variable.required,
                    resolved: $e,
                    spent: (c0Dict$ofOne)($name, $pos),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 728:12', (sp_toHuman)($7)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 720:4', (sp_toHuman)($6)))),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$requireInEnv = (($varNames, $required, $env) => {
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: ((($0) => {
      return (c0List$for)($0, $varNames, (($name, $a) => {
        return (c0Dict$update)($name, (($0) => {
          return (c0Maybe$map)((($var) => {
            const $1 = $var;
            return (Object.assign)({}, $1, ({
              required: $required,
            }));
          }), $0);
        }), $a);
      }));
    }))($0.variables),
  }));
});

const u0Compiler$UniquenessCheck$doExpression = (($env, $errors, $expression) => {
  const $re = (u0Compiler$UniquenessCheck$uniOutInit)($expression);
  return ([
    ((($expression)[0] === "$LiteralText")
      ? ((() => {
        const $pos = ($expression)[1];
        const $l = ($expression)[2];
        return $re;
      }))()
      : ((($expression)[0] === "$LiteralNumber")
        ? ((() => {
          const $pos = ($expression)[1];
          const $l = ($expression)[2];
          return $re;
        }))()
        : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
          ? ((() => {
            const $pos = ($expression)[1];
            return $re;
          }))()
          : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefLocal"))
            ? ((() => {
              const $pos = ($expression)[1];
              const $name = (($expression)[2])[1];
              return ((__re__ = (u0Compiler$UniquenessCheck$doVariable)($env, $errors, $pos, $name, $expression)), ($errors = (__re__)[1]), (__re__)[0]);
            }))()
            : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefPlaceholder"))
              ? ((() => {
                const $pos = ($expression)[1];
                const $n = (($expression)[2])[1];
                return ((__re__ = (u0Compiler$UniquenessCheck$doVariable)($env, $errors, $pos, (text_fromNumber)($n), $expression)), ($errors = (__re__)[1]), (__re__)[0]);
              }))()
              : ((($expression)[0] === "$Constructor")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $usr = ($expression)[2];
                  return $re;
                }))()
                : ((($expression)[0] === "$Fn")
                  ? ((() => {
                    const $pos = ($expression)[1];
                    const $pars = ($expression)[2];
                    const $body = ($expression)[3];
                    const $bodyType = ($expression)[4];
                    return ((__re__ = (u0Compiler$UniquenessCheck$doFn)($env, $pos, $errors, $pars, $body, $bodyType)), ($errors = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($expression)[0] === "$Call")
                    ? ((() => {
                      const $pos = ($expression)[1];
                      const $reference = ($expression)[2];
                      const $arguments = ($expression)[3];
                      return ((__re__ = (u0Compiler$UniquenessCheck$doCall)($env, $errors, $pos, $reference, $arguments)), ($errors = (__re__)[1]), (__re__)[0]);
                    }))()
                    : ((($expression)[0] === "$If")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $condition = ($expression)[2].condition;
                        const $false = ($expression)[2].false;
                        const $true = ($expression)[2].true;
                        const $doneCondition = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $condition)), ($errors = (__re__)[1]), (__re__)[0]);
                        const $newEnv = (u0Compiler$UniquenessCheck$consumeInEnv)($doneCondition.spent, $env);
                        const $doneTrue = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($newEnv, $errors, $true)), ($errors = (__re__)[1]), (__re__)[0]);
                        const $doneFalse = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($newEnv, $errors, $false)), ($errors = (__re__)[1]), (__re__)[0]);
                        const $finalTrueExpression = ((($0) => {
                          return (c0Dict$for)($0, $doneFalse.spent, (($name, _1, $exp) => {
                            return ((c0Dict$member)($name, $doneTrue.spent)
                              ? $exp
                              : (c0Compiler$TypedAst$DestroyIn)($name, $exp));
                          }));
                        }))($doneTrue.resolved);
                        const $finalFalseExpression = ((($0) => {
                          return (c0Dict$for)($0, $doneTrue.spent, (($name, _1, $exp) => {
                            return ((c0Dict$member)($name, $doneFalse.spent)
                              ? $exp
                              : (c0Compiler$TypedAst$DestroyIn)($name, $exp));
                          }));
                        }))($doneFalse.resolved);
                        const $finalExpression = (c0Compiler$TypedAst$If)($pos, ({
                          condition: $doneCondition.resolved,
                          false: $finalFalseExpression,
                          true: $finalTrueExpression,
                        }));
                        return ({
                          recycled: ((($0) => {
                            return (c0Dict$join)($doneFalse.recycled, $0);
                          }))(((($0) => {
                            return (c0Dict$join)($doneTrue.recycled, $0);
                          }))($doneCondition.recycled)),
                          required: ((($0) => {
                            return (c0Dict$join)($doneFalse.required, $0);
                          }))(((($0) => {
                            return (c0Dict$join)($doneTrue.required, $0);
                          }))($doneCondition.required)),
                          resolved: $finalExpression,
                          spent: ((($0) => {
                            return (c0Dict$join)($doneFalse.spent, $0);
                          }))(((($0) => {
                            return (c0Dict$join)($doneTrue.spent, $0);
                          }))($doneCondition.spent)),
                        });
                      }))()
                      : ((($expression)[0] === "$Try")
                        ? ((() => {
                          const $pos = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          const $doneValue = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $value)), ($errors = (__re__)[1]), (__re__)[0]);
                          const $newEnv = (u0Compiler$UniquenessCheck$consumeInEnv)($doneValue.spent, $env);
                          const $zzz = (($4) => {
                            const $pattern = $4.first;
                            const $block = $4.second;
                            const $5 = ((__re__ = (u0Compiler$UniquenessCheck$addPatternToEnv)($errors, $pattern, $newEnv)), ($errors = (__re__)[1]), (__re__)[0]);
                            const $env0 = $5.third;
                            const $mutables_should_be_empty = $5.second;
                            const $addedVars = $5.first;
                            const $localEnv = (u0Compiler$UniquenessCheck$requireInEnv)($addedVars, $doneValue.required, $env0);
                            return ((($0) => {
                              return (u0Compiler$UniquenessCheck$uniOutMap)((($expr) => {
                                return ({
                                  first: $pattern,
                                  second: $expr,
                                });
                              }), $0);
                            }))(((__re__ = (u0Compiler$UniquenessCheck$doExpression)($localEnv, $errors, $block)), ($errors = (__re__)[1]), (__re__)[0]));
                          });
                          const $donePatternsAndBlocks = ((($0) => {
                            return (c0List$map)($zzz, $0);
                          }))($patternsAndExpressions);
                          const $allRecycled = ((($0) => {
                            return (c0List$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                              return (c0Dict$join)($d.recycled, $a);
                            }));
                          }))(c0Dict$empty);
                          const $allRequired = ((($0) => {
                            return (c0List$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                              return (c0Dict$join)($d.required, $a);
                            }));
                          }))(c0Dict$empty);
                          const $allSpent = ((($0) => {
                            return (c0List$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                              return (c0Dict$join)($d.spent, $a);
                            }));
                          }))(c0Dict$empty);
                          const $newPatternsAndBlocks = ((() => {
                            const $xxx = (($4) => {
                              const $recycled = $4.recycled;
                              const $required = $4.required;
                              const $pattern = $4.resolved.first;
                              const $blockExpression = $4.resolved.second;
                              const $spent = $4.spent;
                              const $finalBlock = ((($0) => {
                                return (c0Dict$for)($0, $allSpent, (($name, _1, $exp) => {
                                  return ((c0Dict$member)($name, $spent)
                                    ? $exp
                                    : (c0Compiler$TypedAst$DestroyIn)($name, $exp));
                                }));
                              }))($blockExpression);
                              return ({
                                first: $pattern,
                                second: $finalBlock,
                              });
                            });
                            return (c0List$map)($xxx, $donePatternsAndBlocks);
                          }))();
                          return ({
                            recycled: $allRecycled,
                            required: $allRequired,
                            resolved: (c0Compiler$TypedAst$Try)($pos, ({
                              patternsAndExpressions: $newPatternsAndBlocks,
                              value: $doneValue.resolved,
                              valueType: $valueType,
                            })),
                            spent: $allSpent,
                          });
                        }))()
                        : ((($expression)[0] === "$Record")
                          ? ((() => {
                            const $pos = ($expression)[1];
                            const $maybeExtending = ($expression)[2];
                            const $attrValueByName = ($expression)[3];
                            const $doneExt = ((($maybeExtending)[0] === "$Nothing")
                              ? (u0Compiler$UniquenessCheck$uniOutInit)(c0Maybe$Nothing)
                              : ((($maybeExtending)[0] === "$Just")
                                ? ((() => {
                                  const $extending = ($maybeExtending)[1];
                                  return ((($0) => {
                                    return (u0Compiler$UniquenessCheck$uniOutMap)(c0Maybe$Just, $0);
                                  }))(((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $extending)), ($errors = (__re__)[1]), (__re__)[0]));
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 620:16', (sp_toHuman)($maybeExtending))));
                            const $doneAttrs = ((($0) => {
                              return (c0Dict$for)($0, $attrValueByName, (($name, $value, $doneSoFar) => {
                                const $8 = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $value)), ($errors = (__re__)[1]), (__re__)[0]);
                                const $spent = $8.spent;
                                const $resolved = $8.resolved;
                                const $required = $8.required;
                                const $recycled = $8.recycled;
                                const $consumedTwice = (c0Dict$merge)((($k, $v, $d) => {
                                  return $d;
                                }), (($k, $a, $b, $d) => {
                                  return (c0Dict$insert)($k, ({
                                    first: $a,
                                    second: $b,
                                  }), $d);
                                }), (($k, $v, $d) => {
                                  return $d;
                                }), $spent, $doneSoFar.spent, c0Dict$empty);
                                (c0Dict$each)($consumedTwice, (($n, $9) => {
                                  const $p1 = $9.first;
                                  const $p2 = $9.second;
                                  return ((__re__ = (u0Compiler$UniquenessCheck$errorReferencingConsumedVariable)($env, $n, $p1, $p2, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                                }));
                                return ({
                                  recycled: (c0Dict$join)($recycled, $doneSoFar.recycled),
                                  required: (c0Dict$join)($required, $doneSoFar.required),
                                  resolved: (c0Dict$insert)($name, $resolved, $doneSoFar.resolved),
                                  spent: (c0Dict$join)($spent, $doneSoFar.spent),
                                });
                              }));
                            }))((u0Compiler$UniquenessCheck$uniOutInit)(c0Dict$empty));
                            return ({
                              recycled: (c0Dict$join)($doneExt.recycled, $doneAttrs.recycled),
                              required: (c0Dict$join)($doneExt.required, $doneAttrs.required),
                              resolved: (c0Compiler$TypedAst$Record)($pos, $doneExt.resolved, $doneAttrs.resolved),
                              spent: (c0Dict$join)($doneExt.spent, $doneAttrs.spent),
                            });
                          }))()
                          : ((($expression)[0] === "$RecordAccess")
                            ? ((() => {
                              const $pos = ($expression)[1];
                              const $name = ($expression)[2];
                              const $expr = ($expression)[3];
                              return ((($0) => {
                                return (u0Compiler$UniquenessCheck$uniOutMap)((($0) => {
                                  return (c0Compiler$TypedAst$RecordAccess)($pos, $name, $0);
                                }), $0);
                              }))(((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $expr)), ($errors = (__re__)[1]), (__re__)[0]));
                            }))()
                            : ((($expression)[0] === "$LetIn")
                              ? ((() => {
                                const $valueDef = ($expression)[1];
                                const $rest = ($expression)[2];
                                const $restType = ($expression)[3];
                                const $4 = ((__re__ = (u0Compiler$UniquenessCheck$addPatternToEnv)($errors, $valueDef.pattern, $env)), ($errors = (__re__)[1]), (__re__)[0]);
                                const $env1 = $4.third;
                                const $uniques = $4.second;
                                const $addedVars = $4.first;
                                const $doneDefBody = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env1, $errors, $valueDef.body)), ($errors = (__re__)[1]), (__re__)[0]);
                                const $localEnv = ((($0) => {
                                  return (u0Compiler$UniquenessCheck$requireInEnv)($addedVars, $doneDefBody.required, $0);
                                }))(((($0) => {
                                  return (u0Compiler$UniquenessCheck$consumeInEnv)($doneDefBody.spent, $0);
                                }))($env1));
                                const $doneExpression = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($localEnv, $errors, $rest)), ($errors = (__re__)[1]), (__re__)[0]);
                                ((c0Compiler$TypedAst$typeAllowsFunctions)((($tyvarId) => {
                                  return false;
                                }), $restType.raw)
                                  ? (c0List$each)($addedVars, (($varName) => {
                                    const $6 = (c0Dict$get)($varName, $doneExpression.required);
                                    return ((($6)[0] === "$Nothing")
                                      ? null
                                      : ((($6)[0] === "$Just")
                                        ? ((() => {
                                          const $r = ($6)[1];
                                          return ((__re__ = (u0Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope)($env, $varName, $r, $errors)), ($errors = (__re__)[1]), (__re__)[0]);
                                        }))()
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 685:20', (sp_toHuman)($6))));
                                  }))
                                  : null);
                                const $finalExpression = ((($0) => {
                                  return (c0Dict$for)($0, $uniques, (($name, $pos, $exp) => {
                                    const $9 = (c0Dict$get)($name, $doneExpression.spent);
                                    return ((($9)[0] === "$Just")
                                      ? $exp
                                      : ((($9)[0] === "$Nothing")
                                        ? (c0Compiler$TypedAst$DestroyIn)($name, $exp)
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 694:20', (sp_toHuman)($9))));
                                  }));
                                }))((c0Compiler$TypedAst$LetIn)(((() => {
                                  const $0 = $valueDef;
                                  return (Object.assign)({}, $0, ({
                                    body: $doneDefBody.resolved,
                                  }));
                                }))(), $doneExpression.resolved, $restType));
                                const $spent = ((($0) => {
                                  return (c0Dict$join)($doneDefBody.spent, $0);
                                }))(((($0) => {
                                  return (c0Dict$for)($0, $uniques, (($name, _1, $d) => {
                                    return (c0Dict$remove)($name, $d);
                                  }));
                                }))($doneExpression.spent));
                                return ({
                                  recycled: (c0Dict$join)($doneDefBody.recycled, $doneExpression.recycled),
                                  required: $doneExpression.required,
                                  resolved: $finalExpression,
                                  spent: $spent,
                                });
                              }))()
                              : ((($expression)[0] === "$Error")
                                ? $re
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 492:4', (sp_toHuman)($expression)))))))))))))))),
    $errors,
  ]);
});

const u0Compiler$UniquenessCheck$updateValueDef = (($errors, $modulesByUmr, $1) => {
  const $usr = $1.first;
  const $def = $1.second;
  const $env = ({
    modulesByUmr: $modulesByUmr,
    usr: $usr,
    variables: c0Dict$empty,
  });
  const $doneExpression = ((__re__ = (u0Compiler$UniquenessCheck$doExpression)($env, $errors, $def.body)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    ({
      first: $usr,
      second: ((() => {
        const $0 = $def;
        return (Object.assign)({}, $0, ({
          body: $doneExpression.resolved,
        }));
      }))(),
    }),
    $errors,
  ]);
});

const u0SPLib$RefHierarchy$resolve = (($getEdges, $target, $path, $state0) => {
  return ((c0List$member)($target, $state0.resolved)
    ? $state0
    : ((c0List$member)($target, $path)
      ? ((() => {
        const $circ = (sp_cons)($target, (c0List$takeWhile)((($key) => {
          return (sp_not_equal)($key, $target);
        }), $path));
        const $0 = $state0;
        return (Object.assign)({}, $0, ({
          circular: (c0Dict$insert)((c0Set$fromList)($circ), $circ, $0.circular),
        }));
      }))()
      : ((() => {
        const $s = ((($0) => {
          return (c0Dict$for)($0, ($getEdges)($target), (($a, _1, $d) => {
            return (u0SPLib$RefHierarchy$resolve)($getEdges, $a, (sp_cons)($target, $path), $d);
          }));
        }))($state0);
        const $0 = $s;
        return (Object.assign)({}, $0, ({
          resolved: (sp_cons)($target, $0.resolved),
        }));
      }))()));
});

const u0SPLib$RefHierarchy$reorder = (($nodeToEdges, $nodesById) => {
  const $keyToEdges = (($id) => {
    const $4 = (c0Dict$get)($id, $nodesById);
    return ((($4)[0] === "$Nothing")
      ? c0Dict$empty
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $node = ($4)[1];
          return ($nodeToEdges)($node);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/RefHierarchy.sp 40:8', (sp_toHuman)($4))));
  });
  const $state0 = ({
    circular: c0Dict$empty,
    resolved: c0Core$Nil,
  });
  const $stateF = ((($0) => {
    return (c0Dict$for)($0, $nodesById, (($k, $v, $d) => {
      return (u0SPLib$RefHierarchy$resolve)($keyToEdges, $k, c0Core$Nil, $d);
    }));
  }))($state0);
  return ({
    first: (c0Dict$values)($stateF.circular),
    second: (c0List$reverse)($stateF.resolved),
  });
});

const u0Compiler$LazyBuild$build = (($pars) => {
  let $state = (u0Compiler$LazyBuild$initCollectDependenciesState)(((($0) => {
    return (c0List$map)((($usr) => {
      return ({
        first: $usr,
        second: (u0Compiler$LazyBuild$usrToDependencyType)($usr),
      });
    }), $0);
  }))($pars.requiredUsrs));
  return ((c0Result$onOk)(((_0) => {
    const $nodeToEdges = (($usr) => {
      const $4 = ((__re__ = (hash_get)($state.done, $usr)), ($state.done = (__re__)[1]), (__re__)[0]);
      return ((($4)[0] === "$Nothing")
        ? c0Dict$empty
        : ((($4)[0] === "$Just")
          ? ((() => {
            const $deps = ($4)[1].deps;
            return $deps;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 257:8', (sp_toHuman)($4))));
    });
    const $nodesById = ((__re__ = (c0Hash$for_)(c0Dict$empty, $state.done, (($usr, _1, $dict) => {
      return (c0Dict$insert)($usr, $usr, $dict);
    }))), ($state.done = (__re__)[1]), (__re__)[0]);
    const $3 = (u0SPLib$RefHierarchy$reorder)($nodeToEdges, $nodesById);
    const $orderedUsrs = $3.second;
    const $circulars = $3.first;
    let $errors = (array_fromList)(c0Core$Nil);
    (c0List$each)($circulars, (($circular) => {
      return ((($circular)[0] === "$Cons")
        ? ((() => {
          const $usr = ($circular)[1];
          const $others = ($circular)[2];
          return ((sp_equal)((u0Compiler$LazyBuild$usrToDependencyType)($usr), c0Compiler$Meta$TypeDependency)
            ? ((($0) => {
              return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
            }))((u0Compiler$Error$Raw)((c0Core$Cons)("Circular aliases!", (c0Core$Cons)((sp_toHuman)($circular), c0Core$Nil))))
            : null);
        }))()
        : (true
          ? null
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 284:8', (sp_toHuman)($circular))));
    }));
    return ((c0Result$onOk)(((_0) => {
      const $modulesByUmr = (c0Dict$fromList)(((__re__ = (c0Hash$toList)($state.loadedModulesByUmr)), ($state.loadedModulesByUmr = (__re__)[1]), (__re__)[0]));
      const $env0 = (u0Compiler$TypeCheck$initEnv)($pars.projectImports, $modulesByUmr);
      const $env1 = (c0List$for)($env0, $orderedUsrs, (($0, $1) => {
        return ((__re__ = (u0Compiler$LazyBuild$expandAndInsertType)($state, $errors, $0, $1)), ($state = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
      }));
      return ((c0Result$onOk)(((_0) => {
        let $lastUnificationVarId = (basics_cloneImm)(0);
        const $env2 = (c0List$for)($env1, $circulars, (($0, $1) => {
          return ((__re__ = (u0Compiler$LazyBuild$evaluateCircularValues)($state, $errors, $lastUnificationVarId, $0, $1)), ($state = (__re__)[1]), ($errors = (__re__)[2]), ($lastUnificationVarId = (__re__)[3]), (__re__)[0]);
        }));
        return ((c0Result$onOk)(((_0) => {
          const $envF = (c0List$for)($env2, $orderedUsrs, (($0, $1) => {
            return ((__re__ = (u0Compiler$LazyBuild$typecheckDefinition)($state, $errors, $lastUnificationVarId, $0, $1)), ($state = (__re__)[1]), ($errors = (__re__)[2]), ($lastUnificationVarId = (__re__)[3]), (__re__)[0]);
          }));
          const $valueDefsWithDestruction = ((($0) => {
            return (c0List$map)((($0) => {
              return ((__re__ = (u0Compiler$UniquenessCheck$updateValueDef)($errors, $modulesByUmr, $0)), ($errors = (__re__)[1]), (__re__)[0]);
            }), $0);
          }))((c0List$reverse)($envF.reversedRootValueDefs));
          return ((c0Result$onOk)(((_0) => {
            const $translateDef = (($8) => {
              const $usr = $8.first;
              const $def = $8.second;
              return ({
                deps: $def.directDeps,
                expr: (u0Compiler$MakeEmittable$translateExpression)((u0Compiler$MakeEmittable$mkEnv)($usr, $modulesByUmr), $def.body),
                freeTyvars: $def.freeTyvars,
                freeUnivars: $def.freeUnivars,
                type: $def.type.raw,
                usr: $usr,
              });
            });
            const $rootValues = (c0List$map)($translateDef, $valueDefsWithDestruction);
            const $constructors = (c0Dict$toList)((c0Dict$map)((($k, $v) => {
              return $v.type.raw;
            }), $envF.constructors));
            return (c0Result$Ok)(({
              constructors: $constructors,
              rootValues: $rootValues,
            }));
          })))(((__re__ = (u0Compiler$LazyBuild$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
        })))(((__re__ = (u0Compiler$LazyBuild$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
      })))(((__re__ = (u0Compiler$LazyBuild$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
    })))(((__re__ = (u0Compiler$LazyBuild$stopOnError)($pars, $errors)), ($errors = (__re__)[1]), (__re__)[0]));
  })))(((__re__ = (u0Compiler$LazyBuild$collectRequiredUsrs)($pars, $state)), ($state = (__re__)[1]), (__re__)[0]));
});

const u0Compiler$MakeCanonical$initEnv = (($ro) => {
  return ({
    maybeShorthandTarget: c0Maybe$Nothing,
    nextGeneratedVariableName: 0,
    nonFn: c0Dict$empty,
    ro: $ro,
    values: c0Dict$empty,
  });
});

const u0Compiler$Error$res = (($mod, $pos, $desc) => {
  return (c0Result$Err)((u0Compiler$Error$Simple)($mod, $pos, $desc));
});

const u0Compiler$MakeCanonical$error = (($env, $pos, $msg) => {
  return (u0Compiler$Error$res)($env.ro.errorModule, $pos, $msg);
});

const u0Compiler$MakeCanonical$insertPatternNames = (($isRoot, $pattern, $env) => {
  return ((c0Result$onOk)((($values) => {
    return (c0Result$Ok)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        values: $values,
      }));
    }))());
  })))((c0List$forRes)($env.values, (c0Compiler$CanonicalAst$patternNames)($pattern), (($paName, $vs) => {
    const $6 = (c0Dict$get)($paName.name, $vs);
    return ((($6)[0] === "$Just")
      ? ((() => {
        const $duplicateName = ($6)[1];
        return (u0Compiler$MakeCanonical$error)($env, $paName.pos, (c0Core$Cons)(("A variable named `" + ($paName.name + "` has already been defined.")), (c0Core$Cons)("You need to find a less ambiguous name.", c0Core$Nil)));
      }))()
      : ((($6)[0] === "$Nothing")
        ? ((() => {
          const $resolvePars = ($env.ro.resolvePars)($paName.pos);
          const $shadowsAGlobal = ((() => {
            const $7 = (c0Dict$get)($paName.name, $resolvePars.currentImports.globalNameToLocation);
            return ((($7)[0] === "$Nothing")
              ? false
              : ((($7)[0] === "$Just")
                ? ((() => {
                  const $location = ($7)[1];
                  return ((c0Basics$not)($isRoot)
                    ? true
                    : ((() => {
                      const $8 = (c0Compiler$Meta$resolve)($resolvePars, c0Maybe$Nothing, $paName.name);
                      return ((($8)[0] === "$Err")
                        ? true
                        : (((($8)[0] === "$Ok") && ((($8)[1])[0] === "$USR"))
                          ? ((() => {
                            const $umr = (($8)[1])[1];
                            const $name = (($8)[1])[2];
                            return (sp_not_equal)($umr, $env.ro.umr);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 846:32', (sp_toHuman)($8))));
                    }))());
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 832:20', (sp_toHuman)($7))));
          }))();
          return ((c0Basics$not)($shadowsAGlobal)
            ? (c0Result$Ok)((c0Dict$insert)($paName.name, ({
              isRoot: $isRoot,
              pos: $paName.pos,
            }), $vs))
            : (u0Compiler$MakeCanonical$error)($env, $paName.pos, (c0Core$Cons)(("There is already a global variable named `" + ($paName.name + "`.")), (c0Core$Cons)("You need to find a different name, or modify imports.sp", c0Core$Nil))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 815:8', (sp_toHuman)($6))));
  })));
});

const u0Compiler$MakeCanonical$erroro = (($ro, $pos, $msg) => {
  return (u0Compiler$Error$res)($ro.errorModule, $pos, $msg);
});

const u0Compiler$MakeCanonical$resolveToUsr = (($ro, $pos, $maybeModule, $name) => {
  return (c0Compiler$Meta$resolve)(($ro.resolvePars)($pos), $maybeModule, $name);
});

const u0Compiler$MakeCanonical$translateAttributeName = (($ro, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Lowercase")
    ? ((() => {
      const $attrPath = ($expr_)[1].attrPath;
      const $maybeModule = ($expr_)[1].maybeModule;
      const $maybeType = ($expr_)[1].maybeType;
      const $name = ($expr_)[1].name;
      return ((sp_not_equal)($maybeModule, c0Maybe$Nothing)
        ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("Attribute names must be single words", c0Core$Nil))
        : ((sp_not_equal)($attrPath, c0Core$Nil)
          ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("Attribute names can't contain dots", c0Core$Nil))
          : (c0Result$Ok)(({
            first: $pos,
            second: $name,
            third: $maybeType,
          }))));
    }))()
    : (true
      ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("I need a lowercase attribute name here", c0Core$Nil))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 282:4', (sp_toHuman)($expr_))));
});

const u0Compiler$MakeCanonical$translateAndInsertRecordAttributeType = (($ro, $faAttr, $caAttrs) => {
  return ((c0Result$onOk)((($4) => {
    const $pos = $4.first;
    const $name = $4.second;
    const $maybeFaType = $4.third;
    return ((c0Dict$member)($name, $caAttrs)
      ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)(("Duplicate attribute name: " + $name), c0Core$Nil))
      : ((($maybeFaType)[0] === "$Nothing")
        ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)(("I need to see the type of this attribute, `" + ($name + " as TheType`")), c0Core$Nil))
        : ((($maybeFaType)[0] === "$Just")
          ? ((() => {
            const $faType = ($maybeFaType)[1];
            return ((c0Result$onOk)((($caType) => {
              return ((sp_not_equal)($faAttr.maybeExpr, c0Maybe$Nothing)
                ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("I need a type here; `=` is for assignign values", c0Core$Nil))
                : (c0Result$Ok)(((($0) => {
                  return (c0Dict$insert)($name, $caType, $0);
                }))($caAttrs)));
            })))(((($0) => {
              return (u0Compiler$MakeCanonical$translateRawType)($ro, $0);
            }))($faType));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1260:8', (sp_toHuman)($maybeFaType)))));
  })))((u0Compiler$MakeCanonical$translateAttributeName)($ro, $faAttr.name));
});

const u0Compiler$MakeCanonical$translatePoly = (($ro, $expr) => {
  const $3 = $expr;
  const $expr_ = ($3)[3];
  const $pos = ($3)[2];
  return (((($expr_)[0] === "$UnopCall") && ((($expr_)[1])[0] === "$UnopUnique"))
    ? ((() => {
      const $e = ($expr_)[2];
      return (c0Result$Ok)(({
        first: c0Compiler$Ast$Uni,
        second: $e,
      }));
    }))()
    : ((($expr_)[0] === "$Poly")
      ? ((() => {
        const $numberAsString = ($expr_)[1];
        const $e = ($expr_)[2];
        const $4 = (text_toNumber)($numberAsString);
        return ((($4)[0] === "$Nothing")
          ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("I need an integer number here", c0Core$Nil))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $n = ($4)[1];
              return (c0Result$Ok)(({
                first: (c0Compiler$Ast$Depends)($n),
                second: $e,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1306:12', (sp_toHuman)($4))));
      }))()
      : (true
        ? (c0Result$Ok)(({
          first: c0Compiler$Ast$Imm,
          second: $expr,
        }))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1300:4', (sp_toHuman)($expr_)))));
});

const u0Compiler$MakeCanonical$translateFullType = (($ro, $expr) => {
  return ((c0Result$onOk)((($3) => {
    const $uni = $3.first;
    const $e = $3.second;
    return ((c0Result$onOk)((($raw) => {
      return (c0Result$Ok)(({
        raw: $raw,
        uni: $uni,
      }));
    })))((u0Compiler$MakeCanonical$translateRawType)($ro, $e));
  })))(((($0) => {
    return (u0Compiler$MakeCanonical$translatePoly)($ro, $0);
  }))($expr));
});

const u0Compiler$MakeCanonical$translateTuple = (($ro, $translate, $chain) => {
  const $faExpressions = (c0Compiler$FormattableAst$binopChainExpressions)($chain);
  return ((c0Result$onOk)((($items) => {
    const $pos = (c0List$for)(c0Compiler$Pos$G, $faExpressions, (($6, $z) => {
      const $p = ($6)[2];
      return (c0Compiler$Pos$range)($p, $z);
    }));
    return (((($items)[0] === "$Cons") && (((($items)[2])[0] === "$Cons") && (((($items)[2])[2])[0] === "$Nil")))
      ? ((() => {
        const $ca1 = ($items)[1];
        const $ca2 = (($items)[2])[1];
        return (c0Result$Ok)(((($0) => {
          return (c0Dict$insert)("second", $ca2, $0);
        }))(((($0) => {
          return (c0Dict$insert)("first", $ca1, $0);
        }))(c0Dict$empty)));
      }))()
      : (((($items)[0] === "$Cons") && (((($items)[2])[0] === "$Cons") && ((((($items)[2])[2])[0] === "$Cons") && ((((($items)[2])[2])[2])[0] === "$Nil"))))
        ? ((() => {
          const $ca1 = ($items)[1];
          const $ca2 = (($items)[2])[1];
          const $ca3 = ((($items)[2])[2])[1];
          return (c0Result$Ok)(((($0) => {
            return (c0Dict$insert)("third", $ca3, $0);
          }))(((($0) => {
            return (c0Dict$insert)("second", $ca2, $0);
          }))(((($0) => {
            return (c0Dict$insert)("first", $ca1, $0);
          }))(c0Dict$empty))));
        }))()
        : (true
          ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("tuples can be only of size 2 or 3, use a record instead", c0Core$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 407:4', (sp_toHuman)($items)))));
  })))(((($0) => {
    return (c0List$mapRes)($translate, $0);
  }))($faExpressions));
});

const u0Compiler$MakeCanonical$translateTypeFunctionParameter = (($ro, $expression) => {
  const $3 = $expression;
  const $expr_ = ($3)[3];
  return (((($expr_)[0] === "$UnopCall") && ((($expr_)[1])[0] === "$UnopRecycle"))
    ? ((() => {
      const $faOperand = ($expr_)[2];
      return ((($0) => {
        return (c0Result$map)(c0Compiler$CanonicalAst$ParRe, $0);
      }))(((($0) => {
        return (u0Compiler$MakeCanonical$translateRawType)($ro, $0);
      }))($faOperand));
    }))()
    : (true
      ? ((($0) => {
        return (c0Result$map)(c0Compiler$CanonicalAst$ParSp, $0);
      }))(((($0) => {
        return (u0Compiler$MakeCanonical$translateFullType)($ro, $0);
      }))($expression))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1282:4', (sp_toHuman)($expr_))));
});

const u0Compiler$MakeCanonical$translateRawType = (($ro, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Uppercase")
    ? ((() => {
      const $maybeModule = ($expr_)[1].maybeModule;
      const $name = ($expr_)[1].name;
      return ((c0Result$onOk)((($usr) => {
        return (c0Result$Ok)((c0Compiler$CanonicalAst$TypeNamed)($pos, $usr, c0Core$Nil));
      })))((u0Compiler$MakeCanonical$resolveToUsr)($ro, $pos, $maybeModule, $name));
    }))()
    : ((($expr_)[0] === "$Lowercase")
      ? ((() => {
        const $attrPath = ($expr_)[1].attrPath;
        const $maybeModule = ($expr_)[1].maybeModule;
        const $maybeType = ($expr_)[1].maybeType;
        const $name = ($expr_)[1].name;
        return ((sp_not_equal)($maybeType, c0Maybe$Nothing)
          ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("Can't really specify the type of a type.", c0Core$Nil))
          : ((sp_not_equal)($maybeModule, c0Maybe$Nothing)
            ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("no modules for tyvars!", c0Core$Nil))
            : ((sp_not_equal)($attrPath, c0Core$Nil)
              ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("no attributes for tyvars!", c0Core$Nil))
              : (c0Result$Ok)((c0Compiler$CanonicalAst$TypeAnnotationVariable)($pos, $name)))));
      }))()
      : (((($expr_)[0] === "$Call") && ((($expr_)[1])[0] === "$Expression"))
        ? ((() => {
          const $refPos = (($expr_)[1])[2];
          const $ref = (($expr_)[1])[3];
          const $faArgs = ($expr_)[2];
          return ((($ref)[0] === "$Uppercase")
            ? ((() => {
              const $maybeModule = ($ref)[1].maybeModule;
              const $name = ($ref)[1].name;
              return ((c0Result$onOk)((($caArgs) => {
                return ((c0Result$onOk)((($usr) => {
                  return (c0Result$Ok)((c0Compiler$CanonicalAst$TypeNamed)($pos, $usr, $caArgs));
                })))((u0Compiler$MakeCanonical$resolveToUsr)($ro, $pos, $maybeModule, $name));
              })))(((($0) => {
                return (c0List$mapRes)((($0) => {
                  return (u0Compiler$MakeCanonical$translateRawType)($ro, $0);
                }), $0);
              }))($faArgs));
            }))()
            : (true
              ? (u0Compiler$MakeCanonical$erroro)($ro, $refPos, (c0Core$Cons)("I need an Uppercase type name here", c0Core$Nil))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1344:12', (sp_toHuman)($ref))));
        }))()
        : ((($expr_)[0] === "$List")
          ? ((() => {
            const $dotsAndItems = ($expr_)[2];
            return ((($dotsAndItems)[0] === "$Nil")
              ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("You need to specify the type of the List items", c0Core$Nil))
              : (((($dotsAndItems)[0] === "$Cons") && ((($dotsAndItems)[2])[0] === "$Nil"))
                ? ((() => {
                  const $hasDots = ($dotsAndItems)[1].first;
                  const $faItem = ($dotsAndItems)[1].second;
                  return ($hasDots
                    ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("No need to use dots here", c0Core$Nil))
                    : ((c0Result$onOk)((($caItem) => {
                      return (c0Result$Ok)((u0Compiler$CoreDefs$listType)($caItem));
                    })))((u0Compiler$MakeCanonical$translateRawType)($ro, $faItem)));
                }))()
                : (true
                  ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("List items must all have the same type, so you can specify only one type", c0Core$Nil))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1358:12', (sp_toHuman)($dotsAndItems)))));
          }))()
          : ((($expr_)[0] === "$Record")
            ? ((() => {
              const $attrs = ($expr_)[1].attrs;
              const $maybeExtension = ($expr_)[1].maybeExtension;
              return ((sp_not_equal)($maybeExtension, c0Maybe$Nothing)
                ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("Experimentally, extensible type annotations are disabled", c0Core$Nil))
                : ((c0Result$onOk)((($caAttrs) => {
                  return (c0Result$Ok)(((($0) => {
                    return (c0Compiler$CanonicalAst$TypeRecord)($pos, $0);
                  }))($caAttrs));
                })))(((($0) => {
                  return (c0List$forRes)($0, $attrs, (($0, $1) => {
                    return (u0Compiler$MakeCanonical$translateAndInsertRecordAttributeType)($ro, $0, $1);
                  }));
                }))(c0Dict$empty)));
            }))()
            : ((($expr_)[0] === "$Fn")
              ? ((() => {
                const $faParams = ($expr_)[2];
                const $faReturn = ($expr_)[3];
                return ((c0Result$onOk)((($caParams) => {
                  return ((c0Result$onOk)((($caReturn) => {
                    return (c0Result$Ok)((c0Compiler$CanonicalAst$TypeFn)($pos, $caParams, $caReturn));
                  })))(((($0) => {
                    return (u0Compiler$MakeCanonical$translateFullType)($ro, $0);
                  }))($faReturn));
                })))(((($0) => {
                  return (c0List$mapRes)((($0) => {
                    return (u0Compiler$MakeCanonical$translateTypeFunctionParameter)($ro, $0);
                  }), $0);
                }))($faParams));
              }))()
              : ((($expr_)[0] === "$BinopChain")
                ? ((() => {
                  const $precedence = ($expr_)[1];
                  const $chain = ($expr_)[2];
                  return ((sp_equal)($precedence, c0Compiler$Op$precedence_tuple)
                    ? ((c0Result$onOk)((($recordAttrs) => {
                      return (c0Result$Ok)((c0Compiler$CanonicalAst$TypeRecord)($pos, $recordAttrs));
                    })))(((($0) => {
                      return (u0Compiler$MakeCanonical$translateTuple)($ro, (($0) => {
                        return (u0Compiler$MakeCanonical$translateRawType)($ro, $0);
                      }), $0);
                    }))($chain))
                    : (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("This operator can't be used in type definitions", (c0Core$Cons)((sp_toHuman)($expr_), c0Core$Nil))));
                }))()
                : (true
                  ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)("Not sure what's up with this type =|", (c0Core$Cons)((sp_toHuman)($expr_), c0Core$Nil)))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1326:4', (sp_toHuman)($expr_))))))))));
});

const u0Compiler$MakeCanonical$translateConstructor = (($varType, $varUsr, $varPars, $2, $1) => {
  const $pos = ($2)[2];
  const $expr_ = ($2)[3];
  const $constructors = $1.first;
  const $env = $1.second;
  return ((c0Result$onOk)((($6) => {
    const $name = $6.first;
    const $faPars = $6.second;
    return ((c0Result$onOk)(((_0) => {
      return ((c0Result$onOk)((($ins) => {
        const $tyvars = (c0List$for)(c0Dict$empty, $ins, (($in, $dict) => {
          return (c0Dict$join)((c0Compiler$CanonicalAst$typeTyvars)($in), $dict);
        }));
        const $undeclaredTyvars = (c0Dict$diff)($tyvars, $varPars);
        return ((c0Result$onOk)(((_0) => {
          return ((c0Result$onOk)((($newEnv) => {
            const $directDeps = ((($0) => {
              return (c0List$for)($0, $ins, u0Compiler$MakeCanonical$typeDeps);
            }))((c0Dict$ofOne)($varUsr, c0Compiler$Meta$TypeDependency));
            const $11 = $varUsr;
            const $umr = ($11)[1];
            const $c = ({
              constructorUsr: (c0Compiler$Meta$USR)($umr, $name),
              directDeps: $directDeps,
              ins: $ins,
              name: $name,
              out: $varType,
              pos: $pos,
              variantTypeUsr: $varUsr,
            });
            return (c0Result$Ok)(({
              first: (c0Dict$insert)($name, $c, $constructors),
              second: $newEnv,
            }));
          })))(((($0) => {
            return (u0Compiler$MakeCanonical$insertPatternNames)(true, (c0Compiler$CanonicalAst$PatternAny)($pos, (c0Maybe$Just)($name), c0Maybe$Nothing), $0);
          }))($env));
        })))(((sp_equal)($undeclaredTyvars, c0Dict$empty)
          ? (c0Result$Ok)(null)
          : ((() => {
            const $toError = (($9) => {
              const $n = $9.first;
              const $p = $9.second;
              return (u0Compiler$Error$Simple)($env.ro.errorModule, $p, (c0Core$Cons)(("Undeclared type variable: " + $n), c0Core$Nil));
            });
            return (c0Result$Err)((u0Compiler$Error$Nested)(((($0) => {
              return (c0List$map)($toError, $0);
            }))((c0Dict$toList)($undeclaredTyvars))));
          }))()));
      })))(((($0) => {
        return (c0List$mapRes)((($0) => {
          return (u0Compiler$MakeCanonical$translateRawType)($env.ro, $0);
        }), $0);
      }))($faPars));
    })))(((c0Dict$member)($name, $constructors)
      ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)(("constructor " + ($name + " is duplicate")), c0Core$Nil))
      : (c0Result$Ok)(null)));
  })))((((($expr_)[0] === "$Constructor") && ((($expr_)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($expr_)[1].name;
      return (c0Result$Ok)(({
        first: $name,
        second: c0Core$Nil,
      }));
    }))()
    : (((($expr_)[0] === "$Call") && (((($expr_)[1])[0] === "$Expression") && ((((($expr_)[1])[3])[0] === "$Constructor") && ((((($expr_)[1])[3])[1].maybeModule)[0] === "$Nothing"))))
      ? ((() => {
        const $name = ((($expr_)[1])[3])[1].name;
        const $pars = ($expr_)[2];
        return (c0Result$Ok)(({
          first: $name,
          second: $pars,
        }));
      }))()
      : (true
        ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("I need a 'constructor name here!", c0Core$Nil))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1414:4', (sp_toHuman)($expr_))))));
});

const u0Compiler$MakeCanonical$argumentDeps = (($arg, $deps) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $e = ($arg)[1];
      return (u0Compiler$MakeCanonical$expressionDeps)($e, $deps);
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? $deps
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 197:4', (sp_toHuman)($arg))));
});

const u0Compiler$MakeCanonical$patternDeps = (($pattern, $deps) => {
  return ((($pattern)[0] === "$PatternConstructor")
    ? ((() => {
      const $usr = ($pattern)[2];
      const $ps = ($pattern)[3];
      return ((($0) => {
        return (c0List$for)($0, $ps, u0Compiler$MakeCanonical$patternDeps);
      }))(((($0) => {
        return (c0Dict$insert)($usr, c0Compiler$Meta$ConstructorDependency, $0);
      }))($deps));
    }))()
    : ((($pattern)[0] === "$PatternRecord")
      ? ((() => {
        const $completeness = ($pattern)[2];
        const $ps = ($pattern)[3];
        return (c0Dict$for)($deps, $ps, (($k, $v, $a) => {
          return (u0Compiler$MakeCanonical$patternDeps)($v, $a);
        }));
      }))()
      : (((($pattern)[0] === "$PatternAny") && ((($pattern)[3])[0] === "$Just"))
        ? ((() => {
          const $annotation = (($pattern)[3])[1];
          return (u0Compiler$MakeCanonical$typeDeps)($annotation.raw, $deps);
        }))()
        : (((($pattern)[0] === "$PatternAny") && ((($pattern)[3])[0] === "$Nothing"))
          ? $deps
          : ((($pattern)[0] === "$PatternLiteralNumber")
            ? $deps
            : ((($pattern)[0] === "$PatternLiteralText")
              ? $deps
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 104:4', (sp_toHuman)($pattern))))))));
});

const u0Compiler$MakeCanonical$parameterDeps = (($par, $deps) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $pa = ($par)[2];
      return (u0Compiler$MakeCanonical$patternDeps)($pa, $deps);
    }))()
    : (true
      ? $deps
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 204:4', (sp_toHuman)($par))));
});

const u0Compiler$MakeCanonical$expressionDeps = (($expression, $deps) => {
  return ((($expression)[0] === "$LiteralNumber")
    ? $deps
    : ((($expression)[0] === "$LiteralText")
      ? $deps
      : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
        ? ((() => {
          const $usr = (($expression)[2])[1];
          return (c0Dict$insert)($usr, c0Compiler$Meta$ValueDependency, $deps);
        }))()
        : ((($expression)[0] === "$Variable")
          ? $deps
          : ((($expression)[0] === "$Constructor")
            ? ((() => {
              const $usr = ($expression)[2];
              return (c0Dict$insert)($usr, c0Compiler$Meta$ConstructorDependency, $deps);
            }))()
            : ((($expression)[0] === "$Fn")
              ? ((() => {
                const $pars = ($expression)[2];
                const $body = ($expression)[3];
                return ((($0) => {
                  return (u0Compiler$MakeCanonical$expressionDeps)($body, $0);
                }))(((($0) => {
                  return (c0List$for)($0, $pars, u0Compiler$MakeCanonical$parameterDeps);
                }))($deps));
              }))()
              : (((($expression)[0] === "$Record") && ((($expression)[2])[0] === "$Nothing"))
                ? ((() => {
                  const $exprByName = ($expression)[3];
                  return (c0Dict$for)($deps, $exprByName, (($name, $v, $a) => {
                    return (u0Compiler$MakeCanonical$expressionDeps)($v, $a);
                  }));
                }))()
                : (((($expression)[0] === "$Record") && ((($expression)[2])[0] === "$Just"))
                  ? ((() => {
                    const $expr = (($expression)[2])[1];
                    const $exprByName = ($expression)[3];
                    return ((($0) => {
                      return (c0Dict$for)($0, $exprByName, (($name, $v, $a) => {
                        return (u0Compiler$MakeCanonical$expressionDeps)($v, $a);
                      }));
                    }))(((($0) => {
                      return (u0Compiler$MakeCanonical$expressionDeps)($expr, $0);
                    }))($deps));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $exprByName = ($expression)[3];
                      return (c0Dict$for)($deps, $exprByName, (($name, $v, $a) => {
                        return (u0Compiler$MakeCanonical$expressionDeps)($v, $a);
                      }));
                    }))()
                    : ((($expression)[0] === "$RecordAccess")
                      ? ((() => {
                        const $e = ($expression)[3];
                        return (u0Compiler$MakeCanonical$expressionDeps)($e, $deps);
                      }))()
                      : ((($expression)[0] === "$Call")
                        ? ((() => {
                          const $e0 = ($expression)[2];
                          const $args = ($expression)[3];
                          return ((($0) => {
                            return (c0List$for)($0, $args, u0Compiler$MakeCanonical$argumentDeps);
                          }))(((($0) => {
                            return (u0Compiler$MakeCanonical$expressionDeps)($e0, $0);
                          }))($deps));
                        }))()
                        : ((($expression)[0] === "$If")
                          ? ((() => {
                            const $args = ($expression)[2];
                            return ((($0) => {
                              return (u0Compiler$MakeCanonical$expressionDeps)($args.false, $0);
                            }))(((($0) => {
                              return (u0Compiler$MakeCanonical$expressionDeps)($args.true, $0);
                            }))(((($0) => {
                              return (u0Compiler$MakeCanonical$expressionDeps)($args.condition, $0);
                            }))($deps)));
                          }))()
                          : ((($expression)[0] === "$Try")
                            ? ((() => {
                              const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                              const $value = ($expression)[2].value;
                              const $addDeps = (($4, $d) => {
                                const $u = $4.first;
                                const $p = $4.second;
                                const $b = $4.third;
                                return ((($0) => {
                                  return (u0Compiler$MakeCanonical$expressionDeps)($b, $0);
                                }))(((($0) => {
                                  return (u0Compiler$MakeCanonical$patternDeps)($p, $0);
                                }))($d));
                              });
                              return ((($0) => {
                                return (c0List$for)($0, $patternsAndExpressions, $addDeps);
                              }))(((($0) => {
                                return (u0Compiler$MakeCanonical$expressionDeps)($value, $0);
                              }))($deps));
                            }))()
                            : ((($expression)[0] === "$LetIn")
                              ? ((() => {
                                const $valueDef = ($expression)[1];
                                const $e = ($expression)[2];
                                return ((($0) => {
                                  return (u0Compiler$MakeCanonical$expressionDeps)($e, $0);
                                }))(((($0) => {
                                  return (u0Compiler$MakeCanonical$expressionDeps)($valueDef.body, $0);
                                }))(((($0) => {
                                  return (u0Compiler$MakeCanonical$patternDeps)($valueDef.pattern, $0);
                                }))($deps)));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 130:4', (sp_toHuman)($expression))))))))))))))));
});

const u0Compiler$MakeCanonical$escapeLiteralText = (($singleOrTriple, $l) => {
  return ((($singleOrTriple)[0] === "$SingleQuote")
    ? $l
    : ((($singleOrTriple)[0] === "$TripleQuote")
      ? ((($0) => {
        return (c0Text$replace)("\n", "\\n", $0);
      }))(((($0) => {
        return (c0Text$replace)("\"", "\\\"", $0);
      }))($l))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 551:8', (sp_toHuman)($singleOrTriple))));
});

const u0Compiler$MakeCanonical$isPlaceholder = (($1) => {
  const $expr = ($1)[3];
  return ((($expr)[0] === "$ArgumentPlaceholder")
    ? true
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1058:4', (sp_toHuman)($expr))));
});

const u0Compiler$MakeCanonical$makePartiallyAppliedFunction = (($env, $pos, $placeholdersCount, $body) => {
  const $ex = (($0) => {
    return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $pos, $0);
  });
  return ((($0) => {
    return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
  }))(($ex)(((($0) => {
    return (c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Inline, $0, ($ex)($body));
  }))(((($0) => {
    return (c0List$map)((($x) => {
      return ($ex)((c0Compiler$FormattableAst$ResolvedArgumentPlaceholder)($x));
    }), $0);
  }))((c0List$range)(0, ($placeholdersCount - 1))))));
});

const u0Compiler$MakeCanonical$translateArgument = (($env, $faExpression) => {
  const $3 = $faExpression;
  const $expr = ($3)[3];
  const $pos = ($3)[2];
  return (((($expr)[0] === "$UnopCall") && (((($expr)[1])[0] === "$UnopRecycle") && ((($expr)[2])[0] === "$Expression")))
    ? ((() => {
      const $faOperand = (($expr)[2])[3];
      return ((($faOperand)[0] === "$Lowercase")
        ? ((() => {
          const $attrPath = ($faOperand)[1].attrPath;
          const $maybeModule = ($faOperand)[1].maybeModule;
          const $maybeType = ($faOperand)[1].maybeType;
          const $name = ($faOperand)[1].name;
          return ((sp_not_equal)($maybeType, c0Maybe$Nothing)
            ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Sorry, at least for now annotations are not supported here", c0Core$Nil))
            : ((sp_not_equal)($maybeModule, c0Maybe$Nothing)
              ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Only values declared inside a function scope can be mutated!", c0Core$Nil))
              : (c0Result$Ok)((c0Compiler$CanonicalAst$ArgumentRecycle)($pos, $name, $attrPath))));
        }))()
        : (true
          ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("I can recycle only variables!", c0Core$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1030:12', (sp_toHuman)($faOperand))));
    }))()
    : ((($expr)[0] === "$ArgumentPlaceholder")
      ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("compiler error: this should have been eliminated already", c0Core$Nil))
      : ((($expr)[0] === "$ResolvedArgumentPlaceholder")
        ? ((() => {
          const $n = ($expr)[1];
          return (c0Result$Ok)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)($pos, (c0Compiler$Ast$RefPlaceholder)($n))));
        }))()
        : (true
          ? ((c0Result$onOk)((($caExpr) => {
            return (c0Result$Ok)((c0Compiler$CanonicalAst$ArgumentExpression)($caExpr));
          })))(((($0) => {
            return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
          }))($faExpression))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1027:4', (sp_toHuman)($expr))))));
});

const u0Compiler$MakeCanonical$resolvePipe = (($env, $pos, $opChain) => {
  return ((c0Compiler$FormattableAst$binopChainAllBinops)((($sep) => {
    return (sp_equal)($sep.usr, u0Compiler$CoreDefs$sendRight.usr);
  }), $opChain)
    ? ((() => {
      const $4 = $opChain;
      const $chainTail = $4.second;
      const $head = $4.first;
      return (c0Result$Ok)((c0List$for)($head, $chainTail, (($6, $acc) => {
        const $sep = $6.first;
        const $faExp = $6.second;
        const $7 = $faExp;
        const $p = ($7)[2];
        return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $p, (c0Compiler$FormattableAst$Call)($faExp, (c0Core$Cons)($acc, c0Core$Nil)));
      })));
    }))()
    : ((c0Compiler$FormattableAst$binopChainAllBinops)((($sep) => {
      return (sp_equal)($sep.usr, u0Compiler$CoreDefs$sendLeft.usr);
    }), $opChain)
      ? ((() => {
        const $4 = (c0Compiler$FormattableAst$binopChainReverse)($opChain);
        const $body = $4.second;
        const $last = $4.first;
        return (c0Result$Ok)((c0List$for)($last, $body, (($6, $acc) => {
          const $sep = $6.first;
          const $faExp = $6.second;
          const $7 = $faExp;
          const $p = ($7)[2];
          return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $p, (c0Compiler$FormattableAst$Call)($faExp, (c0Core$Cons)($acc, c0Core$Nil)));
        })));
      }))()
      : (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Mixing `>>` and `<<` is ambiguous. Use parens!", c0Core$Nil))));
});

const u0Compiler$MakeCanonical$sameDirectionAs = (($a, $b) => {
  return ((sp_equal)($a.symbol, $b.symbol)
    ? true
    : ((() => {
      const $3 = $a.symbol;
      return ((">" === $3)
        ? (sp_equal)($b.symbol, ">=")
        : ((">=" === $3)
          ? (sp_equal)($b.symbol, ">")
          : (("<" === $3)
            ? (sp_equal)($b.symbol, "<=")
            : (("<=" === $3)
              ? (sp_equal)($b.symbol, "<")
              : (true
                ? false
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1223:8', (sp_toHuman)($3)))))));
    }))());
});

const u0Compiler$MakeCanonical$translateRightAssociativeBinopChain = (($env, $pos, $1) => {
  const $faLeft = $1.first;
  const $faOpsAndRight = $1.second;
  return ((($faOpsAndRight)[0] === "$Nil")
    ? (u0Compiler$MakeCanonical$translateExpression)($env, $faLeft)
    : ((($faOpsAndRight)[0] === "$Cons")
      ? ((() => {
        const $op = ($faOpsAndRight)[1].first;
        const $faRight = ($faOpsAndRight)[1].second;
        const $faTail = ($faOpsAndRight)[2];
        return ((c0Result$onOk)((($caLeft) => {
          return ((c0Result$onOk)((($caRight) => {
            const $caRef = (c0Compiler$CanonicalAst$Variable)($op.pos, (c0Compiler$Ast$RefGlobal)($op.usr));
            return (c0Result$Ok)((c0Compiler$CanonicalAst$Call)($pos, $caRef, (c0Core$Cons)($caLeft, (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)($caRight), c0Core$Nil))));
          })))((u0Compiler$MakeCanonical$translateRightAssociativeBinopChain)($env, $pos, ({
            first: $faRight,
            second: $faTail,
          })));
        })))((u0Compiler$MakeCanonical$translateArgument)($env, $faLeft));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1233:4', (sp_toHuman)($faOpsAndRight))));
});

const u0Compiler$MakeCanonical$translateComparison = (($env, $pos, $opChain) => {
  const $4 = $opChain.second;
  return ((($4)[0] === "$Nil")
    ? (u0Compiler$MakeCanonical$translateExpression)($env, $opChain.first)
    : (((($4)[0] === "$Cons") && ((($4)[2])[0] === "$Nil"))
      ? ((() => {
        const $sep = ($4)[1].first;
        const $second = ($4)[1].second;
        return (u0Compiler$MakeCanonical$translateRightAssociativeBinopChain)($env, $pos, $opChain);
      }))()
      : ((($4)[0] === "$Cons")
        ? ((() => {
          const $firstSep = ($4)[1].first;
          const $second = ($4)[1].second;
          const $moar = ($4)[2];
          return ((c0Compiler$FormattableAst$binopChainAllBinops)((($0) => {
            return (u0Compiler$MakeCanonical$sameDirectionAs)($firstSep, $0);
          }), $opChain)
            ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("TODO: not (yet) implemented: compops expansion", c0Core$Nil))
            : (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("can't mix comparison ops with different direction", c0Core$Nil)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1170:4', (sp_toHuman)($4)))));
});

const u0Compiler$MakeCanonical$translateLogical = (($env, $pos, $opChain) => {
  const $allSame = ((c0Compiler$FormattableAst$binopChainAllBinops)((($sep) => {
    return (sp_equal)($sep.usr, u0Compiler$CoreDefs$and_.usr);
  }), $opChain) || (c0Compiler$FormattableAst$binopChainAllBinops)((($sep) => {
    return (sp_equal)($sep.usr, u0Compiler$CoreDefs$or_.usr);
  }), $opChain));
  return ($allSame
    ? (u0Compiler$MakeCanonical$translateRightAssociativeBinopChain)($env, $pos, $opChain)
    : (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Mixing `and` and `or` is ambiguous. Use parens!", c0Core$Nil)));
});

const u0Compiler$MakeCanonical$translateMutop = (($env, $pos, $1) => {
  const $left = $1.first;
  const $chainTail = $1.second;
  return ((($chainTail)[0] === "$Nil")
    ? (u0Compiler$MakeCanonical$translateExpression)($env, $left)
    : (((($chainTail)[0] === "$Cons") && ((($chainTail)[2])[0] === "$Nil"))
      ? ((() => {
        const $op = ($chainTail)[1].first;
        const $right = ($chainTail)[1].second;
        const $caRef = (c0Compiler$CanonicalAst$Variable)($op.pos, (c0Compiler$Ast$RefGlobal)($op.usr));
        return ((c0Result$onOk)((($caArgs) => {
          return (c0Result$Ok)((c0Compiler$CanonicalAst$Call)($pos, $caRef, $caArgs));
        })))(((($0) => {
          return (c0List$mapRes)((($0) => {
            return (u0Compiler$MakeCanonical$translateArgument)($env, $0);
          }), $0);
        }))((c0Core$Cons)($left, (c0Core$Cons)($right, c0Core$Nil))));
      }))()
      : (true
        ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("mutops can't be chained", c0Core$Nil))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1200:4', (sp_toHuman)($chainTail)))));
});

const u0Compiler$MakeCanonical$translateTupleExpression = (($env, $pos, $1) => {
  const $one = $1.first;
  const $chainTail = $1.second;
  return ((($chainTail)[0] === "$Nil")
    ? (u0Compiler$MakeCanonical$translateExpression)($env, $one)
    : (((($chainTail)[0] === "$Cons") && ((($chainTail)[2])[0] === "$Nil"))
      ? ((() => {
        const $two = ($chainTail)[1].second;
        return ((c0Result$onOk)((($first) => {
          return ((c0Result$onOk)((($second) => {
            return (c0Result$Ok)(((($0) => {
              return (c0Compiler$CanonicalAst$Record)($pos, c0Maybe$Nothing, $0);
            }))(((($0) => {
              return (c0Dict$insert)("second", $second, $0);
            }))(((($0) => {
              return (c0Dict$insert)("first", $first, $0);
            }))(c0Dict$empty))));
          })))((u0Compiler$MakeCanonical$translateExpression)($env, $two));
        })))((u0Compiler$MakeCanonical$translateExpression)($env, $one));
      }))()
      : (((($chainTail)[0] === "$Cons") && (((($chainTail)[2])[0] === "$Cons") && (((($chainTail)[2])[2])[0] === "$Nil")))
        ? ((() => {
          const $two = ($chainTail)[1].second;
          const $three = (($chainTail)[2])[1].second;
          return ((c0Result$onOk)((($first) => {
            return ((c0Result$onOk)((($second) => {
              return ((c0Result$onOk)((($third) => {
                return (c0Result$Ok)(((($0) => {
                  return (c0Compiler$CanonicalAst$Record)($pos, c0Maybe$Nothing, $0);
                }))(((($0) => {
                  return (c0Dict$insert)("third", $third, $0);
                }))(((($0) => {
                  return (c0Dict$insert)("second", $second, $0);
                }))(((($0) => {
                  return (c0Dict$insert)("first", $first, $0);
                }))(c0Dict$empty)))));
              })))((u0Compiler$MakeCanonical$translateExpression)($env, $three));
            })))((u0Compiler$MakeCanonical$translateExpression)($env, $two));
          })))((u0Compiler$MakeCanonical$translateExpression)($env, $one));
        }))()
        : (true
          ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Tuples can't have more than 3 items, use a record instead.", c0Core$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1134:4', (sp_toHuman)($chainTail))))));
});

const u0Compiler$MakeCanonical$translateBinopChain = (($env, $pos, $group, $opChain) => {
  const $toExpression = (($0) => {
    return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $pos, $0);
  });
  const $5 = ((u0Compiler$MakeCanonical$isPlaceholder)($opChain.first)
    ? ({
      first: 1,
      second: ($toExpression)((c0Compiler$FormattableAst$ResolvedArgumentPlaceholder)(0)),
    })
    : ({
      first: 0,
      second: $opChain.first,
    }));
  const $head = $5.second;
  const $cnt0 = $5.first;
  const $6 = (c0List$for)(({
    first: $cnt0,
    second: c0Core$Nil,
  }), $opChain.second, (($8, $7) => {
    const $op = $8.first;
    const $exp = $8.second;
    const $cnt = $7.first;
    const $rev = $7.second;
    return ((u0Compiler$MakeCanonical$isPlaceholder)($exp)
      ? ((() => {
        const $9 = $exp;
        const $p = ($9)[2];
        const $c = ($9)[1];
        return ({
          first: ($cnt + 1),
          second: (c0Core$Cons)(({
            first: $op,
            second: (c0Compiler$FormattableAst$Expression)($c, $p, (c0Compiler$FormattableAst$ResolvedArgumentPlaceholder)($cnt)),
          }), $rev),
        });
      }))()
      : ({
        first: $cnt,
        second: (c0Core$Cons)(({
          first: $op,
          second: $exp,
        }), $rev),
      }));
  }));
  const $reversedChainTail = $6.second;
  const $placeholdersCount = $6.first;
  return (($placeholdersCount > 0)
    ? ((($0) => {
      return (u0Compiler$MakeCanonical$makePartiallyAppliedFunction)($env, $pos, $placeholdersCount, $0);
    }))((c0Compiler$FormattableAst$BinopChain)($group, ({
      first: $head,
      second: (c0List$reverse)($reversedChainTail),
    })))
    : ((sp_equal)($group, c0Compiler$Op$precedence_pipe)
      ? ((c0Result$onOk)((($0) => {
        return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
      })))((u0Compiler$MakeCanonical$resolvePipe)($env, $pos, $opChain))
      : ((sp_equal)($group, c0Compiler$Op$precedence_tuple)
        ? (u0Compiler$MakeCanonical$translateTupleExpression)($env, $pos, $opChain)
        : ((sp_equal)($group, c0Compiler$Op$precedence_comparison)
          ? (u0Compiler$MakeCanonical$translateComparison)($env, $pos, $opChain)
          : ((sp_equal)($group, c0Compiler$Op$precedence_logical)
            ? (u0Compiler$MakeCanonical$translateLogical)($env, $pos, $opChain)
            : ((sp_equal)($group, c0Compiler$Op$precedence_mutop)
              ? (u0Compiler$MakeCanonical$translateMutop)($env, $pos, $opChain)
              : (u0Compiler$MakeCanonical$translateRightAssociativeBinopChain)($env, $pos, $opChain)))))));
});

const u0Compiler$MakeCanonical$translateNumber = (($ro, $isPercent, $constructor, $pos, $numberAsText) => {
  const $6 = (text_toNumber)((c0Text$replace)("_", "", $numberAsText));
  return ((($6)[0] === "$Nothing")
    ? (u0Compiler$MakeCanonical$erroro)($ro, $pos, (c0Core$Cons)(("invalid number: `" + ($numberAsText + "`")), (c0Core$Cons)("TODO link to documentation on valid number formats", c0Core$Nil)))
    : ((($6)[0] === "$Just")
      ? ((() => {
        const $n = ($6)[1];
        return (c0Result$Ok)(($constructor)($pos, ($isPercent
          ? (sp_divide)($n, 100)
          : $n)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 942:4', (sp_toHuman)($6))));
});

const u0Compiler$MakeCanonical$translateMaybeAnnotation = (($env, $maybeFaType) => {
  return ((($maybeFaType)[0] === "$Nothing")
    ? (c0Result$Ok)(c0Maybe$Nothing)
    : ((($maybeFaType)[0] === "$Just")
      ? ((() => {
        const $faType = ($maybeFaType)[1];
        return ((c0Result$onOk)((($raw) => {
          const $tyvars = ((($0) => {
            return (c0Dict$map)((($tyvarName, $pos) => {
              return ({
                nonFn: (c0Dict$get)($tyvarName, $env.nonFn),
              });
            }), $0);
          }))((c0Compiler$CanonicalAst$typeTyvars)($raw));
          return (c0Result$Ok)((c0Maybe$Just)(({
            raw: $raw,
            tyvars: $tyvars,
            univars: (c0Compiler$CanonicalAst$typeUnivars)($raw),
          })));
        })))((u0Compiler$MakeCanonical$translateRawType)($env.ro, $faType));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 319:4', (sp_toHuman)($maybeFaType))));
});

const u0Compiler$MakeCanonical$translatePatternAny = (($env, $pos, $maybeType, $maybeModule, $name, $attrPath) => {
  return ((sp_not_equal)($attrPath, c0Core$Nil)
    ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("pattern names can't have type attributes", c0Core$Nil))
    : ((c0Result$onOk)((($maybeAnnotation) => {
      const $maybeName = ((sp_equal)($name, "_")
        ? c0Maybe$Nothing
        : (c0Maybe$Just)($name));
      return (c0Result$Ok)((c0Compiler$CanonicalAst$PatternAny)($pos, $maybeName, $maybeAnnotation));
    })))((u0Compiler$MakeCanonical$translateMaybeAnnotation)($env, $maybeType)));
});

const u0Compiler$MakeCanonical$translatePatternConstructor = (($env, $pos, $maybeModule, $name, $args) => {
  return ((c0Result$onOk)((($usr) => {
    return (c0Result$Ok)((c0Compiler$CanonicalAst$PatternConstructor)($pos, $usr, $args));
  })))((u0Compiler$MakeCanonical$resolveToUsr)($env.ro, $pos, $maybeModule, $name));
});

const u0Compiler$MakeCanonical$insertPatternRecordAttribute = (($env, $attr, $caAttrs) => {
  return ((c0Result$onOk)((($4) => {
    const $pos = $4.first;
    const $caName = $4.second;
    const $maybeFaType = $4.third;
    return ((c0Dict$member)($caName, $caAttrs)
      ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)(("duplicate attribute name in pattern: " + $caName), c0Core$Nil))
      : ((() => {
        const $5 = ({
          first: $attr.maybeExpr,
          second: $maybeFaType,
        });
        return (((($5.first)[0] === "$Just") && ((($5.second)[0] === "$Just") && ((($5.second)[1])[0] === "$Expression")))
          ? ((() => {
            const $typePos = (($5.second)[1])[2];
            return (u0Compiler$MakeCanonical$error)($env, $typePos, (c0Core$Cons)("if you want to annotate the attribute, use { x = y as TheType }", c0Core$Nil));
          }))()
          : (((($5.first)[0] === "$Nothing") && (($5.second)[0] === "$Just"))
            ? ((() => {
              const $faType = ($5.second)[1];
              return (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("TODO annotating record attributes needs more thinking", c0Core$Nil));
            }))()
            : (((($5.first)[0] === "$Just") && (($5.second)[0] === "$Nothing"))
              ? ((() => {
                const $faPattern = ($5.first)[1];
                return ((c0Result$onOk)((($caPattern) => {
                  return (c0Result$Ok)(((($0) => {
                    return (c0Dict$insert)($caName, $caPattern, $0);
                  }))($caAttrs));
                })))(((($0) => {
                  return (u0Compiler$MakeCanonical$translateRawPattern)($env, $0);
                }))($faPattern));
              }))()
              : (((($5.first)[0] === "$Nothing") && (($5.second)[0] === "$Nothing"))
                ? (c0Result$Ok)(((($0) => {
                  return (c0Dict$insert)($caName, (c0Compiler$CanonicalAst$PatternAny)($pos, (c0Maybe$Just)($caName), c0Maybe$Nothing), $0);
                }))($caAttrs))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 346:8', (sp_toHuman)($5))))));
      }))());
  })))((u0Compiler$MakeCanonical$translateAttributeName)($env.ro, $attr.name));
});

const u0Compiler$MakeCanonical$translatePatternRecord = (($env, $pos, $maybeMaybeExt, $attrs) => {
  return ((c0Result$onOk)((($completeness) => {
    return ((($0) => {
      return (c0Result$map)((($x) => {
        return (c0Compiler$CanonicalAst$PatternRecord)($pos, $completeness, $x);
      }), $0);
    }))(((($0) => {
      return (c0List$forRes)($0, $attrs, (($0, $1) => {
        return (u0Compiler$MakeCanonical$insertPatternRecordAttribute)($env, $0, $1);
      }));
    }))(c0Dict$empty));
  })))((((($maybeMaybeExt)[0] === "$Just") && (((($maybeMaybeExt)[1])[0] === "$Just") && (((($maybeMaybeExt)[1])[1])[0] === "$Expression")))
    ? ((() => {
      const $p = ((($maybeMaybeExt)[1])[1])[2];
      const $expr_ = ((($maybeMaybeExt)[1])[1])[3];
      return (u0Compiler$MakeCanonical$error)($env, $p, (c0Core$Cons)("Can't extend patterns", c0Core$Nil));
    }))()
    : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Nothing"))
      ? (c0Result$Ok)(c0Compiler$CanonicalAst$Partial)
      : ((($maybeMaybeExt)[0] === "$Nothing")
        ? (c0Result$Ok)(c0Compiler$CanonicalAst$Complete)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 378:4', (sp_toHuman)($maybeMaybeExt))))));
});

const u0Compiler$MakeCanonical$translateRawPattern = (($env, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Constructor")
    ? ((() => {
      const $maybeModule = ($expr_)[1].maybeModule;
      const $name = ($expr_)[1].name;
      return (u0Compiler$MakeCanonical$translatePatternConstructor)($env, $pos, $maybeModule, $name, c0Core$Nil);
    }))()
    : ((($expr_)[0] === "$Lowercase")
      ? ((() => {
        const $attrPath = ($expr_)[1].attrPath;
        const $maybeModule = ($expr_)[1].maybeModule;
        const $maybeType = ($expr_)[1].maybeType;
        const $name = ($expr_)[1].name;
        return (u0Compiler$MakeCanonical$translatePatternAny)($env, $pos, $maybeType, $maybeModule, $name, $attrPath);
      }))()
      : (((($expr_)[0] === "$Call") && ((($expr_)[1])[0] === "$Expression"))
        ? ((() => {
          const $p = (($expr_)[1])[2];
          const $ref = (($expr_)[1])[3];
          const $faArgs = ($expr_)[2];
          return ((($ref)[0] === "$Constructor")
            ? ((() => {
              const $maybeModule = ($ref)[1].maybeModule;
              const $name = ($ref)[1].name;
              return ((c0Result$onOk)((($caPars) => {
                return (u0Compiler$MakeCanonical$translatePatternConstructor)($env, $pos, $maybeModule, $name, $caPars);
              })))(((($0) => {
                return (c0List$mapRes)((($0) => {
                  return (u0Compiler$MakeCanonical$translateRawPattern)($env, $0);
                }), $0);
              }))($faArgs));
            }))()
            : (true
              ? (u0Compiler$MakeCanonical$error)($env, $p, (c0Core$Cons)("I need 'constructor name here", c0Core$Nil))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 447:12', (sp_toHuman)($ref))));
        }))()
        : ((($expr_)[0] === "$List")
          ? ((() => {
            const $faItems = ($expr_)[2];
            const $reversedFaItems = (c0List$reverse)($faItems);
            const $pushItem = (($pattern, $last) => {
              return (c0Compiler$CanonicalAst$PatternConstructor)((c0Compiler$CanonicalAst$patternPos)($pattern), u0Compiler$CoreDefs$consUsr, (c0Core$Cons)($pattern, (c0Core$Cons)($last, c0Core$Nil)));
            });
            return ((($reversedFaItems)[0] === "$Nil")
              ? (c0Result$Ok)((c0Compiler$CanonicalAst$PatternConstructor)($pos, u0Compiler$CoreDefs$nilUsr, c0Core$Nil))
              : (((($reversedFaItems)[0] === "$Cons") && ((($reversedFaItems)[1].second)[0] === "$Expression"))
                ? ((() => {
                  const $lastHasDots = ($reversedFaItems)[1].first;
                  const $p = (($reversedFaItems)[1].second)[2];
                  const $lastFaExpr = (($reversedFaItems)[1].second)[3];
                  const $reversedFaRest = ($reversedFaItems)[2];
                  return ((c0List$any)(c0Tuple$first, $reversedFaRest)
                    ? (u0Compiler$MakeCanonical$error)($env, $p, (c0Core$Cons)("only the last item in a list can have ... triple dots", c0Core$Nil))
                    : ((c0Basics$not)($lastHasDots)
                      ? ((c0Result$onOk)((($reversedCaItems) => {
                        return (c0Result$Ok)((c0List$for)((c0Compiler$CanonicalAst$PatternConstructor)($p, u0Compiler$CoreDefs$nilUsr, c0Core$Nil), $reversedCaItems, $pushItem));
                      })))(((($0) => {
                        return (c0List$mapRes)((($4) => {
                          const $hasDots = $4.first;
                          const $expr = $4.second;
                          return (u0Compiler$MakeCanonical$translateRawPattern)($env, $expr);
                        }), $0);
                      }))($reversedFaItems))
                      : ((c0Result$onOk)((($reversedCaRest) => {
                        return ((($lastFaExpr)[0] === "$Lowercase")
                          ? ((() => {
                            const $attrPath = ($lastFaExpr)[1].attrPath;
                            const $maybeModule = ($lastFaExpr)[1].maybeModule;
                            const $maybeType = ($lastFaExpr)[1].maybeType;
                            const $name = ($lastFaExpr)[1].name;
                            return ((c0Result$onOk)((($caInit) => {
                              return (c0Result$Ok)((c0List$for)($caInit, $reversedCaRest, $pushItem));
                            })))((u0Compiler$MakeCanonical$translatePatternAny)($env, $pos, $maybeType, $maybeModule, $name, $attrPath));
                          }))()
                          : (true
                            ? (u0Compiler$MakeCanonical$error)($env, $p, (c0Core$Cons)("sorry, I don't understand the dots here...", c0Core$Nil))
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 483:24', (sp_toHuman)($lastFaExpr))));
                      })))(((($0) => {
                        return (c0List$mapRes)((($4) => {
                          const $hasDots = $4.first;
                          const $expr = $4.second;
                          return (u0Compiler$MakeCanonical$translateRawPattern)($env, $expr);
                        }), $0);
                      }))($reversedFaRest))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 466:12', (sp_toHuman)($reversedFaItems))));
          }))()
          : ((($expr_)[0] === "$Record")
            ? ((() => {
              const $attrs = ($expr_)[1].attrs;
              const $maybeExtension = ($expr_)[1].maybeExtension;
              return (u0Compiler$MakeCanonical$translatePatternRecord)($env, $pos, $maybeExtension, $attrs);
            }))()
            : ((($expr_)[0] === "$BinopChain")
              ? ((() => {
                const $precedence = ($expr_)[1];
                const $chain = ($expr_)[2];
                return ((sp_equal)($precedence, c0Compiler$Op$precedence_tuple)
                  ? ((c0Result$onOk)((($recordAttrs) => {
                    return (c0Result$Ok)((c0Compiler$CanonicalAst$PatternRecord)($pos, c0Compiler$CanonicalAst$Complete, $recordAttrs));
                  })))(((($0) => {
                    return (u0Compiler$MakeCanonical$translateTuple)($env.ro, (($0) => {
                      return (u0Compiler$MakeCanonical$translateRawPattern)($env, $0);
                    }), $0);
                  }))($chain))
                  : ((sp_equal)($precedence, c0Compiler$Op$precedence_cons)
                    ? ((c0Result$onOk)((($caPas) => {
                      const $4 = (c0List$reverse)($caPas);
                      return ((($4)[0] === "$Cons")
                        ? ((() => {
                          const $last = ($4)[1];
                          const $rest = ($4)[2];
                          return (c0Result$Ok)(((($0) => {
                            return (c0List$for)($0, $rest, (($item, $list) => {
                              return (c0Compiler$CanonicalAst$PatternConstructor)($pos, u0Compiler$CoreDefs$consUsr, (c0Core$Cons)($item, (c0Core$Cons)($list, c0Core$Nil)));
                            }));
                          }))($last));
                        }))()
                        : ((($4)[0] === "$Nil")
                          ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("should not happen: empty cons pattern", c0Core$Nil))
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 507:16', (sp_toHuman)($4))));
                    })))(((($0) => {
                      return (c0List$mapRes)((($0) => {
                        return (u0Compiler$MakeCanonical$translateRawPattern)($env, $0);
                      }), $0);
                    }))((c0Compiler$FormattableAst$binopChainExpressions)($chain)))
                    : (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("This binop can't be used in pattern matching", c0Core$Nil))));
              }))()
              : ((($expr_)[0] === "$LiteralText")
                ? ((() => {
                  const $singleOrTriple = ($expr_)[1];
                  const $l = ($expr_)[2];
                  return (c0Result$Ok)(((($0) => {
                    return (c0Compiler$CanonicalAst$PatternLiteralText)($pos, $0);
                  }))(((($0) => {
                    return (u0Compiler$MakeCanonical$escapeLiteralText)($singleOrTriple, $0);
                  }))($l)));
                }))()
                : ((($expr_)[0] === "$LiteralNumber")
                  ? ((() => {
                    const $isPercent = ($expr_)[1];
                    const $l = ($expr_)[2];
                    return (u0Compiler$MakeCanonical$translateNumber)($env.ro, $isPercent, c0Compiler$CanonicalAst$PatternLiteralNumber, $pos, $l);
                  }))()
                  : ((($expr_)[0] === "$Uppercase")
                    ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("WUT", c0Core$Nil))
                    : ((($expr_)[0] === "$Statements")
                      ? ((() => {
                        const $stats = ($expr_)[1];
                        return (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("WAT", c0Core$Nil));
                      }))()
                      : ((($expr_)[0] === "$Fn")
                        ? ((() => {
                          const $args = ($expr_)[2];
                          const $body = ($expr_)[3];
                          return (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Can't pattern match on functions. =(", c0Core$Nil));
                        }))()
                        : ((($expr_)[0] === "$UnopCall")
                          ? ((() => {
                            const $unop = ($expr_)[1];
                            const $expr = ($expr_)[2];
                            return (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("This op can't be used in pattern matching", c0Core$Nil));
                          }))()
                          : ((($expr_)[0] === "$If")
                            ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("if..then can't be used in pattern matching", c0Core$Nil))
                            : ((($expr_)[0] === "$Try")
                              ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("try..as can't be used in pattern matching", c0Core$Nil))
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 438:4', (sp_toHuman)($expr_))))))))))))))));
});

const u0Compiler$MakeCanonical$translateFullPattern = (($env, $expr) => {
  return ((c0Result$onOk)((($3) => {
    const $uni = $3.first;
    const $e = $3.second;
    return ((c0Result$onOk)((($caPa) => {
      return (c0Result$Ok)(({
        first: $uni,
        second: $caPa,
      }));
    })))((u0Compiler$MakeCanonical$translateRawPattern)($env, $e));
  })))(((($0) => {
    return (u0Compiler$MakeCanonical$translatePoly)($env.ro, $0);
  }))($expr));
});

const u0Compiler$MakeCanonical$translateLowercase = (($env, $pos, $1) => {
  const $attrPath = $1.attrPath;
  const $maybeModule = $1.maybeModule;
  const $maybeType = $1.maybeType;
  const $name = $1.name;
  return ((sp_not_equal)($maybeType, c0Maybe$Nothing)
    ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("no annotations on var reference", c0Core$Nil))
    : ((() => {
      const $isLocal = ((sp_equal)($maybeModule, c0Maybe$Nothing) && ((() => {
        const $4 = (c0Dict$get)($name, $env.values);
        return ((($4)[0] === "$Nothing")
          ? false
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $paName = ($4)[1];
              return (c0Basics$not)($paName.isRoot);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 878:16', (sp_toHuman)($4))));
      }))());
      return ((c0Result$onOk)((($ref) => {
        return (c0Result$Ok)(((($0) => {
          return (c0List$for)($0, $attrPath, (($0, $1) => {
            return (c0Compiler$CanonicalAst$RecordAccess)($pos, $0, $1);
          }));
        }))((c0Compiler$CanonicalAst$Variable)($pos, $ref)));
      })))(($isLocal
        ? (c0Result$Ok)((c0Compiler$Ast$RefLocal)($name))
        : ((($0) => {
          return (c0Result$map)(c0Compiler$Ast$RefGlobal, $0);
        }))((u0Compiler$MakeCanonical$resolveToUsr)($env.ro, $pos, $maybeModule, $name))));
    }))());
});

const u0Compiler$MakeCanonical$translateParameter = (($env, $fa) => {
  const $3 = $fa;
  const $faExpr = ($3)[3];
  const $pos = ($3)[2];
  return (((($faExpr)[0] === "$UnopCall") && (((($faExpr)[1])[0] === "$UnopRecycle") && ((($faExpr)[2])[0] === "$Expression")))
    ? ((() => {
      const $p = (($faExpr)[2])[2];
      const $faOperand = (($faExpr)[2])[3];
      return (((($faOperand)[0] === "$Lowercase") && ((($faOperand)[1].maybeType)[0] === "$Nothing"))
        ? ((() => {
          const $attrPath = ($faOperand)[1].attrPath;
          const $maybeModule = ($faOperand)[1].maybeModule;
          const $name = ($faOperand)[1].name;
          return (((sp_not_equal)($maybeModule, c0Maybe$Nothing) || (sp_not_equal)($attrPath, c0Core$Nil))
            ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("I need a lowercase local variable name here... =|", c0Core$Nil))
            : (c0Result$Ok)((c0Compiler$CanonicalAst$ParameterRecycle)($pos, $name)));
        }))()
        : (true
          ? (u0Compiler$MakeCanonical$error)($env, $p, (c0Core$Cons)("@ should be followed by a variable name to recycle!", c0Core$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 920:12', (sp_toHuman)($faOperand))));
    }))()
    : ((($faExpr)[0] === "$ResolvedArgumentPlaceholder")
      ? ((() => {
        const $n = ($faExpr)[1];
        return (c0Result$Ok)((c0Compiler$CanonicalAst$ParameterPlaceholder)($n));
      }))()
      : (true
        ? ((c0Result$onOk)((($4) => {
          const $uni = $4.first;
          const $ca = $4.second;
          return (c0Result$Ok)((c0Compiler$CanonicalAst$ParameterPattern)($uni, $ca));
        })))((u0Compiler$MakeCanonical$translateFullPattern)($env, $fa))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 917:4', (sp_toHuman)($faExpr)))));
});

const u0Compiler$MakeCanonical$translateAndInsertRecordAttribute = (($env, $attr, $caAttrsAccum) => {
  return ((c0Result$onOk)((($4) => {
    const $pos = $4.first;
    const $caName = $4.second;
    const $maybeFaType = $4.third;
    return ((c0Dict$member)($caName, $caAttrsAccum)
      ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)(("duplicate attribute: " + $caName), c0Core$Nil))
      : ((c0Result$onOk)((($caExpr) => {
        return (c0Result$Ok)(((($0) => {
          return (c0Dict$insert)($caName, $caExpr, $0);
        }))($caAttrsAccum));
      })))(((($0) => {
        return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
      }))(((($0) => {
        return (c0Maybe$withDefault)($attr.name, $0);
      }))($attr.maybeExpr))));
  })))((u0Compiler$MakeCanonical$translateAttributeName)($env.ro, $attr.name));
});

const u0Compiler$MakeCanonical$translateRecord = (($env, $pos, $maybeMaybeExtension, $attrs) => {
  const $zzz = (((($maybeMaybeExtension)[0] === "$Just") && ((($maybeMaybeExtension)[1])[0] === "$Just"))
    ? ((() => {
      const $ext = (($maybeMaybeExtension)[1])[1];
      return ((($0) => {
        return (c0Result$map)(c0Maybe$Just, $0);
      }))((u0Compiler$MakeCanonical$translateExpression)($env, $ext));
    }))()
    : (((($maybeMaybeExtension)[0] === "$Just") && ((($maybeMaybeExtension)[1])[0] === "$Nothing"))
      ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("I need to know what record you are updating", c0Core$Nil))
      : ((($maybeMaybeExtension)[0] === "$Nothing")
        ? (c0Result$Ok)(c0Maybe$Nothing)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 960:8', (sp_toHuman)($maybeMaybeExtension)))));
  return ((c0Result$onOk)((($maybeCaExt) => {
    return ((($maybeCaExt)[0] === "$Nothing")
      ? ((c0Result$onOk)((($caAttrs) => {
        return (c0Result$Ok)((c0Compiler$CanonicalAst$Record)($pos, c0Maybe$Nothing, $caAttrs));
      })))(((($0) => {
        return (c0List$forRes)($0, $attrs, (($0, $1) => {
          return (u0Compiler$MakeCanonical$translateAndInsertRecordAttribute)(((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              maybeShorthandTarget: c0Maybe$Nothing,
            }));
          }))(), $0, $1);
        }));
      }))(c0Dict$empty))
      : ((($maybeCaExt)[0] === "$Just")
        ? ((() => {
          const $caExt = ($maybeCaExt)[1];
          const $varName = (text_fromNumber)($env.nextGeneratedVariableName);
          const $var = (c0Compiler$CanonicalAst$Variable)(c0Compiler$Pos$G, (c0Compiler$Ast$RefLocal)($varName));
          const $newEnv = ((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              maybeShorthandTarget: (c0Maybe$Just)($var),
              nextGeneratedVariableName: ($0.nextGeneratedVariableName + 1),
            }));
          }))();
          return ((c0Result$onOk)((($caAttrs) => {
            const $def = ({
              body: $caExt,
              pattern: (c0Compiler$CanonicalAst$PatternAny)(c0Compiler$Pos$G, (c0Maybe$Just)($varName), c0Maybe$Nothing),
              uni: c0Compiler$Ast$Imm,
            });
            return (c0Result$Ok)(((($0) => {
              return (c0Compiler$CanonicalAst$LetIn)($def, $0);
            }))(((($0) => {
              return (c0Compiler$CanonicalAst$Record)($pos, (c0Maybe$Just)($var), $0);
            }))($caAttrs)));
          })))(((($0) => {
            return (c0List$forRes)($0, $attrs, (($0, $1) => {
              return (u0Compiler$MakeCanonical$translateAndInsertRecordAttribute)($newEnv, $0, $1);
            }));
          }))(c0Dict$empty));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 967:4', (sp_toHuman)($maybeCaExt))));
  })))($zzz);
});

const u0Compiler$MakeCanonical$translateRecordShorthand = (($env, $pos, $attrPath, $name) => {
  const $5 = $env.maybeShorthandTarget;
  return ((($5)[0] === "$Nothing")
    ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Record update shorthands must be used inside a record update such as", (c0Core$Cons)(("    { aRecord with anAttribute = doSomethingWith ." + ((c0Text$join)(".", $attrPath) + " }")), (c0Core$Cons)("but we are not inside a record update!", c0Core$Nil))))
    : ((($5)[0] === "$Just")
      ? ((() => {
        const $shorthandTarget = ($5)[1];
        return (c0Result$Ok)(((($0) => {
          return (c0List$for)($0, (sp_cons)($name, $attrPath), (($attrName, $expr) => {
            return (c0Compiler$CanonicalAst$RecordAccess)($pos, $attrName, $expr);
          }));
        }))($shorthandTarget));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 894:8', (sp_toHuman)($5))));
});

const u0Compiler$MakeCanonical$translateLocalDefinition = (($env, $fa) => {
  const $nonFn = (c0Dict$fromList)(((($0) => {
    return (c0List$map)((($4) => {
      const $pos = $4.first;
      const $name = $4.second;
      return ({
        first: $name,
        second: $pos,
      });
    }), $0);
  }))($fa.nonFn));
  return ((c0Result$onOk)((($3) => {
    const $uni = $3.first;
    const $pattern = $3.second;
    return ((c0Result$onOk)((($localEnv) => {
      return ((c0Result$onOk)((($body) => {
        return (c0Result$Ok)(({
          first: $localEnv,
          second: ({
            body: $body,
            pattern: $pattern,
            uni: $uni,
          }),
        }));
      })))(((($0) => {
        return (u0Compiler$MakeCanonical$translateExpression)($localEnv, $0);
      }))($fa.body));
    })))(((($0) => {
      return (u0Compiler$MakeCanonical$insertPatternNames)(false, $pattern, $0);
    }))($env));
  })))(((($0) => {
    return (u0Compiler$MakeCanonical$translateFullPattern)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        nonFn: $nonFn,
      }));
    }))(), $0);
  }))($fa.pattern));
});

const u0Compiler$MakeCanonical$translateStatements = (($env, $stats) => {
  return ((($stats)[0] === "$Nil")
    ? (c0Result$Ok)(((($0) => {
      return (c0Compiler$CanonicalAst$Constructor)(c0Compiler$Pos$G, $0);
    }))(u0Compiler$CoreDefs$noneConsUsr))
    : (((($stats)[0] === "$Cons") && (((($stats)[1])[0] === "$Evaluation") && ((($stats)[2])[0] === "$Nil")))
      ? ((() => {
        const $faExpression = (($stats)[1])[1];
        return (u0Compiler$MakeCanonical$translateExpression)($env, $faExpression);
      }))()
      : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$CommentStatement"))
        ? ((() => {
          const $tail = ($stats)[2];
          return (u0Compiler$MakeCanonical$translateStatements)($env, $tail);
        }))()
        : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$Evaluation"))
          ? ((() => {
            const $faExpr = (($stats)[1])[1];
            const $tail = ($stats)[2];
            return ((c0Result$onOk)((($caExpr) => {
              const $caDef = ({
                body: $caExpr,
                pattern: (c0Compiler$CanonicalAst$PatternAny)(c0Compiler$Pos$G, c0Maybe$Nothing, c0Maybe$Nothing),
                uni: c0Compiler$Ast$Imm,
              });
              return ((c0Result$onOk)((($acc) => {
                return (c0Result$Ok)((c0Compiler$CanonicalAst$LetIn)($caDef, $acc));
              })))(((($0) => {
                return (u0Compiler$MakeCanonical$translateStatements)($env, $0);
              }))($tail));
            })))(((($0) => {
              return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
            }))($faExpr));
          }))()
          : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$ValueDef"))
            ? ((() => {
              const $fa = (($stats)[1])[1];
              const $tail = ($stats)[2];
              return ((c0Result$onOk)((($3) => {
                const $newEnv = $3.first;
                const $caDef = $3.second;
                return ((c0Result$onOk)((($acc) => {
                  return (c0Result$Ok)((c0Compiler$CanonicalAst$LetIn)($caDef, $acc));
                })))(((($0) => {
                  return (u0Compiler$MakeCanonical$translateStatements)($newEnv, $0);
                }))($tail));
              })))(((($0) => {
                return (u0Compiler$MakeCanonical$translateLocalDefinition)($env, $0);
              }))($fa));
            }))()
            : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$AliasDef"))
              ? ((() => {
                const $fa = (($stats)[1])[1];
                const $tail = ($stats)[2];
                return (u0Compiler$MakeCanonical$error)($env, $fa.name.first, (c0Core$Cons)("Aliases can be declared only in the root scope", c0Core$Nil));
              }))()
              : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$UnionDef"))
                ? ((() => {
                  const $fa = (($stats)[1])[1];
                  const $tail = ($stats)[2];
                  return (u0Compiler$MakeCanonical$error)($env, $fa.name.first, (c0Core$Cons)("Types can be declared only in the root scope", c0Core$Nil));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 567:4', (sp_toHuman)($stats)))))))));
});

const u0Compiler$MakeCanonical$translateExpression = (($env, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$LiteralNumber")
    ? ((() => {
      const $isPercent = ($expr_)[1];
      const $str = ($expr_)[2];
      return (u0Compiler$MakeCanonical$translateNumber)($env.ro, $isPercent, c0Compiler$CanonicalAst$LiteralNumber, $pos, $str);
    }))()
    : ((($expr_)[0] === "$LiteralText")
      ? ((() => {
        const $singleOrTriple = ($expr_)[1];
        const $l = ($expr_)[2];
        return (c0Result$Ok)(((($0) => {
          return (c0Compiler$CanonicalAst$LiteralText)($pos, $0);
        }))(((($0) => {
          return (u0Compiler$MakeCanonical$escapeLiteralText)($singleOrTriple, $0);
        }))($l)));
      }))()
      : ((($expr_)[0] === "$Statements")
        ? ((() => {
          const $stats = ($expr_)[1];
          return (u0Compiler$MakeCanonical$translateStatements)($env, $stats);
        }))()
        : ((($expr_)[0] === "$Lowercase")
          ? ((() => {
            const $pas = ($expr_)[1];
            return (u0Compiler$MakeCanonical$translateLowercase)($env, $pos, $pas);
          }))()
          : ((($expr_)[0] === "$Uppercase")
            ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Can't reference a type or module here...?", c0Core$Nil))
            : ((($expr_)[0] === "$Constructor")
              ? ((() => {
                const $maybeModule = ($expr_)[1].maybeModule;
                const $name = ($expr_)[1].name;
                return ((c0Result$onOk)((($usr) => {
                  return (c0Result$Ok)((c0Compiler$CanonicalAst$Constructor)($pos, $usr));
                })))((u0Compiler$MakeCanonical$resolveToUsr)($env.ro, $pos, $maybeModule, $name));
              }))()
              : ((($expr_)[0] === "$Fn")
                ? ((() => {
                  const $faParams = ($expr_)[2];
                  const $faBody = ($expr_)[3];
                  return ((c0Result$onOk)((($caParams) => {
                    return ((c0Result$onOk)((($localEnv) => {
                      return ((c0Result$onOk)((($caBody) => {
                        return (c0Result$Ok)((c0Compiler$CanonicalAst$Fn)($pos, $caParams, $caBody));
                      })))(((($0) => {
                        return (u0Compiler$MakeCanonical$translateExpression)($localEnv, $0);
                      }))($faBody));
                    })))(((($0) => {
                      return (c0List$forRes)($0, $caParams, (($par, $envX) => {
                        return ((($par)[0] === "$ParameterPattern")
                          ? ((() => {
                            const $uni = ($par)[1];
                            const $pa = ($par)[2];
                            return (u0Compiler$MakeCanonical$insertPatternNames)(false, $pa, $envX);
                          }))()
                          : ((($par)[0] === "$ParameterRecycle")
                            ? ((() => {
                              const $p = ($par)[1];
                              const $name = ($par)[2];
                              return ((($0) => {
                                return (u0Compiler$MakeCanonical$insertPatternNames)(false, $0, $envX);
                              }))((c0Compiler$CanonicalAst$PatternAny)($p, (c0Maybe$Just)($name), c0Maybe$Nothing));
                            }))()
                            : ((($par)[0] === "$ParameterPlaceholder")
                              ? ((() => {
                                const $n = ($par)[1];
                                return (c0Result$Ok)(((() => {
                                  const $0 = $envX;
                                  return (Object.assign)({}, $0, ({
                                    values: (c0Dict$insert)((text_fromNumber)($n), ({
                                      isRoot: false,
                                      pos: $pos,
                                    }), $0.values),
                                  }));
                                }))());
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 648:16', (sp_toHuman)($par)))));
                      }));
                    }))($env));
                  })))(((($0) => {
                    return (c0List$mapRes)((($0) => {
                      return (u0Compiler$MakeCanonical$translateParameter)($env, $0);
                    }), $0);
                  }))($faParams));
                }))()
                : ((($expr_)[0] === "$ResolvedArgumentPlaceholder")
                  ? ((() => {
                    const $n = ($expr_)[1];
                    return (c0Result$Ok)((c0Compiler$CanonicalAst$Variable)($pos, (c0Compiler$Ast$RefPlaceholder)($n)));
                  }))()
                  : ((($expr_)[0] === "$Call")
                    ? ((() => {
                      const $faRef = ($expr_)[1];
                      const $faArgs = ($expr_)[2];
                      const $3 = (c0List$for)(({
                        first: 0,
                        second: c0Core$Nil,
                      }), $faArgs, (($exp, $4) => {
                        const $cnt = $4.first;
                        const $rev = $4.second;
                        return ((u0Compiler$MakeCanonical$isPlaceholder)($exp)
                          ? ((() => {
                            const $6 = $exp;
                            const $p = ($6)[2];
                            const $c = ($6)[1];
                            return ({
                              first: ($cnt + 1),
                              second: (c0Core$Cons)((c0Compiler$FormattableAst$Expression)($c, $p, (c0Compiler$FormattableAst$ResolvedArgumentPlaceholder)($cnt)), $rev),
                            });
                          }))()
                          : ({
                            first: $cnt,
                            second: (c0Core$Cons)($exp, $rev),
                          }));
                      }));
                      const $reversedArgs = $3.second;
                      const $placeholdersCount = $3.first;
                      return (($placeholdersCount > 0)
                        ? ((($0) => {
                          return (u0Compiler$MakeCanonical$makePartiallyAppliedFunction)($env, $pos, $placeholdersCount, $0);
                        }))((c0Compiler$FormattableAst$Call)($faRef, (c0List$reverse)($reversedArgs)))
                        : ((c0Result$onOk)((($caRef) => {
                          return ((c0Result$onOk)((($caArgs) => {
                            return (c0Result$Ok)((c0Compiler$CanonicalAst$Call)($pos, $caRef, $caArgs));
                          })))(((($0) => {
                            return (c0List$mapRes)((($0) => {
                              return (u0Compiler$MakeCanonical$translateArgument)($env, $0);
                            }), $0);
                          }))($faArgs));
                        })))(((($0) => {
                          return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
                        }))($faRef)));
                    }))()
                    : ((($expr_)[0] === "$If")
                      ? ((() => {
                        const $condition = ($expr_)[1].condition;
                        const $false = ($expr_)[1].false;
                        const $true = ($expr_)[1].true;
                        return ((c0Result$onOk)((($c) => {
                          return ((c0Result$onOk)((($t) => {
                            return ((c0Result$onOk)((($f) => {
                              return (c0Result$Ok)(((($0) => {
                                return (c0Compiler$CanonicalAst$If)($pos, $0);
                              }))(({
                                condition: $c,
                                false: $f,
                                true: $t,
                              })));
                            })))((u0Compiler$MakeCanonical$translateExpression)($env, $false));
                          })))((u0Compiler$MakeCanonical$translateExpression)($env, $true));
                        })))((u0Compiler$MakeCanonical$translateExpression)($env, $condition));
                      }))()
                      : ((($expr_)[0] === "$UnopCall")
                        ? ((() => {
                          const $opId = ($expr_)[1];
                          const $faOperand = ($expr_)[2];
                          return ((($opId)[0] === "$UnopUnique")
                            ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("can't use ! here because REASONS", c0Core$Nil))
                            : ((($opId)[0] === "$UnopRecycle")
                              ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("can recycle only in function calls!", c0Core$Nil))
                              : ((($opId)[0] === "$UnopPlus")
                                ? (u0Compiler$MakeCanonical$translateExpression)($env, $faOperand)
                                : ((($opId)[0] === "$UnopMinus")
                                  ? ((c0Result$onOk)((($caOperand) => {
                                    return (c0Result$Ok)((c0Compiler$CanonicalAst$Call)($pos, (c0Compiler$CanonicalAst$Variable)($pos, (c0Compiler$Ast$RefGlobal)(u0Compiler$CoreDefs$unaryMinus.usr)), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)($caOperand), c0Core$Nil)));
                                  })))(((($0) => {
                                    return (u0Compiler$MakeCanonical$translateExpression)($env, $0);
                                  }))($faOperand))
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 716:12', (sp_toHuman)($opId))))));
                        }))()
                        : ((($expr_)[0] === "$BinopChain")
                          ? ((() => {
                            const $group = ($expr_)[1];
                            const $chain = ($expr_)[2];
                            return (u0Compiler$MakeCanonical$translateBinopChain)($env, $pos, $group, $chain);
                          }))()
                          : ((($expr_)[0] === "$Record")
                            ? ((() => {
                              const $attrs = ($expr_)[1].attrs;
                              const $maybeExtension = ($expr_)[1].maybeExtension;
                              return (u0Compiler$MakeCanonical$translateRecord)($env, $pos, $maybeExtension, $attrs);
                            }))()
                            : ((($expr_)[0] === "$RecordShorthand")
                              ? ((() => {
                                const $attrPath = ($expr_)[1].attrPath;
                                const $name = ($expr_)[1].name;
                                return (u0Compiler$MakeCanonical$translateRecordShorthand)($env, $pos, $attrPath, $name);
                              }))()
                              : ((($expr_)[0] === "$List")
                                ? ((() => {
                                  const $faDotsAndItems = ($expr_)[2];
                                  const $rev = (c0List$reverse)($faDotsAndItems);
                                  return ((($rev)[0] === "$Nil")
                                    ? (c0Result$Ok)((c0Compiler$CanonicalAst$Constructor)($pos, u0Compiler$CoreDefs$nilUsr))
                                    : ((($rev)[0] === "$Cons")
                                      ? ((() => {
                                        const $hasDots = ($rev)[1].first;
                                        const $head = ($rev)[1].second;
                                        const $rest = ($rev)[2];
                                        return ((c0List$any)(c0Tuple$first, $rest)
                                          ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("can use dots only on the last element (for now?)", c0Core$Nil))
                                          : ((() => {
                                            const $3 = ($hasDots
                                              ? ({
                                                first: $head,
                                                second: $rest,
                                              })
                                              : ({
                                                first: (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $pos, (c0Compiler$FormattableAst$List)(false, c0Core$Nil)),
                                                second: $rev,
                                              }));
                                            const $revItems = $3.second;
                                            const $init = $3.first;
                                            return ((c0Result$onOk)((($caInit) => {
                                              return ((($0) => {
                                                return (c0List$forRes)($0, $revItems, (($7, $acc) => {
                                                  const $faItem = $7.second;
                                                  return ((c0Result$onOk)((($caItem) => {
                                                    return (c0Result$Ok)((c0Compiler$CanonicalAst$Call)($pos, (c0Compiler$CanonicalAst$Constructor)($pos, u0Compiler$CoreDefs$consUsr), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)($caItem), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)($acc), c0Core$Nil))));
                                                  })))((u0Compiler$MakeCanonical$translateExpression)($env, $faItem));
                                                }));
                                              }))($caInit);
                                            })))((u0Compiler$MakeCanonical$translateExpression)($env, $init));
                                          }))());
                                      }))()
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 746:12', (sp_toHuman)($rev))));
                                }))()
                                : ((($expr_)[0] === "$Try")
                                  ? ((() => {
                                    const $patterns = ($expr_)[1].patterns;
                                    const $value = ($expr_)[1].value;
                                    return ((u0Compiler$MakeCanonical$isPlaceholder)($value)
                                      ? ((($0) => {
                                        return (u0Compiler$MakeCanonical$makePartiallyAppliedFunction)($env, $pos, 1, $0);
                                      }))((c0Compiler$FormattableAst$Try)(({
                                        patterns: $patterns,
                                        value: (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $pos, (c0Compiler$FormattableAst$ResolvedArgumentPlaceholder)(0)),
                                      })))
                                      : ((() => {
                                        const $translatePatternAndStatements = (($3) => {
                                          const $faPattern = $3.first;
                                          const $faExpression = $3.second;
                                          return ((c0Result$onOk)((($4) => {
                                            const $uni = $4.first;
                                            const $caPattern = $4.second;
                                            return ((c0Result$onOk)((($localEnv) => {
                                              return ((c0Result$onOk)((($block) => {
                                                return (c0Result$Ok)(({
                                                  first: $uni,
                                                  second: $caPattern,
                                                  third: $block,
                                                }));
                                              })))(((($0) => {
                                                return (u0Compiler$MakeCanonical$translateExpression)($localEnv, $0);
                                              }))($faExpression));
                                            })))(((($0) => {
                                              return (u0Compiler$MakeCanonical$insertPatternNames)(false, $caPattern, $0);
                                            }))($env));
                                          })))(((($0) => {
                                            return (u0Compiler$MakeCanonical$translateFullPattern)($env, $0);
                                          }))($faPattern));
                                        });
                                        return ((c0Result$onOk)((($caValue) => {
                                          return ((c0Result$onOk)((($patternsAndExpressions) => {
                                            return (c0Result$Ok)((c0Compiler$CanonicalAst$Try)($pos, ({
                                              patternsAndExpressions: $patternsAndExpressions,
                                              value: $caValue,
                                            })));
                                          })))(((($0) => {
                                            return (c0List$mapRes)($translatePatternAndStatements, $0);
                                          }))($patterns));
                                        })))((u0Compiler$MakeCanonical$translateExpression)($env, $value));
                                      }))());
                                  }))()
                                  : ((($expr_)[0] === "$Native")
                                    ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("`this_is_sp_native` can be used only for root level value defs", c0Core$Nil))
                                    : (true
                                      ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("something's wrong here...", (c0Core$Cons)((sp_toHuman)($expr_), c0Core$Nil)))
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 617:4', (sp_toHuman)($expr_))))))))))))))))))));
});

const u0Compiler$MakeCanonical$translateRootDefinition = (($env, $fa) => {
  const $nonFn = (c0Dict$fromList)(((($0) => {
    return (c0List$map)((($4) => {
      const $pos = $4.first;
      const $name = $4.second;
      return ({
        first: $name,
        second: $pos,
      });
    }), $0);
  }))($fa.nonFn));
  return ((c0Result$onOk)((($3) => {
    const $uni = $3.first;
    const $pattern = $3.second;
    return ((c0Result$onOk)(((_0) => {
      return ((c0Result$onOk)((($5) => {
        const $namePos = $5.first;
        const $name = $5.second;
        const $maybeAnnotation = $5.third;
        return ((c0Result$onOk)((($localEnv) => {
          return ((c0Result$onOk)((($7) => {
            const $maybeBody = $7.first;
            const $bodyDeps = $7.second;
            const $directDeps = (u0Compiler$MakeCanonical$patternDeps)($pattern, $bodyDeps);
            return (c0Result$Ok)(({
              first: $localEnv,
              second: ({
                directDeps: $directDeps,
                maybeAnnotation: $maybeAnnotation,
                maybeBody: $maybeBody,
                name: $name,
                namePos: $namePos,
              }),
            }));
          })))(((() => {
            const $7 = $fa.body;
            return (((($7)[0] === "$Expression") && ((($7)[3])[0] === "$Native"))
              ? (c0Result$Ok)(({
                first: c0Maybe$Nothing,
                second: c0Dict$empty,
              }))
              : (true
                ? ((c0Result$onOk)((($body) => {
                  return (c0Result$Ok)(({
                    first: (c0Maybe$Just)($body),
                    second: (u0Compiler$MakeCanonical$expressionDeps)($body, c0Dict$empty),
                  }));
                })))((u0Compiler$MakeCanonical$translateExpression)($localEnv, $fa.body))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 260:4', (sp_toHuman)($7))));
          }))());
        })))(((($0) => {
          return (u0Compiler$MakeCanonical$insertPatternNames)(true, $pattern, $0);
        }))($env));
      })))((((($pattern)[0] === "$PatternAny") && ((($pattern)[2])[0] === "$Just"))
        ? ((() => {
          const $pos = ($pattern)[1];
          const $name = (($pattern)[2])[1];
          const $maybeAnnotation = ($pattern)[3];
          return (c0Result$Ok)(({
            first: $pos,
            second: $name,
            third: $maybeAnnotation,
          }));
        }))()
        : (true
          ? (u0Compiler$MakeCanonical$error)($env, (c0Compiler$CanonicalAst$patternPos)($pattern), (c0Core$Cons)("Root-level patterns are not (yet?) supported.", c0Core$Nil))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 253:4', (sp_toHuman)($pattern)))));
    })))(((sp_not_equal)($uni, c0Compiler$Ast$Imm)
      ? (u0Compiler$MakeCanonical$error)($env, (c0Compiler$CanonicalAst$patternPos)($pattern), (c0Core$Cons)("Unique values can be declared only inside functions.", c0Core$Nil))
      : (c0Result$Ok)(null)));
  })))(((($0) => {
    return (u0Compiler$MakeCanonical$translateFullPattern)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        nonFn: $nonFn,
      }));
    }))(), $0);
  }))($fa.pattern));
});

const u0Compiler$MakeCanonical$insertRootStatement = (($faStatement, $1) => {
  const $caModule = $1.first;
  const $env = $1.second;
  return (((($faStatement)[0] === "$Evaluation") && ((($faStatement)[1])[0] === "$Expression"))
    ? ((() => {
      const $pos = (($faStatement)[1])[2];
      return (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)("Root Evaluations don't really do much =|", c0Core$Nil));
    }))()
    : ((($faStatement)[0] === "$ValueDef")
      ? ((() => {
        const $d = ($faStatement)[1];
        return ((c0Result$onOk)((($3) => {
          const $newEnv = $3.first;
          const $def = $3.second;
          return (c0Result$Ok)(({
            first: ((() => {
              const $0 = $caModule;
              return (Object.assign)({}, $0, ({
                valueDefs: (c0Dict$insert)($def.name, $def, $0.valueDefs),
              }));
            }))(),
            second: $newEnv,
          }));
        })))(((($0) => {
          return (u0Compiler$MakeCanonical$translateRootDefinition)($env, $0);
        }))($d));
      }))()
      : ((($faStatement)[0] === "$AliasDef")
        ? ((() => {
          const $fa = ($faStatement)[1];
          const $3 = $fa.name;
          const $name = $3.second;
          const $pos = $3.first;
          return (((c0Dict$member)($name, $caModule.aliasDefs) || (c0Dict$member)($name, $caModule.variantTypeDefs))
            ? (u0Compiler$MakeCanonical$error)($env, $fa.name.first, (c0Core$Cons)(($name + " declared twice!"), c0Core$Nil))
            : ((c0Result$onOk)((($type) => {
              const $aliasDef = ({
                directDeps: (u0Compiler$MakeCanonical$typeDeps)($type, c0Dict$empty),
                pars: (c0List$map)((($5) => {
                  const $p = $5.first;
                  const $n = $5.second;
                  return ({
                    first: $n,
                    second: $p,
                  });
                }), $fa.args),
                type: $type,
                usr: (c0Compiler$Meta$USR)($env.ro.umr, $name),
              });
              return (c0Result$Ok)(({
                first: ((() => {
                  const $0 = $caModule;
                  return (Object.assign)({}, $0, ({
                    aliasDefs: (c0Dict$insert)($name, $aliasDef, $0.aliasDefs),
                  }));
                }))(),
                second: $env,
              }));
            })))(((($0) => {
              return (u0Compiler$MakeCanonical$translateRawType)($env.ro, $0);
            }))($fa.type)));
        }))()
        : ((($faStatement)[0] === "$UnionDef")
          ? ((() => {
            const $fa = ($faStatement)[1];
            const $3 = $fa.name;
            const $name = $3.second;
            const $pos = $3.first;
            return (((c0Dict$member)($name, $caModule.aliasDefs) || (c0Dict$member)($name, $caModule.variantTypeDefs))
              ? (u0Compiler$MakeCanonical$error)($env, $pos, (c0Core$Cons)(($name + " declared twice!"), c0Core$Nil))
              : ((() => {
                const $caPars = (c0List$map)((($4) => {
                  const $p = $4.first;
                  const $n = $4.second;
                  return ({
                    first: $n,
                    second: $p,
                  });
                }), $fa.args);
                const $usr = (c0Compiler$Meta$USR)($env.ro.umr, $name);
                const $type = ((($0) => {
                  return (c0Compiler$CanonicalAst$TypeNamed)($pos, $usr, $0);
                }))(((($0) => {
                  return (c0List$map)((($5) => {
                    const $n = $5.first;
                    const $p = $5.second;
                    return (c0Compiler$CanonicalAst$TypeAnnotationVariable)($p, $n);
                  }), $0);
                }))($caPars));
                return ((c0Result$onOk)((($4) => {
                  const $constructors = $4.first;
                  const $newEnv = $4.second;
                  const $varDef = ({
                    constructors: $constructors,
                    pars: $caPars,
                    usr: $usr,
                  });
                  const $newModule = ((() => {
                    const $0 = $caModule;
                    return (Object.assign)({}, $0, ({
                      constructorDefs: (c0Dict$for)($0.constructorDefs, $constructors, c0Dict$insert),
                      variantTypeDefs: (c0Dict$insert)($name, $varDef, $0.variantTypeDefs),
                    }));
                  }))();
                  return (c0Result$Ok)(({
                    first: $newModule,
                    second: $newEnv,
                  }));
                })))(((($0) => {
                  return (c0List$forRes)($0, $fa.constructors, (($0, $1) => {
                    return (u0Compiler$MakeCanonical$translateConstructor)($type, $usr, (c0Dict$fromList)($caPars), $0, $1);
                  }));
                }))(({
                  first: c0Dict$empty,
                  second: $env,
                })));
              }))());
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1487:4', (sp_toHuman)($faStatement))))));
});

const u0Compiler$MakeCanonical$translateModule = (($ro, $faModule) => {
  (sp_benchStart)(null);
  const $module = (c0Compiler$CanonicalAst$initModule)($ro.errorModule.fsPath, $ro.umr, $ro.errorModule.content);
  return ((($0) => {
    return (c0Basics$btw)(sp_benchStop, "translateModule", $0);
  }))(((($0) => {
    return (c0Result$map)(c0Tuple$first, $0);
  }))(((($0) => {
    return (c0List$forRes)($0, $faModule, (($0, $1) => {
      return (u0Compiler$MakeCanonical$insertRootStatement)($0, $1);
    }));
  }))(({
    first: $module,
    second: (u0Compiler$MakeCanonical$initEnv)($ro),
  }))));
});

const u0Compiler$Lexer$getPos = (($state) => {
  return ([
    ((__re__ = (basics_cloneUni)($state.nextPos)), ($state.nextPos = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$Lexer$closeOpenBlocks = (($state) => {
  const $pos = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $s = ((__re__ = (array_toList)($state.indentStack)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
  (c0List$each)($s, ((_0) => {
    return ((__re__ = (array_push)($state.tokens, (c0Compiler$Token$Token)($pos, $pos, c0Compiler$Token$BlockEnd))), ($state.tokens = (__re__)[1]), (__re__)[0]);
  }));
  return ([
    ((__re__ = (array_push)($state.sections, ((__re__ = (array_toList)($state.tokens)), ($state.tokens = (__re__)[1]), (__re__)[0]))), ($state.sections = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$Lexer$addCommentTokenAbs = (($start, $end, $kind, $state) => {
  (((__re__ = (basics_cloneUni)($state.keepComments)), ($state.keepComments = (__re__)[1]), (__re__)[0])
    ? ((__re__ = (array_push)($state.tokens, (c0Compiler$Token$Token)($start, $end, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0])
    : null);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const u0Compiler$Lexer$addIndentToken = (($pos, $kind, $state) => {
  return ([
    ((__re__ = (array_push)($state.tokens, (c0Compiler$Token$Token)($pos, $pos, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$Lexer$updateIndent = (($start, $end, $kind, $state) => {
  const $manageIndent = (($head) => {
    const $lineIndent = ((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]);
    return (($lineIndent > $head.indent)
      ? ((() => {
        const $newIndent = ({
          indent: $lineIndent,
          isBlock: ((__re__ = (basics_cloneUni)($state.indentStartsABlock)), ($state.indentStartsABlock = (__re__)[1]), (__re__)[0]),
        });
        ((__re__ = (array_push)($state.indentStack, $newIndent)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
        return (((__re__ = (basics_cloneUni)($state.indentStartsABlock)), ($state.indentStartsABlock = (__re__)[1]), (__re__)[0])
          ? ((__re__ = (u0Compiler$Lexer$addIndentToken)($start, c0Compiler$Token$BlockStart, $state)), ($state = (__re__)[1]), (__re__)[0])
          : null);
      }))()
      : ($head.isBlock
        ? ((() => {
          const $list = ((__re__ = (array_toList)($state.tokens)), ($state.tokens = (__re__)[1]), (__re__)[0]);
          (((sp_not_equal)(((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]), 0) || (sp_equal)($list, c0Core$Nil))
            ? null
            : ((() => {
              ((__re__ = (array_push)($state.sections, $list)), ($state.sections = (__re__)[1]), (__re__)[0]);
              return ($state.tokens = (array_fromList)(c0Core$Nil));
            }))());
          return ((__re__ = (u0Compiler$Lexer$addIndentToken)($start, c0Compiler$Token$NewSiblingLine, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : null));
  });
  const $5 = ((__re__ = (array_pop)($state.indentStack)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
  return ([
    ((($5)[0] === "$Nothing")
      ? ($manageIndent)(({
        indent: 0,
        isBlock: true,
      }))
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $head = ($5)[1];
          return ((((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]) < $head.indent)
            ? ((() => {
              ($head.isBlock
                ? ((__re__ = (u0Compiler$Lexer$addIndentToken)($start, c0Compiler$Token$BlockEnd, $state)), ($state = (__re__)[1]), (__re__)[0])
                : null);
              return ((__re__ = (u0Compiler$Lexer$updateIndent)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((() => {
              ((__re__ = (array_push)($state.indentStack, $head)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
              return ($manageIndent)($head);
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 155:4', (sp_toHuman)($5)))),
    $state,
  ]);
});

const u0Compiler$Lexer$addContentTokenAbs = (($start, $end, $kind, $state) => {
  (((__re__ = (basics_cloneUni)($state.soFarThereAreNoTokensInThisLine)), ($state.soFarThereAreNoTokensInThisLine = (__re__)[1]), (__re__)[0])
    ? ((() => {
      ($state.soFarThereAreNoTokensInThisLine = false);
      return ((__re__ = (u0Compiler$Lexer$updateIndent)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
    }))()
    : null);
  let $indentStartsABlock = ((($kind)[0] === "$Then")
    ? true
    : ((($kind)[0] === "$Else")
      ? true
      : ((($kind)[0] === "$As")
        ? true
        : ((($kind)[0] === "$Colon")
          ? true
          : ((($kind)[0] === "$Defop")
            ? true
            : (true
              ? false
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 185:8', (sp_toHuman)($kind))))))));
  ($state.indentStartsABlock = $indentStartsABlock);
  ((__re__ = (array_push)($state.tokens, (c0Compiler$Token$Token)($start, $end, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const u0Compiler$Lexer$addContentTokenRel = (($ds, $de, $kind, $state) => {
  const $pos = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)(($pos + $ds), ($pos + $de), $kind, $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$Lexer$addError = (($message, $state) => {
  const $end = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $error = (($0) => {
    return (u0Compiler$Error$Simple)($0, (c0Compiler$Pos$P)($start, $end), (c0Core$Cons)($message, c0Core$Nil));
  });
  ((__re__ = (array_push)($state.errors, $error)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const u0Compiler$Lexer$getChunk = (($buffer, $state) => {
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $end = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ({
      first: $start,
      second: $end,
      third: (text_slice)($start, $end, $buffer),
    }),
    $state,
  ]);
});

const u0Compiler$Lexer$addNumberToken = (($isPercent, $buffer, $state) => {
  const $4 = ((__re__ = (u0Compiler$Lexer$getChunk)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = $4.third;
  const $end = $4.second;
  const $start = $4.first;
  return ([
    ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)($start, $end, (c0Compiler$Token$NumberLiteral)($isPercent, $chunk), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const u0Compiler$Lexer$addParenOrCommaToken = (($char, $state) => {
  const $add = (($0) => {
    return ((__re__ = (u0Compiler$Lexer$addContentTokenRel)(0, 1, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  });
  const $line = ((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]);
  return ([
    (("(" === $char)
      ? ($add)((c0Compiler$Token$RoundParen)(c0Compiler$Token$Open))
      : ((")" === $char)
        ? ($add)((c0Compiler$Token$RoundParen)(c0Compiler$Token$Closed))
        : (("[" === $char)
          ? ($add)((c0Compiler$Token$SquareBracket)($line, c0Compiler$Token$Open))
          : (("]" === $char)
            ? ($add)((c0Compiler$Token$SquareBracket)($line, c0Compiler$Token$Closed))
            : (("{" === $char)
              ? ($add)((c0Compiler$Token$CurlyBrace)($line, c0Compiler$Token$Open))
              : (("}" === $char)
                ? ($add)((c0Compiler$Token$CurlyBrace)($line, c0Compiler$Token$Closed))
                : (("," === $char)
                  ? ($add)(c0Compiler$Token$Comma)
                  : (true
                    ? ((__re__ = (u0Compiler$Lexer$addError)(("I can't make sense of this piece of text: `" + ($char + "`")), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 561:4', (sp_toHuman)($char)))))))))),
    $state,
  ]);
});

const u0Compiler$CoreDefs$binopsBySymbol = (c0List$for)(c0Dict$empty, u0Compiler$CoreDefs$binops, (($bop, $d) => {
  return (c0Dict$insert)($bop.symbol, $bop, $d);
}));

const u0Compiler$Lexer$addSquiggleToken = (($buffer, $nextIsSpace, $state) => {
  const $4 = ((__re__ = (u0Compiler$Lexer$getChunk)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = $4.third;
  const $end = $4.second;
  const $start = $4.first;
  const $add = (($0) => {
    return ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)($start, $end, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((":" === $chunk)
      ? ($add)(c0Compiler$Token$Colon)
      : (("=" === $chunk)
        ? ($add)(c0Compiler$Token$Defop)
        : (("?" === $chunk)
          ? ($add)(c0Compiler$Token$UniquenessPolymorphismBinop)
          : (("!" === $chunk)
            ? ($add)((c0Compiler$Token$Unop)(c0Compiler$Op$UnopUnique))
            : (("@" === $chunk)
              ? ($add)((c0Compiler$Token$Unop)(c0Compiler$Op$UnopRecycle))
              : (("-" === $chunk)
                ? ($add)(($nextIsSpace
                  ? (c0Compiler$Token$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), u0Compiler$CoreDefs$subtract)
                  : (c0Compiler$Token$Unop)(c0Compiler$Op$UnopMinus)))
                : (("+" === $chunk)
                  ? ($add)(($nextIsSpace
                    ? (c0Compiler$Token$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), u0Compiler$CoreDefs$add)
                    : (c0Compiler$Token$Unop)(c0Compiler$Op$UnopPlus)))
                  : (true
                    ? ((() => {
                      const $op = $chunk;
                      const $5 = (c0Dict$get)($chunk, u0Compiler$CoreDefs$binopsBySymbol);
                      return ((($5)[0] === "$Just")
                        ? ((() => {
                          const $binop = ($5)[1];
                          return ($add)((c0Compiler$Token$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), $binop));
                        }))()
                        : ((($5)[0] === "$Nothing")
                          ? ((__re__ = (u0Compiler$Lexer$addError)(("Invalid operator: `" + ($chunk + "`")), $state)), ($state = (__re__)[1]), (__re__)[0])
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 545:12', (sp_toHuman)($5))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 521:4', (sp_toHuman)($chunk)))))))))),
    $state,
  ]);
});

const u0Compiler$Lexer$addErrorIf = (($isError, $state, $message) => {
  return ([
    ($isError
      ? ((__re__ = (u0Compiler$Lexer$addError)($message, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const u0Compiler$Lexer$parseAttr = (($state, $text) => {
  ((__re__ = (u0Compiler$Lexer$addErrorIf)((u0Compiler$Lexer$startsWithUpperChar)($text), $state, "record attributes must start with a lowercase letter")), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    $text,
    $state,
  ]);
});

const u0Compiler$Lexer$parseAttrs = (($state, $ts) => {
  return ([
    (c0List$map)((($0) => {
      return ((__re__ = (u0Compiler$Lexer$parseAttr)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
    }), $ts),
    $state,
  ]);
});

const u0Compiler$Lexer$parseModule = (($state, $text) => {
  return ([
    $text,
    $state,
  ]);
});

const u0Compiler$Lexer$parseNameToWord = (($state, $1) => {
  const $attrPath = $1.attrPath;
  const $main = $1.main;
  const $maybeModule = $1.maybeModule;
  const $3 = (text_split)("'", $main);
  return ([
    (((($3)[0] === "$Cons") && (("" === ($3)[1]) && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $raw = (($3)[2])[1];
        ((__re__ = (u0Compiler$Lexer$addErrorIf)((sp_not_equal)($attrPath, c0Core$Nil), $state, "Constructors don't have any attribute to access")), ($state = (__re__)[1]), (__re__)[0]);
        return (c0Compiler$Token$Constructor)(({
          maybeModule: $maybeModule,
          name: $main,
        }));
      }))()
      : (((($3)[0] === "$Cons") && ((($3)[2])[0] === "$Nil"))
        ? ((() => {
          const $name = ($3)[1];
          return ((u0Compiler$Lexer$startsWithUpperChar)($name)
            ? ((() => {
              ((__re__ = (u0Compiler$Lexer$addErrorIf)((sp_not_equal)($attrPath, c0Core$Nil), $state, "WAT... Type names don't have attributes to access. =|")), ($state = (__re__)[1]), (__re__)[0]);
              return (c0Compiler$Token$Uppercase)(({
                maybeModule: $maybeModule,
                name: $name,
              }));
            }))()
            : (c0Compiler$Token$Lowercase)(({
              attrPath: $attrPath,
              maybeModule: $maybeModule,
              name: $name,
            })));
        }))()
        : (true
          ? ((() => {
            ((__re__ = (u0Compiler$Lexer$addError)("apostrophes can be used only at the beginning of a constructor name", $state)), ($state = (__re__)[1]), (__re__)[0]);
            return (c0Compiler$Token$Constructor)(({
              maybeModule: c0Maybe$Nothing,
              name: $main,
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 323:4', (sp_toHuman)($3))))),
    $state,
  ]);
});

const u0Compiler$Lexer$addWord = (($start, $end, $chunk0, $state) => {
  const $5 = ((() => {
    const $6 = (text_split)("...", $chunk0);
    return (((($6)[0] === "$Cons") && (((($6)[2])[0] === "$Cons") && (("" === (($6)[2])[1]) && (((($6)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $c = ($6)[1];
        return ({
          first: $c,
          second: true,
        });
      }))()
      : (((($6)[0] === "$Cons") && ((($6)[2])[0] === "$Nil"))
        ? ((() => {
          const $c = ($6)[1];
          return ({
            first: $c,
            second: false,
          });
        }))()
        : (true
          ? ({
            first: $chunk0,
            second: false,
          })
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 366:8', (sp_toHuman)($6)))));
  }))();
  const $trailingThreeDots = $5.second;
  const $chunk1 = $5.first;
  const $snips = (text_split)(".", $chunk1);
  ((($0) => {
    return ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)($start, $end, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }))(((($snips)[0] === "$Nil")
    ? (c0Compiler$Token$Lowercase)(({
      attrPath: c0Core$Nil,
      maybeModule: c0Maybe$Nothing,
      name: "THIS IS NOT SUPPOSED TO HAPPEN",
    }))
    : (((($snips)[0] === "$Cons") && ((($snips)[2])[0] === "$Nil"))
      ? ((() => {
        const $main = ($snips)[1];
        return ((__re__ = (u0Compiler$Lexer$parseNameToWord)($state, ({
          attrPath: c0Core$Nil,
          main: $main,
          maybeModule: c0Maybe$Nothing,
        }))), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : (((($snips)[0] === "$Cons") && (("" === ($snips)[1]) && ((($snips)[2])[0] === "$Cons")))
        ? ((() => {
          const $two = (($snips)[2])[1];
          const $rest = (($snips)[2])[2];
          ((__re__ = (u0Compiler$Lexer$addErrorIf)((c0List$any)((($0) => {
            return (sp_equal)($0, "");
          }), (sp_cons)($two, $rest)), $state, "use spaces around `..` to concatenate Text")), ($state = (__re__)[1]), (__re__)[0]);
          return (c0Compiler$Token$RecordShorthand)(({
            attrPath: ((__re__ = (u0Compiler$Lexer$parseAttrs)($state, $rest)), ($state = (__re__)[1]), (__re__)[0]),
            name: ((__re__ = (u0Compiler$Lexer$parseAttr)($state, $two)), ($state = (__re__)[1]), (__re__)[0]),
          }));
        }))()
        : (((($snips)[0] === "$Cons") && ((($snips)[2])[0] === "$Cons"))
          ? ((() => {
            const $one = ($snips)[1];
            const $two = (($snips)[2])[1];
            const $rest = (($snips)[2])[2];
            ((__re__ = (u0Compiler$Lexer$addErrorIf)((c0List$any)((($0) => {
              return (sp_equal)($0, "");
            }), $snips), $state, "use spaces around `..` to concatenate Text")), ($state = (__re__)[1]), (__re__)[0]);
            return ((u0Compiler$Lexer$startsWithUpperChar)($one)
              ? ((() => {
                const $module = ((__re__ = (u0Compiler$Lexer$parseModule)($state, $one)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = (u0Compiler$Lexer$parseNameToWord)($state, ({
                  attrPath: ((__re__ = (u0Compiler$Lexer$parseAttrs)($state, $rest)), ($state = (__re__)[1]), (__re__)[0]),
                  main: $two,
                  maybeModule: (c0Maybe$Just)($module),
                }))), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((__re__ = (u0Compiler$Lexer$parseNameToWord)($state, ({
                attrPath: ((__re__ = (u0Compiler$Lexer$parseAttrs)($state, (sp_cons)($two, $rest))), ($state = (__re__)[1]), (__re__)[0]),
                main: $one,
                maybeModule: c0Maybe$Nothing,
              }))), ($state = (__re__)[1]), (__re__)[0]));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 374:4', (sp_toHuman)($snips)))))));
  return ([
    ($trailingThreeDots
      ? ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)(($end - 3), $end, c0Compiler$Token$ThreeDots, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const u0Compiler$Lexer$addWordToken = (($buffer, $state) => {
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $end = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = (text_slice)($start, $end, $buffer);
  const $maybeKeywordKind = (("fn" === $chunk)
    ? (c0Maybe$Just)(c0Compiler$Token$Fn)
    : (("if" === $chunk)
      ? (c0Maybe$Just)((c0Compiler$Token$If)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0])))
      : (("then" === $chunk)
        ? (c0Maybe$Just)(c0Compiler$Token$Then)
        : (("else" === $chunk)
          ? (c0Maybe$Just)((c0Compiler$Token$Else)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0])))
          : (("try" === $chunk)
            ? (c0Maybe$Just)(c0Compiler$Token$Try)
            : (("as" === $chunk)
              ? (c0Maybe$Just)(c0Compiler$Token$As)
              : (("with" === $chunk)
                ? (c0Maybe$Just)(c0Compiler$Token$With)
                : (("and" === $chunk)
                  ? (c0Maybe$Just)((c0Compiler$Token$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), u0Compiler$CoreDefs$and_))
                  : (("or" === $chunk)
                    ? (c0Maybe$Just)((c0Compiler$Token$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), u0Compiler$CoreDefs$or_))
                    : (("__" === $chunk)
                      ? (c0Maybe$Just)(c0Compiler$Token$ArgumentPlaceholder)
                      : (("this_is_sp_native" === $chunk)
                        ? (c0Maybe$Just)(c0Compiler$Token$Native)
                        : (true
                          ? c0Maybe$Nothing
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 445:8', (sp_toHuman)($chunk))))))))))))));
  return ([
    ((($maybeKeywordKind)[0] === "$Just")
      ? ((() => {
        const $kind = ($maybeKeywordKind)[1];
        return ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : (true
        ? ((__re__ = (u0Compiler$Lexer$addWord)($start, $end, $chunk, $state)), ($state = (__re__)[1]), (__re__)[0])
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 459:4', (sp_toHuman)($maybeKeywordKind)))),
    $state,
  ]);
});

const u0Compiler$Lexer$isNumber = ((() => {
  const $re = (text_startsWithRegex)("[0-9_.]");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const u0Compiler$Lexer$isSquiggle = (($char) => {
  return (("=" === $char)
    ? true
    : ((":" === $char)
      ? true
      : (("*" === $char)
        ? true
        : (("+" === $char)
          ? true
          : (("-" === $char)
            ? true
            : (("/" === $char)
              ? true
              : ((">" === $char)
                ? true
                : (("<" === $char)
                  ? true
                  : (("!" === $char)
                    ? true
                    : (("?" === $char)
                      ? true
                      : (("&" === $char)
                        ? true
                        : (("^" === $char)
                          ? true
                          : (("@" === $char)
                            ? true
                            : (("$" === $char)
                              ? true
                              : (true
                                ? false
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 495:4', (sp_toHuman)($char)))))))))))))))));
});

const u0Compiler$Lexer$isWordBody = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z./_0-9']");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const u0Compiler$Lexer$isWordStart = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z._']");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const u0Compiler$Lexer$setMode = (($mode, $state) => {
  return ([
    ($state.mode = (basics_cloneImm)($mode)),
    $state,
  ]);
});

const u0Compiler$Lexer$thereIsABlankAhead = (($offset, $buffer, $state) => {
  const $start = (text_fromNumber)((((__re__ = (basics_cloneUni)($state.nextPos)), ($state.nextPos = (__re__)[1]), (__re__)[0]) + $offset));
  const $regex = (".{" + ($start + "}\n[ ]*(\n|$)"));
  return ([
    (sp_not_equal)(((text_startsWithRegex)($regex))($buffer), ""),
    $state,
  ]);
});

const u0Compiler$Lexer$tryIndent = (($buffer, $indentChar, $char, $state) => {
  return ([
    (((sp_equal)($char, $indentChar) || (sp_equal)($char, ""))
      ? null
      : (((sp_equal)($char, " ") || (sp_equal)($char, "\t"))
        ? ((__re__ = (u0Compiler$Lexer$addError)("mixing tabs and spaces!", $state)), ($state = (__re__)[1]), (__re__)[0])
        : ((sp_equal)($char, "\n")
          ? ((() => {
            ($state.tokenStart = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1));
            return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Indent, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : ((sp_equal)($char, "#")
            ? ((() => {
              const $start = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
              const $column = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]);
              return ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$LineComment)(({
                column: $column,
                start: $start,
              })), $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((() => {
              ($state.lineIndent = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]));
              ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))())))),
    $state,
  ]);
});

const u0Compiler$Lexer$unindent = (($raw) => {
  return ((c0Basics$not)((text_startsWith)("\n", $raw))
    ? $raw
    : ((() => {
      const $multilineText = (text_dropLeft)(1, $raw);
      const $lines = (text_split)("\n", $multilineText);
      const $countLeadingSpaces = ((() => {
        const $re = (text_startsWithRegex)("[ ]*");
        return (($line) => {
          return (text_length)(($re)($line));
        });
      }))();
      const $minLead = ((($0) => {
        return (c0Maybe$withDefault)(0, $0);
      }))((c0List$minimum)(((($0) => {
        return (c0List$map)($countLeadingSpaces, $0);
      }))(((($0) => {
        return (c0List$filter)((($s) => {
          return (sp_not_equal)((text_trimLeft)($s), "");
        }), $0);
      }))($lines))));
      return ((($0) => {
        return ((text_replaceRegex)("\n[ ]*$"))("", $0);
      }))(((($0) => {
        return (c0Text$join)("\n", $0);
      }))(((($0) => {
        return (c0List$map)((($0) => {
          return (text_dropLeft)($minLead, $0);
        }), $0);
      }))($lines)));
    }))());
});

const u0Compiler$Lexer$lexOne = (($buffer, $char, $state) => {
  const $pos = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  let $4 = ((__re__ = (basics_cloneUni)($state.mode)), ($state.mode = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Indent")
      ? ((() => {
        let $5 = ((__re__ = (basics_cloneUni)($state.tabsOrSpaces)), ($state.tabsOrSpaces = (__re__)[1]), (__re__)[0]);
        return ((($5)[0] === "$Tabs")
          ? ((__re__ = (u0Compiler$Lexer$tryIndent)($buffer, "\t", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
          : ((($5)[0] === "$Spaces")
            ? ((__re__ = (u0Compiler$Lexer$tryIndent)($buffer, " ", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
            : ((($5)[0] === "$NoTabsOrSpacesYet")
              ? ((" " === $char)
                ? ((() => {
                  ($state.tabsOrSpaces = u0Compiler$Lexer$Spaces);
                  return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (("\t" === $char)
                  ? ((() => {
                    ($state.tabsOrSpaces = u0Compiler$Lexer$Tabs);
                    return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = (u0Compiler$Lexer$tryIndent)($buffer, " ", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 610:20', (sp_toHuman)($char)))))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 601:12', (sp_toHuman)($5)))));
      }))()
      : ((($4)[0] === "$Default")
        ? (("" === $char)
          ? null
          : (("." === $char)
            ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Dot_One, $state)), ($state = (__re__)[1]), (__re__)[0])
            : (("#" === $char)
              ? ((() => {
                const $start = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $column = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]);
                return ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$LineComment)(({
                  column: $column,
                  start: $start,
                })), $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (("[" === $char)
                ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$ContentOpeningBlockComment, $state)), ($state = (__re__)[1]), (__re__)[0])
                : (("\"" === $char)
                  ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$ContentOpeningQuotes_One, $state)), ($state = (__re__)[1]), (__re__)[0])
                  : (("\n" === $char)
                    ? ((() => {
                      ($state.tokenStart = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1));
                      ($state.soFarThereAreNoTokensInThisLine = true);
                      return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Indent, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : ((" " === $char)
                      ? ($state.tokenStart = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1))
                      : (true
                        ? ((() => {
                          ($state.tokenStart = ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]));
                          return ((u0Compiler$Lexer$isWordStart)($char)
                            ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Word, $state)), ($state = (__re__)[1]), (__re__)[0])
                            : ((u0Compiler$Lexer$isNumber)($char)
                              ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$NumberLiteral, $state)), ($state = (__re__)[1]), (__re__)[0])
                              : ((u0Compiler$Lexer$isSquiggle)($char)
                                ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Squiggles, $state)), ($state = (__re__)[1]), (__re__)[0])
                                : ((__re__ = (u0Compiler$Lexer$addParenOrCommaToken)($char, $state)), ($state = (__re__)[1]), (__re__)[0]))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 626:12', (sp_toHuman)($char))))))))))
        : ((($4)[0] === "$Dot_One")
          ? ((sp_equal)($char, ".")
            ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Dot_Two, $state)), ($state = (__re__)[1]), (__re__)[0])
            : ((u0Compiler$Lexer$isWordStart)($char)
              ? ((() => {
                ($state.tokenStart = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1));
                return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Word, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((u0Compiler$Lexer$isNumber)($char)
                ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$NumberLiteral, $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((__re__ = (u0Compiler$Lexer$addError)("no idea what this is", $state)), ($state = (__re__)[1]), (__re__)[0]))))
          : ((($4)[0] === "$Dot_Two")
            ? ((sp_equal)($char, ".")
              ? ((() => {
                ((__re__ = (u0Compiler$Lexer$addContentTokenRel)(-(1), 1, c0Compiler$Token$ThreeDots, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((() => {
                ((__re__ = (u0Compiler$Lexer$addContentTokenRel)(-(1), 1, (c0Compiler$Token$Binop)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), u0Compiler$CoreDefs$textConcat), $state)), ($state = (__re__)[1]), (__re__)[0]);
                ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))())
            : ((($4)[0] === "$Mutable")
              ? ((u0Compiler$Lexer$isSquiggle)($char)
                ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Squiggles, $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((__re__ = (u0Compiler$Lexer$addError)("no idea what this is", $state)), ($state = (__re__)[1]), (__re__)[0]))
              : ((($4)[0] === "$Word")
                ? ((u0Compiler$Lexer$isWordBody)($char)
                  ? null
                  : ((() => {
                    ((__re__ = (u0Compiler$Lexer$addWordToken)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))())
                : ((($4)[0] === "$NumberLiteral")
                  ? ((u0Compiler$Lexer$isNumber)($char)
                    ? null
                    : ((sp_equal)($char, "%")
                      ? ((() => {
                        ((__re__ = (u0Compiler$Lexer$addNumberToken)(true, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : ((() => {
                        ((__re__ = (u0Compiler$Lexer$addNumberToken)(false, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()))
                  : ((($4)[0] === "$Squiggles")
                    ? ((u0Compiler$Lexer$isSquiggle)($char)
                      ? null
                      : ((() => {
                        ((__re__ = (u0Compiler$Lexer$addSquiggleToken)($buffer, (sp_equal)($char, " "), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))())
                    : ((($4)[0] === "$ContentOpeningQuotes_One")
                      ? ((sp_equal)($char, "\"")
                        ? ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$ContentOpeningQuotes_Two, $state)), ($state = (__re__)[1]), (__re__)[0])
                        : ((sp_equal)($char, "")
                          ? ((__re__ = (u0Compiler$Lexer$addError)("there's no closing quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                          : ((() => {
                            ($state.tokenStart = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1));
                            ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$SingleQuote)(({
                              lastEscape: -(1),
                            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()))
                      : ((($4)[0] === "$ContentOpeningQuotes_Two")
                        ? ((sp_equal)($char, "\"")
                          ? ((() => {
                            ($state.tokenStart = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 2));
                            return ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$TripleQuote)(({
                              closingQuotes: 0,
                              lastEscape: -(1),
                            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : ((() => {
                            ((__re__ = (u0Compiler$Lexer$addContentTokenRel)(-(2), 0, (c0Compiler$Token$TextLiteral)(c0Compiler$Token$SingleQuote, ""), $state)), ($state = (__re__)[1]), (__re__)[0]);
                            ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))())
                        : ((($4)[0] === "$SingleQuote")
                          ? ((() => {
                            const $lastEscape = ($4)[1].lastEscape;
                            const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                            return ((sp_equal)($char, "")
                              ? ((__re__ = (u0Compiler$Lexer$addError)("there's no closing quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                              : ($previousIsEscape
                                ? ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$SingleQuote)(({
                                  lastEscape: $lastEscape,
                                })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                : (("\"" === $char)
                                  ? ((() => {
                                    const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
                                    const $end = ($pos + 1);
                                    const $value = ((($0) => {
                                      return (text_slice)(($start + 1), ($end - 1), $0);
                                    }))($buffer);
                                    ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)($start, $end, (c0Compiler$Token$TextLiteral)(c0Compiler$Token$SingleQuote, $value), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : (("\\" === $char)
                                    ? ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$SingleQuote)(({
                                      lastEscape: $pos,
                                    })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                    : (true
                                      ? null
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 775:16', (sp_toHuman)($char)))))));
                          }))()
                          : ((($4)[0] === "$TripleQuote")
                            ? ((() => {
                              const $closingQuotes = ($4)[1].closingQuotes;
                              const $lastEscape = ($4)[1].lastEscape;
                              const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                              return ((sp_equal)($char, "")
                                ? ((__re__ = (u0Compiler$Lexer$addError)("unterminated triple quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                                : ($previousIsEscape
                                  ? ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$TripleQuote)(({
                                    closingQuotes: 0,
                                    lastEscape: $lastEscape,
                                  })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                  : (("\"" === $char)
                                    ? ((sp_equal)($closingQuotes, 2)
                                      ? ((() => {
                                        const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
                                        const $end = ($pos + 1);
                                        ((($0) => {
                                          return ((__re__ = (u0Compiler$Lexer$addContentTokenAbs)($start, $end, $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                        }))(((($0) => {
                                          return (c0Compiler$Token$TextLiteral)(c0Compiler$Token$TripleQuote, $0);
                                        }))((u0Compiler$Lexer$unindent)(((($0) => {
                                          return (text_slice)(($start + 3), ($end - 3), $0);
                                        }))($buffer))));
                                        return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                      }))()
                                      : ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$TripleQuote)(({
                                        closingQuotes: ($closingQuotes + 1),
                                        lastEscape: $lastEscape,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0]))
                                    : (("\\" === $char)
                                      ? ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$TripleQuote)(({
                                        closingQuotes: 0,
                                        lastEscape: $pos,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                      : (true
                                        ? ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$TripleQuote)(({
                                          closingQuotes: 0,
                                          lastEscape: $lastEscape,
                                        })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 818:16', (sp_toHuman)($char)))))));
                            }))()
                            : ((($4)[0] === "$LineComment")
                              ? ((() => {
                                const $column = ($4)[1].column;
                                const $start = ($4)[1].start;
                                return (((sp_equal)($char, "\n") || (sp_equal)($char, ""))
                                  ? ((() => {
                                    ((($0) => {
                                      return ((__re__ = (u0Compiler$Lexer$addCommentTokenAbs)($start, ((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]), $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    }))((c0Compiler$Token$Comment)(({
                                      indent: $column,
                                      isBlock: false,
                                      isFollowedByBlank: ((__re__ = (u0Compiler$Lexer$thereIsABlankAhead)(0, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]),
                                    })));
                                    ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : null);
                              }))()
                              : ((($4)[0] === "$ContentOpeningBlockComment")
                                ? ((sp_equal)($char, "#")
                                  ? ((() => {
                                    const $start = (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1);
                                    const $column = (((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]) - 1);
                                    return ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$BlockComment)(({
                                      column: $column,
                                      nesting: 1,
                                      previous: "",
                                      start: $start,
                                    })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : ((() => {
                                    ((__re__ = (u0Compiler$Lexer$addContentTokenRel)(-(1), 0, (c0Compiler$Token$SquareBracket)(((__re__ = (basics_cloneUni)($state.line)), ($state.line = (__re__)[1]), (__re__)[0]), c0Compiler$Token$Open), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = (u0Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))())
                                : ((($4)[0] === "$BlockComment")
                                  ? ((() => {
                                    const $column = ($4)[1].column;
                                    const $nesting = ($4)[1].nesting;
                                    const $previous = ($4)[1].previous;
                                    const $start = ($4)[1].start;
                                    const $continueWithDeltaNesting = (($dn) => {
                                      return ((__re__ = (u0Compiler$Lexer$setMode)((u0Compiler$Lexer$BlockComment)(({
                                        column: $column,
                                        nesting: ($nesting + $dn),
                                        previous: $char,
                                        start: $start,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    });
                                    const $5 = ({
                                      first: $previous,
                                      second: $char,
                                    });
                                    return ((("[" === $5.first) && ("#" === $5.second))
                                      ? ($continueWithDeltaNesting)(1)
                                      : ((("#" === $5.first) && ("]" === $5.second))
                                        ? (($nesting > 1)
                                          ? ($continueWithDeltaNesting)(-(1))
                                          : ((() => {
                                            ((($0) => {
                                              return ((__re__ = (u0Compiler$Lexer$addCommentTokenAbs)($start, (((__re__ = (u0Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1), $0, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                            }))((c0Compiler$Token$Comment)(({
                                              indent: $column,
                                              isBlock: true,
                                              isFollowedByBlank: ((__re__ = (u0Compiler$Lexer$thereIsABlankAhead)(1, $buffer, $state)), ($state = (__re__)[1]), (__re__)[0]),
                                            })));
                                            return ((__re__ = (u0Compiler$Lexer$setMode)(u0Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                          }))())
                                        : (("" === $5.second)
                                          ? ((__re__ = (u0Compiler$Lexer$addError)("unterminated block comment", $state)), ($state = (__re__)[1]), (__re__)[0])
                                          : (true
                                            ? ($continueWithDeltaNesting)(0)
                                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 882:12', (sp_toHuman)($5))))));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 598:4', (sp_toHuman)($4))))))))))))))))),
    $state,
  ]);
});

const u0Compiler$Lexer$readStateInit = (($keepComments) => {
  return ({
    column: 0,
    errors: (array_fromList)(c0Core$Nil),
    indentStack: (array_fromList)(c0Core$Nil),
    indentStartsABlock: true,
    keepComments: (basics_cloneImm)($keepComments),
    line: 0,
    lineIndent: 0,
    mode: u0Compiler$Lexer$Indent,
    nextPos: 0,
    sections: (array_fromList)(c0Core$Nil),
    soFarThereAreNoTokensInThisLine: true,
    tabsOrSpaces: u0Compiler$Lexer$NoTabsOrSpacesYet,
    tokenStart: 0,
    tokens: (array_fromList)(c0Core$Nil),
  });
});

const u0Compiler$Lexer$lexer = (($keepComments, $module) => {
  const $moduleCode = $module.content;
  let $state = (u0Compiler$Lexer$readStateInit)($keepComments);
  (text_forEach)($moduleCode, (($char) => {
    ((__re__ = (u0Compiler$Lexer$lexOne)($moduleCode, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
    ($state.nextPos += 1);
    return ((sp_equal)($char, "\n")
      ? ((() => {
        ($state.line += 1);
        return ($state.column = 0);
      }))()
      : ($state.column += 1));
  }));
  ((__re__ = (u0Compiler$Lexer$lexOne)($moduleCode, "", $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $3 = ((__re__ = (array_toList)($state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ((($3)[0] === "$Nil")
    ? ((() => {
      ((__re__ = (u0Compiler$Lexer$closeOpenBlocks)($state)), ($state = (__re__)[1]), (__re__)[0]);
      return (c0Result$Ok)(((__re__ = (array_toList)($state.sections)), ($state.sections = (__re__)[1]), (__re__)[0]));
    }))()
    : (true
      ? ((() => {
        const $errors = $3;
        return (c0Result$Err)((u0Compiler$Error$Nested)(((($0) => {
          return (c0List$map)((($e) => {
            return ($e)($module);
          }), $0);
        }))($errors)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 990:4', (sp_toHuman)($3))));
});

const u0Compiler$Parser$makeError = (($env, $farthestParsed, $message) => {
  return ((($0) => {
    return (u0Compiler$Error$res)($env.errorModule, $0, (c0Core$Cons)($message, c0Core$Nil));
  }))(((($farthestParsed)[0] === "$Nil")
    ? (c0Compiler$Pos$P)(0, 1)
    : (((($farthestParsed)[0] === "$Cons") && ((($farthestParsed)[1])[0] === "$Token"))
      ? ((() => {
        const $start = (($farthestParsed)[1])[1];
        const $end = (($farthestParsed)[1])[2];
        const $k = (($farthestParsed)[1])[3];
        const $rest = ($farthestParsed)[2];
        return (c0Compiler$Pos$P)($start, $end);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 860:4', (sp_toHuman)($farthestParsed)))));
});

const u0Compiler$Parser$eatComments = (($readState) => {
  const $2 = $readState.tokens;
  return (((($2)[0] === "$Cons") && (((($2)[1])[0] === "$Token") && (((($2)[1])[3])[0] === "$Comment")))
    ? ((() => {
      const $start = (($2)[1])[1];
      const $end = (($2)[1])[2];
      const $indent = ((($2)[1])[3])[1].indent;
      const $isBlock = ((($2)[1])[3])[1].isBlock;
      const $isFollowedByBlank = ((($2)[1])[3])[1].isFollowedByBlank;
      const $tail = ($2)[2];
      return (u0Compiler$Parser$eatComments)(({
        commentsReversed: (c0Core$Cons)(({
          end: $end,
          indent: $indent,
          isBlock: $isBlock,
          isFollowedByBlank: $isFollowedByBlank,
          start: $start,
        }), $readState.commentsReversed),
        tokens: $tail,
      }));
    }))()
    : (true
      ? $readState
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 24:4', (sp_toHuman)($2))));
});

const u0SPLib$Parser$accept = (($a) => {
  return (($rejections, $readState) => {
    return ({
      first: $rejections,
      second: (u0SPLib$Parser$Accepted)($readState, $a),
    });
  });
});

const u0Compiler$Parser$ok = u0SPLib$Parser$accept;

const u0SPLib$Parser$thenWithDefault = (($fallbackParser, $chainedParser) => {
  return (($firstParser) => {
    return (($re0, $readState) => {
      const $6 = ($firstParser)($re0, $readState);
      return ((($6.second)[0] === "$Aborted")
        ? ((() => {
          const $re1 = $6.first;
          const $rs = ($6.second)[1];
          const $reason = ($6.second)[2];
          return ({
            first: $re1,
            second: (u0SPLib$Parser$Aborted)($rs, $reason),
          });
        }))()
        : ((($6.second)[0] === "$Rejected")
          ? ((() => {
            const $re1 = $6.first;
            return ($fallbackParser)($re1, $readState);
          }))()
          : ((($6.second)[0] === "$Accepted")
            ? ((() => {
              const $re1 = $6.first;
              const $nextReadState = ($6.second)[1];
              const $a = ($6.second)[2];
              return (($chainedParser)($a))($re1, $nextReadState);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 86:4', (sp_toHuman)($6)))));
    });
  });
});

const u0Compiler$Parser$forZeroOrMore = (($init, $getParser) => {
  return ((u0SPLib$Parser$thenWithDefault)((u0Compiler$Parser$ok)($init), (($0) => {
    return (u0Compiler$Parser$forZeroOrMore)($0, $getParser);
  })))(($getParser)($init));
});

const u0SPLib$Parser$andThen = (($chainedParser) => {
  return (($firstParser) => {
    return (($re0, $readState) => {
      const $5 = ($firstParser)($re0, $readState);
      return ((($5.second)[0] === "$Accepted")
        ? ((() => {
          const $re1 = $5.first;
          const $nextReadState = ($5.second)[1];
          const $a = ($5.second)[2];
          return (($chainedParser)($a))($re1, $nextReadState);
        }))()
        : ((($5.second)[0] === "$Rejected")
          ? ((() => {
            const $re1 = $5.first;
            return ({
              first: $re1,
              second: u0SPLib$Parser$Rejected,
            });
          }))()
          : ((($5.second)[0] === "$Aborted")
            ? ((() => {
              const $re1 = $5.first;
              const $rs = ($5.second)[1];
              const $e = ($5.second)[2];
              return ({
                first: $re1,
                second: (u0SPLib$Parser$Aborted)($rs, $e),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 75:4', (sp_toHuman)($5)))));
    });
  });
});

const u0Compiler$Parser$on = u0SPLib$Parser$andThen;

const u0Compiler$Parser$oneToken = (($rejections, $rs) => {
  const $readState = (u0Compiler$Parser$eatComments)($rs);
  const $3 = $readState.tokens;
  return ((($3)[0] === "$Nil")
    ? ({
      first: (c0Core$Cons)($readState, $rejections),
      second: u0SPLib$Parser$Rejected,
    })
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $token = ($3)[1];
        const $tail = ($3)[2];
        return ({
          first: $rejections,
          second: (u0SPLib$Parser$Accepted)(((() => {
            const $0 = $readState;
            return (Object.assign)({}, $0, ({
              tokens: $tail,
            }));
          }))(), $token),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 46:4', (sp_toHuman)($3))));
});

const u0SPLib$Parser$reject = (($rejections, $readState) => {
  return ({
    first: (sp_cons)($readState, $rejections),
    second: u0SPLib$Parser$Rejected,
  });
});

const u0Compiler$Parser$kind = (($targetKind) => {
  return ((u0Compiler$Parser$on)((($token) => {
    const $3 = $token;
    const $k = ($3)[3];
    return ((sp_equal)($targetKind, $k)
      ? (u0Compiler$Parser$ok)($token)
      : u0SPLib$Parser$reject);
  })))(u0Compiler$Parser$oneToken);
});

const u0Compiler$Parser$stackCommentsReversedAsStatements = (($comments, $acc) => {
  return (c0List$forReversed)($acc, $comments, (($comment, $accN) => {
    return (sp_cons)((c0Compiler$FormattableAst$CommentStatement)($comment), $accN);
  }));
});

const u0Compiler$Parser$mkLine = (($env, $line) => {
  return ($env.stripLocations
    ? -(1)
    : $line);
});

const u0Compiler$Parser$pos = (($env, $start, $end) => {
  return ($env.stripLocations
    ? c0Compiler$Pos$T
    : (c0Compiler$Pos$P)($start, $end));
});

const u0Compiler$Parser$pullCommentsReversed = (($rejections, $rs) => {
  const $readState = (u0Compiler$Parser$eatComments)($rs);
  return ({
    first: $rejections,
    second: (u0SPLib$Parser$Accepted)(((() => {
      const $0 = $readState;
      return (Object.assign)({}, $0, ({
        commentsReversed: c0Core$Nil,
      }));
    }))(), $readState.commentsReversed),
  });
});

const u0Compiler$Parser$binop = (($env) => {
  return ((u0Compiler$Parser$on)((($2) => {
    const $start = ($2)[1];
    const $end = ($2)[2];
    const $k = ($2)[3];
    return ((($k)[0] === "$Binop")
      ? ((() => {
        const $line = ($k)[1];
        const $precedence = ($k)[2].precedence;
        const $symbol = ($k)[2].symbol;
        const $usr = ($k)[2].usr;
        return ((u0Compiler$Parser$on)((($commentsReversed) => {
          return (u0Compiler$Parser$ok)(({
            comments: (c0List$reverse)($commentsReversed),
            line: (u0Compiler$Parser$mkLine)($env, $line),
            pos: (u0Compiler$Parser$pos)($env, $start, $end),
            precedence: $precedence,
            symbol: $symbol,
            usr: $usr,
          }));
        })))(u0Compiler$Parser$pullCommentsReversed);
      }))()
      : (true
        ? u0SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 634:4', (sp_toHuman)($k))));
  })))(u0Compiler$Parser$oneToken);
});

const u0SPLib$Parser$surroundWith = (($left, $right, $parser) => {
  return ((u0SPLib$Parser$andThen)(((_0) => {
    return ((u0SPLib$Parser$andThen)((($p) => {
      return ((u0SPLib$Parser$andThen)(((_0) => {
        return (u0SPLib$Parser$accept)($p);
      })))($right);
    })))($parser);
  })))($left);
});

const u0Compiler$Parser$surroundStrict = (($left, $right, $p) => {
  return (u0SPLib$Parser$surroundWith)((u0Compiler$Parser$kind)($left), (u0Compiler$Parser$kind)($right), $p);
});

const u0Compiler$Parser$block = (($0) => {
  return (u0Compiler$Parser$surroundStrict)(c0Compiler$Token$BlockStart, c0Compiler$Token$BlockEnd, $0);
});

const u0Compiler$Parser$discardFirst = (($a, $b) => {
  return ((u0Compiler$Parser$on)(((_0) => {
    return $b;
  })))($a);
});

const u0Compiler$Parser$sib = (($0) => {
  return (u0Compiler$Parser$discardFirst)((u0Compiler$Parser$kind)(c0Compiler$Token$NewSiblingLine), $0);
});

const u0SPLib$Parser$here = (($rejections, $readState) => {
  return ({
    first: $rejections,
    second: (u0SPLib$Parser$Accepted)($readState, $readState),
  });
});

const u0Compiler$Parser$here = ((u0Compiler$Parser$on)((($readState) => {
  return (u0Compiler$Parser$ok)(((() => {
    const $2 = $readState.tokens;
    return (((($2)[0] === "$Cons") && ((($2)[1])[0] === "$Token"))
      ? ((() => {
        const $start = (($2)[1])[1];
        const $end = (($2)[1])[2];
        const $rest = ($2)[2];
        return $start;
      }))()
      : ((($2)[0] === "$Nil")
        ? 0
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 77:4', (sp_toHuman)($2))));
  }))());
})))(u0SPLib$Parser$here);

const u0Compiler$Parser$siblingStatements = (($env) => {
  return ((u0Compiler$Parser$on)((($start) => {
    return ((u0Compiler$Parser$on)((($acc) => {
      return ((u0Compiler$Parser$on)((($reversedStatements) => {
        return ((u0Compiler$Parser$on)((($end) => {
          return (((($reversedStatements)[0] === "$Cons") && (((($reversedStatements)[1])[0] === "$Evaluation") && ((($reversedStatements)[2])[0] === "$Nil")))
            ? ((() => {
              const $e = (($reversedStatements)[1])[1];
              return (u0Compiler$Parser$ok)($e);
            }))()
            : (true
              ? ((() => {
                const $many = $reversedStatements;
                return (u0Compiler$Parser$ok)(((($0) => {
                  return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, (u0Compiler$Parser$pos)($env, $start, $end), $0);
                }))((c0Compiler$FormattableAst$Statements)((c0List$reverse)($many))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 275:4', (sp_toHuman)($reversedStatements))));
        })))(u0Compiler$Parser$here);
      })))((u0Compiler$Parser$forZeroOrMore)($acc, (($a) => {
        return (u0Compiler$Parser$discardFirst)((u0Compiler$Parser$kind)(c0Compiler$Token$NewSiblingLine), (u0Compiler$Parser$statementParser)($env, $a));
      })));
    })))((u0Compiler$Parser$statementParser)($env, c0Core$Nil));
  })))(u0Compiler$Parser$here);
});

const u0SPLib$Parser$oneOf = (($ps) => {
  return (($rejections, $readState) => {
    return ((($ps)[0] === "$Nil")
      ? ({
        first: $rejections,
        second: u0SPLib$Parser$Rejected,
      })
      : ((($ps)[0] === "$Cons")
        ? ((() => {
          const $headParser = ($ps)[1];
          const $tailParsers = ($ps)[2];
          const $4 = ($headParser)($rejections, $readState);
          return ((($4.second)[0] === "$Rejected")
            ? ((() => {
              const $re1 = $4.first;
              return ((u0SPLib$Parser$oneOf)($tailParsers))($re1, $readState);
            }))()
            : (true
              ? ((() => {
                const $acceptedOrAborted = $4;
                return $acceptedOrAborted;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 144:12', (sp_toHuman)($4))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 138:4', (sp_toHuman)($ps))));
  });
});

const u0Compiler$Parser$alignedOrInlineStatements = (($env) => {
  return (u0SPLib$Parser$oneOf)((c0Core$Cons)(((u0Compiler$Parser$on)((($e) => {
    return (u0Compiler$Parser$ok)(({
      first: c0Compiler$FormattableAst$Indented,
      second: $e,
    }));
  })))((u0Compiler$Parser$block)((u0Compiler$Parser$siblingStatements)($env))), (c0Core$Cons)(((u0Compiler$Parser$on)((($e) => {
    return (u0Compiler$Parser$ok)(({
      first: c0Compiler$FormattableAst$Aligned,
      second: $e,
    }));
  })))((u0Compiler$Parser$sib)((u0Compiler$Parser$siblingStatements)($env))), (c0Core$Cons)(((u0Compiler$Parser$on)((($e) => {
    return (u0Compiler$Parser$ok)(({
      first: c0Compiler$FormattableAst$Inline,
      second: $e,
    }));
  })))((u0Compiler$Parser$expr)($env)), c0Core$Nil))));
});

const u0Compiler$Parser$discardSecond = (($a, $b) => {
  return ((u0Compiler$Parser$on)((($aa) => {
    return ((u0Compiler$Parser$on)(((_0) => {
      return (u0Compiler$Parser$ok)($aa);
    })))($b);
  })))($a);
});

const u0Compiler$Parser$indentedOrInlineStatements = (($env) => {
  return (u0SPLib$Parser$oneOf)((c0Core$Cons)((u0Compiler$Parser$block)((u0Compiler$Parser$siblingStatements)($env)), (c0Core$Cons)((u0Compiler$Parser$expr)($env), c0Core$Nil)));
});

const u0Compiler$Parser$inlineOrBelowOrIndented = (($p) => {
  return (u0SPLib$Parser$oneOf)((c0Core$Cons)((u0Compiler$Parser$block)($p), (c0Core$Cons)((u0Compiler$Parser$sib)($p), (c0Core$Cons)($p, c0Core$Nil))));
});

const u0SPLib$Parser$maybe = (($p) => {
  return ((u0SPLib$Parser$thenWithDefault)((u0SPLib$Parser$accept)(c0Maybe$Nothing), (($x) => {
    return (u0SPLib$Parser$accept)((c0Maybe$Just)($x));
  })))($p);
});

const u0Compiler$Parser$maybe = u0SPLib$Parser$maybe;

const u0Compiler$Parser$maybeNewLine = (($0) => {
  return (u0Compiler$Parser$discardFirst)((u0SPLib$Parser$maybe)((u0Compiler$Parser$kind)(c0Compiler$Token$NewSiblingLine)), $0);
});

const u0SPLib$Parser$zeroOrMore = (($p) => {
  return ((u0SPLib$Parser$thenWithDefault)((u0SPLib$Parser$accept)(c0Core$Nil), (($head) => {
    return ((u0SPLib$Parser$andThen)((($tail) => {
      return (u0SPLib$Parser$accept)((sp_cons)($head, $tail));
    })))((u0SPLib$Parser$zeroOrMore)($p));
  })))($p);
});

const u0Compiler$Parser$oomSeparatedBy = (($sep, $pa) => {
  return ((u0Compiler$Parser$on)((($head) => {
    return ((u0Compiler$Parser$on)((($tail) => {
      return (u0Compiler$Parser$ok)((sp_cons)($head, $tail));
    })))((u0SPLib$Parser$zeroOrMore)((u0Compiler$Parser$discardFirst)($sep, $pa)));
  })))($pa);
});

const u0Compiler$Parser$rawList = (($item) => {
  const $sibsep = (u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$kind)(c0Compiler$Token$Comma));
  return (u0Compiler$Parser$discardFirst)((u0SPLib$Parser$maybe)($sibsep), (u0Compiler$Parser$oomSeparatedBy)($sibsep, $item));
});

const u0Compiler$Parser$expressionWithUnambiguousStart = (($env) => {
  return ((u0Compiler$Parser$on)((($commentsReversed) => {
    return ((u0Compiler$Parser$on)((($3) => {
      const $start = ($3)[1];
      const $end = ($3)[2];
      const $kk = ($3)[3];
      const $expressionOk = (($e) => {
        return (u0Compiler$Parser$ok)((u0Compiler$Parser$E_under)($e));
      });
      const $b = ((($kk)[0] === "$Lowercase")
        ? ((() => {
          const $attrPath = ($kk)[1].attrPath;
          const $maybeModule = ($kk)[1].maybeModule;
          const $name = ($kk)[1].name;
          return ((u0Compiler$Parser$on)((($maybeType) => {
            return ($expressionOk)((c0Compiler$FormattableAst$Lowercase)(({
              attrPath: $attrPath,
              maybeModule: $maybeModule,
              maybeType: $maybeType,
              name: $name,
            })));
          })))((u0Compiler$Parser$maybe)((u0Compiler$Parser$discardFirst)((u0Compiler$Parser$kind)(c0Compiler$Token$As), (u0Compiler$Parser$expr)($env))));
        }))()
        : ((($kk)[0] === "$Constructor")
          ? ((() => {
            const $pas = ($kk)[1];
            return ($expressionOk)((c0Compiler$FormattableAst$Constructor)($pas));
          }))()
          : ((($kk)[0] === "$Uppercase")
            ? ((() => {
              const $pas = ($kk)[1];
              return ($expressionOk)((c0Compiler$FormattableAst$Uppercase)($pas));
            }))()
            : ((($kk)[0] === "$RecordShorthand")
              ? ((() => {
                const $pas = ($kk)[1];
                return ($expressionOk)((c0Compiler$FormattableAst$RecordShorthand)($pas));
              }))()
              : ((($kk)[0] === "$ArgumentPlaceholder")
                ? ($expressionOk)(c0Compiler$FormattableAst$ArgumentPlaceholder)
                : ((($kk)[0] === "$NumberLiteral")
                  ? ((() => {
                    const $isPercent = ($kk)[1];
                    const $s = ($kk)[2];
                    return ((u0Compiler$Parser$on)((($maybeUniPoly) => {
                      return ($expressionOk)(((($maybeUniPoly)[0] === "$Nothing")
                        ? (c0Compiler$FormattableAst$LiteralNumber)($isPercent, $s)
                        : ((($maybeUniPoly)[0] === "$Just")
                          ? ((() => {
                            const $exp = ($maybeUniPoly)[1];
                            return (c0Compiler$FormattableAst$Poly)($s, $exp);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 389:16', (sp_toHuman)($maybeUniPoly)))));
                    })))((u0Compiler$Parser$maybe)((u0Compiler$Parser$discardFirst)((u0Compiler$Parser$kind)(c0Compiler$Token$UniquenessPolymorphismBinop), (u0Compiler$Parser$expr)($env))));
                  }))()
                  : ((($kk)[0] === "$TextLiteral")
                    ? ((() => {
                      const $singleOrTriple = ($kk)[1];
                      const $s = ($kk)[2];
                      return ($expressionOk)((c0Compiler$FormattableAst$LiteralText)($singleOrTriple, $s));
                    }))()
                    : (((($kk)[0] === "$RoundParen") && ((($kk)[1])[0] === "$Open"))
                      ? ((u0Compiler$Parser$on)((($e) => {
                        return (u0Compiler$Parser$ok)((u0Compiler$Parser$E_full)($e));
                      })))((u0Compiler$Parser$discardSecond)((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$expr)($env)), (u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$kind)((c0Compiler$Token$RoundParen)(c0Compiler$Token$Closed)))))
                      : (((($kk)[0] === "$SquareBracket") && ((($kk)[2])[0] === "$Open"))
                        ? ((() => {
                          const $openRow = ($kk)[1];
                          const $item = ((u0Compiler$Parser$on)((($exp) => {
                            return ((u0Compiler$Parser$on)((($maybeDots) => {
                              return (u0Compiler$Parser$ok)(({
                                first: (sp_not_equal)($maybeDots, c0Maybe$Nothing),
                                second: $exp,
                              }));
                            })))((u0Compiler$Parser$maybe)((u0Compiler$Parser$kind)(c0Compiler$Token$ThreeDots)));
                          })))((u0Compiler$Parser$expr)($env));
                          const $closeBracket = ((u0Compiler$Parser$on)((($4) => {
                            const $k = ($4)[3];
                            return (((($k)[0] === "$SquareBracket") && ((($k)[2])[0] === "$Closed"))
                              ? ((() => {
                                const $line = ($k)[1];
                                return (u0Compiler$Parser$ok)($line);
                              }))()
                              : (true
                                ? u0SPLib$Parser$reject
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 415:20', (sp_toHuman)($k))));
                          })))(u0Compiler$Parser$oneToken);
                          return ((u0Compiler$Parser$on)((($exps) => {
                            return ((u0Compiler$Parser$on)((($closeRow) => {
                              return ($expressionOk)((c0Compiler$FormattableAst$List)(($closeRow > $openRow), (c0Maybe$withDefault)(c0Core$Nil, $exps)));
                            })))((u0Compiler$Parser$inlineOrBelowOrIndented)($closeBracket));
                          })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$maybe)((u0Compiler$Parser$rawList)($item))));
                        }))()
                        : (((($kk)[0] === "$CurlyBrace") && ((($kk)[2])[0] === "$Open"))
                          ? ((() => {
                            const $openRow = ($kk)[1];
                            const $extension = (u0Compiler$Parser$discardSecond)((u0Compiler$Parser$maybe)((u0Compiler$Parser$expr)($env)), (u0Compiler$Parser$kind)(c0Compiler$Token$With));
                            const $attribute = ((u0Compiler$Parser$on)(((_0) => {
                              return ((u0Compiler$Parser$on)((($name) => {
                                return ((u0Compiler$Parser$on)((($maybeExpr) => {
                                  return (u0Compiler$Parser$ok)(({
                                    maybeExpr: $maybeExpr,
                                    name: $name,
                                  }));
                                })))((u0Compiler$Parser$maybe)((u0Compiler$Parser$discardFirst)((u0Compiler$Parser$kind)(c0Compiler$Token$Defop), (u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$expr)($env)))));
                              })))((u0Compiler$Parser$expr)($env));
                            })))((u0Compiler$Parser$maybe)((u0Compiler$Parser$kind)(c0Compiler$Token$NewSiblingLine)));
                            const $closeBrace = ((u0Compiler$Parser$on)((($4) => {
                              const $k = ($4)[3];
                              return (((($k)[0] === "$CurlyBrace") && ((($k)[2])[0] === "$Closed"))
                                ? ((() => {
                                  const $line = ($k)[1];
                                  return (u0Compiler$Parser$ok)($line);
                                }))()
                                : (true
                                  ? u0SPLib$Parser$reject
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 441:20', (sp_toHuman)($k))));
                            })))(u0Compiler$Parser$oneToken);
                            return ((u0Compiler$Parser$on)((($maybeExtension) => {
                              return ((u0Compiler$Parser$on)((($attrs) => {
                                return ((u0Compiler$Parser$on)((($closeRow) => {
                                  return ($expressionOk)((c0Compiler$FormattableAst$Record)(({
                                    attrs: (c0Maybe$withDefault)(c0Core$Nil, $attrs),
                                    isMultiline: ($closeRow > $openRow),
                                    maybeExtension: $maybeExtension,
                                  })));
                                })))((u0Compiler$Parser$inlineOrBelowOrIndented)($closeBrace));
                              })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$maybe)((u0Compiler$Parser$rawList)($attribute))));
                            })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$maybe)($extension)));
                          }))()
                          : ((($kk)[0] === "$Fn")
                            ? ((u0Compiler$Parser$on)((($args) => {
                              return ((u0Compiler$Parser$on)(((_0) => {
                                return ((u0Compiler$Parser$on)((($6) => {
                                  const $isMultiline = $6.first;
                                  const $body = $6.second;
                                  return ($expressionOk)((c0Compiler$FormattableAst$Fn)($isMultiline, $args, $body));
                                })))((u0Compiler$Parser$alignedOrInlineStatements)($env));
                              })))((u0Compiler$Parser$kind)(c0Compiler$Token$Colon));
                            })))((u0Compiler$Parser$rawList)((u0Compiler$Parser$expr)($env)))
                            : ((($kk)[0] === "$If")
                              ? ((() => {
                                const $ifLine = ($kk)[1];
                                const $elseParser = ((u0Compiler$Parser$on)((($4) => {
                                  const $k = ($4)[3];
                                  return ((($k)[0] === "$Else")
                                    ? ((() => {
                                      const $line = ($k)[1];
                                      return (u0Compiler$Parser$ok)($line);
                                    }))()
                                    : (true
                                      ? u0SPLib$Parser$reject
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 472:20', (sp_toHuman)($k))));
                                })))(u0Compiler$Parser$oneToken);
                                return ((u0Compiler$Parser$on)((($condition) => {
                                  return ((u0Compiler$Parser$on)(((_0) => {
                                    return ((u0Compiler$Parser$on)((($6) => {
                                      const $true = $6.second;
                                      return ((u0Compiler$Parser$on)((($elseLine) => {
                                        return ((u0Compiler$Parser$on)((($8) => {
                                          const $false = $8.second;
                                          return ($expressionOk)((c0Compiler$FormattableAst$If)(({
                                            condition: $condition,
                                            false: $false,
                                            isMultiline: ($elseLine > $ifLine),
                                            true: $true,
                                          })));
                                        })))((u0Compiler$Parser$alignedOrInlineStatements)($env));
                                      })))((u0Compiler$Parser$inlineOrBelowOrIndented)($elseParser));
                                    })))((u0Compiler$Parser$alignedOrInlineStatements)($env));
                                  })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$kind)(c0Compiler$Token$Then)));
                                })))((u0Compiler$Parser$expr)($env));
                              }))()
                              : ((($kk)[0] === "$Try")
                                ? ((() => {
                                  const $maybeNewLineKind = (($k) => {
                                    return (u0Compiler$Parser$maybeNewLine)((u0Compiler$Parser$kind)($k));
                                  });
                                  const $patternAndValue = ((u0Compiler$Parser$on)((($p) => {
                                    return ((u0Compiler$Parser$on)(((_0) => {
                                      return ((u0Compiler$Parser$on)((($value) => {
                                        return (u0Compiler$Parser$ok)(({
                                          first: $p,
                                          second: $value,
                                        }));
                                      })))((u0Compiler$Parser$indentedOrInlineStatements)($env));
                                    })))((u0Compiler$Parser$kind)(c0Compiler$Token$Colon));
                                  })))((u0Compiler$Parser$expr)($env));
                                  return ((u0Compiler$Parser$on)((($value) => {
                                    return ((u0Compiler$Parser$on)(((_0) => {
                                      return ((u0Compiler$Parser$on)((($patterns) => {
                                        return ($expressionOk)((c0Compiler$FormattableAst$Try)(({
                                          patterns: $patterns,
                                          value: $value,
                                        })));
                                      })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$oomSeparatedBy)((u0Compiler$Parser$kind)(c0Compiler$Token$NewSiblingLine), $patternAndValue)));
                                    })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$kind)(c0Compiler$Token$As)));
                                  })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$expr)($env)));
                                }))()
                                : ((($kk)[0] === "$Unop")
                                  ? ((() => {
                                    const $op = ($kk)[1];
                                    return ((u0Compiler$Parser$on)((($e) => {
                                      return ($expressionOk)((c0Compiler$FormattableAst$UnopCall)($op, $e));
                                    })))((u0Compiler$Parser$expressionWithUnambiguousStart)($env));
                                  }))()
                                  : ((($kk)[0] === "$Native")
                                    ? ($expressionOk)(c0Compiler$FormattableAst$Native)
                                    : (true
                                      ? u0SPLib$Parser$reject
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 360:8', (sp_toHuman)($kk))))))))))))))))));
      return ((u0Compiler$Parser$on)((($ee) => {
        return ((($ee)[0] === "$E_under")
          ? ((() => {
            const $expr_ = ($ee)[1];
            return (u0Compiler$Parser$ok)((c0Compiler$FormattableAst$Expression)((c0List$reverse)($commentsReversed), (u0Compiler$Parser$pos)($env, $start, $end), $expr_));
          }))()
          : ((($ee)[0] === "$E_full")
            ? ((() => {
              const $expression = ($ee)[1];
              return ((sp_equal)($commentsReversed, c0Core$Nil)
                ? (u0Compiler$Parser$ok)($expression)
                : (u0Compiler$Parser$ok)(((($0) => {
                  return (c0Compiler$FormattableAst$Expression)((c0List$reverse)($commentsReversed), (u0Compiler$Parser$pos)($env, $start, $end), $0);
                }))((c0Compiler$FormattableAst$Statements)((c0Core$Cons)((c0Compiler$FormattableAst$Evaluation)($expression), c0Core$Nil)))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 528:4', (sp_toHuman)($ee))));
      })))($b);
    })))(u0Compiler$Parser$oneToken);
  })))(u0Compiler$Parser$pullCommentsReversed);
});

const u0Compiler$Parser$posRange = (($exprs) => {
  return ((($exprs)[0] === "$Nil")
    ? c0Compiler$Pos$G
    : (((($exprs)[0] === "$Cons") && ((($exprs)[1])[0] === "$Expression"))
      ? ((() => {
        const $start = (($exprs)[1])[2];
        const $tail = ($exprs)[2];
        const $2 = (c0List$last)($tail);
        return (((($2)[0] === "$Just") && ((($2)[1])[0] === "$Expression"))
          ? ((() => {
            const $end = (($2)[1])[2];
            return (c0Compiler$Pos$range)($start, $end);
          }))()
          : ((($2)[0] === "$Nothing")
            ? $start
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 754:12', (sp_toHuman)($2))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 748:4', (sp_toHuman)($exprs))));
});

const u0Compiler$Parser$functionApplication = (($env) => {
  const $term = (u0Compiler$Parser$expressionWithUnambiguousStart)($env);
  return ((u0Compiler$Parser$on)((($ref) => {
    return ((u0Compiler$Parser$on)((($inlineArgs) => {
      return ((u0Compiler$Parser$on)((($indentedArgs) => {
        const $args = (c0List$concat)((c0Core$Cons)($inlineArgs, (c0Core$Cons)((c0Maybe$withDefault)(c0Core$Nil, $indentedArgs), c0Core$Nil)));
        return ((sp_equal)($args, c0Core$Nil)
          ? (u0Compiler$Parser$ok)($ref)
          : ((() => {
            const $p = (u0Compiler$Parser$posRange)((c0Core$Cons)($ref, $args));
            return (((($ref)[0] === "$Expression") && ((($ref)[3])[0] === "$UnopCall"))
              ? ((() => {
                const $comments = ($ref)[1];
                const $p1 = ($ref)[2];
                const $op = (($ref)[3])[1];
                const $unoped = (($ref)[3])[2];
                return (u0Compiler$Parser$ok)(((($0) => {
                  return (c0Compiler$FormattableAst$Expression)($comments, $p1, $0);
                }))(((($0) => {
                  return (c0Compiler$FormattableAst$UnopCall)($op, $0);
                }))(((($0) => {
                  return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $p, $0);
                }))((c0Compiler$FormattableAst$Call)($unoped, $args)))));
              }))()
              : (true
                ? (u0Compiler$Parser$ok)(((($0) => {
                  return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $p, $0);
                }))((c0Compiler$FormattableAst$Call)($ref, $args)))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 615:8', (sp_toHuman)($ref))));
          }))());
      })))((u0SPLib$Parser$maybe)((u0Compiler$Parser$block)((u0SPLib$Parser$zeroOrMore)((u0Compiler$Parser$inlineOrBelowOrIndented)($term)))));
    })))((u0SPLib$Parser$zeroOrMore)($term));
  })))($term);
});

const u0Compiler$Parser$binopChain = (($env) => {
  const $app = (u0Compiler$Parser$functionApplication)($env);
  return ((u0Compiler$Parser$on)((($left) => {
    const $binopAndApp = ((u0Compiler$Parser$on)((($b) => {
      return ((u0Compiler$Parser$on)((($a) => {
        return (u0Compiler$Parser$ok)(({
          first: $b,
          second: $a,
        }));
      })))((u0Compiler$Parser$inlineOrBelowOrIndented)($app));
    })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$binop)($env)));
    return ((u0Compiler$Parser$on)((($rights) => {
      return (u0Compiler$Parser$ok)(({
        first: $left,
        second: $rights,
      }));
    })))((u0SPLib$Parser$zeroOrMore)($binopAndApp));
  })))($app);
});

const u0Compiler$Parser$chain_append = (($binopAndExpr, $1) => {
  const $left = $1.first;
  const $rights = $1.second;
  return ({
    first: $left,
    second: (c0List$reverse)((sp_cons)($binopAndExpr, (c0List$reverse)($rights))),
  });
});

const u0Compiler$Parser$blah = (($lowestPrecedence, $remainingChain, $accChain, $accOp) => {
  const $5 = (c0List$partitionWhile)((($6) => {
    const $op = $6.first;
    const $exp = $6.second;
    return ($op.precedence > $lowestPrecedence);
  }), $remainingChain.second);
  const $rest = $5.second;
  const $abovePrecedence = $5.first;
  const $ee = (u0Compiler$Parser$reorderAccordingToBinopPrecedence)(({
    first: $remainingChain.first,
    second: $abovePrecedence,
  }));
  const $updatedChain = (u0Compiler$Parser$chain_append)(({
    first: $accOp,
    second: $ee,
  }), $accChain);
  return ((($rest)[0] === "$Nil")
    ? ((() => {
      const $p = (u0Compiler$Parser$posRange)((sp_cons)($updatedChain.first, (c0List$map)((($x) => {
        return $x.second;
      }), $updatedChain.second)));
      return ((($0) => {
        return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, $p, $0);
      }))(((($0) => {
        return (c0Compiler$FormattableAst$BinopChain)($lowestPrecedence, $0);
      }))($updatedChain));
    }))()
    : ((($rest)[0] === "$Cons")
      ? ((() => {
        const $op = ($rest)[1].first;
        const $e = ($rest)[1].second;
        const $rem = ($rest)[2];
        return (u0Compiler$Parser$blah)($lowestPrecedence, ({
          first: $e,
          second: $rem,
        }), $updatedChain, $op);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 710:4', (sp_toHuman)($rest))));
});

const u0Compiler$Parser$findLowestPrecedence = ((() => {
  const $rec = (($lowest, $exprs) => {
    return ((($exprs)[0] === "$Nil")
      ? $lowest
      : ((($exprs)[0] === "$Cons")
        ? ((() => {
          const $b = ($exprs)[1].first;
          const $tail = ($exprs)[2];
          return ($rec)((c0Basics$min)($lowest, $b.precedence), $tail);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 686:8', (sp_toHuman)($exprs))));
  });
  return (($chain) => {
    return ($rec)(1000, $chain.second);
  });
}))();

const u0Compiler$Parser$reorderAccordingToBinopPrecedence = (($chain) => {
  const $2 = (u0Compiler$Parser$findLowestPrecedence)($chain);
  return ((1000 === $2)
    ? $chain.first
    : (true
      ? ((() => {
        const $lowestPrecedence = $2;
        const $3 = (c0List$partitionWhile)((($4) => {
          const $op = $4.first;
          const $exp = $4.second;
          return ($op.precedence > $lowestPrecedence);
        }), $chain.second);
        const $rest = $3.second;
        const $abovePrecedence = $3.first;
        const $left = (u0Compiler$Parser$reorderAccordingToBinopPrecedence)(({
          first: $chain.first,
          second: $abovePrecedence,
        }));
        return ((($rest)[0] === "$Nil")
          ? $left
          : ((($rest)[0] === "$Cons")
            ? ((() => {
              const $op = ($rest)[1].first;
              const $ee = ($rest)[1].second;
              const $tail = ($rest)[2];
              return (u0Compiler$Parser$blah)($lowestPrecedence, ({
                first: $ee,
                second: $tail,
              }), ({
                first: $left,
                second: c0Core$Nil,
              }), $op);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 741:12', (sp_toHuman)($rest))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 728:4', (sp_toHuman)($2))));
});

const u0Compiler$Parser$expr = (($env) => {
  return ((u0Compiler$Parser$on)((($x) => {
    return (u0Compiler$Parser$ok)((u0Compiler$Parser$reorderAccordingToBinopPrecedence)($x));
  })))((u0Compiler$Parser$binopChain)($env));
});

const u0Compiler$Parser$lowerName = (($env) => {
  return ((u0Compiler$Parser$on)((($2) => {
    const $start = ($2)[1];
    const $end = ($2)[2];
    const $k = ($2)[3];
    return (((($k)[0] === "$Lowercase") && (((($k)[1].attrPath)[0] === "$Nil") && ((($k)[1].maybeModule)[0] === "$Nothing")))
      ? ((() => {
        const $name = ($k)[1].name;
        return (u0Compiler$Parser$ok)(({
          first: (u0Compiler$Parser$pos)($env, $start, $end),
          second: $name,
        }));
      }))()
      : (true
        ? u0SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 185:4', (sp_toHuman)($k))));
  })))(u0Compiler$Parser$oneToken);
});

const u0Compiler$Parser$upperName = (($env) => {
  return ((u0Compiler$Parser$on)((($2) => {
    const $start = ($2)[1];
    const $end = ($2)[2];
    const $k = ($2)[3];
    return (((($k)[0] === "$Uppercase") && ((($k)[1].maybeModule)[0] === "$Nothing"))
      ? ((() => {
        const $name = ($k)[1].name;
        return (u0Compiler$Parser$ok)(({
          first: (u0Compiler$Parser$pos)($env, $start, $end),
          second: $name,
        }));
      }))()
      : (true
        ? u0SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 194:4', (sp_toHuman)($k))));
  })))(u0Compiler$Parser$oneToken);
});

const u0Compiler$Parser$aliasDef = (($env) => {
  return ((u0Compiler$Parser$on)((($name) => {
    return ((u0Compiler$Parser$on)((($args) => {
      return ((u0Compiler$Parser$on)(((_0) => {
        return ((u0Compiler$Parser$on)((($type) => {
          return (u0Compiler$Parser$ok)((c0Compiler$FormattableAst$AliasDef)(({
            args: $args,
            name: $name,
            type: $type,
          })));
        })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$expr)($env)));
      })))((u0Compiler$Parser$kind)(c0Compiler$Token$Defop));
    })))((u0SPLib$Parser$zeroOrMore)((u0Compiler$Parser$lowerName)($env)));
  })))((u0Compiler$Parser$upperName)($env));
});

const u0SPLib$Parser$abort = (($error) => {
  return (($rejections, $readState) => {
    return ({
      first: $rejections,
      second: (u0SPLib$Parser$Aborted)($readState, $error),
    });
  });
});

const u0Compiler$Parser$nonFunction = (($env) => {
  return ((u0Compiler$Parser$on)(((_0) => {
    return ((u0Compiler$Parser$on)((($names) => {
      return ((u0Compiler$Parser$on)((($4) => {
        const $name = $4.second;
        return ((sp_not_equal)($name, "NonFunction")
          ? (u0SPLib$Parser$abort)("Only NonFunction is supported for now")
          : (u0Compiler$Parser$ok)($names));
      })))((u0Compiler$Parser$upperName)($env));
    })))((u0Compiler$Parser$rawList)((u0Compiler$Parser$lowerName)($env)));
  })))((u0Compiler$Parser$kind)(c0Compiler$Token$With));
});

const u0Compiler$Parser$definitionOrEvaluation = (($env) => {
  return ((u0Compiler$Parser$on)((($ex) => {
    const $definitionTail = ((u0Compiler$Parser$on)((($maybeNf) => {
      return ((u0Compiler$Parser$on)(((_0) => {
        return ((u0Compiler$Parser$on)((($body) => {
          return (u0Compiler$Parser$ok)(({
            first: $maybeNf,
            second: $body,
          }));
        })))((u0Compiler$Parser$indentedOrInlineStatements)($env));
      })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$kind)(c0Compiler$Token$Defop)));
    })))((u0Compiler$Parser$maybe)((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$nonFunction)($env))));
    return ((u0Compiler$Parser$on)((($maybeDefTail) => {
      return (u0Compiler$Parser$ok)(((($maybeDefTail)[0] === "$Nothing")
        ? (c0Compiler$FormattableAst$Evaluation)($ex)
        : ((($maybeDefTail)[0] === "$Just")
          ? ((() => {
            const $maybeNf = ($maybeDefTail)[1].first;
            const $body = ($maybeDefTail)[1].second;
            return (c0Compiler$FormattableAst$ValueDef)(({
              body: $body,
              nonFn: (c0Maybe$withDefault)(c0Core$Nil, $maybeNf),
              pattern: $ex,
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 803:4', (sp_toHuman)($maybeDefTail)))));
    })))((u0Compiler$Parser$maybe)($definitionTail));
  })))((u0Compiler$Parser$expr)($env));
});

const u0Compiler$Parser$unionDef = (($env) => {
  const $variantKind = (c0Compiler$Token$Lowercase)(({
    attrPath: c0Core$Nil,
    maybeModule: c0Maybe$Nothing,
    name: "var",
  }));
  return ((u0Compiler$Parser$on)(((_0) => {
    return ((u0Compiler$Parser$on)((($name) => {
      return ((u0Compiler$Parser$on)((($args) => {
        return ((u0Compiler$Parser$on)(((_0) => {
          return ((u0Compiler$Parser$on)((($constructors) => {
            return (u0Compiler$Parser$ok)((c0Compiler$FormattableAst$UnionDef)(({
              args: $args,
              constructors: $constructors,
              name: $name,
            })));
          })))((u0Compiler$Parser$inlineOrBelowOrIndented)((u0Compiler$Parser$rawList)((u0Compiler$Parser$expr)($env))));
        })))((u0Compiler$Parser$kind)(c0Compiler$Token$Defop));
      })))((u0SPLib$Parser$zeroOrMore)((u0Compiler$Parser$lowerName)($env)));
    })))((u0Compiler$Parser$upperName)($env));
  })))((u0Compiler$Parser$kind)($variantKind));
});

const u0SPLib$Parser$breakCircularDefinition = (($a) => {
  return ((u0SPLib$Parser$andThen)($a))((u0SPLib$Parser$accept)(null));
});

const u0Compiler$Parser$statementParser = (($env, $acc0) => {
  return (u0SPLib$Parser$breakCircularDefinition)(((_0) => {
    return ((u0Compiler$Parser$on)(((_0) => {
      return ((u0Compiler$Parser$on)((($commentsReversed) => {
        return ((u0Compiler$Parser$on)((($statement) => {
          return (u0Compiler$Parser$ok)((c0Core$Cons)($statement, (u0Compiler$Parser$stackCommentsReversedAsStatements)($commentsReversed, $acc0)));
        })))((u0SPLib$Parser$oneOf)((c0Core$Cons)((u0Compiler$Parser$aliasDef)($env), (c0Core$Cons)((u0Compiler$Parser$unionDef)($env), (c0Core$Cons)((u0Compiler$Parser$definitionOrEvaluation)($env), c0Core$Nil)))));
      })))(u0Compiler$Parser$pullCommentsReversed);
    })))((u0SPLib$Parser$zeroOrMore)((u0Compiler$Parser$kind)(c0Compiler$Token$NewSiblingLine)));
  }));
});

const u0Compiler$Parser$rootStatement = (($env, $acc0) => {
  return ((u0Compiler$Parser$on)((($acc1) => {
    return ((u0Compiler$Parser$on)(((_0) => {
      return ((u0Compiler$Parser$on)((($rs) => {
        const $readState = (u0Compiler$Parser$eatComments)($rs);
        return ((sp_equal)($readState.tokens, c0Core$Nil)
          ? (u0Compiler$Parser$ok)(((($0) => {
            return (u0Compiler$Parser$stackCommentsReversedAsStatements)($readState.commentsReversed, $0);
          }))($acc1))
          : u0SPLib$Parser$reject);
      })))(u0SPLib$Parser$here);
    })))((u0SPLib$Parser$zeroOrMore)((u0Compiler$Parser$kind)(c0Compiler$Token$BlockEnd)));
  })))((u0Compiler$Parser$forZeroOrMore)($acc0, (($0) => {
    return (u0Compiler$Parser$statementParser)($env, $0);
  })));
});

const u0SPLib$Parser$runParser = (($parser, $readState) => {
  return ($parser)((c0Core$Cons)($readState, c0Core$Nil), $readState);
});

const u0Compiler$Parser$parse = (($env, $allTokens, $acc) => {
  const $initState = ({
    commentsReversed: c0Core$Nil,
    tokens: $allTokens,
  });
  const $4 = (u0SPLib$Parser$runParser)((u0Compiler$Parser$rootStatement)($env, $acc), $initState);
  const $outcome = $4.second;
  const $failureStates = $4.first;
  return ((($outcome)[0] === "$Accepted")
    ? ((() => {
      const $readState = ($outcome)[1];
      const $output = ($outcome)[2];
      return (c0Result$Ok)($output);
    }))()
    : ((($outcome)[0] === "$Aborted")
      ? ((() => {
        const $readState = ($outcome)[1];
        const $message = ($outcome)[2];
        return (u0Compiler$Parser$makeError)($env, $readState.tokens, $message);
      }))()
      : ((($outcome)[0] === "$Rejected")
        ? ((() => {
          const $findMin = (($6, $best) => {
            const $tokens = $6.tokens;
            return (((c0List$length)($tokens) < (c0List$length)($best))
              ? $tokens
              : $best);
          });
          const $farthestParsed = (c0List$for)($allTokens, $failureStates, $findMin);
          const $5 = ({
            first: $farthestParsed,
            second: $allTokens,
          });
          return (((($5.first)[0] === "$Cons") && ((($5.first)[1])[0] === "$Token"))
            ? ((() => {
              const $start = (($5.first)[1])[1];
              const $end = (($5.first)[1])[2];
              const $rest = ($5.first)[2];
              return (u0Compiler$Error$res)($env.errorModule, (c0Compiler$Pos$P)($start, $end), (c0Core$Cons)("I got stuck parsing here. =(", c0Core$Nil));
            }))()
            : (((($5.first)[0] === "$Nil") && ((($5.second)[0] === "$Cons") && ((($5.second)[1])[0] === "$Token")))
              ? ((() => {
                const $start = (($5.second)[1])[1];
                const $end0 = (($5.second)[1])[2];
                const $rest = ($5.second)[2];
                const $end = (c0List$for)($end0, $rest, (($7, _1) => {
                  const $endX = ($7)[2];
                  return $endX;
                }));
                return (u0Compiler$Error$res)($env.errorModule, (c0Compiler$Pos$P)($start, $end), (c0Core$Cons)("I got to the end of the statement and I can't make sense of it. =(", c0Core$Nil));
              }))()
              : (((($5.first)[0] === "$Nil") && (($5.second)[0] === "$Nil"))
                ? (c0Result$Ok)(c0Core$Nil)
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 896:12', (sp_toHuman)($5)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 880:4', (sp_toHuman)($outcome)))));
});

const u0Compiler$Parser$textToFormattableModule = (($env) => {
  const $tokensResult = (u0Compiler$Lexer$lexer)($env.keepComments, $env.errorModule);
  return ((c0Result$onOk)((($tokenChunks) => {
    const $3 = (c0List$for)(({
      first: c0Core$Nil,
      second: c0Core$Nil,
    }), $tokenChunks, (($tokens, $4) => {
      const $es = $4.first;
      const $revStats = $4.second;
      const $6 = (u0Compiler$Parser$parse)($env, $tokens, $revStats);
      return ((($6)[0] === "$Ok")
        ? ((() => {
          const $newReversedStatements = ($6)[1];
          return ({
            first: $es,
            second: $newReversedStatements,
          });
        }))()
        : ((($6)[0] === "$Err")
          ? ((() => {
            const $e = ($6)[1];
            return ({
              first: (c0Core$Cons)($e, $es),
              second: $revStats,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 922:12', (sp_toHuman)($6))));
    }));
    const $reversedStatements = $3.second;
    const $errors = $3.first;
    return ((sp_not_equal)($errors, c0Core$Nil)
      ? (c0Result$Err)((u0Compiler$Error$Nested)($errors))
      : (c0Result$Ok)((c0List$reverse)($reversedStatements)));
  })))($tokensResult);
});

const u0Compiler$MakeCanonical$textToCanonicalModule = (($stripLocations, $ro) => {
  return ((c0Result$onOk)((($faModule) => {
    return (u0Compiler$MakeCanonical$translateModule)($ro, $faModule);
  })))((u0Compiler$Parser$textToFormattableModule)(({
    errorModule: $ro.errorModule,
    keepComments: false,
    stripLocations: $stripLocations,
  })));
});

const u0Compiler$TestHelpers$errorModule = (($content) => {
  return ({
    content: $content,
    fsPath: "<Test>",
  });
});

const u0Compiler$TestHelpers$importsPath = (c0Compiler$Meta$ImportsPath)(c0Compiler$Meta$User, "<testImportsPath/>");

const u0DefaultImports$mod = (($path, $globals) => {
  return ({
    globals: $globals,
    path: $path,
    visibleAs: $path,
  });
});

const u0DefaultImports$defaultImportsFile = ({
  libraries: (c0Core$Cons)(({
    modules: (c0Core$Cons)((u0DefaultImports$mod)("Core", (c0Core$Cons)("None", (c0Core$Cons)("Bool", (c0Core$Cons)("Text", (c0Core$Cons)("Number", (c0Core$Cons)("'none", (c0Core$Cons)("'true", (c0Core$Cons)("'false", (c0Core$Cons)("mut", c0Core$Nil))))))))), (c0Core$Cons)((u0DefaultImports$mod)("Basics", (c0Core$Cons)("Int", (c0Core$Cons)("assert", (c0Core$Cons)("clamp", (c0Core$Cons)("identity", (c0Core$Cons)("modBy", (c0Core$Cons)("min", (c0Core$Cons)("max", (c0Core$Cons)("cloneImm", (c0Core$Cons)("cloneUni", c0Core$Nil)))))))))), (c0Core$Cons)((u0DefaultImports$mod)("Text", c0Core$Nil), (c0Core$Cons)((u0DefaultImports$mod)("Tuple", c0Core$Nil), (c0Core$Cons)((u0DefaultImports$mod)("Debug", (c0Core$Cons)("log", (c0Core$Cons)("todo", c0Core$Nil))), (c0Core$Cons)((u0DefaultImports$mod)("Self", c0Core$Nil), (c0Core$Cons)((u0DefaultImports$mod)("List", c0Core$Nil), (c0Core$Cons)((u0DefaultImports$mod)("Dict", (c0Core$Cons)("Dict", c0Core$Nil)), (c0Core$Cons)((u0DefaultImports$mod)("Array", (c0Core$Cons)("Array", c0Core$Nil)), (c0Core$Cons)((u0DefaultImports$mod)("Hash", (c0Core$Cons)("Hash", c0Core$Nil)), (c0Core$Cons)((u0DefaultImports$mod)("Set", (c0Core$Cons)("Set", c0Core$Nil)), (c0Core$Cons)((u0DefaultImports$mod)("Maybe", (c0Core$Cons)("Maybe", (c0Core$Cons)("'just", (c0Core$Cons)("'nothing", c0Core$Nil)))), (c0Core$Cons)((u0DefaultImports$mod)("Result", (c0Core$Cons)("Result", (c0Core$Cons)("'ok", (c0Core$Cons)("'err", c0Core$Nil)))), c0Core$Nil))))))))))))),
    source: "core",
  }), c0Core$Nil),
  sourceDirs: (c0Core$Cons)(({
    modules: c0Core$Nil,
    path: ".",
  }), (c0Core$Cons)(({
    modules: c0Core$Nil,
    path: "src/",
  }), c0Core$Nil)),
});

const u0ImportsFile$insertModules = (($getModulePathToLocation, $errors, $modules, $imports) => {
  return ([
    (c0List$for)($imports, $modules, (($module, $imp) => {
      const $location = ($getModulePathToLocation)($module.path);
      const $moduleAliasToLocation = (c0Dict$insert)($module.visibleAs, $location, $imp.moduleAliasToLocation);
      const $modulePathToLocation = (c0Dict$insert)($module.path, $location, $imp.modulePathToLocation);
      const $globalNameToLocation = (c0List$for)($imp.globalNameToLocation, $module.globals, (($globalName, $dict) => {
        return (c0Dict$insert)($globalName, $location, $dict);
      }));
      return ({
        globalNameToLocation: $globalNameToLocation,
        moduleAliasToLocation: $moduleAliasToLocation,
        modulePathToLocation: $modulePathToLocation,
      });
    })),
    $errors,
  ]);
});

const u0ImportsFile$parseLibrarySource = (($sourceAsText) => {
  const $2 = (text_split)(":", $sourceAsText);
  return (((($2)[0] === "$Cons") && (("core" === ($2)[1]) && ((($2)[2])[0] === "$Nil")))
    ? (c0Result$Ok)(u0ImportsFile$Core)
    : (((($2)[0] === "$Cons") && (("local" === ($2)[1]) && (((($2)[2])[0] === "$Cons") && (((($2)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $path = (($2)[2])[1];
        return (c0Result$Ok)((u0ImportsFile$Local)($path));
      }))()
      : (((($2)[0] === "$Cons") && ((($2)[2])[0] === "$Cons"))
        ? ((() => {
          const $protocol = ($2)[1];
          const $address = (($2)[2])[1];
          const $more = (($2)[2])[2];
          return (c0Result$Ok)((u0ImportsFile$Installed)(({
            address: (c0Text$join)(":", (c0Core$Cons)($address, $more)),
            protocol: $protocol,
          })));
        }))()
        : (true
          ? (c0Result$Err)(("invalid library source: " + $sourceAsText))
          : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 46:4', (sp_toHuman)($2))))));
});

const u0ImportsFile$insertLibrary = (($pars, $errors, $library, $imports) => {
  const $5 = (u0ImportsFile$parseLibrarySource)($library.source);
  return ([
    ((($5)[0] === "$Err")
      ? ((() => {
        const $msg = ($5)[1];
        ((__re__ = (array_push)($errors, $msg)), ($errors = (__re__)[1]), (__re__)[0]);
        return $imports;
      }))()
      : ((($5)[0] === "$Ok")
        ? ((() => {
          const $librarySource = ($5)[1];
          return ((($0) => {
            return ((__re__ = (u0ImportsFile$insertModules)($0, $errors, $library.modules, $imports)), ($errors = (__re__)[1]), (__re__)[0]);
          }))(((($librarySource)[0] === "$Core")
            ? (($0) => {
              return (c0Compiler$Meta$LocationLibrary)(u0Compiler$CoreDefs$importsPath, $0);
            })
            : ((($librarySource)[0] === "$Local")
              ? ((() => {
                const $libraryDir = ($librarySource)[1];
                const $6 = $pars.importsPath;
                const $currentImportsDir = ($6)[2];
                const $rootDirectory = ($6)[1];
                const $importsDir = ($pars.joinPath)((c0Core$Cons)($currentImportsDir, (c0Core$Cons)($libraryDir, c0Core$Nil)));
                return (($0) => {
                  return (c0Compiler$Meta$LocationLibrary)((c0Compiler$Meta$ImportsPath)($rootDirectory, $importsDir), $0);
                });
              }))()
              : ((($librarySource)[0] === "$Installed")
                ? ((() => {
                  const $address = ($librarySource)[1].address;
                  const $protocol = ($librarySource)[1].protocol;
                  const $importsDir = ($pars.joinPath)((c0Core$Cons)($protocol, (c0Core$Cons)($address, c0Core$Nil)));
                  return (($0) => {
                    return (c0Compiler$Meta$LocationLibrary)((c0Compiler$Meta$ImportsPath)(c0Compiler$Meta$Installed, $importsDir), $0);
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 107:12', (sp_toHuman)($librarySource))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 99:4', (sp_toHuman)($5)))),
    $errors,
  ]);
});

const u0ImportsFile$insertSourceDir = (($pars, $errors, $sourceDir, $imports) => {
  const $modulePathToLocation = (($0) => {
    return (c0Compiler$Meta$LocationSourceDir)(((($0) => {
      return (c0Compiler$Meta$UMR)($pars.importsPath, $sourceDir.path, $0);
    }))($0));
  });
  return ([
    ((__re__ = (u0ImportsFile$insertModules)($modulePathToLocation, $errors, $sourceDir.modules, $imports)), ($errors = (__re__)[1]), (__re__)[0]),
    $errors,
  ]);
});

const u0ImportsFile$toImports = (($pars, $importsFile) => {
  let $errors = (array_fromList)(c0Core$Nil);
  const $meta = ((($0) => {
    return (c0List$for)($0, $importsFile.sourceDirs, (($0, $1) => {
      return ((__re__ = (u0ImportsFile$insertSourceDir)($pars, $errors, $0, $1)), ($errors = (__re__)[1]), (__re__)[0]);
    }));
  }))(((($0) => {
    return (c0List$for)($0, $importsFile.libraries, (($0, $1) => {
      return ((__re__ = (u0ImportsFile$insertLibrary)($pars, $errors, $0, $1)), ($errors = (__re__)[1]), (__re__)[0]);
    }));
  }))(c0Compiler$Meta$initImports));
  const $errs = ((($0) => {
    return (c0List$map)((($msg) => {
      return (u0Compiler$Error$Raw)((c0Core$Cons)($msg, c0Core$Nil));
    }), $0);
  }))(((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]));
  return ((sp_equal)($errs, c0Core$Nil)
    ? (c0Result$Ok)($meta)
    : (c0Result$Err)((u0Compiler$Error$Nested)($errs)));
});

const u0Compiler$TestHelpers$imports = ((() => {
  const $pars = ({
    importsPath: u0Compiler$TestHelpers$importsPath,
    joinPath: path_join,
  });
  const $1 = (u0ImportsFile$toImports)($pars, u0DefaultImports$defaultImportsFile);
  return ((($1)[0] === "$Err")
    ? ((() => {
      const $e = ($1)[1];
      (sp_log)("Error in DefaultImports.sp: ", $e);
      return (sp_todo)("error loading DefaultImports.sp");
    }))()
    : ((($1)[0] === "$Ok")
      ? ((() => {
        const $m = ($1)[1];
        return $m;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 68:4', (sp_toHuman)($1))));
}))();

const u0Compiler$TestHelpers$moduleUmr = (c0Compiler$Meta$UMR)(u0Compiler$TestHelpers$importsPath, "<testSourceDir/>", "<TestModulePath>");

const u0Compiler$Error$breakDownText = (($text) => {
  const $formatSnippet = (($index, $snippet) => {
    return ((sp_equal)((basics_modBy)(2, $index), 0)
      ? (u0Compiler$Error$FormattedText_Default)($snippet)
      : ((() => {
        const $4 = (text_split)(u0Compiler$Error$formatSuffix, $snippet);
        return (((($4)[0] === "$Cons") && (("emphasys" === ($4)[1]) && (((($4)[2])[0] === "$Cons") && (((($4)[2])[2])[0] === "$Nil"))))
          ? ((() => {
            const $s = (($4)[2])[1];
            return (u0Compiler$Error$FormattedText_Emphasys)($s);
          }))()
          : (((($4)[0] === "$Cons") && (("warning" === ($4)[1]) && (((($4)[2])[0] === "$Cons") && (((($4)[2])[2])[0] === "$Nil"))))
            ? ((() => {
              const $s = (($4)[2])[1];
              return (u0Compiler$Error$FormattedText_Warning)($s);
            }))()
            : (((($4)[0] === "$Cons") && (("decoration" === ($4)[1]) && (((($4)[2])[0] === "$Cons") && (((($4)[2])[2])[0] === "$Nil"))))
              ? ((() => {
                const $s = (($4)[2])[1];
                return (u0Compiler$Error$FormattedText_Decoration)($s);
              }))()
              : (true
                ? (u0Compiler$Error$FormattedText_Default)($snippet)
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 68:12', (sp_toHuman)($4))))));
      }))());
  });
  return ((($0) => {
    return (c0List$indexedMap)($formatSnippet, $0);
  }))(((($0) => {
    return (text_split)(u0Compiler$Error$formatSeparator, $0);
  }))($text));
});

const u0Compiler$Error$rawToText = (($desc) => {
  const $description = ((($0) => {
    return (c0Text$join)("\n", $0);
  }))(((($0) => {
    return (c0List$map)((($s) => {
      return ("  " + $s);
    }), $0);
  }))(((($0) => {
    return (c0List$concatMap)((($0) => {
      return (text_split)("\n", $0);
    }), $0);
  }))($desc)));
  return (u0Compiler$Error$breakDownText)(((($0) => {
    return (c0Text$join)("\n", $0);
  }))((c0Core$Cons)("", (c0Core$Cons)("", (c0Core$Cons)($description, (c0Core$Cons)("", c0Core$Nil))))));
});

const u0Compiler$Error$deco = (($0) => {
  return (u0Compiler$Error$formatWrap)("decoration", $0);
});

const u0Compiler$Error$simpleToText = (($mod, $pos, $desc) => {
  const $4 = (u0Compiler$Error$posToHuman)($mod, $pos);
  const $location = $4.location;
  const $block = $4.block;
  const $description = ((($0) => {
    return (c0Text$join)("\n", $0);
  }))(((($0) => {
    return (c0List$map)((($s) => {
      return ("  " + $s);
    }), $0);
  }))(((($0) => {
    return (c0List$concatMap)((($0) => {
      return (text_split)("\n", $0);
    }), $0);
  }))((c0Core$Cons)($block, $desc))));
  return (u0Compiler$Error$breakDownText)(((($0) => {
    return (c0Text$join)("\n", $0);
  }))((c0Core$Cons)("", (c0Core$Cons)("", (c0Core$Cons)((u0Compiler$Error$deco)((c0Text$padRight)(50, "-", ($location + " "))), (c0Core$Cons)("", (c0Core$Cons)($description, (c0Core$Cons)("", c0Core$Nil))))))));
});

const u0Compiler$Error$flatten = (($e, $accum) => {
  return ((($e)[0] === "$Simple")
    ? ((() => {
      const $mod = ($e)[1];
      const $pos = ($e)[2];
      const $desc = ($e)[3];
      return (c0List$concat)((c0Core$Cons)($accum, (c0Core$Cons)((u0Compiler$Error$simpleToText)($mod, $pos, $desc), c0Core$Nil)));
    }))()
    : ((($e)[0] === "$Raw")
      ? ((() => {
        const $desc = ($e)[1];
        return (c0List$concat)((c0Core$Cons)($accum, (c0Core$Cons)((u0Compiler$Error$rawToText)($desc), c0Core$Nil)));
      }))()
      : ((($e)[0] === "$Nested")
        ? ((() => {
          const $ls = ($e)[1];
          return (c0List$for)($accum, $ls, u0Compiler$Error$flatten);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 39:4', (sp_toHuman)($e)))));
});

const u0Compiler$Error$toFormattedText = (($0) => {
  return (u0Compiler$Error$flatten)($0, c0Core$Nil);
});

const u0Compiler$TestHelpers$formattedToStrippedText = (($formatted) => {
  const $strip = (($fmt) => {
    return ((($fmt)[0] === "$FormattedText_Default")
      ? ((() => {
        const $t = ($fmt)[1];
        return $t;
      }))()
      : ((($fmt)[0] === "$FormattedText_Emphasys")
        ? ((() => {
          const $t = ($fmt)[1];
          return $t;
        }))()
        : ((($fmt)[0] === "$FormattedText_Warning")
          ? ((() => {
            const $t = ($fmt)[1];
            return $t;
          }))()
          : ((($fmt)[0] === "$FormattedText_Decoration")
            ? ((() => {
              const $t = ($fmt)[1];
              return $t;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 37:8', (sp_toHuman)($fmt))))));
  });
  return ((($0) => {
    return (c0Text$join)("", $0);
  }))(((($0) => {
    return (c0List$map)($strip, $0);
  }))($formatted));
});

const u0Compiler$TestHelpers$errorToStrippedText = (($0) => {
  return (u0Compiler$TestHelpers$formattedToStrippedText)((u0Compiler$Error$toFormattedText)($0));
});

const u0Compiler$TestHelpers$resErrorToStrippedText = (($0) => {
  return (c0Result$mapError)(u0Compiler$TestHelpers$errorToStrippedText, $0);
});

const u0Compiler$TestHelpers$exports = ((() => {
  const $isOpen = false;
  return ((($0) => {
    return (c0Dict$ofOne)("Core", $0);
  }))((c0Dict$fromList)((c0Core$Cons)(({
    first: "None",
    second: ({
      isOpen: true,
      usr: u0Compiler$CoreDefs$noneTypeUsr,
    }),
  }), (c0Core$Cons)(({
    first: "'none",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$noneConsUsr,
    }),
  }), (c0Core$Cons)(({
    first: "Bool",
    second: ({
      isOpen: true,
      usr: u0Compiler$CoreDefs$boolUsr,
    }),
  }), (c0Core$Cons)(({
    first: "'true",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$trueUsr,
    }),
  }), (c0Core$Cons)(({
    first: "'false",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$falseUsr,
    }),
  }), (c0Core$Cons)(({
    first: "List",
    second: ({
      isOpen: true,
      usr: u0Compiler$CoreDefs$listUsr,
    }),
  }), (c0Core$Cons)(({
    first: "'nil",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$nilUsr,
    }),
  }), (c0Core$Cons)(({
    first: "'cons",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$consUsr,
    }),
  }), (c0Core$Cons)(({
    first: "Text",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$textUsr,
    }),
  }), (c0Core$Cons)(({
    first: "Number",
    second: ({
      isOpen: $isOpen,
      usr: u0Compiler$CoreDefs$numberUsr,
    }),
  }), c0Core$Nil))))))))))));
}))();

const u0Compiler$TestHelpers$loadExports = (($ip) => {
  return (((($ip)[0] === "$ImportsPath") && (((($ip)[1])[0] === "$Core") && ("" === ($ip)[2])))
    ? (c0Result$Ok)(u0Compiler$TestHelpers$exports)
    : (true
      ? (c0Result$Err)((u0Compiler$Error$Raw)((c0Core$Cons)("TestHelpers: trying to load an unknown export:", (c0Core$Cons)("", (c0Core$Cons)((sp_toHuman)($ip), (c0Core$Cons)("", c0Core$Nil))))))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 108:4', (sp_toHuman)($ip))));
});

const u0Compiler$TestHelpers$resolvePars = ({
  currentImports: u0Compiler$TestHelpers$imports,
  currentModule: u0Compiler$TestHelpers$moduleUmr,
  loadExports: u0Compiler$TestHelpers$loadExports,
  makeError: (($0) => {
    return (u0Compiler$Error$Raw)($0);
  }),
});

const u0Compiler$TestHelpers$caFunction = (($from, $to) => {
  return (c0Compiler$CanonicalAst$TypeFn)(c0Compiler$Pos$T, (c0List$map)((($t) => {
    return (c0Compiler$CanonicalAst$ParSp)((c0Compiler$Ast$toImm)($t));
  }), $from), (c0Compiler$Ast$toImm)($to));
});

const u0Compiler$TestHelpers$caNumber = (c0Compiler$CanonicalAst$TypeNamed)(c0Compiler$Pos$T, (u0Compiler$CoreDefs$usr)("Number"), c0Core$Nil);

const u0Compiler$TypeCheck_Test$add = ({
  directDeps: c0Dict$empty,
  maybeAnnotation: (c0Maybe$Just)(({
    raw: (u0Compiler$TestHelpers$caFunction)((c0Core$Cons)(u0Compiler$TestHelpers$caNumber, (c0Core$Cons)(u0Compiler$TestHelpers$caNumber, c0Core$Nil)), u0Compiler$TestHelpers$caNumber),
    tyvars: c0Dict$empty,
    univars: c0Dict$empty,
  })),
  maybeBody: c0Maybe$Nothing,
  name: "add",
  namePos: c0Compiler$Pos$T,
});

const u0Compiler$TestHelpers$caNone = (c0Compiler$CanonicalAst$TypeNamed)(c0Compiler$Pos$T, (u0Compiler$CoreDefs$usr)("None"), c0Core$Nil);

const u0Compiler$TypeCheck_Test$reset = ({
  directDeps: c0Dict$empty,
  maybeAnnotation: (c0Maybe$Just)(({
    raw: (u0Compiler$TestHelpers$caFunction)((c0Core$Cons)(u0Compiler$TestHelpers$caNumber, c0Core$Nil), u0Compiler$TestHelpers$caNone),
    tyvars: c0Dict$empty,
    univars: c0Dict$empty,
  })),
  maybeBody: c0Maybe$Nothing,
  name: "reset",
  namePos: c0Compiler$Pos$T,
});

const u0Compiler$TypeCheck_Test$infer = (($targetName) => {
  return (($code) => {
    const $params = ({
      errorModule: (u0Compiler$TestHelpers$errorModule)($code),
      resolvePars: (($pos) => {
        return u0Compiler$TestHelpers$resolvePars;
      }),
      umr: u0Compiler$TestHelpers$moduleUmr,
    });
    return ((c0Result$onOk)((($caModuleRaw) => {
      const $caModule = ((() => {
        const $0 = $caModuleRaw;
        return (Object.assign)({}, $0, ({
          valueDefs: ((($0) => {
            return (c0Dict$insert)("reset", u0Compiler$TypeCheck_Test$reset, $0);
          }))(((($0) => {
            return (c0Dict$insert)("add", u0Compiler$TypeCheck_Test$add, $0);
          }))($0.valueDefs)),
        }));
      }))();
      const $keysToUsrs = (($0) => {
        return ((($0) => {
          return (c0List$map)((($0) => {
            return (c0Compiler$Meta$USR)(u0Compiler$TestHelpers$moduleUmr, $0);
          }), $0);
        }))((c0Dict$keys)($0));
      });
      const $requiredUsrs = (c0List$concat)((c0Core$Cons)(($keysToUsrs)($caModule.valueDefs), (c0Core$Cons)(($keysToUsrs)($caModule.constructorDefs), (c0Core$Cons)(($keysToUsrs)($caModule.variantTypeDefs), (c0Core$Cons)(($keysToUsrs)($caModule.aliasDefs), c0Core$Nil)))));
      const $loadCaModule = (($umr) => {
        return ((sp_equal)($umr, u0Compiler$TestHelpers$moduleUmr)
          ? (c0Result$Ok)($caModule)
          : ((sp_equal)($umr, u0Compiler$CoreDefs$umr)
            ? (c0Result$Ok)(u0Compiler$CoreDefs$coreModule)
            : (c0Result$Err)((u0Compiler$Error$Raw)((c0Core$Cons)(("no module " + (sp_toHuman)($umr)), c0Core$Nil)))));
      });
      return ((c0Result$onOk)((($4) => {
        const $constructors = $4.constructors;
        const $rootValues = $4.rootValues;
        return ((c0Result$onOk)((($def) => {
          let $hash = (hash_fromList)(c0Core$Nil);
          const $ft = (c0Dict$for)(c0Dict$empty, $def.freeTyvars, (($id, $tc, $d) => {
            return (c0Dict$insert)(((__re__ = (c0Compiler$TypedAst$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]), $tc, $d);
          }));
          const $type = ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $def.type)), ($hash = (__re__)[1]), (__re__)[0]);
          return (c0Result$Ok)(({
            freeTyvars: $ft,
            type: $type,
          }));
        })))(((() => {
          const $5 = (c0List$find)((($rv) => {
            return (sp_equal)($rv.usr, (c0Compiler$Meta$USR)(u0Compiler$TestHelpers$moduleUmr, $targetName));
          }), $rootValues);
          return ((($5)[0] === "$Nothing")
            ? (c0Result$Err)("find fail")
            : ((($5)[0] === "$Just")
              ? ((() => {
                const $def = ($5)[1];
                return (c0Result$Ok)($def);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck_Test.sp 165:4', (sp_toHuman)($5))));
        }))());
      })))((u0Compiler$TestHelpers$resErrorToStrippedText)((u0Compiler$LazyBuild$build)(({
        loadCaModule: $loadCaModule,
        projectImports: u0Compiler$TestHelpers$imports,
        requiredUsrs: $requiredUsrs,
      }))));
    })))((u0Compiler$TestHelpers$resErrorToStrippedText)(((($0) => {
      return (u0Compiler$MakeCanonical$textToCanonicalModule)(true, $0);
    }))($params)));
  });
});

const u3Uniqueness$infer = u0Compiler$TypeCheck_Test$infer;

const u3Uniqueness$howDoesItLookLike = (i1Test$Group)("How does mutability look like?", (c0Core$Cons)((u3Uniqueness$codeTest)("Example: maintaining mutable state", "someFunction = this_is_sp_native\n\naverage as fn [Number]: Number =\n    fn numbers:\n\n    # Unique values can be changed in place, ie, \"mutated\"\n    !total as Number =\n        0\n\n    !count as Number =\n        0\n\n    someFunction numbers fn number:\n        @total += number\n        @count += 1\n\n    # In Squarepants division by 0 yields 0\n    total / count", (u3Uniqueness$infer)("average"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("SKIP (needs IO in the test env) Example: File IO", "logToFile as fn @IO, Text: Result IO.Error None =\n    fn @io, content:\n\n    IO.openFile @io IO.Append \"blah.log\"\n    >> isOk fn @fileDescriptor:\n\n    IO.writeFile @io content @fileDescriptor\n\n    # fileDescriptor is automatically closed here", (u3Uniqueness$infer)("logToFile"), i1Test$isOk), c0Core$Nil)));

const u3Uniqueness$mutation = (i1Test$Group)("Mutation", (c0Core$Cons)((i1Test$Group)("Uniques can be mutated in place", (c0Core$Cons)((u3Uniqueness$codeTest)("Mutation does NOT consume the unique", "scope =\n    !x = 1\n    @x += 1\n    @x += 1", (u3Uniqueness$infer)("scope"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Recycling requires the unique not to be spent", "someFunction = this_is_sp_native\n\nscope =\n    !x = 1\n    someFunction x\n    @x += 1", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("used again here", c0Core$Nil))), c0Core$Nil))), (c0Core$Cons)((i1Test$Group)("A function can be defined to mutate its arguments", (c0Core$Cons)((u3Uniqueness$codeTest)("base", "funz as fn @Number: None =\n    fn @a:\n    @a += 3\n\nscope =\n    !x = 0\n    funz @x\n    funz @x", (u3Uniqueness$infer)("scope"), i1Test$isOk), c0Core$Nil)), (c0Core$Cons)((i1Test$Group)("Calling a function that recycles a unique variable temporarily consumes the variable.", (c0Core$Cons)((u3Uniqueness$codeTest)("base", "someFunction = this_is_sp_native\nscope =\n    !x = 0\n    someFunction @x @x", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("twice", c0Core$Nil))), c0Core$Nil)), c0Core$Nil))));

const u3Uniqueness$parentScope = (i1Test$Group)("Recycling a variable in the parent scope", (c0Core$Cons)((i1Test$Group)("A function that recycles any unique belonging to an ancestor scope \"requires\" that unique.", (c0Core$Cons)((u3Uniqueness$codeTest)("LetIns cannot return functions with requirements", "scope =\n    !x =\n        1\n\n    f =\n        fn n:\n        @x += n\n        'none\n\n    f", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("x", (c0Core$Cons)("from outside", c0Core$Nil)))), (c0Core$Cons)((u3Uniqueness$codeTest)("Functions cannot return functions with UNIQUE requirements", "f =\n    fn !x:\n    fn n:\n    @x += n\n    'none", (u3Uniqueness$infer)("f"), (i1Test$errorContains)((c0Core$Cons)("x", (c0Core$Cons)("from outside", c0Core$Nil)))), (c0Core$Cons)((u3Uniqueness$codeTest)("Functions cannot return functions with RECYCLED requirements", "f =\n    fn @x:\n    fn n:\n    @x += n\n    'none", (u3Uniqueness$infer)("f"), (i1Test$errorContains)((c0Core$Cons)("x", (c0Core$Cons)("from outside", c0Core$Nil)))), (c0Core$Cons)((u3Uniqueness$codeTest)("The Array Test", "var Array_ a = 'meh\n\narray_push as fn a, @Array_ a: None =\n    this_is_sp_native\n\naddFunctions as fn @Array_ (fn Number: Number): None =\n    fn @functions:\n\n    !x =\n        1\n\n    f as fn Number: Number =\n        fn n:\n        @x += 1\n        n\n\n    array_push f @functions\n    'none", (u3Uniqueness$infer)("addFunctions"), (i1Test$errorContains)((c0Core$Cons)("x", (c0Core$Cons)("outside", c0Core$Nil)))), c0Core$Nil))))), c0Core$Nil));

const u3Uniqueness$polymorphism = (i1Test$Group)("Polymorphism", (c0Core$Cons)((u3Uniqueness$codeTest)("Basic syntax", "fun as fn (fn 1?a: 2?b), 1?a: 2?b =\n    fn f, 1?a:\n\n    f a", (u3Uniqueness$infer)("fun"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("A function that returns a Uni can be used in place of a function that returns an Imm", "meh as fn (fn None: Number): Number =\n    fn f: f 'none\n\nblah = meh (fn 'none: 1)", (u3Uniqueness$infer)("blah"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("A function that returns an Imm CANNOT be used in place of a function that returns an Uni", "meh as fn (fn None: !Number): !Number =\n    fn f: f 'none\n\nx as Number = 1\n\nblah = meh (fn 'none: x)", (u3Uniqueness$infer)("blah"), (i1Test$errorContains)((c0Core$Cons)("return", (c0Core$Cons)("uniqueness", c0Core$Nil)))), (c0Core$Cons)((u3Uniqueness$codeTest)("a Uni, b Uni", "var Re error payload = 'er error, 'okk payload\nisOkk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = this_is_sp_native\n\nscope =\n    !v = isOkk (fn !a: 'okk 0) ('okk 0)", (u3Uniqueness$infer)("scope"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("a Uni, b Imm", "var Result_ error payload = 'err_ error, 'ok_ payload\nisOk_ as fn (fn 1?a: 2?Result_ error b), 1?Result_ error a: 2?Result_ error b = this_is_sp_native\nimmB as Number = 1\n\nv = isOk_ (fn !a: 'ok_ immB) ('ok_ 0)", (u3Uniqueness$infer)("v"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("No annotation", "na = fn 0?x: x", (u3Uniqueness$infer)("na"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (c0Dict$ofOne)(1, ({
    maybeAnnotated: c0Maybe$Nothing,
  })),
  type: (c0Compiler$TypedAst$TypeFn)((c0Core$Cons)((c0Compiler$TypedAst$ParSp)(({
    raw: (c0Compiler$TypedAst$TypeVar)(1),
    uni: (c0Compiler$Ast$Depends)(0),
  })), c0Core$Nil), ({
    raw: (c0Compiler$TypedAst$TypeVar)(1),
    uni: (c0Compiler$Ast$Depends)(0),
  })),
}))), (c0Core$Cons)((u3Uniqueness$codeTest)("Generalization", "na as fn 1?a: 1?a =\n    fn 1?x: x\n\nscope as None =\n    !uni = na 0\n\nnone as None =\n    na scope", (u3Uniqueness$infer)("na"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("[rec] variable without any uniqueness flag should be imm", "scope =\n    num = 1\n\n    x as Number = num + 1\n    y as Number = num + 2", (u3Uniqueness$infer)("scope"), i1Test$isOk), c0Core$Nil)))))))));

const u3Uniqueness$records = (i1Test$Group)("Records", (c0Core$Cons)((i1Test$Group)("The attribute of a mutable record can be accessed as a mutable:", (c0Core$Cons)((u3Uniqueness$codeTest)("Simple case", "scope =\n    !record = { x = 0, y = 0 }\n    @record.x += 3", (u3Uniqueness$infer)("scope"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Reject double reference", "someFunction =\n    this_is_sp_native\n\nscope =\n    !record = { x = 0, y = 0 }\n    someFunction @record.x @record.y", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("same unique twice in the same function call", c0Core$Nil))), c0Core$Nil))), c0Core$Nil));

const u0Compiler$TestHelpers$moduleUsr = (($0) => {
  return (c0Compiler$Meta$USR)(u0Compiler$TestHelpers$moduleUmr, $0);
});

const u0Compiler$TestHelpers$taNumber = (c0Compiler$TypedAst$TypeExact)((u0Compiler$CoreDefs$usr)("Number"), c0Core$Nil);

const u3Uniqueness$unions = (i1Test$Group)("Unions", (c0Core$Cons)((u3Uniqueness$codeTest)("Uniques inside immutables are converted to immutables", "var Z a = 'z a\nx = 'z 0", (u3Uniqueness$infer)("x"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: (c0Compiler$TypedAst$TypeExact)((u0Compiler$TestHelpers$moduleUsr)("Z"), (c0Core$Cons)(u0Compiler$TestHelpers$taNumber, c0Core$Nil)),
}))), (c0Core$Cons)((u3Uniqueness$codeTest)("[reg] Lists of immutables", "i as Number = 1\nx = [ i, i ]", (u3Uniqueness$infer)("x"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("[reg] solveOneEquality can receive switched given/required when evaluating a cast?", "z as [fn None: None] = (fn 'none: 'none) :: []", (u3Uniqueness$infer)("z"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("LetIn: Unpack immutable to immutable", "var Z a = 'z a\nscope =\n    x = 'z 0\n    ('z y) = x", (u3Uniqueness$infer)("scope"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("LetIn: Unpack unique to immutable", "var Z a = 'z a\nscope =\n    !x = 'z 0\n    ('z y) = x", (u3Uniqueness$infer)("scope"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("LetIn: Unpack unique to unique", "var Z a = 'z a\nscope =\n    !x = 'z 0\n    !('z y) = x\n    @y += 1", (u3Uniqueness$infer)("scope"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("LetIn: Unpack immutable to unique", "var Z a = 'z a\nscope =\n    x = 'z 0\n    !('z y) = x", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("y", (c0Core$Cons)("Unique", c0Core$Nil)))), (c0Core$Cons)((u3Uniqueness$codeTest)("Fn: Unpack immutable to immutable", "var Z a = 'z a\nf as fn Z a: Z a =\n     fn 'z a: 'z a", (u3Uniqueness$infer)("f"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Fn: Unpack unique to immutable", "var Z a = 'z a\nf as fn !(Z a): Z a =\n     fn !('z a): 'z a", (u3Uniqueness$infer)("f"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Fn: Unpack unique to unique", "var Z a = 'z a\nf as fn !(Z a): !(Z a) =\n     fn !('z a): 'z a", (u3Uniqueness$infer)("f"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Fn: Unpack immutable to unique", "var Z a = 'z a\nf as fn Z a: !(Z a) =\n     fn 'z a: 'z a", (u3Uniqueness$infer)("f"), (i1Test$errorContains)((c0Core$Cons)("Unique", c0Core$Nil))), c0Core$Nil))))))))))));

const u3Uniqueness$uniquenessTyping = (i1Test$Group)("Uniqueness Typing", (c0Core$Cons)((i1Test$Group)("All literal expressions allow uniqueness", (c0Core$Cons)((u3Uniqueness$codeTest)("failure", "f as fn Number: !Number = fn x: x", (u3Uniqueness$infer)("f"), (i1Test$errorContains)((c0Core$Cons)("ErrorUniquenessDoesNotMatch", c0Core$Nil))), (c0Core$Cons)((u3Uniqueness$codeTest)("Number", "f as fn a: !Number = fn _: 1", (u3Uniqueness$infer)("f"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Text", "f as fn a: !Text = fn _: \"meh\"", (u3Uniqueness$infer)("f"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Record", "f as fn a: !{} = fn _: {}", (u3Uniqueness$infer)("f"), i1Test$isOk), (c0Core$Cons)((u3Uniqueness$codeTest)("Constructor 1", "f as fn a: !Bool = fn _: 'true", (u3Uniqueness$infer)("f"), i1Test$isOk), c0Core$Nil)))))), (c0Core$Cons)((i1Test$Group)("Conversions", (c0Core$Cons)((u3Uniqueness$codeTest)("Immutables cannot be used in place of uniques 2", "scope =\n    x = 1\n    @x += 1", (u3Uniqueness$infer)("a"), (i1Test$errorContains)((c0Core$Cons)("ErrorShouldBeUnique", c0Core$Nil))), (c0Core$Cons)((u3Uniqueness$codeTest)("Uniques can be implicitly transformed in immutables", "a as Number = 1", (u3Uniqueness$infer)("a"), i1Test$isOk), c0Core$Nil))), (c0Core$Cons)((i1Test$Group)("A variable with mutable type must be explicitly declared as mutable with `!`", (c0Core$Cons)((u3Uniqueness$codeTest)("1", "z =\n    !a as Number = 1", (u3Uniqueness$infer)("z"), i1Test$isOk), c0Core$Nil)), (c0Core$Cons)((i1Test$Group)("Referencing a mutable variable \"spends\" it", (c0Core$Cons)((u3Uniqueness$codeTest)("base", "scope =\n    !x =\n        1\n\n    !y =\n        # The first time we do it it works!\n        x\n\n    !z =\n        # But here `x` is now spent, so we get a compiler error!\n        x", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("used already here", c0Core$Nil))), (c0Core$Cons)((u3Uniqueness$codeTest)("tuple", "scope =\n    !x =\n        1\n\n    !y =\n        x & x", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("used already here", c0Core$Nil))), c0Core$Nil))), (c0Core$Cons)((i1Test$Group)("A function cannot consume uniques outside its own scope.", (c0Core$Cons)((u3Uniqueness$codeTest)("base", "scope =\n    !x = 1\n    fn z: x", (u3Uniqueness$infer)("scope"), (i1Test$errorContains)((c0Core$Cons)("outside their body", (c0Core$Cons)("x", c0Core$Nil)))), c0Core$Nil)), c0Core$Nil))))));

const u3Uniqueness$specs = (i1Test$Group)("Uniqueness", (c0Core$Cons)(u3Uniqueness$howDoesItLookLike, (c0Core$Cons)(u3Uniqueness$uniquenessTyping, (c0Core$Cons)(u3Uniqueness$mutation, (c0Core$Cons)(u3Uniqueness$parentScope, (c0Core$Cons)(u3Uniqueness$polymorphism, (c0Core$Cons)(u3Uniqueness$unions, (c0Core$Cons)(u3Uniqueness$records, c0Core$Nil))))))));

const u0BuildMain$asModule = (($tuple) => {
  const $2 = $tuple;
  const $name = $2.second;
  const $isDirectory = $2.first;
  return (($isDirectory || (sp_not_equal)(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$"))($name), $name))
    ? c0Maybe$Nothing
    : (c0Maybe$Just)(((($0) => {
      return (c0Text$replace)(".sp", "", $0);
    }))($name)));
});

const u0BuildMain$asModuleDirectory = (($tuple) => {
  const $2 = $tuple;
  const $name = $2.second;
  const $isDirectory = $2.first;
  return (($isDirectory && (sp_equal)(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$"))($name), $name))
    ? (c0Maybe$Just)($name)
    : c0Maybe$Nothing);
});

const u0BuildMain$defaultCorelibDir = "corelib";

const u0BuildMain$getEntryUsr = (($projectImports, $entryModule) => {
  return (c0Compiler$Meta$resolve)(({
    currentImports: $projectImports,
    currentModule: u0Compiler$CoreDefs$umr,
    loadExports: (($importsPath) => {
      return (c0Result$Err)((u0Compiler$Error$Raw)((c0Core$Cons)("Entry point can't be in an installed library!", c0Core$Nil)));
    }),
    makeError: u0Compiler$Error$Raw,
  }), (c0Maybe$Just)($entryModule), "main");
});

const u0BuildMain$importsFileName = "imports.sp";

const u0BuildMain$installedDir = "installedLibraries";

const u0BuildMain$ioToRes = (($0) => {
  return (c0Result$mapError)((($err) => {
    return (u0Compiler$Error$Raw)((c0Core$Cons)($err, c0Core$Nil));
  }), $0);
});

const u0BuildMain$loadCaModule = (($pars, $umr) => {
  return ((sp_equal)($umr, u0Compiler$CoreDefs$umr)
    ? (c0Result$Ok)(u0Compiler$CoreDefs$coreModule)
    : ((() => {
      const $3 = $umr;
      const $modulePath = ($3)[3];
      const $sourceDir = ($3)[2];
      const $importsPath = ($3)[1];
      const $4 = $importsPath;
      const $importsDir = ($4)[2];
      const $rootDirectory = ($4)[1];
      return ((c0Result$onOk)((($imports) => {
        const $rootPath = (c0Compiler$Meta$rootDirectoryToPath)($pars.rootPaths, $rootDirectory);
        const $fileName = ((($0) => {
          return ($0 + ".sp");
        }))((path_join)((c0Core$Cons)($rootPath, (c0Core$Cons)($importsDir, (c0Core$Cons)($sourceDir, (c0Core$Cons)($modulePath, c0Core$Nil))))));
        return ((c0Result$onOk)((($moduleAsText) => {
          const $errorModule = ({
            content: $moduleAsText,
            fsPath: $fileName,
          });
          const $resolvePars = (($pos) => {
            return ({
              currentImports: $imports,
              currentModule: $umr,
              loadExports: $pars.loadExports,
              makeError: (($0) => {
                return (u0Compiler$Error$Simple)($errorModule, $pos, $0);
              }),
            });
          });
          const $params = ({
            errorModule: $errorModule,
            resolvePars: $resolvePars,
            umr: $umr,
          });
          return (u0Compiler$MakeCanonical$textToCanonicalModule)(false, $params);
        })))((u0BuildMain$ioToRes)(($pars.readFile)($fileName)));
      })))(($pars.loadImports)($importsPath));
    }))());
});

const u0BuildMain$exportsFileName = "exports.sp";

const u0BuildMain$listSourceDir = (($io, $sourceDirRoot, $modulePathWithTrailingSlash) => {
  const $path = ($sourceDirRoot + ("/" + $modulePathWithTrailingSlash));
  return ([
    ((c0Result$onOk)((($dirContents) => {
      const $directChildren = ((($0) => {
        return (c0List$map)((($fileName) => {
          return ($modulePathWithTrailingSlash + $fileName);
        }), $0);
      }))(((($0) => {
        return (c0List$filterMap)(u0BuildMain$asModule, $0);
      }))($dirContents));
      return ((c0Result$onOk)((($descendants) => {
        const $x = (c0List$concat)((c0Core$Cons)($directChildren, (c0Core$Cons)((c0List$concat)($descendants), c0Core$Nil)));
        return (c0Result$Ok)($x);
      })))(((($0) => {
        return (c0List$mapRes)((($subDir) => {
          return ((__re__ = (u0BuildMain$listSourceDir)($io, $sourceDirRoot, ($modulePathWithTrailingSlash + ($subDir + "/")))), ($io = (__re__)[1]), (__re__)[0]);
        }), $0);
      }))(((($0) => {
        return (c0List$filterMap)(u0BuildMain$asModuleDirectory, $0);
      }))($dirContents)));
    })))(((__re__ = (io_readDir)($io, $path)), ($io = (__re__)[1]), (__re__)[0])),
    $io,
  ]);
});

const u0BuildMain$updateSourceDir = (($fileNames, $orig) => {
  const $insertModuleName = (($name, $sd) => {
    const $5 = (c0List$find)((($m) => {
      return (sp_equal)($m.path, $name);
    }), $sd.modules);
    return ((($5)[0] === "$Just")
      ? $sd
      : ((($5)[0] === "$Nothing")
        ? ((() => {
          const $0 = $sd;
          return (Object.assign)({}, $0, ({
            modules: (sp_cons)(({
              globals: c0Core$Nil,
              path: $name,
              visibleAs: $name,
            }), $0.modules),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 160:8', (sp_toHuman)($5))));
  });
  return (c0List$for)($orig, $fileNames, $insertModuleName);
});

const u0BuildMain$scanSourceDirs = (($io, $rootPaths, $importsPath, $importsFile) => {
  const $5 = $importsPath;
  const $importsDir = ($5)[2];
  const $root = ($5)[1];
  const $rootPath = (c0Compiler$Meta$rootDirectoryToPath)($rootPaths, $root);
  return ([
    ((c0Result$onOk)((($allSourceDirLists) => {
      const $updatedSourceDirs = (c0List$map2)(u0BuildMain$updateSourceDir, $allSourceDirLists, $importsFile.sourceDirs);
      return (u0ImportsFile$toImports)(({
        importsPath: $importsPath,
        joinPath: path_join,
      }), ((() => {
        const $0 = $importsFile;
        return (Object.assign)({}, $0, ({
          sourceDirs: $updatedSourceDirs,
        }));
      }))());
    })))((u0BuildMain$ioToRes)(((($0) => {
      return (c0List$mapRes)((($sd) => {
        return ((__re__ = (u0BuildMain$listSourceDir)($io, (path_join)((c0Core$Cons)($rootPath, (c0Core$Cons)($importsDir, (c0Core$Cons)($sd.path, c0Core$Nil)))), "")), ($io = (__re__)[1]), (__re__)[0]);
      }), $0);
    }))($importsFile.sourceDirs))),
    $io,
  ]);
});

const u0ImportsFile$init = ({
  libraries: c0Core$Nil,
  sourceDirs: c0Core$Nil,
});

const u0SPLib$SPON$expr = (($aWhat, $getA) => {
  return (($0) => {
    return (((($0)[0] === "$Cons") && (((($0)[1])[0] === "$Evaluation") && (((($0)[1])[1])[0] === "$Expression")))
      ? ((() => {
        const $p = ((($0)[1])[1])[2];
        const $e = ((($0)[1])[1])[3];
        const $tail = ($0)[2];
        const $4 = ($getA)($e);
        return ((($4)[0] === "$Just")
          ? ((() => {
            const $a = ($4)[1];
            return (u0SPLib$SPON$Accepted)($tail, $a);
          }))()
          : ((($4)[0] === "$Nothing")
            ? (u0SPLib$SPON$Rejected)(((($0) => {
              return (c0Compiler$Pos$At)($p, $0);
            }))(("Expecting " + $aWhat)))
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 91:12', (sp_toHuman)($4))));
      }))()
      : (((($0)[0] === "$Cons") && ((($0)[2])[0] === "$Nil"))
        ? ((() => {
          const $s = ($0)[1];
          return (u0SPLib$SPON$Rejected)(((($0) => {
            return (c0Compiler$Pos$At)((c0Compiler$FormattableAst$statementPos)($s), $0);
          }))(("Expecting " + $aWhat)));
        }))()
        : (true
          ? (u0SPLib$SPON$Failed)((c0Compiler$Pos$At)(c0Compiler$Pos$End, "Expecting a statement"))
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 88:4', (sp_toHuman)($0)))));
  });
});

const u0SPLib$SPON$anyName = ((($0) => {
  return (u0SPLib$SPON$expr)("a name", $0);
}))((($0) => {
  return (((($0)[0] === "$Lowercase") && (((($0)[1].attrPath)[0] === "$Nil") && (((($0)[1].maybeModule)[0] === "$Nothing") && ((($0)[1].maybeType)[0] === "$Nothing"))))
    ? ((() => {
      const $name = ($0)[1].name;
      return (c0Maybe$Just)($name);
    }))()
    : (((($0)[0] === "$Uppercase") && ((($0)[1].maybeModule)[0] === "$Nothing"))
      ? ((() => {
        const $name = ($0)[1].name;
        return (c0Maybe$Just)($name);
      }))()
      : (((($0)[0] === "$Constructor") && ((($0)[1].maybeModule)[0] === "$Nothing"))
        ? ((() => {
          const $name = ($0)[1].name;
          return (c0Maybe$Just)($name);
        }))()
        : (true
          ? c0Maybe$Nothing
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 139:4', (sp_toHuman)($0))))));
}));

const u0SPLib$SPON$expressionToStatements = (($e) => {
  return (((($e)[0] === "$Expression") && (((($e)[3])[0] === "$Statements") && ((((($e)[3])[1])[0] === "$Cons") && (((((($e)[3])[1])[1])[0] === "$Evaluation") && ((((($e)[3])[1])[2])[0] === "$Nil")))))
    ? ((() => {
      const $nested = (((($e)[3])[1])[1])[1];
      return (u0SPLib$SPON$expressionToStatements)($nested);
    }))()
    : (((($e)[0] === "$Expression") && ((($e)[3])[0] === "$Statements"))
      ? ((() => {
        const $stats = (($e)[3])[1];
        return $stats;
      }))()
      : (true
        ? (c0Core$Cons)((c0Compiler$FormattableAst$Evaluation)($e), c0Core$Nil)
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 207:4', (sp_toHuman)($e)))));
});

const u0SPLib$SPON$field = (($fieldName, $fieldReader) => {
  return (($0) => {
    return (((($0)[0] === "$Cons") && (((($0)[1])[0] === "$ValueDef") && ((((($0)[1])[1].pattern)[0] === "$Expression") && (((((($0)[1])[1].pattern)[3])[0] === "$Lowercase") && ((((((($0)[1])[1].pattern)[3])[1].attrPath)[0] === "$Nil") && ((((((($0)[1])[1].pattern)[3])[1].maybeModule)[0] === "$Nothing") && (((((($0)[1])[1].pattern)[3])[1].maybeType)[0] === "$Nothing")))))))
      ? ((() => {
        const $body = (($0)[1])[1].body;
        const $nonFn = (($0)[1])[1].nonFn;
        const $pos = ((($0)[1])[1].pattern)[2];
        const $name = (((($0)[1])[1].pattern)[3])[1].name;
        const $tail = ($0)[2];
        return ((sp_equal)($name, $fieldName)
          ? ((() => {
            const $4 = ($fieldReader)((u0SPLib$SPON$expressionToStatements)($body));
            return ((($4)[0] === "$Accepted")
              ? ((() => {
                const $unreadStatements = ($4)[1];
                const $a = ($4)[2];
                return ((($unreadStatements)[0] === "$Nil")
                  ? (u0SPLib$SPON$Accepted)($tail, $a)
                  : ((($unreadStatements)[0] === "$Cons")
                    ? ((() => {
                      const $head = ($unreadStatements)[1];
                      return (u0SPLib$SPON$Failed)(((($0) => {
                        return (c0Compiler$Pos$At)((c0Compiler$FormattableAst$statementPos)($head), $0);
                      }))(("Could not make sense of all the statements in field `" + ($fieldName + "`."))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 239:24', (sp_toHuman)($unreadStatements))));
              }))()
              : (true
                ? ((() => {
                  const $otherwise = $4;
                  return $otherwise;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 236:16', (sp_toHuman)($4))));
          }))()
          : (u0SPLib$SPON$Rejected)(((($0) => {
            return (c0Compiler$Pos$At)($pos, $0);
          }))(("expecting `" + ($fieldName + " =`")))));
      }))()
      : ((($0)[0] === "$Cons")
        ? ((() => {
          const $head = ($0)[1];
          const $tail = ($0)[2];
          return (u0SPLib$SPON$Rejected)((c0Compiler$Pos$At)((c0Compiler$FormattableAst$statementPos)($head), "missing a simple assignment (ie `something = `)"));
        }))()
        : ((($0)[0] === "$Nil")
          ? (u0SPLib$SPON$Rejected)((c0Compiler$Pos$At)(c0Compiler$Pos$End, "unexpected end of file"))
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 215:4', (sp_toHuman)($0)))));
  });
});

const u0SPLib$SPON$many = (($readerA) => {
  const $rec = (($accum) => {
    return (($statements) => {
      return ((sp_equal)($statements, c0Core$Nil)
        ? (u0SPLib$SPON$Accepted)(c0Core$Nil, (c0List$reverse)($accum))
        : ((() => {
          const $4 = ($readerA)($statements);
          return ((($4)[0] === "$Accepted")
            ? ((() => {
              const $tail = ($4)[1];
              const $a = ($4)[2];
              return (($rec)((sp_cons)($a, $accum)))($tail);
            }))()
            : ((($4)[0] === "$Rejected")
              ? ((() => {
                const $e = ($4)[1];
                return (u0SPLib$SPON$Rejected)($e);
              }))()
              : ((($4)[0] === "$Failed")
                ? ((() => {
                  const $e = ($4)[1];
                  return (u0SPLib$SPON$Failed)($e);
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 187:12', (sp_toHuman)($4)))));
        }))());
    });
  });
  return ($rec)(c0Core$Nil);
});

const u0SPLib$SPON$maybe = (($readerA) => {
  return (($statements) => {
    const $3 = ($readerA)($statements);
    return ((($3)[0] === "$Accepted")
      ? ((() => {
        const $tail = ($3)[1];
        const $a = ($3)[2];
        return (u0SPLib$SPON$Accepted)($tail, (c0Maybe$Just)($a));
      }))()
      : ((($3)[0] === "$Rejected")
        ? (u0SPLib$SPON$Accepted)($statements, c0Maybe$Nothing)
        : ((($3)[0] === "$Failed")
          ? ((() => {
            const $r = ($3)[1];
            return (u0SPLib$SPON$Failed)($r);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 198:4', (sp_toHuman)($3)))));
  });
});

const u0SPLib$SPON$onAcc = (($chainedReaderB) => {
  return (($readerA) => {
    return (($statements) => {
      const $4 = ($readerA)($statements);
      return ((($4)[0] === "$Accepted")
        ? ((() => {
          const $newStatements = ($4)[1];
          const $a = ($4)[2];
          return (($chainedReaderB)($a))($newStatements);
        }))()
        : ((($4)[0] === "$Rejected")
          ? ((() => {
            const $reason = ($4)[1];
            return (u0SPLib$SPON$Rejected)($reason);
          }))()
          : ((($4)[0] === "$Failed")
            ? ((() => {
              const $reason = ($4)[1];
              return (u0SPLib$SPON$Failed)($reason);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 20:4', (sp_toHuman)($4)))));
    });
  });
});

const u0SPLib$SPON$return = (($a) => {
  return (($statements) => {
    return (u0SPLib$SPON$Accepted)($statements, $a);
  });
});

const u0SPLib$SPON$upperName = ((($0) => {
  return (u0SPLib$SPON$expr)("a simple Uppercase name", $0);
}))((($0) => {
  return (((($0)[0] === "$Uppercase") && ((($0)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($0)[1].name;
      return (c0Maybe$Just)($name);
    }))()
    : (true
      ? c0Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 125:4', (sp_toHuman)($0))));
}));

const u0ImportsFile$moduleReader = ((u0SPLib$SPON$onAcc)((($path) => {
  return ((u0SPLib$SPON$onAcc)((($visibleAs) => {
    return ((u0SPLib$SPON$onAcc)((($globals) => {
      return (u0SPLib$SPON$return)(({
        globals: (c0Maybe$withDefault)(c0Core$Nil, $globals),
        path: $path,
        visibleAs: (c0Maybe$withDefault)($path, $visibleAs),
      }));
    })))((u0SPLib$SPON$maybe)((u0SPLib$SPON$field)("globals", (u0SPLib$SPON$many)(u0SPLib$SPON$anyName))));
  })))((u0SPLib$SPON$maybe)((u0SPLib$SPON$field)("importAs", u0SPLib$SPON$upperName)));
})))((u0SPLib$SPON$field)("path", u0SPLib$SPON$upperName));

const u0SPLib$SPON$text = ((($0) => {
  return (u0SPLib$SPON$expr)("a text literal", $0);
}))((($0) => {
  return ((($0)[0] === "$LiteralText")
    ? ((() => {
      const $t = ($0)[2];
      return (c0Maybe$Just)($t);
    }))()
    : (true
      ? c0Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 111:4', (sp_toHuman)($0))));
}));

const u0ImportsFile$libraryReader = ((u0SPLib$SPON$onAcc)((($source) => {
  return ((u0SPLib$SPON$onAcc)((($modules) => {
    return (u0SPLib$SPON$return)(({
      modules: $modules,
      source: $source,
    }));
  })))((u0SPLib$SPON$many)((u0SPLib$SPON$field)("module", u0ImportsFile$moduleReader)));
})))((u0SPLib$SPON$field)("source", u0SPLib$SPON$text));

const u0ImportsFile$sourceDirectoryReader = ((u0SPLib$SPON$onAcc)((($path) => {
  return ((u0SPLib$SPON$onAcc)((($modules) => {
    return (u0SPLib$SPON$return)(({
      modules: $modules,
      path: $path,
    }));
  })))((u0SPLib$SPON$many)((u0SPLib$SPON$field)("module", u0ImportsFile$moduleReader)));
})))((u0SPLib$SPON$field)("path", u0SPLib$SPON$text));

const u0SPLib$SPON$oneOf = (($readers) => {
  return (($statements) => {
    return ((($readers)[0] === "$Nil")
      ? ((() => {
        const $pos = ((($statements)[0] === "$Cons")
          ? ((() => {
            const $head = ($statements)[1];
            return (c0Compiler$FormattableAst$statementPos)($head);
          }))()
          : (true
            ? c0Compiler$Pos$End
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 159:16', (sp_toHuman)($statements))));
        return (u0SPLib$SPON$Rejected)((c0Compiler$Pos$At)($pos, "options exhausted"));
      }))()
      : ((($readers)[0] === "$Cons")
        ? ((() => {
          const $headReader = ($readers)[1];
          const $tail = ($readers)[2];
          const $3 = ($headReader)($statements);
          return ((($3)[0] === "$Rejected")
            ? ((u0SPLib$SPON$oneOf)($tail))($statements)
            : (true
              ? ((() => {
                const $otherwise = $3;
                return $otherwise;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 166:12', (sp_toHuman)($3))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 155:4', (sp_toHuman)($readers))));
  });
});

const u0ImportsFile$modulesFileReader = (u0SPLib$SPON$many)((u0SPLib$SPON$oneOf)((c0Core$Cons)(((u0SPLib$SPON$onAcc)((($lib) => {
  return (u0SPLib$SPON$return)((u0ImportsFile$Lib)($lib));
})))((u0SPLib$SPON$field)("library", u0ImportsFile$libraryReader)), (c0Core$Cons)(((u0SPLib$SPON$onAcc)((($dir) => {
  return (u0SPLib$SPON$return)((u0ImportsFile$Dir)($dir));
})))((u0SPLib$SPON$field)("sourceDir", u0ImportsFile$sourceDirectoryReader)), c0Core$Nil))));

const u0SPLib$SPON$run = (($readerA, $errorModule, $statements) => {
  const $4 = ($readerA)($statements);
  return (((($4)[0] === "$Accepted") && ((($4)[1])[0] === "$Nil"))
    ? ((() => {
      const $a = ($4)[2];
      return (c0Result$Ok)($a);
    }))()
    : (((($4)[0] === "$Accepted") && ((($4)[1])[0] === "$Cons"))
      ? ((() => {
        const $head = (($4)[1])[1];
        const $tail = (($4)[1])[2];
        const $a = ($4)[2];
        return (u0Compiler$Error$res)($errorModule, (c0Compiler$FormattableAst$statementPos)($head), (c0Core$Cons)("unread statements", c0Core$Nil));
      }))()
      : (((($4)[0] === "$Rejected") && ((($4)[1])[0] === "$At"))
        ? ((() => {
          const $pos = (($4)[1])[1];
          const $r = (($4)[1])[2];
          return (u0Compiler$Error$res)($errorModule, $pos, (c0Core$Cons)($r, c0Core$Nil));
        }))()
        : (((($4)[0] === "$Failed") && ((($4)[1])[0] === "$At"))
          ? ((() => {
            const $pos = (($4)[1])[1];
            const $r = (($4)[1])[2];
            return (u0Compiler$Error$res)($errorModule, $pos, (c0Core$Cons)($r, c0Core$Nil));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 50:4', (sp_toHuman)($4))))));
});

const u0SPLib$SPON$read = (($reader, $fsPath, $content) => {
  const $errorModule = ({
    content: $content,
    fsPath: $fsPath,
  });
  return ((c0Result$onOk)((($0) => {
    return (u0SPLib$SPON$run)($reader, $errorModule, $0);
  })))((u0Compiler$Parser$textToFormattableModule)(({
    errorModule: $errorModule,
    keepComments: false,
    stripLocations: false,
  })));
});

const u0ImportsFile$fromText = (($sponName, $sponContent) => {
  const $insert = (($rootEntry, $mf) => {
    return ((($rootEntry)[0] === "$Lib")
      ? ((() => {
        const $lib = ($rootEntry)[1];
        const $0 = $mf;
        return (Object.assign)({}, $0, ({
          libraries: (sp_cons)($lib, $mf.libraries),
        }));
      }))()
      : ((($rootEntry)[0] === "$Dir")
        ? ((() => {
          const $dir = ($rootEntry)[1];
          const $0 = $mf;
          return (Object.assign)({}, $0, ({
            sourceDirs: (sp_cons)($dir, $mf.sourceDirs),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 217:8', (sp_toHuman)($rootEntry))));
  });
  return ((($0) => {
    return (c0Result$map)((($0) => {
      return (c0List$for)(u0ImportsFile$init, $0, $insert);
    }), $0);
  }))(((($0) => {
    return (u0SPLib$SPON$read)(u0ImportsFile$modulesFileReader, $sponName, $0);
  }))($sponContent));
});

const u0BuildMain$loadImports = (($io, $loadedImports, $rootPaths, $importsPath) => {
  const $5 = ((__re__ = (hash_get)($loadedImports, $importsPath)), ($loadedImports = (__re__)[1]), (__re__)[0]);
  return ([
    ((($5)[0] === "$Just")
      ? ((() => {
        const $imports = ($5)[1];
        return (c0Result$Ok)($imports);
      }))()
      : ((($5)[0] === "$Nothing")
        ? ((() => {
          const $6 = $importsPath;
          const $importsDir = ($6)[2];
          const $rootDirectory = ($6)[1];
          const $filePath = (path_resolve)((c0Core$Cons)((c0Compiler$Meta$rootDirectoryToPath)($rootPaths, $rootDirectory), (c0Core$Cons)($importsDir, (c0Core$Cons)(u0BuildMain$importsFileName, c0Core$Nil))));
          return ((c0Result$onOk)((($fileContent) => {
            return ((c0Result$onOk)((($importsFile) => {
              return ((c0Result$onOk)((($imports) => {
                ((__re__ = (hash_insert)($loadedImports, $importsPath, $imports)), ($loadedImports = (__re__)[1]), (__re__)[0]);
                return (c0Result$Ok)($imports);
              })))(((__re__ = (u0BuildMain$scanSourceDirs)($io, $rootPaths, $importsPath, $importsFile)), ($io = (__re__)[1]), (__re__)[0]));
            })))((u0ImportsFile$fromText)($filePath, $fileContent));
          })))((u0BuildMain$ioToRes)(((__re__ = (io_readFile)($io, $filePath)), ($io = (__re__)[1]), (__re__)[0])));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 222:4', (sp_toHuman)($5)))),
    $io,
    $loadedImports,
  ]);
});

const u0ExportsFile$exposesReader = ((u0SPLib$SPON$onAcc)((($name) => {
  return (u0SPLib$SPON$return)(({
    name: $name,
    open: true,
  }));
})))(u0SPLib$SPON$anyName);

const u0ExportsFile$moduleReader = ((u0SPLib$SPON$onAcc)((($path) => {
  return ((u0SPLib$SPON$onAcc)((($maybeExposes) => {
    return (u0SPLib$SPON$return)(({
      exposes: (c0List$for)(c0Dict$empty, (c0Maybe$withDefault)(c0Core$Nil, $maybeExposes), (($e, $d) => {
        return (c0Dict$insert)($e.name, $e.open, $d);
      })),
      path: $path,
    }));
  })))((u0SPLib$SPON$maybe)((u0SPLib$SPON$field)("exposes", (u0SPLib$SPON$many)(u0ExportsFile$exposesReader))));
})))((u0SPLib$SPON$field)("path", u0SPLib$SPON$upperName));

const u0ExportsFile$exportsFileReader = ((u0SPLib$SPON$onAcc)((($modules) => {
  return (u0SPLib$SPON$return)((c0List$for)(c0Dict$empty, $modules, (($module, $d) => {
    return (c0Dict$insert)($module.path, $module.exposes, $d);
  })));
})))((u0SPLib$SPON$many)((u0SPLib$SPON$field)("module", u0ExportsFile$moduleReader)));

const u0ExportsFile$fromText = (($0, $1) => {
  return (u0SPLib$SPON$read)(u0ExportsFile$exportsFileReader, $0, $1);
});

const u0ExportsFile$result_withAddError = (($groupErrors, $collectErrors) => {
  let $errors = (array_fromList)(c0Core$Nil);
  const $addError = (($0) => {
    return ((__re__ = (array_push)($errors, $0)), ($errors = (__re__)[1]), (__re__)[0]);
  });
  const $payload = ($collectErrors)($addError);
  const $errorList = ((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]);
  return ((sp_equal)($errorList, c0Core$Nil)
    ? (c0Result$Ok)($payload)
    : (c0Result$Err)(($groupErrors)($errorList)));
});

const u0ExportsFile$toExports = (($imports, $exportsFile) => {
  return (u0ExportsFile$result_withAddError)(u0Compiler$Error$Nested, (($addError_) => {
    const $addError = (($0) => {
      return ($addError_)((u0Compiler$Error$Raw)($0));
    });
    return (c0Dict$for)(c0Dict$empty, $exportsFile, (($modulePath, $exposedNames, $d) => {
      const $7 = (c0Dict$get)($modulePath, $imports.modulePathToLocation);
      return ((($7)[0] === "$Nothing")
        ? ((() => {
          ($addError)((c0Core$Cons)(("TODO exports refers to a module with path " + ($modulePath + " but that is not in imports.")), (c0Core$Cons)(((($0) => {
            return (c0Text$join)(", ", $0);
          }))((c0Dict$keys)($imports.modulePathToLocation)), c0Core$Nil)));
          return $d;
        }))()
        : (((($7)[0] === "$Just") && ((($7)[1])[0] === "$LocationLibrary"))
          ? ((() => {
            const $importsPath = (($7)[1])[1];
            const $modulePath_ = (($7)[1])[2];
            ($addError)((c0Core$Cons)("TODO you can't export modules from a library", c0Core$Nil));
            return $d;
          }))()
          : (((($7)[0] === "$Just") && ((($7)[1])[0] === "$LocationSourceDir"))
            ? ((() => {
              const $umr = (($7)[1])[1];
              return (c0Dict$for)($d, $exposedNames, (($name, $isOpen, $dd) => {
                const $usr = (c0Compiler$Meta$USR)($umr, $name);
                const $addNameToModule = (($0) => {
                  return (c0Maybe$Just)(((($0) => {
                    return (c0Dict$insert)($name, ({
                      isOpen: $isOpen,
                      usr: $usr,
                    }), $0);
                  }))(((($0) => {
                    return (c0Maybe$withDefault)(c0Dict$empty, $0);
                  }))($0)));
                });
                return (c0Dict$update)($modulePath, $addNameToModule, $dd);
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/ExportsFile.sp 53:12', (sp_toHuman)($7)))));
    }));
  }));
});

const u0BuildMain$loadExports = (($io, $loadedImports, $loadedExports, $rootPaths, $importsPath) => {
  const $6 = ((__re__ = (hash_get)($loadedExports, $importsPath)), ($loadedExports = (__re__)[1]), (__re__)[0]);
  return ([
    ((($6)[0] === "$Just")
      ? ((() => {
        const $exports = ($6)[1];
        return (c0Result$Ok)($exports);
      }))()
      : ((($6)[0] === "$Nothing")
        ? ((c0Result$onOk)((($imports) => {
          const $8 = $importsPath;
          const $importsDir = ($8)[2];
          const $rootDirectory = ($8)[1];
          const $filePath = (path_resolve)((c0Core$Cons)((c0Compiler$Meta$rootDirectoryToPath)($rootPaths, $rootDirectory), (c0Core$Cons)($importsDir, (c0Core$Cons)(u0BuildMain$exportsFileName, c0Core$Nil))));
          return ((c0Result$onOk)((($fileContent) => {
            return ((c0Result$onOk)((($exportsFile) => {
              return ((c0Result$onOk)((($exports) => {
                ((__re__ = (hash_insert)($loadedExports, $importsPath, $exports)), ($loadedExports = (__re__)[1]), (__re__)[0]);
                return (c0Result$Ok)($exports);
              })))((u0ExportsFile$toExports)($imports, $exportsFile));
            })))((u0ExportsFile$fromText)($filePath, $fileContent));
          })))((u0BuildMain$ioToRes)(((__re__ = (io_readFile)($io, $filePath)), ($io = (__re__)[1]), (__re__)[0])));
        })))(((__re__ = (u0BuildMain$loadImports)($io, $loadedImports, $rootPaths, $importsPath)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), (__re__)[0]))
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 195:4', (sp_toHuman)($6)))),
    $io,
    $loadedImports,
    $loadedExports,
  ]);
});

const u0BuildMain$searchAncestorDirectories = (($io, $isWantedFile, $searchDir) => {
  const $4 = ((__re__ = (io_readDir)($io, $searchDir)), ($io = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Err")
      ? c0Maybe$Nothing
      : ((($4)[0] === "$Ok")
        ? ((() => {
          const $dirContents = ($4)[1];
          return ((c0List$any)($isWantedFile, $dirContents)
            ? (c0Maybe$Just)($searchDir)
            : ((() => {
              const $parent = (path_resolve)((c0Core$Cons)($searchDir, (c0Core$Cons)("..", c0Core$Nil)));
              return ((sp_equal)($parent, $searchDir)
                ? c0Maybe$Nothing
                : ((__re__ = (u0BuildMain$searchAncestorDirectories)($io, $isWantedFile, $parent)), ($io = (__re__)[1]), (__re__)[0]));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 248:4', (sp_toHuman)($4)))),
    $io,
  ]);
});

const u0BuildMain$compileMain = (($io, $pars) => {
  const $projectRoot = ((($0) => {
    return (c0Maybe$withDefault)(".", $0);
  }))(((__re__ = (u0BuildMain$searchAncestorDirectories)($io, (($3) => {
    const $isDirectory = $3.first;
    const $fileName = $3.second;
    return ((c0Basics$not)($isDirectory) && (sp_equal)($fileName, u0BuildMain$importsFileName));
  }), ".")), ($io = (__re__)[1]), (__re__)[0]));
  ((($0) => {
    return ((__re__ = (io_writeStdout)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
  }))(("Project root is " + ((path_resolve)((c0Core$Cons)($projectRoot, c0Core$Nil)) + "\n")));
  const $importsPath = (c0Compiler$Meta$ImportsPath)(c0Compiler$Meta$User, "");
  const $corelibPath = ((() => {
    const $3 = $pars.corelib;
    return ((($3)[0] === "$Just")
      ? ((() => {
        const $corelib = ($3)[1];
        return $corelib;
      }))()
      : ((($3)[0] === "$Nothing")
        ? ((() => {
          const $executablePath = (path_dirname)((path_resolve)((c0Core$Cons)($pars.selfPath, c0Core$Nil)));
          return (path_join)((c0Core$Cons)($executablePath, (c0Core$Cons)(u0BuildMain$defaultCorelibDir, c0Core$Nil)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 300:8', (sp_toHuman)($3))));
  }))();
  const $rootPaths = ({
    core: $corelibPath,
    installed: (path_join)((c0Core$Cons)($projectRoot, (c0Core$Cons)(u0BuildMain$installedDir, c0Core$Nil))),
    project: $projectRoot,
  });
  let $loadedImports = (hash_fromList)(c0Core$Nil);
  let $loadedExports = (hash_fromList)(c0Core$Nil);
  return ([
    ((c0Result$onOk)((($projectImports) => {
      return ((c0Result$onOk)((($entryUsr) => {
        const $loadCaModulePars = ({
          loadExports: (($0) => {
            return ((__re__ = (u0BuildMain$loadExports)($io, $loadedImports, $loadedExports, $rootPaths, $0)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), ($loadedExports = (__re__)[3]), (__re__)[0]);
          }),
          loadImports: (($0) => {
            return ((__re__ = (u0BuildMain$loadImports)($io, $loadedImports, $rootPaths, $0)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), (__re__)[0]);
          }),
          readFile: (($0) => {
            return ((__re__ = (io_readFile)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
          }),
          rootPaths: $rootPaths,
        });
        return ((c0Result$onOk)((($5) => {
          const $constructors = $5.constructors;
          const $rootValues = $5.rootValues;
          const $outputFile = (c0Maybe$withDefault)($pars.platform.defaultOutputName, $pars.maybeOutputPath);
          const $type = ((() => {
            const $6 = (c0List$find)((($rv) => {
              return (sp_equal)($rv.usr, $entryUsr);
            }), $rootValues);
            return ((($6)[0] === "$Just")
              ? ((() => {
                const $rv = ($6)[1];
                return $rv.type;
              }))()
              : ((($6)[0] === "$Nothing")
                ? (sp_todo)("no type!?")
                : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 372:8', (sp_toHuman)($6))));
          }))();
          return ((c0Result$onOk)(((_0) => {
            return (u0BuildMain$ioToRes)(((__re__ = (io_writeStdout)($io, ("---> " + ($outputFile + " written. =)")))), ($io = (__re__)[1]), (__re__)[0]));
          })))((u0BuildMain$ioToRes)(((($0) => {
            return ((__re__ = (io_writeFile)($io, $outputFile, $0)), ($io = (__re__)[1]), (__re__)[0]);
          }))(($pars.platform.makeExecutable)(({
            constructors: $constructors,
            defs: $rootValues,
            entryUsr: $entryUsr,
            type: $type,
          })))));
        })))((u0Compiler$LazyBuild$build)(({
          loadCaModule: (($0) => {
            return (u0BuildMain$loadCaModule)($loadCaModulePars, $0);
          }),
          projectImports: $projectImports,
          requiredUsrs: (c0Core$Cons)($entryUsr, c0Core$Nil),
        })));
      })))((u0BuildMain$getEntryUsr)($projectImports, $pars.entryPoint));
    })))(((__re__ = (u0BuildMain$loadImports)($io, $loadedImports, $rootPaths, $importsPath)), ($io = (__re__)[1]), ($loadedImports = (__re__)[2]), (__re__)[0])),
    $io,
  ]);
});

const u0Compiler$Lexer_Test$codeTest = (($0, $1, $2, $3) => {
  return (i1Test$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const u0Compiler$Lexer_Test$lexTokens = (($s) => {
  return (u0Compiler$TestHelpers$resErrorToStrippedText)(((($0) => {
    return (u0Compiler$Lexer$lexer)(true, $0);
  }))((u0Compiler$TestHelpers$errorModule)($s)));
});

const u0Compiler$Lexer_Test$lexTokensAndDrop = (($name) => {
  return (($s) => {
    return ((($0) => {
      return (c0Result$map)((($0) => {
        return (c0List$map)((($0) => {
          return (c0List$drop)($name, $0);
        }), $0);
      }), $0);
    }))((u0Compiler$Lexer_Test$lexTokens)($s));
  });
});

const u0Compiler$Lexer_Test$lowerName = (($name) => {
  return (c0Compiler$Token$Lowercase)(({
    attrPath: c0Core$Nil,
    maybeModule: c0Maybe$Nothing,
    name: $name,
  }));
});

const u0Compiler$Lexer_Test$comments = (i1Test$Group)("Comments", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] statement after comment", "\n#\na = 1\n", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)(c0Core$Nil, (c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(3, 4, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(5, 6, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(7, 8, $0);
}))((c0Compiler$Token$NumberLiteral)(false, "1")), c0Core$Nil))), c0Core$Nil)))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] nested comments allow a spurious newline?", "\n[#[##]#]\na = 1\n", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 9, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: false,
}))), c0Core$Nil), (c0Core$Cons)((c0Core$Cons)((c0Compiler$Token$Token)(10, 10, c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(10, 11, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(12, 13, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(14, 15, $0);
}))((c0Compiler$Token$NumberLiteral)(false, "1")), c0Core$Nil)))), c0Core$Nil)))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("Single line", "# hello", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 7, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 0,
  isBlock: false,
  isFollowedByBlank: false,
}))), c0Core$Nil), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("Multi line", "[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 17, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: true,
}))), c0Core$Nil), (c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(19, 19, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(19, 20, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(21, 33, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 2,
  isBlock: true,
  isFollowedByBlank: false,
}))), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(34, 35, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(36, 37, $0);
}))((c0Compiler$Token$NumberLiteral)(false, "1")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(39, 59, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: true,
}))), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(61, 79, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: false,
}))), c0Core$Nil))))))), c0Core$Nil)))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("brackets", "[]", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 1, $0);
}))((c0Compiler$Token$SquareBracket)(0, c0Compiler$Token$Open)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 2, $0);
}))((c0Compiler$Token$SquareBracket)(0, c0Compiler$Token$Closed)), c0Core$Nil)), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] Inline comments should not break a block", "allTests = [\n    , a\n#\n    ]", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 0, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 8, $0);
}))((u0Compiler$Lexer_Test$lowerName)("allTests")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(9, 10, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(11, 12, $0);
}))((c0Compiler$Token$SquareBracket)(0, c0Compiler$Token$Open)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(17, 18, $0);
}))(c0Compiler$Token$Comma), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(19, 20, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(21, 22, $0);
}))((c0Compiler$Token$Comment)(({
  indent: 0,
  isBlock: false,
  isFollowedByBlank: false,
}))), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(27, 28, $0);
}))((c0Compiler$Token$SquareBracket)(3, c0Compiler$Token$Closed)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(28, 28, $0);
}))(c0Compiler$Token$BlockEnd), c0Core$Nil))))))))), c0Core$Nil))), c0Core$Nil)))))));

const u0Compiler$Lexer_Test$upperName = (($name) => {
  return (c0Compiler$Token$Uppercase)(({
    maybeModule: c0Maybe$Nothing,
    name: $name,
  }));
});

const u0Compiler$Lexer_Test$indentation = (i1Test$Group)("Blocks, sibling lines, indentation", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("1", "\na =\n 1\nb = 1", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 1, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 2, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(3, 4, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(6, 6, $0);
}))(c0Compiler$Token$BlockStart), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(6, 7, $0);
}))((c0Compiler$Token$NumberLiteral)(false, "1")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(8, 8, $0);
}))(c0Compiler$Token$BlockEnd), c0Core$Nil)))))), (c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(8, 8, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(8, 9, $0);
}))((u0Compiler$Lexer_Test$lowerName)("b")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(10, 11, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(12, 13, $0);
}))((c0Compiler$Token$NumberLiteral)(false, "1")), c0Core$Nil)))), c0Core$Nil)))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] spurious spaces in front of field name", "module =\n   importAs =\n      SPCore\n   globalTypes =\n      None", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 0, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 6, $0);
}))((u0Compiler$Lexer_Test$lowerName)("module")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(7, 8, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(12, 12, $0);
}))(c0Compiler$Token$BlockStart), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(12, 20, $0);
}))((u0Compiler$Lexer_Test$lowerName)("importAs")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(21, 22, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(29, 29, $0);
}))(c0Compiler$Token$BlockStart), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(29, 35, $0);
}))((u0Compiler$Lexer_Test$upperName)("SPCore")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(39, 39, $0);
}))(c0Compiler$Token$BlockEnd), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(39, 39, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(39, 50, $0);
}))((u0Compiler$Lexer_Test$lowerName)("globalTypes")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(51, 52, $0);
}))(c0Compiler$Token$Defop), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(59, 59, $0);
}))(c0Compiler$Token$BlockStart), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(59, 63, $0);
}))((u0Compiler$Lexer_Test$upperName)("None")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(63, 63, $0);
}))(c0Compiler$Token$BlockEnd), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(63, 63, $0);
}))(c0Compiler$Token$BlockEnd), c0Core$Nil)))))))))))))))), c0Core$Nil))), c0Core$Nil)));

const u0Compiler$Lexer_Test$names = (i1Test$Group)("Names", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] Simple record access", "a.b", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 3, $0);
}))((c0Compiler$Token$Lowercase)(({
  attrPath: (c0Core$Cons)("b", c0Core$Nil),
  maybeModule: c0Maybe$Nothing,
  name: "a",
}))), c0Core$Nil), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] Nested record access", "a.b.c", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 5, $0);
}))((c0Compiler$Token$Lowercase)(({
  attrPath: (c0Core$Cons)("b", (c0Core$Cons)("c", c0Core$Nil)),
  maybeModule: c0Maybe$Nothing,
  name: "a",
}))), c0Core$Nil), c0Core$Nil))), c0Core$Nil)));

const u0Compiler$Lexer_Test$numberLiterals = (i1Test$Group)("Number literals", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("Percent", "10%", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 2, $0);
}))((c0Compiler$Token$NumberLiteral)(true, "10")), c0Core$Nil), c0Core$Nil))), c0Core$Nil));

const u0Compiler$Lexer_Test$ops = (i1Test$Group)("Operators", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] .. set Default", ".. []", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 3, $0);
}))((c0Compiler$Token$Binop)(0, u0Compiler$CoreDefs$textConcat)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(3, 4, $0);
}))((c0Compiler$Token$SquareBracket)(0, c0Compiler$Token$Open)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(4, 5, $0);
}))((c0Compiler$Token$SquareBracket)(0, c0Compiler$Token$Closed)), c0Core$Nil))), c0Core$Nil))), c0Core$Nil));

const u0Compiler$Lexer_Test$position = (i1Test$Group)("Position", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] ops position", "blah <>", u0Compiler$Lexer_Test$lexTokens, (i1Test$errorContains)((c0Core$Cons)("blah <>", c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] ops position, with newline", "blah <>\n", u0Compiler$Lexer_Test$lexTokens, (i1Test$errorContains)((c0Core$Cons)("blah <>", c0Core$Nil))), c0Core$Nil)));

const u0Compiler$Lexer_Test$recordLiterals = (i1Test$Group)("Record literals", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("[reg] .shorthand should work on its own line", "x =\n  .b", (u0Compiler$Lexer_Test$lexTokensAndDrop)(3), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)((c0Compiler$Token$Token)(6, 6, c0Compiler$Token$BlockStart), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(6, 8, $0);
}))((c0Compiler$Token$RecordShorthand)(({
  attrPath: c0Core$Nil,
  name: "b",
}))), (c0Core$Cons)((c0Compiler$Token$Token)(8, 8, c0Compiler$Token$BlockEnd), c0Core$Nil))), c0Core$Nil))), c0Core$Nil));

const u0Compiler$Lexer_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const u0Compiler$Lexer_Test$textLiterals = (i1Test$Group)("Text literals", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("Empty Text", "\"\"", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 0, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 2, $0);
}))((c0Compiler$Token$TextLiteral)(c0Compiler$Token$SingleQuote, "")), c0Core$Nil)), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("Followed by colon", "\"n\":\n", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 0, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 3, $0);
}))((c0Compiler$Token$TextLiteral)(c0Compiler$Token$SingleQuote, "n")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(3, 4, $0);
}))(c0Compiler$Token$Colon), c0Core$Nil))), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$valueTest)("Unindent function", ((_0) => {
  return ((($0) => {
    return (u0Compiler$Lexer$unindent)($0);
  }))(((($0) => {
    return (c0Text$join)("", $0);
  }))((c0Core$Cons)("\n", (c0Core$Cons)("  a\n", (c0Core$Cons)("      \n", (c0Core$Cons)("\n", (c0Core$Cons)("  b\n", (c0Core$Cons)("  ", c0Core$Nil))))))));
}), (i1Test$isOkAndEqualTo)((c0Text$join)("", (c0Core$Cons)("a\n", (c0Core$Cons)("    \n", (c0Core$Cons)("\n", (c0Core$Cons)("b", c0Core$Nil))))))), c0Core$Nil))));

const u0Compiler$Lexer_Test$unaryAddittiveOps = (i1Test$Group)("Unary addittive ops", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("-a", "-a", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 1, $0);
}))((c0Compiler$Token$Unop)(c0Compiler$Op$UnopMinus)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 2, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), c0Core$Nil)), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("a - -a", "a - -a", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 1, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(2, 3, $0);
}))((c0Compiler$Token$Binop)(0, u0Compiler$CoreDefs$subtract)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(4, 5, $0);
}))((c0Compiler$Token$Unop)(c0Compiler$Op$UnopMinus)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(5, 6, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), c0Core$Nil)))), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("SKIP a-a", "a-a", u0Compiler$Lexer_Test$lexTokens, (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 0, $0);
}))(c0Compiler$Token$NewSiblingLine), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 1, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(1, 2, $0);
}))((c0Compiler$Token$Binop)(1, u0Compiler$CoreDefs$subtract)), (c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(2, 3, $0);
}))((u0Compiler$Lexer_Test$lowerName)("a")), c0Core$Nil)))), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("-=", "-=", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 2, $0);
}))((c0Compiler$Token$Binop)(0, u0Compiler$CoreDefs$mutableSubtract)), c0Core$Nil), c0Core$Nil))), c0Core$Nil)))));

const u0Compiler$Lexer_Test$underscores = (i1Test$Group)("Underscores", (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("'_' as a Name", "_", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 1, $0);
}))((u0Compiler$Lexer_Test$lowerName)("_")), c0Core$Nil), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("'_10_20' as a Name", "_10_20", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 6, $0);
}))((u0Compiler$Lexer_Test$lowerName)("_10_20")), c0Core$Nil), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Lexer_Test$codeTest)("'10_20' as a Number", "10_20", (u0Compiler$Lexer_Test$lexTokensAndDrop)(1), (i1Test$isOkAndEqualTo)((c0Core$Cons)((c0Core$Cons)(((($0) => {
  return (c0Compiler$Token$Token)(0, 5, $0);
}))((c0Compiler$Token$NumberLiteral)(false, "10_20")), c0Core$Nil), c0Core$Nil))), c0Core$Nil))));

const u0Compiler$Lexer_Test$tests = (i1Test$Group)("Lexer", (c0Core$Cons)(u0Compiler$Lexer_Test$names, (c0Core$Cons)(u0Compiler$Lexer_Test$ops, (c0Core$Cons)(u0Compiler$Lexer_Test$unaryAddittiveOps, (c0Core$Cons)(u0Compiler$Lexer_Test$indentation, (c0Core$Cons)(u0Compiler$Lexer_Test$comments, (c0Core$Cons)(u0Compiler$Lexer_Test$underscores, (c0Core$Cons)(u0Compiler$Lexer_Test$position, (c0Core$Cons)(u0Compiler$Lexer_Test$textLiterals, (c0Core$Cons)(u0Compiler$Lexer_Test$numberLiterals, (c0Core$Cons)(u0Compiler$Lexer_Test$recordLiterals, c0Core$Nil)))))))))));

const u0Compiler$MakeCanonical_Test$codeTest = (($0, $1, $2, $3) => {
  return (i1Test$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const u0Compiler$MakeCanonical_Test$params = (($errorModule) => {
  return ({
    errorModule: $errorModule,
    resolvePars: (($pos) => {
      return u0Compiler$TestHelpers$resolvePars;
    }),
    umr: u0Compiler$TestHelpers$moduleUmr,
  });
});

const u0Compiler$MakeCanonical_Test$textToModule = (($code) => {
  return (u0Compiler$TestHelpers$resErrorToStrippedText)(((($0) => {
    return (u0Compiler$MakeCanonical$textToCanonicalModule)(true, $0);
  }))((u0Compiler$MakeCanonical_Test$params)((u0Compiler$TestHelpers$errorModule)($code))));
});

const u0Compiler$MakeCanonical_Test$firstDefinition = (($code) => {
  return ((c0Result$onOk)((($mod) => {
    return ((($0) => {
      return (c0Result$fromMaybe)("firstDefinition fail", $0);
    }))((c0List$head)((c0Dict$values)($mod.valueDefs)));
  })))((u0Compiler$MakeCanonical_Test$textToModule)($code));
});

const u0Compiler$MakeCanonical_Test$firstEvaluation = (($name) => {
  return (($code) => {
    return ((c0Result$onOk)((($def) => {
      return (c0Maybe$toResult)("body is 'nothing", $def.maybeBody);
    })))((u0Compiler$MakeCanonical_Test$firstDefinition)($code));
  });
});

const u0Compiler$MakeCanonical_Test$annotations = (i1Test$Group)("Annotations", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("annotation on unique value", "x =\n  !a as Number =\n    3\n  a", u0Compiler$MakeCanonical_Test$firstDefinition, i1Test$isOk), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("annotation on immutable value", "b as Number =\n  3", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), i1Test$isOk), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("annotation of recycling function", "b as fn @List a: !List a =\n  3", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), i1Test$isOk), c0Core$Nil))));

const u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps = (($0) => {
  return ((($0) => {
    return (c0Result$map)((($v) => {
      const $0 = $v;
      return (Object.assign)({}, $0, ({
        directDeps: c0Dict$empty,
      }));
    }), $0);
  }))((u0Compiler$MakeCanonical_Test$firstDefinition)($0));
});

const u0Compiler$MakeCanonical_Test$p = c0Compiler$Pos$T;

const u0Compiler$MakeCanonical_Test$argumentPlaceholders = (i1Test$Group)("Argument placeholders", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Base", "f = f __ __", u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps, (i1Test$isOkAndEqualTo)(({
  directDeps: c0Dict$empty,
  maybeAnnotation: c0Maybe$Nothing,
  maybeBody: (c0Maybe$Just)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(0), (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(1), c0Core$Nil)), (c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefGlobal)((u0Compiler$TestHelpers$moduleUsr)("f"))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(0))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(1))), c0Core$Nil))))),
  name: "f",
  namePos: u0Compiler$MakeCanonical_Test$p,
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Pipelines work with placeholders", "f = __ >> a >> b", (u0Compiler$MakeCanonical_Test$firstEvaluation)("f"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(0), c0Core$Nil), (c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefGlobal)((u0Compiler$TestHelpers$moduleUsr)("b"))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefGlobal)((u0Compiler$TestHelpers$moduleUsr)("a"))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(0))), c0Core$Nil))), c0Core$Nil))))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("try..as", "f = try __ as \"\": 1", (u0Compiler$MakeCanonical_Test$firstEvaluation)("f"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(0), c0Core$Nil), (c0Compiler$CanonicalAst$Try)(u0Compiler$MakeCanonical_Test$p, ({
  patternsAndExpressions: (c0Core$Cons)(({
    first: c0Compiler$Ast$Imm,
    second: (c0Compiler$CanonicalAst$PatternLiteralText)(u0Compiler$MakeCanonical_Test$p, ""),
    third: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1),
  }), c0Core$Nil),
  value: (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(0)),
}))))), c0Core$Nil))));

const u0Compiler$MakeCanonical_Test$shouldHaveSameAB = (($getter) => {
  return (i1Test$freeform)((($2) => {
    const $a = $2.first;
    const $b = $2.second;
    return ((sp_equal)(($getter)($a), ($getter)($b))
      ? c0Maybe$Nothing
      : (c0Maybe$Just)(((($0) => {
        return (c0Text$join)("\n", $0);
      }))((c0Core$Cons)("The two don't match:", (c0Core$Cons)((sp_toHuman)(($getter)($a)), (c0Core$Cons)((sp_toHuman)(($getter)($b)), c0Core$Nil))))));
  }));
});

const u0Compiler$MakeCanonical_Test$transformAB = (($code) => {
  const $findAB = (($mod) => {
    const $3 = ((($0) => {
      return (list_sortBy)((($def) => {
        return $def.pattern;
      }), $0);
    }))((c0Dict$values)($mod.valueDefs));
    return (((($3)[0] === "$Cons") && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil")))
      ? ((() => {
        const $a = ($3)[1];
        const $b = (($3)[2])[1];
        return (c0Maybe$Just)(({
          first: $a,
          second: $b,
        }));
      }))()
      : (true
        ? c0Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical_Test.sp 81:8', (sp_toHuman)($3))));
  });
  return ((c0Result$onOk)((($x) => {
    return ((($0) => {
      return (c0Result$fromMaybe)("findAB fail", $0);
    }))(($findAB)($x));
  })))((u0Compiler$MakeCanonical_Test$textToModule)($code));
});

const u0Compiler$MakeCanonical_Test$binops = (i1Test$Group)("Binops", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("left associativity", "a = v >> f >> g\nb = (v >> f) >> g", u0Compiler$MakeCanonical_Test$transformAB, (u0Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("right associativity", "a = v :: f :: g\nb = v :: (f :: g)", u0Compiler$MakeCanonical_Test$transformAB, (u0Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("precedence", "a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4", u0Compiler$MakeCanonical_Test$transformAB, (u0Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("SKIP (burned out) Pipe optimization 1", "a = b >> a __\nb = a b", u0Compiler$MakeCanonical_Test$transformAB, (u0Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("SKIP (burned out) Pipe optimization 2", "a = (__ >> __ >> __) a b c\nb = a >> b >> c", u0Compiler$MakeCanonical_Test$transformAB, (u0Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.maybeBody;
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Op chain definition and optimization", "a = __ + __ + 3 + __", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(0), (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(1), (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPlaceholder)(2), c0Core$Nil))), (c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefGlobal)(u0Compiler$CoreDefs$add.usr)), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(0))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefGlobal)(u0Compiler$CoreDefs$add.usr)), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(1))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefGlobal)(u0Compiler$CoreDefs$add.usr)), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 3)), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefPlaceholder)(2))), c0Core$Nil)))), c0Core$Nil)))), c0Core$Nil)))))), c0Core$Nil)))))));

const u0Compiler$TestHelpers$rootLocal = (($name) => {
  return (c0Compiler$Ast$RefGlobal)((c0Compiler$Meta$USR)(u0Compiler$TestHelpers$moduleUmr, $name));
});

const u0Compiler$MakeCanonical_Test$functions = (i1Test$Group)("Functions", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("[rec] function with call", "a =\n    fn x:\n        add x 1", (u0Compiler$MakeCanonical_Test$firstEvaluation)("f"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPattern)(c0Compiler$Ast$Imm, (c0Compiler$CanonicalAst$PatternAny)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)("x"), c0Maybe$Nothing)), c0Core$Nil), (c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("add")), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefLocal)("x"))), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1)), c0Core$Nil)))))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("[rec] function with two arguments", "f =\n  fn a, b: 1", (u0Compiler$MakeCanonical_Test$firstEvaluation)("f"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPattern)(c0Compiler$Ast$Imm, (c0Compiler$CanonicalAst$PatternAny)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)("a"), c0Maybe$Nothing)), (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPattern)(c0Compiler$Ast$Imm, (c0Compiler$CanonicalAst$PatternAny)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)("b"), c0Maybe$Nothing)), c0Core$Nil)), (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1)))), c0Core$Nil)));

const u0Compiler$TestHelpers$caBool = (c0Compiler$CanonicalAst$TypeNamed)(c0Compiler$Pos$T, (u0Compiler$CoreDefs$usr)("Bool"), c0Core$Nil);

const u0Compiler$MakeCanonical_Test$lists = (i1Test$Group)("Lists", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("list type sugar", "l as [ Bool ] =\n  l", u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps, (i1Test$isOkAndEqualTo)(({
  directDeps: c0Dict$empty,
  maybeAnnotation: (c0Maybe$Just)(({
    raw: (u0Compiler$CoreDefs$listType)(u0Compiler$TestHelpers$caBool),
    tyvars: c0Dict$empty,
    univars: c0Dict$empty,
  })),
  maybeBody: (c0Maybe$Just)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("l"))),
  name: "l",
  namePos: u0Compiler$MakeCanonical_Test$p,
}))), c0Core$Nil));

const u0Compiler$MakeCanonical_Test$localDef = (($name, $body) => {
  return ({
    body: $body,
    pattern: (c0Compiler$CanonicalAst$PatternAny)(c0Compiler$Pos$G, (c0Maybe$Just)($name), c0Maybe$Nothing),
    uni: c0Compiler$Ast$Imm,
  });
});

const u0Compiler$MakeCanonical_Test$moduleAndAttributePaths = ((() => {
  const $accept = (($s) => {
    return (u0Compiler$MakeCanonical_Test$codeTest)($s, ("a = " + $s), u0Compiler$MakeCanonical_Test$firstDefinition, i1Test$isOk);
  });
  const $reject = (($s, $m) => {
    return (u0Compiler$MakeCanonical_Test$codeTest)($s, ("a = " + $s), u0Compiler$MakeCanonical_Test$firstDefinition, (i1Test$errorContains)((c0Core$Cons)($m, c0Core$Nil)));
  });
  return (i1Test$Group)("Module and Attribute Paths", (c0Core$Cons)(($accept)("blah.blah.blah"), (c0Core$Cons)(($reject)("Blah.Blah.blah", "attribute"), (c0Core$Cons)(($reject)("List.blah.Blah", "lower"), (c0Core$Cons)(($reject)("List..blah", "space"), (c0Core$Cons)(($reject)(".Blah", "must start with a lowercase"), (c0Core$Cons)(($reject)(".blah.blah", "shorthand"), (c0Core$Cons)(($reject)(".blah", "shorthand"), (c0Core$Cons)(($reject)("...", ""), (c0Core$Cons)(($accept)("x .. y"), c0Core$Nil))))))))));
}))();

const u0Compiler$MakeCanonical_Test$nonFunction = (i1Test$Group)("NonFunction", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("one", "funz as a with a NonFunction =\n    1", u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps, (i1Test$isOkAndEqualTo)(({
  directDeps: c0Dict$empty,
  maybeAnnotation: (c0Maybe$Just)(({
    raw: (c0Compiler$CanonicalAst$TypeAnnotationVariable)(u0Compiler$MakeCanonical_Test$p, "a"),
    tyvars: (c0Dict$ofOne)("a", ({
      nonFn: (c0Maybe$Just)(c0Compiler$Pos$T),
    })),
    univars: c0Dict$empty,
  })),
  maybeBody: (c0Maybe$Just)((c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1)),
  name: "funz",
  namePos: u0Compiler$MakeCanonical_Test$p,
}))), c0Core$Nil));

const u0Compiler$MakeCanonical_Test$numbers = (i1Test$Group)("Numbers", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Percent", "a = 1%", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 0.01))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Underscore", "a = 1_000_000", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, (1000 * 1000)))), c0Core$Nil)));

const u0Compiler$MakeCanonical_Test$patterns = (i1Test$Group)("Patterns", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Record patterns can be partial", "a =\n  { with c } = d", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), i1Test$isOk), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("[reg] record patterns are NOT extensible", "a =\n  { b with c } = d", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$errorContains)((c0Core$Cons)("extend pattern", c0Core$Nil))), c0Core$Nil)));

const u0Compiler$MakeCanonical_Test$pipes = (i1Test$Group)("Pipes", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("sendLeft is inlined", "a = thing >> function", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("function")), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("thing"))), c0Core$Nil)))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("sendRight is inlined", "a = function << thing", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Call)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("function")), (c0Core$Cons)((c0Compiler$CanonicalAst$ArgumentExpression)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("thing"))), c0Core$Nil)))), c0Core$Nil)));

const u0Compiler$MakeCanonical_Test$polymorphicUniques = (i1Test$Group)("Polymorphic Uniques", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("In pattern", "f =\n    fn 1?a:\n    1?b = a\n    b", u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps, (i1Test$isOkAndEqualTo)(({
  directDeps: c0Dict$empty,
  maybeAnnotation: c0Maybe$Nothing,
  maybeBody: (c0Maybe$Just)((c0Compiler$CanonicalAst$Fn)(u0Compiler$MakeCanonical_Test$p, (c0Core$Cons)((c0Compiler$CanonicalAst$ParameterPattern)((c0Compiler$Ast$Depends)(1), (c0Compiler$CanonicalAst$PatternAny)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)("a"), c0Maybe$Nothing)), c0Core$Nil), (c0Compiler$CanonicalAst$LetIn)(({
    body: (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefLocal)("a")),
    pattern: (c0Compiler$CanonicalAst$PatternAny)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)("b"), c0Maybe$Nothing),
    uni: (c0Compiler$Ast$Depends)(1),
  }), (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (c0Compiler$Ast$RefLocal)("b"))))),
  name: "f",
  namePos: u0Compiler$MakeCanonical_Test$p,
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("In annotation", "isOk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = meh", (($t) => {
  return ((c0Result$onOk)((($def) => {
    const $3 = $def.maybeAnnotation;
    return ((($3)[0] === "$Just")
      ? ((() => {
        const $ann = ($3)[1];
        return (c0Result$Ok)($ann.univars);
      }))()
      : (true
        ? (c0Result$Err)("no ann")
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical_Test.sp 782:17', (sp_toHuman)($3))));
  })))((u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps)($t));
}), (i1Test$isOkAndEqualTo)((c0Set$fromList)((c0Core$Cons)(1, (c0Core$Cons)(2, c0Core$Nil))))), c0Core$Nil)));

const u0Compiler$MakeCanonical_Test$records = (i1Test$Group)("Records", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("functional update", "a = { m with b, c = 1 }", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$LetIn)((u0Compiler$MakeCanonical_Test$localDef)("0", (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("m"))), (c0Compiler$CanonicalAst$Record)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)((c0Compiler$CanonicalAst$Variable)(c0Compiler$Pos$G, (c0Compiler$Ast$RefLocal)("0"))), (c0Dict$fromList)((c0Core$Cons)(({
  first: "c",
  second: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1),
}), (c0Core$Cons)(({
  first: "b",
  second: (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("b")),
}), c0Core$Nil))))))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Update shorthand", "b = { a with y = .x }", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$LetIn)((u0Compiler$MakeCanonical_Test$localDef)("0", (c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("a"))), (c0Compiler$CanonicalAst$Record)(u0Compiler$MakeCanonical_Test$p, (c0Maybe$Just)((c0Compiler$CanonicalAst$Variable)(c0Compiler$Pos$G, (c0Compiler$Ast$RefLocal)("0"))), (c0Dict$fromList)((c0Core$Cons)(({
  first: "y",
  second: (c0Compiler$CanonicalAst$RecordAccess)(u0Compiler$MakeCanonical_Test$p, "x", (c0Compiler$CanonicalAst$Variable)(c0Compiler$Pos$G, (c0Compiler$Ast$RefLocal)("0"))),
}), c0Core$Nil)))))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("annotation, extensible", "a as { b with x as Bool } =\n  a", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$errorContains)((c0Core$Cons)("disabled", c0Core$Nil))), c0Core$Nil))));

const u0Compiler$MakeCanonical_Test$shadowing = (i1Test$Group)("Shadowing", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Root", "a = 0\na = 0", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$errorContains)((c0Core$Cons)("`a`", c0Core$Nil))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Local", "a = 0\nb =\n    a = 0\n    a + a", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), (i1Test$errorContains)((c0Core$Cons)("`a`", c0Core$Nil))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Function parameter", "a = 0\nb = fn a: a + a", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), (i1Test$errorContains)((c0Core$Cons)("`a`", c0Core$Nil))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("try..as", "a = 0\nb = try x as\n     a: 0", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), (i1Test$errorContains)((c0Core$Cons)("`a`", (c0Core$Cons)("already been defined", c0Core$Nil)))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Types", "var X = 'meh\nX = {}\nb = 0", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), (i1Test$errorContains)((c0Core$Cons)("X", (c0Core$Cons)("twice", c0Core$Nil)))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Constructors", "var A = 'meh\nvar B = 'meh\nb = 0", (u0Compiler$MakeCanonical_Test$firstEvaluation)("b"), (i1Test$errorContains)((c0Core$Cons)("meh", (c0Core$Cons)("already been defined", c0Core$Nil)))), c0Core$Nil)))))));

const u0Compiler$MakeCanonical_Test$tuples = (i1Test$Group)("Tuples", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("tuple2", "a = 1 & 2", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Record)(u0Compiler$MakeCanonical_Test$p, c0Maybe$Nothing, (c0Dict$fromList)((c0Core$Cons)(({
  first: "first",
  second: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1),
}), (c0Core$Cons)(({
  first: "second",
  second: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 2),
}), c0Core$Nil)))))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("tuple3", "a = 1 & 2 & 3", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$isOkAndEqualTo)((c0Compiler$CanonicalAst$Record)(u0Compiler$MakeCanonical_Test$p, c0Maybe$Nothing, (c0Dict$fromList)((c0Core$Cons)(({
  first: "first",
  second: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 1),
}), (c0Core$Cons)(({
  first: "second",
  second: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 2),
}), (c0Core$Cons)(({
  first: "third",
  second: (c0Compiler$CanonicalAst$LiteralNumber)(u0Compiler$MakeCanonical_Test$p, 3),
}), c0Core$Nil))))))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("tuple4", "a = 1 & 2 & 3 & 4", (u0Compiler$MakeCanonical_Test$firstEvaluation)("a"), (i1Test$errorContains)((c0Core$Cons)("use a record", c0Core$Nil))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Tuple2 type", "a as Number & Number =\n  a", u0Compiler$MakeCanonical_Test$firstDefinitionStripDeps, (i1Test$isOkAndEqualTo)(({
  directDeps: c0Dict$empty,
  maybeAnnotation: (c0Maybe$Just)(({
    raw: ((($0) => {
      return (c0Compiler$CanonicalAst$TypeRecord)(u0Compiler$MakeCanonical_Test$p, $0);
    }))(((($0) => {
      return (c0Dict$insert)("second", u0Compiler$TestHelpers$caNumber, $0);
    }))(((($0) => {
      return (c0Dict$insert)("first", u0Compiler$TestHelpers$caNumber, $0);
    }))(c0Dict$empty))),
    tyvars: c0Dict$empty,
    univars: c0Dict$empty,
  })),
  maybeBody: (c0Maybe$Just)((c0Compiler$CanonicalAst$Variable)(u0Compiler$MakeCanonical_Test$p, (u0Compiler$TestHelpers$rootLocal)("a"))),
  name: "a",
  namePos: u0Compiler$MakeCanonical_Test$p,
}))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("tuple4, type", "a as Blah & Blah & Blah & Blah =\n  a", u0Compiler$MakeCanonical_Test$firstDefinition, (i1Test$errorContains)((c0Core$Cons)("use a record", c0Core$Nil))), c0Core$Nil))))));

const u0Compiler$MakeCanonical_Test$varTypes = (i1Test$Group)("Variant types", (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Tuples op precedence", "var A = 'x Bool & Bool", u0Compiler$MakeCanonical_Test$textToModule, (i1Test$errorContains)((c0Core$Cons)("I need a 'constructor", c0Core$Nil))), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("Tuples op precedence works with parens", "var A = 'x (Bool & Bool)", u0Compiler$MakeCanonical_Test$textToModule, i1Test$isOk), (c0Core$Cons)((u0Compiler$MakeCanonical_Test$codeTest)("SKIP (make `var` a keyword?) [reg] Should reject uppercase arg name", "var Outcome Token output = 'a", u0Compiler$MakeCanonical_Test$textToModule, (i1Test$errorContains)((c0Core$Cons)("must start with a lowercase", c0Core$Nil))), c0Core$Nil))));

const u0Compiler$MakeCanonical_Test$tests = (i1Test$Group)("MakeCanonical", (c0Core$Cons)(u0Compiler$MakeCanonical_Test$varTypes, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$binops, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$tuples, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$lists, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$moduleAndAttributePaths, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$records, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$patterns, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$annotations, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$pipes, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$functions, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$nonFunction, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$argumentPlaceholders, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$polymorphicUniques, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$numbers, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$shadowing, c0Core$Nil))))))))))))))));

const u0Compiler$Parser_Test$e = (($0) => {
  return (c0Compiler$FormattableAst$Expression)(c0Core$Nil, c0Compiler$Pos$T, $0);
});

const u0Compiler$Parser_Test$annotatedVariable = (($name, $type) => {
  return (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Lowercase)(({
    attrPath: c0Core$Nil,
    maybeModule: c0Maybe$Nothing,
    maybeType: (c0Maybe$Just)($type),
    name: $name,
  })));
});

const u0Compiler$Parser_Test$codeTest = (($0, $1, $2, $3) => {
  return (i1Test$codeTest)(sp_toHuman, $0, $1, $2, $3);
});

const u0Compiler$Parser_Test$asDefinition = (($s) => {
  return ((($s)[0] === "$ValueDef")
    ? ((() => {
      const $a = ($s)[1];
      return (c0Result$Ok)($a);
    }))()
    : (true
      ? (c0Result$Err)("Test says: no def")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 32:4', (sp_toHuman)($s))));
});

const u0Compiler$Parser_Test$firstStatement = (($code) => {
  const $grabFirst = (($stats) => {
    return ((($stats)[0] === "$Nil")
      ? (c0Result$Err)("Test says: no statements")
      : ((($stats)[0] === "$Cons")
        ? ((() => {
          const $head = ($stats)[1];
          const $tail = ($stats)[2];
          return (c0Result$Ok)($head);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 48:8', (sp_toHuman)($stats))));
  });
  return ((c0Result$onOk)($grabFirst))((u0Compiler$TestHelpers$resErrorToStrippedText)((u0Compiler$Parser$textToFormattableModule)(({
    errorModule: ({
      content: $code,
      fsPath: "Test",
    }),
    keepComments: true,
    stripLocations: true,
  }))));
});

const u0Compiler$Parser_Test$firstDefinition = (($code) => {
  return ((c0Result$onOk)(u0Compiler$Parser_Test$asDefinition))((u0Compiler$Parser_Test$firstStatement)($code));
});

const u0Compiler$Parser_Test$lowercase = (($name) => {
  return (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Lowercase)(({
    attrPath: c0Core$Nil,
    maybeModule: c0Maybe$Nothing,
    maybeType: c0Maybe$Nothing,
    name: $name,
  })));
});

const u0Compiler$Parser_Test$faBinop = (($op) => {
  return ({
    comments: c0Core$Nil,
    line: -(1),
    pos: c0Compiler$Pos$T,
    precedence: $op.precedence,
    symbol: $op.symbol,
    usr: $op.usr,
  });
});

const u0Compiler$Parser_Test$tuple = (($a, $b) => {
  return (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$BinopChain)(c0Compiler$Op$precedence_tuple, ({
    first: $a,
    second: (c0Core$Cons)(({
      first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$tuple),
      second: $b,
    }), c0Core$Nil),
  })));
});

const u0Compiler$Parser_Test$annotations = (i1Test$Group)("Annotations", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Trivial case", "a as b =\n    z", u0Compiler$Parser_Test$firstDefinition, (i1Test$isOkAndEqualTo)(({
  body: (u0Compiler$Parser_Test$lowercase)("z"),
  nonFn: c0Core$Nil,
  pattern: (u0Compiler$Parser_Test$annotatedVariable)("a", (u0Compiler$Parser_Test$lowercase)("b")),
}))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Tuple precedence", "a as fn int & int: bool =\n    b", u0Compiler$Parser_Test$firstDefinition, (i1Test$isOkAndEqualTo)(({
  body: (u0Compiler$Parser_Test$lowercase)("b"),
  nonFn: c0Core$Nil,
  pattern: (u0Compiler$Parser_Test$annotatedVariable)("a", (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Inline, (c0Core$Cons)((u0Compiler$Parser_Test$tuple)((u0Compiler$Parser_Test$lowercase)("int"), (u0Compiler$Parser_Test$lowercase)("int")), c0Core$Nil), (u0Compiler$Parser_Test$lowercase)("bool")))),
}))), c0Core$Nil)));

const u0Compiler$Parser_Test$asEvaluation = (($s) => {
  return ((($s)[0] === "$Evaluation")
    ? ((() => {
      const $a = ($s)[1];
      return (c0Result$Ok)($a);
    }))()
    : (true
      ? (c0Result$Err)("Test says: no eval")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 39:4', (sp_toHuman)($s))));
});

const u0Compiler$Parser_Test$firstEvaluation = (($code) => {
  return ((c0Result$onOk)(u0Compiler$Parser_Test$asEvaluation))((u0Compiler$Parser_Test$firstStatement)($code));
});

const u0Compiler$Parser_Test$firstEvaluationOfDefinition = (($code) => {
  return ((c0Result$onOk)((($def) => {
    return (c0Result$Ok)($def.body);
  })))(((c0Result$onOk)(u0Compiler$Parser_Test$asDefinition))((u0Compiler$Parser_Test$firstStatement)($code)));
});

const u0Compiler$Parser_Test$binops = ((() => {
  const $sendBtoC = (u0Compiler$Parser_Test$e)(((($0) => {
    return (c0Compiler$FormattableAst$BinopChain)(c0Compiler$Op$precedence_pipe, $0);
  }))(({
    first: (u0Compiler$Parser_Test$lowercase)("b"),
    second: (c0Core$Cons)(({
      first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$sendRight),
      second: (u0Compiler$Parser_Test$lowercase)("c"),
    }), c0Core$Nil),
  })));
  const $sendBtoCtoD = (u0Compiler$Parser_Test$e)(((($0) => {
    return (c0Compiler$FormattableAst$BinopChain)(c0Compiler$Op$precedence_pipe, $0);
  }))(({
    first: (u0Compiler$Parser_Test$lowercase)("b"),
    second: (c0Core$Cons)(({
      first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$sendRight),
      second: (u0Compiler$Parser_Test$lowercase)("c"),
    }), (c0Core$Cons)(({
      first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$sendRight),
      second: (u0Compiler$Parser_Test$lowercase)("d"),
    }), c0Core$Nil)),
  })));
  return (i1Test$Group)("Binops", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("no indent", "b >> c", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)($sendBtoC)), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("pipe indent 1", "b\n  >> c", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)($sendBtoC)), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("pipe indent 2", "b\n  >> c\n  >> d", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)($sendBtoCtoD)), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("pyramid indent", "b\n  >> c\n    >> d", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)($sendBtoCtoD)), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("no indent", "x =\n    b\n    >>\n    c", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)($sendBtoC)), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("SKIP (I'm tired) Starting", "x = >> c", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$errorContains)((c0Core$Cons)("TODO", c0Core$Nil))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("SKIP (I'm tired) Double", "x = a >> >> c", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$errorContains)((c0Core$Cons)("TODO", c0Core$Nil))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("SKIP (I'm tired) Ending", "x = a >>", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$errorContains)((c0Core$Cons)("TODO", c0Core$Nil))), c0Core$Nil)))))))));
}))();

const u0Compiler$Parser_Test$comments = (i1Test$Group)("Comments", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] trailing", "a =\n  b\n  # c", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), c0Core$Nil));

const u0Compiler$Parser_Test$constructor = (($name) => {
  return (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Constructor)(({
    maybeModule: c0Maybe$Nothing,
    name: $name,
  })));
});

const u0Compiler$Parser_Test$functions = (i1Test$Group)("functions", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Inline body", "fn a, b: 3", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Inline, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("a"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), c0Core$Nil)), (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$LiteralNumber)(false, "3")))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Indented body", "fn a:\n    3", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Indented, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("a"), c0Core$Nil), (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$LiteralNumber)(false, "3")))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Sibling nesting", "z =\n  fn a:\n  fn b:\n  3", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Aligned, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("a"), c0Core$Nil), (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Aligned, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), c0Core$Nil), (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$LiteralNumber)(false, "3")))))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Tuple vs lambda precedence", "fn a & b: a", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Inline, (c0Core$Cons)((u0Compiler$Parser_Test$tuple)((u0Compiler$Parser_Test$lowercase)("a"), (u0Compiler$Parser_Test$lowercase)("b")), c0Core$Nil), (u0Compiler$Parser_Test$lowercase)("a"))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] Pass to function without parens", "xxx fn y: y", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("xxx"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Inline, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("y"), c0Core$Nil), (u0Compiler$Parser_Test$lowercase)("y"))), c0Core$Nil))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Pass to function without parens, below", "z =\n  xxx fn y:\n  y", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("xxx"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Aligned, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("y"), c0Core$Nil), (u0Compiler$Parser_Test$lowercase)("y"))), c0Core$Nil))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("SKIP Function should not swallow pipeline", "value\n>> map fn x: blah\n>> sblorp", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)(((($0) => {
  return (c0Compiler$FormattableAst$BinopChain)(c0Compiler$Op$precedence_pipe, $0);
}))(({
  first: (u0Compiler$Parser_Test$lowercase)("value"),
  second: (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$sendRight),
    second: (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("map"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Aligned, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("x"), c0Core$Nil), (u0Compiler$Parser_Test$lowercase)("blah"))), c0Core$Nil))),
  }), (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$sendRight),
    second: (u0Compiler$Parser_Test$lowercase)("sblorp"),
  }), c0Core$Nil)),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] Fn with multiple indented statements", "fn x:\n  x\n  x", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Indented, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("x"), c0Core$Nil), (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Statements)((c0Core$Cons)((c0Compiler$FormattableAst$Evaluation)((u0Compiler$Parser_Test$lowercase)("x")), (c0Core$Cons)((c0Compiler$FormattableAst$Evaluation)((u0Compiler$Parser_Test$lowercase)("x")), c0Core$Nil)))))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] Fn with definition", "a =\n    fn x:\n    y = 1\n    x", u0Compiler$Parser_Test$firstDefinition, (i1Test$isOkAndEqualTo)(({
  body: (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Aligned, (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("x"), c0Core$Nil), (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Statements)((c0Core$Cons)((c0Compiler$FormattableAst$ValueDef)(({
    body: (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$LiteralNumber)(false, "1")),
    nonFn: c0Core$Nil,
    pattern: (u0Compiler$Parser_Test$lowercase)("y"),
  })), (c0Core$Cons)((c0Compiler$FormattableAst$Evaluation)((u0Compiler$Parser_Test$lowercase)("x")), c0Core$Nil)))))),
  nonFn: c0Core$Nil,
  pattern: (u0Compiler$Parser_Test$lowercase)("a"),
}))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] argument not being recognized?", "@b += 1", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)(((($0) => {
  return (c0Compiler$FormattableAst$BinopChain)(c0Compiler$Op$precedence_mutop, $0);
}))(({
  first: (u0Compiler$Parser_Test$e)(((($0) => {
    return (c0Compiler$FormattableAst$UnopCall)(c0Compiler$Op$UnopRecycle, $0);
  }))((u0Compiler$Parser_Test$lowercase)("b"))),
  second: (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$faBinop)(u0Compiler$CoreDefs$mutableAdd),
    second: (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$LiteralNumber)(false, "1")),
  }), c0Core$Nil),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] multiple lines, compact", "x =\n    a = pop a\n    b = 1", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), c0Core$Nil))))))))))));

const u0Compiler$Parser_Test$ifs = (i1Test$Group)("Ifs", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Inline", "if a then b else c", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$If)(({
  condition: (u0Compiler$Parser_Test$lowercase)("a"),
  false: (u0Compiler$Parser_Test$lowercase)("c"),
  isMultiline: false,
  true: (u0Compiler$Parser_Test$lowercase)("b"),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Multiline, formatted", "z =\n  if a then\n      b\n  else\n      c", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$If)(({
  condition: (u0Compiler$Parser_Test$lowercase)("a"),
  false: (u0Compiler$Parser_Test$lowercase)("c"),
  isMultiline: true,
  true: (u0Compiler$Parser_Test$lowercase)("b"),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Multiline, compact", "z =\n  if a then b\n  else c", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$If)(({
  condition: (u0Compiler$Parser_Test$lowercase)("a"),
  false: (u0Compiler$Parser_Test$lowercase)("c"),
  isMultiline: true,
  true: (u0Compiler$Parser_Test$lowercase)("b"),
}))))), c0Core$Nil))));

const u0Compiler$Parser_Test$lists = (i1Test$Group)("Lists", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Empty", "[]", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(false, c0Core$Nil)))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Inline", "[a, b]", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(false, (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("a"),
}), (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("b"),
}), c0Core$Nil)))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Multiline", "z =\n  [\n  , a\n  , b\n  ]", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(true, (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("a"),
}), (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("b"),
}), c0Core$Nil)))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Ancient egyptian", "z =\n  blah [\n  , a\n  , b\n  ]", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("blah"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(true, (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("a"),
}), (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("b"),
}), c0Core$Nil)))), c0Core$Nil))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Dots", "[a..., b, c...]", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(false, (c0Core$Cons)(({
  first: true,
  second: (u0Compiler$Parser_Test$lowercase)("a"),
}), (c0Core$Cons)(({
  first: false,
  second: (u0Compiler$Parser_Test$lowercase)("b"),
}), (c0Core$Cons)(({
  first: true,
  second: (u0Compiler$Parser_Test$lowercase)("c"),
}), c0Core$Nil))))))), c0Core$Nil))))));

const u0Compiler$Parser_Test$parens = (i1Test$Group)("Parens", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Can exist on multiple lines even when useless", "tests =\n    (Ok\n    )", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Can exist on multiple lines", "tests =\n    blah\n        (Ok\n        )", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), c0Core$Nil)));

const u0Compiler$Parser_Test$uppercase = (($name) => {
  return (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Uppercase)(({
    maybeModule: c0Maybe$Nothing,
    name: $name,
  })));
});

const u0Compiler$Parser_Test$patterns = (i1Test$Group)("Patterns", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("List unpacking", "[a as Int, b] = x", u0Compiler$Parser_Test$firstDefinition, (i1Test$isOkAndEqualTo)(({
  body: (u0Compiler$Parser_Test$lowercase)("x"),
  nonFn: c0Core$Nil,
  pattern: (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(false, (c0Core$Cons)(({
    first: false,
    second: (u0Compiler$Parser_Test$annotatedVariable)("a", (u0Compiler$Parser_Test$uppercase)("Int")),
  }), (c0Core$Cons)(({
    first: false,
    second: (u0Compiler$Parser_Test$lowercase)("b"),
  }), c0Core$Nil)))),
}))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Record argument unpacking", "fn { with a, b }:\n  x", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Fn)(c0Compiler$FormattableAst$Indented, (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: c0Maybe$Nothing,
    name: (u0Compiler$Parser_Test$lowercase)("a"),
  }), (c0Core$Cons)(({
    maybeExpr: c0Maybe$Nothing,
    name: (u0Compiler$Parser_Test$lowercase)("b"),
  }), c0Core$Nil)),
  isMultiline: false,
  maybeExtension: (c0Maybe$Just)(c0Maybe$Nothing),
}))), c0Core$Nil), (u0Compiler$Parser_Test$lowercase)("x"))))), c0Core$Nil)));

const u0Compiler$Parser_Test$records = (i1Test$Group)("Records", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Empty", "{}", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: c0Core$Nil,
  isMultiline: false,
  maybeExtension: c0Maybe$Nothing,
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Inline", "{ x = b }", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: (c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("b")),
    name: (u0Compiler$Parser_Test$lowercase)("x"),
  }), c0Core$Nil),
  isMultiline: false,
  maybeExtension: c0Maybe$Nothing,
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Multiline", "z =\n  {\n  , x = a\n  , y = b\n  }", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: (c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("a")),
    name: (u0Compiler$Parser_Test$lowercase)("x"),
  }), (c0Core$Cons)(({
    maybeExpr: (c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("b")),
    name: (u0Compiler$Parser_Test$lowercase)("y"),
  }), c0Core$Nil)),
  isMultiline: true,
  maybeExtension: c0Maybe$Nothing,
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Pattern extension", "z =\n  { with\n  , x = a\n  }", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: (c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("a")),
    name: (u0Compiler$Parser_Test$lowercase)("x"),
  }), c0Core$Nil),
  isMultiline: true,
  maybeExtension: (c0Maybe$Just)(c0Maybe$Nothing),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Expression extension", "q =\n  { z with\n  , x = a\n  }", u0Compiler$Parser_Test$firstEvaluationOfDefinition, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: (c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("a")),
    name: (u0Compiler$Parser_Test$lowercase)("x"),
  }), c0Core$Nil),
  isMultiline: true,
  maybeExtension: (c0Maybe$Just)((c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("z"))),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Type or annotated implicit value", "{ x as Bool }", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: c0Maybe$Nothing,
    name: (u0Compiler$Parser_Test$annotatedVariable)("x", (u0Compiler$Parser_Test$uppercase)("Bool")),
  }), c0Core$Nil),
  isMultiline: false,
  maybeExtension: c0Maybe$Nothing,
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Type or annotated explicit value", "{ x as Bool = y }", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Record)(({
  attrs: (c0Core$Cons)(({
    maybeExpr: (c0Maybe$Just)((u0Compiler$Parser_Test$lowercase)("y")),
    name: (u0Compiler$Parser_Test$annotatedVariable)("x", (u0Compiler$Parser_Test$uppercase)("Bool")),
  }), c0Core$Nil),
  isMultiline: false,
  maybeExtension: c0Maybe$Nothing,
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] real-world use", "a =\n  { state with\n      , pos = endPos\n      , code = rest\n      , accum =\n          [\n          , { kind = Token.Comment\n            , start = startPos\n            , end = endPos\n            }\n          , state.accum...\n          ]\n  }", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), c0Core$Nil)))))))));

const u0Compiler$Parser_Test$tries = (i1Test$Group)("Try", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Multiline, formatted", "try a as\n   b:\n    c\n   d:\n    e", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Try)(({
  patterns: (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$lowercase)("b"),
    second: (u0Compiler$Parser_Test$lowercase)("c"),
  }), (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$lowercase)("d"),
    second: (u0Compiler$Parser_Test$lowercase)("e"),
  }), c0Core$Nil)),
  value: (u0Compiler$Parser_Test$lowercase)("a"),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Multiline, compact", "try a as\n   b: c\n   d: e", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Try)(({
  patterns: (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$lowercase)("b"),
    second: (u0Compiler$Parser_Test$lowercase)("c"),
  }), (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$lowercase)("d"),
    second: (u0Compiler$Parser_Test$lowercase)("e"),
  }), c0Core$Nil)),
  value: (u0Compiler$Parser_Test$lowercase)("a"),
}))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Nested", "try a as\n   b:\n    try c as\n         q:\n            q\n   d:\n    e", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Try)(({
  patterns: (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$lowercase)("b"),
    second: (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Try)(({
      patterns: (c0Core$Cons)(({
        first: (u0Compiler$Parser_Test$lowercase)("q"),
        second: (u0Compiler$Parser_Test$lowercase)("q"),
      }), c0Core$Nil),
      value: (u0Compiler$Parser_Test$lowercase)("c"),
    }))),
  }), (c0Core$Cons)(({
    first: (u0Compiler$Parser_Test$lowercase)("d"),
    second: (u0Compiler$Parser_Test$lowercase)("e"),
  }), c0Core$Nil)),
  value: (u0Compiler$Parser_Test$lowercase)("a"),
}))))), c0Core$Nil))));

const u0Compiler$Parser_Test$word = (($name) => {
  return ({
    first: c0Compiler$Pos$T,
    second: $name,
  });
});

const u0Compiler$Parser_Test$unionDefs = ((() => {
  const $asTypeDef = (($s) => {
    return ((($s)[0] === "$UnionDef")
      ? ((() => {
        const $a = ($s)[1];
        return (c0Result$Ok)($a);
      }))()
      : (true
        ? (c0Result$Err)("no type def")
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 442:8', (sp_toHuman)($s))));
  });
  const $firstTypeDef = (($x) => {
    return ((c0Result$onOk)($asTypeDef))((u0Compiler$Parser_Test$firstStatement)($x));
  });
  return (i1Test$Group)("Type Definitions", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Parse inline def", "var A b c = 'v1 b, 'v2 c, 'v3, 'v4 b c", $firstTypeDef, (i1Test$isOkAndEqualTo)(({
    args: (c0Core$Cons)((u0Compiler$Parser_Test$word)("b"), (c0Core$Cons)((u0Compiler$Parser_Test$word)("c"), c0Core$Nil)),
    constructors: (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'v1"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'v2"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("c"), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Parser_Test$constructor)("'v3"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'v4"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("c"), c0Core$Nil)))), c0Core$Nil)))),
    name: (u0Compiler$Parser_Test$word)("A"),
  }))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Parse multiline def", "var A b c =\n    , 'v1 b\n    , 'v2 c\n    , 'v3\n    , 'v4 b c", $firstTypeDef, (i1Test$isOkAndEqualTo)(({
    args: (c0Core$Cons)((u0Compiler$Parser_Test$word)("b"), (c0Core$Cons)((u0Compiler$Parser_Test$word)("c"), c0Core$Nil)),
    constructors: (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'v1"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'v2"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("c"), c0Core$Nil))), (c0Core$Cons)((u0Compiler$Parser_Test$constructor)("'v3"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'v4"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("c"), c0Core$Nil)))), c0Core$Nil)))),
    name: (u0Compiler$Parser_Test$word)("A"),
  }))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("List argument", "var A = 'a [Int]", $firstTypeDef, (i1Test$isOkAndEqualTo)(({
    args: c0Core$Nil,
    constructors: (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$constructor)("'a"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$List)(false, (c0Core$Cons)(({
      first: false,
      second: (u0Compiler$Parser_Test$uppercase)("Int"),
    }), c0Core$Nil))), c0Core$Nil))), c0Core$Nil),
    name: (u0Compiler$Parser_Test$word)("A"),
  }))), c0Core$Nil))));
}))();

const u0Compiler$Parser_Test$unops = (i1Test$Group)("Unops", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] Unop", "a = f -n", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Precedence 1", "-a b", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$UnopCall)(c0Compiler$Op$UnopMinus, (u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("a"), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("b"), c0Core$Nil))))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Precedence 2", "a -b", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("a"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$UnopCall)(c0Compiler$Op$UnopMinus, (u0Compiler$Parser_Test$lowercase)("b"))), c0Core$Nil))))), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("Precedence 3", "a -b c", u0Compiler$Parser_Test$firstEvaluation, (i1Test$isOkAndEqualTo)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$Call)((u0Compiler$Parser_Test$lowercase)("a"), (c0Core$Cons)((u0Compiler$Parser_Test$e)((c0Compiler$FormattableAst$UnopCall)(c0Compiler$Op$UnopMinus, (u0Compiler$Parser_Test$lowercase)("b"))), (c0Core$Cons)((u0Compiler$Parser_Test$lowercase)("c"), c0Core$Nil)))))), c0Core$Nil)))));

const u0Compiler$Parser_Test$values = (i1Test$Group)("Values", (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] Parse root comments", "# blank\na = 1", u0Compiler$Parser_Test$firstStatement, i1Test$isOk), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] deal with spurious NewSiblingLine introduced by inline comments", "library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\"", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), (c0Core$Cons)((u0Compiler$Parser_Test$codeTest)("[reg] SPON", "library =\n    source = \"core:prelude\"\n\n    module =\n        path = Core\n        importAs = Core", u0Compiler$Parser_Test$firstDefinition, i1Test$isOk), c0Core$Nil))));

const u0Compiler$Parser_Test$tests = (i1Test$Group)("Parser", (c0Core$Cons)(u0Compiler$Parser_Test$values, (c0Core$Cons)(u0Compiler$Parser_Test$parens, (c0Core$Cons)(u0Compiler$Parser_Test$functions, (c0Core$Cons)(u0Compiler$Parser_Test$annotations, (c0Core$Cons)(u0Compiler$Parser_Test$unionDefs, (c0Core$Cons)(u0Compiler$Parser_Test$lists, (c0Core$Cons)(u0Compiler$Parser_Test$records, (c0Core$Cons)(u0Compiler$Parser_Test$ifs, (c0Core$Cons)(u0Compiler$Parser_Test$tries, (c0Core$Cons)(u0Compiler$Parser_Test$patterns, (c0Core$Cons)(u0Compiler$Parser_Test$binops, (c0Core$Cons)(u0Compiler$Parser_Test$unops, (c0Core$Cons)(u0Compiler$Parser_Test$comments, c0Core$Nil))))))))))))));

const u0Compiler$TestHelpers$taBool = (c0Compiler$TypedAst$TypeExact)((u0Compiler$CoreDefs$usr)("Bool"), c0Core$Nil);

const u0Compiler$TestHelpers$taFunction = (($from, $to) => {
  return (c0Compiler$TypedAst$TypeFn)((c0List$map)((($t) => {
    return (c0Compiler$TypedAst$ParSp)((c0Compiler$Ast$toImm)($t));
  }), $from), (c0Compiler$Ast$toImm)($to));
});

const u0Compiler$TestHelpers$taList = (($item) => {
  return (c0Compiler$TypedAst$TypeExact)((u0Compiler$CoreDefs$usr)("List"), (c0Core$Cons)($item, c0Core$Nil));
});

const u0Compiler$TestHelpers$taNone = (c0Compiler$TypedAst$TypeExact)((u0Compiler$CoreDefs$usr)("None"), c0Core$Nil);

const u0Compiler$TestHelpers$taTyvar = (($0) => {
  return (c0Compiler$TypedAst$TypeVar)($0);
});

const u0Compiler$TypeCheck_Test$outToHuman = (($out) => {
  const $env = (u0Compiler$TypeCheck$initEnv)(u0Compiler$TestHelpers$imports, c0Dict$empty);
  const $type = (u0SPLib$Format$render)(((($0) => {
    return (u0Human$Format$formatExpression)(({
      isRoot: true,
      originalContent: "",
    }), $0);
  }))(((($0) => {
    return (u0Human$Type$doRawType)(u0Compiler$TestHelpers$imports, $0);
  }))($out.type)));
  return ((($0) => {
    return (c0Text$join)("\n", $0);
  }))((c0Core$Cons)(("  tyvars = " + (sp_toHuman)((c0Dict$toList)($out.freeTyvars))), (c0Core$Cons)(("  type = " + $type), c0Core$Nil)));
});

const u0Compiler$TypeCheck_Test$codeTest = (($0, $1, $2, $3) => {
  return (i1Test$codeTest)(u0Compiler$TypeCheck_Test$outToHuman, $0, $1, $2, $3);
});

const u0Compiler$TypeCheck_Test$freeTyvars = (($ids) => {
  return (c0List$for)(c0Dict$empty, $ids, (($id, $d) => {
    return (c0Dict$insert)($id, ({
      maybeAnnotated: c0Maybe$Nothing,
    }), $d);
  }));
});

const u0Compiler$TypeCheck_Test$freeTyvarsAnnotated = (($ids) => {
  return ((($0) => {
    return (c0List$for)($0, $ids, (($4, $d) => {
      const $id = $4.first;
      const $name = $4.second;
      return (c0Dict$insert)($id, ({
        maybeAnnotated: (c0Maybe$Just)(({
          allowFunctions: true,
          name: $name,
        })),
      }), $d);
    }));
  }))(c0Dict$empty);
});

const u0Compiler$TypeCheck_Test$tyvar = u0Compiler$TestHelpers$taTyvar;

const u0Compiler$TypeCheck_Test$functions = (i1Test$Group)("functions", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Known function with correct params", "a = add 3 1", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: u0Compiler$TestHelpers$taNumber,
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Known function with wrong *number* of args", "a = add 'false", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$errorContains)((c0Core$Cons)("Number", (c0Core$Cons)("Arguments", c0Core$Nil)))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Known function with wrong params", "a = add 'false 1", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$errorContains)((c0Core$Cons)("Bool", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Function inference 1", "a = fn x: add x 1", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)(u0Compiler$TestHelpers$taNumber, c0Core$Nil), u0Compiler$TestHelpers$taNumber),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Function inference 2: same as 1, but with swapped args", "a = fn x: add 1 x", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)(u0Compiler$TestHelpers$taNumber, c0Core$Nil), u0Compiler$TestHelpers$taNumber),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] fn had type None", "a = fn x: 1", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (c0Compiler$TypedAst$TypeFn)((c0Core$Cons)((c0Compiler$TypedAst$ParSp)((c0Compiler$Ast$toImm)((u0Compiler$TypeCheck_Test$tyvar)(1))), c0Core$Nil), (c0Compiler$Ast$toUni)(u0Compiler$TestHelpers$taNumber)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Multiple arguments are correctly inferred", "a = fn x, y, z: x + y + z", (u0Compiler$TypeCheck_Test$infer)("a"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Annotation should be consistent with mutability", "f as fn @Number: Number = fn a:\n  a", (u0Compiler$TypeCheck_Test$infer)("f"), (i1Test$errorContains)((c0Core$Cons)("RecyclingDoesNotMatch", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Free tyvar should not be compatible with constructor", "listCons as fn item: item =\n    fn item:\n    []", (u0Compiler$TypeCheck_Test$infer)("listCons"), (i1Test$errorContains)((c0Core$Cons)("Incompatible", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Annotations that are too general should be rejected", "f as fn a: b =\n    fn a: a", (u0Compiler$TypeCheck_Test$infer)("f"), (i1Test$errorContains)(c0Core$Nil)), c0Core$Nil)))))))))));

const u0Compiler$TypeCheck_Test$higherOrderTypes = (i1Test$Group)("higher order types", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Parse precedence", "var T a = 't a\n\na as fn T a: T a =\n    fn l: l", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvarsAnnotated)((c0Core$Cons)(({
    first: 1,
    second: "a",
  }), c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((c0Compiler$TypedAst$TypeExact)((u0Compiler$TestHelpers$moduleUsr)("T"), (c0Core$Cons)((u0Compiler$TypeCheck_Test$tyvar)(1), c0Core$Nil)), c0Core$Nil), (c0Compiler$TypedAst$TypeExact)((u0Compiler$TestHelpers$moduleUsr)("T"), (c0Core$Cons)((u0Compiler$TypeCheck_Test$tyvar)(1), c0Core$Nil))),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Variant type constructors", "var X a = 'l\nl = 'l", (u0Compiler$TypeCheck_Test$infer)("l"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (c0Compiler$TypedAst$TypeExact)((u0Compiler$TestHelpers$moduleUsr)("X"), (c0Core$Cons)((u0Compiler$TypeCheck_Test$tyvar)(1), c0Core$Nil)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] type check mistakes a variant type with free tyvars for a free tyvar?", "var O r e o = 'o r e o\n\nrun as fn (fn r: O r e o), r: O r e o =\n   fn rToOreo, r:\n   rToOreo r", (u0Compiler$TypeCheck_Test$infer)("run"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Wrong should be Text", "var O o = 'o Text o\n\nfun as Number: Text: O wrong = _: a:\n    'o a a", (u0Compiler$TypeCheck_Test$infer)("fun"), (i1Test$errorContains)((c0Core$Cons)("wrong", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Should complain about undefined type argument", "var O a = 'o Text output\nx = 1", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("output", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Named vars can't be refined?", "var Wrap a = 'w a\n\nf as fn a: Wrap a =\n    fn a: a", (u0Compiler$TypeCheck_Test$infer)("f"), (i1Test$errorContains)((c0Core$Cons)("Wrap", c0Core$Nil))), c0Core$Nil)))))));

const u0Compiler$TypeCheck_Test$if_else = (i1Test$Group)("if..else", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("basic functionality", "x =\n    fn q:\n    if q then 1\n    else 2", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: (c0Compiler$TypedAst$TypeFn)((c0Core$Cons)((c0Compiler$TypedAst$ParSp)((c0Compiler$Ast$toImm)(u0Compiler$TestHelpers$taBool)), c0Core$Nil), (c0Compiler$Ast$toUni)(u0Compiler$TestHelpers$taNumber)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("rejects non-bool conditions", "x =\n    fn q:\n    if 1 then 1\n    else 2", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("Bool", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks", "x =\n    fn q:\n    if q then 2\n    else 'false", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("Number", c0Core$Nil))), c0Core$Nil))));

const u0Compiler$TypeCheck_Test$misc = (i1Test$Group)("Misc", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Undefined types should be rejected", "v as ThisTypeIsNotDefined = this_is_sp_native", (u0Compiler$TypeCheck_Test$infer)("v"), (i1Test$errorContains)((c0Core$Cons)("ThisTypeIsNotDefined", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Placeholder works with unique args", "stuff as fn !Number: Number = this_is_sp_native\nv =\n    1 >> stuff __", (u0Compiler$TypeCheck_Test$infer)("v"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: u0Compiler$TestHelpers$taNumber,
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] named tyvars should not \"bleed\" to other definitions", "var DD q =\n    , 'RBEmpty_elm_builtin\n\nempty as DD key =\n    'RBEmpty_elm_builtin\n\nmerge as fn (fn key, b, res: res), res: res =\n  fn rightStep, initialResult:\n\n  stepState as fn key, b, [key & a] & res: [key & a] & res =\n    fn rKey, rValue, q:\n    try q.first as\n       []: q\n\n  initialResult", (u0Compiler$TypeCheck_Test$infer)("merge"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Constructors not being generalized led to tyvar bleed", "var DD a b = 'Blah\n\nddget as fn a, DD a b: DD a b =\n    fn a, b:\n    'Blah\n\nformatSnippet as Text =\n    try [\"\"] as\n         [\"emphasys\", s]: s\n\nfmtBlock as Text =\n    try ddget 1 'Blah as\n         'Blah:\n            \"\"", (u0Compiler$TypeCheck_Test$infer)("formatSnippet"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Non-annotated variables are not correctly inserted", "n = 3\n\nz as Number = n + 1", (u0Compiler$TypeCheck_Test$infer)("z"), i1Test$isOk), c0Core$Nil))))));

const u0Compiler$TypeCheck_Test$nonFunction = (i1Test$Group)("NonFunction", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("SKIP (burnedout) Basic functionality", "blah as fn [a]: [a] with a NonFunction =\n  fn a:\n  a\n\nmeh =\n    blah [fn x: x]", (u0Compiler$TypeCheck_Test$infer)("meh"), (i1Test$errorContains)((c0Core$Cons)("ErrorTypeAllowsFunctions", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("SKIP (burnedout) Constraint is enforced with annotation", "blah as fn [a]: [a] with a NonFunction =\n  fn a: a\n\nmeh as fn b: b =\n    fn a: blah a", (u0Compiler$TypeCheck_Test$infer)("meh"), (i1Test$errorContains)((c0Core$Cons)("ErrorTypeAllowsFunctions", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("SKIP (burnedout) Constraint is enforced without annotation", "blah as fn [a]: [a] with a NonFunction =\n    fn a: a\n\nmeh =\n    fn a: blah a", (u0Compiler$TypeCheck_Test$infer)("meh"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (c0Dict$ofOne)(1, ({
    maybeAnnotated: c0Maybe$Nothing,
  })),
  type: u0Compiler$TestHelpers$taNumber,
}))), c0Core$Nil))));

const u0Compiler$TypeCheck_Test$patterns = (i1Test$Group)("Patterns", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Constructor unpacking", "var Z a = 'z a\n\nidentityFunction =\n   fn a:\n   'z b = 'z a\n   b", (u0Compiler$TypeCheck_Test$infer)("identityFunction"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((u0Compiler$TypeCheck_Test$tyvar)(1), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("List unpacking", "x =\n   fn q:\n   [ first, second ] = q\n   first", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((u0Compiler$TestHelpers$taList)((u0Compiler$TypeCheck_Test$tyvar)(1)), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Complete records are correctly unpacked", "x =\n    fn q:\n    { first } = q\n    first", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((c0Compiler$TypedAst$TypeRecord)(c0Maybe$Nothing, (c0Dict$fromList)((c0Core$Cons)(({
    first: "first",
    second: (u0Compiler$TypeCheck_Test$tyvar)(1),
  }), c0Core$Nil))), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Incomplete records are correctly unpacked", "x =\n    fn q:\n    { with first } = q\n    first", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, (c0Core$Cons)(2, c0Core$Nil))),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(2), (c0Dict$fromList)((c0Core$Cons)(({
    first: "first",
    second: (u0Compiler$TypeCheck_Test$tyvar)(1),
  }), c0Core$Nil))), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Constructors should instantiate their variable types", "each as fn [a], (fn a: b): None =\n    fn ls, f:\n    try ls as\n         Core.'nil: 'none\n\nresult =\n    1 :: Core.'nil = Core.'nil", (u0Compiler$TypeCheck_Test$infer)("result"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Trying to check against an inferred value?", "tuple as Text & Number =\n    \"\" & 1\n\nx =\n    (a as Text) & (b as Number) =\n        tuple", (u0Compiler$TypeCheck_Test$infer)("x"), i1Test$isOk), c0Core$Nil)))))));

const u0Compiler$TypeCheck_Test$records = (i1Test$Group)("Records", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Attribute access", "a = fn b: b.meh.blah", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, (c0Core$Cons)(2, (c0Core$Cons)(3, c0Core$Nil)))),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(1), (c0Dict$ofOne)("meh", (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(2), (c0Dict$ofOne)("blah", (u0Compiler$TypeCheck_Test$tyvar)(3))))), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(3)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Attribute mutation", "a = fn @b: @b.meh.blah += 1", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, (c0Core$Cons)(2, c0Core$Nil))),
  type: (c0Compiler$TypedAst$TypeFn)((c0Core$Cons)((c0Compiler$TypedAst$ParRe)((c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(1), (c0Dict$ofOne)("meh", (c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(2), (c0Dict$ofOne)("blah", u0Compiler$TestHelpers$taNumber))))), c0Core$Nil), (c0Compiler$Ast$toImm)(u0Compiler$TestHelpers$taNone)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Tuple3 direct item mutability", "x =\n    !a = 3 & 'false & 2\n\n    @a.third += 1", (u0Compiler$TypeCheck_Test$infer)("x"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Tuple2 direct item mutability, annotated", "x =\n   fn _:\n   !a as Number & Number =\n     1 & 2\n\n   @a.first += 1", (u0Compiler$TypeCheck_Test$infer)("x"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("functional update", "a = fn b: { b with x = 1 }", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
    type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)($re, c0Core$Nil), $re),
  });
}))((c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(1), (c0Dict$ofOne)("x", u0Compiler$TestHelpers$taNumber))))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("SKIP(needs reordering) instantiate and refine inferred records", "a = fn t: { t with x = 1 }\nc = a", (u0Compiler$TypeCheck_Test$infer)("c"), (i1Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: c0Dict$empty,
    type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)($re, c0Core$Nil), $re),
  });
}))((c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(1), (c0Dict$ofOne)("x", u0Compiler$TestHelpers$taNumber))))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] excessive forallness in records", "x =\n  fn q:\n  a = q.first\n  a", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, (c0Core$Cons)(2, c0Core$Nil))),
    type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)($re, c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(2)),
  });
}))((c0Compiler$TypedAst$TypeRecord)((c0Maybe$Just)(1), (c0Dict$ofOne)("first", (u0Compiler$TypeCheck_Test$tyvar)(2)))))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] refineType when the record has a non-extensible alias", "A = { c as Number, d as Number }\n\nupd as fn A: A = fn a:\n  { a with c = .c + 1 }", (u0Compiler$TypeCheck_Test$infer)("upd"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] infinite recursion on addSubstitution/unify_", "B = { l as [Text] }\n\nreadOne as fn B: (Text & B) =\n    fn b:\n    try b.l as\n         []: \"\" & b\n         [h, t...]: h & { b with l = t }", (u0Compiler$TypeCheck_Test$infer)("readOne"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] unifyToNonExtensibleRecord correctly substitutes the record extension", "R = { x as Number, y as Number }\n\nrec as fn R: R =\n    fn s:\n\n    if 'true then\n        { s with y = .y }\n    else\n        rec { s with y = .y }", (u0Compiler$TypeCheck_Test$infer)("rec"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Record missing attributes", "R = { x as Number, y as Number }\n\nr as R = {\n  , x = 3\n  }", (u0Compiler$TypeCheck_Test$infer)("r"), (i1Test$errorContains)((c0Core$Cons)("Missing", c0Core$Nil))), c0Core$Nil))))))))))));

const u0Compiler$TypeCheck_Test$recursiveTypes = (i1Test$Group)("Recursive types", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Normal types cannot be self recursive", "A = { a as A }\na as A = this_is_sp_native", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$errorContains)((c0Core$Cons)("Circular", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Normal types cannot be mutually recursive", "A = { b as B }\nB = { a as A }\na as A = this_is_sp_native", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$errorContains)((c0Core$Cons)("Circular", c0Core$Nil))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Variant types can be recursive", "var A = 'a2 B\nB = { a as A }\na as A = this_is_sp_native\nb as B = this_is_sp_native", (u0Compiler$TypeCheck_Test$infer)("a"), i1Test$isOk), c0Core$Nil))));

const u0Compiler$TypeCheck_Test$statements = (i1Test$Group)("statements", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Statement blocks should return the last statement's type", "a =\n  3\n  'false", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: u0Compiler$TestHelpers$taBool,
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Definition statements return type None", "a =\n  f = fn x: 3", (u0Compiler$TypeCheck_Test$infer)("a"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: u0Compiler$TestHelpers$taNone,
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Definition statement with annotation return type None", "a as None =\n  f = 3", (u0Compiler$TypeCheck_Test$infer)("a"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Annotated declarations are actually typechecked", "x as None =\n    q = 1 + \"\"", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)(c0Core$Nil)), c0Core$Nil)))));

const u0Compiler$TypeCheck_Test$try_as = (i1Test$Group)("try..as", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("basic functionality", "x =\n    fn q:\n    try q as\n         'true: 2\n         _: 3", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: c0Dict$empty,
  type: (c0Compiler$TypedAst$TypeFn)((c0Core$Cons)((c0Compiler$TypedAst$ParSp)((c0Compiler$Ast$toImm)(u0Compiler$TestHelpers$taBool)), c0Core$Nil), (c0Compiler$Ast$toUni)(u0Compiler$TestHelpers$taNumber)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("rejects non-matching patterns", "x =\n    fn q:\n    try q as\n         'true: 2\n         []: 3", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("List", (c0Core$Cons)("Bool", c0Core$Nil)))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks", "x =\n    fn q:\n    try q as\n         'true: 2\n         'false: 'false", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("Number", (c0Core$Cons)("Bool", c0Core$Nil)))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] actually infers blocks", "x as Number =\n    try \"\" as\n         \"\": y", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("y", c0Core$Nil))), c0Core$Nil)))));

const u0Compiler$TypeCheck_Test$variableTypes = (i1Test$Group)("Variable types", (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Identity, annotated", "id as fn a: a =\n  fn a: a", (u0Compiler$TypeCheck_Test$infer)("id"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvarsAnnotated)((c0Core$Cons)(({
    first: 1,
    second: "a",
  }), c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((u0Compiler$TypeCheck_Test$tyvar)(1), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Identity, inferred", "id =\n  fn a: a", (u0Compiler$TypeCheck_Test$infer)("id"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taFunction)((c0Core$Cons)((u0Compiler$TypeCheck_Test$tyvar)(1), c0Core$Nil), (u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("Annotated vars are instantiated when referenced", "q as [item] =\n  Core.'nil\n\nr as [Text] =\n      q", (u0Compiler$TypeCheck_Test$infer)("r"), i1Test$isOk), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] on is missing tyvars", "andThen as [a] = []\n\non = andThen", (u0Compiler$TypeCheck_Test$infer)("on"), (i1Test$isOkAndEqualTo)(({
  freeTyvars: (u0Compiler$TypeCheck_Test$freeTyvars)((c0Core$Cons)(1, c0Core$Nil)),
  type: (u0Compiler$TestHelpers$taList)((u0Compiler$TypeCheck_Test$tyvar)(1)),
}))), (c0Core$Cons)((u0Compiler$TypeCheck_Test$codeTest)("[reg] Unifying functions does not unfiy their args", "var Dict_ k v = 'empty\ndict_member as fn k, Dict_ k v: Bool = this_is_sp_native\ndict_filter as fn (fn k, v: Bool), Dict_ k v: Dict_ k v = this_is_sp_native\n\nfreeTyvars as Dict_ Number {} = this_is_sp_native\ntypeTyvars as Dict_ Number None = this_is_sp_native\n\nx = dict_filter (fn k, v: dict_member v typeTyvars) freeTyvars", (u0Compiler$TypeCheck_Test$infer)("x"), (i1Test$errorContains)((c0Core$Cons)("{}", (c0Core$Cons)("Number", c0Core$Nil)))), c0Core$Nil))))));

const u0Compiler$TypeCheck_Test$tests = (i1Test$Group)("TypeCheck", (c0Core$Cons)(u0Compiler$TypeCheck_Test$functions, (c0Core$Cons)(u0Compiler$TypeCheck_Test$statements, (c0Core$Cons)(u0Compiler$TypeCheck_Test$recursiveTypes, (c0Core$Cons)(u0Compiler$TypeCheck_Test$variableTypes, (c0Core$Cons)(u0Compiler$TypeCheck_Test$higherOrderTypes, (c0Core$Cons)(u0Compiler$TypeCheck_Test$records, (c0Core$Cons)(u0Compiler$TypeCheck_Test$patterns, (c0Core$Cons)(u0Compiler$TypeCheck_Test$try_as, (c0Core$Cons)(u0Compiler$TypeCheck_Test$if_else, (c0Core$Cons)(u0Compiler$TypeCheck_Test$nonFunction, (c0Core$Cons)(u0Compiler$TypeCheck_Test$misc, c0Core$Nil))))))))))));

const u0DefaultImports$platformDefaultImportsFile = (($modules) => {
  const $platform = ({
    modules: (c0List$map)((($2) => {
      const $path = $2.first;
      const $globals = $2.second;
      return (u0DefaultImports$mod)($path, $globals);
    }), $modules),
    source: "platform",
  });
  const $0 = u0DefaultImports$defaultImportsFile;
  return (Object.assign)({}, $0, ({
    libraries: (c0Core$Cons)($platform, $0.libraries),
  }));
});

const u0Human$Format_Test$format = (($input) => {
  return ((c0Result$onOk)((($faStatements) => {
    const $env = ({
      isRoot: true,
      originalContent: $input,
    });
    return (c0Result$Ok)((u0SPLib$Format$render)(((($0) => {
      return (u0Human$Format$formatStatements)($env, $0);
    }))($faStatements)));
  })))(((($0) => {
    return (c0Result$mapError)(sp_toHuman, $0);
  }))((u0Compiler$Parser$textToFormattableModule)(({
    errorModule: ({
      content: $input,
      fsPath: "test",
    }),
    keepComments: true,
    stripLocations: false,
  }))));
});

const u0Human$Format_Test$formatTest = (($title, $input, $expectedOutput) => {
  const $quote = (($0) => {
    return ("```\n" + ($0 + "\n```"));
  });
  const $4 = (i1Test$isOkAndEqualTo)($expectedOutput);
  const $toMaybeError = ($4)[1];
  return (i1Test$Single)($title, "", ((_0) => {
    return (i1Test$maybeToOutcome)(((($0) => {
      return ($toMaybeError)($quote, $0);
    }))((u0Human$Format_Test$format)($input)));
  }));
});

const u0Human$Format_Test$calls = (i1Test$Group)("Calls", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Arguments indentation", "a =\n   fun\n      #comment1\n      a\n        #comment2\n        b", "a =\n    fun\n        #comment1\n        a\n        #comment2\n        b\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("precedence", "a (b  c)", "a (b c)\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("With multiline args", "a =\n    (x >> y)\n       fn _:\n          a\n          b\n      (assert blah)\n      (zak meh)", "a =\n    (x >> y)\n        (fn _:\n             a\n\n             b\n        )\n        (assert blah)\n        (zak meh)\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve aligned", "a =\n    x fn _:\n    y", "a =\n    x fn _:\n    y\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve indent", "a =\n    x fn _:\n      y", "a =\n    x fn _:\n        y\n"), c0Core$Nil))))));

const u0Human$Format_Test$comments = (i1Test$Group)("Comments", (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] Should not add indent to empty lines", "if a then\n    [#\n\n        comment\n\n    #]\n    b\n  else\n    c", "if a then\n    [#\n\n        comment\n\n    #]\n    b\nelse\n    c\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve whether a comment has a trailing blank, line", "# blank\n\na = 1\n\n# no blank\nb = 1", "# blank\n\na =\n    1\n\n\n# no blank\nb =\n    1\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve whether a comment has a trailing blank, block", "[# blank #]\n\na = 1\n\n[# no blank #]\nb = 1", "[# blank #]\n\na =\n    1\n\n\n[# no blank #]\nb =\n    1\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Comment order is preserved", "# a\n# b\n# c\naaaaa =\n# d\n# e\n# f\n      bbbbb\n\n      #g\n      #h\n      #i\n      ccccc", "# a\n# b\n# c\naaaaa =\n# d\n# e\n# f\n    bbbbb\n\n    #g\n    #h\n    #i\n    ccccc\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Normal comments get indented, line", "a =\n # b\n    1", "a =\n    # b\n    1\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("\"Quick\" comments remain untouched, line", "a =\n# b\n  1", "a =\n# b\n    1\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Normal comments get indented, block", "a =\n [# b\nblah#]\n    1", "a =\n    [# b\n    blah#]\n    1\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("\"Quick\" comments remain untouched, block", "a =\n[# b\n#]\n  1", "a =\n[# b\n#]\n    1\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] Section comment should stay before the if", "f =\n    a = 1\n\n# comment\n\n    if a then\n        b\n      else\n        c", "f =\n    a =\n        1\n\n# comment\n\n    if a then\n        b\n    else\n        c\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] Block comment internal indent should remain consistent", "x =\n    [#\n        comment\n    #]\n    d", "x =\n    [#\n        comment\n    #]\n    d\n"), c0Core$Nil)))))))))));

const u0Human$Format_Test$definitions = (i1Test$Group)("Definitions", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Alias", "Meh a b = Int", "Meh a b =\n    Int\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Unions 1", "var Meh = 'meh z", "var Meh =\n    , 'meh z\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Unions 2", "var Meh a b = 'blah, 'meh x y z", "var Meh a b =\n    , 'blah\n    , 'meh x y z\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Annotated values", "(x as Type) & (y as Kind) = thing", "(x as Type) & (y as Kind) =\n    thing\n"), c0Core$Nil)))));

const u0Human$Format_Test$functions = (i1Test$Group)("Functions", (c0Core$Cons)((u0Human$Format_Test$formatTest)("SKIP (low priority) Named functions should always have their body below", "f =\n    fn a: fn b: c", "f =\n    fn a:\n    fn b:\n    c"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Named functions should always have their body below", "x =\n  a\n  >> onOk fn b:\n\n  c\n  >> onOk fn d:\n\n  e", "x =\n    a\n    >> onOk fn b:\n    c\n    >> onOk fn d:\n    e\n"), c0Core$Nil)));

const u0Human$Format_Test$ifs = (i1Test$Group)("if..then", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Single line", "x = if blah   then a  else b", "x =\n    if blah then a else b\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Make multiline", "x = if blah then\n      a = 1\n      a + b\n  else  b", "x =\n    if blah then\n        a =\n            1\n\n        a + b\n    else\n        b\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve multiline", "x =\n    if blah then\n        a\n    else b", "x =\n    if blah then\n        a\n    else\n        b\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("if else", "x = if blah then a else if o then b else q", "x =\n    if blah then\n        a\n    else if o then\n        b\n    else\n        q\n"), c0Core$Nil)))));

const u0Human$Format_Test$lists = (i1Test$Group)("Lists", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve one-liners", "a = [1, 2, 3]", "a =\n    [ 1, 2, 3 ]\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve multilines", "a = [1\n  , 2, 3]", "a =\n    [\n    , 1\n    , 2\n    , 3\n    ]\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] weird shit happening when a definition is preceded by a blank line?", "\nll as [Int] = []", "ll as [ Int ] =\n    []\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Expansion", "\nll = [a..., b, fun arg..., (pas)...]", "ll =\n    [ a..., b, fun arg..., pas... ]\n"), c0Core$Nil)))));

const u0Human$Format_Test$operators = (i1Test$Group)("Operators", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Precedence", "a = (1 + 2 * 3 + 4)\nb = 5*(6+ 7)*8", "a =\n    1 + 2 * 3 + 4\n\n\nb =\n    5 * (6 + 7) * 8\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Pipe on a single line stays on a single line", "a = b >> c >> d >> e", "a =\n    b >> c >> d >> e\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Pipe right gets indented if there is at least one line break", "a = b >> c\n  >> d >> e", "a =\n    b\n    >> c\n    >> d\n    >> e\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] Preserve comment", "escape =\n    x\n    # comment\n    >> replace\n    >> replace", "escape =\n    x\n    # comment\n    >> replace\n    >> replace\n"), c0Core$Nil)))));

const u0Human$Format_Test$records = (i1Test$Group)("Records", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Reorder attributes", "a = { z, e, r }", "a =\n    { e, r, z }\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Comments", "a = {\n    , z = 1\n    # AAA\n    , e = 2\n    , r =\n      # BBB\n       3\n   }", "a =\n    {\n    # AAA\n    , e =\n        2\n    , r =\n        # BBB\n        3\n    , z = 1\n    }\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Extension", "{ z with e }", "{ z with e }\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Shorthands", "a = { b with c = .d }", "a =\n    { b with c = .d }\n"), c0Core$Nil)))));

const u0Human$Format_Test$textLiterals = (i1Test$Group)("Text literals", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Single quotes escape quotes and backspaces", "a = \"\\\"\\\\\"", "a =\n    \"\\\"\\\\\"\n"), c0Core$Nil));

const u0Human$Format_Test$tryAs = (i1Test$Group)("try..as", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Compact", "x = try blah as\n  Just a: a\n  Nothing:  b", "x =\n    try blah as\n        Just a: a\n        Nothing: b\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Long", "x = try blah as\n  Just a:\n        b = 1\n        b + a\n  Nothing:  b", "x =\n    try blah as\n\n        Just a:\n            b =\n                1\n\n            b + a\n\n        Nothing:\n            b\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("SKIP (low priority) Preserves comments (compact)", "try e  as\n    T: 9\n    # comment\n    _:  10", "try e as\n    T: 9\n    # comment\n    _: 10\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserves comments (long, inline comments)", "try e as\n    # AAA\n    T:\n    # BBB\n        9\n    _: 10", "try e as\n\n    # AAA\n    T:\n        # BBB\n        9\n\n    _:\n        10\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserves comments (long, block comments)", "try e as\n    [# AAA #]\n    T:\n    [# BBB #]\n        9\n    _: 10", "try e as\n\n    [# AAA #]\n    T:\n        [# BBB #]\n        9\n\n    _:\n        10\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("Comments", "x =\n          try char as\n            \"\":\n                None\n\n#            \"@\":\n\n            \"#\":\n                start\n", "x =\n    try char as\n\n        \"\":\n            None\n\n#            \"@\":\n\n        \"#\":\n            start\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] Should not move a comma inside a multi-line comment", "try char as\n  a: b\n\n  [#\n  comment\n  #]\n\n  d: c", "try char as\n\n    a:\n        b\n\n    [#\n    comment\n    #]\n\n    d:\n        c\n"), (c0Core$Cons)((u0Human$Format_Test$formatTest)("[reg] Comments should not cause content to multiline", "try value as\n\n    # TODO restore `None` here once it doesn't break JS any more\n    Err _:\n        formatIndented", "try value as\n\n    # TODO restore `None` here once it doesn't break JS any more\n    Err _:\n        formatIndented\n"), c0Core$Nil)))))))));

const u0Human$Format_Test$uniqueness = (i1Test$Group)("Uniqueness", (c0Core$Cons)((u0Human$Format_Test$formatTest)("Preserve uniqueness annotations", "f as fn !a, 2?b, @c: !d = fn !a, 2?b, @c: blah", "f as fn !a, 2?b, @c: !d =\n    fn !a, 2?b, @c: blah\n"), c0Core$Nil));

const u0Human$Format_Test$tests = (i1Test$Group)("Formatter", (c0Core$Cons)(u0Human$Format_Test$definitions, (c0Core$Cons)(u0Human$Format_Test$operators, (c0Core$Cons)(u0Human$Format_Test$functions, (c0Core$Cons)(u0Human$Format_Test$calls, (c0Core$Cons)(u0Human$Format_Test$lists, (c0Core$Cons)(u0Human$Format_Test$records, (c0Core$Cons)(u0Human$Format_Test$comments, (c0Core$Cons)(u0Human$Format_Test$textLiterals, (c0Core$Cons)(u0Human$Format_Test$uniqueness, (c0Core$Cons)(u0Human$Format_Test$tryAs, (c0Core$Cons)(u0Human$Format_Test$ifs, c0Core$Nil))))))))))));

const u0SPLib$Format$spaceSeparatedOrIndentForce = (($force, $blocks) => {
  return (u0SPLib$Format$rowOrIndentForce)($force, (c0Maybe$Just)(u0SPLib$Format$space), $blocks);
});

const u0SPLib$Format_Test$format1 = (($breakFirst, $breakRest, $f, $1) => {
  const $arg0 = ($1)[1];
  const $args = ($1)[2];
  return ((($0) => {
    return (c0List$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))((u0SPLib$Format$render)((u0SPLib$Format$spaceSeparatedOrIndentForce)($breakRest, (sp_cons)((u0SPLib$Format$spaceSeparatedOrIndentForce)($breakFirst, (c0Core$Cons)($f, (c0Core$Cons)($arg0, c0Core$Nil))), $args)))));
});

const u0SPLib$Format_Test$format2 = (($break, $1) => {
  const $first = ($1)[1];
  const $rest = ($1)[2];
  const $formatEntry = (($open, $block) => {
    return (u0SPLib$Format$prefix)(2, (u0SPLib$Format$Row)((u0SPLib$Format$Text_)($open), u0SPLib$Format$space), $block);
  });
  return ((($0) => {
    return (c0List$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))((u0SPLib$Format$render)((u0SPLib$Format$spaceSeparatedOrStackForce)($break, (c0Core$Cons)((u0SPLib$Format$rowOrStackForce)($break, c0Maybe$Nothing, (sp_cons)(($formatEntry)("[", $first), (c0List$map)((($0) => {
    return ($formatEntry)(",", $0);
  }), $rest))), (c0Core$Cons)((u0SPLib$Format$textToBlock)("]"), c0Core$Nil))))));
});

const u0SPLib$Format_Test$format3 = (($1) => {
  const $first = ($1)[1];
  const $rest = ($1)[2];
  const $formatEntry = (($open, $2) => {
    const $key = $2.first;
    const $break = $2.second;
    const $value = $2.third;
    return (u0SPLib$Format$spaceSeparatedOrIndentForce)($break, (c0Core$Cons)((u0SPLib$Format$spaceSeparatedOrStack)((c0Core$Cons)((u0SPLib$Format$textToBlock)($open), (c0Core$Cons)($key, (c0Core$Cons)((u0SPLib$Format$textToBlock)("="), c0Core$Nil)))), (c0Core$Cons)($value, c0Core$Nil)));
  });
  return ((($0) => {
    return (c0List$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))((u0SPLib$Format$render)((u0SPLib$Format$stack)((c0List$concat)((c0Core$Cons)((c0Core$Cons)(($formatEntry)("{", $first), c0Core$Nil), (c0Core$Cons)((c0List$map)((($0) => {
    return ($formatEntry)(",", $0);
  }), $rest), (c0Core$Cons)((c0Core$Cons)((u0SPLib$Format$textToBlock)("}"), c0Core$Nil), c0Core$Nil))))))));
});

const u0SPLib$Format_Test$format4 = (($breakCond, $breakBodies, $2, $elseBody) => {
  const $ifCond = $2.first;
  const $ifBody = $2.second;
  return ((($0) => {
    return (c0List$filter)((($0) => {
      return (sp_not_equal)($0, "");
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))((u0SPLib$Format$render)((u0SPLib$Format$spaceSeparatedOrStack)((c0Core$Cons)((u0SPLib$Format$spaceSeparatedOrIndentForce)($breakBodies, (c0Core$Cons)((u0SPLib$Format$rowOrStack)(c0Maybe$Nothing, (c0Core$Cons)((u0SPLib$Format$rowOrIndentForce)($breakCond, c0Maybe$Nothing, (c0Core$Cons)((u0SPLib$Format$textToBlock)("if ("), (c0Core$Cons)($ifCond, c0Core$Nil))), (c0Core$Cons)((u0SPLib$Format$textToBlock)(") {"), c0Core$Nil))), (c0Core$Cons)($ifBody, c0Core$Nil))), (c0Core$Cons)((u0SPLib$Format$spaceSeparatedOrIndentForce)(($breakBodies || $breakCond), (c0Core$Cons)((u0SPLib$Format$textToBlock)("} else {"), (c0Core$Cons)($elseBody, c0Core$Nil))), (c0Core$Cons)((u0SPLib$Format$textToBlock)("}"), c0Core$Nil)))))));
});

const u0SPLib$Format_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const u0SPLib$Format_Test$tests = (i1Test$Group)("Block examples", (c0Core$Cons)((i1Test$Group)("Elm-like examples", (c0Core$Cons)((i1Test$Group)("function application", (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("Formats on a single line", ((_0) => {
  return (u0SPLib$Format_Test$format1)(false, false, (u0SPLib$Format$textToBlock)("f"), (c0List$map)(u0SPLib$Format$textToBlock, (c0Core$Cons)("a", (c0Core$Cons)("b", c0Core$Nil))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("f a b", c0Core$Nil))), (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats with all arguments split", ((_0) => {
  return (u0SPLib$Format_Test$format1)(true, false, (u0SPLib$Format$textToBlock)("f"), (c0List$map)(u0SPLib$Format$textToBlock, (c0Core$Cons)("a", (c0Core$Cons)("b", c0Core$Nil))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("f", (c0Core$Cons)("    a", (c0Core$Cons)("    b", c0Core$Nil))))), (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats with first argument joined", ((_0) => {
  return (u0SPLib$Format_Test$format1)(false, true, (u0SPLib$Format$textToBlock)("f"), (c0List$map)(u0SPLib$Format$textToBlock, (c0Core$Cons)("a", (c0Core$Cons)("b", c0Core$Nil))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("f a", (c0Core$Cons)("    b", c0Core$Nil)))), c0Core$Nil)))), (c0Core$Cons)((i1Test$Group)("list", (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats single-line", ((_0) => {
  return (u0SPLib$Format_Test$format2)(false, (c0List$map)(u0SPLib$Format$textToBlock, (c0Core$Cons)("a", (c0Core$Cons)("b", (c0Core$Cons)("c", c0Core$Nil)))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("[ a, b, c ]", c0Core$Nil))), (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats multiline", ((_0) => {
  return (u0SPLib$Format_Test$format2)(true, (c0List$map)(u0SPLib$Format$textToBlock, (c0Core$Cons)("a", (c0Core$Cons)("b", (c0Core$Cons)("c", c0Core$Nil)))));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("[ a", (c0Core$Cons)(", b", (c0Core$Cons)(", c", (c0Core$Cons)("]", c0Core$Nil)))))), c0Core$Nil))), (c0Core$Cons)((i1Test$Group)("record", (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats single-line entries", ((_0) => {
  return (u0SPLib$Format_Test$format3)((c0Core$Cons)(({
    first: (u0SPLib$Format$textToBlock)("a"),
    second: false,
    third: (u0SPLib$Format$textToBlock)("1"),
  }), (c0Core$Cons)(({
    first: (u0SPLib$Format$textToBlock)("b"),
    second: false,
    third: (u0SPLib$Format$textToBlock)("2"),
  }), c0Core$Nil)));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("{ a = 1", (c0Core$Cons)(", b = 2", (c0Core$Cons)("}", c0Core$Nil))))), (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats multiline entries", ((_0) => {
  return (u0SPLib$Format_Test$format3)((c0Core$Cons)(({
    first: (u0SPLib$Format$textToBlock)("a"),
    second: true,
    third: (u0SPLib$Format$textToBlock)("1"),
  }), (c0Core$Cons)(({
    first: (u0SPLib$Format$textToBlock)("b"),
    second: false,
    third: (u0SPLib$Format$textToBlock)("2"),
  }), c0Core$Nil)));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("{ a =", (c0Core$Cons)("    1", (c0Core$Cons)(", b = 2", (c0Core$Cons)("}", c0Core$Nil)))))), c0Core$Nil))), c0Core$Nil)))), (c0Core$Cons)((i1Test$Group)("Javascript-like examples", (c0Core$Cons)((i1Test$Group)("if-else", (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats single-line", ((_0) => {
  return (u0SPLib$Format_Test$format4)(false, false, ({
    first: (u0SPLib$Format$textToBlock)("p"),
    second: (u0SPLib$Format$textToBlock)("a"),
  }), (u0SPLib$Format$textToBlock)("b"));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("if (p) { a } else { b }", c0Core$Nil))), (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats multiline", ((_0) => {
  return (u0SPLib$Format_Test$format4)(false, true, ({
    first: (u0SPLib$Format$textToBlock)("p"),
    second: (u0SPLib$Format$textToBlock)("a"),
  }), (u0SPLib$Format$textToBlock)("b"));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("if (p) {", (c0Core$Cons)("    a", (c0Core$Cons)("} else {", (c0Core$Cons)("    b", (c0Core$Cons)("}", c0Core$Nil))))))), (c0Core$Cons)((u0SPLib$Format_Test$valueTest)("formats multiline condition", ((_0) => {
  return (u0SPLib$Format_Test$format4)(true, false, ({
    first: (u0SPLib$Format$textToBlock)("p"),
    second: (u0SPLib$Format$textToBlock)("a"),
  }), (u0SPLib$Format$textToBlock)("b"));
}), (i1Test$isOkAndEqualTo)((c0Core$Cons)("if (", (c0Core$Cons)("    p", (c0Core$Cons)(") {", (c0Core$Cons)("    a", (c0Core$Cons)("} else {", (c0Core$Cons)("    b", (c0Core$Cons)("}", c0Core$Nil))))))))), c0Core$Nil)))), c0Core$Nil)), c0Core$Nil)));

const u0SPLib$RefHierarchy_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const u0SPLib$RefHierarchy_Test$canonicalJsTest = (u0SPLib$RefHierarchy_Test$valueTest)("[reg] THIS SHOULD BE IN CANONICALTOJS", ((_0) => {
  return (basics_compare)(null, null);
}), (i1Test$isOkAndEqualTo)(0));

const u0SPLib$RefHierarchy_Test$graph1 = ((() => {
  const $x = (($k, $l) => {
    return ({
      first: $k,
      second: ({
        first: $k,
        second: (c0Set$fromList)($l),
      }),
    });
  });
  return (c0Dict$fromList)((c0Core$Cons)(($x)("a", (c0Core$Cons)("b", (c0Core$Cons)("d", c0Core$Nil))), (c0Core$Cons)(($x)("b", (c0Core$Cons)("c", (c0Core$Cons)("e", c0Core$Nil))), (c0Core$Cons)(($x)("c", (c0Core$Cons)("e", (c0Core$Cons)("d", c0Core$Nil))), (c0Core$Cons)(($x)("d", c0Core$Nil), (c0Core$Cons)(($x)("e", c0Core$Nil), c0Core$Nil))))));
}))();

const u0SPLib$RefHierarchy_Test$graph2 = ((() => {
  const $x = (($k, $l) => {
    return ({
      first: $k,
      second: ({
        first: $k,
        second: (c0Set$fromList)($l),
      }),
    });
  });
  return (c0Dict$fromList)((c0Core$Cons)(($x)("a", (c0Core$Cons)("b", (c0Core$Cons)("d", c0Core$Nil))), (c0Core$Cons)(($x)("b", (c0Core$Cons)("c", (c0Core$Cons)("e", c0Core$Nil))), (c0Core$Cons)(($x)("c", (c0Core$Cons)("e", (c0Core$Cons)("d", c0Core$Nil))), (c0Core$Cons)(($x)("d", (c0Core$Cons)("b", c0Core$Nil)), (c0Core$Cons)(($x)("e", c0Core$Nil), c0Core$Nil))))));
}))();

const u0SPLib$RefHierarchy_Test$tests = (i1Test$Group)("RefHierarchy", (c0Core$Cons)(u0SPLib$RefHierarchy_Test$canonicalJsTest, (c0Core$Cons)((u0SPLib$RefHierarchy_Test$valueTest)("Basic", ((_0) => {
  return (u0SPLib$RefHierarchy$reorder)(c0Tuple$second, u0SPLib$RefHierarchy_Test$graph1);
}), (i1Test$isOkAndEqualTo)(({
  first: c0Core$Nil,
  second: (c0Core$Cons)("d", (c0Core$Cons)("e", (c0Core$Cons)("c", (c0Core$Cons)("b", (c0Core$Cons)("a", c0Core$Nil))))),
}))), (c0Core$Cons)((u0SPLib$RefHierarchy_Test$valueTest)("Circular", ((_0) => {
  return (u0SPLib$RefHierarchy$reorder)(c0Tuple$second, u0SPLib$RefHierarchy_Test$graph2);
}), (i1Test$isOkAndEqualTo)(({
  first: (c0Core$Cons)((c0Core$Cons)("b", (c0Core$Cons)("d", (c0Core$Cons)("c", c0Core$Nil))), c0Core$Nil),
  second: (c0Core$Cons)("d", (c0Core$Cons)("e", (c0Core$Cons)("c", (c0Core$Cons)("b", (c0Core$Cons)("a", c0Core$Nil))))),
}))), c0Core$Nil))));

const u0Targets$Emitted_Test$valueTest = (($0, $1, $2) => {
  return (i1Test$valueTest)(sp_toHuman, $0, $1, $2);
});

const u0Targets$Emitted_Test$javascript = (i1Test$Group)("JavaScript", (c0Core$Cons)((u0Targets$Emitted_Test$valueTest)("[reg] Imperative try..as should not force the function to return prematurely", ((_0) => {
  let $2 = false;
  return (!($2)
    ? 1
    : ($2
      ? 2
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Emitted_Test.sp 32:17', (sp_toHuman)($2))));
  return "abc";
}), (i1Test$isOkAndEqualTo)("abc")), (c0Core$Cons)((u0Targets$Emitted_Test$valueTest)("[reg] Pattern matching fails on None", ((_0) => {
  let $2 = null;
  return (true
    ? 1
    : (sp_throw)('Missing pattern in try..as', 'src/Targets/Emitted_Test.sp 44:17', (sp_toHuman)($2)));
}), (i1Test$isOkAndEqualTo)(1)), c0Core$Nil)));

const u0Targets$Emitted_Test$tests = (i1Test$Group)("Emitted", (c0Core$Cons)(u0Targets$Emitted_Test$javascript, c0Core$Nil));

const u0Main$allTests = (c0Core$Cons)(u0Human$Format_Test$tests, (c0Core$Cons)(u0Compiler$Lexer_Test$tests, (c0Core$Cons)(u0Compiler$Parser_Test$tests, (c0Core$Cons)(u0Compiler$MakeCanonical_Test$tests, (c0Core$Cons)(u0Compiler$TypeCheck_Test$tests, (c0Core$Cons)(u0Targets$Emitted_Test$tests, (c0Core$Cons)(c0Hash_Test$tests, (c0Core$Cons)(c0Array_Test$tests, (c0Core$Cons)(c0List_Test$tests, (c0Core$Cons)(c0Dict_Test$tests, (c0Core$Cons)(u3Uniqueness$specs, (c0Core$Cons)(u0SPLib$Format_Test$tests, (c0Core$Cons)(u0SPLib$RefHierarchy_Test$tests, c0Core$Nil)))))))))))));

const u0Platforms$Browser$defaultImportsFile = (u0DefaultImports$platformDefaultImportsFile)((c0Core$Cons)(({
  first: "Browser",
  second: c0Core$Nil,
}), (c0Core$Cons)(({
  first: "Html",
  second: c0Core$Nil,
}), (c0Core$Cons)(({
  first: "VirtualDom",
  second: c0Core$Nil,
}), c0Core$Nil))));

const u0Platforms$Browser$overrides = (($usr) => {
  return (c0Core$Cons)(({
    first: ($usr)("jsCreateTextNode"),
    second: "virtualDom_jsCreateTextNode",
  }), (c0Core$Cons)(({
    first: ($usr)("jsCreateElement"),
    second: "virtualDom_jsCreateElement",
  }), (c0Core$Cons)(({
    first: ($usr)("jsReplaceWith"),
    second: "virtualDom_jsReplaceWith",
  }), (c0Core$Cons)(({
    first: ($usr)("jsAppendChild"),
    second: "virtualDom_jsAppendChild",
  }), (c0Core$Cons)(({
    first: ($usr)("jsSetProperty"),
    second: "virtualDom_jsSetProperty",
  }), (c0Core$Cons)(({
    first: ($usr)("jsSetAttribute"),
    second: "virtualDom_jsSetAttribute",
  }), (c0Core$Cons)(({
    first: ($usr)("jsRemoveAttribute"),
    second: "virtualDom_jsRemoveAttribute",
  }), (c0Core$Cons)(({
    first: ($usr)("jsAddEventListener"),
    second: "virtualDom_jsAddEventListener",
  }), (c0Core$Cons)(({
    first: ($usr)("jsRemoveEventListener"),
    second: "virtualDom_jsRemoveEventListener",
  }), (c0Core$Cons)(({
    first: ($usr)("eventToText"),
    second: "virtualDom_eventToText",
  }), (c0Core$Cons)(({
    first: ($usr)("eventToFloat"),
    second: "virtualDom_eventToFloat",
  }), (c0Core$Cons)(({
    first: ($usr)("setChild"),
    second: "virtualDom_setChild",
  }), (c0Core$Cons)(({
    first: ($usr)("removeAllChildrenStartingFromIndex"),
    second: "virtualDom_removeAllChildrenStartingFromIndex",
  }), (c0Core$Cons)(({
    first: ($usr)("drawCanvas"),
    second: "virtualDom_drawCanvas",
  }), (c0Core$Cons)(({
    first: ($usr)("setViewportOf"),
    second: "virtualDom_setViewportOf",
  }), c0Core$Nil)))))))))))))));
});

const u0Platforms$Browser$virtualDomUsr = (($platformImportsPath) => {
  return (($0) => {
    return (c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)($platformImportsPath, "src/", "VirtualDom"), $0);
  });
});

const u0Targets$Javascript$EmittableToJs$accessAttrs = (($attrPath, $e) => {
  return (c0List$for)($e, $attrPath, u0Targets$Javascript$Ast$AccessWithDot);
});

const u0Targets$Javascript$EmittableToJs$accessArrayIndex = (($index, $j) => {
  return ((($0) => {
    return (u0Targets$Javascript$Ast$AccessWithBrackets)($0, $j);
  }))((u0Targets$Javascript$Ast$Literal)((text_fromNumber)($index)));
});

const u0Targets$Javascript$EmittableToJs$literalString = (($str) => {
  const $escaped = $str;
  return (u0Targets$Javascript$Ast$Literal)(("\"" + ($escaped + "\"")));
});

const u0Targets$Javascript$EmittableToJs$recycleTempVariable = (u0Targets$Javascript$Ast$Var)("__re__");

const u0Targets$Javascript$EmittableToJs$translateName = (($name) => {
  return ((text_startsWith)("'", $name)
    ? ((() => {
      const $head = (text_slice)(1, 2, $name);
      const $rest = (text_slice)(2, 9999, $name);
      return ("$" + ((text_toUpper)($head) + $rest));
    }))()
    : ("$" + $name));
});

const u0Targets$Javascript$EmittableToJs$makeCall = (($state, $env, $jaRef, $args) => {
  const $call = ((($0) => {
    return (u0Targets$Javascript$Ast$Call)($jaRef, $0);
  }))(((($0) => {
    return (c0List$map)((($0) => {
      return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateArg)($state, ({
        nativeBinop: false,
      }), $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
    }), $0);
  }))($args));
  const $asRecycled = (($arg) => {
    return ((($arg)[0] === "$ArgumentSpend")
      ? c0Maybe$Nothing
      : ((($arg)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $rawType = ($arg)[1];
          const $attrPath = ($arg)[2];
          const $name = ($arg)[3];
          return (c0Maybe$Just)(((($0) => {
            return (u0Targets$Javascript$EmittableToJs$accessAttrs)($attrPath, $0);
          }))((u0Targets$Javascript$Ast$Var)((u0Targets$Javascript$EmittableToJs$translateName)($name))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 387:8', (sp_toHuman)($arg))));
  });
  const $recycledArgs = (c0List$filterMap)($asRecycled, $args);
  return ([
    ((sp_equal)($recycledArgs, c0Core$Nil)
      ? $call
      : ((() => {
        const $zzz = (($index, $arg) => {
          const $bracketIndex = (u0Targets$Javascript$Ast$Literal)((text_fromNumber)(($index + 1)));
          return (u0Targets$Javascript$Ast$Binop)("=", $arg, (u0Targets$Javascript$Ast$AccessWithBrackets)($bracketIndex, u0Targets$Javascript$EmittableToJs$recycleTempVariable));
        });
        return (u0Targets$Javascript$Ast$Comma)((c0List$concat)((c0Core$Cons)((c0Core$Cons)((u0Targets$Javascript$Ast$Binop)("=", u0Targets$Javascript$EmittableToJs$recycleTempVariable, $call), c0Core$Nil), (c0Core$Cons)(((($0) => {
          return (c0List$indexedMap)($zzz, $0);
        }))($recycledArgs), (c0Core$Cons)((c0Core$Cons)((u0Targets$Javascript$Ast$AccessWithBrackets)((u0Targets$Javascript$Ast$Literal)("0"), u0Targets$Javascript$EmittableToJs$recycleTempVariable), c0Core$Nil), c0Core$Nil)))));
      }))()),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateRoot = (($0) => {
  return ((($0)[0] === "$Core")
    ? "c"
    : ((($0)[0] === "$User")
      ? "u"
      : ((($0)[0] === "$Installed")
        ? "i"
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 657:4', (sp_toHuman)($0)))));
});

const u0Targets$Javascript$EmittableToJs$translateUmr = (($state, $1) => {
  const $root = (($1)[1])[1];
  const $importsDir = (($1)[1])[2];
  const $sourceDir = ($1)[2];
  const $modulePath = ($1)[3];
  const $r = (u0Targets$Javascript$EmittableToJs$translateRoot)($root);
  const $address = ($importsDir + ("@" + $sourceDir));
  const $id = ((() => {
    const $3 = ((__re__ = (hash_get)($state.importsAndSourceDirToId, $address)), ($state.importsAndSourceDirToId = (__re__)[1]), (__re__)[0]);
    return ((($3)[0] === "$Just")
      ? ((() => {
        const $id_ = ($3)[1];
        return $id_;
      }))()
      : ((($3)[0] === "$Nothing")
        ? ((() => {
          const $id_ = (text_fromNumber)(((__re__ = (basics_cloneUni)($state.importsAndSourceDirCount)), ($state.importsAndSourceDirCount = (__re__)[1]), (__re__)[0]));
          ($state.importsAndSourceDirCount += 1);
          ((__re__ = (hash_insert)($state.importsAndSourceDirToId, $address, $id_)), ($state.importsAndSourceDirToId = (__re__)[1]), (__re__)[0]);
          return $id_;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 672:8', (sp_toHuman)($3))));
  }))();
  return ([
    ($r + ($id + (c0Text$replace)("/", "$", $modulePath))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateUsr = (($state, $1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return ([
    (((__re__ = (u0Targets$Javascript$EmittableToJs$translateUmr)($state, $umr)), ($state = (__re__)[1]), (__re__)[0]) + (u0Targets$Javascript$EmittableToJs$translateName)($name)),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$maybeOverrideUsr = (($state, $env, $usr) => {
  const $4 = (c0Dict$get)($usr, $env.overrides);
  return ([
    (((($4)[0] === "$Just") && ((($4)[1])[0] === "$Override"))
      ? ((() => {
        const $call = (($4)[1])[1].call;
        const $value = (($4)[1])[1].value;
        return ($value)($env);
      }))()
      : ((($4)[0] === "$Nothing")
        ? (u0Targets$Javascript$Ast$Var)(((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $usr)), ($state = (__re__)[1]), (__re__)[0]))
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 273:4', (sp_toHuman)($4)))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor = (($state, $env, $usr) => {
  const $4 = (c0Dict$get)($usr, $env.overrides);
  return ([
    (((($4)[0] === "$Just") && ((($4)[1])[0] === "$Override"))
      ? ((() => {
        const $call = (($4)[1])[1].call;
        const $value = (($4)[1])[1].value;
        return ($value)($env);
      }))()
      : ((($4)[0] === "$Nothing")
        ? (u0Targets$Javascript$Ast$Var)(((($0) => {
          return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
        }))($usr))
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 280:4', (sp_toHuman)($4)))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateExpression = (($state, $env, $eaExpression) => {
  return ([
    (((($eaExpression)[0] === "$Variable") && ((($eaExpression)[1])[0] === "$RefLocal"))
      ? ((() => {
        const $name = (($eaExpression)[1])[1];
        return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Var)((u0Targets$Javascript$EmittableToJs$translateName)($name)));
      }))()
      : (((($eaExpression)[0] === "$Variable") && ((($eaExpression)[1])[0] === "$RefPlaceholder"))
        ? ((() => {
          const $n = (($eaExpression)[1])[1];
          return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Var)((u0Targets$Javascript$EmittableToJs$translateName)((text_fromNumber)($n))));
        }))()
        : (((($eaExpression)[0] === "$Variable") && ((($eaExpression)[1])[0] === "$RefGlobal"))
          ? ((() => {
            const $usr = (($eaExpression)[1])[1];
            return (u0Targets$Javascript$EmittableToJs$Inline)(((__re__ = (u0Targets$Javascript$EmittableToJs$maybeOverrideUsr)($state, $env, $usr)), ($state = (__re__)[1]), (__re__)[0]));
          }))()
          : ((($eaExpression)[0] === "$Call")
            ? ((() => {
              const $ref = ($eaExpression)[1];
              const $args = ($eaExpression)[2];
              const $maybeNativeOverride = (((($ref)[0] === "$Variable") && ((($ref)[1])[0] === "$RefGlobal"))
                ? ((() => {
                  const $usr = (($ref)[1])[1];
                  return (c0Dict$get)($usr, $env.overrides);
                }))()
                : (true
                  ? c0Maybe$Nothing
                  : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 455:16', (sp_toHuman)($ref))));
              return (((($maybeNativeOverride)[0] === "$Just") && ((($maybeNativeOverride)[1])[0] === "$Override"))
                ? ((() => {
                  const $call = (($maybeNativeOverride)[1])[1].call;
                  return (u0Targets$Javascript$EmittableToJs$Inline)(((__re__ = ($call)($state, $env, $args)), ($state = (__re__)[1]), (__re__)[0]));
                }))()
                : ((($maybeNativeOverride)[0] === "$Nothing")
                  ? (u0Targets$Javascript$EmittableToJs$Inline)(((__re__ = (u0Targets$Javascript$EmittableToJs$makeCall)($state, $env, ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $ref)), ($state = (__re__)[1]), (__re__)[0]), $args)), ($state = (__re__)[1]), (__re__)[0]))
                  : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 459:12', (sp_toHuman)($maybeNativeOverride))));
            }))()
            : ((($eaExpression)[0] === "$Fn")
              ? ((() => {
                const $eaArgs = ($eaExpression)[1];
                const $body = ($eaExpression)[2];
                const $argsWithNames = ((() => {
                  const $zzz = (($index, $4) => {
                    const $re = $4.first;
                    const $maybeName = $4.second;
                    return ((($maybeName)[0] === "$Just")
                      ? ((() => {
                        const $name = ($maybeName)[1];
                        return ({
                          first: $re,
                          second: (u0Targets$Javascript$EmittableToJs$translateName)($name),
                        });
                      }))()
                      : ((($maybeName)[0] === "$Nothing")
                        ? ({
                          first: $re,
                          second: ("_" + (text_fromNumber)($index)),
                        })
                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 467:20', (sp_toHuman)($maybeName))));
                  });
                  return (c0List$indexedMap)($zzz, $eaArgs);
                }))();
                const $recycledPars = ((($0) => {
                  return (c0List$map)((($5) => {
                    const $name = $5.second;
                    return (u0Targets$Javascript$Ast$Var)($name);
                  }), $0);
                }))(((($0) => {
                  return (c0List$filter)(c0Tuple$first, $0);
                }))($argsWithNames));
                const $statementsRaw = ((() => {
                  const $4 = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpression)($state, $env, $body)), ($state = (__re__)[1]), (__re__)[0]);
                  return ((($4)[0] === "$Inline")
                    ? ((() => {
                      const $expr = ($4)[1];
                      return (c0Core$Cons)((u0Targets$Javascript$Ast$Return)($expr), c0Core$Nil);
                    }))()
                    : ((($4)[0] === "$Block")
                      ? ((() => {
                        const $block = ($4)[1];
                        return $block;
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 479:16', (sp_toHuman)($4))));
                }))();
                const $statementsFinal = ((sp_equal)($recycledPars, c0Core$Nil)
                  ? $statementsRaw
                  : ((() => {
                    const $addRecycled = (($stat) => {
                      return ((($stat)[0] === "$Return")
                        ? ((() => {
                          const $e = ($stat)[1];
                          return (u0Targets$Javascript$Ast$Return)((u0Targets$Javascript$Ast$Array)((sp_cons)($e, $recycledPars)));
                        }))()
                        : (true
                          ? $stat
                          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 493:24', (sp_toHuman)($stat))));
                    });
                    return (c0List$map)($addRecycled, $statementsRaw);
                  }))());
                return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$BlockLambda)((c0List$map)(c0Tuple$second, $argsWithNames), $statementsFinal));
              }))()
              : ((($eaExpression)[0] === "$LetIn")
                ? ((() => {
                  const $inExpression = ($eaExpression)[1].inExpression;
                  const $letExpression = ($eaExpression)[1].letExpression;
                  const $maybeName = ($eaExpression)[1].maybeName;
                  const $type = ($eaExpression)[1].type;
                  const $inStatements = ((() => {
                    const $4 = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpression)($state, $env, $inExpression)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((($4)[0] === "$Block")
                      ? ((() => {
                        const $stats = ($4)[1];
                        return $stats;
                      }))()
                      : ((($4)[0] === "$Inline")
                        ? ((() => {
                          const $jaExpression = ($4)[1];
                          return (c0Core$Cons)((u0Targets$Javascript$Ast$Return)($jaExpression), c0Core$Nil);
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 503:16', (sp_toHuman)($4))));
                  }))();
                  return ((($maybeName)[0] === "$Nothing")
                    ? ((() => {
                      const $4 = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpression)($state, $env, $letExpression)), ($state = (__re__)[1]), (__re__)[0]);
                      return ((($4)[0] === "$Inline")
                        ? ((() => {
                          const $expr = ($4)[1];
                          return (u0Targets$Javascript$EmittableToJs$Block)((sp_cons)((u0Targets$Javascript$Ast$Eval)($expr), $inStatements));
                        }))()
                        : ((($4)[0] === "$Block")
                          ? ((() => {
                            const $stats = ($4)[1];
                            return (u0Targets$Javascript$EmittableToJs$Block)((c0List$concat)((c0Core$Cons)($stats, (c0Core$Cons)($inStatements, c0Core$Nil))));
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 510:20', (sp_toHuman)($4))));
                    }))()
                    : ((($maybeName)[0] === "$Just")
                      ? ((() => {
                        const $name = ($maybeName)[1];
                        const $letStatement = ((($0) => {
                          return (u0Targets$Javascript$Ast$Define)((sp_equal)($type.uni, c0Compiler$Ast$Uni), (u0Targets$Javascript$EmittableToJs$translateName)($name), $0);
                        }))(((($0) => {
                          return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
                        }))($letExpression));
                        return (u0Targets$Javascript$EmittableToJs$Block)((sp_cons)($letStatement, $inStatements));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 507:12', (sp_toHuman)($maybeName))));
                }))()
                : ((($eaExpression)[0] === "$LiteralText")
                  ? ((() => {
                    const $string = ($eaExpression)[1];
                    return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$EmittableToJs$literalString)($string));
                  }))()
                  : ((($eaExpression)[0] === "$LiteralNumber")
                    ? ((() => {
                      const $num = ($eaExpression)[1];
                      return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Literal)((text_fromNumber)($num)));
                    }))()
                    : ((($eaExpression)[0] === "$Conditional")
                      ? ((() => {
                        const $test = ($eaExpression)[1];
                        const $true = ($eaExpression)[2];
                        const $false = ($eaExpression)[3];
                        return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Conditional)(((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $test)), ($state = (__re__)[1]), (__re__)[0]), ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $true)), ($state = (__re__)[1]), (__re__)[0]), ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $false)), ($state = (__re__)[1]), (__re__)[0])));
                      }))()
                      : ((($eaExpression)[0] === "$And")
                        ? ((() => {
                          const $eaTests = ($eaExpression)[1];
                          const $jaTests = (c0List$map)((($0) => {
                            return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
                          }), $eaTests);
                          const $4 = (c0List$reverse)($jaTests);
                          return ((($4)[0] === "$Nil")
                            ? (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Literal)("true"))
                            : ((($4)[0] === "$Cons")
                              ? ((() => {
                                const $head = ($4)[1];
                                const $tail = ($4)[2];
                                return (u0Targets$Javascript$EmittableToJs$Inline)(((($0) => {
                                  return (c0List$for)($0, $tail, (($test, $expr) => {
                                    return (u0Targets$Javascript$Ast$Binop)("&&", $test, $expr);
                                  }));
                                }))($head));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 537:12', (sp_toHuman)($4))));
                        }))()
                        : ((($eaExpression)[0] === "$ShallowEqual")
                          ? ((() => {
                            const $a = ($eaExpression)[1];
                            const $b = ($eaExpression)[2];
                            return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Binop)("===", ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $a)), ($state = (__re__)[1]), (__re__)[0]), ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $b)), ($state = (__re__)[1]), (__re__)[0])));
                          }))()
                          : ((($eaExpression)[0] === "$LiteralArray")
                            ? ((() => {
                              const $items = ($eaExpression)[1];
                              return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Array)(((($0) => {
                                return (c0List$map)((($0) => {
                                  return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
                                }), $0);
                              }))($items)));
                            }))()
                            : ((($eaExpression)[0] === "$ArrayAccess")
                              ? ((() => {
                                const $index = ($eaExpression)[1];
                                const $array = ($eaExpression)[2];
                                return (u0Targets$Javascript$EmittableToJs$Inline)(((($0) => {
                                  return (u0Targets$Javascript$EmittableToJs$accessArrayIndex)($index, $0);
                                }))(((($0) => {
                                  return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
                                }))($array)));
                              }))()
                              : ((($eaExpression)[0] === "$Constructor")
                                ? ((() => {
                                  const $usr = ($eaExpression)[1];
                                  return (u0Targets$Javascript$EmittableToJs$Inline)(((__re__ = (u0Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor)($state, $env, $usr)), ($state = (__re__)[1]), (__re__)[0]));
                                }))()
                                : ((($eaExpression)[0] === "$ConstructorAccess")
                                  ? ((() => {
                                    const $argIndex = ($eaExpression)[1];
                                    const $value = ($eaExpression)[2];
                                    return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$EmittableToJs$accessArrayIndex)(($argIndex + 1), ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $value)), ($state = (__re__)[1]), (__re__)[0])));
                                  }))()
                                  : ((($eaExpression)[0] === "$IsConstructor")
                                    ? ((() => {
                                      const $usr = ($eaExpression)[1];
                                      const $eaValue = ($eaExpression)[2];
                                      const $jaValue = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $eaValue)), ($state = (__re__)[1]), (__re__)[0]);
                                      return ((sp_equal)($usr, u0Compiler$CoreDefs$noneConsUsr)
                                        ? (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Var)("true"))
                                        : ((sp_equal)($usr, u0Compiler$CoreDefs$trueUsr)
                                          ? (u0Targets$Javascript$EmittableToJs$Inline)($jaValue)
                                          : ((sp_equal)($usr, u0Compiler$CoreDefs$falseUsr)
                                            ? (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Unop)("!", $jaValue))
                                            : ((() => {
                                              const $4 = $usr;
                                              const $name = ($4)[2];
                                              return (u0Targets$Javascript$EmittableToJs$Inline)(((($0) => {
                                                return (u0Targets$Javascript$Ast$Binop)("===", (u0Targets$Javascript$EmittableToJs$accessArrayIndex)(0, $jaValue), $0);
                                              }))((u0Targets$Javascript$EmittableToJs$literalString)((u0Targets$Javascript$EmittableToJs$translateName)($name))));
                                            }))())));
                                    }))()
                                    : ((($eaExpression)[0] === "$LiteralRecord")
                                      ? ((() => {
                                        const $maybeExtend = ($eaExpression)[1];
                                        const $attrNamesAndValues = ($eaExpression)[2];
                                        const $obj = (u0Targets$Javascript$Ast$Record)(((($0) => {
                                          return (c0List$for)($0, $attrNamesAndValues, (($6, $d) => {
                                            const $name = $6.first;
                                            const $value = $6.second;
                                            return (c0Dict$insert)($name, ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $value)), ($state = (__re__)[1]), (__re__)[0]), $d);
                                          }));
                                        }))(c0Dict$empty));
                                        return ((($maybeExtend)[0] === "$Nothing")
                                          ? (u0Targets$Javascript$EmittableToJs$Inline)($obj)
                                          : ((($maybeExtend)[0] === "$Just")
                                            ? ((() => {
                                              const $extend = ($maybeExtend)[1];
                                              return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$Call)((u0Targets$Javascript$Ast$Var)("Object.assign"), (c0Core$Cons)((u0Targets$Javascript$Ast$Record)(c0Dict$empty), (c0Core$Cons)(((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $extend)), ($state = (__re__)[1]), (__re__)[0]), (c0Core$Cons)($obj, c0Core$Nil)))));
                                            }))()
                                            : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 595:12', (sp_toHuman)($maybeExtend))));
                                      }))()
                                      : ((($eaExpression)[0] === "$RecordAccess")
                                        ? ((() => {
                                          const $attrName = ($eaExpression)[1];
                                          const $value = ($eaExpression)[2];
                                          return (u0Targets$Javascript$EmittableToJs$Inline)((u0Targets$Javascript$Ast$AccessWithDot)($attrName, ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $value)), ($state = (__re__)[1]), (__re__)[0])));
                                        }))()
                                        : ((($eaExpression)[0] === "$MissingPattern")
                                          ? ((() => {
                                            const $location = ($eaExpression)[1];
                                            const $value = ($eaExpression)[2];
                                            return (u0Targets$Javascript$EmittableToJs$Inline)(((($0) => {
                                              return (u0Targets$Javascript$Ast$Call)((u0Targets$Javascript$Ast$Literal)("sp_throw"), $0);
                                            }))((c0Core$Cons)((u0Targets$Javascript$Ast$Literal)("'Missing pattern in try..as'"), (c0Core$Cons)((u0Targets$Javascript$Ast$Literal)(("'" + ($location + "'"))), (c0Core$Cons)((u0Targets$Javascript$Ast$Call)((u0Targets$Javascript$Ast$Literal)("sp_toHuman"), (c0Core$Cons)(((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $value)), ($state = (__re__)[1]), (__re__)[0]), c0Core$Nil)), c0Core$Nil)))));
                                          }))()
                                          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 435:4', (sp_toHuman)($eaExpression))))))))))))))))))))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateExpressionToExpression = (($state, $env, $expr) => {
  const $4 = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpression)($state, $env, $expr)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ((($4)[0] === "$Inline")
      ? ((() => {
        const $e = ($4)[1];
        return $e;
      }))()
      : ((($4)[0] === "$Block")
        ? ((() => {
          const $block = ($4)[1];
          return (u0Targets$Javascript$Ast$Call)((u0Targets$Javascript$Ast$BlockLambda)(c0Core$Nil, $block), c0Core$Nil);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 373:4', (sp_toHuman)($4)))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateArg = (($state, $stuff, $env, $eaExpression) => {
  return ([
    ((($eaExpression)[0] === "$ArgumentSpend")
      ? ((() => {
        const $fullType = ($eaExpression)[1];
        const $e = ($eaExpression)[2];
        return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $e)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($eaExpression)[0] === "$ArgumentRecycle")
        ? ((() => {
          const $rawType = ($eaExpression)[1];
          const $attrPath = ($eaExpression)[2];
          const $name = ($eaExpression)[3];
          return (u0Targets$Javascript$EmittableToJs$accessAttrs)($attrPath, (u0Targets$Javascript$Ast$Var)((u0Targets$Javascript$EmittableToJs$translateName)($name)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 298:4', (sp_toHuman)($eaExpression)))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$binop = (($jsOp) => {
  return (u0Targets$Javascript$EmittableToJs$Override)(({
    call: (($state, $env, $arguments) => {
      return ([
        (((($arguments)[0] === "$Cons") && (((($arguments)[2])[0] === "$Cons") && (((($arguments)[2])[2])[0] === "$Nil")))
          ? ((() => {
            const $right = ($arguments)[1];
            const $left = (($arguments)[2])[1];
            return (u0Targets$Javascript$Ast$Binop)($jsOp, ((__re__ = (u0Targets$Javascript$EmittableToJs$translateArg)($state, ({
              nativeBinop: true,
            }), $env, $right)), ($state = (__re__)[1]), (__re__)[0]), ((__re__ = (u0Targets$Javascript$EmittableToJs$translateArg)($state, ({
              nativeBinop: true,
            }), $env, $left)), ($state = (__re__)[1]), (__re__)[0]));
          }))()
          : (true
            ? (sp_todo)(("compiler bug: wrong number of arguments for binop" + (sp_toHuman)(({
              arguments: $arguments,
              jsOp: $jsOp,
            }))))
            : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 166:8', (sp_toHuman)($arguments)))),
        $state,
      ]);
    }),
    value: (($env) => {
      return (sp_todo)(("binop " + ($jsOp + " has no raw value")));
    }),
  }));
});

const u0Targets$Javascript$EmittableToJs$constructor = (($jsValue) => {
  return (u0Targets$Javascript$EmittableToJs$Override)(({
    call: (($state, $env, $args) => {
      return ([
        ((__re__ = (u0Targets$Javascript$EmittableToJs$makeCall)($state, $env, (u0Targets$Javascript$Ast$Var)($jsValue), $args)), ($state = (__re__)[1]), (__re__)[0]),
        $state,
      ]);
    }),
    value: (($env) => {
      return (u0Targets$Javascript$Ast$Var)($jsValue);
    }),
  }));
});

const u0Targets$Javascript$EmittableToJs$function = (($jaName) => {
  return (u0Targets$Javascript$EmittableToJs$Override)(({
    call: (($state, $env, $args) => {
      return ([
        ((__re__ = (u0Targets$Javascript$EmittableToJs$makeCall)($state, $env, (u0Targets$Javascript$Ast$Var)($jaName), $args)), ($state = (__re__)[1]), (__re__)[0]),
        $state,
      ]);
    }),
    value: (($env) => {
      return (u0Targets$Javascript$Ast$Var)($jaName);
    }),
  }));
});

const u0Targets$Javascript$EmittableToJs$introspectOverride = ((() => {
  const $call = (($state, $env, $eaArgs) => {
    return ([
      (((($eaArgs)[0] === "$Cons") && (((($eaArgs)[1])[0] === "$ArgumentSpend") && ((($eaArgs)[2])[0] === "$Nil")))
        ? ((() => {
          const $raw = (($eaArgs)[1])[1].raw;
          const $e = (($eaArgs)[1])[2];
          const $expression = (u0Targets$Javascript$Ast$Literal)((JSON.stringify)($e));
          const $type = (u0Targets$Javascript$Ast$Literal)((JSON.stringify)($raw));
          const $nonFn = (u0Targets$Javascript$Ast$Array)(c0Core$Nil);
          const $value = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $e)), ($state = (__re__)[1]), (__re__)[0]);
          return (u0Targets$Javascript$Ast$Record)((c0Dict$fromList)((c0Core$Cons)(({
            first: "expression",
            second: $expression,
          }), (c0Core$Cons)(({
            first: "raw",
            second: $type,
          }), (c0Core$Cons)(({
            first: "nonFn",
            second: $nonFn,
          }), (c0Core$Cons)(({
            first: "value",
            second: $value,
          }), c0Core$Nil))))));
        }))()
        : (true
          ? (sp_todo)("introspectOverride BUG?!")
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 198:8', (sp_toHuman)($eaArgs)))),
      $state,
    ]);
  });
  return (u0Targets$Javascript$EmittableToJs$Override)(({
    call: $call,
    value: (($env) => {
      return (sp_todo)("TODO: monomorphization is not yet implemented so `introspect` can only be called directly");
    }),
  }));
}))();

const u0Targets$Javascript$EmittableToJs$loadOverride = ((() => {
  const $call = (($state, $env, $eaArgs) => {
    const $jaArgs = (c0List$map)((($0) => {
      return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateArg)($state, ({
        nativeBinop: false,
      }), $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
    }), $eaArgs);
    const $requestedTypeHumanized = (((($eaArgs)[0] === "$Cons") && (((($eaArgs)[2])[0] === "$Cons") && ((((($eaArgs)[2])[1])[0] === "$ArgumentSpend") && (((((($eaArgs)[2])[1])[1].raw)[0] === "$TypeFn") && ((((((($eaArgs)[2])[1])[1].raw)[1])[0] === "$Cons") && (((((((($eaArgs)[2])[1])[1].raw)[1])[1])[0] === "$ParSp") && (((((((($eaArgs)[2])[1])[1].raw)[1])[2])[0] === "$Nil") && (((($eaArgs)[2])[2])[0] === "$Nil"))))))))
      ? ((() => {
        const $compiledProgram = ($eaArgs)[1];
        const $compiledType = (((((($eaArgs)[2])[1])[1].raw)[1])[1])[1].raw;
        let $hash = (hash_fromList)(c0Core$Nil);
        return (u0Targets$Javascript$EmittableToJs$literalString)((sp_toHuman)(((($0) => {
          return ((__re__ = (c0Compiler$TypedAst$normalizeType)($hash, $0)), ($hash = (__re__)[1]), (__re__)[0]);
        }))($compiledType)));
      }))()
      : (true
        ? (sp_todo)("loadOverride BUG?!")
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 244:12', (sp_toHuman)($eaArgs))));
    return ([
      (u0Targets$Javascript$Ast$Call)((u0Targets$Javascript$Ast$Var)("self_load"), (c0Core$Cons)($requestedTypeHumanized, $jaArgs)),
      $state,
    ]);
  });
  return (u0Targets$Javascript$EmittableToJs$Override)(({
    call: $call,
    value: (($env) => {
      return (sp_todo)("TODO: load as value... I guess we need monomorphization?");
    }),
  }));
}))();

const u0Targets$Javascript$EmittableToJs$unaryMinus = (u0Targets$Javascript$EmittableToJs$Override)(({
  call: (($state, $env, $arguments) => {
    return ([
      (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentSpend") && ((($arguments)[2])[0] === "$Nil")))
        ? ((() => {
          const $fullType = (($arguments)[1])[1];
          const $arg = (($arguments)[1])[2];
          return (u0Targets$Javascript$Ast$Unop)("-", ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $arg)), ($state = (__re__)[1]), (__re__)[0]));
        }))()
        : (true
          ? (sp_todo)("compiler bug: wrong number of arguments for unop")
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 148:8', (sp_toHuman)($arguments)))),
      $state,
    ]);
  }),
  value: (($env) => {
    return (sp_todo)("unaryMinus has no raw value");
  }),
}));

const u0Targets$Javascript$EmittableToJs$unaryPlus = (u0Targets$Javascript$EmittableToJs$Override)(({
  call: (($state, $env, $arguments) => {
    return ([
      (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentSpend") && ((($arguments)[2])[0] === "$Nil")))
        ? ((() => {
          const $fullType = (($arguments)[1])[1];
          const $arg = (($arguments)[1])[2];
          return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $arg)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : (true
          ? (sp_todo)("compiler bug: wrong number of arguments for unop")
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 131:8', (sp_toHuman)($arguments)))),
      $state,
    ]);
  }),
  value: (($env) => {
    return (sp_todo)("unaryPlus has no raw value");
  }),
}));

const u0Targets$Javascript$EmittableToJs$coreOverrides = ((_0) => {
  const $corelib = (($module, $name) => {
    return (c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)(u0Compiler$CoreDefs$importsPath, "src", $module), $name);
  });
  return (c0Dict$fromList)((c0Core$Cons)(({
    first: u0Compiler$CoreDefs$unaryPlus.usr,
    second: u0Targets$Javascript$EmittableToJs$unaryPlus,
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$unaryMinus.usr,
    second: u0Targets$Javascript$EmittableToJs$unaryMinus,
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$add.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("+"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$multiply.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("*"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$subtract.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("-"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$mutableAssign.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("="),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$mutableAdd.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("+="),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$mutableSubtract.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("-="),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$textConcat.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("+"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$greaterThan.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)(">"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$lesserThan.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("<"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$greaterOrEqualThan.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)(">="),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$lesserOrEqualThan.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("<="),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$or_.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("||"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$and_.usr,
    second: (u0Targets$Javascript$EmittableToJs$binop)("&&"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$trueUsr,
    second: (u0Targets$Javascript$EmittableToJs$constructor)("true"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$falseUsr,
    second: (u0Targets$Javascript$EmittableToJs$constructor)("false"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$noneConsUsr,
    second: (u0Targets$Javascript$EmittableToJs$constructor)("null"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$divide.usr,
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_divide"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$listCons.usr,
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_cons"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$equal.usr,
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_equal"),
  }), (c0Core$Cons)(({
    first: u0Compiler$CoreDefs$notEqual.usr,
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_not_equal"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Basics", "modBy"),
    second: (u0Targets$Javascript$EmittableToJs$function)("basics_modBy"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Basics", "round"),
    second: (u0Targets$Javascript$EmittableToJs$function)("Math.round"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Basics", "cloneImm"),
    second: (u0Targets$Javascript$EmittableToJs$function)("basics_cloneImm"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Basics", "cloneUni"),
    second: (u0Targets$Javascript$EmittableToJs$function)("basics_cloneUni"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Basics", "compare"),
    second: (u0Targets$Javascript$EmittableToJs$function)("basics_compare"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Debug", "log"),
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_log"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Debug", "todo"),
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_todo"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Debug", "toHuman"),
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_toHuman"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Debug", "benchStart"),
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_benchStart"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Debug", "benchStop"),
    second: (u0Targets$Javascript$EmittableToJs$function)("sp_benchStop"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "fromNumber"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_fromNumber"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "toLower"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_toLower"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "toUpper"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_toUpper"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "toNumber"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_toNumber"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "split"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_split"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "length"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_length"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "slice"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_slice"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "startsWith"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_startsWith"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "startsWithRegex"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_startsWithRegex"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "replaceRegex"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_replaceRegex"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "trimLeft"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_trimLeft"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "dropLeft"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_dropLeft"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Text", "forEach"),
    second: (u0Targets$Javascript$EmittableToJs$function)("text_forEach"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "fromList"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_fromList"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "insert"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_insert"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "remove"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_remove"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "get"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_get"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "for"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_for"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "each"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_each"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Hash", "pop"),
    second: (u0Targets$Javascript$EmittableToJs$function)("hash_pop"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "each"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_each"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "push"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_push"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "pop"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_pop"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "get"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_get"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "set"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_set"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "sortBy"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_sortBy"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "fromList"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_fromList"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Array", "toList"),
    second: (u0Targets$Javascript$EmittableToJs$function)("array_toList"),
  }), (c0Core$Cons)(({
    first: ($corelib)("List", "sortBy"),
    second: (u0Targets$Javascript$EmittableToJs$function)("list_sortBy"),
  }), (c0Core$Cons)(({
    first: ($corelib)("Self", "load"),
    second: u0Targets$Javascript$EmittableToJs$loadOverride,
  }), (c0Core$Cons)(({
    first: ($corelib)("Self", "introspect"),
    second: u0Targets$Javascript$EmittableToJs$introspectOverride,
  }), (c0Core$Cons)(({
    first: ($corelib)("Self", "internalRepresentation"),
    second: (u0Targets$Javascript$EmittableToJs$function)("JSON.stringify"),
  }), c0Core$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
});

const u0Targets$Javascript$EmittableToJs$constructorArgumentName = (($i) => {
  return ("$" + (text_fromNumber)($i));
});

const u0Targets$Javascript$EmittableToJs$translateConstructorDef = (($state, $1) => {
  const $usr = $1.first;
  const $taType = $1.second;
  const $3 = $usr;
  const $nameWithApostrophe = ($3)[2];
  const $umr = ($3)[1];
  const $arrayHead = (u0Targets$Javascript$EmittableToJs$literalString)((u0Targets$Javascript$EmittableToJs$translateName)($nameWithApostrophe));
  const $definitionBody = ((($taType)[0] === "$TypeFn")
    ? ((() => {
      const $pars = ($taType)[1];
      const $out = ($taType)[2];
      const $argNames = ((($0) => {
        return (c0List$indexedMap)((($index, $name) => {
          return (u0Targets$Javascript$EmittableToJs$constructorArgumentName)(($index + 1));
        }), $0);
      }))($pars);
      return ((($0) => {
        return (u0Targets$Javascript$Ast$SimpleLambda)($argNames, $0);
      }))((u0Targets$Javascript$Ast$Array)((sp_cons)($arrayHead, (c0List$map)(u0Targets$Javascript$Ast$Var, $argNames))));
    }))()
    : (true
      ? (u0Targets$Javascript$Ast$Array)((c0Core$Cons)($arrayHead, c0Core$Nil))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 633:8', (sp_toHuman)($taType))));
  return ([
    (u0Targets$Javascript$Ast$Define)(false, ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $usr)), ($state = (__re__)[1]), (__re__)[0]), $definitionBody),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateDef = (($state, $env, $def) => {
  const $4 = (c0Dict$get)($def.usr, $env.overrides);
  return ([
    ((($4)[0] === "$Just")
      ? c0Maybe$Nothing
      : ((($4)[0] === "$Nothing")
        ? (c0Maybe$Just)((u0Targets$Javascript$Ast$Define)(false, ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $def.usr)), ($state = (__re__)[1]), (__re__)[0]), ((__re__ = (u0Targets$Javascript$EmittableToJs$translateExpressionToExpression)($state, $env, $def.expr)), ($state = (__re__)[1]), (__re__)[0])))
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 651:4', (sp_toHuman)($4)))),
    $state,
  ]);
});

const u0Targets$Javascript$EmittableToJs$translateAll = (($state, $pars) => {
  const $3 = $pars;
  const $platformOverrides = $3.platformOverrides;
  const $eaDefs = $3.eaDefs;
  const $constructors = $3.constructors;
  const $jaConstructors = (c0List$map)((($0) => {
    return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateConstructorDef)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
  }), $constructors);
  const $env = ({
    overrides: (c0List$for)((u0Targets$Javascript$EmittableToJs$coreOverrides)(null), $platformOverrides, (($5, $d) => {
      const $usr = $5.first;
      const $runtimeName = $5.second;
      return (c0Dict$insert)($usr, (u0Targets$Javascript$EmittableToJs$function)($runtimeName), $d);
    })),
  });
  const $jaStatements = (c0List$filterMap)((($0) => {
    return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateDef)($state, $env, $0)), ($state = (__re__)[1]), (__re__)[0]);
  }), $eaDefs);
  return ([
    (c0List$concat)((c0Core$Cons)($jaConstructors, (c0Core$Cons)($jaStatements, c0Core$Nil))),
    $state,
  ]);
});

const u0Targets$Javascript$JsToText$id = (($level) => {
  return (c0Text$repeat)($level, "  ");
});

const u0Targets$Javascript$JsToText$emitBlock = (($l, $block) => {
  const $lines = ((($0) => {
    return (c0Text$join)("\n", $0);
  }))(((($0) => {
    return (c0List$map)((($0) => {
      return (u0Targets$Javascript$JsToText$emitStatement)(($l + 1), $0);
    }), $0);
  }))($block));
  return ("{\n" + ($lines + ("\n" + ((u0Targets$Javascript$JsToText$id)($l) + "}"))));
});

const u0Targets$Javascript$JsToText$emitExpr = (($l, $expression) => {
  return ((($expression)[0] === "$Literal")
    ? ((() => {
      const $s = ($expression)[1];
      return $s;
    }))()
    : ((($expression)[0] === "$Var")
      ? ((() => {
        const $n = ($expression)[1];
        return $n;
      }))()
      : ((($expression)[0] === "$Call")
        ? ((() => {
          const $ref = ($expression)[1];
          const $args = ($expression)[2];
          return ("(" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $ref) + (")(" + ((c0Text$join)(", ", (c0List$map)((($0) => {
            return (u0Targets$Javascript$JsToText$emitExpr)($l, $0);
          }), $args)) + ")"))));
        }))()
        : ((($expression)[0] === "$Unop")
          ? ((() => {
            const $op = ($expression)[1];
            const $left = ($expression)[2];
            return ($op + ("(" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $left) + ")")));
          }))()
          : ((($expression)[0] === "$Binop")
            ? ((() => {
              const $op = ($expression)[1];
              const $left = ($expression)[2];
              const $right = ($expression)[3];
              return ("(" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $left) + (" " + ($op + (" " + ((u0Targets$Javascript$JsToText$emitExpr)($l, $right) + ")"))))));
            }))()
            : ((($expression)[0] === "$Mutop")
              ? ((() => {
                const $op = ($expression)[1];
                const $yield = ($expression)[2];
                const $left = ($expression)[3];
                const $right = ($expression)[4];
                return ("(" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $left) + (" " + ($op + (" " + ((u0Targets$Javascript$JsToText$emitExpr)($l, $right) + (", " + ($yield + ")"))))))));
              }))()
              : ((($expression)[0] === "$SimpleLambda")
                ? ((() => {
                  const $params = ($expression)[1];
                  const $expr = ($expression)[2];
                  return ("((" + ((c0Text$join)(", ", $params) + (") => " + ((u0Targets$Javascript$JsToText$emitExpr)($l, $expr) + ")"))));
                }))()
                : ((($expression)[0] === "$BlockLambda")
                  ? ((() => {
                    const $params = ($expression)[1];
                    const $stats = ($expression)[2];
                    return ("((" + ((c0Text$join)(", ", $params) + (") => " + ((u0Targets$Javascript$JsToText$emitBlock)($l, $stats) + ")"))));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $attrs = ($expression)[1];
                      return ((sp_equal)($attrs, c0Dict$empty)
                        ? "{}"
                        : ((($a) => {
                          return ("({\n" + ((c0Text$join)("\n", $a) + ("\n" + ((u0Targets$Javascript$JsToText$id)($l) + "})"))));
                        }))(((($0) => {
                          return (c0List$map)((($4) => {
                            const $key = $4.first;
                            const $value = $4.second;
                            return ((u0Targets$Javascript$JsToText$id)(($l + 1)) + ($key + (": " + ((u0Targets$Javascript$JsToText$emitExpr)(($l + 1), $value) + ","))));
                          }), $0);
                        }))(((($0) => {
                          return (list_sortBy)(c0Tuple$first, $0);
                        }))((c0Dict$toList)($attrs)))));
                    }))()
                    : ((($expression)[0] === "$AccessWithDot")
                      ? ((() => {
                        const $name = ($expression)[1];
                        const $e = ($expression)[2];
                        return ((u0Targets$Javascript$JsToText$emitExpr)($l, $e) + ("." + $name));
                      }))()
                      : ((($expression)[0] === "$AccessWithBrackets")
                        ? ((() => {
                          const $i = ($expression)[1];
                          const $expr = ($expression)[2];
                          return ("(" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $expr) + (")[" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $i) + "]"))));
                        }))()
                        : ((($expression)[0] === "$Conditional")
                          ? ((() => {
                            const $p = ($expression)[1];
                            const $true = ($expression)[2];
                            const $false = ($expression)[3];
                            return (("(" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $p) + "\n")) + (((u0Targets$Javascript$JsToText$id)(($l + 1)) + ("? " + (u0Targets$Javascript$JsToText$emitExpr)(($l + 1), $true))) + ("\n" + (((u0Targets$Javascript$JsToText$id)(($l + 1)) + (": " + (u0Targets$Javascript$JsToText$emitExpr)(($l + 1), $false))) + ")"))));
                          }))()
                          : ((($expression)[0] === "$Array")
                            ? ((() => {
                              const $items = ($expression)[1];
                              return ((sp_equal)($items, c0Core$Nil)
                                ? "[]"
                                : ((($0) => {
                                  return ((($a) => {
                                    return ("([\n" + ((c0Text$join)("\n", $a) + ("\n" + ((u0Targets$Javascript$JsToText$id)($l) + "])"))));
                                  }))($0);
                                }))(((($0) => {
                                  return (c0List$map)((($i) => {
                                    return ((u0Targets$Javascript$JsToText$id)(($l + 1)) + ((u0Targets$Javascript$JsToText$emitExpr)(($l + 1), $i) + ","));
                                  }), $0);
                                }))($items)));
                            }))()
                            : ((($expression)[0] === "$Comma")
                              ? ((() => {
                                const $expr = ($expression)[1];
                                return ("(" + ((c0Text$join)(", ", (c0List$map)((($0) => {
                                  return (u0Targets$Javascript$JsToText$emitExpr)($l, $0);
                                }), $expr)) + ")"));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/JsToText.sp 43:4', (sp_toHuman)($expression))))))))))))))));
});

const u0Targets$Javascript$JsToText$emitStatement = (($l, $stat) => {
  const $std = (($mid, $expr) => {
    return ((u0Targets$Javascript$JsToText$id)($l) + ($mid + ((u0Targets$Javascript$JsToText$emitExpr)($l, $expr) + ";")));
  });
  return ((($stat)[0] === "$Eval")
    ? ((() => {
      const $e = ($stat)[1];
      return ($std)("", $e);
    }))()
    : ((($stat)[0] === "$Return")
      ? ((() => {
        const $e = ($stat)[1];
        return ($std)("return ", $e);
      }))()
      : ((($stat)[0] === "$Define")
        ? ((() => {
          const $isReassignable = ($stat)[1];
          const $name = ($stat)[2];
          const $e = ($stat)[3];
          const $modifier = ($isReassignable
            ? "let"
            : "const");
          return ($std)(($modifier + (" " + ($name + " = "))), $e);
        }))()
        : ((($stat)[0] === "$If")
          ? ((() => {
            const $condition = ($stat)[1];
            const $block = ($stat)[2];
            return ((u0Targets$Javascript$JsToText$id)($l) + ("if (" + ((u0Targets$Javascript$JsToText$emitExpr)($l, $condition) + (") " + (u0Targets$Javascript$JsToText$emitBlock)($l, $block)))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/JsToText.sp 12:4', (sp_toHuman)($stat))))));
});

const u0Platforms$Browser$compile = (($state, $platformImportsPath, $out) => {
  (sp_log)("Creating JS AST...", "");
  const $jaStatements = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateAll)($state, ({
    constructors: $out.constructors,
    eaDefs: $out.defs,
    platformOverrides: (u0Platforms$Browser$overrides)((u0Platforms$Browser$virtualDomUsr)($platformImportsPath)),
  }))), ($state = (__re__)[1]), (__re__)[0]);
  (sp_log)("Emitting JS...", "");
  return ([
    ((($0) => {
      return (c0Text$join)("\n\n", $0);
    }))(((($0) => {
      return (c0List$map)((($0) => {
        return (u0Targets$Javascript$JsToText$emitStatement)(0, $0);
      }), $0);
    }))($jaStatements)),
    $state,
  ]);
});

const u0Platforms$Browser$footer = (($state, $platformImportsPath, $pars) => {
  const $mainName = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $pars.entryUsr)), ($state = (__re__)[1]), (__re__)[0]);
  const $updateDomNode = ((($0) => {
    return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
  }))(((u0Platforms$Browser$virtualDomUsr)($platformImportsPath))("updateDomNode"));
  return ([
    ("\n// TODO these globals will be a hell of trouble if we want to run more than one app\nlet effects = [];\nlet oldVirtualDom = {}; // TODO this should be properly initialized\nlet model = null;\nlet elementId = null;\n\nfunction dispatch(msgResult) {\n    if (msgResult[0] === \"Ok\") {\n\n        const msg = msgResult[1];\n\n        model =" + ($mainName + (".update(effects, msg, model)[0];\n\n            // TODO set a flag and use requestAnimationFrame\n            updateDom();\n        } else {\n            console.log('rejecting msg: ', msgResult[1]);\n        }\n    }\n\n\n    function updateDom() {\n        const e = win.document.getElementById(elementId);\n\n        const newVirtualDom =" + ($mainName + (".view(model);\n\n" + ($updateDomNode + ("(newVirtualDom, oldVirtualDom, e.childNodes[0]);\n\n        oldVirtualDom = newVirtualDom;\n\n        effects.forEach((e) => e());\n        effects = [];\n    }\n\n\n\n    function main(eid) {\n        elementId = eid;\n        model =" + ($mainName + ".init(effects)[0];\n        updateDom();\n    }\n\n\n\n\n\n    win.Squarepants = {\n        main: main,\n    };\n\n})(this);\n")))))))),
    $state,
  ]);
});

const u0Platforms$Browser$header = "(function (win) {\n";

const u0Platforms$Browser$runtime = "const crawlObject = (path, type, object) => {\n\n    while(path[0] === 'Cons') {\n\n        const head = path[1];\n        const tail = path[2];\n\n        const o = object[head];\n\n        if (o === undefined) {\n            return [ 'Err', 'no field named: ' + head ];\n        }\n\n        object = o;\n        path = path[2];\n    }\n\n    return typeof object === type\n        ? [ 'Ok', object ]\n        : [ 'Err', 'wrong type: ' + typeof object ]\n        ;\n}\n\n\nconst virtualDom_eventToText = (path, event) => crawlObject(path, 'string', event);\nconst virtualDom_eventToFloat = (path, event) => crawlObject(path, 'number', event);\n\n// TODO ensure that those who must return None actually return None (ie, null)\nconst virtualDom_jsCreateTextNode = (content) => document.createTextNode(content);\nconst virtualDom_jsCreateElement = (tag) => document.createElement(tag);\nconst virtualDom_jsReplaceWith = (new_, old) => { old.replaceWith(new_); return new_; }\nconst virtualDom_jsAppendChild = (pars) => pars.parent.appendChild(pars.child);\nconst virtualDom_jsSetAttribute = (name, value, node) => node.setAttribute(name, value);\nconst virtualDom_jsRemoveAttribute = (name, node) => node.removeAttribute(name);\nconst virtualDom_jsSetProperty = (name, value, node) => node[name] = value;\n\n\nconst virtualDom_setChild = (upd, index, parentNode) => {\n    const child = parentNode.childNodes[index];\n    child && upd(child);\n};\n\n\nconst virtualDom_removeAllChildrenStartingFromIndex = (index, parentNode) => {\n    while(parentNode.childNodes[index]) {\n      parentNode.removeChild(parentNode.childNodes[index]);\n    }\n}\n\n\n// an EventHandler is a function that takes an Event and produces a msg\nconst virtualDom_jsAddEventListener = (eventName, handler, node) => {\n\n    node.squarepantsEventHandlers = node.squarepantsEventHandlers || {};\n\n    if (node.squarepantsEventHandlers[eventName]) {\n      node.removeEventListener(eventName, node.squarepantsEventHandlers[eventName]);\n    }\n\n    const onEvent = (event) => dispatch(handler(event));\n    node.squarepantsEventHandlers[eventName] = onEvent;\n    node.addEventListener(eventName, onEvent);\n};\n\nconst virtualDom_jsRemoveEventListener = (eventName, handler, node) => {\n    node.removeEventListener(eventName, node.squarepantsEventHandlers[eventName]);\n    node.squarepantsEventHandlers[eventName] = undefined;\n}\n\n\nconst virtualDom_setViewportOf = (id, top, left) => () => {\n    const e = document.getElementById(id);\n    if (!e) {\n        console.error('could not find element #' + id);\n        return\n    }\n\n    e.scrollTop = top;\n    e.scrollLeft = left;\n}\n\n\nconst virtualDom_drawCanvas = (canvasId, shaderFn) => () => {\n\n    const canvas = document.getElementById(canvasId);\n    if (!canvas) {\n        console.error('could not find canvas', canvasId);\n        return\n    }\n\n    const w = canvas.width;\n    const h = canvas.height;\n\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.createImageData(w, h);\n\n    for (let x = 0; x < w; x++) for (let y = 0; y < h; y++) {\n\n        const frag = shaderFn(x / (w - 1), 1 - y / (h - 1));\n\n        let j = (x + y * w) * 4;\n        imageData.data[j + 0] = frag.r * 255;\n        imageData.data[j + 1] = frag.g * 255;\n        imageData.data[j + 2] = frag.b * 255;\n        imageData.data[j + 3] = 255;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n};";

const u0Targets$Javascript$EmittableToJs$initState = ({
  importsAndSourceDirCount: 0,
  importsAndSourceDirToId: (hash_fromList)(c0Core$Nil),
});

const u0Targets$Javascript$Runtime$listConsName = (u0Targets$Javascript$EmittableToJs$translateName)(u0Compiler$CoreDefs$consName);

const u0Targets$Javascript$Runtime$listNilName = (u0Targets$Javascript$EmittableToJs$translateName)(u0Compiler$CoreDefs$nilName);

const u0Targets$Javascript$Runtime$nativeDefinitions = (($state) => {
  const $nothingRef = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, (c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)(u0Compiler$CoreDefs$importsPath, "src", "Maybe"), "'nothing"))), ($state = (__re__)[1]), (__re__)[0]);
  const $justRef = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, (c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)(u0Compiler$CoreDefs$importsPath, "src", "Maybe"), "'just"))), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ("let __re__;\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a, b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i], b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k], b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a, b) => {\n  return !sp_equal(a, b);\n}\n\n\nconst basics_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = basics_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = basics_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (left, right) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\n// TODO remove this and handle it like any other op?\nconst basics_modBy = (a, b) => b % a;\n\n\nconst basics_cloneImm = sp_clone;\n\n\nconst basics_cloneUni = (uni) =>\n    [ sp_clone(uni), uni ];\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message, thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\n// TODO how should benchmark work in a browser?\ntypeof process !== 'undefined' && process.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.error(\"\");\n        console.error(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.error(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst id = (n) => '    '.repeat(n);\n\n\nconst sp_toHuman = (a, l = 0) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a, l) || sp_toHumanAsDict(a, l) || sp_toHumanAsUnion(a, l);\n\n  if (typeof a === 'function') {\n    return '<fn ' + a.length + '>';\n  }\n\n  if (typeof a === 'object') {\n    let acc = '{\\n';\n    for (let key in a)\n        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\\n';\n\n    return acc + id(l) + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a, l) => {\n\n  if (a.length === 1) {\n      return a[0];\n  }\n\n  let acc = a[0] + '\\n';\n\n  a.slice(1).forEach(arg => {\n\n      const sub = sp_toHuman(arg, l + 1);\n      if (!sub.startsWith('{') && sub.indexOf('\\n') > -1)\n          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\\n';\n      else\n          acc += id(l + 1) + sub + '\\n';\n\n  })\n\n  return acc;\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list, l) => {\n  if (list[0] === '" + (u0Targets$Javascript$Runtime$listConsName + ("' && list.length === 3) {\n    arrayAccum.push(sp_toHuman(list[1], l));\n    return sp_toHumanAsList(arrayAccum, list[2], l);\n  }\n\n  if (list[0] === '" + (u0Targets$Javascript$Runtime$listNilName + ("')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\nconst sp_toHumanAsDict = (dict, l) => {\n  if (dict[0] === 'RBNode_elm_builtin') {\n      return 'DICT' + sp_toHumanAsList([], $core$Dict$toList(dict), l);\n  }\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ?" + ($nothingRef + (":" + ($justRef + ("(n);\n    }\n\n    const text_toLower = (s) => s.toLowerCase()\n\n    const text_toUpper = (s) => s.toUpperCase()\n\n    const text_split = (separator, target) => arrayToListLow(target.split(separator));\n\n    const text_length = (s) => s.length;\n\n    const text_slice = (start, end, s) => s.slice(start, end);\n\n    const text_startsWith = (sub, s) => s.startsWith(sub);\n\n    const text_startsWithRegex = (regex) => {\n      let re;\n      try {\n        re = new RegExp('^' + regex, 's');\n      } catch (e) {\n        return () => \"\"\n      }\n\n      return (s) => {\n        let m = s.match(re);\n        return m ? m[0] : \"\";\n      }\n    }\n\n    const text_replaceRegex = (regex) => {\n      let re;\n      try {\n        re = new RegExp(regex, 'g');\n      } catch (e) {\n        return () => \"\"\n      }\n\n      return (replacer, s) => s.replace(re, replacer);\n    }\n\n    const text_trimLeft = (s) => s.trimLeft();\n\n    const text_dropLeft = (n, s) => s.slice(n);\n\n    const text_forEach = (s, f) => {\n      for (let i of s) f(i);\n      return null;\n    }\n\n\n    //\n    // Hashes\n    //\n\n    const hash_pop = (hash) => {\n        for (let key in hash) {\n            const [actualKey, value] = hash[key];\n            delete hash[key];\n            return [" + ($justRef + ("({ first: actualKey, second: value }), hash ];\n        }\n\n        return [" + ($nothingRef + (", hash ];\n    }\n\n\n    const hash_fromList = (list) => {\n      const hash = {};\n\n      // TODO iteration instead of recursion\n      const rec = (ls) => {\n        if (ls[0] === '" + (u0Targets$Javascript$Runtime$listNilName + ("')\n          return hash;\n\n        const { first, second } = ls[1];\n\n        hash[JSON.stringify(first)] = [first, second];\n\n        return rec(ls[2]);\n      };\n\n      return rec(list);\n    }\n\n\n    const hash_insert = (hash, key, value) => {\n        hash[JSON.stringify(key)] = [key, value];\n        return [null, hash];\n    }\n\n\n    const hash_remove = (hash, key) => {\n        delete hash[JSON.stringify(key)];\n        return [null, hash];\n    }\n\n\n    const hash_get = (hash, key) => {\n        const r = hash[JSON.stringify(key)];\n        return [r === undefined ?" + ($nothingRef + (":" + ($justRef + ("(r[1]), hash];\n    }\n\n\n    const hash_for = (hash, f, acc) => {\n        for (let k in hash) {\n            const kv = hash[k];\n            acc = f(kv[0], kv[1], acc);\n        }\n        return [acc, hash];\n    }\n\n\n    const hash_each = (hash, f) => {\n        for (let k in hash) {\n            const kv = hash[k];\n            f(kv[0], kv[1]);\n        }\n        return [null, hash];\n    }\n\n\n    //\n    // Arrays\n    //\n\n    const array_each = (array, f) => {\n        array.forEach(f);\n        return [null, array];\n    }\n\n    const array_push = (array, item) => {\n        array.push(item);\n        return [null, array];\n    }\n\n    const array_pop = (a) => {\n        return [a.length ?" + ($justRef + ("(a.pop()) :" + ($nothingRef + (", a];\n    }\n\n    const array_get = (array, index) => {\n        const r = array[index];\n        return [r === undefined ?" + ($nothingRef + (":" + ($justRef + ("(r), array];\n    }\n\n    const array_set = (a, index, item) => {\n        if (index < 0) return false;\n        if (index >= a.length) return [false, a];\n        a[index] = item;\n        return [true, a];\n    }\n\n    const array_sortBy = (arr, f) => {\n        arr.sort((a, b) => basics_compare(f(a), f(b)));\n        return [null, arr];\n    }\n\n    const arrayToListLow = (arr) => {\n      const length = arr.length;\n      let list = [ '" + (u0Targets$Javascript$Runtime$listNilName + ("' ];\n      for (let i = length - 1; i >= 0; i--) {\n          list = [ '" + (u0Targets$Javascript$Runtime$listConsName + ("', arr[i], list ];\n      }\n      return list;\n    }\n\n    const array_toList = (arr) => [arrayToListLow(arr), arr];\n\n\n    const arrayFromListLow = (list) => {\n      const array = [];\n      const rec = (ls) => {\n        if (ls[0] === '" + (u0Targets$Javascript$Runtime$listNilName + ("')\n          return array;\n\n        array.push(ls[1]);\n        return rec(ls[2]);\n      };\n\n      return rec(list);\n    }\n\n    const array_fromList = arrayFromListLow;\n\n\n    //\n    // Lists\n    //\n\n\n    const sp_cons = (item, list) => {\n      return [ '" + (u0Targets$Javascript$Runtime$listConsName + "', item, list];\n    }\n\n    const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f(a), f(b))));\n\n\n    //\n    // Dynamic loading\n    //\n    const self_load = (requestedTypeHumanized, pars, variantConstructor) => {\n\n        const actualTypeHumanized = sp_toHuman(pars.type);\n        if (actualTypeHumanized !== requestedTypeHumanized) {\n            return [ 'Err', pars.type ];\n        }\n\n        // TODO using directly the source name sd1 is super fragile: must revisit this as soon as I have `Load.expose`\n        // TODO hoping that the state won't be mutated, once we have `Load.expose` maybe we don't need to lug the state around any more?\n        const translateUsr = $sd1$Targets$Javascript$EmittableToJs$translateUsr;\n        const js = $sd1$Platforms$Browser$compile(pars);\n\n        //   { name1, name2, name3, ... } = externals;\n        const unpackExterns = 'const { ' + pars.externalValues.map((e) => translateUsr(e.usr)).join(', ') + ' } = externs;';\n\n        const body = `{ ${unpackExterns}\n${js}; return ${translateUsr(pars.entryUsr)}; }`;\n\n        const arg = {};\n        pars.externalValues.forEach((e) => arg[translateUsr(e.usr)] = e.self.value);\n\n        return [ 'wwwwok', variantConstructor(Function('externs', body)(arg)) ];\n    };\n\n")))))))))))))))))))))))))))))))))),
    $state,
  ]);
});

const u0Platforms$Browser$makeExecutable = (($platformImportsPath) => {
  return (($out) => {
    let $state = (basics_cloneImm)(u0Targets$Javascript$EmittableToJs$initState);
    const $compiledStatements = ((__re__ = (u0Platforms$Browser$compile)($state, $platformImportsPath, $out)), ($state = (__re__)[1]), (__re__)[0]);
    return (u0Platforms$Browser$header + (((__re__ = (u0Targets$Javascript$Runtime$nativeDefinitions)($state)), ($state = (__re__)[1]), (__re__)[0]) + (u0Platforms$Browser$runtime + ($compiledStatements + ((__re__ = (u0Platforms$Browser$footer)($state, $platformImportsPath, $out)), ($state = (__re__)[1]), (__re__)[0])))));
  });
});

const u0Platforms$Browser$platform = (($platformImportsPath) => {
  return ({
    defaultImportsFile: u0Platforms$Browser$defaultImportsFile,
    defaultOutputName: "index.js",
    makeExecutable: (u0Platforms$Browser$makeExecutable)($platformImportsPath),
    name: "browser",
    quickstart: "TODO",
  });
});

const u0Main$platformBrowser = (u0Platforms$Browser$platform)((c0Compiler$Meta$ImportsPath)(c0Compiler$Meta$Installed, "browser"));

const u0Platforms$Posix$defaultImportsFile = (u0DefaultImports$platformDefaultImportsFile)((c0Core$Cons)(({
  first: "IO",
  second: (c0Core$Cons)("IO", c0Core$Nil),
}), (c0Core$Cons)(({
  first: "Path",
  second: c0Core$Nil,
}), c0Core$Nil)));

const u0Platforms$Posix$header = "#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096\n\n//Error.stackTraceLimit = 100;\n\nconst { performance } = require('perf_hooks');\n\n";

const u0Platforms$Posix$overrides = (($platformImportsPath) => {
  const $ioModule = (($0) => {
    return (c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)($platformImportsPath, "", "IO"), $0);
  });
  const $pathModule = (($0) => {
    return (c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)($platformImportsPath, "", "Path"), $0);
  });
  return (c0Core$Cons)(({
    first: ($ioModule)("parallel"),
    second: "io_parallel",
  }), (c0Core$Cons)(({
    first: ($ioModule)("readDir"),
    second: "io_readDir",
  }), (c0Core$Cons)(({
    first: ($ioModule)("readFile"),
    second: "io_readFile",
  }), (c0Core$Cons)(({
    first: ($ioModule)("writeFile"),
    second: "io_writeFile",
  }), (c0Core$Cons)(({
    first: ($ioModule)("readStdin"),
    second: "io_readStdin",
  }), (c0Core$Cons)(({
    first: ($ioModule)("writeStdout"),
    second: "io_writeStdout",
  }), (c0Core$Cons)(({
    first: ($ioModule)("writeStderr"),
    second: "io_writeStderr",
  }), (c0Core$Cons)(({
    first: ($pathModule)("dirname"),
    second: "path_dirname",
  }), (c0Core$Cons)(({
    first: ($pathModule)("resolve"),
    second: "path_resolve",
  }), (c0Core$Cons)(({
    first: ($pathModule)("join"),
    second: "path_join",
  }), c0Core$Nil))))))))));
});

const u0Platforms$Posix$runtime = (($state) => {
  const $makeOk = ((($0) => {
    return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
  }))((c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)(u0Compiler$CoreDefs$importsPath, "src", "Result"), "'ok"));
  const $makeErr = ((($0) => {
    return ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $0)), ($state = (__re__)[1]), (__re__)[0]);
  }))((c0Compiler$Meta$USR)((c0Compiler$Meta$UMR)(u0Compiler$CoreDefs$importsPath, "src", "Result"), "'ok"));
  return ([
    ("\n//\n// Platform: IO\n//\nconst fs = require('fs');\nconst path = require('path');\n\nconst io_readDir = (io, dirPath) => {\n    // as @IO, Text: Re [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return [" + ($makeErr + ("(e.message), null];\n        }\n\n        return [" + ($makeOk + ("(arrayToListLow(entries.map((dirent) => ({\n            first: dirent.isDirectory(),\n            second: dirent.name,\n        })))), null];\n    };\n\n\n    const io_readFile = (io, path) => {\n        // as @IO, Text: Re Text\n\n        var content;\n        try {\n            content = fs.readFileSync(path, 'utf8');\n        } catch (e) {\n            return [" + ($makeErr + ("(e.message), null];\n        }\n\n        return [" + ($makeOk + ("(content), null];\n    };\n\n\n    const io_writeFile = (io, path, content) => {\n        // as @IO, Text, Text: Re Int\n\n        try {\n            fs.writeFileSync(path, content);\n        } catch (e) {\n            return [" + ($makeErr + ("(e.message), null];\n        }\n\n        return [" + ($makeOk + ("(0), null];\n    };\n\n\n    const io_readStdin = (io) => {\n        // as @IO: Re Text\n\n        try {\n            return [" + ($makeOk + ("(fs.readFileSync(0, 'utf8')), null];\n        } catch (e) {\n            return [" + ($makeErr + ("(e.message), null];\n        }\n    };\n\n\n    const io_writeStdout = (io, content) => {\n        // as @IO, Text: Re None\n\n        try {\n            fs.writeFileSync(1, content);\n        } catch (e) {\n            return [" + ($makeErr + ("(e.message), null];\n        }\n\n        return [" + ($makeOk + ("(null), null];\n    };\n\n\n    const io_writeStderr = (io, content) => {\n        // as @IO, Text: Re Int\n\n        try {\n            fs.writeFileSync(2, content);\n        } catch (e) {\n            return [" + ($makeErr + ("(e.message), null];\n        }\n\n        return [" + ($makeOk + "(null), null];\n    };\n\n\n    const path_resolve = (p) => path.resolve(...arrayFromListLow(p));\n\n    const path_join = (p) => path.join(...arrayFromListLow(p));\n\n    const path_dirname = path.dirname;\n\n")))))))))))))))))))))))),
    $state,
  ]);
});

const u0Platforms$Posix$makeExecutable = (($platformImportsPath) => {
  return (($out) => {
    let $state = (basics_cloneImm)(u0Targets$Javascript$EmittableToJs$initState);
    const $entryName = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateUsr)($state, $out.entryUsr)), ($state = (__re__)[1]), (__re__)[0]);
    const $callMain = ("\n\nconst args = arrayToListLow(process.argv.slice(1));\nprocess.exitCode =" + ($entryName + "(null, process.env, args)[0];"));
    const $compiledStatements = ((() => {
      (sp_log)("Creating JS AST...", "");
      const $jaStatements = ((__re__ = (u0Targets$Javascript$EmittableToJs$translateAll)($state, ({
        constructors: $out.constructors,
        eaDefs: $out.defs,
        platformOverrides: (u0Platforms$Posix$overrides)($platformImportsPath),
      }))), ($state = (__re__)[1]), (__re__)[0]);
      (sp_log)("Emitting JS...", "");
      return ((($0) => {
        return (c0Text$join)("\n\n", $0);
      }))(((($0) => {
        return (c0List$map)((($0) => {
          return (u0Targets$Javascript$JsToText$emitStatement)(0, $0);
        }), $0);
      }))($jaStatements));
    }))();
    return (u0Platforms$Posix$header + (((__re__ = (u0Targets$Javascript$Runtime$nativeDefinitions)($state)), ($state = (__re__)[1]), (__re__)[0]) + (((__re__ = (u0Platforms$Posix$runtime)($state)), ($state = (__re__)[1]), (__re__)[0]) + ($compiledStatements + $callMain))));
  });
});

const u0Platforms$Posix$platform = (($platformImportsPath) => {
  return ({
    defaultImportsFile: u0Platforms$Posix$defaultImportsFile,
    defaultOutputName: "nodeExecutable.js",
    makeExecutable: (u0Platforms$Posix$makeExecutable)($platformImportsPath),
    name: "posix",
    quickstart: "TODO",
  });
});

const u0Main$platformPosix = (u0Platforms$Posix$platform)((c0Compiler$Meta$ImportsPath)(c0Compiler$Meta$Installed, "posix"));

const u0Main$availablePlatforms = (c0Core$Cons)(u0Main$platformPosix, (c0Core$Cons)(u0Main$platformBrowser, c0Core$Nil));

const u0Main$cliDefaults = ({
  corelib: c0Maybe$Nothing,
  platform: u0Main$platformPosix,
});

const u0Main$parseCorelibPath = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "$Nothing")
    ? (c0Result$Err)("Please specify the path where your corelib is.")
    : ((($maybeValue)[0] === "$Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        return (c0Result$Ok)(((() => {
          const $0 = $cliState;
          return (Object.assign)({}, $0, ({
            corelib: (c0Maybe$Just)($value),
          }));
        }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 255:4', (sp_toHuman)($maybeValue))));
});

const u0Main$parsePlatformName = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "$Nothing")
    ? (c0Result$Err)("Please specify a platform name, for example: `--platform=posix`")
    : ((($maybeValue)[0] === "$Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        const $3 = (c0List$find)((($p) => {
          return (sp_equal)($p.name, $value);
        }), u0Main$availablePlatforms);
        return ((($3)[0] === "$Nothing")
          ? (c0Result$Err)(("I don't know this platform name: `" + ($value + ("`\n\n                    Valid platform names are:\n\n" + ((($0) => {
            return (c0Text$join)("\n", $0);
          }))((c0List$map)((($p) => {
            return ("    " + $p.name);
          }), u0Main$availablePlatforms))))))
          : ((($3)[0] === "$Just")
            ? ((() => {
              const $platform = ($3)[1];
              return (c0Result$Ok)(((() => {
                const $0 = $cliState;
                return (Object.assign)({}, $0, ({
                  platform: $platform,
                }));
              }))());
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 233:12', (sp_toHuman)($3))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 227:4', (sp_toHuman)($maybeValue))));
});

const u0Main$cliOptions = (c0Core$Cons)(({
  info: "select build platform",
  name: "--platform",
  parser: u0Main$parsePlatformName,
}), (c0Core$Cons)(({
  info: "specify the path for for the corelib",
  name: "--corelib",
  parser: u0Main$parseCorelibPath,
}), c0Core$Nil));

const u0Term$color = (($code) => {
  return (($text) => {
    return ($code + ($text + "\x1b[0m"));
  });
});

const u0Term$blue = (u0Term$color)("\x1b[34m");

const u0Term$red = (u0Term$color)("\x1b[31m");

const u0Term$yellow = (u0Term$color)("\x1b[33m");

const u0Main$formattedToConsoleColoredText = (($formattedText) => {
  return ((($formattedText)[0] === "$FormattedText_Default")
    ? ((() => {
      const $t = ($formattedText)[1];
      return $t;
    }))()
    : ((($formattedText)[0] === "$FormattedText_Emphasys")
      ? ((() => {
        const $t = ($formattedText)[1];
        return (u0Term$yellow)($t);
      }))()
      : ((($formattedText)[0] === "$FormattedText_Warning")
        ? ((() => {
          const $t = ($formattedText)[1];
          return (u0Term$red)($t);
        }))()
        : ((($formattedText)[0] === "$FormattedText_Decoration")
          ? ((() => {
            const $t = ($formattedText)[1];
            return (u0Term$blue)($t);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 25:4', (sp_toHuman)($formattedText))))));
});

const u0Main$errorToText = (($0) => {
  return ((($0) => {
    return (c0Text$join)("", $0);
  }))(((($0) => {
    return (c0List$map)(u0Main$formattedToConsoleColoredText, $0);
  }))((u0Compiler$Error$toFormattedText)($0)));
});

const u0Main$resToIo = (($res) => {
  return ((($res)[0] === "$Ok")
    ? ((() => {
      const $a = ($res)[1];
      return (c0Result$Ok)($a);
    }))()
    : ((($res)[0] === "$Err")
      ? ((() => {
        const $e = ($res)[1];
        return (c0Result$Err)((u0Main$errorToText)($e));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 42:4', (sp_toHuman)($res))));
});

const u0Main$formatMain = (($io, $targets) => {
  const $formatText = (($fsPath, $content) => {
    return ((c0Result$onOk)((($formattableAst) => {
      return (c0Result$Ok)((u0SPLib$Format$render)(((($0) => {
        return (u0Human$Format$formatStatements)(({
          isRoot: true,
          originalContent: $content,
        }), $0);
      }))($formattableAst)));
    })))((u0Main$resToIo)((u0Compiler$Parser$textToFormattableModule)(({
      errorModule: ({
        content: $content,
        fsPath: $fsPath,
      }),
      keepComments: true,
      stripLocations: false,
    }))));
  });
  const $formatFile = (($name) => {
    return ((c0Result$onOk)((($moduleAsText) => {
      return ((c0Result$onOk)((($formatted) => {
        return ((__re__ = (io_writeFile)($io, $name, $formatted)), ($io = (__re__)[1]), (__re__)[0]);
      })))(($formatText)($name, $moduleAsText));
    })))(((__re__ = (io_readFile)($io, $name)), ($io = (__re__)[1]), (__re__)[0]));
  });
  return ([
    ((sp_equal)($targets, c0Core$Nil)
      ? ((c0Result$onOk)((($moduleAsText) => {
        return ((c0Result$onOk)((($formatted) => {
          return ((__re__ = (io_writeStdout)($io, $formatted)), ($io = (__re__)[1]), (__re__)[0]);
        })))(($formatText)("<stdin>", $moduleAsText));
      })))(((__re__ = (io_readStdin)($io)), ($io = (__re__)[1]), (__re__)[0]))
      : ((c0Result$onOk)(((_0) => {
        return (c0Result$Ok)(null);
      })))((c0List$mapRes)($formatFile, $targets))),
    $io,
  ]);
});

const u0Main$indent = (($s) => {
  return ((($0) => {
    return (c0Text$join)("\n", $0);
  }))(((($0) => {
    return (c0List$map)((($l) => {
      return ("  " + $l);
    }), $0);
  }))(((($0) => {
    return (text_split)("\n", $0);
  }))($s)));
});

const u0Main$parseArguments = (($options, $args, $initState) => {
  const $4 = (c0List$partition)((($0) => {
    return (text_startsWith)("--", $0);
  }), $args);
  const $others = $4.second;
  const $optionTexts = $4.first;
  const $findOption = (($optionText, $state) => {
    const $7 = (text_split)("=", $optionText);
    return ((($7)[0] === "$Nil")
      ? (c0Result$Ok)($state)
      : ((($7)[0] === "$Cons")
        ? ((() => {
          const $optionName = ($7)[1];
          const $rest = ($7)[2];
          const $8 = (c0List$find)((($o) => {
            return (sp_equal)($o.name, $optionName);
          }), $options);
          return ((($8)[0] === "$Nothing")
            ? (c0Result$Err)(("Unknown option " + $optionName))
            : ((($8)[0] === "$Just")
              ? ((() => {
                const $option = ($8)[1];
                const $value = ((sp_equal)($rest, c0Core$Nil)
                  ? c0Maybe$Nothing
                  : (c0Maybe$Just)((c0Text$join)("=", $rest)));
                return ($option.parser)($value, $state);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 77:16', (sp_toHuman)($8))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 71:8', (sp_toHuman)($7))));
  });
  return ((($0) => {
    return (c0Result$map)((($0) => {
      return (c0Tuple$pair)($others, $0);
    }), $0);
  }))(((($0) => {
    return (c0List$forRes)($0, $optionTexts, $findOption);
  }))($initState));
});

const u0Main$order = (($outcome) => {
  return ((($outcome)[0] === "$Success")
    ? 0
    : ((($outcome)[0] === "$Skipped")
      ? 1
      : ((($outcome)[0] === "$Error")
        ? 2
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 115:4', (sp_toHuman)($outcome)))));
});

const u0Term$green = (u0Term$color)("\x1b[32m");

const u0Main$testOutcomeToText = (($name, $code, $outcome) => {
  return ((($outcome)[0] === "$Success")
    ? (u0Term$green)(("* PASS: " + $name))
    : ((($outcome)[0] === "$Skipped")
      ? (u0Term$yellow)(("* skip: " + $name))
      : ((($outcome)[0] === "$Error")
        ? ((() => {
          const $error = ($outcome)[1];
          return ((u0Term$red)(("FAIL ! " + $name)) + ("\n" + ((u0Main$indent)($code) + ("\n" + (u0Main$indent)($error)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 107:4', (sp_toHuman)($outcome)))));
});

const u0Main$selftestMain = (($io) => {
  return ([
    ((($0) => {
      return ((__re__ = (io_writeStdout)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
    }))(((($0) => {
      return ($0 + "\n");
    }))(((($0) => {
      return (c0Text$join)("\n", $0);
    }))(((($0) => {
      return (c0List$map)((($x) => {
        return (u0Main$testOutcomeToText)($x.name, $x.code, $x.outcome);
      }), $0);
    }))(((($0) => {
      return (list_sortBy)((($x) => {
        return ({
          first: (u0Main$order)($x.outcome),
          second: $x.name,
        });
      }), $0);
    }))((i1Test$flattenAndRun)(u0Main$allTests)))))),
    $io,
  ]);
});

const u0Main$main = (($io, $env, $rawArgs) => {
  return ([
    ((($0) => {
      return ((__re__ = (i2IO$reToStderr)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
    }))(((() => {
      const $4 = (u0Main$parseArguments)(u0Main$cliOptions, $rawArgs, u0Main$cliDefaults);
      return ((($4)[0] === "$Err")
        ? ((() => {
          const $message = ($4)[1];
          return ((__re__ = (io_writeStderr)($io, ($message + "\n"))), ($io = (__re__)[1]), (__re__)[0]);
        }))()
        : ((($4)[0] === "$Ok")
          ? ((() => {
            const $args = ($4)[1].first;
            const $cliState = ($4)[1].second;
            return (((($args)[0] === "$Cons") && (((($args)[2])[0] === "$Cons") && ("selftest" === (($args)[2])[1])))
              ? ((() => {
                const $self = ($args)[1];
                const $tail = (($args)[2])[2];
                return ((__re__ = (u0Main$selftestMain)($io)), ($io = (__re__)[1]), (__re__)[0]);
              }))()
              : (((($args)[0] === "$Cons") && (((($args)[2])[0] === "$Cons") && ("format" === (($args)[2])[1])))
                ? ((() => {
                  const $self = ($args)[1];
                  const $tail = (($args)[2])[2];
                  return ((__re__ = (u0Main$formatMain)($io, $tail)), ($io = (__re__)[1]), (__re__)[0]);
                }))()
                : (((($args)[0] === "$Cons") && ((($args)[2])[0] === "$Cons"))
                  ? ((() => {
                    const $self = ($args)[1];
                    const $entryPoint = (($args)[2])[1];
                    const $tail = (($args)[2])[2];
                    const $maybeOutputPath = (c0List$head)($tail);
                    return (u0Main$resToIo)(((__re__ = (u0BuildMain$compileMain)($io, ({
                      corelib: $cliState.corelib,
                      entryPoint: $entryPoint,
                      maybeOutputPath: $maybeOutputPath,
                      platform: $cliState.platform,
                      selfPath: $self,
                    }))), ($io = (__re__)[1]), (__re__)[0]));
                  }))()
                  : (true
                    ? ((($0) => {
                      return ((__re__ = (io_writeStdout)($io, $0)), ($io = (__re__)[1]), (__re__)[0]);
                    }))("\nHi! This is the Squarepants compiler!\n\nTo compile something, write:\n\n    squarepants pathToMainModule.sp\n\n")
                    : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 290:12', (sp_toHuman)($args))))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 284:4', (sp_toHuman)($4))));
    }))()),
    $io,
    $env,
  ]);
});

const args = arrayToListLow(process.argv.slice(1));
process.exitCode =u0Main$main(null, process.env, args)[0];