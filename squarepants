#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096

//Error.stackTraceLimit = 100;

const { performance } = require('perf_hooks');

let __re__;


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


/*  HACK

    TODO this is super brittle
    once we have a proper Platform system in place, the platform can probably
    use its internal Meta to figure out the proper constructor

*/
const maybe_nothing = [ "Nothing" ];
const maybe_just = (a) => [ "Just", a ];


//
// Basic ops
//


const sp_equal = (a, b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i], b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k], b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a, b) => {
  return !sp_equal(a, b);
}


const basics_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = basics_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = basics_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (right, left) => {
  if (right === 0) return 0;
  return left / right;
}


// TODO remove this and handle it like any other op?
const basics_modBy = (a, b) => b % a;


const basics_cloneImm = sp_clone;


const basics_cloneUni = (uni) =>
    [ sp_clone(uni), uni ];


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message, thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


// TODO how should benchmark work in a browser?
typeof process !== 'undefined' && process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.info("");
        console.info("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.info(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const id = (n) => '    '.repeat(n);


const sp_toHuman = (a, l = 0) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a, l) || sp_toHumanAsUnion(a, l);

  if (typeof a === 'function') {
    return '<fn ' + a.length + '>';
  }

  if (typeof a === 'object') {
    let acc = '{\n';
    for (let key in a)
        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\n';

    return acc + id(l) + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a, l) => {

  if (a.length === 1) {
      return a[0];
  }

  let acc = a[0] + '\n';

  a.slice(1).forEach(arg => {

      const sub = sp_toHuman(arg, l + 1);
      if (!sub.startsWith('{') && sub.indexOf('\n') > -1)
          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\n';
      else
          acc += id(l + 1) + sub + '\n';

  })

  return acc;
}


const sp_toHumanAsList = (arrayAccum, list, l) => {
  if (list[0] === 'Cons' && list.length === 3) {
    arrayAccum.push(sp_toHuman(list[1], l));
    return sp_toHumanAsList(arrayAccum, list[2], l);
  }

  if (list[0] === 'Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ? maybe_nothing : maybe_just(n);
}

const text_split = (separator, target) => arrayToListLow(target.split(separator));

const text_length = (s) => s.length;

const text_slice = (start, end, s) => s.slice(start, end);

const text_startsWith = (sub, s) => s.startsWith(sub);

const text_startsWithRegex = (regex) => {
  let re;
  try {
    re = new RegExp('^' + regex);
  } catch (e) {
    return () => ""
  }

  return (s) => {
    let m = s.match(re);
    return m ? m[0] : "";
  }
}

const text_replaceRegex = (regex) => {
  let re;
  try {
    re = new RegExp(regex, 'g');
  } catch (e) {
    return () => ""
  }

  return (replacer, s) => s.replace(re, replacer);
}

const text_trimLeft = (s) => s.trimLeft();

const text_dropLeft = (n, s) => s.slice(n);

const text_forEach = (s, f) => {
  for (let i of s) f(i);
  return null;
}


//
// Hashes
//

const hash_fromList = (list) => {
  const hash = {};

  // TODO iteration instead of recursion
  const rec = (ls) => {
    if (ls[0] === 'Nil')
      return hash;

    const { first, second } = ls[1];

    hash[JSON.stringify(first)] = [first, second];

    return rec(ls[2]);
  };

  return rec(list);
}


const hash_insert = (hash, key, value) => {
    hash[JSON.stringify(key)] = [key, value];
    return [null, hash];
}


const hash_remove = (hash, key) => {
    delete hash[JSON.stringify(key)];
    return [null, hash];
}


const hash_get = (hash, key) => {
    const r = hash[JSON.stringify(key)];
    return [r === undefined ? maybe_nothing : maybe_just(r[1]), hash];
}


const hash_for = (hash, f, acc) => {
    for (let k in hash) {
        const kv = hash[k];
        acc = f(kv[0], kv[1], acc);
    }
    return [acc, hash];
}


const hash_each = (hash, f) => {
    for (let k in hash) {
        const kv = hash[k];
        f(kv[0], kv[1]);
    }
    return [null, hash];
}


//
// Arrays
//

const array_each = (array, f) => {
    array.forEach(f);
    return [null, array];
}

const array_push = (array, item) => {
    array.push(item);
    return [null, array];
}

const array_pop = (a) => {
    return [a.length ? maybe_just(a.pop()) : maybe_nothing, a];
}

const array_get = (array, index) => {
    const r = array[index];
    return [r === undefined ? maybe_nothing : maybe_just(r), array];
}

const array_set = (a, index, item) => {
    if (index < 0) return false;
    if (index >= a.length) return [false, a];
    a[index] = item;
    return [true, a];
}

const array_sortBy = (arr, f) => {
    arr.sort((a, b) => basics_compare(f(a), f(b)));
    return [null, arr];
}

const arrayToListLow = (arr) => {
  const length = arr.length;
  let list = [ 'Nil' ];
  for (let i = length - 1; i >= 0; i--) {
      list = [ 'Cons', arr[i], list ];
  }
  return list;
}

const array_toList = (arr) => [arrayToListLow(arr), arr];


const arrayFromListLow = (list) => {
  const array = [];
  const rec = (ls) => {
    if (ls[0] === 'Nil')
      return array;

    array.push(ls[1]);
    return rec(ls[2]);
  };

  return rec(list);
}

const array_fromList = arrayFromListLow;


//
// Lists
//


const sp_cons = (item, list) => {
  return [ 'Cons', item, list];
}

const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f(a), f(b))));
    
//
// Platform: IO
//
const fs = require('fs');
const path = require('path');

const io_wrap = (f) => [ "IO.IO", f ];

const io_parallel = (iosAsList) => io_wrap((never) => {
    // as [IO a]: IO [a]

    const ios = arrayFromListLow(iosAsList);

    // TODO actually run them in parallel!

    let arr = [];
    for (let io of ios) {
        const r = io[1](never);
        if (r[0] === "Ok")
            arr.push(r[1]);
        else
            return $core$Result$Err(r[1]);
    }

    return $core$Result$Ok(arrayToListLow(arr));
});


const io_readDir = (dirPath) => io_wrap((never) => {
    // as Text: IO [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return $core$Result$Err(e.message);
    }

    return $core$Result$Ok(arrayToListLow(entries.map((dirent) => ({
        first: dirent.isDirectory(),
        second: dirent.name,
    }))));
});


const io_readFile = (path) => io_wrap((never) => {
    // as Text: IO Text

    var content;
    try {
        content = fs.readFileSync(path, 'utf8');
    } catch (e) {
        return $core$Result$Err(e.message);
    }

    return $core$Result$Ok(content);
});


const io_writeFile = (path, content) => io_wrap((never) => {
    // as Text: Text: IO Int

    try {
        fs.writeFileSync(path, content);
    } catch (e) {
        return $core$Result$Err(e.message);
    }

    return $core$Result$Ok(0);
});


const io_writeStdout = (content) => io_wrap((never) => {
    // as Text: IO Int

    console.info(content);
    return $core$Result$Ok(0);
});


const io_writeStderr = (content) => io_wrap((never) => {
    // as Text: IO Int

    console.error(content);
    return $core$Result$Ok(-1);
});


const path_resolve = (p) => path.resolve(...arrayFromListLow(p));


const path_dirname = path.dirname;
const $core$Array$Array__ = (($1) => ([
  "Array__",
  $1,
]));

const $core$Core$Cons = (($1, $2) => ([
  "Cons",
  $1,
  $2,
]));

const $core$Core$False = ([
  "False",
]);

const $core$Core$Nil = ([
  "Nil",
]);

const $core$Core$None = ([
  "None",
]);

const $core$Core$True = ([
  "True",
]);

const $core$Dict$Black = ([
  "Black",
]);

const $core$Dict$RBEmpty_elm_builtin = ([
  "RBEmpty_elm_builtin",
]);

const $core$Dict$RBNode_elm_builtin = (($1, $2, $3, $4, $5) => ([
  "RBNode_elm_builtin",
  $1,
  $2,
  $3,
  $4,
  $5,
]));

const $core$Dict$Red = ([
  "Red",
]);

const $core$Hash$Hash__ = (($1) => ([
  "Hash__",
  $1,
]));

const $core$Maybe$Just = (($1) => ([
  "Just",
  $1,
]));

const $core$Maybe$Nothing = ([
  "Nothing",
]);

const $core$Result$Err = (($1) => ([
  "Err",
  $1,
]));

const $core$Result$Ok = (($1) => ([
  "Ok",
  $1,
]));

const $posix$IO$IO = (($1) => ([
  "IO",
  $1,
]));

const $posix$IO$Never = (($1) => ([
  "Never",
  $1,
]));

const $sd0$Compiler$Error$FormattedText_Decoration = (($1) => ([
  "FormattedText_Decoration",
  $1,
]));

const $sd0$Compiler$Error$FormattedText_Default = (($1) => ([
  "FormattedText_Default",
  $1,
]));

const $sd0$Compiler$Error$FormattedText_Emphasys = (($1) => ([
  "FormattedText_Emphasys",
  $1,
]));

const $sd0$Compiler$Error$FormattedText_Warning = (($1) => ([
  "FormattedText_Warning",
  $1,
]));

const $sd0$Compiler$Error$HighlightBlock = (($1) => ([
  "HighlightBlock",
  $1,
]));

const $sd0$Compiler$Error$HighlightWord = (($1) => ([
  "HighlightWord",
  $1,
]));

const $sd0$Compiler$Error$Nested = (($1) => ([
  "Nested",
  $1,
]));

const $sd0$Compiler$Error$Simple = (($1, $2) => ([
  "Simple",
  $1,
  $2,
]));

const $sd0$Compiler$Lexer$BlockComment = (($1) => ([
  "BlockComment",
  $1,
]));

const $sd0$Compiler$Lexer$ContentOpeningBlockComment = ([
  "ContentOpeningBlockComment",
]);

const $sd0$Compiler$Lexer$ContentOpeningQuotes_One = ([
  "ContentOpeningQuotes_One",
]);

const $sd0$Compiler$Lexer$ContentOpeningQuotes_Two = ([
  "ContentOpeningQuotes_Two",
]);

const $sd0$Compiler$Lexer$Default = ([
  "Default",
]);

const $sd0$Compiler$Lexer$Dot_One = ([
  "Dot_One",
]);

const $sd0$Compiler$Lexer$Dot_Two = ([
  "Dot_Two",
]);

const $sd0$Compiler$Lexer$Indent = ([
  "Indent",
]);

const $sd0$Compiler$Lexer$LineComment = ([
  "LineComment",
]);

const $sd0$Compiler$Lexer$Mutable = ([
  "Mutable",
]);

const $sd0$Compiler$Lexer$NoTabsOrSpacesYet = ([
  "NoTabsOrSpacesYet",
]);

const $sd0$Compiler$Lexer$NumberLiteral = ([
  "NumberLiteral",
]);

const $sd0$Compiler$Lexer$SingleQuote = (($1) => ([
  "SingleQuote",
  $1,
]));

const $sd0$Compiler$Lexer$Spaces = ([
  "Spaces",
]);

const $sd0$Compiler$Lexer$Squiggles = ([
  "Squiggles",
]);

const $sd0$Compiler$Lexer$Tabs = ([
  "Tabs",
]);

const $sd0$Compiler$Lexer$TripleQuote = (($1) => ([
  "TripleQuote",
  $1,
]));

const $sd0$Compiler$Lexer$Word = (($1) => ([
  "Word",
  $1,
]));

const $sd0$Compiler$MakeEmittable$DollarName = (($1) => ([
  "DollarName",
  $1,
]));

const $sd0$Compiler$MakeEmittable$NoNamedVariables = ([
  "NoNamedVariables",
]);

const $sd0$Compiler$MakeEmittable$SafeMainName = (($1) => ([
  "SafeMainName",
  $1,
]));

const $sd0$Compiler$MakeEmittable$TrivialPattern = (($1, $2) => ([
  "TrivialPattern",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$CanBeCastNo = (($1) => ([
  "CanBeCastNo",
  $1,
]));

const $sd0$Compiler$TypeCheck$CanBeCastYes = ([
  "CanBeCastYes",
]);

const $sd0$Compiler$TypeCheck$Context_Argument = (($1, $2) => ([
  "Context_Argument",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$Context_AttributeName = (($1, $2) => ([
  "Context_AttributeName",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$Context_FnBody = (($1, $2) => ([
  "Context_FnBody",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$Context_FnPar = (($1, $2) => ([
  "Context_FnPar",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$Context_Global = ([
  "Context_Global",
]);

const $sd0$Compiler$TypeCheck$Context_IfCondition = ([
  "Context_IfCondition",
]);

const $sd0$Compiler$TypeCheck$Context_IfFalse = ([
  "Context_IfFalse",
]);

const $sd0$Compiler$TypeCheck$Context_IfTrue = ([
  "Context_IfTrue",
]);

const $sd0$Compiler$TypeCheck$Context_LetInBody = (($1) => ([
  "Context_LetInBody",
  $1,
]));

const $sd0$Compiler$TypeCheck$Context_Module = (($1) => ([
  "Context_Module",
  $1,
]));

const $sd0$Compiler$TypeCheck$Context_TryBranch = ([
  "Context_TryBranch",
]);

const $sd0$Compiler$TypeCheck$Equality = (($1, $2, $3, $4, $5) => ([
  "Equality",
  $1,
  $2,
  $3,
  $4,
  $5,
]));

const $sd0$Compiler$TypeCheck$ErrorCallingANonFunction = (($1) => ([
  "ErrorCallingANonFunction",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorCircularAlias = (($1) => ([
  "ErrorCircularAlias",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorCircularValue = ([
  "ErrorCircularValue",
]);

const $sd0$Compiler$TypeCheck$ErrorConstructorNotFound = (($1) => ([
  "ErrorConstructorNotFound",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorIncompatiblePattern = (($1, $2) => ([
  "ErrorIncompatiblePattern",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$ErrorIncompatibleRecycling = ([
  "ErrorIncompatibleRecycling",
]);

const $sd0$Compiler$TypeCheck$ErrorIncompatibleTypes = (($1, $2) => ([
  "ErrorIncompatibleTypes",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$ErrorNamedTypeNotFound = (($1) => ([
  "ErrorNamedTypeNotFound",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorNotCompatibleWithRecord = ([
  "ErrorNotCompatibleWithRecord",
]);

const $sd0$Compiler$TypeCheck$ErrorNotEnoughArguments = ([
  "ErrorNotEnoughArguments",
]);

const $sd0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute = (($1) => ([
  "ErrorRecordDoesNotHaveAttribute",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation = ([
  "ErrorRecordHasAttributesNotInAnnotation",
]);

const $sd0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation = ([
  "ErrorRecordIsMissingAttibutesInAnnotation",
]);

const $sd0$Compiler$TypeCheck$ErrorRecyclingDoesNotMatch = ([
  "ErrorRecyclingDoesNotMatch",
]);

const $sd0$Compiler$TypeCheck$ErrorShouldBeUnique = ([
  "ErrorShouldBeUnique",
]);

const $sd0$Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord = (($1, $2) => ([
  "ErrorTryingToAccessAttributeOfNonRecord",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$ErrorTypeAllowsFunctions = (($1, $2, $3) => ([
  "ErrorTypeAllowsFunctions",
  $1,
  $2,
  $3,
]));

const $sd0$Compiler$TypeCheck$ErrorUndefinedTypeVariable = (($1) => ([
  "ErrorUndefinedTypeVariable",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorUniInRecordAttribute = (($1) => ([
  "ErrorUniInRecordAttribute",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorUniInTypeArg = ([
  "ErrorUniInTypeArg",
]);

const $sd0$Compiler$TypeCheck$ErrorUniqueGlobal = ([
  "ErrorUniqueGlobal",
]);

const $sd0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatch = (($1) => ([
  "ErrorUniquenessDoesNotMatch",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchArgument = ([
  "ErrorUniquenessDoesNotMatchArgument",
]);

const $sd0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter = (($1, $2) => ([
  "ErrorUniquenessDoesNotMatchParameter",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$ErrorUnresolvableUniqueness = (($1, $2) => ([
  "ErrorUnresolvableUniqueness",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$ErrorVariableNotFound = (($1) => ([
  "ErrorVariableNotFound",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorWrongNumberOfArguments = (($1) => ([
  "ErrorWrongNumberOfArguments",
  $1,
]));

const $sd0$Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments = ([
  "ErrorWrongNumberOfConstructorArguments",
]);

const $sd0$Compiler$TypeCheck$ErrorWrongNumberOfParameters = ([
  "ErrorWrongNumberOfParameters",
]);

const $sd0$Compiler$TypeCheck$ErrorWrongNumberOfTypeArguments = (($1, $2, $3) => ([
  "ErrorWrongNumberOfTypeArguments",
  $1,
  $2,
  $3,
]));

const $sd0$Compiler$TypeCheck$Why_Annotation = ([
  "Why_Annotation",
]);

const $sd0$Compiler$TypeCheck$Why_Argument = (($1) => ([
  "Why_Argument",
  $1,
]));

const $sd0$Compiler$TypeCheck$Why_Attribute = (($1) => ([
  "Why_Attribute",
  $1,
]));

const $sd0$Compiler$TypeCheck$Why_CalledAsFunction = ([
  "Why_CalledAsFunction",
]);

const $sd0$Compiler$TypeCheck$Why_FunctionInput = (($1, $2) => ([
  "Why_FunctionInput",
  $1,
  $2,
]));

const $sd0$Compiler$TypeCheck$Why_FunctionOutput = (($1) => ([
  "Why_FunctionOutput",
  $1,
]));

const $sd0$Compiler$TypeCheck$Why_IfBranches = ([
  "Why_IfBranches",
]);

const $sd0$Compiler$TypeCheck$Why_IfCondition = ([
  "Why_IfCondition",
]);

const $sd0$Compiler$TypeCheck$Why_LetIn = ([
  "Why_LetIn",
]);

const $sd0$Compiler$TypeCheck$Why_Record = ([
  "Why_Record",
]);

const $sd0$Compiler$TypeCheck$Why_RecordAccess = ([
  "Why_RecordAccess",
]);

const $sd0$Compiler$TypeCheck$Why_RecordExt = ([
  "Why_RecordExt",
]);

const $sd0$Compiler$TypeCheck$Why_ReturnType = ([
  "Why_ReturnType",
]);

const $sd0$Compiler$TypeCheck$Why_Todo = ([
  "Why_Todo",
]);

const $sd0$Compiler$TypeCheck$Why_TryExpression = ([
  "Why_TryExpression",
]);

const $sd0$Compiler$TypeCheck$Why_TryPattern = ([
  "Why_TryPattern",
]);

const $sd0$Compiler$TypeCheck$Why_TypeArgument = (($1, $2, $3) => ([
  "Why_TypeArgument",
  $1,
  $2,
  $3,
]));

const $sd0$Compiler$UniquenessCheck$Available = ([
  "Available",
]);

const $sd0$Compiler$UniquenessCheck$ConsumedAt = (($1) => ([
  "ConsumedAt",
  $1,
]));

const $sd0$Compiler$UniquenessCheck$Immutable = ([
  "Immutable",
]);

const $sd0$Compiler$UniquenessCheck$Unique = (($1) => ([
  "Unique",
  $1,
]));

const $sd0$Human$Type$Block = (($1, $2) => ([
  "Block",
  $1,
  $2,
]));

const $sd0$Human$Type$IndentedWithHeader = (($1) => ([
  "IndentedWithHeader",
  $1,
]));

const $sd0$Human$Type$NotIndented = ([
  "NotIndented",
]);

const $sd0$Human$Type$Span = (($1, $2) => ([
  "Span",
  $1,
  $2,
]));

const $sd0$Main$Compile = (($1) => ([
  "Compile",
  $1,
]));

const $sd0$Main$Help = ([
  "Help",
]);

const $sd0$Main$Selftest = ([
  "Selftest",
]);

const $sd0$ModulesFile$Dir = (($1) => ([
  "Dir",
  $1,
]));

const $sd0$ModulesFile$Lib = (($1) => ([
  "Lib",
  $1,
]));

const $sd0$SPLib$Parser$Aborted = (($1, $2) => ([
  "Aborted",
  $1,
  $2,
]));

const $sd0$SPLib$Parser$Accepted = (($1, $2) => ([
  "Accepted",
  $1,
  $2,
]));

const $sd0$SPLib$Parser$Rejected = ([
  "Rejected",
]);

const $sd0$SPON$Accepted = (($1, $2) => ([
  "Accepted",
  $1,
  $2,
]));

const $sd0$SPON$Failed = (($1) => ([
  "Failed",
  $1,
]));

const $sd0$SPON$Rejected = (($1) => ([
  "Rejected",
  $1,
]));

const $sd0$Targets$Javascript$EmittableToJs$Block = (($1) => ([
  "Block",
  $1,
]));

const $sd0$Targets$Javascript$EmittableToJs$Inline = (($1) => ([
  "Inline",
  $1,
]));

const $sd0$Targets$Javascript$EmittableToJs$Override = (($1) => ([
  "Override",
  $1,
]));

const $sd0$Test$CodeExpectation = (($1) => ([
  "CodeExpectation",
  $1,
]));

const $sd0$Test$Error = (($1) => ([
  "Error",
  $1,
]));

const $sd0$Test$Group = (($1, $2) => ([
  "Group",
  $1,
  $2,
]));

const $sd0$Test$NotNow = (($1) => ([
  "NotNow",
  $1,
]));

const $sd0$Test$Single = (($1, $2, $3) => ([
  "Single",
  $1,
  $2,
  $3,
]));

const $sd0$Test$Skipped = ([
  "Skipped",
]);

const $sd0$Test$Success = ([
  "Success",
]);

const $sd0$Types$Ast$Depends = (($1) => ([
  "Depends",
  $1,
]));

const $sd0$Types$Ast$Imm = ([
  "Imm",
]);

const $sd0$Types$Ast$RefGlobal = (($1) => ([
  "RefGlobal",
  $1,
]));

const $sd0$Types$Ast$RefLocal = (($1) => ([
  "RefLocal",
  $1,
]));

const $sd0$Types$Ast$Uni = ([
  "Uni",
]);

const $sd0$Types$CanonicalAst$ArgumentExpression = (($1) => ([
  "ArgumentExpression",
  $1,
]));

const $sd0$Types$CanonicalAst$ArgumentRecycle = (($1, $2, $3) => ([
  "ArgumentRecycle",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$Call = (($1, $2, $3) => ([
  "Call",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$Complete = ([
  "Complete",
]);

const $sd0$Types$CanonicalAst$Constructor = (($1, $2) => ([
  "Constructor",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$DestroyIn = (($1, $2) => ([
  "DestroyIn",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$Fn = (($1, $2, $3) => ([
  "Fn",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$If = (($1, $2) => ([
  "If",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$LetIn = (($1, $2) => ([
  "LetIn",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$LiteralNumber = (($1, $2) => ([
  "LiteralNumber",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$LiteralText = (($1, $2) => ([
  "LiteralText",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$ParRe = (($1) => ([
  "ParRe",
  $1,
]));

const $sd0$Types$CanonicalAst$ParSp = (($1) => ([
  "ParSp",
  $1,
]));

const $sd0$Types$CanonicalAst$ParameterPattern = (($1, $2) => ([
  "ParameterPattern",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$ParameterPlaceholder = (($1, $2) => ([
  "ParameterPlaceholder",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$ParameterRecycle = (($1, $2) => ([
  "ParameterRecycle",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$Partial = ([
  "Partial",
]);

const $sd0$Types$CanonicalAst$PatternAny = (($1, $2) => ([
  "PatternAny",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$PatternConstructor = (($1, $2, $3) => ([
  "PatternConstructor",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$PatternLiteralNumber = (($1, $2) => ([
  "PatternLiteralNumber",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$PatternLiteralText = (($1, $2) => ([
  "PatternLiteralText",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$PatternRecord = (($1, $2, $3) => ([
  "PatternRecord",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$Record = (($1, $2, $3) => ([
  "Record",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$RecordAccess = (($1, $2, $3) => ([
  "RecordAccess",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$Try = (($1, $2) => ([
  "Try",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$TypeAnnotationVariable = (($1, $2) => ([
  "TypeAnnotationVariable",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$TypeError = (($1) => ([
  "TypeError",
  $1,
]));

const $sd0$Types$CanonicalAst$TypeFn = (($1, $2, $3) => ([
  "TypeFn",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$TypeNamed = (($1, $2, $3) => ([
  "TypeNamed",
  $1,
  $2,
  $3,
]));

const $sd0$Types$CanonicalAst$TypeRecord = (($1, $2) => ([
  "TypeRecord",
  $1,
  $2,
]));

const $sd0$Types$CanonicalAst$Variable = (($1, $2) => ([
  "Variable",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$And = (($1) => ([
  "And",
  $1,
]));

const $sd0$Types$EmittableAst$ArgumentRecycle = (($1, $2) => ([
  "ArgumentRecycle",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$ArgumentSpend = (($1) => ([
  "ArgumentSpend",
  $1,
]));

const $sd0$Types$EmittableAst$ArrayAccess = (($1, $2) => ([
  "ArrayAccess",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$Call = (($1, $2) => ([
  "Call",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$Conditional = (($1, $2, $3) => ([
  "Conditional",
  $1,
  $2,
  $3,
]));

const $sd0$Types$EmittableAst$Constructor = (($1) => ([
  "Constructor",
  $1,
]));

const $sd0$Types$EmittableAst$ConstructorAccess = (($1, $2) => ([
  "ConstructorAccess",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$Fn = (($1, $2) => ([
  "Fn",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$IsConstructor = (($1, $2) => ([
  "IsConstructor",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$LetIn = (($1) => ([
  "LetIn",
  $1,
]));

const $sd0$Types$EmittableAst$LiteralArray = (($1) => ([
  "LiteralArray",
  $1,
]));

const $sd0$Types$EmittableAst$LiteralNumber = (($1) => ([
  "LiteralNumber",
  $1,
]));

const $sd0$Types$EmittableAst$LiteralRecord = (($1, $2) => ([
  "LiteralRecord",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$LiteralText = (($1) => ([
  "LiteralText",
  $1,
]));

const $sd0$Types$EmittableAst$MissingPattern = (($1, $2) => ([
  "MissingPattern",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$RecordAccess = (($1, $2) => ([
  "RecordAccess",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$ShallowEqual = (($1, $2) => ([
  "ShallowEqual",
  $1,
  $2,
]));

const $sd0$Types$EmittableAst$Variable = (($1) => ([
  "Variable",
  $1,
]));

const $sd0$Types$FormattableAst$AliasDef = (($1) => ([
  "AliasDef",
  $1,
]));

const $sd0$Types$FormattableAst$ArgumentPlaceholder = ([
  "ArgumentPlaceholder",
]);

const $sd0$Types$FormattableAst$Binop = (($1, $2) => ([
  "Binop",
  $1,
  $2,
]));

const $sd0$Types$FormattableAst$Call = (($1, $2) => ([
  "Call",
  $1,
  $2,
]));

const $sd0$Types$FormattableAst$Evaluation = (($1) => ([
  "Evaluation",
  $1,
]));

const $sd0$Types$FormattableAst$Expression = (($1, $2) => ([
  "Expression",
  $1,
  $2,
]));

const $sd0$Types$FormattableAst$Fn = (($1, $2) => ([
  "Fn",
  $1,
  $2,
]));

const $sd0$Types$FormattableAst$If = (($1) => ([
  "If",
  $1,
]));

const $sd0$Types$FormattableAst$List = (($1) => ([
  "List",
  $1,
]));

const $sd0$Types$FormattableAst$LiteralNumber = (($1) => ([
  "LiteralNumber",
  $1,
]));

const $sd0$Types$FormattableAst$LiteralText = (($1) => ([
  "LiteralText",
  $1,
]));

const $sd0$Types$FormattableAst$Poly = (($1, $2) => ([
  "Poly",
  $1,
  $2,
]));

const $sd0$Types$FormattableAst$Record = (($1) => ([
  "Record",
  $1,
]));

const $sd0$Types$FormattableAst$Statements = (($1) => ([
  "Statements",
  $1,
]));

const $sd0$Types$FormattableAst$Try = (($1) => ([
  "Try",
  $1,
]));

const $sd0$Types$FormattableAst$UnionDef = (($1) => ([
  "UnionDef",
  $1,
]));

const $sd0$Types$FormattableAst$Unop = (($1, $2) => ([
  "Unop",
  $1,
  $2,
]));

const $sd0$Types$FormattableAst$ValueDef = (($1) => ([
  "ValueDef",
  $1,
]));

const $sd0$Types$FormattableAst$Variable = (($1) => ([
  "Variable",
  $1,
]));

const $sd0$Types$JavascriptAst$AccessWithBrackets = (($1, $2) => ([
  "AccessWithBrackets",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$AccessWithDot = (($1, $2) => ([
  "AccessWithDot",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$Array = (($1) => ([
  "Array",
  $1,
]));

const $sd0$Types$JavascriptAst$Binop = (($1, $2, $3) => ([
  "Binop",
  $1,
  $2,
  $3,
]));

const $sd0$Types$JavascriptAst$BlockLambda = (($1, $2) => ([
  "BlockLambda",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$Call = (($1, $2) => ([
  "Call",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$Comma = (($1) => ([
  "Comma",
  $1,
]));

const $sd0$Types$JavascriptAst$Conditional = (($1, $2, $3) => ([
  "Conditional",
  $1,
  $2,
  $3,
]));

const $sd0$Types$JavascriptAst$Define = (($1, $2, $3) => ([
  "Define",
  $1,
  $2,
  $3,
]));

const $sd0$Types$JavascriptAst$Eval = (($1) => ([
  "Eval",
  $1,
]));

const $sd0$Types$JavascriptAst$If = (($1, $2) => ([
  "If",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$Literal = (($1) => ([
  "Literal",
  $1,
]));

const $sd0$Types$JavascriptAst$Mutop = (($1, $2, $3, $4) => ([
  "Mutop",
  $1,
  $2,
  $3,
  $4,
]));

const $sd0$Types$JavascriptAst$Record = (($1) => ([
  "Record",
  $1,
]));

const $sd0$Types$JavascriptAst$Return = (($1) => ([
  "Return",
  $1,
]));

const $sd0$Types$JavascriptAst$SimpleLambda = (($1, $2) => ([
  "SimpleLambda",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$Unop = (($1, $2) => ([
  "Unop",
  $1,
  $2,
]));

const $sd0$Types$JavascriptAst$Var = (($1) => ([
  "Var",
  $1,
]));

const $sd0$Types$Meta$Browser = ([
  "Browser",
]);

const $sd0$Types$Meta$Core = ([
  "Core",
]);

const $sd0$Types$Meta$Posix = ([
  "Posix",
]);

const $sd0$Types$Meta$SourceDir = (($1) => ([
  "SourceDir",
  $1,
]));

const $sd0$Types$Meta$UMR = (($1, $2) => ([
  "UMR",
  $1,
  $2,
]));

const $sd0$Types$Meta$USR = (($1, $2) => ([
  "USR",
  $1,
  $2,
]));

const $sd0$Types$Op$Addittive = ([
  "Addittive",
]);

const $sd0$Types$Op$Comparison = ([
  "Comparison",
]);

const $sd0$Types$Op$Cons = ([
  "Cons",
]);

const $sd0$Types$Op$Exponential = ([
  "Exponential",
]);

const $sd0$Types$Op$Left = ([
  "Left",
]);

const $sd0$Types$Op$Logical = ([
  "Logical",
]);

const $sd0$Types$Op$Multiplicative = ([
  "Multiplicative",
]);

const $sd0$Types$Op$Mutop = ([
  "Mutop",
]);

const $sd0$Types$Op$NonAssociative = ([
  "NonAssociative",
]);

const $sd0$Types$Op$Pipe = ([
  "Pipe",
]);

const $sd0$Types$Op$Right = ([
  "Right",
]);

const $sd0$Types$Op$Tuple = ([
  "Tuple",
]);

const $sd0$Types$Op$UnopMinus = ([
  "UnopMinus",
]);

const $sd0$Types$Op$UnopPlus = ([
  "UnopPlus",
]);

const $sd0$Types$Op$UnopRecycle = ([
  "UnopRecycle",
]);

const $sd0$Types$Op$UnopUnique = ([
  "UnopUnique",
]);

const $sd0$Types$Pos$At = (($1, $2) => ([
  "At",
  $1,
  $2,
]));

const $sd0$Types$Pos$End = (($1) => ([
  "End",
  $1,
]));

const $sd0$Types$Pos$G = ([
  "G",
]);

const $sd0$Types$Pos$I = (($1) => ([
  "I",
  $1,
]));

const $sd0$Types$Pos$M = (($1) => ([
  "M",
  $1,
]));

const $sd0$Types$Pos$N = ([
  "N",
]);

const $sd0$Types$Pos$P = (($1, $2, $3) => ([
  "P",
  $1,
  $2,
  $3,
]));

const $sd0$Types$Pos$S = ([
  "S",
]);

const $sd0$Types$Pos$T = ([
  "T",
]);

const $sd0$Types$Token$Af = (($1, $2) => ([
  "Af",
  $1,
  $2,
]));

const $sd0$Types$Token$ArgumentPlaceholder = ([
  "ArgumentPlaceholder",
]);

const $sd0$Types$Token$As = ([
  "As",
]);

const $sd0$Types$Token$BadIndent = ([
  "BadIndent",
]);

const $sd0$Types$Token$Be = (($1, $2) => ([
  "Be",
  $1,
  $2,
]));

const $sd0$Types$Token$Binop = (($1) => ([
  "Binop",
  $1,
]));

const $sd0$Types$Token$BlockEnd = ([
  "BlockEnd",
]);

const $sd0$Types$Token$BlockStart = ([
  "BlockStart",
]);

const $sd0$Types$Token$Closed = ([
  "Closed",
]);

const $sd0$Types$Token$Colon = ([
  "Colon",
]);

const $sd0$Types$Token$Comma = ([
  "Comma",
]);

const $sd0$Types$Token$CurlyBrace = (($1) => ([
  "CurlyBrace",
  $1,
]));

const $sd0$Types$Token$Defop = ([
  "Defop",
]);

const $sd0$Types$Token$Else = ([
  "Else",
]);

const $sd0$Types$Token$Fn = ([
  "Fn",
]);

const $sd0$Types$Token$If = ([
  "If",
]);

const $sd0$Types$Token$N = ([
  "N",
]);

const $sd0$Types$Token$NameNoModifier = ([
  "NameNoModifier",
]);

const $sd0$Types$Token$NameStartsWithDot = ([
  "NameStartsWithDot",
]);

const $sd0$Types$Token$NewSiblingLine = ([
  "NewSiblingLine",
]);

const $sd0$Types$Token$NumberLiteral = (($1) => ([
  "NumberLiteral",
  $1,
]));

const $sd0$Types$Token$Open = ([
  "Open",
]);

const $sd0$Types$Token$RoundParen = (($1) => ([
  "RoundParen",
  $1,
]));

const $sd0$Types$Token$SquareBracket = (($1) => ([
  "SquareBracket",
  $1,
]));

const $sd0$Types$Token$TextLiteral = (($1) => ([
  "TextLiteral",
  $1,
]));

const $sd0$Types$Token$Then = ([
  "Then",
]);

const $sd0$Types$Token$ThreeDots = ([
  "ThreeDots",
]);

const $sd0$Types$Token$Token = (($1, $2, $3, $4) => ([
  "Token",
  $1,
  $2,
  $3,
  $4,
]));

const $sd0$Types$Token$Try = ([
  "Try",
]);

const $sd0$Types$Token$UniquenessPolymorphismBinop = ([
  "UniquenessPolymorphismBinop",
]);

const $sd0$Types$Token$Unop = (($1) => ([
  "Unop",
  $1,
]));

const $sd0$Types$Token$With = ([
  "With",
]);

const $sd0$Types$Token$Word = (($1) => ([
  "Word",
  $1,
]));

const $sd0$Types$TypedAst$ArgumentExpression = (($1, $2) => ([
  "ArgumentExpression",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$ArgumentRecycle = (($1, $2, $3, $4) => ([
  "ArgumentRecycle",
  $1,
  $2,
  $3,
  $4,
]));

const $sd0$Types$TypedAst$Call = (($1, $2, $3) => ([
  "Call",
  $1,
  $2,
  $3,
]));

const $sd0$Types$TypedAst$Constructor = (($1, $2) => ([
  "Constructor",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$DestroyIn = (($1, $2) => ([
  "DestroyIn",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$Error = (($1) => ([
  "Error",
  $1,
]));

const $sd0$Types$TypedAst$Fn = (($1, $2, $3, $4) => ([
  "Fn",
  $1,
  $2,
  $3,
  $4,
]));

const $sd0$Types$TypedAst$If = (($1, $2) => ([
  "If",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$LetIn = (($1, $2, $3) => ([
  "LetIn",
  $1,
  $2,
  $3,
]));

const $sd0$Types$TypedAst$LiteralNumber = (($1, $2) => ([
  "LiteralNumber",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$LiteralText = (($1, $2) => ([
  "LiteralText",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$ParRe = (($1) => ([
  "ParRe",
  $1,
]));

const $sd0$Types$TypedAst$ParSp = (($1) => ([
  "ParSp",
  $1,
]));

const $sd0$Types$TypedAst$ParameterPattern = (($1, $2) => ([
  "ParameterPattern",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$ParameterRecycle = (($1, $2, $3) => ([
  "ParameterRecycle",
  $1,
  $2,
  $3,
]));

const $sd0$Types$TypedAst$PatternAny = (($1, $2) => ([
  "PatternAny",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$PatternConstructor = (($1, $2, $3) => ([
  "PatternConstructor",
  $1,
  $2,
  $3,
]));

const $sd0$Types$TypedAst$PatternLiteralNumber = (($1, $2) => ([
  "PatternLiteralNumber",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$PatternLiteralText = (($1, $2) => ([
  "PatternLiteralText",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$PatternRecord = (($1, $2) => ([
  "PatternRecord",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$Record = (($1, $2, $3) => ([
  "Record",
  $1,
  $2,
  $3,
]));

const $sd0$Types$TypedAst$RecordAccess = (($1, $2, $3) => ([
  "RecordAccess",
  $1,
  $2,
  $3,
]));

const $sd0$Types$TypedAst$Try = (($1, $2) => ([
  "Try",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$TypeError = ([
  "TypeError",
]);

const $sd0$Types$TypedAst$TypeExact = (($1, $2) => ([
  "TypeExact",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$TypeFn = (($1, $2) => ([
  "TypeFn",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$TypeRecord = (($1, $2) => ([
  "TypeRecord",
  $1,
  $2,
]));

const $sd0$Types$TypedAst$TypeVar = (($1) => ([
  "TypeVar",
  $1,
]));

const $sd0$Types$TypedAst$Variable = (($1, $2) => ([
  "Variable",
  $1,
  $2,
]));

const $sd0$Test$maybeToOutcome = (($m) => {
  return ((($m)[0] === "Just")
    ? ((() => {
      const $e = ($m)[1];
      return ($sd0$Test$Error)($e);
    }))()
    : ((($m)[0] === "Nothing")
      ? $sd0$Test$Success
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 15:4', (sp_toHuman)($m))));
});

const $sd0$Test$valueTest = (($toText, $title, $generateValue, $ce) => {
  const $$toMaybeError = $ce;
  const $toMaybeError = ($$toMaybeError)[1];
  return ($sd0$Test$Single)($title, "", ((_0) => {
    return ($sd0$Test$maybeToOutcome)(((($1) => {
      return ($toMaybeError)($toText, $1);
    }))(($core$Result$Ok)(($generateValue)(null))));
  }));
});

const $core$Array_Test$valueTest = (($1, $2, $3) => {
  return ($sd0$Test$valueTest)(sp_toHuman, $1, $2, $3);
});

const $core$Text$join = (($sep, $listOfText) => {
  return ((($listOfText)[0] === "Nil")
    ? ""
    : ((($listOfText)[0] === "Cons")
      ? ((() => {
        const $head = ($listOfText)[1];
        const $tail = ($listOfText)[2];
        const $rec = (($ls, $acc) => {
          return ((($ls)[0] === "Nil")
            ? $acc
            : ((($ls)[0] === "Cons")
              ? ((() => {
                const $h = ($ls)[1];
                const $t = ($ls)[2];
                return ($rec)($t, ($acc + ($sep + $h)));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Text.sp 136:12', (sp_toHuman)($ls))));
        });
        return ($rec)($tail, $head);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Text.sp 128:4', (sp_toHuman)($listOfText))));
});

const $sd0$Test$isOkAndEqualTo = (($expectedOk) => {
  return ($sd0$Test$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($core$Maybe$Just)($e);
      }))()
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return ((sp_equal)($actualOk, $expectedOk)
            ? $core$Maybe$Nothing
            : ($core$Maybe$Just)(((($1) => {
              return ($core$Text$join)("\n", $1);
            }))(($core$Core$Cons)("expected = ", ($core$Core$Cons)(($toText)($expectedOk), ($core$Core$Cons)("", ($core$Core$Cons)("actual = ", ($core$Core$Cons)(($toText)($actualOk), $core$Core$Nil))))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 82:6', (sp_toHuman)($result))));
  }));
});

const $core$Array_Test$tests = ($sd0$Test$Group)("Array", ($core$Core$Cons)(($core$Array_Test$valueTest)("push", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)("a", $core$Core$Nil));
  ((__re__ = (array_push)($a, "b")), ($a = (__re__)[1]), (__re__)[0]);
  ((__re__ = (array_push)($a, "c")), ($a = (__re__)[1]), (__re__)[0]);
  return ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)("a", ($core$Core$Cons)("b", ($core$Core$Cons)("c", $core$Core$Nil))))), ($core$Core$Cons)(($core$Array_Test$valueTest)("pop 1", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)("x", ($core$Core$Cons)("y", ($core$Core$Cons)("z", $core$Core$Nil))));
  const $b = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $c = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
}), ($sd0$Test$isOkAndEqualTo)(({
  b: ($core$Maybe$Just)("z"),
  c: ($core$Maybe$Just)("y"),
  l: ($core$Core$Cons)("x", $core$Core$Nil),
}))), ($core$Core$Cons)(($core$Array_Test$valueTest)("pop empty", ((_0) => {
  let $a = (array_fromList)($core$Core$Nil);
  const $b = ((__re__ = (array_pop)($a)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    b: $b,
    l: $l,
  });
}), ($sd0$Test$isOkAndEqualTo)(({
  b: $core$Maybe$Nothing,
  l: $core$Core$Nil,
}))), ($core$Core$Cons)(($core$Array_Test$valueTest)("get Just", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)("p", ($core$Core$Cons)("q", $core$Core$Nil)));
  return ((__re__ = (array_get)($a, 1)), ($a = (__re__)[1]), (__re__)[0]);
}), ($sd0$Test$isOkAndEqualTo)(($core$Maybe$Just)("q"))), ($core$Core$Cons)(($core$Array_Test$valueTest)("get Nothing", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)("p", ($core$Core$Cons)("q", $core$Core$Nil)));
  return ((__re__ = (array_get)($a, 3)), ($a = (__re__)[1]), (__re__)[0]);
}), ($sd0$Test$isOkAndEqualTo)($core$Maybe$Nothing)), ($core$Core$Cons)(($core$Array_Test$valueTest)("set success", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)(8, ($core$Core$Cons)(9, $core$Core$Nil)));
  const $r = ((__re__ = (array_set)($a, 0, 10)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    l: $l,
    r: $r,
  });
}), ($sd0$Test$isOkAndEqualTo)(({
  l: ($core$Core$Cons)(10, ($core$Core$Cons)(9, $core$Core$Nil)),
  r: true,
}))), ($core$Core$Cons)(($core$Array_Test$valueTest)("set fail", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)(8, ($core$Core$Cons)(9, $core$Core$Nil)));
  const $r = ((__re__ = (array_set)($a, 3, 10)), ($a = (__re__)[1]), (__re__)[0]);
  const $l = ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
  return ({
    l: $l,
    r: $r,
  });
}), ($sd0$Test$isOkAndEqualTo)(({
  l: ($core$Core$Cons)(8, ($core$Core$Cons)(9, $core$Core$Nil)),
  r: false,
}))), ($core$Core$Cons)(($core$Array_Test$valueTest)("sortBy", ((_0) => {
  let $a = (array_fromList)(($core$Core$Cons)(55, ($core$Core$Cons)(99, ($core$Core$Cons)(22, $core$Core$Nil))));
  ((__re__ = (array_sortBy)($a, (($x) => {
    return -($x);
  }))), ($a = (__re__)[1]), (__re__)[0]);
  return ((__re__ = (array_toList)($a)), ($a = (__re__)[1]), (__re__)[0]);
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(99, ($core$Core$Cons)(55, ($core$Core$Cons)(22, $core$Core$Nil))))), $core$Core$Nil)))))))));

const $core$Basics$btw = (($f, $a, $c) => {
  ($f)($a);
  return $c;
});

const $core$Basics$clamp = (($low, $high, $n) => {
  return (($n < $low)
    ? $low
    : (($n > $high)
      ? $high
      : $n));
});

const $core$Basics$identity = (($a) => {
  return $a;
});

const $core$Basics$max = (($a, $b) => {
  return (($a > $b)
    ? $a
    : $b);
});

const $core$Basics$min = (($a, $b) => {
  return (($a < $b)
    ? $a
    : $b);
});

const $core$Basics$not = (($b) => {
  return ($b
    ? false
    : true);
});

const $core$Core$sendLeft = "native";

const $core$Core$sendRight = "native";

const $core$Dict$any = (($f, $dict) => {
  return ((($dict)[0] === "RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $v = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return (($f)($key, $v)
        ? true
        : (($core$Dict$any)($f, $left) || ($core$Dict$any)($f, $right)));
    }))()
    : ((($dict)[0] === "RBEmpty_elm_builtin")
      ? false
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 522:4', (sp_toHuman)($dict))));
});

const $core$Dict$balance = (($color, $key, $value, $left, $right) => {
  return (((($right)[0] === "RBNode_elm_builtin") && ((($right)[1])[0] === "Red"))
    ? ((() => {
      const $rK = ($right)[2];
      const $rV = ($right)[3];
      const $rLeft = ($right)[4];
      const $rRight = ($right)[5];
      return (((($left)[0] === "RBNode_elm_builtin") && ((($left)[1])[0] === "Red"))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $lLeft = ($left)[4];
          const $lRight = ($left)[5];
          return ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $key, $value, ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $lK, $lV, $lLeft, $lRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $rK, $rV, $rLeft, $rRight));
        }))()
        : (true
          ? ($core$Dict$RBNode_elm_builtin)($color, $rK, $rV, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $key, $value, $left, $rLeft), $rRight)
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 113:6', (sp_toHuman)($left))));
    }))()
    : (true
      ? (((($left)[0] === "RBNode_elm_builtin") && (((($left)[1])[0] === "Red") && (((($left)[4])[0] === "RBNode_elm_builtin") && (((($left)[4])[1])[0] === "Red"))))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $llK = (($left)[4])[2];
          const $llV = (($left)[4])[3];
          const $llLeft = (($left)[4])[4];
          const $llRight = (($left)[4])[5];
          const $lRight = ($left)[5];
          return ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $llK, $llV, $llLeft, $llRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $key, $value, $lRight, $right));
        }))()
        : (true
          ? ($core$Dict$RBNode_elm_builtin)($color, $key, $value, $left, $right)
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 126:6', (sp_toHuman)($left))))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 111:2', (sp_toHuman)($right))));
});

const $core$Dict$for = (($acc, $dict, $func) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? $acc
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ($core$Dict$for)(($func)($key, $value, ($core$Dict$for)($acc, $left, $func)), $right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 465:2', (sp_toHuman)($dict))));
});

const $core$Dict$moveRedLeft = (($dict) => {
  return (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && (((($dict)[5])[0] === "RBNode_elm_builtin") && ((((($dict)[5])[4])[0] === "RBNode_elm_builtin") && ((((($dict)[5])[4])[1])[0] === "Red")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $lLeft = (($dict)[4])[4];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rlK = ((($dict)[5])[4])[2];
      const $rlV = ((($dict)[5])[4])[3];
      const $rlL = ((($dict)[5])[4])[4];
      const $rlR = ((($dict)[5])[4])[5];
      const $rRight = (($dict)[5])[5];
      return ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $rlK, $rlV, ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, $lLeft, $lRight), $rlL), ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $rK, $rV, $rlR, $rRight));
    }))()
    : (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && ((($dict)[5])[0] === "RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "Black")
          ? ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, $lLeft, $lRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "Red")
            ? ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, $lLeft, $lRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 281:6', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 271:2', (sp_toHuman)($dict)))));
});

const $core$Dict$getMin = (($dict) => {
  return ((($dict)[0] === "RBNode_elm_builtin")
    ? ((() => {
      const $left = ($dict)[4];
      return ((($left)[0] === "RBNode_elm_builtin")
        ? ($core$Dict$getMin)($left)
        : (true
          ? $dict
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 230:6', (sp_toHuman)($left))));
    }))()
    : (true
      ? $dict
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 228:2', (sp_toHuman)($dict))));
});

const $core$Dict$removeMin = (($dict) => {
  return ((($dict)[0] === "RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((($left)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $lColor = ($left)[1];
          const $lLeft = ($left)[4];
          return ((($lColor)[0] === "Black")
            ? (((($lLeft)[0] === "RBNode_elm_builtin") && ((($lLeft)[1])[0] === "Red"))
              ? ($core$Dict$RBNode_elm_builtin)($color, $key, $value, ($core$Dict$removeMin)($left), $right)
              : (true
                ? ((() => {
                  const $$try1 = ($core$Dict$moveRedLeft)($dict);
                  return ((($$try1)[0] === "RBNode_elm_builtin")
                    ? ((() => {
                      const $nColor = ($$try1)[1];
                      const $nKey = ($$try1)[2];
                      const $nValue = ($$try1)[3];
                      const $nLeft = ($$try1)[4];
                      const $nRight = ($$try1)[5];
                      return ($core$Dict$balance)($nColor, $nKey, $nValue, ($core$Dict$removeMin)($nLeft), $nRight);
                    }))()
                    : ((($$try1)[0] === "RBEmpty_elm_builtin")
                      ? $core$Dict$RBEmpty_elm_builtin
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 253:18', (sp_toHuman)($$try1))));
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 248:14', (sp_toHuman)($lLeft))))
            : (true
              ? ($core$Dict$RBNode_elm_builtin)($color, $key, $value, ($core$Dict$removeMin)($left), $right)
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 246:10', (sp_toHuman)($lColor))));
        }))()
        : (true
          ? $core$Dict$RBEmpty_elm_builtin
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 244:6', (sp_toHuman)($left))));
    }))()
    : (true
      ? $core$Dict$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 242:2', (sp_toHuman)($dict))));
});

const $core$Dict$removeHelpEQGT = (($targetKey, $dict) => {
  return ((($dict)[0] === "RBNode_elm_builtin")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((sp_equal)($targetKey, $key)
        ? ((() => {
          const $$try1 = ($core$Dict$getMin)($right);
          return ((($$try1)[0] === "RBNode_elm_builtin")
            ? ((() => {
              const $minKey = ($$try1)[2];
              const $minValue = ($$try1)[3];
              return ($core$Dict$balance)($color, $minKey, $minValue, $left, ($core$Dict$removeMin)($right));
            }))()
            : ((($$try1)[0] === "RBEmpty_elm_builtin")
              ? $core$Dict$RBEmpty_elm_builtin
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 213:8', (sp_toHuman)($$try1))));
        }))()
        : ($core$Dict$balance)($color, $key, $value, $left, ($core$Dict$removeHelp)($targetKey, $right)));
    }))()
    : ((($dict)[0] === "RBEmpty_elm_builtin")
      ? $core$Dict$RBEmpty_elm_builtin
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 210:2', (sp_toHuman)($dict))));
});

const $core$Dict$moveRedRight = (($dict) => {
  return (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && ((((($dict)[4])[4])[0] === "RBNode_elm_builtin") && (((((($dict)[4])[4])[1])[0] === "Red") && ((($dict)[5])[0] === "RBNode_elm_builtin")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $llK = ((($dict)[4])[4])[2];
      const $llV = ((($dict)[4])[4])[3];
      const $llLeft = ((($dict)[4])[4])[4];
      const $llRight = ((($dict)[4])[4])[5];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rLeft = (($dict)[5])[4];
      const $rRight = (($dict)[5])[5];
      return ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $llK, $llV, $llLeft, $llRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, $lRight, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $rK, $rV, $rLeft, $rRight)));
    }))()
    : (((($dict)[0] === "RBNode_elm_builtin") && (((($dict)[4])[0] === "RBNode_elm_builtin") && ((($dict)[5])[0] === "RBNode_elm_builtin")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "Black")
          ? ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, $lLeft, $lRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "Red")
            ? ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $lK, $lV, $lLeft, $lRight), ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 314:6', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 304:2', (sp_toHuman)($dict)))));
});

const $core$Dict$removeHelpPrepEQGT = (($targetKey, $dict, $color, $key, $value, $left, $right) => {
  return (((($left)[0] === "RBNode_elm_builtin") && ((($left)[1])[0] === "Red"))
    ? ((() => {
      const $lK = ($left)[2];
      const $lV = ($left)[3];
      const $lLeft = ($left)[4];
      const $lRight = ($left)[5];
      return ($core$Dict$RBNode_elm_builtin)($color, $lK, $lV, $lLeft, ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $key, $value, $lRight, $right));
    }))()
    : (true
      ? (((($right)[0] === "RBNode_elm_builtin") && (((($right)[1])[0] === "Black") && (((($right)[4])[0] === "RBNode_elm_builtin") && (((($right)[4])[1])[0] === "Black"))))
        ? ($core$Dict$moveRedRight)($dict)
        : (((($right)[0] === "RBNode_elm_builtin") && (((($right)[1])[0] === "Black") && ((($right)[4])[0] === "RBEmpty_elm_builtin")))
          ? ($core$Dict$moveRedRight)($dict)
          : (true
            ? $dict
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 195:6', (sp_toHuman)($right)))))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 185:2', (sp_toHuman)($left))));
});

const $core$Dict$removeHelp = (($targetKey, $dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? $core$Dict$RBEmpty_elm_builtin
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ((sp_equal)((basics_compare)($targetKey, $key), (0 - 1))
          ? (((($left)[0] === "RBNode_elm_builtin") && ((($left)[1])[0] === "Black"))
            ? ((() => {
              const $lLeft = ($left)[4];
              return (((($lLeft)[0] === "RBNode_elm_builtin") && ((($lLeft)[1])[0] === "Red"))
                ? ($core$Dict$RBNode_elm_builtin)($color, $key, $value, ($core$Dict$removeHelp)($targetKey, $left), $right)
                : (true
                  ? ((() => {
                    const $$try1 = ($core$Dict$moveRedLeft)($dict);
                    return ((($$try1)[0] === "RBNode_elm_builtin")
                      ? ((() => {
                        const $nColor = ($$try1)[1];
                        const $nKey = ($$try1)[2];
                        const $nValue = ($$try1)[3];
                        const $nLeft = ($$try1)[4];
                        const $nRight = ($$try1)[5];
                        return ($core$Dict$balance)($nColor, $nKey, $nValue, ($core$Dict$removeHelp)($targetKey, $nLeft), $nRight);
                      }))()
                      : ((($$try1)[0] === "RBEmpty_elm_builtin")
                        ? $core$Dict$RBEmpty_elm_builtin
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 169:16', (sp_toHuman)($$try1))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 164:12', (sp_toHuman)($lLeft))));
            }))()
            : (true
              ? ($core$Dict$RBNode_elm_builtin)($color, $key, $value, ($core$Dict$removeHelp)($targetKey, $left), $right)
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 162:8', (sp_toHuman)($left))))
          : ($core$Dict$removeHelpEQGT)($targetKey, ($core$Dict$removeHelpPrepEQGT)($targetKey, $dict, $color, $key, $value, $left, $right)));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 156:2', (sp_toHuman)($dict))));
});

const $core$Dict$remove = (($key, $dict) => {
  const $$try1 = ($core$Dict$removeHelp)($key, $dict);
  return (((($$try1)[0] === "RBNode_elm_builtin") && ((($$try1)[1])[0] === "Red"))
    ? ((() => {
      const $k = ($$try1)[2];
      const $v = ($$try1)[3];
      const $l = ($$try1)[4];
      const $r = ($$try1)[5];
      return ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $$try1;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 144:2', (sp_toHuman)($$try1))));
});

const $core$Dict$diff = (($t1, $t2) => {
  return ($core$Dict$for)($t1, $t2, (($k, $v, $t) => {
    return ($core$Dict$remove)($k, $t);
  }));
});

const $core$Dict$each = (($dict, $func) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? null
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        ($func)($key, $value);
        ($core$Dict$each)($left, $func);
        return ($core$Dict$each)($right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 453:2', (sp_toHuman)($dict))));
});

const $core$Dict$empty = $core$Dict$RBEmpty_elm_builtin;

const $core$Dict$insertHelp = (($key, $value, $dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? ($core$Dict$RBNode_elm_builtin)($core$Dict$Red, $key, $value, $core$Dict$RBEmpty_elm_builtin, $core$Dict$RBEmpty_elm_builtin)
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $nColor = ($dict)[1];
        const $nKey = ($dict)[2];
        const $nValue = ($dict)[3];
        const $nLeft = ($dict)[4];
        const $nRight = ($dict)[5];
        const $$try1 = (basics_compare)($key, $nKey);
        return ((1 === $$try1)
          ? ($core$Dict$balance)($nColor, $nKey, $nValue, $nLeft, ($core$Dict$insertHelp)($key, $value, $nRight))
          : ((0 === $$try1)
            ? ($core$Dict$RBNode_elm_builtin)($nColor, $nKey, $value, $nLeft, $nRight)
            : (true
              ? ($core$Dict$balance)($nColor, $nKey, $nValue, ($core$Dict$insertHelp)($key, $value, $nLeft), $nRight)
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 96:6', (sp_toHuman)($$try1)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 89:2', (sp_toHuman)($dict))));
});

const $core$Dict$insert = (($key, $value, $dict) => {
  const $$try1 = ($core$Dict$insertHelp)($key, $value, $dict);
  return (((($$try1)[0] === "RBNode_elm_builtin") && ((($$try1)[1])[0] === "Red"))
    ? ((() => {
      const $k = ($$try1)[2];
      const $v = ($$try1)[3];
      const $l = ($$try1)[4];
      const $r = ($$try1)[5];
      return ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $$try1;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 79:2', (sp_toHuman)($$try1))));
});

const $core$Dict$filter = (($isGood, $dict) => {
  return ($core$Dict$for)($core$Dict$empty, $dict, (($k, $v, $d) => {
    return (($isGood)($k, $v)
      ? ($core$Dict$insert)($k, $v, $d)
      : $d);
  }));
});

const $core$Result$onOk = (($f) => {
  return (($result) => {
    return ((($result)[0] === "Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($core$Result$Err)($e);
      }))()
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $a = ($result)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Result.sp 18:4', (sp_toHuman)($result))));
  });
});

const $core$Dict$forRes = (($acc, $dict, $func) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? ($core$Result$Ok)($acc)
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (($core$Result$onOk)((($l) => {
          return (($core$Result$onOk)((($f) => {
            return ($core$Dict$forRes)($f, $right, $func);
          })))(($func)($key, $value, $l));
        })))(($core$Dict$forRes)($acc, $left, $func));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 475:4', (sp_toHuman)($dict))));
});

const $core$Dict$forReversed = (($acc, $t, $func) => {
  return ((($t)[0] === "RBEmpty_elm_builtin")
    ? $acc
    : ((($t)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $key = ($t)[2];
        const $value = ($t)[3];
        const $left = ($t)[4];
        const $right = ($t)[5];
        return ($core$Dict$forReversed)(($func)($key, $value, ($core$Dict$forReversed)($acc, $right, $func)), $left, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 487:2', (sp_toHuman)($t))));
});

const $core$List$for = (($init, $aList, $function) => {
  return ((($aList)[0] === "Nil")
    ? $init
    : ((($aList)[0] === "Cons")
      ? ((() => {
        const $h = ($aList)[1];
        const $tail = ($aList)[2];
        return ($core$List$for)(($function)($h, $init), $tail, $function);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 62:4', (sp_toHuman)($aList))));
});

const $core$Dict$fromList = (($1) => {
  return ($core$List$for)($core$Dict$empty, $1, (($keyAndValue, $dict) => {
    return ($core$Dict$insert)($keyAndValue.first, $keyAndValue.second, $dict);
  }));
});

const $core$Dict$get = (($targetKey, $dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? $core$Maybe$Nothing
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        const $$try1 = (basics_compare)($targetKey, $key);
        return ((1 === $$try1)
          ? ($core$Dict$get)($targetKey, $right)
          : ((0 === $$try1)
            ? ($core$Maybe$Just)($value)
            : (true
              ? ($core$Dict$get)($targetKey, $left)
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 23:6', (sp_toHuman)($$try1)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 18:2', (sp_toHuman)($dict))));
});

const $core$Dict$member = (($key, $dict) => {
  const $$try1 = ($core$Dict$get)($key, $dict);
  return ((($$try1)[0] === "Just")
    ? true
    : ((($$try1)[0] === "Nothing")
      ? false
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 39:2', (sp_toHuman)($$try1))));
});

const $core$Dict$intersect = (($t1, $t2) => {
  return ($core$Dict$filter)((($k, _1) => {
    return ($core$Dict$member)($k, $t2);
  }), $t1);
});

const $core$Dict$isEmpty = (($dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? true
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? false
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 66:2', (sp_toHuman)($dict))));
});

const $core$Dict$join = (($0, $1) => {
  return ($core$Dict$for)($0, $1, $core$Dict$insert);
});

const $core$Dict$keys = (($1) => {
  return ($core$Dict$forReversed)($core$Core$Nil, $1, (($key, $value, $keyList) => {
    return ($core$Core$Cons)($key, $keyList);
  }));
});

const $core$Dict$map = (($func, $dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? $core$Dict$RBEmpty_elm_builtin
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ($core$Dict$RBNode_elm_builtin)($color, $key, ($func)($key, $value), ($core$Dict$map)($func, $left), ($core$Dict$map)($func, $right));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 424:2', (sp_toHuman)($dict))));
});

const $core$Dict$mapKeys = (($func, $dict) => {
  return ($core$Dict$for)($core$Dict$empty, $dict, (($k, $v, $d) => {
    return ($core$Dict$insert)(($func)($k), $v, $d);
  }));
});

const $core$Dict$mapRes = (($func, $dict) => {
  return ((($dict)[0] === "RBEmpty_elm_builtin")
    ? ($core$Result$Ok)($core$Dict$RBEmpty_elm_builtin)
    : ((($dict)[0] === "RBNode_elm_builtin")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (($core$Result$onOk)((($one) => {
          return (($core$Result$onOk)((($two) => {
            return (($core$Result$onOk)((($three) => {
              return ($core$Result$Ok)(($core$Dict$RBNode_elm_builtin)($color, $key, $one, $two, $three));
            })))(($core$Dict$mapRes)($func, $right));
          })))(($core$Dict$mapRes)($func, $left));
        })))(($func)($key, $value));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 434:2', (sp_toHuman)($dict))));
});

const $core$Dict$toList = ((() => {
  const $f = (($key, $value, $list) => {
    return ($core$Core$Cons)(({
      first: $key,
      second: $value,
    }), $list);
  });
  return (($1) => {
    return ($core$Dict$forReversed)($core$Core$Nil, $1, $f);
  });
}))();

const $core$Dict$merge = (($leftStep, $bothStep, $rightStep, $leftDict, $rightDict, $initialResult) => {
  const $stepState = (($rKey, $rValue, $q) => {
    const $$list = $q;
    const $res = $$list.second;
    const $list = $$list.first;
    return ((($list)[0] === "Nil")
      ? ({
        first: $list,
        second: ($rightStep)($rKey, $rValue, $res),
      })
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $lKey = ($list)[1].first;
          const $lValue = ($list)[1].second;
          const $rest = ($list)[2];
          const $$try1 = (basics_compare)($lKey, $rKey);
          return ((1 === $$try1)
            ? ({
              first: $list,
              second: ($rightStep)($rKey, $rValue, $res),
            })
            : ((0 === $$try1)
              ? ({
                first: $rest,
                second: ($bothStep)($lKey, $lValue, $rValue, $res),
              })
              : (true
                ? ($stepState)($rKey, $rValue, ({
                  first: $rest,
                  second: ($leftStep)($lKey, $lValue, $res),
                }))
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 383:10', (sp_toHuman)($$try1)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 378:4', (sp_toHuman)($list))));
  });
  const $$intermediateResult = ($core$Dict$for)(({
    first: ($core$Dict$toList)($leftDict),
    second: $initialResult,
  }), $rightDict, $stepState);
  const $intermediateResult = $$intermediateResult.second;
  const $leftovers = $$intermediateResult.first;
  const $liftLeftStep = (($t, $res) => {
    const $$k = $t;
    const $v = $$k.second;
    const $k = $$k.first;
    return ($leftStep)($k, $v, $res);
  });
  return ($core$List$for)($intermediateResult, $leftovers, $liftLeftStep);
});

const $core$Dict$ofOne = (($key, $value) => {
  return ($core$Dict$RBNode_elm_builtin)($core$Dict$Black, $key, $value, $core$Dict$RBEmpty_elm_builtin, $core$Dict$RBEmpty_elm_builtin);
});

const $core$Dict$onlyBothOnly = (($da, $db) => {
  const $onAOnly = (($key, $a, $$aOnly) => {
    const $aOnly = $$aOnly.first;
    const $both = $$aOnly.second;
    const $bOnly = $$aOnly.third;
    return ({
      first: ($core$Dict$insert)($key, $a, $aOnly),
      second: $both,
      third: $bOnly,
    });
  });
  const $onBOnly = (($key, $b, $$aOnly) => {
    const $aOnly = $$aOnly.first;
    const $both = $$aOnly.second;
    const $bOnly = $$aOnly.third;
    return ({
      first: $aOnly,
      second: $both,
      third: ($core$Dict$insert)($key, $b, $bOnly),
    });
  });
  const $onBoth = (($key, $a, $b, $$aOnly) => {
    const $aOnly = $$aOnly.first;
    const $both = $$aOnly.second;
    const $bOnly = $$aOnly.third;
    return ({
      first: $aOnly,
      second: ($core$Dict$insert)($key, ({
        first: $a,
        second: $b,
      }), $both),
      third: $bOnly,
    });
  });
  return ($core$Dict$merge)($onAOnly, $onBoth, $onBOnly, $da, $db, ({
    first: $core$Dict$empty,
    second: $core$Dict$empty,
    third: $core$Dict$empty,
  }));
});

const $core$Dict$partition = (($isGood, $dict) => {
  const $add = (($key, $value, $t) => {
    const $$t1 = $t;
    const $t2 = $$t1.second;
    const $t1 = $$t1.first;
    return (($isGood)($key, $value)
      ? ({
        first: ($core$Dict$insert)($key, $value, $t1),
        second: $t2,
      })
      : ({
        first: $t1,
        second: ($core$Dict$insert)($key, $value, $t2),
      }));
  });
  return ($core$Dict$for)(({
    first: $core$Dict$empty,
    second: $core$Dict$empty,
  }), $dict, $add);
});

const $core$Dict$size = ((() => {
  const $sizeHelp = (($n, $dict) => {
    return ((($dict)[0] === "RBEmpty_elm_builtin")
      ? $n
      : ((($dict)[0] === "RBNode_elm_builtin")
        ? ((() => {
          const $left = ($dict)[4];
          const $right = ($dict)[5];
          return ($sizeHelp)(($sizeHelp)(($n + 1), $right), $left);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 53:4', (sp_toHuman)($dict))));
  });
  return (($1) => {
    return ($sizeHelp)(0, $1);
  });
}))();

const $core$Dict$update = (($targetKey, $alter, $dictionary) => {
  const $$try1 = ($alter)(($core$Dict$get)($targetKey, $dictionary));
  return ((($$try1)[0] === "Just")
    ? ((() => {
      const $value = ($$try1)[1];
      return ($core$Dict$insert)($targetKey, $value, $dictionary);
    }))()
    : ((($$try1)[0] === "Nothing")
      ? ($core$Dict$remove)($targetKey, $dictionary)
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Dict.sp 337:2', (sp_toHuman)($$try1))));
});

const $core$Dict$values = (($1) => {
  return ($core$Dict$forReversed)($core$Core$Nil, $1, (($key, $value, $valueList) => {
    return ($core$Core$Cons)($value, $valueList);
  }));
});

const $core$Dict_Test$valueTest = (($1, $2, $3) => {
  return ($sd0$Test$valueTest)(sp_toHuman, $1, $2, $3);
});

const $core$Dict_Test$insertAndGet = ($sd0$Test$Group)("insertAndGet", ($core$Core$Cons)(($core$Dict_Test$valueTest)("get, success", ((_0) => {
  return ((($1) => {
    return ($core$Dict$get)(($core$Maybe$Just)("a"), $1);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("b"), 2, $2);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("a"), 1, $2);
  }))($core$Dict$empty)));
}), ($sd0$Test$isOkAndEqualTo)(($core$Maybe$Just)(1))), ($core$Core$Cons)(($core$Dict_Test$valueTest)("get, fail", ((_0) => {
  return ((($1) => {
    return ($core$Dict$get)(($core$Maybe$Just)("c"), $1);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("b"), 2, $2);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("a"), 1, $2);
  }))($core$Dict$empty)));
}), ($sd0$Test$isOkAndEqualTo)($core$Maybe$Nothing)), $core$Core$Nil)));

const $core$Dict_Test$lists = ($sd0$Test$Group)("lists", ($core$Core$Cons)(($core$Dict_Test$valueTest)("keys", ((_0) => {
  return ((($1) => {
    return (list_sortBy)($core$Basics$identity, $1);
  }))(($core$Dict$keys)(((($2) => {
    return ($core$Dict$insert)($core$Maybe$Nothing, 2, $2);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("b"), 2, $2);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("a"), 1, $2);
  }))($core$Dict$empty)))));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(($core$Maybe$Just)("a"), ($core$Core$Cons)(($core$Maybe$Just)("b"), ($core$Core$Cons)($core$Maybe$Nothing, $core$Core$Nil))))), ($core$Core$Cons)(($core$Dict_Test$valueTest)("values", ((_0) => {
  return ((($1) => {
    return (list_sortBy)($core$Basics$identity, $1);
  }))(($core$Dict$values)(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("b"), ({
      a: 3,
    }), $2);
  }))(((($2) => {
    return ($core$Dict$insert)(($core$Maybe$Just)("a"), ({
      a: 1,
    }), $2);
  }))($core$Dict$empty))));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(({
  a: 1,
}), ($core$Core$Cons)(({
  a: 3,
}), $core$Core$Nil)))), $core$Core$Nil)));

const $core$Dict_Test$tests = ($sd0$Test$Group)("Dict", ($core$Core$Cons)($core$Dict_Test$insertAndGet, ($core$Core$Cons)($core$Dict_Test$lists, $core$Core$Nil)));

const $core$Hash$toList = (($h) => {
  return ([
    ((__re__ = (hash_for)($h, (($k, $v, $l) => {
      return ($core$Core$Cons)(({
        first: $k,
        second: $v,
      }), $l);
    }), $core$Core$Nil)), ($h = (__re__)[1]), (__re__)[0]),
    $h,
  ]);
});

const $core$Hash_Test$valueTest = (($1, $2, $3) => {
  return ($sd0$Test$valueTest)(sp_toHuman, $1, $2, $3);
});

const $core$List$each = (($ls, $f) => {
  return ((($ls)[0] === "Nil")
    ? null
    : ((($ls)[0] === "Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $tail = ($ls)[2];
        ($f)($h);
        return ($core$List$each)($tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 341:4', (sp_toHuman)($ls))));
});

const $core$List$range = (($low, $high) => {
  const $rec = (($accum, $up) => {
    return (($up > $low)
      ? ($rec)((sp_cons)($up, $accum), ($up - 1))
      : ((sp_equal)($up, $low)
        ? (sp_cons)($up, $accum)
        : $accum));
  });
  return ($rec)($core$Core$Nil, $high);
});

const $core$Tuple$first = (($t) => {
  return $t.first;
});

const $core$Hash_Test$tests = ($sd0$Test$Group)("Hash", ($core$Core$Cons)(($core$Hash_Test$valueTest)("insert", ((_0) => {
  let $h = (hash_fromList)(($core$Core$Cons)(({
    first: 1,
    second: 2,
  }), $core$Core$Nil));
  ((__re__ = (hash_insert)($h, 2, 3)), ($h = (__re__)[1]), (__re__)[0]);
  return $h;
}), ($sd0$Test$isOkAndEqualTo)((hash_fromList)(($core$Core$Cons)(({
  first: 1,
  second: 2,
}), ($core$Core$Cons)(({
  first: 2,
  second: 3,
}), $core$Core$Nil))))), ($core$Core$Cons)(($core$Hash_Test$valueTest)("remove", ((_0) => {
  let $h = (hash_fromList)(($core$Core$Cons)(({
    first: 1,
    second: 2,
  }), ($core$Core$Cons)(({
    first: 3,
    second: 4,
  }), $core$Core$Nil)));
  ((__re__ = (hash_remove)($h, 1)), ($h = (__re__)[1]), (__re__)[0]);
  return $h;
}), ($sd0$Test$isOkAndEqualTo)((hash_fromList)(($core$Core$Cons)(({
  first: 3,
  second: 4,
}), $core$Core$Nil)))), ($core$Core$Cons)(($core$Hash_Test$valueTest)("get Just", ((_0) => {
  let $h = (hash_fromList)(($core$Core$Cons)(({
    first: 1,
    second: 2,
  }), ($core$Core$Cons)(({
    first: 3,
    second: 4,
  }), $core$Core$Nil)));
  return ((__re__ = (hash_get)($h, 1)), ($h = (__re__)[1]), (__re__)[0]);
}), ($sd0$Test$isOkAndEqualTo)(($core$Maybe$Just)(2))), ($core$Core$Cons)(($core$Hash_Test$valueTest)("get Nothing", ((_0) => {
  let $h = (hash_fromList)(($core$Core$Cons)(({
    first: 1,
    second: 2,
  }), ($core$Core$Cons)(({
    first: 3,
    second: 4,
  }), $core$Core$Nil)));
  return ((__re__ = (hash_get)($h, 66)), ($h = (__re__)[1]), (__re__)[0]);
}), ($sd0$Test$isOkAndEqualTo)($core$Maybe$Nothing)), ($core$Core$Cons)(($core$Hash_Test$valueTest)("for", ((_0) => {
  let $hash = (hash_fromList)(($core$Core$Cons)(({
    first: ($core$Maybe$Just)(true),
    second: 2,
  }), ($core$Core$Cons)(({
    first: $core$Maybe$Nothing,
    second: 4,
  }), $core$Core$Nil)));
  return ((($1) => {
    return (list_sortBy)($core$Tuple$first, $1);
  }))(((($2) => {
    return ((__re__ = (hash_for)($hash, (($k, $v, $a) => {
      return ($core$Core$Cons)(({
        first: $v,
        second: $k,
      }), $a);
    }), $2)), ($hash = (__re__)[1]), (__re__)[0]);
  }))($core$Core$Nil));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(({
  first: 2,
  second: ($core$Maybe$Just)(true),
}), ($core$Core$Cons)(({
  first: 4,
  second: $core$Maybe$Nothing,
}), $core$Core$Nil)))), ($core$Core$Cons)(($core$Hash_Test$valueTest)("each", ((_0) => {
  let $a = (array_fromList)($core$Core$Nil);
  let $hash = (hash_fromList)(($core$Core$Cons)(({
    first: ($core$Maybe$Just)(true),
    second: 2,
  }), ($core$Core$Cons)(({
    first: $core$Maybe$Nothing,
    second: 1,
  }), $core$Core$Nil)));
  ((__re__ = (hash_each)($hash, (($k, $v) => {
    return ($core$List$each)(($core$List$range)(1, $v), ((_0) => {
      return ((__re__ = (array_push)($a, $k)), ($a = (__re__)[1]), (__re__)[0]);
    }));
  }))), ($hash = (__re__)[1]), (__re__)[0]);
  ((__re__ = (array_sortBy)($a, $core$Basics$identity)), ($a = (__re__)[1]), (__re__)[0]);
  return $a;
}), ($sd0$Test$isOkAndEqualTo)((array_fromList)(($core$Core$Cons)(($core$Maybe$Just)(true), ($core$Core$Cons)(($core$Maybe$Just)(true), ($core$Core$Cons)($core$Maybe$Nothing, $core$Core$Nil)))))), $core$Core$Nil)))))));

const $core$List$all = (($fun, $list) => {
  return ((($list)[0] === "Nil")
    ? true
    : ((($list)[0] === "Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($fun)($h)
          ? ($core$List$all)($fun, $t)
          : false);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 13:4', (sp_toHuman)($list))));
});

const $core$List$any = (($fun, $list) => {
  return ((($list)[0] === "Nil")
    ? false
    : ((($list)[0] === "Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($fun)($h)
          ? true
          : ($core$List$any)($fun, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 6:4', (sp_toHuman)($list))));
});

const $core$List$reverse = (($aList) => {
  return ($core$List$for)($core$Core$Nil, $aList, $core$Core$Cons);
});

const $core$List$forReversed = (($init, $list, $f) => {
  const $foldrHelper = (($acc, $ctr, $ls) => {
    return ((($ls)[0] === "Nil")
      ? $acc
      : ((($ls)[0] === "Cons")
        ? ((() => {
          const $a = ($ls)[1];
          const $r1 = ($ls)[2];
          return ((($r1)[0] === "Nil")
            ? ($f)($a, $acc)
            : ((($r1)[0] === "Cons")
              ? ((() => {
                const $b = ($r1)[1];
                const $r2 = ($r1)[2];
                return ((($r2)[0] === "Nil")
                  ? ($f)($a, ($f)($b, $acc))
                  : ((($r2)[0] === "Cons")
                    ? ((() => {
                      const $c = ($r2)[1];
                      const $r3 = ($r2)[2];
                      return ((($r3)[0] === "Nil")
                        ? ($f)($a, ($f)($b, ($f)($c, $acc)))
                        : ((($r3)[0] === "Cons")
                          ? ((() => {
                            const $d = ($r3)[1];
                            const $r4 = ($r3)[2];
                            const $res = (($ctr > 500)
                              ? ($core$List$for)($acc, ($core$List$reverse)($r4), $f)
                              : ($foldrHelper)($acc, ($ctr + 1), $r4));
                            return ($f)($a, ($f)($b, ($f)($c, ($f)($d, $res))));
                          }))()
                          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 96:32', (sp_toHuman)($r3))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 91:24', (sp_toHuman)($r2))));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 86:16', (sp_toHuman)($r1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 81:8', (sp_toHuman)($ls))));
  });
  return ($foldrHelper)($init, 0, $list);
});

const $core$List$append = (($xs, $ys) => {
  return ((($ys)[0] === "Nil")
    ? $xs
    : (true
      ? ($core$List$forReversed)($ys, $xs, $core$Core$Cons)
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 199:2', (sp_toHuman)($ys))));
});

const $core$List$concat = (($lists) => {
  return ($core$List$forReversed)($core$Core$Nil, $lists, $core$List$append);
});

const $core$List$map = (($f, $list) => {
  return ($core$List$forReversed)($core$Core$Nil, $list, (($x, $acc) => {
    return (sp_cons)(($f)($x), $acc);
  }));
});

const $core$List$concatMap = (($f, $list) => {
  return ($core$List$concat)(($core$List$map)($f, $list));
});

const $core$List$drop = (($n, $ls) => {
  return ((sp_equal)($n, 0)
    ? $ls
    : ((($ls)[0] === "Nil")
      ? $core$Core$Nil
      : ((($ls)[0] === "Cons")
        ? ((() => {
          const $h = ($ls)[1];
          const $tail = ($ls)[2];
          return ($core$List$drop)(($n - 1), $tail);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 371:6', (sp_toHuman)($ls)))));
});

const $core$List$filter = (($f, $ls) => {
  return ($core$List$forReversed)($core$Core$Nil, $ls, (($item, $acc) => {
    return (($f)($item)
      ? (sp_cons)($item, $acc)
      : $acc);
  }));
});

const $core$List$filterMap = (($f, $la) => {
  const $update = (($a, $acc) => {
    const $$try1 = ($f)($a);
    return ((($$try1)[0] === "Just")
      ? ((() => {
        const $b = ($$try1)[1];
        return (sp_cons)($b, $acc);
      }))()
      : ((($$try1)[0] === "Nothing")
        ? $acc
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 319:6', (sp_toHuman)($$try1))));
  });
  return ($core$List$forReversed)($core$Core$Nil, $la, $update);
});

const $core$List$find = (($test, $list) => {
  return ((($list)[0] === "Nil")
    ? $core$Maybe$Nothing
    : ((($list)[0] === "Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($test)($h)
          ? ($core$Maybe$Just)($h)
          : ($core$List$find)($test, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 24:4', (sp_toHuman)($list))));
});

const $core$List$forRes = (($accum, $ls, $f) => {
  return ((($ls)[0] === "Nil")
    ? ($core$Result$Ok)($accum)
    : ((($ls)[0] === "Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $t = ($ls)[2];
        const $$try1 = ($f)($h, $accum);
        return ((($$try1)[0] === "Err")
          ? ((() => {
            const $x = ($$try1)[1];
            return ($core$Result$Err)($x);
          }))()
          : ((($$try1)[0] === "Ok")
            ? ((() => {
              const $newAccum = ($$try1)[1];
              return ($core$List$forRes)($newAccum, $t, $f);
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 153:12', (sp_toHuman)($$try1))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 148:4', (sp_toHuman)($ls))));
});

const $core$List$head = (($list) => {
  return ((($list)[0] === "Nil")
    ? $core$Maybe$Nothing
    : ((($list)[0] === "Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ($core$Maybe$Just)($h);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 226:4', (sp_toHuman)($list))));
});

const $core$Tuple$second = (($t) => {
  return $t.second;
});

const $core$List$indexedFor = (($init, $aList, $function) => {
  return ($core$Tuple$second)(($core$List$for)(({
    first: 0,
    second: $init,
  }), $aList, (($item, $$accum) => {
    const $index = $$accum.first;
    const $accum = $$accum.second;
    return ({
      first: ($index + 1),
      second: ($function)($index, $item, $accum),
    });
  })));
});

const $core$List$indexedMap = (($f, $aa) => {
  const $rec = (($accum, $n, $list) => {
    return ((($list)[0] === "Nil")
      ? ($core$List$reverse)($accum)
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return ($rec)((sp_cons)(($f)($n, $h), $accum), ($n + 1), $t);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 178:8', (sp_toHuman)($list))));
  });
  return ($rec)($core$Core$Nil, 0, $aa);
});

const $core$List$indexedMap2 = (($f, $aaa, $bbb) => {
  const $rec = (($accum, $n, $aa, $bb) => {
    const $$try1 = ({
      first: $aa,
      second: $bb,
    });
    return (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Cons"))
      ? ((() => {
        const $a = ($$try1.first)[1];
        const $at = ($$try1.first)[2];
        const $b = ($$try1.second)[1];
        const $bt = ($$try1.second)[2];
        return ($rec)((sp_cons)(($f)($n, $a, $b), $accum), ($n + 1), $at, $bt);
      }))()
      : (true
        ? ($core$List$reverse)($accum)
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 190:8', (sp_toHuman)($$try1))));
  });
  return ($rec)($core$Core$Nil, 0, $aaa, $bbb);
});

const $core$List$last = (($list) => {
  return ((($list)[0] === "Nil")
    ? $core$Maybe$Nothing
    : (((($list)[0] === "Cons") && ((($list)[2])[0] === "Nil"))
      ? ((() => {
        const $h = ($list)[1];
        return ($core$Maybe$Just)($h);
      }))()
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return ($core$List$last)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 233:4', (sp_toHuman)($list)))));
});

const $core$List$length = (($list) => {
  return ($core$List$for)(0, $list, ((_0, $a) => {
    return ($a + 1);
  }));
});

const $core$List$map2 = (($f, $aa, $bb) => {
  const $rec = (($accum, $ax, $bx) => {
    const $$try1 = ({
      first: $ax,
      second: $bx,
    });
    return (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Cons"))
      ? ((() => {
        const $ahead = ($$try1.first)[1];
        const $atail = ($$try1.first)[2];
        const $bhead = ($$try1.second)[1];
        const $btail = ($$try1.second)[2];
        return ($rec)(($core$Core$Cons)(($f)($ahead, $bhead), $accum), $atail, $btail);
      }))()
      : (true
        ? ($core$List$reverse)($accum)
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 127:6', (sp_toHuman)($$try1))));
  });
  return ($rec)($core$Core$Nil, $aa, $bb);
});

const $core$List$mapFirst = (($f, $ls) => {
  return ((($ls)[0] === "Nil")
    ? $core$Maybe$Nothing
    : ((($ls)[0] === "Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $tail = ($ls)[2];
        const $r = ($f)($h);
        return ((($r)[0] === "Nothing")
          ? ($core$List$mapFirst)($f, $tail)
          : (true
            ? $r
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 334:12', (sp_toHuman)($r))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 328:4', (sp_toHuman)($ls))));
});

const $core$Result$map = (($f, $result) => {
  return ((($result)[0] === "Err")
    ? ((() => {
      const $e = ($result)[1];
      return ($core$Result$Err)($e);
    }))()
    : ((($result)[0] === "Ok")
      ? ((() => {
        const $a = ($result)[1];
        return ($core$Result$Ok)(($f)($a));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Result.sp 10:4', (sp_toHuman)($result))));
});

const $core$List$mapRes = (($f, $list) => {
  const $fun = (($a, $acc) => {
    return ($core$Result$map)((($b) => {
      return ($core$Core$Cons)($b, $acc);
    }), ($f)($a));
  });
  return ((($1) => {
    return ($core$Result$map)($core$List$reverse, $1);
  }))(($core$List$forRes)($core$Core$Nil, $list, $fun));
});

const $core$List$member = (($a, $list) => {
  return ((($list)[0] === "Nil")
    ? false
    : ((($list)[0] === "Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ((sp_equal)($a, $h)
          ? true
          : ($core$List$member)($a, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 35:4', (sp_toHuman)($list))));
});

const $core$List$minimum = (($list) => {
  return ((($list)[0] === "Cons")
    ? ((() => {
      const $x = ($list)[1];
      const $xs = ($list)[2];
      return ($core$Maybe$Just)(($core$List$for)($x, $xs, $core$Basics$min));
    }))()
    : (true
      ? $core$Maybe$Nothing
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 379:4', (sp_toHuman)($list))));
});

const $core$List$partition = (($f, $ls) => {
  return ((($0) => {
    return ($core$List$forReversed)($0, $ls, (($item, $$false) => {
      const $true = $$false.first;
      const $false = $$false.second;
      return (($f)($item)
        ? ({
          first: (sp_cons)($item, $true),
          second: $false,
        })
        : ({
          first: $true,
          second: (sp_cons)($item, $false),
        }));
    }));
  }))(({
    first: $core$Core$Nil,
    second: $core$Core$Nil,
  }));
});

const $core$List$repeat = (($n, $a) => {
  const $rec = (($c, $acc) => {
    return (($c > 0)
      ? ($rec)(($c - 1), (sp_cons)($a, $acc))
      : $acc);
  });
  return ($rec)($n, $core$Core$Nil);
});

const $core$List$sort = (($1) => {
  return (list_sortBy)($core$Basics$identity, $1);
});

const $core$List$takeReverse = (($n, $list, $kept) => {
  return (($n < 1)
    ? $kept
    : ((($list)[0] === "Nil")
      ? $kept
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $x = ($list)[1];
          const $xs = ($list)[2];
          return ($core$List$takeReverse)(($n - 1), $xs, ($core$Core$Cons)($x, $kept));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 283:4', (sp_toHuman)($list)))));
});

const $core$List$takeTailRec = (($n, $list) => {
  return ($core$List$reverse)(($core$List$takeReverse)($n, $list, $core$Core$Nil));
});

const $core$List$takeFast = (($ctr, $n, $list) => {
  return (($n < 1)
    ? $core$Core$Nil
    : ((() => {
      const $$try1 = ({
        first: $n,
        second: $list,
      });
      return ((($$try1.second)[0] === "Nil")
        ? $list
        : (((1 === $$try1.first) && (($$try1.second)[0] === "Cons"))
          ? ((() => {
            const $x = ($$try1.second)[1];
            return ($core$Core$Cons)($x, $core$Core$Nil);
          }))()
          : (((2 === $$try1.first) && ((($$try1.second)[0] === "Cons") && ((($$try1.second)[2])[0] === "Cons")))
            ? ((() => {
              const $x = ($$try1.second)[1];
              const $y = (($$try1.second)[2])[1];
              return ($core$Core$Cons)($x, ($core$Core$Cons)($y, $core$Core$Nil));
            }))()
            : (((3 === $$try1.first) && ((($$try1.second)[0] === "Cons") && (((($$try1.second)[2])[0] === "Cons") && (((($$try1.second)[2])[2])[0] === "Cons"))))
              ? ((() => {
                const $x = ($$try1.second)[1];
                const $y = (($$try1.second)[2])[1];
                const $z = ((($$try1.second)[2])[2])[1];
                return ($core$Core$Cons)($x, ($core$Core$Cons)($y, ($core$Core$Cons)($z, $core$Core$Nil)));
              }))()
              : (((($$try1.second)[0] === "Cons") && (((($$try1.second)[2])[0] === "Cons") && ((((($$try1.second)[2])[2])[0] === "Cons") && ((((($$try1.second)[2])[2])[2])[0] === "Cons"))))
                ? ((() => {
                  const $x = ($$try1.second)[1];
                  const $y = (($$try1.second)[2])[1];
                  const $z = ((($$try1.second)[2])[2])[1];
                  const $w = (((($$try1.second)[2])[2])[2])[1];
                  const $tl = (((($$try1.second)[2])[2])[2])[2];
                  const $cons = $core$Core$Cons;
                  return (($ctr > 1000)
                    ? ($cons)($x, ($cons)($y, ($cons)($z, ($cons)($w, ($core$List$takeTailRec)(($n - 4), $tl)))))
                    : ($cons)($x, ($cons)($y, ($cons)($z, ($cons)($w, ($core$List$takeFast)(($ctr + 1), ($n - 4), $tl))))));
                }))()
                : (true
                  ? $list
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 249:4', (sp_toHuman)($$try1))))))));
    }))());
});

const $core$List$take = (($1, $2) => {
  return ($core$List$takeFast)(0, $1, $2);
});

const $core$List$takeWhile = (($test, $its) => {
  const $rec = (($accum, $list) => {
    return ((($list)[0] === "Nil")
      ? ($core$List$reverse)($accum)
      : ((($list)[0] === "Cons")
        ? ((() => {
          const $head = ($list)[1];
          const $tail = ($list)[2];
          return (($test)($head)
            ? ($rec)((sp_cons)($head, $accum), $tail)
            : ($core$List$reverse)($accum));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/List.sp 296:6', (sp_toHuman)($list))));
  });
  return ($rec)($core$Core$Nil, $its);
});

const $core$List_Test$valueTest = (($1, $2, $3) => {
  return ($sd0$Test$valueTest)(sp_toHuman, $1, $2, $3);
});

const $core$List_Test$concat = ($sd0$Test$Group)("concat", ($core$Core$Cons)(($core$List_Test$valueTest)("concats two lists", ((_0) => {
  return ($core$List$concat)(($core$Core$Cons)(($core$Core$Cons)(1, ($core$Core$Cons)(2, $core$Core$Nil)), ($core$Core$Cons)(($core$Core$Cons)(3, ($core$Core$Cons)(4, $core$Core$Nil)), $core$Core$Nil)));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(1, ($core$Core$Cons)(2, ($core$Core$Cons)(3, ($core$Core$Cons)(4, $core$Core$Nil)))))), $core$Core$Nil));

const $core$List_Test$sortBy = ($sd0$Test$Group)("sortBy", ($core$Core$Cons)(($core$List_Test$valueTest)("Can actually sort stuff", ((_0) => {
  return ((($1) => {
    return (list_sortBy)($core$Basics$identity, $1);
  }))(($core$Core$Cons)(($core$Maybe$Just)(23), ($core$Core$Cons)($core$Maybe$Nothing, ($core$Core$Cons)(($core$Maybe$Just)(11), $core$Core$Nil))));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(($core$Maybe$Just)(11), ($core$Core$Cons)(($core$Maybe$Just)(23), ($core$Core$Cons)($core$Maybe$Nothing, $core$Core$Nil))))), ($core$Core$Cons)(($core$List_Test$valueTest)("Correctly orders tuple-2", ((_0) => {
  return ((($1) => {
    return (list_sortBy)($core$Basics$identity, $1);
  }))(($core$Core$Cons)(({
    first: 23,
    second: 1,
  }), ($core$Core$Cons)(({
    first: 1,
    second: 2,
  }), ($core$Core$Cons)(({
    first: 11,
    second: 3,
  }), $core$Core$Nil))));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(({
  first: 1,
  second: 2,
}), ($core$Core$Cons)(({
  first: 11,
  second: 3,
}), ($core$Core$Cons)(({
  first: 23,
  second: 1,
}), $core$Core$Nil))))), ($core$Core$Cons)(($core$List_Test$valueTest)("Correctly orders tuple-3", ((_0) => {
  return ((($1) => {
    return (list_sortBy)($core$Basics$identity, $1);
  }))(($core$Core$Cons)(({
    first: "z",
    second: "a",
    third: "2",
  }), ($core$Core$Cons)(({
    first: "a",
    second: "b",
    third: "33",
  }), ($core$Core$Cons)(({
    first: "z",
    second: "a",
    third: "1",
  }), ($core$Core$Cons)(({
    first: "z",
    second: "b",
    third: "3",
  }), $core$Core$Nil)))));
}), ($sd0$Test$isOkAndEqualTo)(($core$Core$Cons)(({
  first: "a",
  second: "b",
  third: "33",
}), ($core$Core$Cons)(({
  first: "z",
  second: "a",
  third: "1",
}), ($core$Core$Cons)(({
  first: "z",
  second: "a",
  third: "2",
}), ($core$Core$Cons)(({
  first: "z",
  second: "b",
  third: "3",
}), $core$Core$Nil)))))), $core$Core$Nil))));

const $core$List_Test$tests = ($sd0$Test$Group)("List", ($core$Core$Cons)($core$List_Test$sortBy, ($core$Core$Cons)($core$List_Test$concat, $core$Core$Nil)));

const $core$Maybe$andThen = (($f) => {
  return (($ma) => {
    return ((($ma)[0] === "Nothing")
      ? $core$Maybe$Nothing
      : ((($ma)[0] === "Just")
        ? ((() => {
          const $a = ($ma)[1];
          return ($f)($a);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Maybe.sp 9:4', (sp_toHuman)($ma))));
  });
});

const $core$Maybe$map = (($f, $m) => {
  return ((($m)[0] === "Nothing")
    ? $core$Maybe$Nothing
    : ((($m)[0] === "Just")
      ? ((() => {
        const $v = ($m)[1];
        return ($core$Maybe$Just)(($f)($v));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Maybe.sp 16:4', (sp_toHuman)($m))));
});

const $core$Maybe$mapRes = (($f, $m) => {
  return ((($m)[0] === "Nothing")
    ? ($core$Result$Ok)($core$Maybe$Nothing)
    : ((($m)[0] === "Just")
      ? ((() => {
        const $a = ($m)[1];
        return ($core$Result$map)($core$Maybe$Just, ($f)($a));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Maybe.sp 38:4', (sp_toHuman)($m))));
});

const $core$Maybe$withDefault = (($default, $maybe) => {
  return ((($maybe)[0] === "Just")
    ? ((() => {
      const $v = ($maybe)[1];
      return $v;
    }))()
    : ((($maybe)[0] === "Nothing")
      ? $default
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Maybe.sp 48:4', (sp_toHuman)($maybe))));
});

const $core$Result$fromMaybe = (($err, $maybe) => {
  return ((($maybe)[0] === "Nothing")
    ? ($core$Result$Err)($err)
    : ((($maybe)[0] === "Just")
      ? ((() => {
        const $a = ($maybe)[1];
        return ($core$Result$Ok)($a);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Result.sp 34:4', (sp_toHuman)($maybe))));
});

const $core$Result$mapError = (($f, $result) => {
  return ((($result)[0] === "Ok")
    ? ((() => {
      const $a = ($result)[1];
      return ($core$Result$Ok)($a);
    }))()
    : ((($result)[0] === "Err")
      ? ((() => {
        const $e1 = ($result)[1];
        return ($core$Result$Err)(($f)($e1));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Result.sp 26:4', (sp_toHuman)($result))));
});

const $core$Result$withDefault = (($default, $result) => {
  return ((($result)[0] === "Ok")
    ? ((() => {
      const $a = ($result)[1];
      return $a;
    }))()
    : ((($result)[0] === "Err")
      ? $default
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Result.sp 42:4', (sp_toHuman)($result))));
});

const $core$Set$diff = $core$Dict$diff;

const $core$Set$empty = $core$Dict$empty;

const $core$Set$insert = (($0, $2) => {
  return ($core$Dict$insert)($0, null, $2);
});

const $core$Set$fromList = (($1) => {
  return ($core$List$for)($core$Set$empty, $1, $core$Set$insert);
});

const $core$Set$intersect = $core$Dict$intersect;

const $core$Set$isEmpty = $core$Dict$isEmpty;

const $core$Set$join = $core$Dict$join;

const $core$Set$map = (($f, $set) => {
  return ($core$Dict$for)($core$Set$empty, $set, (($k, _1, $d) => {
    return ($core$Dict$insert)(($f)($k), null, $d);
  }));
});

const $core$Set$member = $core$Dict$member;

const $core$Set$ofOne = (($0) => {
  return ($core$Dict$ofOne)($0, null);
});

const $core$Set$remove = $core$Dict$remove;

const $core$Set$size = $core$Dict$size;

const $core$Set$toList = $core$Dict$keys;

const $core$Text$contains = (($sub, $str) => {
  const $$try1 = (text_split)($sub, $str);
  return (((($$try1)[0] === "Cons") && ((($$try1)[2])[0] === "Nil"))
    ? false
    : (true
      ? true
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/core/Text.sp 116:4', (sp_toHuman)($$try1))));
});

const $core$Text$dropRight = (($n, $s) => {
  return (($n > 0)
    ? (text_slice)(0, -($n), $s)
    : $s);
});

const $core$Text$repeat = (($n, $s) => {
  return ($core$Text$join)("", ($core$List$repeat)($n, $s));
});

const $core$Text$padLeft = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($textLength - $minLength), (text_length)($pad));
      return (($core$Text$repeat)($times, $pad) + $s);
    }))()
    : $s);
});

const $core$Text$padRight = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($textLength - $minLength), (text_length)($pad));
      return ($s + ($core$Text$repeat)($times, $pad));
    }))()
    : $s);
});

const $core$Text$replace = (($toRemove, $toPut, $s) => {
  return ((($1) => {
    return ($core$Text$join)($toPut, $1);
  }))(((($1) => {
    return (text_split)($toRemove, $1);
  }))($s));
});

const $core$Tuple$mapBoth = (($fa, $fb, $t) => {
  return ({
    first: ($fa)($t.first),
    second: ($fb)($t.second),
  });
});

const $core$Tuple$mapFirst = (($f, $t) => {
  return ({
    first: ($f)($t.first),
    second: $t.second,
  });
});

const $core$Tuple$mapSecond = (($f, $t) => {
  return ({
    first: $t.first,
    second: ($f)($t.second),
  });
});

const $core$Tuple$pair = (($a, $b) => {
  return ({
    first: $a,
    second: $b,
  });
});

const $posix$IO$_run = (($never, $r) => {
  const $$neverToResult = $r;
  const $neverToResult = ($$neverToResult)[1];
  return ($neverToResult)($never);
});

const $posix$IO$fail = (($message) => {
  return ($posix$IO$IO)((($never) => {
    return ($core$Result$Err)($message);
  }));
});

const $posix$IO$onResult = (($f) => {
  return (($m) => {
    return ($posix$IO$IO)((($never) => {
      return ((($1) => {
        return ($posix$IO$_run)($never, $1);
      }))(($f)(((($1) => {
        return ($posix$IO$_run)($never, $1);
      }))($m)));
    }));
  });
});

const $posix$IO$onSuccess = (($f) => {
  return (($m) => {
    return ($posix$IO$IO)((($never) => {
      const $$try1 = ($posix$IO$_run)($never, $m);
      return ((($$try1)[0] === "Ok")
        ? ((() => {
          const $a = ($$try1)[1];
          return ($posix$IO$_run)($never, ($f)($a));
        }))()
        : ((($$try1)[0] === "Err")
          ? ((() => {
            const $e = ($$try1)[1];
            return ($core$Result$Err)($e);
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/lib/posix/IO.sp 40:8', (sp_toHuman)($$try1))));
    }));
  });
});

const $posix$IO$succeed = (($a) => {
  return ($posix$IO$IO)((($never) => {
    return ($core$Result$Ok)($a);
  }));
});

const $sd0$Compile$asModule = (($tuple) => {
  const $$isDirectory = $tuple;
  const $name = $$isDirectory.second;
  const $isDirectory = $$isDirectory.first;
  return (($isDirectory || (sp_not_equal)(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$"))($name), $name))
    ? $core$Maybe$Nothing
    : ($core$Maybe$Just)(((($2) => {
      return ($core$Text$replace)(".sp", "", $2);
    }))($name)));
});

const $sd0$Compile$asModuleDirectory = (($tuple) => {
  const $$isDirectory = $tuple;
  const $name = $$isDirectory.second;
  const $isDirectory = $$isDirectory.first;
  return (($isDirectory && (sp_equal)(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$"))($name), $name))
    ? ($core$Maybe$Just)($name)
    : $core$Maybe$Nothing);
});

const $sd0$Compile$libDirectoryName = "lib";

const $sd0$Compile$listSourceDir = (($sourceDirRoot, $modulePathWithTrailingSlash) => {
  const $path = ($sourceDirRoot + ("/" + $modulePathWithTrailingSlash));
  return (($posix$IO$onSuccess)((($dirContents) => {
    const $directChildren = ((($1) => {
      return ($core$List$map)((($fileName) => {
        return ($modulePathWithTrailingSlash + $fileName);
      }), $1);
    }))(((($1) => {
      return ($core$List$filterMap)($sd0$Compile$asModule, $1);
    }))($dirContents));
    const $getDescendants = (io_parallel)(((($1) => {
      return ($core$List$map)((($subDir) => {
        return ($sd0$Compile$listSourceDir)($sourceDirRoot, ($modulePathWithTrailingSlash + ($subDir + "/")));
      }), $1);
    }))(((($1) => {
      return ($core$List$filterMap)($sd0$Compile$asModuleDirectory, $1);
    }))($dirContents)));
    return (($posix$IO$onSuccess)((($descendants) => {
      return ($posix$IO$succeed)(($core$List$concat)(($core$Core$Cons)($directChildren, ($core$Core$Cons)(($core$List$concat)($descendants), $core$Core$Nil))));
    })))($getDescendants);
  })))((io_readDir)($path));
});

const $sd0$Compile$modulesFileName = "modules.sp";

const $sd0$Term$color = (($code) => {
  return (($text) => {
    return ($code + ($text + "\x1b[0m"));
  });
});

const $sd0$Term$blue = ($sd0$Term$color)("\x1b[34m");

const $sd0$Term$red = ($sd0$Term$color)("\x1b[31m");

const $sd0$Term$yellow = ($sd0$Term$color)("\x1b[33m");

const $sd0$Compile$formattedToConsoleColoredText = (($formattedText) => {
  return ((($formattedText)[0] === "FormattedText_Default")
    ? ((() => {
      const $t = ($formattedText)[1];
      return $t;
    }))()
    : ((($formattedText)[0] === "FormattedText_Emphasys")
      ? ((() => {
        const $t = ($formattedText)[1];
        return ($sd0$Term$yellow)($t);
      }))()
      : ((($formattedText)[0] === "FormattedText_Warning")
        ? ((() => {
          const $t = ($formattedText)[1];
          return ($sd0$Term$red)($t);
        }))()
        : ((($formattedText)[0] === "FormattedText_Decoration")
          ? ((() => {
            const $t = ($formattedText)[1];
            return ($sd0$Term$blue)($t);
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 20:4', (sp_toHuman)($formattedText))))));
});

const $sd0$Compiler$Error$flatten = (($e, $accum) => {
  return ((($e)[0] === "Simple")
    ? ((() => {
      const $pos = ($e)[1];
      const $descr = ($e)[2];
      return ($core$Core$Cons)(({
        first: $pos,
        second: $descr,
      }), $accum);
    }))()
    : ((($e)[0] === "Nested")
      ? ((() => {
        const $ls = ($e)[1];
        return ($core$List$for)($accum, $ls, $sd0$Compiler$Error$flatten);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 104:4', (sp_toHuman)($e))));
});

const $sd0$Compiler$Error$formatSeparator = "$|$|$";

const $sd0$Compiler$Error$formatSuffix = "$`$`$";

const $sd0$Compiler$Error$breakDownText = (($text) => {
  const $formatSnippet = (($index, $snippet) => {
    return ((sp_equal)((basics_modBy)(2, $index), 0)
      ? ($sd0$Compiler$Error$FormattedText_Default)($snippet)
      : ((() => {
        const $$try1 = (text_split)($sd0$Compiler$Error$formatSuffix, $snippet);
        return (((($$try1)[0] === "Cons") && (("emphasys" === ($$try1)[1]) && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil"))))
          ? ((() => {
            const $s = (($$try1)[2])[1];
            return ($sd0$Compiler$Error$FormattedText_Emphasys)($s);
          }))()
          : (((($$try1)[0] === "Cons") && (("warning" === ($$try1)[1]) && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil"))))
            ? ((() => {
              const $s = (($$try1)[2])[1];
              return ($sd0$Compiler$Error$FormattedText_Warning)($s);
            }))()
            : (((($$try1)[0] === "Cons") && (("decoration" === ($$try1)[1]) && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil"))))
              ? ((() => {
                const $s = (($$try1)[2])[1];
                return ($sd0$Compiler$Error$FormattedText_Decoration)($s);
              }))()
              : (true
                ? ($sd0$Compiler$Error$FormattedText_Default)($snippet)
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 69:10', (sp_toHuman)($$try1))))));
      }))());
  });
  return ((($1) => {
    return ($core$List$indexedMap)($formatSnippet, $1);
  }))(((($1) => {
    return (text_split)($sd0$Compiler$Error$formatSeparator, $1);
  }))($text));
});

const $sd0$Compiler$Error$formatWrap = (($fmtName, $text) => {
  return ($sd0$Compiler$Error$formatSeparator + ($fmtName + ($sd0$Compiler$Error$formatSuffix + ($text + $sd0$Compiler$Error$formatSeparator))));
});

const $sd0$Compiler$Error$deco = (($1) => {
  return ($sd0$Compiler$Error$formatWrap)("decoration", $1);
});

const $sd0$Compiler$Error$positionToLineAndColumn = (($s, $index) => {
  const $before = (text_slice)(0, $index, $s);
  const $lines = (text_split)("\n", $before);
  const $lineNumber = ($core$List$length)($lines);
  const $colNumber = ((($1) => {
    return ($core$Maybe$withDefault)(0, $1);
  }))(((($1) => {
    return ($core$Maybe$map)(text_length, $1);
  }))(($core$List$last)($lines)));
  return ({
    col: $colNumber,
    line: $lineNumber,
  });
});

const $sd0$Compiler$Error$highlightSplit = (($h, $x) => {
  const $$lines = $x;
  const $lines = $$lines.second;
  const $words = $$lines.first;
  return ((($h)[0] === "HighlightWord")
    ? ((() => {
      const $colEnd = ($h)[1].colEnd;
      const $colStart = ($h)[1].colStart;
      const $line = ($h)[1].line;
      return ({
        first: ($core$Dict$insert)($line, ({
          first: $colStart,
          second: $colEnd,
        }), $words),
        second: $lines,
      });
    }))()
    : ((($h)[0] === "HighlightBlock")
      ? ((() => {
        const $lineEnd = ($h)[1].lineEnd;
        const $lineStart = ($h)[1].lineStart;
        return ({
          first: $words,
          second: ($core$List$for)($lines, ($core$List$range)($lineStart, $lineEnd), $core$Set$insert),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 141:4', (sp_toHuman)($h))));
});

const $sd0$Compiler$Error$warn = (($1) => {
  return ($sd0$Compiler$Error$formatWrap)("warning", $1);
});

const $sd0$Compiler$Error$fmtBlock = (($start, $highlights, $ls) => {
  const $$highlightedLines = ($core$List$for)(({
    first: $core$Dict$empty,
    second: $core$Set$empty,
  }), $highlights, $sd0$Compiler$Error$highlightSplit);
  const $highlightedLines = $$highlightedLines.second;
  const $highlightedWords = $$highlightedLines.first;
  const $pad = (text_length)((text_fromNumber)(($start + ($core$List$length)($ls))));
  const $wordHighlight = (($lineNumber) => {
    const $$try1 = ($core$Dict$get)($lineNumber, $highlightedWords);
    return ((($$try1)[0] === "Nothing")
      ? ""
      : ((($$try1)[0] === "Just")
        ? ((() => {
          const $s = ($$try1)[1].first;
          const $e = ($$try1)[1].second;
          return ("\n" + (($core$Text$repeat)($pad, " ") + ("   " + (($core$Text$repeat)(($s - 1), " ") + ($sd0$Compiler$Error$warn)(($core$Text$repeat)(($core$Basics$max)(1, ($e - $s)), "^"))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 162:8', (sp_toHuman)($$try1))));
  });
  const $lineDem = (($lineIndex) => {
    return (($core$Set$member)($lineIndex, $highlightedLines)
      ? ($sd0$Compiler$Error$warn)(" > ")
      : " | ");
  });
  const $fmtLine = (($i, $line) => {
    const $index = ($i + $start);
    const $s = ((($2) => {
      return ($core$Text$padLeft)($pad, " ", $2);
    }))((text_fromNumber)($index));
    return ($s + (($lineDem)($index) + ($line + ($wordHighlight)($index))));
  });
  return ((($s) => {
    return ($s + "\n");
  }))(((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$indexedMap)($fmtLine, $1);
  }))($ls)));
});

const $sd0$Compiler$Error$showCodeBlock = (($code, $start, $end) => {
  return (($end.line < 0)
    ? ""
    : ((() => {
      const $highlight = ((sp_not_equal)($start.line, $end.line)
        ? ($sd0$Compiler$Error$HighlightBlock)(({
          lineEnd: $end.line,
          lineStart: $start.line,
        }))
        : ($sd0$Compiler$Error$HighlightWord)(({
          colEnd: $end.col,
          colStart: $start.col,
          line: $start.line,
        })));
      const $extraLines = 2;
      const $lines = (text_split)("\n", $code);
      const $maxLines = ($core$List$length)($lines);
      const $startLine = ($core$Basics$clamp)(0, ($maxLines - 1), ($start.line - ($extraLines - 1)));
      const $endLine = ($core$Basics$clamp)(0, ($maxLines - 1), ($end.line + $extraLines));
      const $size = ($core$Basics$max)(1, ($endLine - $startLine));
      return ((($2) => {
        return ($sd0$Compiler$Error$fmtBlock)(($startLine + 1), ($core$Core$Cons)($highlight, $core$Core$Nil), $2);
      }))(((($1) => {
        return ($core$List$take)($size, $1);
      }))(((($1) => {
        return ($core$List$drop)($startLine, $1);
      }))($lines)));
    }))());
});

const $sd0$Compiler$Error$posToHuman = (($eEnv, $pos) => {
  const $noBlock = (($loc) => {
    return ({
      block: "",
      location: $loc,
    });
  });
  return ((($pos)[0] === "P")
    ? ((() => {
      const $moduleName = ($pos)[1];
      const $startAsInt = ($pos)[2];
      const $endAsInt = ($pos)[3];
      const $$try2 = ($core$Dict$get)($moduleName, $eEnv.moduleByName);
      return ((($$try2)[0] === "Just")
        ? ((() => {
          const $mod = ($$try2)[1];
          const $start = ($sd0$Compiler$Error$positionToLineAndColumn)($mod.content, $startAsInt);
          const $end = ($sd0$Compiler$Error$positionToLineAndColumn)($mod.content, $endAsInt);
          return ({
            block: ($sd0$Compiler$Error$showCodeBlock)($mod.content, $start, $end),
            location: ($mod.fsPath + (" " + ((text_fromNumber)($start.line) + (":" + (text_fromNumber)($start.col))))),
          });
        }))()
        : ((($$try2)[0] === "Nothing")
          ? ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 252:12', (sp_toHuman)($$try2))));
    }))()
    : ((($pos)[0] === "End")
      ? ((() => {
        const $moduleName = ($pos)[1];
        const $$try1 = ($core$Dict$get)($moduleName, $eEnv.moduleByName);
        return ((($$try1)[0] === "Just")
          ? ((() => {
            const $mod = ($$try1)[1];
            const $end = ($sd0$Compiler$Error$positionToLineAndColumn)($mod.content, ((text_length)($mod.content) - 1));
            const $start = ({
              col: 0,
              line: ($end.line - 8),
            });
            return ({
              block: ($sd0$Compiler$Error$showCodeBlock)($mod.content, $start, $end),
              location: ($mod.fsPath + (" " + ((text_fromNumber)($end.line) + ":0 (end of file)"))),
            });
          }))()
          : ((($$try1)[0] === "Nothing")
            ? ($noBlock)(("<The module name is `" + ($moduleName + "` but I can't find it. This as a compiler bug.>")))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 268:12', (sp_toHuman)($$try1))));
      }))()
      : ((($pos)[0] === "N")
        ? ($noBlock)("<native code>")
        : ((($pos)[0] === "S")
          ? ($noBlock)("<the location information has been stripped>")
          : ((($pos)[0] === "T")
            ? ($noBlock)("<defined in test modules>")
            : ((($pos)[0] === "I")
              ? ((() => {
                const $n = ($pos)[1];
                return ($noBlock)(("<inferred " + ((text_fromNumber)($n) + ">")));
              }))()
              : ((($pos)[0] === "G")
                ? ($noBlock)("<generated>")
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Error.sp 250:4', (sp_toHuman)($pos)))))))));
});

const $sd0$Compiler$Error$toText = (($env, $pos, $desc) => {
  const $$block = ($sd0$Compiler$Error$posToHuman)($env, $pos);
  const $location = $$block.location;
  const $block = $$block.block;
  const $description = ((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($s) => {
      return ("  " + $s);
    }), $1);
  }))(((($1) => {
    return ($core$List$concatMap)((($1) => {
      return (text_split)("\n", $1);
    }), $1);
  }))(((($d) => {
    return ($core$Core$Cons)($block, $d);
  }))(($desc)($env)))));
  return ($sd0$Compiler$Error$breakDownText)(((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(($core$Core$Cons)("", ($core$Core$Cons)("", ($core$Core$Cons)(($sd0$Compiler$Error$deco)(($core$Text$padRight)(50, "-", ($location + " "))), ($core$Core$Cons)("", ($core$Core$Cons)($description, ($core$Core$Cons)("", $core$Core$Nil))))))));
});

const $sd0$Compiler$Error$toFormattedText = (($eenv, $e) => {
  const $newline = ($sd0$Compiler$Error$FormattedText_Default)("");
  const $tupleToFormattedText = (($x) => {
    const $$descr = $x;
    const $descr = $$descr.second;
    const $pos = $$descr.first;
    return ($sd0$Compiler$Error$toText)($eenv, $pos, $descr);
  });
  return ($core$List$concatMap)($tupleToFormattedText, ($sd0$Compiler$Error$flatten)($e, $core$Core$Nil));
});

const $sd0$Compile$resToIo = (($errorEnv, $res) => {
  return ((($res)[0] === "Ok")
    ? ((() => {
      const $a = ($res)[1];
      return ($posix$IO$succeed)($a);
    }))()
    : ((($res)[0] === "Err")
      ? ((() => {
        const $e = ($res)[1];
        return ($posix$IO$fail)(((($1) => {
          return ($core$Text$join)("", $1);
        }))(((($1) => {
          return ($core$List$map)($sd0$Compile$formattedToConsoleColoredText, $1);
        }))(((($1) => {
          return ($sd0$Compiler$Error$toFormattedText)($errorEnv, $1);
        }))($e))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 29:4', (sp_toHuman)($res))));
});

const $sd0$ModulesFile$initModulesFile = ({
  libraries: $core$Core$Nil,
  sourceDirs: $core$Core$Nil,
});

const $sd0$SPON$expressionToStatements = (($e) => {
  return (((($e)[0] === "Expression") && (((($e)[2])[0] === "Statements") && ((((($e)[2])[1])[0] === "Cons") && (((((($e)[2])[1])[1])[0] === "Evaluation") && ((((($e)[2])[1])[2])[0] === "Nil")))))
    ? ((() => {
      const $nested = (((($e)[2])[1])[1])[1];
      return ($sd0$SPON$expressionToStatements)($nested);
    }))()
    : (((($e)[0] === "Expression") && ((($e)[2])[0] === "Statements"))
      ? ((() => {
        const $stats = (($e)[2])[1];
        return $stats;
      }))()
      : (true
        ? ($core$Core$Cons)(($sd0$Types$FormattableAst$Evaluation)($e), $core$Core$Nil)
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 224:4', (sp_toHuman)($e)))));
});

const $sd0$SPON$posEnd = ($sd0$Types$Pos$End)("");

const $sd0$Types$FormattableAst$statementPos = (($statement) => {
  return (((($statement)[0] === "Evaluation") && ((($statement)[1])[0] === "Expression"))
    ? ((() => {
      const $pos = (($statement)[1])[1];
      const $expr_ = (($statement)[1])[2];
      return $pos;
    }))()
    : (((($statement)[0] === "ValueDef") && ((($statement)[1].pattern)[0] === "Expression"))
      ? ((() => {
        const $body = ($statement)[1].body;
        const $nonFn = ($statement)[1].nonFn;
        const $pos = (($statement)[1].pattern)[1];
        const $expr_ = (($statement)[1].pattern)[2];
        return $pos;
      }))()
      : (((($statement)[0] === "AliasDef") && ((($statement)[1].name)[0] === "At"))
        ? ((() => {
          const $args = ($statement)[1].args;
          const $pos = (($statement)[1].name)[1];
          const $type = ($statement)[1].type;
          return $pos;
        }))()
        : (((($statement)[0] === "UnionDef") && ((($statement)[1].name)[0] === "At"))
          ? ((() => {
            const $args = ($statement)[1].args;
            const $constructors = ($statement)[1].constructors;
            const $pos = (($statement)[1].name)[1];
            return $pos;
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/FormattableAst.sp 127:4', (sp_toHuman)($statement))))));
});

const $sd0$SPON$field = (($fieldName, $fieldReader) => {
  return (($statements) => {
    return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "ValueDef") && ((((($statements)[1])[1].pattern)[0] === "Expression") && (((((($statements)[1])[1].pattern)[2])[0] === "Variable") && ((((((($statements)[1])[1].pattern)[2])[1].maybeType)[0] === "Nothing") && ((((((($statements)[1])[1].pattern)[2])[1].word.attrPath)[0] === "Nil") && ((((((($statements)[1])[1].pattern)[2])[1].word.maybeModule)[0] === "Nothing") && (((((($statements)[1])[1].pattern)[2])[1].word.modifier)[0] === "NameNoModifier"))))))))
      ? ((() => {
        const $body = (($statements)[1])[1].body;
        const $nonFn = (($statements)[1])[1].nonFn;
        const $pos = ((($statements)[1])[1].pattern)[1];
        const $name = (((($statements)[1])[1].pattern)[2])[1].word.name;
        const $tail = ($statements)[2];
        return ((sp_equal)($name, $fieldName)
          ? ((() => {
            const $$try1 = ($fieldReader)(($sd0$SPON$expressionToStatements)($body));
            return ((($$try1)[0] === "Accepted")
              ? ((() => {
                const $unreadStatements = ($$try1)[1];
                const $a = ($$try1)[2];
                return ((($unreadStatements)[0] === "Nil")
                  ? ($sd0$SPON$Accepted)($tail, $a)
                  : ((($unreadStatements)[0] === "Cons")
                    ? ((() => {
                      const $head = ($unreadStatements)[1];
                      return ($sd0$SPON$Failed)(((($1) => {
                        return ($sd0$Types$Pos$At)(($sd0$Types$FormattableAst$statementPos)($head), $1);
                      }))(("Could not make sense of all the statements in field `" + ($fieldName + "`."))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 258:28', (sp_toHuman)($unreadStatements))));
              }))()
              : (true
                ? ((() => {
                  const $otherwise = $$try1;
                  return $otherwise;
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 256:20', (sp_toHuman)($$try1))));
          }))()
          : ($sd0$SPON$Rejected)(((($1) => {
            return ($sd0$Types$Pos$At)($pos, $1);
          }))(("expecting `" + ($fieldName + " =`")))));
      }))()
      : ((($statements)[0] === "Cons")
        ? ((() => {
          const $head = ($statements)[1];
          const $tail = ($statements)[2];
          return ($sd0$SPON$Rejected)(($sd0$Types$Pos$At)(($sd0$Types$FormattableAst$statementPos)($head), "missing a simple assignment (ie `something = `)"));
        }))()
        : ((($statements)[0] === "Nil")
          ? ($sd0$SPON$Rejected)(($sd0$Types$Pos$At)($sd0$SPON$posEnd, "unexpected end of file"))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 234:4', (sp_toHuman)($statements)))));
  });
});

const $sd0$SPON$onAcc = (($chainedReaderB) => {
  return (($readerA) => {
    return (($statements) => {
      const $$try1 = ($readerA)($statements);
      return ((($$try1)[0] === "Accepted")
        ? ((() => {
          const $newStatements = ($$try1)[1];
          const $a = ($$try1)[2];
          return (($chainedReaderB)($a))($newStatements);
        }))()
        : ((($$try1)[0] === "Rejected")
          ? ((() => {
            const $reason = ($$try1)[1];
            return ($sd0$SPON$Rejected)($reason);
          }))()
          : ((($$try1)[0] === "Failed")
            ? ((() => {
              const $reason = ($$try1)[1];
              return ($sd0$SPON$Failed)($reason);
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 18:4', (sp_toHuman)($$try1)))));
    });
  });
});

const $sd0$SPON$getPos = (($statements) => {
  return ((($statements)[0] === "Cons")
    ? ((() => {
      const $head = ($statements)[1];
      const $tail = ($statements)[2];
      return ($sd0$Types$FormattableAst$statementPos)($head);
    }))()
    : ((($statements)[0] === "Nil")
      ? $sd0$SPON$posEnd
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 36:4', (sp_toHuman)($statements))));
});

const $sd0$SPON$reject = (($message) => {
  return (($statements) => {
    return ($sd0$SPON$Rejected)(($sd0$Types$Pos$At)(($sd0$SPON$getPos)($statements), $message));
  });
});

const $sd0$SPON$return = (($a) => {
  return (($statements) => {
    return ($sd0$SPON$Accepted)($statements, $a);
  });
});

const $sd0$SPON$word = (($statements) => {
  return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Evaluation") && ((((($statements)[1])[1])[0] === "Expression") && ((((($statements)[1])[1])[2])[0] === "Variable"))))
    ? ((() => {
      const $maybeType = (((($statements)[1])[1])[2])[1].maybeType;
      const $word = (((($statements)[1])[1])[2])[1].word;
      const $tail = ($statements)[2];
      return ($sd0$SPON$Accepted)($tail, $word);
    }))()
    : (((($statements)[0] === "Cons") && ((($statements)[2])[0] === "Nil"))
      ? ((() => {
        const $s = ($statements)[1];
        return ($sd0$SPON$Rejected)(($sd0$Types$Pos$At)(($sd0$Types$FormattableAst$statementPos)($s), "expecting an Uppercase name"));
      }))()
      : (true
        ? ($sd0$SPON$Failed)(($sd0$Types$Pos$At)($sd0$SPON$posEnd, "expecting a statement"))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 118:4', (sp_toHuman)($statements)))));
});

const $sd0$SPON$lowerOrUpperName = (($sd0$SPON$onAcc)((($w) => {
  return (((($w.attrPath)[0] === "Nil") && ((($w.maybeModule)[0] === "Nothing") && (($w.modifier)[0] === "NameNoModifier")))
    ? ((() => {
      const $name = $w.name;
      return ($sd0$SPON$return)($name);
    }))()
    : (true
      ? ($sd0$SPON$reject)("expecting an upper or lower case name")
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 142:4', (sp_toHuman)($w))));
})))($sd0$SPON$word);

const $sd0$SPON$many = (($readerA) => {
  const $rec = (($accum) => {
    return (($statements) => {
      return ((sp_equal)($statements, $core$Core$Nil)
        ? ($sd0$SPON$Accepted)($core$Core$Nil, ($core$List$reverse)($accum))
        : ((() => {
          const $$try1 = ($readerA)($statements);
          return ((($$try1)[0] === "Accepted")
            ? ((() => {
              const $tail = ($$try1)[1];
              const $a = ($$try1)[2];
              return (($rec)((sp_cons)($a, $accum)))($tail);
            }))()
            : ((($$try1)[0] === "Rejected")
              ? ((() => {
                const $e = ($$try1)[1];
                return ($sd0$SPON$Rejected)($e);
              }))()
              : ((($$try1)[0] === "Failed")
                ? ((() => {
                  const $e = ($$try1)[1];
                  return ($sd0$SPON$Failed)($e);
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 194:12', (sp_toHuman)($$try1)))));
        }))());
    });
  });
  return ($rec)($core$Core$Nil);
});

const $sd0$SPON$maybe = (($readerA) => {
  return (($statements) => {
    const $$try1 = ($readerA)($statements);
    return ((($$try1)[0] === "Accepted")
      ? ((() => {
        const $tail = ($$try1)[1];
        const $a = ($$try1)[2];
        return ($sd0$SPON$Accepted)($tail, ($core$Maybe$Just)($a));
      }))()
      : ((($$try1)[0] === "Rejected")
        ? ($sd0$SPON$Accepted)($statements, $core$Maybe$Nothing)
        : ((($$try1)[0] === "Failed")
          ? ((() => {
            const $r = ($$try1)[1];
            return ($sd0$SPON$Failed)($r);
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 210:4', (sp_toHuman)($$try1)))));
  });
});

const $sd0$SPON$upperName = (($sd0$SPON$onAcc)((($w) => {
  return (((($w.attrPath)[0] === "Nil") && ($w.isUpper && ((($w.maybeModule)[0] === "Nothing") && (($w.modifier)[0] === "NameNoModifier"))))
    ? ((() => {
      const $name = $w.name;
      return ($sd0$SPON$return)($name);
    }))()
    : (true
      ? ($sd0$SPON$reject)("expecting an upper case name")
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 132:4', (sp_toHuman)($w))));
})))($sd0$SPON$word);

const $sd0$ModulesFile$moduleReader = (($sd0$SPON$onAcc)((($path) => {
  return (($sd0$SPON$onAcc)((($visibleAs) => {
    return (($sd0$SPON$onAcc)((($globalTypes) => {
      return (($sd0$SPON$onAcc)((($globalValues) => {
        return ($sd0$SPON$return)(({
          globalTypes: ($core$Maybe$withDefault)($core$Core$Nil, $globalTypes),
          globalValues: ($core$Maybe$withDefault)($core$Core$Nil, $globalValues),
          path: $path,
          visibleAs: ($core$Maybe$withDefault)($path, $visibleAs),
        }));
      })))(($sd0$SPON$maybe)(($sd0$SPON$field)("globalValues", ($sd0$SPON$many)($sd0$SPON$lowerOrUpperName))));
    })))(($sd0$SPON$maybe)(($sd0$SPON$field)("globalTypes", ($sd0$SPON$many)($sd0$SPON$upperName))));
  })))(($sd0$SPON$maybe)(($sd0$SPON$field)("importAs", $sd0$SPON$upperName)));
})))(($sd0$SPON$field)("path", $sd0$SPON$upperName));

const $sd0$SPON$text = (($statements) => {
  return (((($statements)[0] === "Cons") && (((($statements)[1])[0] === "Evaluation") && ((((($statements)[1])[1])[0] === "Expression") && (((((($statements)[1])[1])[2])[0] === "LiteralText") && ((($statements)[2])[0] === "Nil")))))
    ? ((() => {
      const $t = (((($statements)[1])[1])[2])[1];
      return ($sd0$SPON$Accepted)($core$Core$Nil, $t);
    }))()
    : (((($statements)[0] === "Cons") && ((($statements)[2])[0] === "Nil"))
      ? ((() => {
        const $s = ($statements)[1];
        return ($sd0$SPON$Rejected)(($sd0$Types$Pos$At)(($sd0$Types$FormattableAst$statementPos)($s), "expecting a text literal"));
      }))()
      : (true
        ? ($sd0$SPON$Failed)(($sd0$Types$Pos$At)($sd0$SPON$posEnd, "expecting a single statement"))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 105:4', (sp_toHuman)($statements)))));
});

const $sd0$ModulesFile$libraryReader = (($sd0$SPON$onAcc)((($source) => {
  return (($sd0$SPON$onAcc)((($modules) => {
    return ($sd0$SPON$return)(({
      modules: $modules,
      source: $source,
    }));
  })))(($sd0$SPON$many)(($sd0$SPON$field)("module", $sd0$ModulesFile$moduleReader)));
})))(($sd0$SPON$field)("source", $sd0$SPON$text));

const $sd0$ModulesFile$sourceDirectoryReader = (($sd0$SPON$onAcc)((($path) => {
  return (($sd0$SPON$onAcc)((($modules) => {
    return ($sd0$SPON$return)(({
      modules: $modules,
      path: $path,
    }));
  })))(($sd0$SPON$many)(($sd0$SPON$field)("module", $sd0$ModulesFile$moduleReader)));
})))(($sd0$SPON$field)("path", $sd0$SPON$text));

const $sd0$SPON$oneOf = (($readers) => {
  return (($statements) => {
    return ((($readers)[0] === "Nil")
      ? ((() => {
        const $pos = ((($statements)[0] === "Cons")
          ? ((() => {
            const $head = ($statements)[1];
            return ($sd0$Types$FormattableAst$statementPos)($head);
          }))()
          : (true
            ? $sd0$SPON$posEnd
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 161:16', (sp_toHuman)($statements))));
        return ($sd0$SPON$Rejected)(($sd0$Types$Pos$At)($pos, "options exhausted"));
      }))()
      : ((($readers)[0] === "Cons")
        ? ((() => {
          const $headReader = ($readers)[1];
          const $tail = ($readers)[2];
          const $$try1 = ($headReader)($statements);
          return ((($$try1)[0] === "Rejected")
            ? (($sd0$SPON$oneOf)($tail))($statements)
            : (true
              ? ((() => {
                const $otherwise = $$try1;
                return $otherwise;
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 168:12', (sp_toHuman)($$try1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 158:4', (sp_toHuman)($readers))));
  });
});

const $sd0$ModulesFile$modulesFileReader = ($sd0$SPON$many)(($sd0$SPON$oneOf)(($core$Core$Cons)((($sd0$SPON$onAcc)((($lib) => {
  return ($sd0$SPON$return)(($sd0$ModulesFile$Lib)($lib));
})))(($sd0$SPON$field)("library", $sd0$ModulesFile$libraryReader)), ($core$Core$Cons)((($sd0$SPON$onAcc)((($dir) => {
  return ($sd0$SPON$return)(($sd0$ModulesFile$Dir)($dir));
})))(($sd0$SPON$field)("sourceDir", $sd0$ModulesFile$sourceDirectoryReader)), $core$Core$Nil))));

const $sd0$Compiler$Lexer$getPos = (($state) => {
  return ([
    ((__re__ = (basics_cloneUni)($state.nextPos)), ($state.nextPos = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$closeOpenBlocks = (($state) => {
  const $pos = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $s = ((__re__ = (array_toList)($state.indentStack)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
  ($core$List$each)($s, ((_0) => {
    return ((__re__ = (array_push)($state.tokens, ($sd0$Types$Token$Token)($sd0$Types$Token$N, $pos, $pos, $sd0$Types$Token$BlockEnd))), ($state.tokens = (__re__)[1]), (__re__)[0]);
  }));
  return ([
    ((__re__ = (array_push)($state.sections, ((__re__ = (array_toList)($state.tokens)), ($state.tokens = (__re__)[1]), (__re__)[0]))), ($state.sections = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$addIndentToken = (($pos, $kind, $state) => {
  return ([
    ((__re__ = (array_push)($state.tokens, ($sd0$Types$Token$Token)($sd0$Types$Token$N, $pos, $pos, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$updateIndent = (($start, $end, $kind, $state) => {
  const $manageIndent = (($head) => {
    const $lineIndent = ((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]);
    return (($lineIndent > $head.indent)
      ? ((() => {
        const $newIndent = ({
          indent: $lineIndent,
          isBlock: ((__re__ = (basics_cloneUni)($state.indentStartsABlock)), ($state.indentStartsABlock = (__re__)[1]), (__re__)[0]),
        });
        ((__re__ = (array_push)($state.indentStack, $newIndent)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
        return (((__re__ = (basics_cloneUni)($state.indentStartsABlock)), ($state.indentStartsABlock = (__re__)[1]), (__re__)[0])
          ? ((__re__ = ($sd0$Compiler$Lexer$addIndentToken)($start, $sd0$Types$Token$BlockStart, $state)), ($state = (__re__)[1]), (__re__)[0])
          : null);
      }))()
      : ($head.isBlock
        ? ((() => {
          const $list = ((__re__ = (array_toList)($state.tokens)), ($state.tokens = (__re__)[1]), (__re__)[0]);
          (((sp_not_equal)(((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]), 0) || (sp_equal)($list, $core$Core$Nil))
            ? null
            : ((() => {
              ((__re__ = (array_push)($state.sections, $list)), ($state.sections = (__re__)[1]), (__re__)[0]);
              return ($state.tokens = (array_fromList)($core$Core$Nil));
            }))());
          return ((__re__ = ($sd0$Compiler$Lexer$addIndentToken)($start, $sd0$Types$Token$NewSiblingLine, $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : null));
  });
  const $$try1 = ((__re__ = (array_pop)($state.indentStack)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
  return ([
    ((($$try1)[0] === "Just")
      ? ((() => {
        const $head = ($$try1)[1];
        return ((((__re__ = (basics_cloneUni)($state.lineIndent)), ($state.lineIndent = (__re__)[1]), (__re__)[0]) < $head.indent)
          ? ((() => {
            ($head.isBlock
              ? ((__re__ = ($sd0$Compiler$Lexer$addIndentToken)($start, $sd0$Types$Token$BlockEnd, $state)), ($state = (__re__)[1]), (__re__)[0])
              : null);
            return ((__re__ = ($sd0$Compiler$Lexer$updateIndent)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : ((() => {
            ((__re__ = (array_push)($state.indentStack, $head)), ($state.indentStack = (__re__)[1]), (__re__)[0]);
            return ($manageIndent)($head);
          }))());
      }))()
      : ((($$try1)[0] === "Nothing")
        ? ($manageIndent)(({
          indent: 0,
          isBlock: true,
        }))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 156:4', (sp_toHuman)($$try1)))),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$absAddToken = (($start, $end, $kind, $state) => {
  (((__re__ = (basics_cloneUni)($state.soFarThereAreNoTokensInThisLine)), ($state.soFarThereAreNoTokensInThisLine = (__re__)[1]), (__re__)[0])
    ? ((() => {
      ($state.soFarThereAreNoTokensInThisLine = false);
      return ((__re__ = ($sd0$Compiler$Lexer$updateIndent)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
    }))()
    : null);
  let $indentStartsABlock = ((($kind)[0] === "Then")
    ? true
    : ((($kind)[0] === "Else")
      ? true
      : ((($kind)[0] === "As")
        ? true
        : ((($kind)[0] === "Colon")
          ? true
          : ((($kind)[0] === "Defop")
            ? true
            : (true
              ? false
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 185:8', (sp_toHuman)($kind))))))));
  ($state.indentStartsABlock = $indentStartsABlock);
  ((__re__ = (array_push)($state.tokens, ($sd0$Types$Token$Token)($sd0$Types$Token$N, $start, $end, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$addError = (($message, $state) => {
  const $end = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $error = (($moduleName) => {
    return ($sd0$Compiler$Error$Simple)(($sd0$Types$Pos$P)($moduleName, $start, $end), ((_0) => {
      return ($core$Core$Cons)($message, $core$Core$Nil);
    }));
  });
  ((__re__ = (array_push)($state.errors, $error)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ([
    ($state.tokenStart = (basics_cloneImm)($end)),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$getChunk = (($buffer, $state) => {
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $end = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ({
      first: $start,
      second: $end,
      third: (text_slice)($start, $end, $buffer),
    }),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$addNumberToken = (($buffer, $state) => {
  const $$chunk = ((__re__ = ($sd0$Compiler$Lexer$getChunk)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = $$chunk.third;
  const $end = $$chunk.second;
  const $start = $$chunk.first;
  return ([
    ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, ($sd0$Types$Token$NumberLiteral)($chunk), $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$relAddToken = (($ds, $de, $kind, $state) => {
  const $pos = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ((__re__ = ($sd0$Compiler$Lexer$absAddToken)(($pos + $ds), ($pos + $de), $kind, $state)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$addParenOrCommaToken = (($char, $state) => {
  const $add = (($2) => {
    return ((__re__ = ($sd0$Compiler$Lexer$relAddToken)(0, 1, $2, $state)), ($state = (__re__)[1]), (__re__)[0]);
  });
  return ([
    (("(" === $char)
      ? ($add)(($sd0$Types$Token$RoundParen)($sd0$Types$Token$Open))
      : ((")" === $char)
        ? ($add)(($sd0$Types$Token$RoundParen)($sd0$Types$Token$Closed))
        : (("[" === $char)
          ? ($add)(($sd0$Types$Token$SquareBracket)($sd0$Types$Token$Open))
          : (("]" === $char)
            ? ($add)(($sd0$Types$Token$SquareBracket)($sd0$Types$Token$Closed))
            : (("{" === $char)
              ? ($add)(($sd0$Types$Token$CurlyBrace)($sd0$Types$Token$Open))
              : (("}" === $char)
                ? ($add)(($sd0$Types$Token$CurlyBrace)($sd0$Types$Token$Closed))
                : (("," === $char)
                  ? ($add)($sd0$Types$Token$Comma)
                  : (true
                    ? ((__re__ = ($sd0$Compiler$Lexer$addError)(("I can't make sense of this piece of text: `" + ($char + "`")), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 498:4', (sp_toHuman)($char)))))))))),
    $state,
  ]);
});

const $sd0$Compiler$CoreTypes$p = $sd0$Types$Pos$N;

const $sd0$Compiler$CoreTypes$defToType = (($def, $pars) => {
  return ($sd0$Types$CanonicalAst$TypeNamed)($sd0$Compiler$CoreTypes$p, $def.usr, $pars);
});

const $sd0$Compiler$CoreTypes$umr = ($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "Core");

const $sd0$Compiler$CoreTypes$makeUsr = (($1) => {
  return ($sd0$Types$Meta$USR)($sd0$Compiler$CoreTypes$umr, $1);
});

const $sd0$Compiler$CoreTypes$numberDef = ({
  constructors: $core$Dict$empty,
  directTypeDeps: $core$Set$empty,
  pars: $core$Core$Nil,
  usr: ($sd0$Compiler$CoreTypes$makeUsr)("Number"),
});

const $sd0$Compiler$CoreTypes$number = ($sd0$Compiler$CoreTypes$defToType)($sd0$Compiler$CoreTypes$numberDef, $core$Core$Nil);

const $sd0$Prelude$numberUsr = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "Number"), $1);
});

const $sd0$Types$Ast$toImm = (($raw) => {
  return ({
    raw: $raw,
    uni: $sd0$Types$Ast$Imm,
  });
});

const $sd0$Types$Ast$toUni = (($raw) => {
  return ({
    raw: $raw,
    uni: $sd0$Types$Ast$Uni,
  });
});

const $sd0$Prelude$typeBinopUnique = (($ty) => {
  return ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$N, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParSp)(($sd0$Types$Ast$toImm)($ty)), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParSp)(($sd0$Types$Ast$toImm)($ty)), $core$Core$Nil)), ($sd0$Types$Ast$toUni)($ty));
});

const $sd0$Prelude$add = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Addittive,
  symbol: "+",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$numberUsr)("add"),
});

const $sd0$Compiler$CoreTypes$nameToType = (($name, $args) => {
  return ($sd0$Types$CanonicalAst$TypeNamed)($sd0$Compiler$CoreTypes$p, ($sd0$Compiler$CoreTypes$makeUsr)($name), $args);
});

const $sd0$Compiler$CoreTypes$bool = ($sd0$Compiler$CoreTypes$nameToType)("Bool", $core$Core$Nil);

const $sd0$Prelude$coreUsr = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "Core"), $1);
});

const $sd0$Prelude$and_ = ({
  associativity: $sd0$Types$Op$Right,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Logical,
  symbol: "and",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("and_"),
});

const $sd0$Prelude$divide = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Multiplicative,
  symbol: "/",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$numberUsr)("divide"),
});

const $sd0$Prelude$tyVar = (($name) => {
  return ($sd0$Types$CanonicalAst$TypeAnnotationVariable)($sd0$Types$Pos$N, $name);
});

const $sd0$Prelude$tyFn = (($pars, $to) => {
  return ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$N, ($core$List$map)((($p) => {
    return ($sd0$Types$CanonicalAst$ParSp)(($sd0$Types$Ast$toImm)($p));
  }), $pars), ($sd0$Types$Ast$toImm)($to));
});

const $sd0$Prelude$typeBinop = (($left, $right, $return) => {
  return ($sd0$Prelude$tyFn)(($core$Core$Cons)($left, ($core$Core$Cons)($right, $core$Core$Nil)), $return);
});

const $sd0$Prelude$equal = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  precedence: $sd0$Types$Op$Comparison,
  symbol: "==",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("a"), $sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("equal"),
});

const $sd0$Prelude$greaterOrEqualThan = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  precedence: $sd0$Types$Op$Comparison,
  symbol: ">=",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("a"), $sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("greaterOrEqualThan"),
});

const $sd0$Prelude$greaterThan = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  precedence: $sd0$Types$Op$Comparison,
  symbol: ">",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("a"), $sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("greaterThan"),
});

const $sd0$Prelude$lesserOrEqualThan = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  precedence: $sd0$Types$Op$Comparison,
  symbol: "<=",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("a"), $sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("lesserOrEqualThan"),
});

const $sd0$Prelude$lesserThan = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  precedence: $sd0$Types$Op$Comparison,
  symbol: "<",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("a"), $sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("lesserThan"),
});

const $sd0$Compiler$CoreTypes$list = (($item) => {
  return ($sd0$Compiler$CoreTypes$nameToType)("List", ($core$Core$Cons)($item, $core$Core$Nil));
});

const $sd0$Prelude$listUsr = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "List"), $1);
});

const $sd0$Prelude$listCons = ((() => {
  const $item = ($sd0$Prelude$tyVar)("item");
  return ({
    associativity: $sd0$Types$Op$Right,
    nonFn: $core$Core$Nil,
    precedence: $sd0$Types$Op$Cons,
    symbol: "::",
    type: ($sd0$Prelude$typeBinop)($item, ($sd0$Compiler$CoreTypes$list)($item), ($sd0$Compiler$CoreTypes$list)($item)),
    usr: ($sd0$Prelude$listUsr)("stack"),
  });
}))();

const $sd0$Prelude$multiply = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Multiplicative,
  symbol: "*",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$numberUsr)("multiply"),
});

const $sd0$Compiler$CoreTypes$noneName = "None";

const $sd0$Compiler$CoreTypes$none = ($sd0$Compiler$CoreTypes$nameToType)($sd0$Compiler$CoreTypes$noneName, $core$Core$Nil);

const $sd0$Prelude$mutableAdd = ({
  associativity: $sd0$Types$Op$NonAssociative,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Mutop,
  symbol: "+=",
  type: ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$N, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParRe)($sd0$Compiler$CoreTypes$number), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParSp)(({
    raw: $sd0$Compiler$CoreTypes$number,
    uni: $sd0$Types$Ast$Imm,
  })), $core$Core$Nil)), ({
    raw: $sd0$Compiler$CoreTypes$none,
    uni: $sd0$Types$Ast$Imm,
  })),
  usr: ($sd0$Prelude$numberUsr)("mutableAdd"),
});

const $sd0$Prelude$mutableAssign = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Mutop,
  symbol: ":=",
  type: ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$N, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParRe)(($sd0$Prelude$tyVar)("a")), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParSp)(({
    raw: ($sd0$Prelude$tyVar)("a"),
    uni: $sd0$Types$Ast$Uni,
  })), $core$Core$Nil)), ({
    raw: $sd0$Compiler$CoreTypes$none,
    uni: $sd0$Types$Ast$Imm,
  })),
  usr: ($sd0$Prelude$coreUsr)("mutableAssign"),
});

const $sd0$Prelude$mutableSubtract = ({
  associativity: $sd0$Types$Op$NonAssociative,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Mutop,
  symbol: "-=",
  type: ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$N, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParRe)($sd0$Compiler$CoreTypes$number), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParSp)(({
    raw: $sd0$Compiler$CoreTypes$number,
    uni: $sd0$Types$Ast$Imm,
  })), $core$Core$Nil)), ({
    raw: $sd0$Compiler$CoreTypes$none,
    uni: $sd0$Types$Ast$Imm,
  })),
  usr: ($sd0$Prelude$numberUsr)("mutableSubtract"),
});

const $sd0$Prelude$notEqual = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  precedence: $sd0$Types$Op$Comparison,
  symbol: "/=",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("a"), $sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("notEqual"),
});

const $sd0$Prelude$or_ = ({
  associativity: $sd0$Types$Op$Right,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Logical,
  symbol: "or",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$bool),
  usr: ($sd0$Prelude$coreUsr)("or_"),
});

const $sd0$Prelude$sendLeft = ({
  associativity: $sd0$Types$Op$Right,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Pipe,
  symbol: "<<",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyFn)(($core$Core$Cons)(($sd0$Prelude$tyVar)("a"), $core$Core$Nil), ($sd0$Prelude$tyVar)("b")), ($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("b")),
  usr: ($sd0$Prelude$coreUsr)("sendLeft"),
});

const $sd0$Prelude$sendRight = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Pipe,
  symbol: ">>",
  type: ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyFn)(($core$Core$Cons)(($sd0$Prelude$tyVar)("a"), $core$Core$Nil), ($sd0$Prelude$tyVar)("b")), ($sd0$Prelude$tyVar)("b")),
  usr: ($sd0$Prelude$coreUsr)("sendRight"),
});

const $sd0$Prelude$subtract = ({
  associativity: $sd0$Types$Op$Left,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Addittive,
  symbol: "-",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$numberUsr)("subtract"),
});

const $sd0$Compiler$CoreTypes$textDef = ({
  constructors: $core$Dict$empty,
  directTypeDeps: $core$Set$empty,
  pars: $core$Core$Nil,
  usr: ($sd0$Compiler$CoreTypes$makeUsr)("Text"),
});

const $sd0$Compiler$CoreTypes$text = ($sd0$Compiler$CoreTypes$defToType)($sd0$Compiler$CoreTypes$textDef, $core$Core$Nil);

const $sd0$Prelude$textUsr = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "Text"), $1);
});

const $sd0$Prelude$textConcat = ({
  associativity: $sd0$Types$Op$Right,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Addittive,
  symbol: "..",
  type: ($sd0$Prelude$typeBinopUnique)($sd0$Compiler$CoreTypes$text),
  usr: ($sd0$Prelude$textUsr)("concat"),
});

const $sd0$Prelude$tupleUsr = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "Tuple"), $1);
});

const $sd0$Prelude$tuple = ({
  associativity: $sd0$Types$Op$NonAssociative,
  nonFn: $core$Core$Nil,
  precedence: $sd0$Types$Op$Tuple,
  symbol: "&",
  type: ((($2) => {
    return ($sd0$Prelude$typeBinop)(($sd0$Prelude$tyVar)("a"), ($sd0$Prelude$tyVar)("b"), $2);
  }))(((($1) => {
    return ($sd0$Types$CanonicalAst$TypeRecord)($sd0$Types$Pos$N, $1);
  }))(((($2) => {
    return ($core$Dict$insert)("second", ($sd0$Prelude$tyVar)("b"), $2);
  }))(((($2) => {
    return ($core$Dict$insert)("first", ($sd0$Prelude$tyVar)("a"), $2);
  }))($core$Dict$empty)))),
  usr: ($sd0$Prelude$tupleUsr)(""),
});

const $sd0$Prelude$binops = ($core$Core$Cons)($sd0$Prelude$and_, ($core$Core$Cons)($sd0$Prelude$or_, ($core$Core$Cons)($sd0$Prelude$textConcat, ($core$Core$Cons)($sd0$Prelude$listCons, ($core$Core$Cons)($sd0$Prelude$tuple, ($core$Core$Cons)($sd0$Prelude$add, ($core$Core$Cons)($sd0$Prelude$subtract, ($core$Core$Cons)($sd0$Prelude$multiply, ($core$Core$Cons)($sd0$Prelude$divide, ($core$Core$Cons)($sd0$Prelude$mutableAssign, ($core$Core$Cons)($sd0$Prelude$mutableAdd, ($core$Core$Cons)($sd0$Prelude$mutableSubtract, ($core$Core$Cons)($sd0$Prelude$equal, ($core$Core$Cons)($sd0$Prelude$notEqual, ($core$Core$Cons)($sd0$Prelude$lesserThan, ($core$Core$Cons)($sd0$Prelude$greaterThan, ($core$Core$Cons)($sd0$Prelude$lesserOrEqualThan, ($core$Core$Cons)($sd0$Prelude$greaterOrEqualThan, ($core$Core$Cons)($sd0$Prelude$sendRight, ($core$Core$Cons)($sd0$Prelude$sendLeft, $core$Core$Nil))))))))))))))))))));

const $sd0$Prelude$binopsBySymbol = ($core$List$for)($core$Dict$empty, $sd0$Prelude$binops, (($bop, $d) => {
  return ($core$Dict$insert)($bop.symbol, $bop, $d);
}));

const $sd0$Compiler$Lexer$addSquiggleToken = (($buffer, $nextIsSpace, $state) => {
  const $$chunk = ((__re__ = ($sd0$Compiler$Lexer$getChunk)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $chunk = $$chunk.third;
  const $end = $$chunk.second;
  const $start = $$chunk.first;
  const $add = (($2) => {
    return ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, $2, $state)), ($state = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((":" === $chunk)
      ? ($add)($sd0$Types$Token$Colon)
      : (("=" === $chunk)
        ? ($add)($sd0$Types$Token$Defop)
        : (("?" === $chunk)
          ? ($add)($sd0$Types$Token$UniquenessPolymorphismBinop)
          : (("!" === $chunk)
            ? ($add)(($sd0$Types$Token$Unop)($sd0$Types$Op$UnopUnique))
            : (("@" === $chunk)
              ? ($add)(($sd0$Types$Token$Unop)($sd0$Types$Op$UnopRecycle))
              : (("-" === $chunk)
                ? ($add)(($nextIsSpace
                  ? ($sd0$Types$Token$Binop)($sd0$Prelude$subtract)
                  : ($sd0$Types$Token$Unop)($sd0$Types$Op$UnopMinus)))
                : (("+" === $chunk)
                  ? ($add)(($nextIsSpace
                    ? ($sd0$Types$Token$Binop)($sd0$Prelude$add)
                    : ($sd0$Types$Token$Unop)($sd0$Types$Op$UnopPlus)))
                  : (true
                    ? ((() => {
                      const $op = $chunk;
                      const $$try1 = ($core$Dict$get)($chunk, $sd0$Prelude$binopsBySymbol);
                      return ((($$try1)[0] === "Just")
                        ? ((() => {
                          const $binop = ($$try1)[1];
                          return ($add)(($sd0$Types$Token$Binop)($binop));
                        }))()
                        : ((($$try1)[0] === "Nothing")
                          ? ((__re__ = ($sd0$Compiler$Lexer$addError)(("Invalid operator: `" + ($chunk + "`")), $state)), ($state = (__re__)[1]), (__re__)[0])
                          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 482:12', (sp_toHuman)($$try1))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 473:4', (sp_toHuman)($chunk)))))))))),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$startsWithUpperChar = ((() => {
  const $re = (text_startsWithRegex)("[A-Z]");
  return (($s) => {
    const $$try1 = ($re)($s);
    return (("" === $$try1)
      ? false
      : (true
        ? true
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 282:4', (sp_toHuman)($$try1))));
  });
}))();

const $sd0$Compiler$Lexer$addLowerOrUpperWord = (($start, $end, $modifier, $chunk, $state) => {
  const $upperName = (($maybeModule, $name) => {
    return ((($modifier)[0] === "NameNoModifier")
      ? ((() => {
        const $word = ({
          attrPath: $core$Core$Nil,
          isUpper: true,
          maybeModule: $maybeModule,
          modifier: $modifier,
          name: $name,
        });
        return ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, ($sd0$Types$Token$Word)($word), $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($modifier)[0] === "NameStartsWithDot")
        ? ((__re__ = ($sd0$Compiler$Lexer$addError)("Types or constructors can't start with `.` and attribute names can't start with an uppercase letter. =|", $state)), ($state = (__re__)[1]), (__re__)[0])
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 292:8', (sp_toHuman)($modifier))));
  });
  const $lowerName = (($maybeModule, $name, $attrs) => {
    return (($core$List$any)($sd0$Compiler$Lexer$startsWithUpperChar, $attrs)
      ? ((__re__ = ($sd0$Compiler$Lexer$addError)("attribute names must start with a lowercase letter", $state)), ($state = (__re__)[1]), (__re__)[0])
      : (((sp_not_equal)($maybeModule, $core$Maybe$Nothing) && (sp_not_equal)($modifier, $sd0$Types$Token$NameNoModifier))
        ? ((__re__ = ($sd0$Compiler$Lexer$addError)("can't use . or @ modifier on an imported value", $state)), ($state = (__re__)[1]), (__re__)[0])
        : ((() => {
          const $word = ({
            attrPath: $attrs,
            isUpper: false,
            maybeModule: $maybeModule,
            modifier: $modifier,
            name: $name,
          });
          return ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, ($sd0$Types$Token$Word)($word), $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()));
  });
  const $snips = (text_split)(".", $chunk);
  return ([
    (($core$List$any)((($s) => {
      return (sp_equal)($s, "");
    }), $snips)
      ? ((__re__ = ($sd0$Compiler$Lexer$addError)("use spaces around `..` to concatenate Text", $state)), ($state = (__re__)[1]), (__re__)[0])
      : ((($snips)[0] === "Nil")
        ? (sp_todo)("should not happen")
        : (((($snips)[0] === "Cons") && ((($snips)[2])[0] === "Nil"))
          ? ((() => {
            const $one = ($snips)[1];
            return (($sd0$Compiler$Lexer$startsWithUpperChar)($one)
              ? ($upperName)($core$Maybe$Nothing, $one)
              : ($lowerName)($core$Maybe$Nothing, $one, $core$Core$Nil));
          }))()
          : (((($snips)[0] === "Cons") && ((($snips)[2])[0] === "Cons"))
            ? ((() => {
              const $first = ($snips)[1];
              const $second = (($snips)[2])[1];
              const $more = (($snips)[2])[2];
              const $$try1 = ({
                first: ($sd0$Compiler$Lexer$startsWithUpperChar)($first),
                second: ($sd0$Compiler$Lexer$startsWithUpperChar)($second),
              });
              return ((!($$try1.first) && !($$try1.second))
                ? ($lowerName)($core$Maybe$Nothing, $first, (sp_cons)($second, $more))
                : (($$try1.first && !($$try1.second))
                  ? ($lowerName)(($core$Maybe$Just)($first), $second, $more)
                  : (($$try1.first && $$try1.second)
                    ? ((sp_not_equal)($more, $core$Core$Nil)
                      ? ((__re__ = ($sd0$Compiler$Lexer$addError)("Types and constructors can't have .attributes", $state)), ($state = (__re__)[1]), (__re__)[0])
                      : ($upperName)(($core$Maybe$Just)($first), $second))
                    : ((!($$try1.first) && $$try1.second)
                      ? ((__re__ = ($sd0$Compiler$Lexer$addError)("Something wrong with uppercases?", $state)), ($state = (__re__)[1]), (__re__)[0])
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 354:12', (sp_toHuman)($$try1))))));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 335:6', (sp_toHuman)($snips)))))),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$addWordToken = (($buffer, $modifier, $state) => {
  const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
  const $end = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  const $ds = ((sp_equal)($modifier, $sd0$Types$Token$NameNoModifier)
    ? 0
    : 1);
  const $chunk = (text_slice)(($start + $ds), $end, $buffer);
  const $maybeKeywordKind = (("fn" === $chunk)
    ? ($core$Maybe$Just)($sd0$Types$Token$Fn)
    : (("if" === $chunk)
      ? ($core$Maybe$Just)($sd0$Types$Token$If)
      : (("then" === $chunk)
        ? ($core$Maybe$Just)($sd0$Types$Token$Then)
        : (("else" === $chunk)
          ? ($core$Maybe$Just)($sd0$Types$Token$Else)
          : (("try" === $chunk)
            ? ($core$Maybe$Just)($sd0$Types$Token$Try)
            : (("as" === $chunk)
              ? ($core$Maybe$Just)($sd0$Types$Token$As)
              : (("with" === $chunk)
                ? ($core$Maybe$Just)($sd0$Types$Token$With)
                : (("and" === $chunk)
                  ? ($core$Maybe$Just)(($sd0$Types$Token$Binop)($sd0$Prelude$and_))
                  : (("or" === $chunk)
                    ? ($core$Maybe$Just)(($sd0$Types$Token$Binop)($sd0$Prelude$or_))
                    : (("__" === $chunk)
                      ? ($core$Maybe$Just)($sd0$Types$Token$ArgumentPlaceholder)
                      : (true
                        ? $core$Maybe$Nothing
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 391:8', (sp_toHuman)($chunk)))))))))))));
  const $$try1 = ({
    first: $maybeKeywordKind,
    second: $modifier,
  });
  return ([
    (((($$try1.first)[0] === "Just") && (($$try1.second)[0] === "NameNoModifier"))
      ? ((() => {
        const $kind = ($$try1.first)[1];
        return ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, $kind, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($$try1.first)[0] === "Just")
        ? ((() => {
          const $kind = ($$try1.first)[1];
          return ((__re__ = ($sd0$Compiler$Lexer$addError)(($chunk + " as a keyword, you can't really use it this way"), $state)), ($state = (__re__)[1]), (__re__)[0]);
        }))()
        : (true
          ? ((__re__ = ($sd0$Compiler$Lexer$addLowerOrUpperWord)($start, $end, $modifier, $chunk, $state)), ($state = (__re__)[1]), (__re__)[0])
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 404:4', (sp_toHuman)($$try1))))),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$isNumber = ((() => {
  const $re = (text_startsWithRegex)("[0-9_.]");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const $sd0$Compiler$Lexer$isSquiggle = (($char) => {
  return (("=" === $char)
    ? true
    : ((":" === $char)
      ? true
      : (("*" === $char)
        ? true
        : (("+" === $char)
          ? true
          : (("-" === $char)
            ? true
            : (("/" === $char)
              ? true
              : ((">" === $char)
                ? true
                : (("<" === $char)
                  ? true
                  : (("!" === $char)
                    ? true
                    : (("?" === $char)
                      ? true
                      : (("&" === $char)
                        ? true
                        : (("^" === $char)
                          ? true
                          : (("@" === $char)
                            ? true
                            : (("$" === $char)
                              ? true
                              : (true
                                ? false
                                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 446:4', (sp_toHuman)($char)))))))))))))))));
});

const $sd0$Compiler$Lexer$isWordBody = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z./_0-9]");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const $sd0$Compiler$Lexer$isWordStart = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z._]");
  return (($char) => {
    return (sp_not_equal)(($re)($char), "");
  });
}))();

const $sd0$Compiler$Lexer$setMode = (($mode, $state) => {
  return ([
    ($state.mode = (basics_cloneImm)($mode)),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$tryIndent = (($buffer, $indentChar, $char, $state) => {
  return ([
    (((sp_equal)($char, $indentChar) || (sp_equal)($char, ""))
      ? null
      : (((sp_equal)($char, " ") || (sp_equal)($char, "\t"))
        ? ((__re__ = ($sd0$Compiler$Lexer$addError)("mixing tabs and spaces!", $state)), ($state = (__re__)[1]), (__re__)[0])
        : ((sp_equal)($char, "\n")
          ? ((() => {
            ($state.tokenStart = (((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1));
            return ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Indent, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : ((sp_equal)($char, "#")
            ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$LineComment, $state)), ($state = (__re__)[1]), (__re__)[0])
            : ((() => {
              ($state.lineIndent = ((__re__ = (basics_cloneUni)($state.column)), ($state.column = (__re__)[1]), (__re__)[0]));
              ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))())))),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$unindent = (($raw) => {
  return (($core$Basics$not)((text_startsWith)("\n", $raw))
    ? $raw
    : ((() => {
      const $multilineText = (text_dropLeft)(1, $raw);
      const $lines = (text_split)("\n", $multilineText);
      const $countLeadingSpaces = ((() => {
        const $re = (text_startsWithRegex)("[ ]*");
        return (($line) => {
          return (text_length)(($re)($line));
        });
      }))();
      const $minLead = ((($1) => {
        return ($core$Maybe$withDefault)(0, $1);
      }))(($core$List$minimum)(((($1) => {
        return ($core$List$map)($countLeadingSpaces, $1);
      }))(((($1) => {
        return ($core$List$filter)((($s) => {
          return (sp_not_equal)((text_trimLeft)($s), "");
        }), $1);
      }))($lines))));
      return ((($1) => {
        return ((text_replaceRegex)("\n[ ]*$"))("", $1);
      }))(((($1) => {
        return ($core$Text$join)("\n", $1);
      }))(((($1) => {
        return ($core$List$map)((($1) => {
          return (text_dropLeft)($minLead, $1);
        }), $1);
      }))($lines)));
    }))());
});

const $sd0$Compiler$Lexer$lexOne = (($buffer, $char, $state) => {
  const $pos = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  let $$try1 = ((__re__ = (basics_cloneUni)($state.mode)), ($state.mode = (__re__)[1]), (__re__)[0]);
  return ([
    ((($$try1)[0] === "Indent")
      ? ((() => {
        let $$try3 = ((__re__ = (basics_cloneUni)($state.tabsOrSpaces)), ($state.tabsOrSpaces = (__re__)[1]), (__re__)[0]);
        return ((($$try3)[0] === "Tabs")
          ? ((__re__ = ($sd0$Compiler$Lexer$tryIndent)($buffer, "\t", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
          : ((($$try3)[0] === "Spaces")
            ? ((__re__ = ($sd0$Compiler$Lexer$tryIndent)($buffer, " ", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
            : ((($$try3)[0] === "NoTabsOrSpacesYet")
              ? ((" " === $char)
                ? ((() => {
                  ($state.tabsOrSpaces = $sd0$Compiler$Lexer$Spaces);
                  return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (("\t" === $char)
                  ? ((() => {
                    ($state.tabsOrSpaces = $sd0$Compiler$Lexer$Tabs);
                    return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = ($sd0$Compiler$Lexer$tryIndent)($buffer, " ", $char, $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 534:14', (sp_toHuman)($char)))))
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 526:10', (sp_toHuman)($$try3)))));
      }))()
      : ((($$try1)[0] === "Default")
        ? (("" === $char)
          ? null
          : (("." === $char)
            ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Dot_One, $state)), ($state = (__re__)[1]), (__re__)[0])
            : (("#" === $char)
              ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$LineComment, $state)), ($state = (__re__)[1]), (__re__)[0])
              : (("[" === $char)
                ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$ContentOpeningBlockComment, $state)), ($state = (__re__)[1]), (__re__)[0])
                : (("\"" === $char)
                  ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$ContentOpeningQuotes_One, $state)), ($state = (__re__)[1]), (__re__)[0])
                  : (("\n" === $char)
                    ? ((() => {
                      ($state.tokenStart = (((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1));
                      ($state.soFarThereAreNoTokensInThisLine = true);
                      return ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Indent, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : ((" " === $char)
                      ? ($state.tokenStart = (((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) + 1))
                      : (true
                        ? ((() => {
                          ($state.tokenStart = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]));
                          return (($sd0$Compiler$Lexer$isWordStart)($char)
                            ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$Word)($sd0$Types$Token$NameNoModifier), $state)), ($state = (__re__)[1]), (__re__)[0])
                            : (($sd0$Compiler$Lexer$isNumber)($char)
                              ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$NumberLiteral, $state)), ($state = (__re__)[1]), (__re__)[0])
                              : (($sd0$Compiler$Lexer$isSquiggle)($char)
                                ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Squiggles, $state)), ($state = (__re__)[1]), (__re__)[0])
                                : ((__re__ = ($sd0$Compiler$Lexer$addParenOrCommaToken)($char, $state)), ($state = (__re__)[1]), (__re__)[0]))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 545:10', (sp_toHuman)($char))))))))))
        : ((($$try1)[0] === "Dot_One")
          ? ((sp_equal)($char, ".")
            ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Dot_Two, $state)), ($state = (__re__)[1]), (__re__)[0])
            : (($sd0$Compiler$Lexer$isWordStart)($char)
              ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$Word)($sd0$Types$Token$NameStartsWithDot), $state)), ($state = (__re__)[1]), (__re__)[0])
              : (($sd0$Compiler$Lexer$isNumber)($char)
                ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$NumberLiteral, $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((__re__ = ($sd0$Compiler$Lexer$addError)("no idea what this is", $state)), ($state = (__re__)[1]), (__re__)[0]))))
          : ((($$try1)[0] === "Dot_Two")
            ? ((sp_equal)($char, ".")
              ? ((() => {
                ((__re__ = ($sd0$Compiler$Lexer$relAddToken)((0 - 1), 1, $sd0$Types$Token$ThreeDots, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((() => {
                ((__re__ = ($sd0$Compiler$Lexer$relAddToken)((0 - 1), 1, ($sd0$Types$Token$Binop)($sd0$Prelude$textConcat), $state)), ($state = (__re__)[1]), (__re__)[0]);
                ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))())
            : ((($$try1)[0] === "Mutable")
              ? (($sd0$Compiler$Lexer$isSquiggle)($char)
                ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Squiggles, $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((__re__ = ($sd0$Compiler$Lexer$addError)("no idea what this is", $state)), ($state = (__re__)[1]), (__re__)[0]))
              : ((($$try1)[0] === "Word")
                ? ((() => {
                  const $modifier = ($$try1)[1];
                  return (($sd0$Compiler$Lexer$isWordBody)($char)
                    ? null
                    : ((() => {
                      ((__re__ = ($sd0$Compiler$Lexer$addWordToken)($buffer, $modifier, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))());
                }))()
                : ((($$try1)[0] === "NumberLiteral")
                  ? (($sd0$Compiler$Lexer$isNumber)($char)
                    ? null
                    : ((() => {
                      ((__re__ = ($sd0$Compiler$Lexer$addNumberToken)($buffer, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))())
                  : ((($$try1)[0] === "Squiggles")
                    ? (($sd0$Compiler$Lexer$isSquiggle)($char)
                      ? null
                      : ((() => {
                        ((__re__ = ($sd0$Compiler$Lexer$addSquiggleToken)($buffer, (sp_equal)($char, " "), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))())
                    : ((($$try1)[0] === "ContentOpeningQuotes_One")
                      ? ((sp_equal)($char, "\"")
                        ? ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$ContentOpeningQuotes_Two, $state)), ($state = (__re__)[1]), (__re__)[0])
                        : ((sp_equal)($char, "")
                          ? ((__re__ = ($sd0$Compiler$Lexer$addError)("there's no closing quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                          : ((() => {
                            ($state.tokenStart = (((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 1));
                            ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$SingleQuote)(({
                              lastEscape: -(1),
                            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()))
                      : ((($$try1)[0] === "ContentOpeningQuotes_Two")
                        ? ((sp_equal)($char, "\"")
                          ? ((() => {
                            ($state.tokenStart = (((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]) - 2));
                            return ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$TripleQuote)(({
                              closingQuotes: 0,
                              lastEscape: -(1),
                            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : ((() => {
                            ((__re__ = ($sd0$Compiler$Lexer$relAddToken)((0 - 2), 0, ($sd0$Types$Token$TextLiteral)(""), $state)), ($state = (__re__)[1]), (__re__)[0]);
                            ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))())
                        : ((($$try1)[0] === "SingleQuote")
                          ? ((() => {
                            const $lastEscape = ($$try1)[1].lastEscape;
                            const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                            return ((sp_equal)($char, "")
                              ? ((__re__ = ($sd0$Compiler$Lexer$addError)("there's no closing quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                              : ($previousIsEscape
                                ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$SingleQuote)(({
                                  lastEscape: $lastEscape,
                                })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                : (("\"" === $char)
                                  ? ((() => {
                                    const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
                                    const $end = ($pos + 1);
                                    const $value = ((($2) => {
                                      return ($core$Text$replace)("\\\"", "\"", $2);
                                    }))(((($2) => {
                                      return (text_slice)(($start + 1), ($end - 1), $2);
                                    }))($buffer));
                                    ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, ($sd0$Types$Token$TextLiteral)($value), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))()
                                  : (("\\" === $char)
                                    ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$SingleQuote)(({
                                      lastEscape: $pos,
                                    })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                    : (true
                                      ? null
                                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 677:12', (sp_toHuman)($char)))))));
                          }))()
                          : ((($$try1)[0] === "TripleQuote")
                            ? ((() => {
                              const $closingQuotes = ($$try1)[1].closingQuotes;
                              const $lastEscape = ($$try1)[1].lastEscape;
                              const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                              return ((sp_equal)($char, "")
                                ? ((__re__ = ($sd0$Compiler$Lexer$addError)("unterminated triple quotes", $state)), ($state = (__re__)[1]), (__re__)[0])
                                : ($previousIsEscape
                                  ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$TripleQuote)(({
                                    closingQuotes: 0,
                                    lastEscape: $lastEscape,
                                  })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                  : (("\"" === $char)
                                    ? ((sp_equal)($closingQuotes, 2)
                                      ? ((() => {
                                        const $start = ((__re__ = (basics_cloneUni)($state.tokenStart)), ($state.tokenStart = (__re__)[1]), (__re__)[0]);
                                        const $end = ($pos + 1);
                                        const $value = ($sd0$Compiler$Lexer$unindent)(((($2) => {
                                          return (text_slice)(($start + 3), ($end - 3), $2);
                                        }))($buffer));
                                        ((__re__ = ($sd0$Compiler$Lexer$absAddToken)($start, $end, ($sd0$Types$Token$TextLiteral)($value), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                        return ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                      }))()
                                      : ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$TripleQuote)(({
                                        closingQuotes: ($closingQuotes + 1),
                                        lastEscape: $lastEscape,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0]))
                                    : (("\\" === $char)
                                      ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$TripleQuote)(({
                                        closingQuotes: 0,
                                        lastEscape: $pos,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                      : (true
                                        ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$TripleQuote)(({
                                          closingQuotes: 0,
                                          lastEscape: $lastEscape,
                                        })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 717:13', (sp_toHuman)($char)))))));
                            }))()
                            : ((($$try1)[0] === "LineComment")
                              ? (((sp_equal)($char, "\n") || (sp_equal)($char, ""))
                                ? ((() => {
                                  ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                }))()
                                : null)
                              : ((($$try1)[0] === "ContentOpeningBlockComment")
                                ? ((sp_equal)($char, "#")
                                  ? ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$BlockComment)(({
                                    nesting: 1,
                                    previous: "",
                                  })), $state)), ($state = (__re__)[1]), (__re__)[0])
                                  : ((() => {
                                    ((__re__ = ($sd0$Compiler$Lexer$relAddToken)((0 - 1), 0, ($sd0$Types$Token$SquareBracket)($sd0$Types$Token$Open), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ((__re__ = ($sd0$Compiler$Lexer$lexOne)($buffer, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                  }))())
                                : ((($$try1)[0] === "BlockComment")
                                  ? ((() => {
                                    const $nesting = ($$try1)[1].nesting;
                                    const $previous = ($$try1)[1].previous;
                                    const $continueWithDeltaNesting = (($dn) => {
                                      return ((__re__ = ($sd0$Compiler$Lexer$setMode)(($sd0$Compiler$Lexer$BlockComment)(({
                                        nesting: ($nesting + $dn),
                                        previous: $char,
                                      })), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    });
                                    const $$try2 = ({
                                      first: $previous,
                                      second: $char,
                                    });
                                    return ((("[" === $$try2.first) && ("#" === $$try2.second))
                                      ? ($continueWithDeltaNesting)(1)
                                      : ((("#" === $$try2.first) && ("]" === $$try2.second))
                                        ? (($nesting > 1)
                                          ? ($continueWithDeltaNesting)((0 - 1))
                                          : ((__re__ = ($sd0$Compiler$Lexer$setMode)($sd0$Compiler$Lexer$Default, $state)), ($state = (__re__)[1]), (__re__)[0]))
                                        : (("" === $$try2.second)
                                          ? ((__re__ = ($sd0$Compiler$Lexer$addError)("unterminated block comment", $state)), ($state = (__re__)[1]), (__re__)[0])
                                          : (true
                                            ? ($continueWithDeltaNesting)(0)
                                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 763:10', (sp_toHuman)($$try2))))));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 523:4', (sp_toHuman)($$try1))))))))))))))))),
    $state,
  ]);
});

const $sd0$Compiler$Lexer$readStateInit = (($moduleCode) => {
  return ({
    column: 0,
    errors: (array_fromList)($core$Core$Nil),
    indentStack: (array_fromList)($core$Core$Nil),
    indentStartsABlock: true,
    line: 0,
    lineIndent: 0,
    mode: $sd0$Compiler$Lexer$Indent,
    nextPos: 0,
    sections: (array_fromList)($core$Core$Nil),
    soFarThereAreNoTokensInThisLine: true,
    tabsOrSpaces: $sd0$Compiler$Lexer$NoTabsOrSpacesYet,
    tokenStart: 0,
    tokens: (array_fromList)($core$Core$Nil),
  });
});

const $sd0$Compiler$Lexer$lexer = (($moduleName, $moduleCode) => {
  (sp_benchStart)(null);
  let $state = ($sd0$Compiler$Lexer$readStateInit)($moduleCode);
  (text_forEach)($moduleCode, (($char) => {
    ((__re__ = ($sd0$Compiler$Lexer$lexOne)($moduleCode, $char, $state)), ($state = (__re__)[1]), (__re__)[0]);
    ($state.nextPos += 1);
    return ((sp_equal)($char, "\n")
      ? ((() => {
        ($state.line += 1);
        return ($state.column = 0);
      }))()
      : ($state.column += 1));
  }));
  ((__re__ = ($sd0$Compiler$Lexer$lexOne)($moduleCode, "", $state)), ($state = (__re__)[1]), (__re__)[0]);
  (sp_benchStop)("lexer");
  const $$try1 = ((__re__ = (array_toList)($state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ((($$try1)[0] === "Nil")
    ? ((() => {
      ((__re__ = ($sd0$Compiler$Lexer$closeOpenBlocks)($state)), ($state = (__re__)[1]), (__re__)[0]);
      return ($core$Result$Ok)(((__re__ = (array_toList)($state.sections)), ($state.sections = (__re__)[1]), (__re__)[0]));
    }))()
    : (true
      ? ((() => {
        const $errors = $$try1;
        return ($core$Result$Err)(($sd0$Compiler$Error$Nested)(((($1) => {
          return ($core$List$map)((($e) => {
            return ($e)($moduleName);
          }), $1);
        }))($errors)));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Lexer.sp 839:4', (sp_toHuman)($$try1))));
});

const $sd0$Compiler$Error$res = (($pos, $desc) => {
  return ($core$Result$Err)(($sd0$Compiler$Error$Simple)($pos, $desc));
});

const $sd0$Compiler$Parser$makeError = (($moduleName, $readState, $message) => {
  const $p = ((($readState)[0] === "Nil")
    ? ($sd0$Types$Pos$P)($moduleName, 0, 1)
    : (((($readState)[0] === "Cons") && ((($readState)[1])[0] === "Token"))
      ? ((() => {
        const $comment = (($readState)[1])[1];
        const $start = (($readState)[1])[2];
        const $end = (($readState)[1])[3];
        const $k = (($readState)[1])[4];
        const $rest = ($readState)[2];
        return ($sd0$Types$Pos$P)($moduleName, $start, $end);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 667:8', (sp_toHuman)($readState))));
  return ($sd0$Compiler$Error$res)($p, (($eenv) => {
    return ($core$Core$Cons)($message, $core$Core$Nil);
  }));
});

const $sd0$SPLib$Parser$accept = (($a) => {
  return (($rejections, $readState) => {
    return ({
      first: $rejections,
      second: ($sd0$SPLib$Parser$Accepted)($readState, $a),
    });
  });
});

const $sd0$Compiler$Parser$ok = $sd0$SPLib$Parser$accept;

const $sd0$SPLib$Parser$andThen = (($chainedParser) => {
  return (($firstParser) => {
    return (($re0, $readState) => {
      const $$try1 = ($firstParser)($re0, $readState);
      return ((($$try1.second)[0] === "Accepted")
        ? ((() => {
          const $re1 = $$try1.first;
          const $nextReadState = ($$try1.second)[1];
          const $a = ($$try1.second)[2];
          return (($chainedParser)($a))($re1, $nextReadState);
        }))()
        : ((($$try1.second)[0] === "Rejected")
          ? ((() => {
            const $re1 = $$try1.first;
            return ({
              first: $re1,
              second: $sd0$SPLib$Parser$Rejected,
            });
          }))()
          : ((($$try1.second)[0] === "Aborted")
            ? ((() => {
              const $re1 = $$try1.first;
              const $rs = ($$try1.second)[1];
              const $e = ($$try1.second)[2];
              return ({
                first: $re1,
                second: ($sd0$SPLib$Parser$Aborted)($rs, $e),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPLib/Parser.sp 86:4', (sp_toHuman)($$try1)))));
    });
  });
});

const $sd0$Compiler$Parser$on = $sd0$SPLib$Parser$andThen;

const $sd0$SPLib$Parser$consumeOne = (($rejections, $readState) => {
  return ((($readState)[0] === "Nil")
    ? ({
      first: (sp_cons)($readState, $rejections),
      second: $sd0$SPLib$Parser$Rejected,
    })
    : ((($readState)[0] === "Cons")
      ? ((() => {
        const $token = ($readState)[1];
        const $nextState = ($readState)[2];
        return ({
          first: $rejections,
          second: ($sd0$SPLib$Parser$Accepted)($nextState, $token),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPLib/Parser.sp 69:4', (sp_toHuman)($readState))));
});

const $sd0$Compiler$Parser$oneToken = $sd0$SPLib$Parser$consumeOne;

const $sd0$SPLib$Parser$reject = (($rejections, $readState) => {
  return ({
    first: (sp_cons)($readState, $rejections),
    second: $sd0$SPLib$Parser$Rejected,
  });
});

const $sd0$Compiler$Parser$kind = (($targetKind) => {
  return (($sd0$Compiler$Parser$on)((($token) => {
    const $$k = $token;
    const $k = ($$k)[4];
    return ((sp_equal)($targetKind, $k)
      ? ($sd0$Compiler$Parser$ok)($token)
      : $sd0$SPLib$Parser$reject);
  })))($sd0$Compiler$Parser$oneToken);
});

const $sd0$Compiler$Parser$binaryOperators = (($group) => {
  return (($sd0$Compiler$Parser$on)((($$c) => {
    const $c = ($$c)[1];
    const $s = ($$c)[2];
    const $e = ($$c)[3];
    const $k = ($$c)[4];
    return ((($k)[0] === "Binop")
      ? ((() => {
        const $op = ($k)[1];
        return ((sp_equal)($op.precedence, $group)
          ? ($sd0$Compiler$Parser$ok)($op)
          : $sd0$SPLib$Parser$reject);
      }))()
      : (true
        ? $sd0$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 627:4', (sp_toHuman)($k))));
  })))($sd0$Compiler$Parser$oneToken);
});

const $sd0$SPLib$Parser$here = (($rejections, $readState) => {
  return ({
    first: $rejections,
    second: ($sd0$SPLib$Parser$Accepted)($readState, $readState),
  });
});

const $sd0$Compiler$Parser$here = (($sd0$Compiler$Parser$on)((($tokens) => {
  return ($sd0$Compiler$Parser$ok)((((($tokens)[0] === "Cons") && ((($tokens)[1])[0] === "Token"))
    ? ((() => {
      const $c = (($tokens)[1])[1];
      const $mod = (($tokens)[1])[2];
      const $start = (($tokens)[1])[3];
      const $end = (($tokens)[1])[4];
      const $rest = ($tokens)[2];
      return $start;
    }))()
    : ((($tokens)[0] === "Nil")
      ? 0
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 35:8', (sp_toHuman)($tokens)))));
})))($sd0$SPLib$Parser$here);

const $sd0$Compiler$Parser$pos = (($env, $start, $end) => {
  return ($env.stripLocations
    ? $sd0$Types$Pos$T
    : ($sd0$Types$Pos$P)($env.moduleName, $start, $end));
});

const $sd0$SPLib$Parser$surroundWith = (($left, $right, $parser) => {
  return (($sd0$SPLib$Parser$andThen)(((_0) => {
    return (($sd0$SPLib$Parser$andThen)((($p) => {
      return (($sd0$SPLib$Parser$andThen)(((_0) => {
        return ($sd0$SPLib$Parser$accept)($p);
      })))($right);
    })))($parser);
  })))($left);
});

const $sd0$Compiler$Parser$surroundStrict = (($left, $right, $p) => {
  return ($sd0$SPLib$Parser$surroundWith)(($sd0$Compiler$Parser$kind)($left), ($sd0$Compiler$Parser$kind)($right), $p);
});

const $sd0$Compiler$Parser$block = (($2) => {
  return ($sd0$Compiler$Parser$surroundStrict)($sd0$Types$Token$BlockStart, $sd0$Types$Token$BlockEnd, $2);
});

const $sd0$Compiler$Parser$discardFirst = (($a, $b) => {
  return (($sd0$Compiler$Parser$on)(((_0) => {
    return $b;
  })))($a);
});

const $sd0$Compiler$Parser$sib = (($1) => {
  return ($sd0$Compiler$Parser$discardFirst)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine), $1);
});

const $sd0$SPLib$Parser$oneOf = (($ps) => {
  return (($rejections, $readState) => {
    return ((($ps)[0] === "Nil")
      ? ({
        first: $rejections,
        second: $sd0$SPLib$Parser$Rejected,
      })
      : ((($ps)[0] === "Cons")
        ? ((() => {
          const $headParser = ($ps)[1];
          const $tailParsers = ($ps)[2];
          const $$try1 = ($headParser)($rejections, $readState);
          return ((($$try1.second)[0] === "Rejected")
            ? ((() => {
              const $re1 = $$try1.first;
              return (($sd0$SPLib$Parser$oneOf)($tailParsers))($re1, $readState);
            }))()
            : (true
              ? ((() => {
                const $acceptedOrAborted = $$try1;
                return $acceptedOrAborted;
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPLib/Parser.sp 150:12', (sp_toHuman)($$try1))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPLib/Parser.sp 145:4', (sp_toHuman)($ps))));
  });
});

const $sd0$Compiler$Parser$sepListAtSep = (($sep, $item) => {
  return (($sd0$Compiler$Parser$on)((($sep0) => {
    const $theParserStillSucks = ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$block)(($sd0$Compiler$Parser$sepListAtItem)($sep, $item)), ($core$Core$Cons)(($sd0$Compiler$Parser$sib)(($sd0$Compiler$Parser$sepListAtItem)($sep, $item)), ($core$Core$Cons)(($sd0$Compiler$Parser$sepListAtItem)($sep, $item), $core$Core$Nil))));
    return (($sd0$Compiler$Parser$on)((($$item0) => {
      const $item0 = $$item0.first;
      const $tail = $$item0.second;
      return ($sd0$Compiler$Parser$ok)((sp_cons)(({
        first: $sep0,
        second: $item0,
      }), $tail));
    })))($theParserStillSucks);
  })))($sep);
});

const $sd0$Compiler$Parser$sepListAtItem = (($sep, $item) => {
  return (($sd0$Compiler$Parser$on)((($item0) => {
    const $theParserStillSucks = ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$block)(($sd0$Compiler$Parser$sepListAtSep)($sep, $item)), ($core$Core$Cons)(($sd0$Compiler$Parser$sib)(($sd0$Compiler$Parser$sepListAtSep)($sep, $item)), ($core$Core$Cons)(($sd0$Compiler$Parser$sepListAtSep)($sep, $item), ($core$Core$Cons)(($sd0$Compiler$Parser$ok)($core$Core$Nil), $core$Core$Nil)))));
    return (($sd0$Compiler$Parser$on)((($sepsAndItems) => {
      return ($sd0$Compiler$Parser$ok)(({
        first: $item0,
        second: $sepsAndItems,
      }));
    })))($theParserStillSucks);
  })))($item);
});

const $sd0$Compiler$Parser$sepList = $sd0$Compiler$Parser$sepListAtItem;

const $sd0$Compiler$Parser$binopsOr = (($env, $group) => {
  return (($higher) => {
    return (($sd0$Compiler$Parser$on)((($start) => {
      return (($sd0$Compiler$Parser$on)((($$head) => {
        const $head = $$head.first;
        const $sepTail = $$head.second;
        return (($sd0$Compiler$Parser$on)((($end) => {
          return ((sp_equal)($sepTail, $core$Core$Nil)
            ? ($sd0$Compiler$Parser$ok)($head)
            : ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Expression)(($sd0$Compiler$Parser$pos)($env, $start, $end), ($sd0$Types$FormattableAst$Binop)($group, ({
              first: $head,
              second: $sepTail,
            })))));
        })))($sd0$Compiler$Parser$here);
      })))(($sd0$Compiler$Parser$sepList)(($sd0$Compiler$Parser$binaryOperators)($group), $higher));
    })))($sd0$Compiler$Parser$here);
  });
});

const $sd0$SPLib$Parser$thenWithDefault = (($fallbackParser, $chainedParser) => {
  return (($firstParser) => {
    return (($re0, $readState) => {
      const $$try1 = ($firstParser)($re0, $readState);
      return ((($$try1.second)[0] === "Aborted")
        ? ((() => {
          const $re1 = $$try1.first;
          const $rs = ($$try1.second)[1];
          const $reason = ($$try1.second)[2];
          return ({
            first: $re1,
            second: ($sd0$SPLib$Parser$Aborted)($rs, $reason),
          });
        }))()
        : ((($$try1.second)[0] === "Rejected")
          ? ((() => {
            const $re1 = $$try1.first;
            return ($fallbackParser)($re1, $readState);
          }))()
          : ((($$try1.second)[0] === "Accepted")
            ? ((() => {
              const $re1 = $$try1.first;
              const $nextReadState = ($$try1.second)[1];
              const $a = ($$try1.second)[2];
              return (($chainedParser)($a))($re1, $nextReadState);
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPLib/Parser.sp 102:4', (sp_toHuman)($$try1)))));
    });
  });
});

const $sd0$SPLib$Parser$zeroOrMore = (($p) => {
  return (($sd0$SPLib$Parser$thenWithDefault)(($sd0$SPLib$Parser$accept)($core$Core$Nil), (($head) => {
    return (($sd0$SPLib$Parser$andThen)((($tail) => {
      return ($sd0$SPLib$Parser$accept)((sp_cons)($head, $tail));
    })))(($sd0$SPLib$Parser$zeroOrMore)($p));
  })))($p);
});

const $sd0$Compiler$Parser$oomSeparatedBy = (($sep, $pa) => {
  return (($sd0$Compiler$Parser$on)((($head) => {
    return (($sd0$Compiler$Parser$on)((($tail) => {
      return ($sd0$Compiler$Parser$ok)((sp_cons)($head, $tail));
    })))(($sd0$SPLib$Parser$zeroOrMore)(($sd0$Compiler$Parser$discardFirst)($sep, $pa)));
  })))($pa);
});

const $sd0$Compiler$Parser$siblingStatements = (($env) => {
  return (($sd0$Compiler$Parser$on)((($start) => {
    return (($sd0$Compiler$Parser$on)((($stats) => {
      return (($sd0$Compiler$Parser$on)((($end) => {
        return (((($stats)[0] === "Cons") && (((($stats)[1])[0] === "Evaluation") && ((($stats)[2])[0] === "Nil")))
          ? ((() => {
            const $expr = (($stats)[1])[1];
            return ($sd0$Compiler$Parser$ok)($expr);
          }))()
          : (true
            ? ((() => {
              const $many = $stats;
              return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Expression)(($sd0$Compiler$Parser$pos)($env, $start, $end), ($sd0$Types$FormattableAst$Statements)($stats)));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 243:2', (sp_toHuman)($stats))));
      })))($sd0$Compiler$Parser$here);
    })))(($sd0$Compiler$Parser$oomSeparatedBy)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine), ($sd0$Compiler$Parser$statement)($env)));
  })))($sd0$Compiler$Parser$here);
});

const $sd0$Compiler$Parser$alignedOrInlineStatements = (($env) => {
  return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$block)(($sd0$Compiler$Parser$siblingStatements)($env)), ($core$Core$Cons)(($sd0$Compiler$Parser$sib)(($sd0$Compiler$Parser$siblingStatements)($env)), ($core$Core$Cons)(($sd0$Compiler$Parser$expr)($env), $core$Core$Nil))));
});

const $sd0$Compiler$Parser$discardSecond = (($a, $b) => {
  return (($sd0$Compiler$Parser$on)((($aa) => {
    return (($sd0$Compiler$Parser$on)(((_0) => {
      return ($sd0$Compiler$Parser$ok)($aa);
    })))($b);
  })))($a);
});

const $sd0$Compiler$Parser$indentedOrInlineStatements = (($env) => {
  return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$block)(($sd0$Compiler$Parser$siblingStatements)($env)), ($core$Core$Cons)(($sd0$Compiler$Parser$expr)($env), $core$Core$Nil)));
});

const $sd0$Compiler$Parser$inlineOrBelowOrIndented = (($p) => {
  return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$block)($p), ($core$Core$Cons)(($sd0$Compiler$Parser$sib)($p), ($core$Core$Cons)($p, $core$Core$Nil))));
});

const $sd0$SPLib$Parser$maybe = (($p) => {
  return (($sd0$SPLib$Parser$thenWithDefault)(($sd0$SPLib$Parser$accept)($core$Maybe$Nothing), (($x) => {
    return ($sd0$SPLib$Parser$accept)(($core$Maybe$Just)($x));
  })))($p);
});

const $sd0$Compiler$Parser$maybe = $sd0$SPLib$Parser$maybe;

const $sd0$Compiler$Parser$maybeNewLine = (($1) => {
  return ($sd0$Compiler$Parser$discardFirst)(($sd0$SPLib$Parser$maybe)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine)), $1);
});

const $sd0$Compiler$Parser$rawList = (($item) => {
  const $sibsep = ($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Comma));
  return ($sd0$Compiler$Parser$discardFirst)(($sd0$SPLib$Parser$maybe)($sibsep), ($sd0$Compiler$Parser$oomSeparatedBy)($sibsep, $item));
});

const $sd0$Compiler$Parser$exprWithLeftDelimiter = (($env, $tokenKind) => {
  return ((($tokenKind)[0] === "Word")
    ? ((() => {
      const $word = ($tokenKind)[1];
      return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)((($sd0$Compiler$Parser$on)((($t) => {
        return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Variable)(({
          maybeType: ($core$Maybe$Just)($t),
          word: $word,
        })));
      })))(($sd0$Compiler$Parser$discardFirst)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$As), ($sd0$Compiler$Parser$expr)($env))), ($core$Core$Cons)(($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Variable)(({
        maybeType: $core$Maybe$Nothing,
        word: $word,
      }))), $core$Core$Nil)));
    }))()
    : ((($tokenKind)[0] === "ArgumentPlaceholder")
      ? ($sd0$Compiler$Parser$ok)($sd0$Types$FormattableAst$ArgumentPlaceholder)
      : ((($tokenKind)[0] === "NumberLiteral")
        ? ((() => {
          const $s = ($tokenKind)[1];
          return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)((($sd0$Compiler$Parser$on)((($e) => {
            return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Poly)($s, $e));
          })))(($sd0$Compiler$Parser$discardFirst)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$UniquenessPolymorphismBinop), ($sd0$Compiler$Parser$expr)($env))), ($core$Core$Cons)(($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$LiteralNumber)($s)), $core$Core$Nil)));
        }))()
        : ((($tokenKind)[0] === "TextLiteral")
          ? ((() => {
            const $s = ($tokenKind)[1];
            return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$LiteralText)($s));
          }))()
          : (((($tokenKind)[0] === "RoundParen") && ((($tokenKind)[1])[0] === "Open"))
            ? (($sd0$Compiler$Parser$on)((($$expr_) => {
              const $pos = ($$expr_)[1];
              const $expr_ = ($$expr_)[2];
              return (($sd0$Compiler$Parser$on)(((_0) => {
                return ($sd0$Compiler$Parser$ok)($expr_);
              })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)(($sd0$Types$Token$RoundParen)($sd0$Types$Token$Closed))));
            })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$expr)($env)))
            : (((($tokenKind)[0] === "SquareBracket") && ((($tokenKind)[1])[0] === "Open"))
              ? ((() => {
                const $item = (($sd0$Compiler$Parser$on)((($maybeDots) => {
                  return (($sd0$Compiler$Parser$on)((($exp) => {
                    return ($sd0$Compiler$Parser$ok)(({
                      first: (sp_not_equal)($maybeDots, $core$Maybe$Nothing),
                      second: $exp,
                    }));
                  })))(($sd0$Compiler$Parser$expr)($env));
                })))(($sd0$Compiler$Parser$maybe)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$ThreeDots)));
                return (($sd0$Compiler$Parser$on)((($exps) => {
                  return (($sd0$Compiler$Parser$on)(((_0) => {
                    return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$List)(($core$Maybe$withDefault)($core$Core$Nil, $exps)));
                  })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)(($sd0$Types$Token$SquareBracket)($sd0$Types$Token$Closed))));
                })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$maybe)(($sd0$Compiler$Parser$rawList)($item))));
              }))()
              : (((($tokenKind)[0] === "CurlyBrace") && ((($tokenKind)[1])[0] === "Open"))
                ? ((() => {
                  const $extension = ($sd0$Compiler$Parser$discardSecond)(($sd0$Compiler$Parser$maybe)(($sd0$Compiler$Parser$expr)($env)), ($sd0$Compiler$Parser$kind)($sd0$Types$Token$With));
                  const $attribute = (($sd0$Compiler$Parser$on)(((_0) => {
                    return (($sd0$Compiler$Parser$on)((($name) => {
                      return (($sd0$Compiler$Parser$on)((($maybeExpr) => {
                        return ($sd0$Compiler$Parser$ok)(({
                          maybeExpr: $maybeExpr,
                          name: $name,
                        }));
                      })))(($sd0$Compiler$Parser$maybe)(($sd0$Compiler$Parser$discardFirst)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Defop), ($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$expr)($env)))));
                    })))(($sd0$Compiler$Parser$expr)($env));
                  })))(($sd0$Compiler$Parser$maybe)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine)));
                  return (($sd0$Compiler$Parser$on)((($maybeExtension) => {
                    return (($sd0$Compiler$Parser$on)((($attrs) => {
                      return (($sd0$Compiler$Parser$on)(((_0) => {
                        return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Record)(({
                          attrs: ($core$Maybe$withDefault)($core$Core$Nil, $attrs),
                          maybeExtension: $maybeExtension,
                        })));
                      })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)(($sd0$Types$Token$CurlyBrace)($sd0$Types$Token$Closed))));
                    })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$maybe)(($sd0$Compiler$Parser$rawList)($attribute))));
                  })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$maybe)($extension)));
                }))()
                : ((($tokenKind)[0] === "Fn")
                  ? (($sd0$Compiler$Parser$on)((($args) => {
                    return (($sd0$Compiler$Parser$on)(((_0) => {
                      return (($sd0$Compiler$Parser$on)((($body) => {
                        return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Fn)($args, $body));
                      })))(($sd0$Compiler$Parser$alignedOrInlineStatements)($env));
                    })))(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Colon));
                  })))(($sd0$Compiler$Parser$rawList)(($sd0$Compiler$Parser$expr)($env)))
                  : ((($tokenKind)[0] === "If")
                    ? (($sd0$Compiler$Parser$on)((($condition) => {
                      return (($sd0$Compiler$Parser$on)(((_0) => {
                        return (($sd0$Compiler$Parser$on)((($true) => {
                          return (($sd0$Compiler$Parser$on)(((_0) => {
                            return (($sd0$Compiler$Parser$on)((($false) => {
                              return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$If)(({
                                condition: $condition,
                                false: $false,
                                true: $true,
                              })));
                            })))(($sd0$Compiler$Parser$alignedOrInlineStatements)($env));
                          })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Else)));
                        })))(($sd0$Compiler$Parser$alignedOrInlineStatements)($env));
                      })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Then)));
                    })))(($sd0$Compiler$Parser$expr)($env))
                    : ((($tokenKind)[0] === "Try")
                      ? ((() => {
                        const $maybeNewLineKind = (($k) => {
                          return ($sd0$Compiler$Parser$maybeNewLine)(($sd0$Compiler$Parser$kind)($k));
                        });
                        const $patternAndValue = (($sd0$Compiler$Parser$on)((($p) => {
                          return (($sd0$Compiler$Parser$on)(((_0) => {
                            return (($sd0$Compiler$Parser$on)((($value) => {
                              return ($sd0$Compiler$Parser$ok)(({
                                first: $p,
                                second: $value,
                              }));
                            })))(($sd0$Compiler$Parser$indentedOrInlineStatements)($env));
                          })))(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Colon));
                        })))(($sd0$Compiler$Parser$expr)($env));
                        return (($sd0$Compiler$Parser$on)((($value) => {
                          return (($sd0$Compiler$Parser$on)(((_0) => {
                            return (($sd0$Compiler$Parser$on)((($patterns) => {
                              return (($sd0$Compiler$Parser$on)((($end) => {
                                return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Try)(({
                                  patterns: $patterns,
                                  value: $value,
                                })));
                              })))($sd0$Compiler$Parser$here);
                            })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$rawList)($patternAndValue)));
                          })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$As)));
                        })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$expr)($env)));
                      }))()
                      : (true
                        ? $sd0$SPLib$Parser$reject
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 334:4', (sp_toHuman)($tokenKind)))))))))))));
});

const $sd0$Compiler$Parser$maybeWithDefault = (($a, $p) => {
  return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)($p, ($core$Core$Cons)(($sd0$Compiler$Parser$ok)($a), $core$Core$Nil)));
});

const $sd0$Compiler$Parser$recInlineOrIndentedOrBelow = (($higher, $accum) => {
  return (($sd0$Compiler$Parser$on)((($h) => {
    const $r = (sp_cons)($h, $accum);
    return ((($1) => {
      return ($sd0$Compiler$Parser$maybeWithDefault)($r, $1);
    }))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$recInlineOrIndentedOrBelow)($higher, $r)));
  })))($higher);
});

const $sd0$Compiler$Parser$unaryOperator = (($sd0$Compiler$Parser$on)((($token) => {
  return (((($token)[0] === "Token") && ((($token)[4])[0] === "Unop"))
    ? ((() => {
      const $c = ($token)[1];
      const $s = ($token)[2];
      const $e = ($token)[3];
      const $op = (($token)[4])[1];
      return ($sd0$SPLib$Parser$accept)(({
        first: $op,
        second: $token,
      }));
    }))()
    : (true
      ? $sd0$SPLib$Parser$reject
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 528:4', (sp_toHuman)($token))));
})))($sd0$Compiler$Parser$oneToken);

const $sd0$Compiler$Parser$unopsOr = (($env, $higher) => {
  return (($sd0$Compiler$Parser$on)((($maybeUnary) => {
    return (($sd0$Compiler$Parser$on)((($right) => {
      return (($sd0$Compiler$Parser$on)((($end) => {
        return (((($maybeUnary)[0] === "Just") && ((($maybeUnary)[1].second)[0] === "Token"))
          ? ((() => {
            const $op = ($maybeUnary)[1].first;
            const $start = (($maybeUnary)[1].second)[2];
            return ($sd0$Compiler$Parser$ok)(((($1) => {
              return ($sd0$Types$FormattableAst$Expression)(($sd0$Compiler$Parser$pos)($env, $start, $end), $1);
            }))(($sd0$Types$FormattableAst$Unop)($op, $right)));
          }))()
          : ((($maybeUnary)[0] === "Nothing")
            ? ($sd0$Compiler$Parser$ok)($right)
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 516:4', (sp_toHuman)($maybeUnary))));
      })))($sd0$Compiler$Parser$here);
    })))($higher);
  })))(($sd0$SPLib$Parser$maybe)($sd0$Compiler$Parser$unaryOperator));
});

const $sd0$Compiler$Parser$functionApplicationOr = (($env, $higher) => {
  const $recInlineOrIndented = (($accum) => {
    const $p = ((sp_equal)($accum, $core$Core$Nil)
      ? $higher
      : ($sd0$Compiler$Parser$unopsOr)($env, $higher));
    return (($sd0$Compiler$Parser$on)((($h) => {
      const $r = (sp_cons)($h, $accum);
      return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$block)(($sd0$Compiler$Parser$recInlineOrIndentedOrBelow)($higher, $r)), ($core$Core$Cons)(($recInlineOrIndented)($r), ($core$Core$Cons)(($sd0$Compiler$Parser$ok)($r), $core$Core$Nil))));
    })))($p);
  });
  return (($sd0$Compiler$Parser$on)((($start) => {
    return (($sd0$Compiler$Parser$on)((($reversedArgs) => {
      return (($sd0$Compiler$Parser$on)((($end) => {
        const $$try1 = ($core$List$reverse)($reversedArgs);
        return ((($$try1)[0] === "Nil")
          ? $sd0$SPLib$Parser$reject
          : (((($$try1)[0] === "Cons") && ((($$try1)[2])[0] === "Nil"))
            ? ((() => {
              const $fnExpression = ($$try1)[1];
              return ($sd0$Compiler$Parser$ok)($fnExpression);
            }))()
            : ((($$try1)[0] === "Cons")
              ? ((() => {
                const $fnExpression = ($$try1)[1];
                const $args = ($$try1)[2];
                return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Expression)(($sd0$Compiler$Parser$pos)($env, $start, $end), ($sd0$Types$FormattableAst$Call)($fnExpression, $args)));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 497:4', (sp_toHuman)($$try1)))));
      })))($sd0$Compiler$Parser$here);
    })))(($recInlineOrIndented)($core$Core$Nil));
  })))($sd0$Compiler$Parser$here);
});

const $sd0$SPLib$Parser$expression = (($term, $ops) => {
  return ((($ops)[0] === "Nil")
    ? $term
    : ((($ops)[0] === "Cons")
      ? ((() => {
        const $op = ($ops)[1];
        const $rest = ($ops)[2];
        return ($sd0$SPLib$Parser$expression)(($op)($term), $rest);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPLib/Parser.sp 206:4', (sp_toHuman)($ops))));
});

const $sd0$Compiler$Parser$expr = (($env) => {
  const $expressionWithLeftDelimiter = (($sd0$Compiler$Parser$on)((($$comment) => {
    const $comment = ($$comment)[1];
    const $start = ($$comment)[2];
    const $end = ($$comment)[3];
    const $k = ($$comment)[4];
    return (($sd0$Compiler$Parser$on)((($expr_) => {
      return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Expression)(($sd0$Compiler$Parser$pos)($env, $start, $end), $expr_));
    })))(($sd0$Compiler$Parser$exprWithLeftDelimiter)($env, $k));
  })))($sd0$Compiler$Parser$oneToken);
  return ($sd0$SPLib$Parser$expression)($expressionWithLeftDelimiter, ($core$Core$Cons)((($1) => {
    return ($sd0$Compiler$Parser$functionApplicationOr)($env, $1);
  }), ($core$Core$Cons)((($1) => {
    return ($sd0$Compiler$Parser$unopsOr)($env, $1);
  }), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Exponential), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Multiplicative), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Addittive), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Comparison), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Logical), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Tuple), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Cons), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Pipe), ($core$Core$Cons)(($sd0$Compiler$Parser$binopsOr)($env, $sd0$Types$Op$Mutop), $core$Core$Nil))))))))))));
});

const $sd0$Compiler$Parser$word = (($env) => {
  return (($sd0$Compiler$Parser$on)((($$comment) => {
    const $comment = ($$comment)[1];
    const $start = ($$comment)[2];
    const $end = ($$comment)[3];
    const $kind = ($$comment)[4];
    return ((($kind)[0] === "Word")
      ? ((() => {
        const $w = ($kind)[1];
        return ($sd0$Compiler$Parser$ok)(($sd0$Types$Pos$At)(($sd0$Compiler$Parser$pos)($env, $start, $end), $w));
      }))()
      : (true
        ? $sd0$SPLib$Parser$reject
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 178:4', (sp_toHuman)($kind))));
  })))($sd0$Compiler$Parser$oneToken);
});

const $sd0$Compiler$Parser$aliasDef = (($env) => {
  const $aliasWord = ({
    attrPath: $core$Core$Nil,
    isUpper: false,
    maybeModule: $core$Maybe$Nothing,
    modifier: $sd0$Types$Token$NameNoModifier,
    name: "alias",
  });
  return (($sd0$Compiler$Parser$on)(((_0) => {
    return (($sd0$Compiler$Parser$on)((($name) => {
      return (($sd0$Compiler$Parser$on)((($args) => {
        return (($sd0$Compiler$Parser$on)(((_0) => {
          return (($sd0$Compiler$Parser$on)((($type) => {
            return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$AliasDef)(({
              args: $args,
              name: $name,
              type: $type,
            })));
          })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$expr)($env)));
        })))(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Defop));
      })))(($sd0$SPLib$Parser$zeroOrMore)(($sd0$Compiler$Parser$word)($env)));
    })))(($sd0$Compiler$Parser$word)($env));
  })))(($sd0$Compiler$Parser$kind)(($sd0$Types$Token$Word)($aliasWord)));
});

const $sd0$SPLib$Parser$abort = (($error) => {
  return (($rejections, $readState) => {
    return ({
      first: $rejections,
      second: ($sd0$SPLib$Parser$Aborted)($readState, $error),
    });
  });
});

const $sd0$Compiler$Parser$nonFunction = (($env) => {
  return (($sd0$Compiler$Parser$on)(((_0) => {
    return (($sd0$Compiler$Parser$on)((($names) => {
      return (($sd0$Compiler$Parser$on)((($$literal) => {
        const $literal = ($$literal)[2];
        return ((sp_not_equal)($literal.name, "NonFunction")
          ? ($sd0$SPLib$Parser$abort)("Only NonFunction is supported for now")
          : ($sd0$Compiler$Parser$ok)($names));
      })))(($sd0$Compiler$Parser$word)($env));
    })))(($sd0$Compiler$Parser$rawList)(($sd0$Compiler$Parser$word)($env)));
  })))(($sd0$Compiler$Parser$kind)($sd0$Types$Token$With));
});

const $sd0$Compiler$Parser$definition = (($env) => {
  return (($sd0$Compiler$Parser$on)((($start) => {
    return (($sd0$Compiler$Parser$on)((($p) => {
      return (($sd0$Compiler$Parser$on)((($nf) => {
        return (($sd0$Compiler$Parser$on)((($defModifier) => {
          return (($sd0$Compiler$Parser$on)((($body) => {
            return (($sd0$Compiler$Parser$on)((($end) => {
              return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$ValueDef)(({
                body: $body,
                nonFn: ($core$Maybe$withDefault)($core$Core$Nil, $nf),
                pattern: $p,
              })));
            })))($sd0$Compiler$Parser$here);
          })))(($sd0$Compiler$Parser$indentedOrInlineStatements)($env));
        })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Defop)));
      })))(($sd0$SPLib$Parser$maybe)(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$nonFunction)($env))));
    })))(($sd0$Compiler$Parser$expr)($env));
  })))($sd0$Compiler$Parser$here);
});

const $sd0$Compiler$Parser$unionDef = (($env) => {
  const $unionWord = ({
    attrPath: $core$Core$Nil,
    isUpper: false,
    maybeModule: $core$Maybe$Nothing,
    modifier: $sd0$Types$Token$NameNoModifier,
    name: "union",
  });
  return (($sd0$Compiler$Parser$on)(((_0) => {
    return (($sd0$Compiler$Parser$on)((($name) => {
      return (($sd0$Compiler$Parser$on)((($args) => {
        return (($sd0$Compiler$Parser$on)(((_0) => {
          return (($sd0$Compiler$Parser$on)((($constructors) => {
            return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$UnionDef)(({
              args: $args,
              constructors: $constructors,
              name: $name,
            })));
          })))(($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$rawList)(($sd0$Compiler$Parser$expr)($env))));
        })))(($sd0$Compiler$Parser$kind)($sd0$Types$Token$Defop));
      })))(($sd0$SPLib$Parser$zeroOrMore)(($sd0$Compiler$Parser$word)($env)));
    })))(($sd0$Compiler$Parser$word)($env));
  })))(($sd0$Compiler$Parser$kind)(($sd0$Types$Token$Word)($unionWord)));
});

const $sd0$SPLib$Parser$breakCircularDefinition = (($a) => {
  return (($sd0$SPLib$Parser$andThen)($a))(($sd0$SPLib$Parser$accept)(null));
});

const $sd0$Compiler$Parser$statement = (($env) => {
  return ($sd0$SPLib$Parser$breakCircularDefinition)(((_0) => {
    return (($sd0$Compiler$Parser$on)(((_0) => {
      return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$aliasDef)($env), ($core$Core$Cons)(($sd0$Compiler$Parser$unionDef)($env), ($core$Core$Cons)(($sd0$Compiler$Parser$definition)($env), ($core$Core$Cons)((($sd0$Compiler$Parser$on)((($e) => {
        return ($sd0$Compiler$Parser$ok)(($sd0$Types$FormattableAst$Evaluation)($e));
      })))(($sd0$Compiler$Parser$expr)($env)), $core$Core$Nil)))));
    })))(($sd0$SPLib$Parser$maybe)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine)));
  }));
});

const $sd0$SPLib$Parser$without = (($p) => {
  return (($sd0$SPLib$Parser$thenWithDefault)(($sd0$SPLib$Parser$accept)(null), ((_0) => {
    return $sd0$SPLib$Parser$reject;
  })))($p);
});

const $sd0$SPLib$Parser$end = ($sd0$SPLib$Parser$without)($sd0$SPLib$Parser$consumeOne);

const $sd0$Compiler$Parser$rootStatement = (($env) => {
  const $fillers = ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$BlockEnd), ($core$Core$Cons)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine), $core$Core$Nil)));
  return (($sd0$Compiler$Parser$on)(((_0) => {
    return (($sd0$Compiler$Parser$on)((($maybeStatement) => {
      return (($sd0$Compiler$Parser$on)(((_0) => {
        return (($sd0$Compiler$Parser$on)(((_0) => {
          return ($sd0$SPLib$Parser$accept)($maybeStatement);
        })))($sd0$SPLib$Parser$end);
      })))(($sd0$SPLib$Parser$zeroOrMore)($fillers));
    })))(($sd0$SPLib$Parser$maybe)(($sd0$Compiler$Parser$statement)($env)));
  })))(($sd0$SPLib$Parser$zeroOrMore)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$NewSiblingLine)));
});

const $sd0$SPLib$Parser$runParser = (($parser, $readState) => {
  return ($parser)(($core$Core$Cons)($readState, $core$Core$Nil), $readState);
});

const $sd0$Compiler$Parser$parse = (($env, $tokens) => {
  const $$failureStates = ($sd0$SPLib$Parser$runParser)(($sd0$Compiler$Parser$rootStatement)($env), $tokens);
  const $outcome = $$failureStates.second;
  const $failureStates = $$failureStates.first;
  return ((($outcome)[0] === "Accepted")
    ? ((() => {
      const $readState = ($outcome)[1];
      const $output = ($outcome)[2];
      return ($core$Result$Ok)($output);
    }))()
    : ((($outcome)[0] === "Aborted")
      ? ((() => {
        const $readState = ($outcome)[1];
        const $message = ($outcome)[2];
        return ($sd0$Compiler$Parser$makeError)($env.moduleName, $readState, $message);
      }))()
      : ((($outcome)[0] === "Rejected")
        ? ((() => {
          const $findMin = (($readState, $best) => {
            return ((($core$List$length)($readState) < ($core$List$length)($best))
              ? $readState
              : $best);
          });
          const $readState = ($core$List$for)($tokens, $failureStates, $findMin);
          const $message = ((($readState)[0] === "Nil")
            ? "I got to the end of the statement and I can't make sense of it. =("
            : (true
              ? "I got stuck parsing here. =("
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 695:16', (sp_toHuman)($readState))));
          return ($sd0$Compiler$Parser$makeError)($env.moduleName, $readState, $message);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/Parser.sp 680:4', (sp_toHuman)($outcome)))));
});

const $sd0$Compiler$Parser$textToFormattableModule = (($env, $code) => {
  const $tokensResult = ($sd0$Compiler$Lexer$lexer)($env.moduleName, $code);
  return (($core$Result$onOk)((($rootStatements) => {
    (sp_benchStart)(null);
    const $result = ((($1) => {
      return ($core$Result$map)((($1) => {
        return ($core$List$filterMap)($core$Basics$identity, $1);
      }), $1);
    }))(((($1) => {
      return ($core$List$mapRes)((($1) => {
        return ($sd0$Compiler$Parser$parse)($env, $1);
      }), $1);
    }))($rootStatements));
    (sp_benchStop)("parse");
    return $result;
  })))($tokensResult);
});

const $sd0$SPON$unhackPosEnd = (($moduleName, $pos) => {
  return ((($pos)[0] === "End")
    ? ($sd0$Types$Pos$End)($moduleName)
    : (true
      ? $pos
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 58:4', (sp_toHuman)($pos))));
});

const $sd0$SPON$run = (($readerA, $sponName, $statements) => {
  const $$try1 = ($readerA)($statements);
  return (((($$try1)[0] === "Accepted") && ((($$try1)[1])[0] === "Nil"))
    ? ((() => {
      const $a = ($$try1)[2];
      return ($core$Result$Ok)($a);
    }))()
    : (((($$try1)[0] === "Accepted") && ((($$try1)[1])[0] === "Cons"))
      ? ((() => {
        const $head = (($$try1)[1])[1];
        const $tail = (($$try1)[1])[2];
        const $a = ($$try1)[2];
        return ($sd0$Compiler$Error$res)(($sd0$Types$FormattableAst$statementPos)($head), ((_0) => {
          return ($core$Core$Cons)("unread statements", $core$Core$Nil);
        }));
      }))()
      : (((($$try1)[0] === "Rejected") && ((($$try1)[1])[0] === "At"))
        ? ((() => {
          const $pos = (($$try1)[1])[1];
          const $r = (($$try1)[1])[2];
          return ($sd0$Compiler$Error$res)(($sd0$SPON$unhackPosEnd)($sponName, $pos), ((_0) => {
            return ($core$Core$Cons)($r, $core$Core$Nil);
          }));
        }))()
        : (((($$try1)[0] === "Failed") && ((($$try1)[1])[0] === "At"))
          ? ((() => {
            const $pos = (($$try1)[1])[1];
            const $r = (($$try1)[1])[2];
            return ($sd0$Compiler$Error$res)(($sd0$SPON$unhackPosEnd)($sponName, $pos), ((_0) => {
              return ($core$Core$Cons)($r, $core$Core$Nil);
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 65:4', (sp_toHuman)($$try1))))));
});

const $sd0$SPON$read = (($reader, $moduleName, $sponContent) => {
  return (($core$Result$onOk)((($2) => {
    return ($sd0$SPON$run)($reader, $moduleName, $2);
  })))(((($1) => {
    return ($sd0$Compiler$Parser$textToFormattableModule)(({
      moduleName: $moduleName,
      stripLocations: false,
    }), $1);
  }))($sponContent));
});

const $sd0$ModulesFile$textToModulesFile = (($sponName, $sponContent) => {
  const $insert = (($rootEntry, $mf) => {
    return ((($rootEntry)[0] === "Lib")
      ? ((() => {
        const $lib = ($rootEntry)[1];
        const $0 = $mf;
        return (Object.assign)({}, $0, ({
          libraries: (sp_cons)($lib, $mf.libraries),
        }));
      }))()
      : ((($rootEntry)[0] === "Dir")
        ? ((() => {
          const $dir = ($rootEntry)[1];
          const $0 = $mf;
          return (Object.assign)({}, $0, ({
            sourceDirs: (sp_cons)($dir, $mf.sourceDirs),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/ModulesFile.sp 156:8', (sp_toHuman)($rootEntry))));
  });
  return ((($1) => {
    return ($core$Result$map)((($rootEntries) => {
      return ($core$List$for)($sd0$ModulesFile$initModulesFile, $rootEntries, $insert);
    }), $1);
  }))(((($2) => {
    return ($sd0$SPON$read)($sd0$ModulesFile$modulesFileReader, $sponName, $2);
  }))($sponContent));
});

const $sd0$Compile$loadModulesFile = (($platform, $projectRoot) => {
  const $path = (path_resolve)(($core$Core$Cons)($projectRoot, ($core$Core$Cons)($sd0$Compile$modulesFileName, $core$Core$Nil)));
  (sp_log)("Metafile: ", $path);
  return (($posix$IO$onResult)((($result) => {
    const $modulesAsText = ((($result)[0] === "Ok")
      ? ((() => {
        const $f = ($result)[1];
        return $f;
      }))()
      : ((($result)[0] === "Err")
        ? ((() => {
          (sp_log)("Using default modules.sp", "");
          return $platform.defaultModules;
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 63:8', (sp_toHuman)($result))));
    const $eenv = ({
      moduleByName: ($core$Dict$ofOne)($sd0$Compile$modulesFileName, ({
        content: $modulesAsText,
        fsPath: $sd0$Compile$modulesFileName,
      })),
    });
    return ((($1) => {
      return ($sd0$Compile$resToIo)($eenv, $1);
    }))(($sd0$ModulesFile$textToModulesFile)($sd0$Compile$modulesFileName, $modulesAsText));
  })))((io_readFile)($path));
});

const $sd0$Compile$updateSourceDir = (($fileNames, $orig) => {
  const $insertModuleName = (($name, $sd) => {
    const $$try1 = ($core$List$find)((($m) => {
      return (sp_equal)($m.path, $name);
    }), $sd.modules);
    return ((($$try1)[0] === "Just")
      ? $sd
      : ((($$try1)[0] === "Nothing")
        ? ((() => {
          const $0 = $sd;
          return (Object.assign)({}, $0, ({
            modules: (sp_cons)(({
              globalTypes: $core$Core$Nil,
              globalValues: $core$Core$Nil,
              path: $name,
              visibleAs: $name,
            }), $0.modules),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 204:8', (sp_toHuman)($$try1))));
  });
  return ($core$List$for)($orig, $fileNames, $insertModuleName);
});

const $sd0$ModulesFile$insertModule = (($source, $mod, $meta) => {
  const $visibleAs = $mod.visibleAs;
  const $umr = ($sd0$Types$Meta$UMR)($source, $mod.path);
  const $insertGlobal = (($varName, $d) => {
    return ((($1) => {
      return ($core$Dict$insert)($varName, $1, $d);
    }))(((($1) => {
      return ($sd0$Types$Meta$USR)($umr, $1);
    }))($varName));
  });
  return ({
    globalTypes: ($core$List$for)($meta.globalTypes, $mod.globalTypes, $insertGlobal),
    globalValues: ($core$List$for)($meta.globalValues, $mod.globalValues, $insertGlobal),
    moduleVisibleAsToUmr: ($core$Dict$insert)($visibleAs, $umr, $meta.moduleVisibleAsToUmr),
    umrToModuleVisibleAs: ($core$Dict$insert)($umr, $visibleAs, $meta.umrToModuleVisibleAs),
  });
});

const $sd0$ModulesFile$insertLibrary = (($lib, $meta) => {
  const $umr = ((() => {
    const $$try1 = $lib.source;
    return (("core:prelude" === $$try1)
      ? $sd0$Types$Meta$Core
      : (("core:browser" === $$try1)
        ? $sd0$Types$Meta$Browser
        : (("core:posix" === $$try1)
          ? $sd0$Types$Meta$Posix
          : (true
            ? (sp_todo)(("Library source `" + ($lib.source + "` is not supported.")))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/ModulesFile.sp 55:8', (sp_toHuman)($$try1))))));
  }))();
  return ($core$List$for)($meta, $lib.modules, (($1, $2) => {
    return ($sd0$ModulesFile$insertModule)($umr, $1, $2);
  }));
});

const $sd0$ModulesFile$insertModules = (($sd, $m) => {
  return ($core$List$for)($m, $sd.modules, (($1, $2) => {
    return ($sd0$ModulesFile$insertModule)(($sd0$Types$Meta$SourceDir)($sd.path), $1, $2);
  }));
});

const $sd0$Types$Meta$init = ({
  globalTypes: $core$Dict$empty,
  globalValues: $core$Dict$empty,
  moduleVisibleAsToUmr: $core$Dict$empty,
  umrToModuleVisibleAs: $core$Dict$empty,
});

const $sd0$ModulesFile$toMeta = (($mf) => {
  return ((($0) => {
    return ($core$List$for)($0, $mf.sourceDirs, $sd0$ModulesFile$insertModules);
  }))(((($0) => {
    return ($core$List$for)($0, $mf.libraries, $sd0$ModulesFile$insertLibrary);
  }))($sd0$Types$Meta$init));
});

const $sd0$Compile$loadMeta = (($env, $platform, $entryModuleDir, $projectRoot) => {
  return (($posix$IO$onSuccess)((($modulesFileRaw) => {
    const $resolvedDirs = ((($1) => {
      return ($core$List$map)((($sd) => {
        const $0 = $sd;
        return (Object.assign)({}, $0, ({
          path: (path_resolve)(($core$Core$Cons)($projectRoot, ($core$Core$Cons)($0.path, $core$Core$Nil))),
        }));
      }), $1);
    }))($modulesFileRaw.sourceDirs);
    const $allDirs = (($core$List$any)((($sd) => {
      return (sp_equal)($sd.path, $entryModuleDir);
    }), $resolvedDirs)
      ? $resolvedDirs
      : (sp_cons)(({
        modules: $core$Core$Nil,
        path: $entryModuleDir,
      }), $resolvedDirs));
    const $modulesFile = ((() => {
      const $0 = $modulesFileRaw;
      return (Object.assign)({}, $0, ({
        sourceDirs: $allDirs,
      }));
    }))();
    const $getAllSourceDirLists = (io_parallel)(((($1) => {
      return ($core$List$map)((($sd) => {
        return ($sd0$Compile$listSourceDir)($sd.path, "");
      }), $1);
    }))($modulesFile.sourceDirs));
    return (($posix$IO$onSuccess)((($allSourceDirLists) => {
      const $updatedSourceDirs = ($core$List$map2)($sd0$Compile$updateSourceDir, $allSourceDirLists, $modulesFile.sourceDirs);
      return ($posix$IO$succeed)(($sd0$ModulesFile$toMeta)(((() => {
        const $0 = $modulesFile;
        return (Object.assign)({}, $0, ({
          sourceDirs: $updatedSourceDirs,
        }));
      }))()));
    })))($getAllSourceDirLists);
  })))(($sd0$Compile$loadModulesFile)($platform, $projectRoot));
});

const $sd0$Compiler$MakeCanonical$error = (($pos, $msg) => {
  return ($sd0$Compiler$Error$res)($pos, (($errorEnv) => {
    return $msg;
  }));
});

const $sd0$Compiler$MakeCanonical$initEnv = (($ro) => {
  return ({
    maybeShorthandTarget: $core$Maybe$Nothing,
    nextGeneratedVariableName: 0,
    nonFn: $core$Dict$empty,
    nonRootValues: $core$Dict$empty,
    ro: $ro,
  });
});

const $sd0$Compiler$MakeCanonical$translateAttributeName = (($$expr_) => {
  const $pos = ($$expr_)[1];
  const $expr_ = ($$expr_)[2];
  return ((($expr_)[0] === "Variable")
    ? ((() => {
      const $maybeType = ($expr_)[1].maybeType;
      const $word = ($expr_)[1].word;
      return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("attribute names can't start with a dot", $core$Core$Nil))
        : ($word.isUpper
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("attribute names must be lower case", $core$Core$Nil))
          : ((sp_not_equal)($word.maybeModule, $core$Maybe$Nothing)
            ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("attribute names must be single words", $core$Core$Nil))
            : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
              ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("attribute names can't contain dots", $core$Core$Nil))
              : ($core$Result$Ok)(({
                first: $pos,
                second: $word.name,
                third: $maybeType,
              }))))));
    }))()
    : (true
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Expecting an attribute name here", $core$Core$Nil))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 391:4', (sp_toHuman)($expr_))));
});

const $sd0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType = (($ro, $faAttr, $caAttrs) => {
  return (($core$Result$onOk)((($$maybeFaType) => {
    const $pos = $$maybeFaType.first;
    const $name = $$maybeFaType.second;
    const $maybeFaType = $$maybeFaType.third;
    return (($core$Dict$member)($name, $caAttrs)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("Duplicate attribute name: " + $name), $core$Core$Nil))
      : ((($maybeFaType)[0] === "Nothing")
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("I need to see the type of this attribute, `" + ($name + " as TheType`")), $core$Core$Nil))
        : ((($maybeFaType)[0] === "Just")
          ? ((() => {
            const $faType = ($maybeFaType)[1];
            return (($core$Result$onOk)((($caType) => {
              return ((sp_not_equal)($faAttr.maybeExpr, $core$Maybe$Nothing)
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I'm expecting a type here; `=` is for assignign values", $core$Core$Nil))
                : ($core$Result$Ok)(((($2) => {
                  return ($core$Dict$insert)($name, $caType, $2);
                }))($caAttrs)));
            })))(((($1) => {
              return ($sd0$Compiler$MakeCanonical$translateRawType)($ro, $1);
            }))($faType));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1358:8', (sp_toHuman)($maybeFaType)))));
  })))(($sd0$Compiler$MakeCanonical$translateAttributeName)($faAttr.name));
});

const $sd0$Compiler$MakeCanonical$translatePoly = (($expr) => {
  const $$expr_ = $expr;
  const $expr_ = ($$expr_)[2];
  const $pos = ($$expr_)[1];
  return (((($expr_)[0] === "Unop") && ((($expr_)[1])[0] === "UnopUnique"))
    ? ((() => {
      const $e = ($expr_)[2];
      return ($core$Result$Ok)(({
        first: $sd0$Types$Ast$Uni,
        second: $e,
      }));
    }))()
    : ((($expr_)[0] === "Poly")
      ? ((() => {
        const $numberAsString = ($expr_)[1];
        const $e = ($expr_)[2];
        const $$try1 = (text_toNumber)($numberAsString);
        return ((($$try1)[0] === "Nothing")
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I need an integer number here", $core$Core$Nil))
          : ((($$try1)[0] === "Just")
            ? ((() => {
              const $n = ($$try1)[1];
              return ($core$Result$Ok)(({
                first: ($sd0$Types$Ast$Depends)($n),
                second: $e,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1430:12', (sp_toHuman)($$try1))));
      }))()
      : (true
        ? ($core$Result$Ok)(({
          first: $sd0$Types$Ast$Imm,
          second: $expr,
        }))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1423:4', (sp_toHuman)($expr_)))));
});

const $sd0$Compiler$MakeCanonical$translateFullType = (($ro, $expr) => {
  return (($core$Result$onOk)((($$e) => {
    const $uni = $$e.first;
    const $e = $$e.second;
    return (($core$Result$onOk)((($raw) => {
      return ($core$Result$Ok)(({
        raw: $raw,
        uni: $uni,
      }));
    })))(($sd0$Compiler$MakeCanonical$translateRawType)($ro, $e));
  })))(($sd0$Compiler$MakeCanonical$translatePoly)($expr));
});

const $sd0$Compiler$MakeCanonical$maybeForeignUsr = (($getter, $ro, $maybeModule, $name) => {
  return ((($maybeModule)[0] === "Just")
    ? ((() => {
      const $moduleName = ($maybeModule)[1];
      const $$try1 = ($core$Dict$get)($moduleName, $ro.meta.moduleVisibleAsToUmr);
      return ((($$try1)[0] === "Just")
        ? ((() => {
          const $umr = ($$try1)[1];
          return ($core$Maybe$Just)(($sd0$Types$Meta$USR)($umr, $name));
        }))()
        : ((($$try1)[0] === "Nothing")
          ? (sp_todo)(("!!resolveToUsr can't find the module: " + ($moduleName + (" (for: " + ($name + ")")))))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 88:12', (sp_toHuman)($$try1))));
    }))()
    : ((($maybeModule)[0] === "Nothing")
      ? ($core$Dict$get)($name, ($getter)($ro.meta))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 86:4', (sp_toHuman)($maybeModule))));
});

const $sd0$Compiler$MakeCanonical$resolveToUsr = (($getter, $ro, $maybeModule, $name) => {
  return ((($1) => {
    return ($core$Maybe$withDefault)(($sd0$Types$Meta$USR)($ro.currentModule, $name), $1);
  }))(($sd0$Compiler$MakeCanonical$maybeForeignUsr)($getter, $ro, $maybeModule, $name));
});

const $sd0$Compiler$MakeCanonical$resolveToTypeUsr = (($1, $2, $3) => {
  return ($sd0$Compiler$MakeCanonical$resolveToUsr)((($m) => {
    return $m.globalTypes;
  }), $1, $2, $3);
});

const $sd0$Compiler$MakeCanonical$translateNamedType = (($ro, $pos, $word, $caArgs) => {
  return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I was expecting a type name here =|", $core$Core$Nil))
    : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Type names have no attributes to access", $core$Core$Nil))
      : ($core$Result$Ok)(($sd0$Types$CanonicalAst$TypeNamed)($pos, ($sd0$Compiler$MakeCanonical$resolveToTypeUsr)($ro, $word.maybeModule, $word.name), $caArgs))));
});

const $sd0$Types$FormattableAst$sepToList = (($$head) => {
  const $head = $$head.first;
  const $tuples = $$head.second;
  return (sp_cons)($head, ($core$List$map)($core$Tuple$second, $tuples));
});

const $sd0$Types$Pos$range = (($a, $b) => {
  const $$try1 = ({
    first: $a,
    second: $b,
  });
  return (((($$try1.first)[0] === "P") && (($$try1.second)[0] === "P"))
    ? ((() => {
      const $ma = ($$try1.first)[1];
      const $sa = ($$try1.first)[2];
      const $ea = ($$try1.first)[3];
      const $mb = ($$try1.second)[1];
      const $sb = ($$try1.second)[2];
      const $eb = ($$try1.second)[3];
      return ((sp_not_equal)($ma, $mb)
        ? (sp_todo)("trying to range across two different modules")
        : ($sd0$Types$Pos$P)($ma, ($core$Basics$min)($sa, $sb), ($core$Basics$max)($ea, $eb)));
    }))()
    : ((($$try1.first)[0] === "P")
      ? $a
      : (true
        ? $b
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/Pos.sp 45:4', (sp_toHuman)($$try1)))));
});

const $sd0$Compiler$MakeCanonical$translateTuple = (($translate, $sepList) => {
  const $faExpressions = ($sd0$Types$FormattableAst$sepToList)($sepList);
  return (($core$Result$onOk)((($items) => {
    const $pos = ($core$List$for)($sd0$Types$Pos$G, $faExpressions, (($$p, $z) => {
      const $p = ($$p)[1];
      return ($sd0$Types$Pos$range)($p, $z);
    }));
    return (((($items)[0] === "Cons") && (((($items)[2])[0] === "Cons") && (((($items)[2])[2])[0] === "Nil")))
      ? ((() => {
        const $ca1 = ($items)[1];
        const $ca2 = (($items)[2])[1];
        return ($core$Result$Ok)(((($2) => {
          return ($core$Dict$insert)("second", $ca2, $2);
        }))(((($2) => {
          return ($core$Dict$insert)("first", $ca1, $2);
        }))($core$Dict$empty)));
      }))()
      : (((($items)[0] === "Cons") && (((($items)[2])[0] === "Cons") && ((((($items)[2])[2])[0] === "Cons") && ((((($items)[2])[2])[2])[0] === "Nil"))))
        ? ((() => {
          const $ca1 = ($items)[1];
          const $ca2 = (($items)[2])[1];
          const $ca3 = ((($items)[2])[2])[1];
          return ($core$Result$Ok)(((($2) => {
            return ($core$Dict$insert)("third", $ca3, $2);
          }))(((($2) => {
            return ($core$Dict$insert)("second", $ca2, $2);
          }))(((($2) => {
            return ($core$Dict$insert)("first", $ca1, $2);
          }))($core$Dict$empty))));
        }))()
        : (true
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("tuples can be only of size 2 or 3, use a record instead", $core$Core$Nil))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 529:4', (sp_toHuman)($items)))));
  })))(((($1) => {
    return ($core$List$mapRes)($translate, $1);
  }))($faExpressions));
});

const $sd0$Compiler$MakeCanonical$translateTypeFunctionParameter = (($ro, $expression) => {
  const $$expr_ = $expression;
  const $expr_ = ($$expr_)[2];
  return (((($expr_)[0] === "Unop") && ((($expr_)[1])[0] === "UnopRecycle"))
    ? ((() => {
      const $faOperand = ($expr_)[2];
      return ((($1) => {
        return ($core$Result$map)($sd0$Types$CanonicalAst$ParRe, $1);
      }))(((($1) => {
        return ($sd0$Compiler$MakeCanonical$translateRawType)($ro, $1);
      }))($faOperand));
    }))()
    : (true
      ? ((($1) => {
        return ($core$Result$map)($sd0$Types$CanonicalAst$ParSp, $1);
      }))(((($1) => {
        return ($sd0$Compiler$MakeCanonical$translateFullType)($ro, $1);
      }))($expression))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1406:4', (sp_toHuman)($expr_))));
});

const $sd0$Compiler$MakeCanonical$translateTypeVariable = (($pos, $word) => {
  return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I was expecting a type variable name here =|", $core$Core$Nil))
    : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Type variables have no attributes to access", $core$Core$Nil))
      : ((sp_not_equal)($word.maybeModule, $core$Maybe$Nothing)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("No point it getting tyvars from modules?", $core$Core$Nil))
        : ($core$Result$Ok)($word.name))));
});

const $sd0$Compiler$MakeCanonical$translateRawType = (($ro, $$expr_) => {
  const $pos = ($$expr_)[1];
  const $expr_ = ($$expr_)[2];
  return ((($expr_)[0] === "Variable")
    ? ((() => {
      const $maybeType = ($expr_)[1].maybeType;
      const $word = ($expr_)[1].word;
      return ((sp_not_equal)($maybeType, $core$Maybe$Nothing)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't really specify the type of a type.", $core$Core$Nil))
        : ($word.isUpper
          ? ($sd0$Compiler$MakeCanonical$translateNamedType)($ro, $pos, $word, $core$Core$Nil)
          : (($core$Result$onOk)((($tyvarName) => {
            return ($core$Result$Ok)(($sd0$Types$CanonicalAst$TypeAnnotationVariable)($pos, $tyvarName));
          })))(($sd0$Compiler$MakeCanonical$translateTypeVariable)($pos, $word))));
    }))()
    : (((($expr_)[0] === "Call") && ((($expr_)[1])[0] === "Expression"))
      ? ((() => {
        const $refPos = (($expr_)[1])[1];
        const $ref = (($expr_)[1])[2];
        const $faArgs = ($expr_)[2];
        return (((($ref)[0] === "Variable") && ((($ref)[1].maybeType)[0] === "Nothing"))
          ? ((() => {
            const $word = ($ref)[1].word;
            return (($core$Result$onOk)((($caArgs) => {
              return ($sd0$Compiler$MakeCanonical$translateNamedType)($ro, $refPos, $word, $caArgs);
            })))(((($1) => {
              return ($core$List$mapRes)((($1) => {
                return ($sd0$Compiler$MakeCanonical$translateRawType)($ro, $1);
              }), $1);
            }))($faArgs));
          }))()
          : (true
            ? ($sd0$Compiler$MakeCanonical$error)($refPos, ($core$Core$Cons)("I was expecting a named type here", $core$Core$Nil))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1471:12', (sp_toHuman)($ref))));
      }))()
      : ((($expr_)[0] === "List")
        ? ((() => {
          const $dotsAndItems = ($expr_)[1];
          return ((($dotsAndItems)[0] === "Nil")
            ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("You need to specify the type of the List items", $core$Core$Nil))
            : (((($dotsAndItems)[0] === "Cons") && ((($dotsAndItems)[2])[0] === "Nil"))
              ? ((() => {
                const $hasDots = ($dotsAndItems)[1].first;
                const $faItem = ($dotsAndItems)[1].second;
                return ($hasDots
                  ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("No need to use dots here", $core$Core$Nil))
                  : (($core$Result$onOk)((($caItem) => {
                    return ($core$Result$Ok)(($sd0$Compiler$CoreTypes$list)($caItem));
                  })))(($sd0$Compiler$MakeCanonical$translateRawType)($ro, $faItem)));
              }))()
              : (true
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("List items must all have the same type, so you can specify only one type", $core$Core$Nil))
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1483:12', (sp_toHuman)($dotsAndItems)))));
        }))()
        : ((($expr_)[0] === "Record")
          ? ((() => {
            const $attrs = ($expr_)[1].attrs;
            const $maybeExtension = ($expr_)[1].maybeExtension;
            return ((sp_not_equal)($maybeExtension, $core$Maybe$Nothing)
              ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Experimentally, extensible type annotations are disabled", $core$Core$Nil))
              : (($core$Result$onOk)((($caAttrs) => {
                return ($core$Result$Ok)(((($1) => {
                  return ($sd0$Types$CanonicalAst$TypeRecord)($pos, $1);
                }))($caAttrs));
              })))(((($0) => {
                return ($core$List$forRes)($0, $attrs, (($1, $2) => {
                  return ($sd0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType)($ro, $1, $2);
                }));
              }))($core$Dict$empty)));
          }))()
          : ((($expr_)[0] === "Fn")
            ? ((() => {
              const $faParams = ($expr_)[1];
              const $faReturn = ($expr_)[2];
              return (($core$Result$onOk)((($caParams) => {
                return (($core$Result$onOk)((($caReturn) => {
                  return ($core$Result$Ok)(($sd0$Types$CanonicalAst$TypeFn)($pos, $caParams, $caReturn));
                })))(((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateFullType)($ro, $1);
                }))($faReturn));
              })))(((($1) => {
                return ($core$List$mapRes)((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateTypeFunctionParameter)($ro, $1);
                }), $1);
              }))($faParams));
            }))()
            : (((($expr_)[0] === "Binop") && ((($expr_)[1])[0] === "Tuple"))
              ? ((() => {
                const $sepList = ($expr_)[2];
                return (($core$Result$onOk)((($recordAttrs) => {
                  return ($core$Result$Ok)(($sd0$Types$CanonicalAst$TypeRecord)($pos, $recordAttrs));
                })))(((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateTuple)((($1) => {
                    return ($sd0$Compiler$MakeCanonical$translateRawType)($ro, $1);
                  }), $1);
                }))($sepList));
              }))()
              : (true
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Not sure what's up with this type =|", ($core$Core$Cons)((sp_toHuman)($expr_), $core$Core$Nil)))
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1457:4', (sp_toHuman)($expr_)))))))));
});

const $sd0$Compiler$MakeCanonical$translateConstructor = (($ro, $unionType, $unionUsr, $$expr_, $constructors) => {
  const $pos = ($$expr_)[1];
  const $expr_ = ($$expr_)[2];
  const $zzz = ((($expr_)[0] === "Variable")
    ? ((() => {
      const $var = ($expr_)[1];
      return ($core$Result$Ok)(({
        first: $var,
        second: $core$Core$Nil,
      }));
    }))()
    : (((($expr_)[0] === "Call") && (((($expr_)[1])[0] === "Expression") && (((($expr_)[1])[2])[0] === "Variable")))
      ? ((() => {
        const $var = ((($expr_)[1])[2])[1];
        const $pars = ($expr_)[2];
        return ($core$Result$Ok)(({
          first: $var,
          second: $pars,
        }));
      }))()
      : (true
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I was expecting a constructor name here", $core$Core$Nil))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1547:8', (sp_toHuman)($expr_)))));
  return (($core$Result$onOk)((($$faPars) => {
    const $maybeType = $$faPars.first.maybeType;
    const $word = $$faPars.first.word;
    const $faPars = $$faPars.second;
    const $isValidName = ((sp_equal)($word.modifier, $sd0$Types$Token$NameNoModifier) && ($word.isUpper && ((sp_equal)($word.maybeModule, $core$Maybe$Nothing) && (sp_equal)($word.attrPath, $core$Core$Nil))));
    return (($core$Basics$not)($isValidName)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I need just an Uppercase word here", $core$Core$Nil))
      : (($core$Dict$member)($word.name, $constructors)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("constructor " + ($word.name + " is duplicate")), $core$Core$Nil))
        : (($core$Result$onOk)((($ins) => {
          const $c = ({
            ins: $ins,
            out: $unionType,
            pos: $pos,
            typeUsr: $unionUsr,
          });
          return ($core$Result$Ok)(((($2) => {
            return ($core$Dict$insert)($word.name, $c, $2);
          }))($constructors));
        })))(((($1) => {
          return ($core$List$mapRes)((($1) => {
            return ($sd0$Compiler$MakeCanonical$translateRawType)($ro, $1);
          }), $1);
        }))($faPars))));
  })))($zzz);
});

const $sd0$Compiler$MakeCanonical$addUnivarId = (($uni, $acc) => {
  return ((($uni)[0] === "Depends")
    ? ((() => {
      const $id = ($uni)[1];
      return ($core$Dict$insert)($id, null, $acc);
    }))()
    : (true
      ? $acc
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 280:4', (sp_toHuman)($uni))));
});

const $sd0$Compiler$MakeCanonical$addPar = (($parType, $acc) => {
  return ((($parType)[0] === "ParRe")
    ? ((() => {
      const $raw = ($parType)[1];
      return ($sd0$Compiler$MakeCanonical$addRawTypeUnivars)($raw, $acc);
    }))()
    : ((($parType)[0] === "ParSp")
      ? ((() => {
        const $full = ($parType)[1];
        return ((($1) => {
          return ($sd0$Compiler$MakeCanonical$addRawTypeUnivars)($full.raw, $1);
        }))(((($1) => {
          return ($sd0$Compiler$MakeCanonical$addUnivarId)($full.uni, $1);
        }))($acc));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 288:4', (sp_toHuman)($parType))));
});

const $sd0$Compiler$MakeCanonical$addRawTypeUnivars = (($raw, $acc) => {
  return ((($raw)[0] === "TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($core$List$for)($acc, $args, $sd0$Compiler$MakeCanonical$addRawTypeUnivars);
    }))()
    : ((($raw)[0] === "TypeRecord")
      ? ((() => {
        const $attrs = ($raw)[2];
        return ($core$Dict$for)($acc, $attrs, (($k, $v, $a) => {
          return ($sd0$Compiler$MakeCanonical$addRawTypeUnivars)($v, $a);
        }));
      }))()
      : ((($raw)[0] === "TypeAnnotationVariable")
        ? $acc
        : ((($raw)[0] === "TypeError")
          ? $acc
          : ((($raw)[0] === "TypeFn")
            ? ((() => {
              const $pars = ($raw)[2];
              const $out = ($raw)[3];
              return ((($0) => {
                return ($core$List$for)($0, $pars, $sd0$Compiler$MakeCanonical$addPar);
              }))(((($1) => {
                return ($sd0$Compiler$MakeCanonical$addRawTypeUnivars)($out.raw, $1);
              }))(((($1) => {
                return ($sd0$Compiler$MakeCanonical$addUnivarId)($out.uni, $1);
              }))($acc)));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 299:4', (sp_toHuman)($raw)))))));
});

const $sd0$Compiler$MakeCanonical$addPatternUnivars = (($pattern, $acc) => {
  return ((($pattern)[0] === "PatternConstructor")
    ? ((() => {
      const $args = ($pattern)[3];
      return ($core$List$for)($acc, $args, $sd0$Compiler$MakeCanonical$addPatternUnivars);
    }))()
    : ((($pattern)[0] === "PatternRecord")
      ? ((() => {
        const $attrs = ($pattern)[3];
        return ($core$Dict$for)($acc, $attrs, (($k, $v, $a) => {
          return ($sd0$Compiler$MakeCanonical$addPatternUnivars)($v, $a);
        }));
      }))()
      : (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeAnnotation)[0] === "Just"))
        ? ((() => {
          const $rawType = (($pattern)[2].maybeAnnotation)[1];
          const $maybeName = ($pattern)[2].maybeName;
          return ($sd0$Compiler$MakeCanonical$addRawTypeUnivars)($rawType, $acc);
        }))()
        : (true
          ? $acc
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 314:4', (sp_toHuman)($pattern))))));
});

const $sd0$Compiler$MakeCanonical$deps_init = ({
  cons: $core$Set$empty,
  types: $core$Set$empty,
  values: $core$Set$empty,
});

const $sd0$Compiler$MakeCanonical$argumentDeps = (($arg, $deps) => {
  return ((($arg)[0] === "ArgumentExpression")
    ? ((() => {
      const $e = ($arg)[1];
      return ($sd0$Compiler$MakeCanonical$expressionDeps)($e, $deps);
    }))()
    : ((($arg)[0] === "ArgumentRecycle")
      ? $deps
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 259:4', (sp_toHuman)($arg))));
});

const $sd0$Compiler$MakeCanonical$typeDeps = (($type, $acc) => {
  return ((($type)[0] === "TypeNamed")
    ? ((() => {
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return ((($0) => {
        return ($core$List$for)($0, $args, $sd0$Compiler$MakeCanonical$typeDeps);
      }))(((($1) => {
        return ($core$Set$insert)($usr, $1);
      }))($acc));
    }))()
    : ((($type)[0] === "TypeAnnotationVariable")
      ? $acc
      : ((($type)[0] === "TypeRecord")
        ? ((() => {
          const $attrs = ($type)[2];
          return ($core$Dict$for)($acc, $attrs, (($k, $v, $a) => {
            return ($sd0$Compiler$MakeCanonical$typeDeps)($v, $a);
          }));
        }))()
        : ((($type)[0] === "TypeError")
          ? $acc
          : ((($type)[0] === "TypeFn")
            ? ((() => {
              const $params = ($type)[2];
              const $to = ($type)[3];
              return ((($0) => {
                return ($core$List$for)($0, $params, (($par, $z) => {
                  return ((($par)[0] === "ParRe")
                    ? ((() => {
                      const $raw = ($par)[1];
                      return ($sd0$Compiler$MakeCanonical$typeDeps)($raw, $z);
                    }))()
                    : ((($par)[0] === "ParSp")
                      ? ((() => {
                        const $full = ($par)[1];
                        return ($sd0$Compiler$MakeCanonical$typeDeps)($full.raw, $z);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 150:16', (sp_toHuman)($par))));
                }));
              }))(((($1) => {
                return ($sd0$Compiler$MakeCanonical$typeDeps)($to.raw, $1);
              }))($acc));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 141:4', (sp_toHuman)($type)))))));
});

const $sd0$Compiler$MakeCanonical$patternDeps = (($pattern, $deps) => {
  return ((($pattern)[0] === "PatternConstructor")
    ? ((() => {
      const $usr = ($pattern)[2];
      const $ps = ($pattern)[3];
      return ($core$List$for)(((() => {
        const $0 = $deps;
        return (Object.assign)({}, $0, ({
          cons: ($core$Set$insert)($usr, $0.cons),
        }));
      }))(), $ps, $sd0$Compiler$MakeCanonical$patternDeps);
    }))()
    : ((($pattern)[0] === "PatternRecord")
      ? ((() => {
        const $completeness = ($pattern)[2];
        const $ps = ($pattern)[3];
        return ($core$Dict$for)($deps, $ps, (($k, $v, $a) => {
          return ($sd0$Compiler$MakeCanonical$patternDeps)($v, $a);
        }));
      }))()
      : (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeAnnotation)[0] === "Just"))
        ? ((() => {
          const $type = (($pattern)[2].maybeAnnotation)[1];
          const $0 = $deps;
          return (Object.assign)({}, $0, ({
            types: ($sd0$Compiler$MakeCanonical$typeDeps)($type, $0.types),
          }));
        }))()
        : (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeAnnotation)[0] === "Nothing"))
          ? $deps
          : ((($pattern)[0] === "PatternLiteralNumber")
            ? $deps
            : ((($pattern)[0] === "PatternLiteralText")
              ? $deps
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 174:4', (sp_toHuman)($pattern))))))));
});

const $sd0$Compiler$MakeCanonical$parameterDeps = (($par, $deps) => {
  return ((($par)[0] === "ParameterPattern")
    ? ((() => {
      const $pa = ($par)[2];
      return ($sd0$Compiler$MakeCanonical$patternDeps)($pa, $deps);
    }))()
    : (true
      ? $deps
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 267:4', (sp_toHuman)($par))));
});

const $sd0$Compiler$MakeCanonical$expressionDeps = (($expression, $deps) => {
  return ((($expression)[0] === "LiteralNumber")
    ? $deps
    : ((($expression)[0] === "LiteralText")
      ? $deps
      : (((($expression)[0] === "Variable") && ((($expression)[2])[0] === "RefGlobal"))
        ? ((() => {
          const $usr = (($expression)[2])[1];
          const $0 = $deps;
          return (Object.assign)({}, $0, ({
            values: ($core$Set$insert)($usr, $0.values),
          }));
        }))()
        : ((($expression)[0] === "Variable")
          ? $deps
          : ((($expression)[0] === "Constructor")
            ? ((() => {
              const $usr = ($expression)[2];
              const $0 = $deps;
              return (Object.assign)({}, $0, ({
                cons: ($core$Set$insert)($usr, $0.cons),
              }));
            }))()
            : ((($expression)[0] === "Fn")
              ? ((() => {
                const $pars = ($expression)[2];
                const $body = ($expression)[3];
                return ((($1) => {
                  return ($sd0$Compiler$MakeCanonical$expressionDeps)($body, $1);
                }))(((($0) => {
                  return ($core$List$for)($0, $pars, $sd0$Compiler$MakeCanonical$parameterDeps);
                }))($deps));
              }))()
              : (((($expression)[0] === "Record") && ((($expression)[2])[0] === "Nothing"))
                ? ((() => {
                  const $exprByName = ($expression)[3];
                  return ($core$Dict$for)($deps, $exprByName, (($name, $v, $a) => {
                    return ($sd0$Compiler$MakeCanonical$expressionDeps)($v, $a);
                  }));
                }))()
                : (((($expression)[0] === "Record") && ((($expression)[2])[0] === "Just"))
                  ? ((() => {
                    const $expr = (($expression)[2])[1];
                    const $exprByName = ($expression)[3];
                    return ((($0) => {
                      return ($core$Dict$for)($0, $exprByName, (($name, $v, $a) => {
                        return ($sd0$Compiler$MakeCanonical$expressionDeps)($v, $a);
                      }));
                    }))(((($1) => {
                      return ($sd0$Compiler$MakeCanonical$expressionDeps)($expr, $1);
                    }))($deps));
                  }))()
                  : ((($expression)[0] === "Record")
                    ? ((() => {
                      const $exprByName = ($expression)[3];
                      return ($core$Dict$for)($deps, $exprByName, (($name, $v, $a) => {
                        return ($sd0$Compiler$MakeCanonical$expressionDeps)($v, $a);
                      }));
                    }))()
                    : ((($expression)[0] === "RecordAccess")
                      ? ((() => {
                        const $e = ($expression)[3];
                        return ($sd0$Compiler$MakeCanonical$expressionDeps)($e, $deps);
                      }))()
                      : ((($expression)[0] === "Call")
                        ? ((() => {
                          const $e0 = ($expression)[2];
                          const $args = ($expression)[3];
                          return ((($0) => {
                            return ($core$List$for)($0, $args, $sd0$Compiler$MakeCanonical$argumentDeps);
                          }))(((($1) => {
                            return ($sd0$Compiler$MakeCanonical$expressionDeps)($e0, $1);
                          }))($deps));
                        }))()
                        : ((($expression)[0] === "If")
                          ? ((() => {
                            const $args = ($expression)[2];
                            return ((($1) => {
                              return ($sd0$Compiler$MakeCanonical$expressionDeps)($args.false, $1);
                            }))(((($1) => {
                              return ($sd0$Compiler$MakeCanonical$expressionDeps)($args.true, $1);
                            }))(((($1) => {
                              return ($sd0$Compiler$MakeCanonical$expressionDeps)($args.condition, $1);
                            }))($deps)));
                          }))()
                          : ((($expression)[0] === "Try")
                            ? ((() => {
                              const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                              const $value = ($expression)[2].value;
                              return ((($0) => {
                                return ($core$List$for)($0, $patternsAndExpressions, (($$b, $d) => {
                                  const $u = $$b.first;
                                  const $p = $$b.second;
                                  const $b = $$b.third;
                                  return ((($1) => {
                                    return ($sd0$Compiler$MakeCanonical$expressionDeps)($b, $1);
                                  }))(((($1) => {
                                    return ($sd0$Compiler$MakeCanonical$patternDeps)($p, $1);
                                  }))($d));
                                }));
                              }))(((($1) => {
                                return ($sd0$Compiler$MakeCanonical$expressionDeps)($value, $1);
                              }))($deps));
                            }))()
                            : ((($expression)[0] === "LetIn")
                              ? ((() => {
                                const $valueDef = ($expression)[1];
                                const $e = ($expression)[2];
                                return ((($1) => {
                                  return ($sd0$Compiler$MakeCanonical$expressionDeps)($e, $1);
                                }))(((($1) => {
                                  return ($sd0$Compiler$MakeCanonical$expressionDeps)($valueDef.body, $1);
                                }))(((($1) => {
                                  return ($sd0$Compiler$MakeCanonical$patternDeps)($valueDef.pattern, $1);
                                }))($deps)));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 198:4', (sp_toHuman)($expression))))))))))))))));
});

const $sd0$Compiler$CoreTypes$cons = ($sd0$Compiler$CoreTypes$makeUsr)("Cons");

const $sd0$Compiler$CoreTypes$nil = ($sd0$Compiler$CoreTypes$makeUsr)("Nil");

const $sd0$Compiler$MakeCanonical$translateArgument = (($env, $faExpr) => {
  return (((($faExpr)[0] === "Expression") && (((($faExpr)[2])[0] === "Unop") && ((((($faExpr)[2])[1])[0] === "UnopRecycle") && (((($faExpr)[2])[2])[0] === "Expression"))))
    ? ((() => {
      const $pos = ((($faExpr)[2])[2])[1];
      const $faOperand = ((($faExpr)[2])[2])[2];
      return ((($faOperand)[0] === "Variable")
        ? ((() => {
          const $maybeType = ($faOperand)[1].maybeType;
          const $word = ($faOperand)[1].word;
          return ((sp_not_equal)($maybeType, $core$Maybe$Nothing)
            ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Sorry, at least for now annotations are not supported here", $core$Core$Nil))
            : ((sp_not_equal)($word.maybeModule, $core$Maybe$Nothing)
              ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Only values declared inside a function scope can be mutated!", $core$Core$Nil))
              : ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("This can't start with .", $core$Core$Nil))
                : ($word.isUpper
                  ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't recycle constructors", $core$Core$Nil))
                  : ($core$Result$Ok)(($sd0$Types$CanonicalAst$ArgumentRecycle)($pos, $word.name, $word.attrPath))))));
        }))()
        : (true
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I can recycle only variables!", $core$Core$Nil))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1133:12', (sp_toHuman)($faOperand))));
    }))()
    : (true
      ? (($core$Result$onOk)((($caExpr) => {
        return ($core$Result$Ok)(($sd0$Types$CanonicalAst$ArgumentExpression)($caExpr));
      })))(((($1) => {
        return ($sd0$Compiler$MakeCanonical$translateExpression)($env, $1);
      }))($faExpr))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1131:4', (sp_toHuman)($faExpr))));
});

const $sd0$Compiler$MakeCanonical$translateArgumentsAndPlaceholders = (($pos, $env, $faArgs) => {
  const $insertArg = (($faArg, $$arity) => {
    const $arity = $$arity.arity;
    const $caArgs = $$arity.caArgs;
    const $caPars = $$arity.caPars;
    const $$faArg_ = $faArg;
    const $faArg_ = ($$faArg_)[2];
    const $pos = ($$faArg_)[1];
    return ((($faArg_)[0] === "ArgumentPlaceholder")
      ? ((() => {
        const $name = (text_fromNumber)($arity);
        return ($core$Result$Ok)(({
          arity: ($arity + 1),
          caArgs: (sp_cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$Variable)($pos, ($sd0$Types$Ast$RefLocal)($name))), $caArgs),
          caPars: (sp_cons)(($sd0$Types$CanonicalAst$ParameterPlaceholder)($name, $arity), $caPars),
        }));
      }))()
      : (true
        ? (($core$Result$onOk)((($caArg) => {
          return ($core$Result$Ok)(({
            arity: ($arity + 1),
            caArgs: (sp_cons)($caArg, $caArgs),
            caPars: $caPars,
          }));
        })))(($sd0$Compiler$MakeCanonical$translateArgument)($env, $faArg))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 915:8', (sp_toHuman)($faArg_))));
  });
  return (($core$Result$onOk)((($$arity) => {
    const $arity = $$arity.arity;
    const $caArgs = $$arity.caArgs;
    const $caPars = $$arity.caPars;
    const $wrap = ((sp_equal)($caPars, $core$Core$Nil)
      ? $core$Basics$identity
      : (($call) => {
        return ($sd0$Types$CanonicalAst$Fn)($pos, ($core$List$reverse)($caPars), $call);
      }));
    return ($core$Result$Ok)(({
      first: ($core$List$reverse)($caArgs),
      second: $wrap,
    }));
  })))(((($0) => {
    return ($core$List$forRes)($0, $faArgs, $insertArg);
  }))(({
    arity: 0,
    caArgs: $core$Core$Nil,
    caPars: $core$Core$Nil,
  })));
});

const $sd0$Compiler$MakeCanonical$notAllSeparators = (($f, $ls) => {
  return ((($ls)[0] === "Nil")
    ? false
    : ((($ls)[0] === "Cons")
      ? ((() => {
        const $sep = ($ls)[1].first;
        const $item = ($ls)[1].second;
        const $tail = ($ls)[2];
        return (($f)($sep)
          ? ($sd0$Compiler$MakeCanonical$notAllSeparators)($f, $tail)
          : true);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1235:4', (sp_toHuman)($ls))));
});

const $sd0$Compiler$MakeCanonical$sameDirectionAs = (($a, $b) => {
  return ((sp_equal)($a.symbol, $b.symbol)
    ? true
    : ((() => {
      const $$try1 = $a.symbol;
      return ((">" === $$try1)
        ? (sp_equal)($b.symbol, ">=")
        : ((">=" === $$try1)
          ? (sp_equal)($b.symbol, ">")
          : (("<" === $$try1)
            ? (sp_equal)($b.symbol, "<=")
            : (("<=" === $$try1)
              ? (sp_equal)($b.symbol, "<")
              : (true
                ? false
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1253:8', (sp_toHuman)($$try1)))))));
    }))());
});

const $sd0$Compiler$MakeCanonical$makeBinop = (($pos, $left, $op, $right) => {
  return ((sp_equal)($op.symbol, $sd0$Prelude$sendRight.symbol)
    ? ((($right)[0] === "ArgumentExpression")
      ? ((() => {
        const $ref = ($right)[1];
        return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Call)($pos, $ref, ($core$Core$Cons)($left, $core$Core$Nil)));
      }))()
      : ((($right)[0] === "ArgumentRecycle")
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't >> to a recyclable", $core$Core$Nil))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1314:8', (sp_toHuman)($right))))
    : ((sp_equal)($op.symbol, $sd0$Prelude$sendLeft.symbol)
      ? ((($left)[0] === "ArgumentExpression")
        ? ((() => {
          const $ref = ($left)[1];
          return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Call)($pos, $ref, ($core$Core$Cons)($right, $core$Core$Nil)));
        }))()
        : ((($left)[0] === "ArgumentRecycle")
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't << to a recyclable", $core$Core$Nil))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1324:8', (sp_toHuman)($left))))
      : ($core$Result$Ok)(($sd0$Types$CanonicalAst$Call)($pos, ($sd0$Types$CanonicalAst$Variable)($pos, ($sd0$Types$Ast$RefGlobal)($op.usr)), ($core$Core$Cons)($left, ($core$Core$Cons)($right, $core$Core$Nil))))));
});

const $sd0$Compiler$MakeCanonical$translateBinopSepListRec = (($env, $pos, $leftAccum, $opsAndRight) => {
  return ((($opsAndRight)[0] === "Nil")
    ? ($core$Result$Ok)($leftAccum)
    : ((($opsAndRight)[0] === "Cons")
      ? ((() => {
        const $op = ($opsAndRight)[1].first;
        const $faRight = ($opsAndRight)[1].second;
        const $tail = ($opsAndRight)[2];
        return (($core$Result$onOk)((($caRight) => {
          return (($core$Result$onOk)((($binop) => {
            return ($sd0$Compiler$MakeCanonical$translateBinopSepListRec)($env, $pos, $binop, $tail);
          })))(($sd0$Compiler$MakeCanonical$makeBinop)($pos, ($sd0$Types$CanonicalAst$ArgumentExpression)($leftAccum), $op, $caRight));
        })))(($sd0$Compiler$MakeCanonical$translateArgument)($env, $faRight));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1293:4', (sp_toHuman)($opsAndRight))));
});

const $sd0$Compiler$MakeCanonical$translateBinopSepList_leftAssociative = (($env, $pos, $leftAccum, $opsAndRight) => {
  return (($core$Result$onOk)((($caLeftAccum) => {
    return ($sd0$Compiler$MakeCanonical$translateBinopSepListRec)($env, $pos, $caLeftAccum, $opsAndRight);
  })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $leftAccum));
});

const $sd0$Compiler$MakeCanonical$translateBinopSepList_rightAssociative = (($env, $pos, $left, $opsAndRight) => {
  return (($core$Result$onOk)((($caLeft) => {
    return ((($opsAndRight)[0] === "Nil")
      ? ($core$Result$Ok)($caLeft)
      : ((($opsAndRight)[0] === "Cons")
        ? ((() => {
          const $op = ($opsAndRight)[1].first;
          const $right = ($opsAndRight)[1].second;
          const $tail = ($opsAndRight)[2];
          return (($core$Result$onOk)((($caRight) => {
            return ($sd0$Compiler$MakeCanonical$makeBinop)($pos, ($sd0$Types$CanonicalAst$ArgumentExpression)($caLeft), $op, ($sd0$Types$CanonicalAst$ArgumentExpression)($caRight));
          })))(($sd0$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env, $pos, $right, $tail));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1273:4', (sp_toHuman)($opsAndRight))));
  })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $left));
});

const $sd0$Compiler$MakeCanonical$translateSimpleBinop = (($env, $pos, $left, $op, $right) => {
  return (($core$Result$onOk)((($l) => {
    return (($core$Result$onOk)((($r) => {
      return ($sd0$Compiler$MakeCanonical$makeBinop)($pos, $l, $op, $r);
    })))(($sd0$Compiler$MakeCanonical$translateArgument)($env, $right));
  })))(($sd0$Compiler$MakeCanonical$translateArgument)($env, $left));
});

const $sd0$Compiler$MakeCanonical$translateBinops = (($env, $pos, $group, $$firstItem) => {
  const $firstItem = $$firstItem.first;
  const $firstTail = $$firstItem.second;
  return ((($firstTail)[0] === "Nil")
    ? ($sd0$Compiler$MakeCanonical$translateExpression)($env, $firstItem)
    : (((($firstTail)[0] === "Cons") && ((($firstTail)[2])[0] === "Nil"))
      ? ((() => {
        const $firstSep = ($firstTail)[1].first;
        const $secondItem = ($firstTail)[1].second;
        return ((($group)[0] === "Tuple")
          ? (($core$Result$onOk)((($first) => {
            return (($core$Result$onOk)((($second) => {
              return ($core$Result$Ok)(((($2) => {
                return ($sd0$Types$CanonicalAst$Record)($pos, $core$Maybe$Nothing, $2);
              }))(((($2) => {
                return ($core$Dict$insert)("second", $second, $2);
              }))(((($2) => {
                return ($core$Dict$insert)("first", $first, $2);
              }))($core$Dict$empty))));
            })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $secondItem));
          })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $firstItem))
          : (true
            ? ($sd0$Compiler$MakeCanonical$translateSimpleBinop)($env, $pos, $firstItem, $firstSep, $secondItem)
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1166:12', (sp_toHuman)($group))));
      }))()
      : (((($firstTail)[0] === "Cons") && ((($firstTail)[2])[0] === "Cons"))
        ? ((() => {
          const $firstSep = ($firstTail)[1].first;
          const $secondItem = ($firstTail)[1].second;
          const $secondSep = (($firstTail)[2])[1].first;
          const $thirdItem = (($firstTail)[2])[1].second;
          const $thirdTail = (($firstTail)[2])[2];
          const $secondTail = (sp_cons)(({
            first: $secondSep,
            second: $thirdItem,
          }), $thirdTail);
          return ((($group)[0] === "Comparison")
            ? (($sd0$Compiler$MakeCanonical$notAllSeparators)((($1) => {
              return ($sd0$Compiler$MakeCanonical$sameDirectionAs)($firstSep, $1);
            }), $secondTail)
              ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("can't mix comparison ops with different direction", $core$Core$Nil))
              : ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("NI compops expansion", $core$Core$Nil)))
            : ((($group)[0] === "Logical")
              ? (($sd0$Compiler$MakeCanonical$notAllSeparators)((($x) => {
                return (sp_equal)($x, $firstSep);
              }), $secondTail)
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Mixing `and` and `or` is ambiguous. Use parens!", $core$Core$Nil))
                : ($sd0$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env, $pos, $firstItem, $firstTail))
              : ((($group)[0] === "Tuple")
                ? ((sp_not_equal)($thirdTail, $core$Core$Nil)
                  ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Tuples can't have more than 3 items, use a record instead.", $core$Core$Nil))
                  : (($core$Result$onOk)((($first) => {
                    return (($core$Result$onOk)((($second) => {
                      return (($core$Result$onOk)((($third) => {
                        return ($core$Result$Ok)(((($2) => {
                          return ($sd0$Types$CanonicalAst$Record)($pos, $core$Maybe$Nothing, $2);
                        }))(((($2) => {
                          return ($core$Dict$insert)("third", $third, $2);
                        }))(((($2) => {
                          return ($core$Dict$insert)("second", $second, $2);
                        }))(((($2) => {
                          return ($core$Dict$insert)("first", $first, $2);
                        }))($core$Dict$empty)))));
                      })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $thirdItem));
                    })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $secondItem));
                  })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $firstItem)))
                : ((($group)[0] === "Pipe")
                  ? (($sd0$Compiler$MakeCanonical$notAllSeparators)((($x) => {
                    return (sp_equal)($x, $firstSep);
                  }), $secondTail)
                    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Mixing pipes is ambigous. Use parens.", $core$Core$Nil))
                    : ((sp_equal)($firstSep.associativity, $sd0$Types$Op$Right)
                      ? ($sd0$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env, $pos, $firstItem, $firstTail)
                      : ($sd0$Compiler$MakeCanonical$translateBinopSepList_leftAssociative)($env, $pos, $firstItem, $firstTail)))
                  : ((($group)[0] === "Mutop")
                    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("mutops can't be chained", $core$Core$Nil))
                    : (true
                      ? ($sd0$Compiler$MakeCanonical$translateBinopSepList_rightAssociative)($env, $pos, $firstItem, $firstTail)
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1184:12', (sp_toHuman)($group))))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1161:4', (sp_toHuman)($firstTail)))));
});

const $sd0$Compiler$MakeCanonical$translateNumber = (($constructor, $pos, $numberAsText) => {
  const $$try1 = (text_toNumber)($numberAsText);
  return ((($$try1)[0] === "Nothing")
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("invalid number: `" + ($numberAsText + "`")), ($core$Core$Cons)("TODO link to documentation on valid number formats", $core$Core$Nil)))
    : ((($$try1)[0] === "Just")
      ? ((() => {
        const $n = ($$try1)[1];
        return ($core$Result$Ok)(($constructor)($pos, $n));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1038:4', (sp_toHuman)($$try1))));
});

const $sd0$Compiler$MakeCanonical$translatePatternAny = (($env, $pos, $maybeFaType, $word) => {
  return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Record access shorthands", $core$Core$Nil))
    : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("To access attributes in pattern matching use { with theAttributeName = theVariableName }", $core$Core$Nil))
      : ((sp_not_equal)($word.maybeModule, $core$Maybe$Nothing)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("You can't access modules here...", $core$Core$Nil))
        : ((() => {
          const $resultMaybeRaw = ((($maybeFaType)[0] === "Just")
            ? ((() => {
              const $faType = ($maybeFaType)[1];
              return ((($1) => {
                return ($core$Result$map)($core$Maybe$Just, $1);
              }))(((($1) => {
                return ($sd0$Compiler$MakeCanonical$translateRawType)($env.ro, $1);
              }))($faType));
            }))()
            : ((($maybeFaType)[0] === "Nothing")
              ? ($core$Result$Ok)($core$Maybe$Nothing)
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 433:12', (sp_toHuman)($maybeFaType))));
          return (($core$Result$onOk)((($maybeRaw) => {
            const $maybeName = ((sp_equal)($word.name, "_")
              ? $core$Maybe$Nothing
              : ($core$Maybe$Just)($word.name));
            return ($core$Result$Ok)(($sd0$Types$CanonicalAst$PatternAny)($pos, ({
              maybeAnnotation: $maybeRaw,
              maybeName: $maybeName,
            })));
          })))($resultMaybeRaw);
        }))())));
});

const $sd0$Compiler$MakeCanonical$resolveToConstructorUsr = (($1, $2, $3) => {
  return ($sd0$Compiler$MakeCanonical$resolveToUsr)((($m) => {
    return $m.globalValues;
  }), $1, $2, $3);
});

const $sd0$Compiler$MakeCanonical$translatePatternConstructor = (($env, $pos, $word, $args) => {
  return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Constructor names cannot have modifiers", $core$Core$Nil))
    : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Constructors don't have attributes", $core$Core$Nil))
      : ($core$Result$Ok)(((($2) => {
        return ($sd0$Types$CanonicalAst$PatternConstructor)($pos, ($sd0$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro, $word.maybeModule, $word.name), $2);
      }))($args))));
});

const $sd0$Compiler$MakeCanonical$insertAttribute = (($env, $attr, $caAttrs) => {
  return (($core$Result$onOk)((($$caName) => {
    const $pos = $$caName.first;
    const $caName = $$caName.second;
    const $maybeFaType = $$caName.third;
    return (($core$Dict$member)($caName, $caAttrs)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("duplicate attribute name in pattern: " + $caName), $core$Core$Nil))
      : ((() => {
        const $$try1 = ({
          first: $attr.maybeExpr,
          second: $maybeFaType,
        });
        return (((($$try1.first)[0] === "Just") && ((($$try1.second)[0] === "Just") && ((($$try1.second)[1])[0] === "Expression")))
          ? ((() => {
            const $typePos = (($$try1.second)[1])[1];
            return ($sd0$Compiler$MakeCanonical$error)($typePos, ($core$Core$Cons)("if you want to annotate the attribute, use { x = y as TheType }", $core$Core$Nil));
          }))()
          : (((($$try1.first)[0] === "Nothing") && (($$try1.second)[0] === "Just"))
            ? ((() => {
              const $faType = ($$try1.second)[1];
              return (($core$Result$onOk)((($caType) => {
                return ($core$Result$Ok)(((($2) => {
                  return ($core$Dict$insert)($caName, ($sd0$Types$CanonicalAst$PatternAny)($pos, ({
                    maybeAnnotation: ($core$Maybe$Just)($caType),
                    maybeName: ($core$Maybe$Just)($caName),
                  })), $2);
                }))($caAttrs));
              })))(($sd0$Compiler$MakeCanonical$translateRawType)($env.ro, $faType));
            }))()
            : (((($$try1.first)[0] === "Just") && (($$try1.second)[0] === "Nothing"))
              ? ((() => {
                const $faPattern = ($$try1.first)[1];
                return (($core$Result$onOk)((($caPattern) => {
                  return ($core$Result$Ok)(((($2) => {
                    return ($core$Dict$insert)($caName, $caPattern, $2);
                  }))($caAttrs));
                })))(((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $1);
                }))($faPattern));
              }))()
              : (((($$try1.first)[0] === "Nothing") && (($$try1.second)[0] === "Nothing"))
                ? ($core$Result$Ok)(((($2) => {
                  return ($core$Dict$insert)($caName, ($sd0$Types$CanonicalAst$PatternAny)($pos, ({
                    maybeAnnotation: $core$Maybe$Nothing,
                    maybeName: ($core$Maybe$Just)($caName),
                  })), $2);
                }))($caAttrs))
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 465:8', (sp_toHuman)($$try1))))));
      }))());
  })))(($sd0$Compiler$MakeCanonical$translateAttributeName)($attr.name));
});

const $sd0$Compiler$MakeCanonical$translatePatternRecord = (($env, $pos, $maybeMaybeExt, $attrs) => {
  const $zzz = (((($maybeMaybeExt)[0] === "Just") && (((($maybeMaybeExt)[1])[0] === "Just") && (((($maybeMaybeExt)[1])[1])[0] === "Expression")))
    ? ((() => {
      const $p = ((($maybeMaybeExt)[1])[1])[1];
      const $expr_ = ((($maybeMaybeExt)[1])[1])[2];
      return ($sd0$Compiler$MakeCanonical$error)($p, ($core$Core$Cons)("Can't extend patterns", $core$Core$Nil));
    }))()
    : (((($maybeMaybeExt)[0] === "Just") && ((($maybeMaybeExt)[1])[0] === "Nothing"))
      ? ($core$Result$Ok)($sd0$Types$CanonicalAst$Partial)
      : ((($maybeMaybeExt)[0] === "Nothing")
        ? ($core$Result$Ok)($sd0$Types$CanonicalAst$Complete)
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 496:8', (sp_toHuman)($maybeMaybeExt)))));
  return (($core$Result$onOk)((($completeness) => {
    return ((($1) => {
      return ($core$Result$map)((($x) => {
        return ($sd0$Types$CanonicalAst$PatternRecord)($pos, $completeness, $x);
      }), $1);
    }))(((($0) => {
      return ($core$List$forRes)($0, $attrs, (($1, $2) => {
        return ($sd0$Compiler$MakeCanonical$insertAttribute)($env, $1, $2);
      }));
    }))($core$Dict$empty));
  })))($zzz);
});

const $sd0$Types$CanonicalAst$patternPos = (($pa) => {
  return ((($pa)[0] === "PatternAny")
    ? ((() => {
      const $p = ($pa)[1];
      return $p;
    }))()
    : ((($pa)[0] === "PatternLiteralText")
      ? ((() => {
        const $p = ($pa)[1];
        return $p;
      }))()
      : ((($pa)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $p = ($pa)[1];
          return $p;
        }))()
        : ((($pa)[0] === "PatternConstructor")
          ? ((() => {
            const $p = ($pa)[1];
            return $p;
          }))()
          : ((($pa)[0] === "PatternRecord")
            ? ((() => {
              const $p = ($pa)[1];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/CanonicalAst.sp 193:4', (sp_toHuman)($pa)))))));
});

const $sd0$Compiler$MakeCanonical$translateRawPattern = (($env, $$expr_) => {
  const $pos = ($$expr_)[1];
  const $expr_ = ($$expr_)[2];
  return ((($expr_)[0] === "Variable")
    ? ((() => {
      const $maybeType = ($expr_)[1].maybeType;
      const $word = ($expr_)[1].word;
      return ($word.isUpper
        ? ((sp_not_equal)($maybeType, $core$Maybe$Nothing)
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Pattern constructors can't have type annotations", $core$Core$Nil))
          : ($sd0$Compiler$MakeCanonical$translatePatternConstructor)($env, $pos, $word, $core$Core$Nil))
        : ($sd0$Compiler$MakeCanonical$translatePatternAny)($env, $pos, $maybeType, $word));
    }))()
    : (((($expr_)[0] === "Call") && ((($expr_)[1])[0] === "Expression"))
      ? ((() => {
        const $pos = (($expr_)[1])[1];
        const $ref = (($expr_)[1])[2];
        const $faArgs = ($expr_)[2];
        return ((($ref)[0] === "Variable")
          ? ((() => {
            const $maybeType = ($ref)[1].maybeType;
            const $word = ($ref)[1].word;
            return (($core$Basics$not)($word.isUpper)
              ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I need an uppercase constructor name here", $core$Core$Nil))
              : ((sp_not_equal)($maybeType, $core$Maybe$Nothing)
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Constructors can't be annotated (yet? would it make sense?)", $core$Core$Nil))
                : (($core$Result$onOk)((($caPars) => {
                  return ($sd0$Compiler$MakeCanonical$translatePatternConstructor)($env, $pos, $word, $caPars);
                })))(((($1) => {
                  return ($core$List$mapRes)((($1) => {
                    return ($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $1);
                  }), $1);
                }))($faArgs))));
          }))()
          : (true
            ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I was expecting a constructor name here", $core$Core$Nil))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 577:12', (sp_toHuman)($ref))));
      }))()
      : ((($expr_)[0] === "List")
        ? ((() => {
          const $faItems = ($expr_)[1];
          const $reversedFaItems = ($core$List$reverse)($faItems);
          const $pushItem = (($pattern, $last) => {
            return ($sd0$Types$CanonicalAst$PatternConstructor)(($sd0$Types$CanonicalAst$patternPos)($pattern), $sd0$Compiler$CoreTypes$cons, ($core$Core$Cons)($pattern, ($core$Core$Cons)($last, $core$Core$Nil)));
          });
          return ((($reversedFaItems)[0] === "Nil")
            ? ($core$Result$Ok)(($sd0$Types$CanonicalAst$PatternConstructor)($pos, $sd0$Compiler$CoreTypes$nil, $core$Core$Nil))
            : (((($reversedFaItems)[0] === "Cons") && ((($reversedFaItems)[1].second)[0] === "Expression"))
              ? ((() => {
                const $lastHasDots = ($reversedFaItems)[1].first;
                const $pos = (($reversedFaItems)[1].second)[1];
                const $lastFaExpr = (($reversedFaItems)[1].second)[2];
                const $reversedFaRest = ($reversedFaItems)[2];
                return (($core$List$any)($core$Tuple$first, $reversedFaRest)
                  ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("only the last item in a list can have ... triple dots", $core$Core$Nil))
                  : (($core$Basics$not)($lastHasDots)
                    ? (($core$Result$onOk)((($reversedCaItems) => {
                      return ($core$Result$Ok)(($core$List$for)(($sd0$Types$CanonicalAst$PatternConstructor)($pos, $sd0$Compiler$CoreTypes$nil, $core$Core$Nil), $reversedCaItems, $pushItem));
                    })))(((($1) => {
                      return ($core$List$mapRes)((($$expr) => {
                        const $hasDots = $$expr.first;
                        const $expr = $$expr.second;
                        return ($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $expr);
                      }), $1);
                    }))($reversedFaItems))
                    : (($core$Result$onOk)((($reversedCaRest) => {
                      return ((($lastFaExpr)[0] === "Variable")
                        ? ((() => {
                          const $maybeType = ($lastFaExpr)[1].maybeType;
                          const $word = ($lastFaExpr)[1].word;
                          return (($core$Result$onOk)((($caInit) => {
                            return ($core$Result$Ok)(($core$List$for)($caInit, $reversedCaRest, $pushItem));
                          })))(($sd0$Compiler$MakeCanonical$translatePatternAny)($env, $pos, $maybeType, $word));
                        }))()
                        : (true
                          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("sorry, I don't understand the dots here...", $core$Core$Nil))
                          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 623:24', (sp_toHuman)($lastFaExpr))));
                    })))(((($1) => {
                      return ($core$List$mapRes)((($$expr) => {
                        const $hasDots = $$expr.first;
                        const $expr = $$expr.second;
                        return ($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $expr);
                      }), $1);
                    }))($reversedFaRest))));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 601:12', (sp_toHuman)($reversedFaItems))));
        }))()
        : ((($expr_)[0] === "Record")
          ? ((() => {
            const $attrs = ($expr_)[1].attrs;
            const $maybeExtension = ($expr_)[1].maybeExtension;
            return ($sd0$Compiler$MakeCanonical$translatePatternRecord)($env, $pos, $maybeExtension, $attrs);
          }))()
          : (((($expr_)[0] === "Binop") && ((($expr_)[1])[0] === "Tuple"))
            ? ((() => {
              const $sepList = ($expr_)[2];
              return (($core$Result$onOk)((($recordAttrs) => {
                return ($core$Result$Ok)(($sd0$Types$CanonicalAst$PatternRecord)($pos, $sd0$Types$CanonicalAst$Complete, $recordAttrs));
              })))(((($1) => {
                return ($sd0$Compiler$MakeCanonical$translateTuple)((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $1);
                }), $1);
              }))($sepList));
            }))()
            : (((($expr_)[0] === "Binop") && ((($expr_)[1])[0] === "Cons"))
              ? ((() => {
                const $sepList = ($expr_)[2];
                return (($core$Result$onOk)((($caPas) => {
                  const $$try1 = ($core$List$reverse)($caPas);
                  return ((($$try1)[0] === "Cons")
                    ? ((() => {
                      const $last = ($$try1)[1];
                      const $rest = ($$try1)[2];
                      return ($core$Result$Ok)(((($0) => {
                        return ($core$List$for)($0, $rest, (($item, $list) => {
                          return ($sd0$Types$CanonicalAst$PatternConstructor)($pos, $sd0$Compiler$CoreTypes$cons, ($core$Core$Cons)($item, ($core$Core$Cons)($list, $core$Core$Nil)));
                        }));
                      }))($last));
                    }))()
                    : ((($$try1)[0] === "Nil")
                      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("should not happen: empty cons pattern", $core$Core$Nil))
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 650:12', (sp_toHuman)($$try1))));
                })))(((($1) => {
                  return ($core$List$mapRes)((($1) => {
                    return ($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $1);
                  }), $1);
                }))(($sd0$Types$FormattableAst$sepToList)($sepList)));
              }))()
              : ((($expr_)[0] === "Binop")
                ? ((() => {
                  const $opPrecedence = ($expr_)[1];
                  const $sepList = ($expr_)[2];
                  return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("This binop can't be used in pattern matching", $core$Core$Nil));
                }))()
                : ((($expr_)[0] === "LiteralText")
                  ? ((() => {
                    const $l = ($expr_)[1];
                    return ($core$Result$Ok)(($sd0$Types$CanonicalAst$PatternLiteralText)($pos, $l));
                  }))()
                  : ((($expr_)[0] === "LiteralNumber")
                    ? ((() => {
                      const $l = ($expr_)[1];
                      return ($sd0$Compiler$MakeCanonical$translateNumber)($sd0$Types$CanonicalAst$PatternLiteralNumber, $pos, $l);
                    }))()
                    : ((($expr_)[0] === "Statements")
                      ? ((() => {
                        const $stats = ($expr_)[1];
                        return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("WAT", $core$Core$Nil));
                      }))()
                      : ((($expr_)[0] === "Fn")
                        ? ((() => {
                          const $args = ($expr_)[1];
                          const $body = ($expr_)[2];
                          return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't pattern match on functions. =(", $core$Core$Nil));
                        }))()
                        : ((($expr_)[0] === "Unop")
                          ? ((() => {
                            const $unop = ($expr_)[1];
                            const $expr = ($expr_)[2];
                            return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("This op can't be used in pattern matching", $core$Core$Nil));
                          }))()
                          : ((($expr_)[0] === "If")
                            ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("if..then can't be used in pattern matching", $core$Core$Nil))
                            : ((($expr_)[0] === "Try")
                              ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("try..as can't be used in pattern matching", $core$Core$Nil))
                              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 564:4', (sp_toHuman)($expr_))))))))))))))));
});

const $sd0$Compiler$MakeCanonical$translateFullPattern = (($env, $expr) => {
  return (($core$Result$onOk)((($$e) => {
    const $uni = $$e.first;
    const $e = $$e.second;
    return (($core$Result$onOk)((($caPa) => {
      return ($core$Result$Ok)(({
        first: $uni,
        second: $caPa,
      }));
    })))(($sd0$Compiler$MakeCanonical$translateRawPattern)($env, $e));
  })))(((($0) => {
    return ($sd0$Compiler$MakeCanonical$translatePoly)($0);
  }))($expr));
});

const $sd0$Compiler$MakeCanonical$translateParameter = (($env, $fa) => {
  const $$faExpr = $fa;
  const $faExpr = ($$faExpr)[2];
  const $pos = ($$faExpr)[1];
  const $maybeRecycle = (((($faExpr)[0] === "Unop") && (((($faExpr)[1])[0] === "UnopRecycle") && ((($faExpr)[2])[0] === "Expression")))
    ? ((() => {
      const $p = (($faExpr)[2])[1];
      const $faOperand = (($faExpr)[2])[2];
      return (((($faOperand)[0] === "Variable") && ((($faOperand)[1].maybeType)[0] === "Nothing"))
        ? ((() => {
          const $word = ($faOperand)[1].word;
          return ($core$Result$Ok)(($core$Maybe$Just)($word));
        }))()
        : (true
          ? ($sd0$Compiler$MakeCanonical$error)($p, ($core$Core$Cons)("@ should be followed by a variable name to recycle!", $core$Core$Nil))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1005:16', (sp_toHuman)($faOperand))));
    }))()
    : (true
      ? ($core$Result$Ok)($core$Maybe$Nothing)
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1003:8', (sp_toHuman)($faExpr))));
  return (($core$Result$onOk)((($maybeWord) => {
    return ((($maybeWord)[0] === "Just")
      ? ((() => {
        const $word = ($maybeWord)[1];
        const $isValid = ((sp_equal)($word.modifier, $sd0$Types$Token$NameNoModifier) && (($core$Basics$not)($word.isUpper) && ((sp_equal)($word.maybeModule, $core$Maybe$Nothing) && (sp_equal)($word.attrPath, $core$Core$Nil))));
        return (($core$Basics$not)($isValid)
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I was expecting a local variable name here... =|", $core$Core$Nil))
          : ($core$Result$Ok)(($sd0$Types$CanonicalAst$ParameterRecycle)($pos, $word.name)));
      }))()
      : ((($maybeWord)[0] === "Nothing")
        ? (($core$Result$onOk)((($$ca) => {
          const $uni = $$ca.first;
          const $ca = $$ca.second;
          return ($core$Result$Ok)(($sd0$Types$CanonicalAst$ParameterPattern)($uni, $ca));
        })))(($sd0$Compiler$MakeCanonical$translateFullPattern)($env, $fa))
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1017:4', (sp_toHuman)($maybeWord))));
  })))($maybeRecycle);
});

const $sd0$Compiler$MakeCanonical$translateAndInsertRecordAttribute = (($env, $attr, $caAttrsAccum) => {
  return (($core$Result$onOk)((($$caName) => {
    const $pos = $$caName.first;
    const $caName = $$caName.second;
    const $maybeFaType = $$caName.third;
    return (($core$Dict$member)($caName, $caAttrsAccum)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("duplicate attribute: " + $caName), $core$Core$Nil))
      : (($core$Result$onOk)((($caExpr) => {
        return ($core$Result$Ok)(((($2) => {
          return ($core$Dict$insert)($caName, $caExpr, $2);
        }))($caAttrsAccum));
      })))(((($1) => {
        return ($sd0$Compiler$MakeCanonical$translateExpression)($env, $1);
      }))(((($1) => {
        return ($core$Maybe$withDefault)($attr.name, $1);
      }))($attr.maybeExpr))));
  })))(($sd0$Compiler$MakeCanonical$translateAttributeName)($attr.name));
});

const $sd0$Compiler$MakeCanonical$translateRecord = (($env, $pos, $maybeMaybeExtension, $attrs) => {
  const $zzz = (((($maybeMaybeExtension)[0] === "Just") && ((($maybeMaybeExtension)[1])[0] === "Just"))
    ? ((() => {
      const $ext = (($maybeMaybeExtension)[1])[1];
      return ((($1) => {
        return ($core$Result$map)($core$Maybe$Just, $1);
      }))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $ext));
    }))()
    : (((($maybeMaybeExtension)[0] === "Just") && ((($maybeMaybeExtension)[1])[0] === "Nothing"))
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("I need to know what record you are updating", $core$Core$Nil))
      : ((($maybeMaybeExtension)[0] === "Nothing")
        ? ($core$Result$Ok)($core$Maybe$Nothing)
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1053:8', (sp_toHuman)($maybeMaybeExtension)))));
  return (($core$Result$onOk)((($maybeCaExt) => {
    return ((($maybeCaExt)[0] === "Nothing")
      ? (($core$Result$onOk)((($caAttrs) => {
        return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Record)($pos, $core$Maybe$Nothing, $caAttrs));
      })))(((($0) => {
        return ($core$List$forRes)($0, $attrs, (($1, $2) => {
          return ($sd0$Compiler$MakeCanonical$translateAndInsertRecordAttribute)(((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              maybeShorthandTarget: $core$Maybe$Nothing,
            }));
          }))(), $1, $2);
        }));
      }))($core$Dict$empty))
      : ((($maybeCaExt)[0] === "Just")
        ? ((() => {
          const $caExt = ($maybeCaExt)[1];
          const $varName = (text_fromNumber)($env.nextGeneratedVariableName);
          const $var = ($sd0$Types$CanonicalAst$Variable)($sd0$Types$Pos$G, ($sd0$Types$Ast$RefLocal)($varName));
          const $newEnv = ((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              maybeShorthandTarget: ($core$Maybe$Just)($var),
              nextGeneratedVariableName: ($0.nextGeneratedVariableName + 1),
            }));
          }))();
          return (($core$Result$onOk)((($caAttrs) => {
            const $def = ({
              body: $caExt,
              directConsDeps: $core$Dict$empty,
              directTypeDeps: $core$Dict$empty,
              directValueDeps: $core$Dict$empty,
              native: false,
              pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Types$Pos$G, ({
                maybeAnnotation: $core$Maybe$Nothing,
                maybeName: ($core$Maybe$Just)($varName),
              })),
              tyvars: $core$Dict$empty,
              uni: $sd0$Types$Ast$Imm,
              univars: $core$Dict$empty,
            });
            return ($core$Result$Ok)(((($1) => {
              return ($sd0$Types$CanonicalAst$LetIn)($def, $1);
            }))(((($2) => {
              return ($sd0$Types$CanonicalAst$Record)($pos, ($core$Maybe$Just)($var), $2);
            }))($caAttrs)));
          })))(((($0) => {
            return ($core$List$forRes)($0, $attrs, (($1, $2) => {
              return ($sd0$Compiler$MakeCanonical$translateAndInsertRecordAttribute)($newEnv, $1, $2);
            }));
          }))($core$Dict$empty));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1061:4', (sp_toHuman)($maybeCaExt))));
  })))($zzz);
});

const $sd0$Compiler$CoreTypes$noneValue = ($sd0$Compiler$CoreTypes$makeUsr)($sd0$Compiler$CoreTypes$noneName);

const $sd0$Types$CanonicalAst$patternNames = (($p) => {
  return (((($p)[0] === "PatternAny") && ((($p)[2].maybeName)[0] === "Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return $core$Dict$empty;
    }))()
    : (((($p)[0] === "PatternAny") && ((($p)[2].maybeName)[0] === "Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $maybeAnnotation = ($p)[2].maybeAnnotation;
        const $n = (($p)[2].maybeName)[1];
        return ($core$Dict$ofOne)($n, ({
          maybeAnnotation: $maybeAnnotation,
          pos: $pos,
        }));
      }))()
      : ((($p)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return $core$Dict$empty;
        }))()
        : ((($p)[0] === "PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return $core$Dict$empty;
          }))()
          : ((($p)[0] === "PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $path = ($p)[2];
              const $ps = ($p)[3];
              return ($core$List$for)($core$Dict$empty, $ps, (($x, $a) => {
                return ((($1) => {
                  return ($core$Dict$join)($a, $1);
                }))(($sd0$Types$CanonicalAst$patternNames)($x));
              }));
            }))()
            : ((($p)[0] === "PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[3];
                return ($core$Dict$for)($core$Dict$empty, $ps, (($k, $v, $a) => {
                  return ((($1) => {
                    return ($core$Dict$join)($a, $1);
                  }))(($sd0$Types$CanonicalAst$patternNames)($v));
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/CanonicalAst.sp 214:4', (sp_toHuman)($p))))))));
});

const $sd0$Compiler$MakeCanonical$translateStatements = (($env, $stats) => {
  return ((($stats)[0] === "Nil")
    ? ($core$Result$Ok)(((($1) => {
      return ($sd0$Types$CanonicalAst$Constructor)($sd0$Types$Pos$G, $1);
    }))($sd0$Compiler$CoreTypes$noneValue))
    : (((($stats)[0] === "Cons") && (((($stats)[1])[0] === "Evaluation") && ((($stats)[2])[0] === "Nil")))
      ? ((() => {
        const $faExpression = (($stats)[1])[1];
        return ($sd0$Compiler$MakeCanonical$translateExpression)($env, $faExpression);
      }))()
      : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "Evaluation"))
        ? ((() => {
          const $faExpr = (($stats)[1])[1];
          const $tail = ($stats)[2];
          return (($core$Result$onOk)((($caExpr) => {
            const $caDef = ({
              body: $caExpr,
              directConsDeps: $core$Dict$empty,
              directTypeDeps: $core$Dict$empty,
              directValueDeps: $core$Dict$empty,
              native: false,
              pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Types$Pos$G, ({
                maybeAnnotation: $core$Maybe$Nothing,
                maybeName: $core$Maybe$Nothing,
              })),
              tyvars: $core$Dict$empty,
              uni: $sd0$Types$Ast$Imm,
              univars: $core$Dict$empty,
            });
            return (($core$Result$onOk)((($acc) => {
              return ($core$Result$Ok)(($sd0$Types$CanonicalAst$LetIn)($caDef, $acc));
            })))(((($1) => {
              return ($sd0$Compiler$MakeCanonical$translateStatements)($env, $1);
            }))($tail));
          })))(((($1) => {
            return ($sd0$Compiler$MakeCanonical$translateExpression)($env, $1);
          }))($faExpr));
        }))()
        : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "ValueDef"))
          ? ((() => {
            const $fa = (($stats)[1])[1];
            const $tail = ($stats)[2];
            return (($core$Result$onOk)((($caDef) => {
              const $newEnv = ((() => {
                const $0 = $env;
                return (Object.assign)({}, $0, ({
                  nonRootValues: ($core$Dict$join)(($sd0$Types$CanonicalAst$patternNames)($caDef.pattern), $0.nonRootValues),
                }));
              }))();
              return (($core$Result$onOk)((($acc) => {
                return ($core$Result$Ok)(($sd0$Types$CanonicalAst$LetIn)($caDef, $acc));
              })))(((($1) => {
                return ($sd0$Compiler$MakeCanonical$translateStatements)($newEnv, $1);
              }))($tail));
            })))(((($2) => {
              return ($sd0$Compiler$MakeCanonical$translateDefinition)(false, $env, $2);
            }))($fa));
          }))()
          : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "AliasDef"))
            ? ((() => {
              const $fa = (($stats)[1])[1];
              const $tail = ($stats)[2];
              const $$pos = $fa.name;
              const $pos = ($$pos)[1];
              return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Aliases can be declared only in the root scope", $core$Core$Nil));
            }))()
            : (((($stats)[0] === "Cons") && ((($stats)[1])[0] === "UnionDef"))
              ? ((() => {
                const $fa = (($stats)[1])[1];
                const $tail = ($stats)[2];
                const $$pos = $fa.name;
                const $pos = ($$pos)[1];
                return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Types can be declared only in the root scope", $core$Core$Nil));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 692:4', (sp_toHuman)($stats))))))));
});

const $sd0$Compiler$MakeCanonical$resolveToValueRef = (($ro, $declaredInsideFunction, $maybeModule, $name) => {
  const $$try1 = ($sd0$Compiler$MakeCanonical$maybeForeignUsr)((($m) => {
    return $m.globalValues;
  }), $ro, $maybeModule, $name);
  return ((($$try1)[0] === "Just")
    ? ((() => {
      const $usr = ($$try1)[1];
      return ($sd0$Types$Ast$RefGlobal)($usr);
    }))()
    : ((($$try1)[0] === "Nothing")
      ? ($declaredInsideFunction
        ? ($sd0$Types$Ast$RefLocal)($name)
        : ($sd0$Types$Ast$RefGlobal)(($sd0$Types$Meta$USR)($ro.currentModule, $name)))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 114:4', (sp_toHuman)($$try1))));
});

const $sd0$Compiler$MakeCanonical$translateVariable = (($env, $pos, $maybeType, $word) => {
  const $$try1 = $word.modifier;
  return ((($$try1)[0] === "NameStartsWithDot")
    ? (($word.isUpper || (sp_not_equal)($word.maybeModule, $core$Maybe$Nothing))
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("record attribute names must start with a lowercase letter", $core$Core$Nil))
      : ((() => {
        const $$try2 = $env.maybeShorthandTarget;
        return ((($$try2)[0] === "Nothing")
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Record update shorthands must be used inside a record update such as", ($core$Core$Cons)(("    { aRecord with anAttribute = doSomethingWith ." + (($core$Text$join)(".", $word.attrPath) + " }")), ($core$Core$Cons)("but we are not inside a record update!", $core$Core$Nil))))
          : ((($$try2)[0] === "Just")
            ? ((() => {
              const $shorthandTarget = ($$try2)[1];
              return ($core$Result$Ok)(((($0) => {
                return ($core$List$for)($0, (sp_cons)($word.name, $word.attrPath), (($attrName, $expr) => {
                  return ($sd0$Types$CanonicalAst$RecordAccess)($pos, $attrName, $expr);
                }));
              }))($shorthandTarget));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 965:16', (sp_toHuman)($$try2))));
      }))())
    : ((($$try1)[0] === "NameNoModifier")
      ? ($word.isUpper
        ? ((sp_not_equal)($word.attrPath, $core$Core$Nil)
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("something's wrong with the lexer?", $core$Core$Nil))
          : ($core$Result$Ok)(((($1) => {
            return ($sd0$Types$CanonicalAst$Constructor)($pos, $1);
          }))(($sd0$Compiler$MakeCanonical$resolveToConstructorUsr)($env.ro, $word.maybeModule, $word.name))))
        : ((() => {
          const $declaredInsideFunction = ($core$Dict$member)($word.name, $env.nonRootValues);
          return ($core$Result$Ok)(((($0) => {
            return ($core$List$for)($0, $word.attrPath, (($1, $2) => {
              return ($sd0$Types$CanonicalAst$RecordAccess)($pos, $1, $2);
            }));
          }))(((($1) => {
            return ($sd0$Types$CanonicalAst$Variable)($pos, $1);
          }))(($sd0$Compiler$MakeCanonical$resolveToValueRef)($env.ro, $declaredInsideFunction, $word.maybeModule, $word.name))));
        }))())
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 960:4', (sp_toHuman)($$try1))));
});

const $sd0$Prelude$unaryMinus = ({
  symbol: "0 -",
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)($sd0$Compiler$CoreTypes$number, $core$Core$Nil), $sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$numberUsr)("unaryMinus"),
});

const $sd0$Compiler$MakeCanonical$translateExpression = (($env, $$expr_) => {
  const $pos = ($$expr_)[1];
  const $expr_ = ($$expr_)[2];
  return ((($expr_)[0] === "LiteralNumber")
    ? ((() => {
      const $str = ($expr_)[1];
      return ($sd0$Compiler$MakeCanonical$translateNumber)($sd0$Types$CanonicalAst$LiteralNumber, $pos, $str);
    }))()
    : ((($expr_)[0] === "LiteralText")
      ? ((() => {
        const $v = ($expr_)[1];
        return ($core$Result$Ok)(($sd0$Types$CanonicalAst$LiteralText)($pos, $v));
      }))()
      : ((($expr_)[0] === "Statements")
        ? ((() => {
          const $stats = ($expr_)[1];
          return ($sd0$Compiler$MakeCanonical$translateStatements)($env, $stats);
        }))()
        : ((($expr_)[0] === "Variable")
          ? ((() => {
            const $maybeType = ($expr_)[1].maybeType;
            const $word = ($expr_)[1].word;
            return ($sd0$Compiler$MakeCanonical$translateVariable)($env, $pos, $maybeType, $word);
          }))()
          : ((($expr_)[0] === "Fn")
            ? ((() => {
              const $faParams = ($expr_)[1];
              const $faBody = ($expr_)[2];
              return (($core$Result$onOk)((($caParams) => {
                const $zzz = ((($0) => {
                  return ($core$List$forRes)($0, $caParams, (($par, $envX) => {
                    const $names = ((($par)[0] === "ParameterPattern")
                      ? ((() => {
                        const $uni = ($par)[1];
                        const $pa = ($par)[2];
                        return ($sd0$Types$CanonicalAst$patternNames)($pa);
                      }))()
                      : ((($par)[0] === "ParameterRecycle")
                        ? ((() => {
                          const $name = ($par)[2];
                          return ($core$Dict$ofOne)($name, ({
                            maybeAnnotation: $core$Maybe$Nothing,
                            pos: $pos,
                          }));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 779:24', (sp_toHuman)($par))));
                    const $duplicates = ($core$Dict$keys)(($core$Dict$intersect)($names, $envX.nonRootValues));
                    return ((sp_not_equal)($duplicates, $core$Core$Nil)
                      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(("parameters shadows these values: " + ($core$Text$join)(",", $duplicates)), $core$Core$Nil))
                      : ($core$Result$Ok)(((() => {
                        const $0 = $envX;
                        return (Object.assign)({}, $0, ({
                          nonRootValues: ($core$Dict$join)($names, $0.nonRootValues),
                        }));
                      }))()));
                  }));
                }))($env);
                return (($core$Result$onOk)((($localEnv) => {
                  return (($core$Result$onOk)((($caBody) => {
                    return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Fn)($pos, $caParams, $caBody));
                  })))(((($1) => {
                    return ($sd0$Compiler$MakeCanonical$translateExpression)($localEnv, $1);
                  }))($faBody));
                })))($zzz);
              })))(((($1) => {
                return ($core$List$mapRes)((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateParameter)($env, $1);
                }), $1);
              }))($faParams));
            }))()
            : ((($expr_)[0] === "Call")
              ? ((() => {
                const $faRef = ($expr_)[1];
                const $faArgs = ($expr_)[2];
                return (($core$Result$onOk)((($caRef) => {
                  return (($core$Result$onOk)((($$caArgs) => {
                    const $caArgs = $$caArgs.first;
                    const $wrap = $$caArgs.second;
                    return ($core$Result$Ok)(($wrap)(($sd0$Types$CanonicalAst$Call)($pos, $caRef, $caArgs)));
                  })))(((($2) => {
                    return ($sd0$Compiler$MakeCanonical$translateArgumentsAndPlaceholders)($pos, $env, $2);
                  }))($faArgs));
                })))(((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateExpression)($env, $1);
                }))($faRef));
              }))()
              : ((($expr_)[0] === "If")
                ? ((() => {
                  const $condition = ($expr_)[1].condition;
                  const $false = ($expr_)[1].false;
                  const $true = ($expr_)[1].true;
                  return (($core$Result$onOk)((($c) => {
                    return (($core$Result$onOk)((($t) => {
                      return (($core$Result$onOk)((($f) => {
                        return ($core$Result$Ok)(((($1) => {
                          return ($sd0$Types$CanonicalAst$If)($pos, $1);
                        }))(({
                          condition: $c,
                          false: $f,
                          true: $t,
                        })));
                      })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $false));
                    })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $true));
                  })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $condition));
                }))()
                : ((($expr_)[0] === "Unop")
                  ? ((() => {
                    const $opId = ($expr_)[1];
                    const $faOperand = ($expr_)[2];
                    return ((($opId)[0] === "UnopUnique")
                      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("can't use ! here because REASONS", $core$Core$Nil))
                      : ((($opId)[0] === "UnopRecycle")
                        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("can recycle only in function calls!", $core$Core$Nil))
                        : ((($opId)[0] === "UnopPlus")
                          ? ($sd0$Compiler$MakeCanonical$translateExpression)($env, $faOperand)
                          : ((($opId)[0] === "UnopMinus")
                            ? (($core$Result$onOk)((($caOperand) => {
                              return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Call)($pos, ($sd0$Types$CanonicalAst$Variable)($pos, ($sd0$Types$Ast$RefGlobal)($sd0$Prelude$unaryMinus.usr)), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)($caOperand), $core$Core$Nil)));
                            })))(((($1) => {
                              return ($sd0$Compiler$MakeCanonical$translateExpression)($env, $1);
                            }))($faOperand))
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 827:12', (sp_toHuman)($opId))))));
                  }))()
                  : ((($expr_)[0] === "Binop")
                    ? ((() => {
                      const $group = ($expr_)[1];
                      const $sepList = ($expr_)[2];
                      return ($sd0$Compiler$MakeCanonical$translateBinops)($env, $pos, $group, $sepList);
                    }))()
                    : ((($expr_)[0] === "Record")
                      ? ((() => {
                        const $attrs = ($expr_)[1].attrs;
                        const $maybeExtension = ($expr_)[1].maybeExtension;
                        return ($sd0$Compiler$MakeCanonical$translateRecord)($env, $pos, $maybeExtension, $attrs);
                      }))()
                      : ((($expr_)[0] === "List")
                        ? ((() => {
                          const $faDotsAndItems = ($expr_)[1];
                          const $rev = ($core$List$reverse)($faDotsAndItems);
                          return ((($rev)[0] === "Nil")
                            ? ($core$Result$Ok)(($sd0$Types$CanonicalAst$Constructor)($pos, $sd0$Compiler$CoreTypes$nil))
                            : ((($rev)[0] === "Cons")
                              ? ((() => {
                                const $hasDots = ($rev)[1].first;
                                const $head = ($rev)[1].second;
                                const $rest = ($rev)[2];
                                return (($core$List$any)($core$Tuple$first, $rest)
                                  ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("can use dots only on the last element (for now?)", $core$Core$Nil))
                                  : ((() => {
                                    const $$init = ($hasDots
                                      ? ({
                                        first: $head,
                                        second: $rest,
                                      })
                                      : ({
                                        first: ($sd0$Types$FormattableAst$Expression)($pos, ($sd0$Types$FormattableAst$List)($core$Core$Nil)),
                                        second: $rev,
                                      }));
                                    const $revItems = $$init.second;
                                    const $init = $$init.first;
                                    return (($core$Result$onOk)((($caInit) => {
                                      return ((($0) => {
                                        return ($core$List$forRes)($0, $revItems, (($$faItem, $acc) => {
                                          const $faItem = $$faItem.second;
                                          return (($core$Result$onOk)((($caItem) => {
                                            return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Call)($pos, ($sd0$Types$CanonicalAst$Constructor)($pos, $sd0$Compiler$CoreTypes$cons), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)($caItem), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)($acc), $core$Core$Nil))));
                                          })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $faItem));
                                        }));
                                      }))($caInit);
                                    })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $init));
                                  }))());
                              }))()
                              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 850:12', (sp_toHuman)($rev))));
                        }))()
                        : ((($expr_)[0] === "Try")
                          ? ((() => {
                            const $patterns = ($expr_)[1].patterns;
                            const $value = ($expr_)[1].value;
                            const $translatePatternAndStatements = (($$faExpression) => {
                              const $faPattern = $$faExpression.first;
                              const $faExpression = $$faExpression.second;
                              return (($core$Result$onOk)((($$caPattern) => {
                                const $uni = $$caPattern.first;
                                const $caPattern = $$caPattern.second;
                                return (($core$Result$onOk)((($block) => {
                                  return ($core$Result$Ok)(({
                                    first: $uni,
                                    second: $caPattern,
                                    third: $block,
                                  }));
                                })))(((($1) => {
                                  return ($sd0$Compiler$MakeCanonical$translateExpression)(((() => {
                                    const $0 = $env;
                                    return (Object.assign)({}, $0, ({
                                      nonRootValues: ($core$Dict$join)(($sd0$Types$CanonicalAst$patternNames)($caPattern), $env.nonRootValues),
                                    }));
                                  }))(), $1);
                                }))($faExpression));
                              })))(((($1) => {
                                return ($sd0$Compiler$MakeCanonical$translateFullPattern)($env, $1);
                              }))($faPattern));
                            });
                            return (($core$Result$onOk)((($caValue) => {
                              return (($core$Result$onOk)((($patternsAndExpressions) => {
                                return ($core$Result$Ok)(($sd0$Types$CanonicalAst$Try)($pos, ({
                                  patternsAndExpressions: $patternsAndExpressions,
                                  value: $caValue,
                                })));
                              })))(((($1) => {
                                return ($core$List$mapRes)($translatePatternAndStatements, $1);
                              }))($patterns));
                            })))(($sd0$Compiler$MakeCanonical$translateExpression)($env, $value));
                          }))()
                          : (true
                            ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("something's wrong here...", ($core$Core$Cons)((sp_toHuman)($expr_), $core$Core$Nil)))
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 758:4', (sp_toHuman)($expr_)))))))))))))));
});

const $sd0$Compiler$MakeCanonical$translateTypeParameter = (($$pos) => {
  const $pos = ($$pos)[1];
  const $word = ($$pos)[2];
  return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't start with .", $core$Core$Nil))
    : ($word.isUpper
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("type params must start with a lowercase letter", $core$Core$Nil))
      : ((sp_not_equal)($word.maybeModule, $core$Maybe$Nothing)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("why modules here?", $core$Core$Nil))
        : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("why attrs here?", $core$Core$Nil))
          : ($core$Result$Ok)(($sd0$Types$Pos$At)($pos, $word.name))))));
});

const $sd0$Types$CanonicalAst$parTypeToRaw = (($p) => {
  return ((($p)[0] === "ParRe")
    ? ((() => {
      const $raw = ($p)[1];
      return $raw;
    }))()
    : ((($p)[0] === "ParSp")
      ? ((() => {
        const $full = ($p)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/CanonicalAst.sp 171:4', (sp_toHuman)($p))));
});

const $sd0$Types$CanonicalAst$typeTyvars = (($raw) => {
  const $fromList = (($list) => {
    return ($core$List$for)($core$Dict$empty, $list, (($item, $acc) => {
      return ($core$Dict$join)($acc, ($sd0$Types$CanonicalAst$typeTyvars)($item));
    }));
  });
  return ((($raw)[0] === "TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList)($args);
    }))()
    : ((($raw)[0] === "TypeFn")
      ? ((() => {
        const $pars = ($raw)[2];
        const $to = ($raw)[3];
        return ($fromList)((sp_cons)($to.raw, ($core$List$map)($sd0$Types$CanonicalAst$parTypeToRaw, $pars)));
      }))()
      : ((($raw)[0] === "TypeRecord")
        ? ((() => {
          const $attrs = ($raw)[2];
          return ($fromList)(($core$Dict$values)($attrs));
        }))()
        : ((($raw)[0] === "TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($raw)[1];
            const $name = ($raw)[2];
            return ($core$Dict$ofOne)($name, $pos);
          }))()
          : ((($raw)[0] === "TypeError")
            ? $core$Dict$empty
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/CanonicalAst.sp 183:4', (sp_toHuman)($raw)))))));
});

const $sd0$Types$CanonicalAst$patternTyvars = (($pa) => {
  return (((($pa)[0] === "PatternAny") && ((($pa)[2].maybeAnnotation)[0] === "Just"))
    ? ((() => {
      const $t = (($pa)[2].maybeAnnotation)[1];
      return ($sd0$Types$CanonicalAst$typeTyvars)($t);
    }))()
    : (((($pa)[0] === "PatternAny") && ((($pa)[2].maybeAnnotation)[0] === "Nothing"))
      ? $core$Dict$empty
      : ((($pa)[0] === "PatternLiteralText")
        ? $core$Dict$empty
        : ((($pa)[0] === "PatternLiteralNumber")
          ? $core$Dict$empty
          : ((($pa)[0] === "PatternConstructor")
            ? ((() => {
              const $args = ($pa)[3];
              return ($core$List$for)($core$Dict$empty, $args, (($arg, $acc) => {
                return ($core$Dict$join)($acc, ($sd0$Types$CanonicalAst$patternTyvars)($arg));
              }));
            }))()
            : ((($pa)[0] === "PatternRecord")
              ? ((() => {
                const $attrs = ($pa)[3];
                return ($core$Dict$for)($core$Dict$empty, $attrs, (($k, $arg, $acc) => {
                  return ($core$Dict$join)($acc, ($sd0$Types$CanonicalAst$patternTyvars)($arg));
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/CanonicalAst.sp 203:4', (sp_toHuman)($pa))))))));
});

const $sd0$Compiler$MakeCanonical$translateDefinition = (($isRoot, $env, $fa) => {
  return (($core$Result$onOk)((($$pattern) => {
    const $uni = $$pattern.first;
    const $pattern = $$pattern.second;
    return (($core$Result$onOk)((($nonFn) => {
      const $univars = ((($1) => {
        return ($sd0$Compiler$MakeCanonical$addPatternUnivars)($pattern, $1);
      }))(((($1) => {
        return ($sd0$Compiler$MakeCanonical$addUnivarId)($uni, $1);
      }))($core$Dict$empty));
      const $tyvars = ((($1) => {
        return ($core$Dict$map)((($tyvarName, $pos) => {
          return ({
            allowFunctions: ($core$List$all)((($$name) => {
              const $name = ($$name)[2];
              return (sp_not_equal)($name, $tyvarName);
            }), $nonFn),
          });
        }), $1);
      }))(($sd0$Types$CanonicalAst$patternTyvars)($pattern));
      const $nonRootValues1 = ($isRoot
        ? $env.nonRootValues
        : ($core$Dict$join)(($sd0$Types$CanonicalAst$patternNames)($pattern), $env.nonRootValues));
      const $localEnv0 = ((() => {
        const $0 = $env;
        return (Object.assign)({}, $0, ({
          nonRootValues: $nonRootValues1,
        }));
      }))();
      return (($core$Result$onOk)((($body) => {
        const $deps = ($isRoot
          ? ((($1) => {
            return ($sd0$Compiler$MakeCanonical$expressionDeps)($body, $1);
          }))(((($1) => {
            return ($sd0$Compiler$MakeCanonical$patternDeps)($pattern, $1);
          }))($sd0$Compiler$MakeCanonical$deps_init))
          : $sd0$Compiler$MakeCanonical$deps_init);
        return ($core$Result$Ok)(({
          body: $body,
          directConsDeps: $deps.cons,
          directTypeDeps: $deps.types,
          directValueDeps: $deps.values,
          native: false,
          pattern: $pattern,
          tyvars: $tyvars,
          uni: $uni,
          univars: $univars,
        }));
      })))(((($1) => {
        return ($sd0$Compiler$MakeCanonical$translateExpression)($localEnv0, $1);
      }))($fa.body));
    })))(((($1) => {
      return ($core$List$mapRes)($sd0$Compiler$MakeCanonical$translateTypeParameter, $1);
    }))($fa.nonFn));
  })))(((($1) => {
    return ($sd0$Compiler$MakeCanonical$translateFullPattern)($env, $1);
  }))($fa.pattern));
});

const $sd0$Compiler$MakeCanonical$translateTypeName = (($$pos) => {
  const $pos = ($$pos)[1];
  const $word = ($$pos)[2];
  return ((sp_not_equal)($word.modifier, $sd0$Types$Token$NameNoModifier)
    ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Can't start with .", $core$Core$Nil))
    : (($core$Basics$not)($word.isUpper)
      ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("type names must start with Uppercase letter", $core$Core$Nil))
      : ((sp_not_equal)($word.maybeModule, $core$Maybe$Nothing)
        ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("why modules here?", $core$Core$Nil))
        : ((sp_not_equal)($word.attrPath, $core$Core$Nil)
          ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("why attrs here?", $core$Core$Nil))
          : ($core$Result$Ok)($word.name)))));
});

const $sd0$Compiler$MakeCanonical$insertRootStatement = (($ro, $faStatement, $caModule) => {
  return (((($faStatement)[0] === "Evaluation") && ((($faStatement)[1])[0] === "Expression"))
    ? ((() => {
      const $pos = (($faStatement)[1])[1];
      return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)("Root Evaluations don't really do much =|", $core$Core$Nil));
    }))()
    : ((($faStatement)[0] === "ValueDef")
      ? ((() => {
        const $d = ($faStatement)[1];
        return (($core$Result$onOk)((($def) => {
          return ((sp_not_equal)($def.uni, $sd0$Types$Ast$Imm)
            ? ($sd0$Compiler$MakeCanonical$error)(($sd0$Types$CanonicalAst$patternPos)($def.pattern), ($core$Core$Cons)("Unique values can be declared only inside functions.", $core$Core$Nil))
            : ($core$Result$Ok)(((() => {
              const $0 = $caModule;
              return (Object.assign)({}, $0, ({
                valueDefs: ($core$Dict$insert)($def.pattern, $def, $0.valueDefs),
              }));
            }))()));
        })))(((($2) => {
          return ($sd0$Compiler$MakeCanonical$translateDefinition)(true, ($sd0$Compiler$MakeCanonical$initEnv)($ro), $2);
        }))($d));
      }))()
      : ((($faStatement)[0] === "AliasDef")
        ? ((() => {
          const $fa = ($faStatement)[1];
          return (($core$Result$onOk)((($name) => {
            return ((($core$Dict$member)($name, $caModule.aliasDefs) || ($core$Dict$member)($name, $caModule.unionDefs))
              ? ((() => {
                const $$pos = $fa.name;
                const $pos = ($$pos)[1];
                return ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(($name + " declared twice!"), $core$Core$Nil));
              }))()
              : (($core$Result$onOk)((($caPars) => {
                return (($core$Result$onOk)((($type) => {
                  const $aliasDef = ({
                    directTypeDeps: ($sd0$Compiler$MakeCanonical$typeDeps)($type, $core$Set$empty),
                    pars: $caPars,
                    type: $type,
                    usr: ($sd0$Types$Meta$USR)($ro.currentModule, $name),
                  });
                  return ($core$Result$Ok)(((() => {
                    const $0 = $caModule;
                    return (Object.assign)({}, $0, ({
                      aliasDefs: ($core$Dict$insert)($name, $aliasDef, $0.aliasDefs),
                    }));
                  }))());
                })))(((($1) => {
                  return ($sd0$Compiler$MakeCanonical$translateRawType)($ro, $1);
                }))($fa.type));
              })))(((($1) => {
                return ($core$List$mapRes)($sd0$Compiler$MakeCanonical$translateTypeParameter, $1);
              }))($fa.args)));
          })))(($sd0$Compiler$MakeCanonical$translateTypeName)($fa.name));
        }))()
        : ((($faStatement)[0] === "UnionDef")
          ? ((() => {
            const $fa = ($faStatement)[1];
            const $$pos = $fa.name;
            const $pos = ($$pos)[1];
            return (($core$Result$onOk)((($name) => {
              return ((($core$Dict$member)($name, $caModule.aliasDefs) || ($core$Dict$member)($name, $caModule.unionDefs))
                ? ($sd0$Compiler$MakeCanonical$error)($pos, ($core$Core$Cons)(($name + " declared twice!"), $core$Core$Nil))
                : (($core$Result$onOk)((($caPars) => {
                  const $usr = ($sd0$Types$Meta$USR)($ro.currentModule, $name);
                  const $type = ((($2) => {
                    return ($sd0$Types$CanonicalAst$TypeNamed)($pos, $usr, $2);
                  }))(((($1) => {
                    return ($core$List$map)((($$n) => {
                      const $p = ($$n)[1];
                      const $n = ($$n)[2];
                      return ($sd0$Types$CanonicalAst$TypeAnnotationVariable)($p, $n);
                    }), $1);
                  }))($caPars));
                  return (($core$Result$onOk)((($constructors) => {
                    const $unionDef = ({
                      constructors: $constructors,
                      directTypeDeps: ($core$Dict$for)($core$Set$empty, $constructors, (($k, $c, $z) => {
                        return ($core$List$for)($z, $c.ins, $sd0$Compiler$MakeCanonical$typeDeps);
                      })),
                      pars: $caPars,
                      usr: $usr,
                    });
                    return ($core$Result$Ok)(((() => {
                      const $0 = $caModule;
                      return (Object.assign)({}, $0, ({
                        unionDefs: ($core$Dict$insert)($name, $unionDef, $0.unionDefs),
                      }));
                    }))());
                  })))(((($0) => {
                    return ($core$List$forRes)($0, $fa.constructors, (($3, $4) => {
                      return ($sd0$Compiler$MakeCanonical$translateConstructor)($ro, $type, $usr, $3, $4);
                    }));
                  }))($core$Dict$empty));
                })))(((($1) => {
                  return ($core$List$mapRes)($sd0$Compiler$MakeCanonical$translateTypeParameter, $1);
                }))($fa.args)));
            })))(($sd0$Compiler$MakeCanonical$translateTypeName)($fa.name));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical.sp 1632:4', (sp_toHuman)($faStatement))))));
});

const $sd0$Types$CanonicalAst$initModule = (($asText, $umr) => {
  return ({
    aliasDefs: $core$Dict$empty,
    asText: $asText,
    umr: $umr,
    unionDefs: $core$Dict$empty,
    valueDefs: $core$Dict$empty,
  });
});

const $sd0$Compiler$MakeCanonical$translateModule = (($ro, $asText, $umr, $faModule) => {
  (sp_benchStart)(null);
  const $module = ($sd0$Types$CanonicalAst$initModule)($asText, $umr);
  return ((($2) => {
    return ($core$Basics$btw)(sp_benchStop, "translateModule", $2);
  }))(((($0) => {
    return ($core$List$forRes)($0, $faModule, (($1, $2) => {
      return ($sd0$Compiler$MakeCanonical$insertRootStatement)($ro, $1, $2);
    }));
  }))($module));
});

const $sd0$Compiler$MakeCanonical$textToCanonicalModule = (($pars, $code) => {
  const $ro = ({
    currentModule: ($sd0$Types$Meta$UMR)($pars.source, $pars.name),
    meta: $pars.meta,
  });
  const $umr = ($sd0$Types$Meta$UMR)($pars.source, $pars.name);
  return (($core$Result$onOk)((($faModule) => {
    return ($sd0$Compiler$MakeCanonical$translateModule)($ro, $code, $umr, $faModule);
  })))(((($1) => {
    return ($sd0$Compiler$Parser$textToFormattableModule)(({
      moduleName: $pars.name,
      stripLocations: $pars.stripLocations,
    }), $1);
  }))($code));
});

const $sd0$Compile$loadModule = (($meta, $umr, $fileName) => {
  const $$moduleName = $umr;
  const $moduleName = ($$moduleName)[2];
  const $source = ($$moduleName)[1];
  return (($posix$IO$onSuccess)((($moduleAsText) => {
    const $params = ({
      meta: $meta,
      name: $moduleName,
      source: $source,
      stripLocations: false,
    });
    const $eenv = ({
      moduleByName: ($core$Dict$ofOne)($moduleName, ({
        content: $moduleAsText,
        fsPath: $fileName,
      })),
    });
    return ((($1) => {
      return ($sd0$Compile$resToIo)($eenv, $1);
    }))(($sd0$Compiler$MakeCanonical$textToCanonicalModule)($params, $moduleAsText));
  })))((io_readFile)($fileName));
});

const $sd0$Compile$mergeWithCore = (($coreModule, $userModule) => {
  const $0 = $userModule;
  return (Object.assign)({}, $0, ({
    aliasDefs: ($core$Dict$join)($coreModule.aliasDefs, $0.aliasDefs),
    unionDefs: ($core$Dict$join)($coreModule.unionDefs, $0.unionDefs),
    valueDefs: ($core$Dict$join)($coreModule.valueDefs, $0.valueDefs),
  }));
});

const $sd0$Compile$onResSuccess = (($errorEnv, $f) => {
  return (($res) => {
    return ((($0) => {
      return (($posix$IO$onSuccess)($f))($0);
    }))(((($1) => {
      return ($sd0$Compile$resToIo)($errorEnv, $1);
    }))($res));
  });
});

const $sd0$Compile$searchAncestorDirectories = (($isWantedFile, $searchDir) => {
  return (($posix$IO$onResult)((($result) => {
    return ((($result)[0] === "Err")
      ? ($posix$IO$succeed)($core$Maybe$Nothing)
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $dirContents = ($result)[1];
          return (($core$List$any)($isWantedFile, $dirContents)
            ? ($posix$IO$succeed)(($core$Maybe$Just)($searchDir))
            : ((() => {
              const $parent = (path_resolve)(($core$Core$Cons)($searchDir, ($core$Core$Cons)("..", $core$Core$Nil)));
              return ((sp_equal)($parent, $searchDir)
                ? ($posix$IO$succeed)($core$Maybe$Nothing)
                : ((($1) => {
                  return ($sd0$Compile$searchAncestorDirectories)($isWantedFile, $1);
                }))($parent));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 257:4', (sp_toHuman)($result))));
  })))((io_readDir)($searchDir));
});

const $sd0$Compile$umrToFileName = (($corePath, $umr) => {
  const $$name = $umr;
  const $name = ($$name)[2];
  const $source = ($$name)[1];
  return ((($source)[0] === "SourceDir")
    ? ((() => {
      const $d = ($source)[1];
      return (path_resolve)(($core$Core$Cons)($d, ($core$Core$Cons)(($name + ".sp"), $core$Core$Nil)));
    }))()
    : ((($source)[0] === "Core")
      ? (path_resolve)((sp_cons)($corePath, (sp_cons)("core", ((($1) => {
        return (text_split)("/", $1);
      }))(($name + ".sp")))))
      : ((($source)[0] === "Posix")
        ? (path_resolve)((sp_cons)($corePath, (sp_cons)("posix", ((($1) => {
          return (text_split)("/", $1);
        }))(($name + ".sp")))))
        : ((($source)[0] === "Browser")
          ? (path_resolve)((sp_cons)($corePath, (sp_cons)("browser", ((($1) => {
            return (text_split)("/", $1);
          }))(($name + ".sp")))))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 145:4', (sp_toHuman)($source))))));
});

const $sd0$Compiler$MakeEmittable$circularIsError = (($globalDefsByName, $names) => {
  const $zzz = (($name) => {
    const $$try1 = ($core$Dict$get)($name, $globalDefsByName);
    return ((($$try1)[0] === "Nothing")
      ? false
      : ((($$try1)[0] === "Just")
        ? ((() => {
          const $globalDef = ($$try1)[1];
          const $$try2 = $globalDef.expr;
          return ((($$try2)[0] === "Fn")
            ? false
            : (true
              ? true
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 459:14', (sp_toHuman)($$try2))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 453:6', (sp_toHuman)($$try1))));
  });
  return ($core$List$any)($zzz, $names);
});

const $sd0$Compiler$MakeEmittable$translateSource = (($state, $src) => {
  return ([
    ((($src)[0] === "Core")
      ? "core"
      : ((($src)[0] === "Posix")
        ? "posix"
        : ((($src)[0] === "Browser")
          ? "browser"
          : ((($src)[0] === "SourceDir")
            ? ((() => {
              const $path = ($src)[1];
              const $$try1 = ((__re__ = (hash_get)($state.sourceDirsToId, $path)), ($state.sourceDirsToId = (__re__)[1]), (__re__)[0]);
              return ((($$try1)[0] === "Nothing")
                ? ((() => {
                  const $n = ("sd" + (text_fromNumber)(((__re__ = (basics_cloneUni)($state.sourceDirsCounter)), ($state.sourceDirsCounter = (__re__)[1]), (__re__)[0])));
                  ($state.sourceDirsCounter += 1);
                  ((__re__ = (hash_insert)($state.sourceDirsToId, $path, $n)), ($state.sourceDirsToId = (__re__)[1]), (__re__)[0]);
                  return $n;
                }))()
                : ((($$try1)[0] === "Just")
                  ? ((() => {
                    const $id = ($$try1)[1];
                    return $id;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 68:12', (sp_toHuman)($$try1))));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 57:4', (sp_toHuman)($src)))))),
    $state,
  ]);
});

const $sd0$Compiler$MakeEmittable$makeTextUsr = (($state, $umr, $$name) => {
  const $name = ($$name)[1];
  const $$modulePath = $umr;
  const $modulePath = ($$modulePath)[2];
  const $source = ($$modulePath)[1];
  return ([
    ("$" + (((__re__ = ($sd0$Compiler$MakeEmittable$translateSource)($state, $source)), ($state = (__re__)[1]), (__re__)[0]) + ("$" + (($core$Text$replace)("/", "$", $modulePath) + $name)))),
    $state,
  ]);
});

const $sd0$Compiler$MakeEmittable$generatedName = (($base) => {
  return ($sd0$Compiler$MakeEmittable$DollarName)(("$$" + $base));
});

const $sd0$Compiler$MakeEmittable$userSpecifiedName = (($name) => {
  return ($sd0$Compiler$MakeEmittable$DollarName)(("$" + $name));
});

const $sd0$Types$TypedAst$patternNames = (($p) => {
  return (((($p)[0] === "PatternAny") && ((($p)[2].maybeName)[0] === "Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return $core$Dict$empty;
    }))()
    : (((($p)[0] === "PatternAny") && ((($p)[2].maybeName)[0] === "Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $n = (($p)[2].maybeName)[1];
        const $type = ($p)[2].type;
        return ($core$Dict$ofOne)($n, ({
          pos: $pos,
          type: $type,
        }));
      }))()
      : ((($p)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return $core$Dict$empty;
        }))()
        : ((($p)[0] === "PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return $core$Dict$empty;
          }))()
          : ((($p)[0] === "PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $usr = ($p)[2];
              const $ps = ($p)[3];
              return ($core$List$for)($core$Dict$empty, $ps, (($x, $a) => {
                return ((($0) => {
                  return ($core$Dict$join)($0, $a);
                }))(($sd0$Types$TypedAst$patternNames)($x));
              }));
            }))()
            : ((($p)[0] === "PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[2];
                return ($core$Dict$for)($core$Dict$empty, $ps, (($k, $$pa, $a) => {
                  const $pa = $$pa.first;
                  const $ty = $$pa.second;
                  return ((($1) => {
                    return ($core$Dict$join)($a, $1);
                  }))(($sd0$Types$TypedAst$patternNames)($pa));
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 329:4', (sp_toHuman)($p))))))));
});

const $sd0$Compiler$MakeEmittable$pickMainName = (($pattern) => {
  return (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeName)[0] === "Just"))
    ? ((() => {
      const $pos = ($pattern)[1];
      const $name = (($pattern)[2].maybeName)[1];
      const $type = ($pattern)[2].type;
      return ($sd0$Compiler$MakeEmittable$TrivialPattern)(($sd0$Compiler$MakeEmittable$userSpecifiedName)($name), $type);
    }))()
    : (true
      ? ((() => {
        const $$try1 = ($core$Dict$keys)(($sd0$Types$TypedAst$patternNames)($pattern));
        return ((($$try1)[0] === "Cons")
          ? ((() => {
            const $head = ($$try1)[1];
            const $tail = ($$try1)[2];
            return ($sd0$Compiler$MakeEmittable$SafeMainName)(($sd0$Compiler$MakeEmittable$generatedName)($head));
          }))()
          : ((($$try1)[0] === "Nil")
            ? $sd0$Compiler$MakeEmittable$NoNamedVariables
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 112:12', (sp_toHuman)($$try1))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 106:4', (sp_toHuman)($pattern))));
});

const $sd0$Compiler$MakeEmittable$generateTryName = (($counter) => {
  ($counter += 1);
  return ([
    ($sd0$Compiler$MakeEmittable$generatedName)(("try" + (text_fromNumber)(((__re__ = (basics_cloneUni)($counter)), ($counter = (__re__)[1]), (__re__)[0])))),
    $counter,
  ]);
});

const $sd0$Compiler$MakeEmittable$testPattern = (($pattern, $valueToTest, $accum) => {
  return ((($pattern)[0] === "PatternAny")
    ? $accum
    : ((($pattern)[0] === "PatternLiteralText")
      ? ((() => {
        const $text = ($pattern)[2];
        return (sp_cons)(($sd0$Types$EmittableAst$ShallowEqual)(($sd0$Types$EmittableAst$LiteralText)($text), $valueToTest), $accum);
      }))()
      : ((($pattern)[0] === "PatternLiteralNumber")
        ? ((() => {
          const $num = ($pattern)[2];
          return (sp_cons)(($sd0$Types$EmittableAst$ShallowEqual)(($sd0$Types$EmittableAst$LiteralNumber)($num), $valueToTest), $accum);
        }))()
        : (((($pattern)[0] === "PatternConstructor") && ((($pattern)[2])[0] === "USR"))
          ? ((() => {
            const $umr = (($pattern)[2])[1];
            const $name = (($pattern)[2])[2];
            const $pas = ($pattern)[3];
            return ((($0) => {
              return ($core$List$indexedFor)($0, $pas, (($index, $argPattern, $a) => {
                return ($sd0$Compiler$MakeEmittable$testPattern)($argPattern, ($sd0$Types$EmittableAst$ConstructorAccess)($index, $valueToTest), $a);
              }));
            }))((sp_cons)(($sd0$Types$EmittableAst$IsConstructor)($name, $valueToTest), $accum));
          }))()
          : ((($pattern)[0] === "PatternRecord")
            ? ((() => {
              const $attrs = ($pattern)[2];
              return ((($0) => {
                return ($core$Dict$for)($0, $attrs, (($name, $$pa, $a) => {
                  const $pa = $$pa.first;
                  const $type = $$pa.second;
                  return ($sd0$Compiler$MakeEmittable$testPattern)($pa, ($sd0$Types$EmittableAst$RecordAccess)($name, $valueToTest), $a);
                }));
              }))($accum);
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 174:4', (sp_toHuman)($pattern)))))));
});

const $sd0$Compiler$MakeEmittable$translateArgAndType = (($state, $counter, $taArg) => {
  return ([
    ((($taArg)[0] === "ArgumentExpression")
      ? ((() => {
        const $fullType = ($taArg)[1];
        const $exp = ($taArg)[2];
        return ($sd0$Types$EmittableAst$ArgumentSpend)(((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $exp)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]));
      }))()
      : ((($taArg)[0] === "ArgumentRecycle")
        ? ((() => {
          const $pos = ($taArg)[1];
          const $rawType = ($taArg)[2];
          const $attrPath = ($taArg)[3];
          const $name = ($taArg)[4];
          const $$n = ($sd0$Compiler$MakeEmittable$userSpecifiedName)($name);
          const $n = ($$n)[1];
          return ($sd0$Types$EmittableAst$ArgumentRecycle)($attrPath, $n);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 235:4', (sp_toHuman)($taArg)))),
    $state,
    $counter,
  ]);
});

const $sd0$Compiler$MakeEmittable$translatePatternRec = (($pattern, $accessExpr, $accum) => {
  return (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeName)[0] === "Nothing"))
    ? ((() => {
      const $type = ($pattern)[2].type;
      return $accum;
    }))()
    : (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeName)[0] === "Just"))
      ? ((() => {
        const $name = (($pattern)[2].maybeName)[1];
        const $type = ($pattern)[2].type;
        return (sp_cons)(({
          first: $type,
          second: ($sd0$Compiler$MakeEmittable$userSpecifiedName)($name),
          third: $accessExpr,
        }), $accum);
      }))()
      : ((($pattern)[0] === "PatternLiteralNumber")
        ? $accum
        : ((($pattern)[0] === "PatternLiteralText")
          ? $accum
          : ((($pattern)[0] === "PatternConstructor")
            ? ((() => {
              const $path = ($pattern)[2];
              const $pas = ($pattern)[3];
              return ((($0) => {
                return ($core$List$indexedFor)($0, $pas, (($index, $pa, $a) => {
                  return ($sd0$Compiler$MakeEmittable$translatePatternRec)($pa, ($sd0$Types$EmittableAst$ConstructorAccess)($index, $accessExpr), $a);
                }));
              }))($accum);
            }))()
            : ((($pattern)[0] === "PatternRecord")
              ? ((() => {
                const $attrs = ($pattern)[2];
                return ((($0) => {
                  return ($core$Dict$for)($0, $attrs, (($name, $$pa, $a) => {
                    const $pa = $$pa.first;
                    const $type = $$pa.second;
                    return ($sd0$Compiler$MakeEmittable$translatePatternRec)($pa, ($sd0$Types$EmittableAst$RecordAccess)($name, $accessExpr), $a);
                  }));
                }))($accum);
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 132:4', (sp_toHuman)($pattern))))))));
});

const $sd0$Compiler$MakeEmittable$translatePattern = (($pattern, $accessExpr) => {
  return ($sd0$Compiler$MakeEmittable$translatePatternRec)($pattern, $accessExpr, $core$Core$Nil);
});

const $sd0$Compiler$MakeEmittable$translateParameter = (($state, $counter, $bodyAcc, $param) => {
  return ([
    ((($param)[0] === "ParameterRecycle")
      ? ((() => {
        const $pos = ($param)[1];
        const $rawType = ($param)[2];
        const $name = ($param)[3];
        const $$n = ($sd0$Compiler$MakeEmittable$userSpecifiedName)($name);
        const $n = ($$n)[1];
        return ({
          first: $bodyAcc,
          second: ({
            first: true,
            second: ($core$Maybe$Just)($n),
          }),
        });
      }))()
      : ((($param)[0] === "ParameterPattern")
        ? ((() => {
          const $fullType = ($param)[1];
          const $pa = ($param)[2];
          const $$try1 = ($sd0$Compiler$MakeEmittable$pickMainName)($pa);
          return ((($$try1)[0] === "NoNamedVariables")
            ? ({
              first: $bodyAcc,
              second: ({
                first: false,
                second: $core$Maybe$Nothing,
              }),
            })
            : (((($$try1)[0] === "TrivialPattern") && ((($$try1)[1])[0] === "DollarName"))
              ? ((() => {
                const $argName = (($$try1)[1])[1];
                const $type = ($$try1)[2];
                return ({
                  first: $bodyAcc,
                  second: ({
                    first: false,
                    second: ($core$Maybe$Just)($argName),
                  }),
                });
              }))()
              : (((($$try1)[0] === "SafeMainName") && ((($$try1)[1])[0] === "DollarName"))
                ? ((() => {
                  const $mainName = (($$try1)[1])[1];
                  const $namesAndExpressions = ($sd0$Compiler$MakeEmittable$translatePattern)($pa, ($sd0$Types$EmittableAst$Variable)($mainName));
                  const $wrapWithArgumentLetIn = (($$letExpression, $inExpression) => {
                    const $type = $$letExpression.first;
                    const $varName = ($$letExpression.second)[1];
                    const $letExpression = $$letExpression.third;
                    return ($sd0$Types$EmittableAst$LetIn)(({
                      inExpression: $inExpression,
                      letExpression: $letExpression,
                      maybeName: ($core$Maybe$Just)($varName),
                      type: $type,
                    }));
                  });
                  return ({
                    first: ($core$List$for)($bodyAcc, $namesAndExpressions, $wrapWithArgumentLetIn),
                    second: ({
                      first: false,
                      second: ($core$Maybe$Just)($mainName),
                    }),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 208:12', (sp_toHuman)($$try1)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 199:4', (sp_toHuman)($param)))),
    $state,
    $counter,
  ]);
});

const $sd0$Compiler$MakeEmittable$translateUsr = (($state, $usr) => {
  const $$name = $usr;
  const $name = ($$name)[2];
  const $umr = ($$name)[1];
  return ([
    ((__re__ = ($sd0$Compiler$MakeEmittable$makeTextUsr)($state, $umr, ($sd0$Compiler$MakeEmittable$userSpecifiedName)($name))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$MakeEmittable$translateVariableArgs = (($state, $ref) => {
  const $variableName = ((($ref)[0] === "RefLocal")
    ? ((() => {
      const $name = ($ref)[1];
      const $$n = ($sd0$Compiler$MakeEmittable$userSpecifiedName)($name);
      const $n = ($$n)[1];
      return $n;
    }))()
    : ((($ref)[0] === "RefGlobal")
      ? ((() => {
        const $usr = ($ref)[1];
        return ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($state, $usr)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 158:8', (sp_toHuman)($ref))));
  return ([
    ($sd0$Types$EmittableAst$Variable)($variableName),
    $state,
  ]);
});

const $sd0$Compiler$MakeEmittable$translateExpression = (($state, $counter, $expression) => {
  return ([
    ((($expression)[0] === "LiteralNumber")
      ? ((() => {
        const $num = ($expression)[2];
        return ($sd0$Types$EmittableAst$LiteralNumber)($num);
      }))()
      : ((($expression)[0] === "LiteralText")
        ? ((() => {
          const $text = ($expression)[2];
          return ($sd0$Types$EmittableAst$LiteralText)($text);
        }))()
        : ((($expression)[0] === "Variable")
          ? ((() => {
            const $ref = ($expression)[2];
            return ((__re__ = ($sd0$Compiler$MakeEmittable$translateVariableArgs)($state, $ref)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : ((($expression)[0] === "Constructor")
            ? ((() => {
              const $usr = ($expression)[2];
              return ($sd0$Types$EmittableAst$Constructor)(((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($state, $usr)), ($state = (__re__)[1]), (__re__)[0]));
            }))()
            : ((($expression)[0] === "RecordAccess")
              ? ((() => {
                const $attrName = ($expression)[2];
                const $exp = ($expression)[3];
                return ($sd0$Types$EmittableAst$RecordAccess)($attrName, ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $exp)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]));
              }))()
              : ((($expression)[0] === "Fn")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $taPars = ($expression)[2];
                  const $body = ($expression)[3];
                  const $bodyT = ($expression)[4];
                  const $eaBody = ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $body)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]);
                  const $$eaPars = ((($0) => {
                    return ($core$List$forReversed)($0, $taPars, (($taPar, $$bodyAcc) => {
                      const $bodyAcc = $$bodyAcc.first;
                      const $eaParsAcc = $$bodyAcc.second;
                      const $$bodyX = ((__re__ = ($sd0$Compiler$MakeEmittable$translateParameter)($state, $counter, $bodyAcc, $taPar)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]);
                      const $eaPar = $$bodyX.second;
                      const $bodyX = $$bodyX.first;
                      return ({
                        first: $bodyX,
                        second: (sp_cons)($eaPar, $eaParsAcc),
                      });
                    }));
                  }))(({
                    first: $eaBody,
                    second: $core$Core$Nil,
                  }));
                  const $eaPars = $$eaPars.second;
                  const $wrappedBody = $$eaPars.first;
                  return ($sd0$Types$EmittableAst$Fn)($eaPars, $wrappedBody);
                }))()
                : ((($expression)[0] === "Record")
                  ? ((() => {
                    const $extends = ($expression)[2];
                    const $attrs = ($expression)[3];
                    return ((($1) => {
                      return ($sd0$Types$EmittableAst$LiteralRecord)(($core$Maybe$map)((($2) => {
                        return ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $2)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]);
                      }), $extends), $1);
                    }))(((($1) => {
                      return ($core$List$map)((($1) => {
                        return ($core$Tuple$mapSecond)((($2) => {
                          return ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $2)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]);
                        }), $1);
                      }), $1);
                    }))(((($1) => {
                      return (list_sortBy)($core$Tuple$first, $1);
                    }))(($core$Dict$toList)($attrs))));
                  }))()
                  : ((($expression)[0] === "Call")
                    ? ((() => {
                      const $ref = ($expression)[2];
                      const $argsAndTypes = ($expression)[3];
                      return ($sd0$Types$EmittableAst$Call)(((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $ref)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]), ($core$List$map)((($2) => {
                        return ((__re__ = ($sd0$Compiler$MakeEmittable$translateArgAndType)($state, $counter, $2)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]);
                      }), $argsAndTypes));
                    }))()
                    : ((($expression)[0] === "If")
                      ? ((() => {
                        const $ar = ($expression)[2];
                        return ($sd0$Types$EmittableAst$Conditional)(((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $ar.condition)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]), ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $ar.true)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]), ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $ar.false)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]));
                      }))()
                      : ((($expression)[0] === "Try")
                        ? ((() => {
                          const $pos = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          const $$valueExpression = ((() => {
                            const $$try2 = ({
                              first: $value,
                              second: $valueType.uni,
                            });
                            return (((($$try2.first)[0] === "Variable") && (($$try2.second)[0] === "Imm"))
                              ? ((() => {
                                const $ref = ($$try2.first)[2];
                                return ({
                                  first: ((__re__ = ($sd0$Compiler$MakeEmittable$translateVariableArgs)($state, $ref)), ($state = (__re__)[1]), (__re__)[0]),
                                  second: $core$Basics$identity,
                                });
                              }))()
                              : (true
                                ? ((() => {
                                  const $$tryName = ((__re__ = ($sd0$Compiler$MakeEmittable$generateTryName)($counter)), ($counter = (__re__)[1]), (__re__)[0]);
                                  const $tryName = ($$tryName)[1];
                                  const $wrap = (($tryExpression) => {
                                    return ($sd0$Types$EmittableAst$LetIn)(({
                                      inExpression: $tryExpression,
                                      letExpression: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $value)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
                                      maybeName: ($core$Maybe$Just)($tryName),
                                      type: $valueType,
                                    }));
                                  });
                                  return ({
                                    first: ($sd0$Types$EmittableAst$Variable)($tryName),
                                    second: $wrap,
                                  });
                                }))()
                                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 302:16', (sp_toHuman)($$try2))));
                          }))();
                          const $wrapWithLetIn = $$valueExpression.second;
                          const $valueExpression = $$valueExpression.first;
                          const $addTryPatternAndBlock = (($$block, $nextTryExpression) => {
                            const $pattern = $$block.first;
                            const $block = $$block.second;
                            const $testIfPatternMatches = ($sd0$Types$EmittableAst$And)(($core$List$reverse)(($sd0$Compiler$MakeEmittable$testPattern)($pattern, $valueExpression, $core$Core$Nil)));
                            const $namesAndExpressions = ($sd0$Compiler$MakeEmittable$translatePattern)($pattern, $valueExpression);
                            const $whenConditionMatches = ((($0) => {
                              return ($core$List$for)($0, $namesAndExpressions, (($$letExpression, $inExpression) => {
                                const $type = $$letExpression.first;
                                const $name = ($$letExpression.second)[1];
                                const $letExpression = $$letExpression.third;
                                return ($sd0$Types$EmittableAst$LetIn)(({
                                  inExpression: $inExpression,
                                  letExpression: $letExpression,
                                  maybeName: ($core$Maybe$Just)($name),
                                  type: $type,
                                }));
                              }));
                            }))(((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $block)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]));
                            return ($sd0$Types$EmittableAst$Conditional)($testIfPatternMatches, $whenConditionMatches, $nextTryExpression);
                          });
                          const $default = ($sd0$Types$EmittableAst$MissingPattern)($pos, $valueExpression);
                          return ($wrapWithLetIn)(((($0) => {
                            return ($core$List$forReversed)($0, $patternsAndExpressions, $addTryPatternAndBlock);
                          }))($default));
                        }))()
                        : ((($expression)[0] === "LetIn")
                          ? ((() => {
                            const $valueDef = ($expression)[1];
                            const $e = ($expression)[2];
                            const $bodyType = ($expression)[3];
                            const $$try1 = ($sd0$Compiler$MakeEmittable$pickMainName)($valueDef.pattern);
                            return ((($$try1)[0] === "NoNamedVariables")
                              ? ($sd0$Types$EmittableAst$LetIn)(({
                                inExpression: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $e)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
                                letExpression: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $valueDef.body)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
                                maybeName: $core$Maybe$Nothing,
                                type: $valueDef.type,
                              }))
                              : (((($$try1)[0] === "TrivialPattern") && ((($$try1)[1])[0] === "DollarName"))
                                ? ((() => {
                                  const $defName = (($$try1)[1])[1];
                                  const $type = ($$try1)[2];
                                  return ($sd0$Types$EmittableAst$LetIn)(({
                                    inExpression: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $e)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
                                    letExpression: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $valueDef.body)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
                                    maybeName: ($core$Maybe$Just)($defName),
                                    type: $type,
                                  }));
                                }))()
                                : (((($$try1)[0] === "SafeMainName") && ((($$try1)[1])[0] === "DollarName"))
                                  ? ((() => {
                                    const $mainName = (($$try1)[1])[1];
                                    const $namesAndExpressions = ($sd0$Compiler$MakeEmittable$translatePattern)($valueDef.pattern, ($sd0$Types$EmittableAst$Variable)($mainName));
                                    const $wrapWithUnpackedPatternVar = (($$letExpression, $inExpression) => {
                                      const $type = $$letExpression.first;
                                      const $name = ($$letExpression.second)[1];
                                      const $letExpression = $$letExpression.third;
                                      return ($sd0$Types$EmittableAst$LetIn)(({
                                        inExpression: $inExpression,
                                        letExpression: $letExpression,
                                        maybeName: ($core$Maybe$Just)($name),
                                        type: $type,
                                      }));
                                    });
                                    const $wrapWithActualLetIn = (($inExpression) => {
                                      return ($sd0$Types$EmittableAst$LetIn)(({
                                        inExpression: $inExpression,
                                        letExpression: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $valueDef.body)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
                                        maybeName: ($core$Maybe$Just)($mainName),
                                        type: $valueDef.type,
                                      }));
                                    });
                                    return ($wrapWithActualLetIn)(((($0) => {
                                      return ($core$List$forReversed)($0, $namesAndExpressions, $wrapWithUnpackedPatternVar);
                                    }))(((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $e)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0])));
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 351:12', (sp_toHuman)($$try1)))));
                          }))()
                          : ((($expression)[0] === "DestroyIn")
                            ? ((() => {
                              const $name = ($expression)[1];
                              const $e = ($expression)[2];
                              return ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $e)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]);
                            }))()
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 250:4', (sp_toHuman)($expression)))))))))))))),
    $state,
    $counter,
  ]);
});

const $sd0$Compiler$MakeEmittable$translateRootValueDef = (($state, $umr, $def, $accum) => {
  let $counter = 0;
  const $deps = ($core$Set$map)((($1) => {
    return ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($state, $1)), ($state = (__re__)[1]), (__re__)[0]);
  }), $def.directValueDeps);
  const $$try1 = ($sd0$Compiler$MakeEmittable$pickMainName)($def.pattern);
  return ([
    ((($$try1)[0] === "NoNamedVariables")
      ? $accum
      : ((($$try1)[0] === "TrivialPattern")
        ? ((() => {
          const $name = ($$try1)[1];
          const $type = ($$try1)[2];
          const $usrAsText = ((__re__ = ($sd0$Compiler$MakeEmittable$makeTextUsr)($state, $umr, $name)), ($state = (__re__)[1]), (__re__)[0]);
          return ((($2) => {
            return ($core$Dict$insert)($usrAsText, ({
              deps: $deps,
              expr: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $def.body)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
              name: $usrAsText,
            }), $2);
          }))($accum);
        }))()
        : ((($$try1)[0] === "SafeMainName")
          ? ((() => {
            const $mainName = ($$try1)[1];
            const $mainUsrAsText = ((__re__ = ($sd0$Compiler$MakeEmittable$makeTextUsr)($state, $umr, $mainName)), ($state = (__re__)[1]), (__re__)[0]);
            const $mainDef = ({
              deps: $deps,
              expr: ((__re__ = ($sd0$Compiler$MakeEmittable$translateExpression)($state, $counter, $def.body)), ($state = (__re__)[1]), ($counter = (__re__)[2]), (__re__)[0]),
              name: $mainUsrAsText,
            });
            return ((($0) => {
              return ($core$List$for)($0, ($sd0$Compiler$MakeEmittable$translatePattern)($def.pattern, ($sd0$Types$EmittableAst$Variable)($mainUsrAsText)), (($$expr, $z) => {
                const $type = $$expr.first;
                const $name = $$expr.second;
                const $expr = $$expr.third;
                const $textUsr = ((__re__ = ($sd0$Compiler$MakeEmittable$makeTextUsr)($state, $umr, $name)), ($state = (__re__)[1]), (__re__)[0]);
                return ($core$Dict$insert)($textUsr, ({
                  deps: ($core$Set$ofOne)($mainUsrAsText),
                  expr: $expr,
                  name: $textUsr,
                }), $z);
              }));
            }))(((($2) => {
              return ($core$Dict$insert)($mainUsrAsText, $mainDef, $2);
            }))($accum));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeEmittable.sp 411:4', (sp_toHuman)($$try1))))),
    $state,
  ]);
});

const $sd0$RefHierarchy$resolve = (($getEdges, $target, $path, $state0) => {
  return (($core$List$member)($target, $state0.resolved)
    ? $state0
    : (($core$List$member)($target, $path)
      ? ((() => {
        const $circ = (sp_cons)($target, ($core$List$takeWhile)((($key) => {
          return (sp_not_equal)($key, $target);
        }), $path));
        const $0 = $state0;
        return (Object.assign)({}, $0, ({
          circular: ($core$Dict$insert)(($core$Set$fromList)($circ), $circ, $0.circular),
        }));
      }))()
      : ((() => {
        const $s = ((($0) => {
          return ($core$Dict$for)($0, ($getEdges)($target), (($a, _1, $d) => {
            return ($sd0$RefHierarchy$resolve)($getEdges, $a, (sp_cons)($target, $path), $d);
          }));
        }))($state0);
        const $0 = $s;
        return (Object.assign)({}, $0, ({
          resolved: (sp_cons)($target, $0.resolved),
        }));
      }))()));
});

const $sd0$RefHierarchy$reorder = (($nodeToEdges, $nodesById) => {
  const $keyToEdges = (($id) => {
    const $$try1 = ($core$Dict$get)($id, $nodesById);
    return ((($$try1)[0] === "Nothing")
      ? $core$Set$empty
      : ((($$try1)[0] === "Just")
        ? ((() => {
          const $node = ($$try1)[1];
          return ($nodeToEdges)($node);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/RefHierarchy.sp 44:8', (sp_toHuman)($$try1))));
  });
  const $state0 = ({
    circular: $core$Dict$empty,
    resolved: $core$Core$Nil,
  });
  const $stateF = ((($0) => {
    return ($core$Dict$for)($0, $nodesById, (($k, $v, $d) => {
      return ($sd0$RefHierarchy$resolve)($keyToEdges, $k, $core$Core$Nil, $d);
    }));
  }))($state0);
  return ({
    first: ($core$Dict$values)($stateF.circular),
    second: ($core$List$reverse)($stateF.resolved),
  });
});

const $sd0$Compiler$MakeEmittable$translateAll = (($modules) => {
  (sp_benchStart)(null);
  let $state = ({
    sourceDirsCounter: 0,
    sourceDirsToId: (hash_fromList)($core$Core$Nil),
  });
  const $globalDefsByName = ((($0) => {
    return ($core$List$for)($0, $modules, (($module, $d) => {
      return ($core$Dict$for)($d, $module.valueDefs, ((_0, $def, $a) => {
        return ((__re__ = ($sd0$Compiler$MakeEmittable$translateRootValueDef)($state, $module.umr, $def, $a)), ($state = (__re__)[1]), (__re__)[0]);
      }));
    }));
  }))($core$Dict$empty);
  const $$circulars = ($sd0$RefHierarchy$reorder)((($globalDef) => {
    return $globalDef.deps;
  }), $globalDefsByName);
  const $reorderedNames = $$circulars.second;
  const $circulars = $$circulars.first;
  (sp_benchStop)("makeEmittable");
  const $errors = ((($1) => {
    return ($core$List$filter)((($1) => {
      return ($sd0$Compiler$MakeEmittable$circularIsError)($globalDefsByName, $1);
    }), $1);
  }))($circulars);
  const $s = $state;
  return ((sp_not_equal)($errors, $core$Core$Nil)
    ? ($core$Result$Err)($errors)
    : ($core$Result$Ok)(((($1) => {
      return ($core$Tuple$pair)($s, $1);
    }))(((($1) => {
      return ($core$List$filterMap)((($name) => {
        return ($core$Dict$get)($name, $globalDefsByName);
      }), $1);
    }))($reorderedNames))));
});

const $sd0$Compiler$TypeCheck$bug = (($msg) => {
  return (sp_todo)(("Compiler bug: " + $msg));
});

const $sd0$Compiler$TypeCheck$addErError = (($equality, $message, $state) => {
  const $0 = $state;
  return (Object.assign)({}, $0, ({
    errors: (sp_cons)(({
      first: $equality,
      second: $message,
    }), $0.errors),
  }));
});

const $sd0$Compiler$TypeCheck$addEquality = (($env, $pos, $why, $t1, $t2, $state) => {
  return ([
    ((($1) => {
      return ((__re__ = (array_push)($state.equalities, $1)), ($state.equalities = (__re__)[1]), (__re__)[0]);
    }))(($sd0$Compiler$TypeCheck$Equality)($env.context, $pos, $why, $t1, $t2)),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$addError = (($env, $pos, $error, $state) => {
  return ([
    ((__re__ = (array_push)($state.errors, ({
      first: $pos,
      second: $env.context,
      third: $error,
    }))), ($state.errors = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$addErrorIf = (($test, $env, $pos, $error, $state) => {
  return ([
    ($test
      ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $error, $state)), ($state = (__re__)[1]), (__re__)[0])
      : null),
    $state,
  ]);
});

const $sd0$Types$TypedAst$resolveUni = (($uniSub, $uni) => {
  return ((($uni)[0] === "Depends")
    ? ((() => {
      const $id = ($uni)[1];
      const $$try1 = ($uniSub)($id);
      return ((($$try1)[0] === "Nothing")
        ? $uni
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $u = ($$try1)[1];
            return $u;
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 153:12', (sp_toHuman)($$try1))));
    }))()
    : (true
      ? $uni
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 151:4', (sp_toHuman)($uni))));
});

const $sd0$Types$TypedAst$resolveFull = (($saf, $$raw) => {
  const $raw = $$raw.raw;
  const $uni = $$raw.uni;
  return ({
    raw: ($sd0$Types$TypedAst$resolveRaw)($saf, $raw),
    uni: ($sd0$Types$TypedAst$resolveUni)($saf.uni, $uni),
  });
});

const $sd0$Types$TypedAst$resolveParType = (($saf, $par) => {
  return ((($par)[0] === "ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return ($sd0$Types$TypedAst$ParRe)(($sd0$Types$TypedAst$resolveRaw)($saf, $raw));
    }))()
    : ((($par)[0] === "ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return ($sd0$Types$TypedAst$ParSp)(($sd0$Types$TypedAst$resolveFull)($saf, $full));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 163:4', (sp_toHuman)($par))));
});

const $sd0$Types$TypedAst$resolveRaw = (($saf, $raw) => {
  const $rec = (($1) => {
    return ($sd0$Types$TypedAst$resolveRaw)($saf, $1);
  });
  return ((($raw)[0] === "TypeVar")
    ? ((() => {
      const $id = ($raw)[1];
      const $$try2 = ($saf.ty)($id);
      return ((($$try2)[0] === "Nothing")
        ? $raw
        : ((($$try2)[0] === "Just")
          ? ((() => {
            const $replacement = ($$try2)[1];
            return $replacement;
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 185:12', (sp_toHuman)($$try2))));
    }))()
    : ((($raw)[0] === "TypeExact")
      ? ((() => {
        const $usr = ($raw)[1];
        const $pars = ($raw)[2];
        return ($sd0$Types$TypedAst$TypeExact)($usr, ($core$List$map)($rec, $pars));
      }))()
      : ((($raw)[0] === "TypeFn")
        ? ((() => {
          const $pars = ($raw)[1];
          const $out = ($raw)[2];
          return ($sd0$Types$TypedAst$TypeFn)(($core$List$map)((($1) => {
            return ($sd0$Types$TypedAst$resolveParType)($saf, $1);
          }), $pars), ($sd0$Types$TypedAst$resolveFull)($saf, $out));
        }))()
        : (((($raw)[0] === "TypeRecord") && ((($raw)[1])[0] === "Nothing"))
          ? ((() => {
            const $attrs = ($raw)[2];
            return ($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, ($core$Dict$map)((($k, $v) => {
              return ($rec)($v);
            }), $attrs));
          }))()
          : (((($raw)[0] === "TypeRecord") && ((($raw)[1])[0] === "Just"))
            ? ((() => {
              const $id = (($raw)[1])[1];
              const $attrs = ($raw)[2];
              const $$try1 = ($saf.ty)($id);
              return ((($$try1)[0] === "Just")
                ? ((() => {
                  const $replacement = ($$try1)[1];
                  return $replacement;
                }))()
                : ((($$try1)[0] === "Nothing")
                  ? ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($id), ($core$Dict$map)((($k, $v) => {
                    return ($rec)($v);
                  }), $attrs))
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 201:12', (sp_toHuman)($$try1))));
            }))()
            : ((($raw)[0] === "TypeError")
              ? $sd0$Types$TypedAst$TypeError
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 183:4', (sp_toHuman)($raw))))))));
});

const $sd0$Compiler$TypeCheck$applySubstitutionToType = (($tyvarId, $replacingType, $originalType) => {
  const $subsAsFns = ({
    ty: (($id) => {
      return ((sp_equal)($id, $tyvarId)
        ? ($core$Maybe$Just)($replacingType)
        : $core$Maybe$Nothing);
    }),
    uni: ((_0) => {
      return $core$Maybe$Nothing;
    }),
  });
  return ($sd0$Types$TypedAst$resolveRaw)($subsAsFns, $originalType);
});

const $sd0$Compiler$TypeCheck$newTyvarId = (($state) => {
  ($state.lastUnificationVarId += 1);
  return ([
    ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$replaceUnivarRec = (($old, $new, $raw) => {
  const $doRaw = (($2) => {
    return ($sd0$Compiler$TypeCheck$replaceUnivarRec)($old, $new, $2);
  });
  return ((($raw)[0] === "TypeExact")
    ? ((() => {
      const $usr = ($raw)[1];
      const $args = ($raw)[2];
      return ($sd0$Types$TypedAst$TypeExact)($usr, ($core$List$map)($doRaw, $args));
    }))()
    : ((($raw)[0] === "TypeRecord")
      ? ((() => {
        const $maybeExt = ($raw)[1];
        const $attrs = ($raw)[2];
        return ($sd0$Types$TypedAst$TypeRecord)($maybeExt, ($core$Dict$map)((($k, $v) => {
          return ($doRaw)($v);
        }), $attrs));
      }))()
      : ((($raw)[0] === "TypeError")
        ? $sd0$Types$TypedAst$TypeError
        : ((($raw)[0] === "TypeVar")
          ? ((() => {
            const $id = ($raw)[1];
            return ($sd0$Types$TypedAst$TypeVar)($id);
          }))()
          : ((($raw)[0] === "TypeFn")
            ? ((() => {
              const $ins = ($raw)[1];
              const $out = ($raw)[2];
              const $doUni = (($uni) => {
                return ((($uni)[0] === "Depends")
                  ? ((() => {
                    const $id = ($uni)[1];
                    return ((sp_equal)($id, $old)
                      ? $new
                      : $uni);
                  }))()
                  : (true
                    ? $uni
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 346:16', (sp_toHuman)($uni))));
              });
              const $mapPar = (($par) => {
                return ((($par)[0] === "ParRe")
                  ? ((() => {
                    const $r = ($par)[1];
                    return ($sd0$Types$TypedAst$ParRe)(($doRaw)($r));
                  }))()
                  : ((($par)[0] === "ParSp")
                    ? ((() => {
                      const $f = ($par)[1];
                      return ($sd0$Types$TypedAst$ParSp)(({
                        raw: ($doRaw)($f.raw),
                        uni: ($doUni)($f.uni),
                      }));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 352:16', (sp_toHuman)($par))));
              });
              return ($sd0$Types$TypedAst$TypeFn)(($core$List$map)($mapPar, $ins), ({
                raw: ($doRaw)($out.raw),
                uni: ($doUni)($out.uni),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 329:4', (sp_toHuman)($raw)))))));
});

const $sd0$Compiler$TypeCheck$generalize = (($env, $pos, $ref, $instance, $state) => {
  const $replaceUnivar = (($originalUnivarId, _1, $r) => {
    const $newUnivarId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
    return ($sd0$Compiler$TypeCheck$replaceUnivarRec)($originalUnivarId, ($sd0$Types$Ast$Depends)($newUnivarId), $r);
  });
  const $raw = ((($0) => {
    return ($core$Dict$for)($0, $instance.freeTyvars, (($originalTyvarId, $tyvar, $a) => {
      const $generalizedTyvarId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = (hash_insert)($state.tyvarsById, $generalizedTyvarId, ((() => {
        const $0 = $tyvar;
        return (Object.assign)({}, $0, ({
          generalizedAt: $pos,
          generalizedFor: $ref,
        }));
      }))())), ($state.tyvarsById = (__re__)[1]), (__re__)[0]);
      return ($sd0$Compiler$TypeCheck$applySubstitutionToType)($originalTyvarId, ($sd0$Types$TypedAst$TypeVar)($generalizedTyvarId), $a);
    }));
  }))(((($0) => {
    return ($core$Dict$for)($0, $instance.freeUnivars, $replaceUnivar);
  }))($instance.type.raw));
  const $0 = $instance.type;
  return ([
    (Object.assign)({}, $0, ({
      raw: $raw,
    })),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$getConstructorByUsr = (($usr, $env) => {
  return ($core$Dict$get)($usr, $env.constructors);
});

const $sd0$Compiler$TypeCheck$coreTypeNumber = ($sd0$Types$TypedAst$TypeExact)($sd0$Compiler$CoreTypes$numberDef.usr, $core$Core$Nil);

const $sd0$Compiler$TypeCheck$coreTypeText = ($sd0$Types$TypedAst$TypeExact)($sd0$Compiler$CoreTypes$textDef.usr, $core$Core$Nil);

const $sd0$Compiler$TypeCheck$newRawType = (($state) => {
  return ([
    ($sd0$Types$TypedAst$TypeVar)(((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0])),
    $state,
  ]);
});

const $sd0$Types$TypedAst$mapPars = (($f, $pars) => {
  const $zzz = (($par) => {
    return ((($par)[0] === "ParRe")
      ? ((() => {
        const $raw = ($par)[1];
        return ($sd0$Types$TypedAst$ParRe)(($f)($raw));
      }))()
      : ((($par)[0] === "ParSp")
        ? ((() => {
          const $full = ($par)[1];
          return ($sd0$Types$TypedAst$ParSp)(((() => {
            const $0 = $full;
            return (Object.assign)({}, $0, ({
              raw: ($f)($0.raw),
            }));
          }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 321:8', (sp_toHuman)($par))));
  });
  return ($core$List$map)($zzz, $pars);
});

const $sd0$Compiler$TypeCheck$expandTyvarsInType = (($tyvarIdsToType, $state, $type) => {
  const $rec = (($2) => {
    return ((__re__ = ($sd0$Compiler$TypeCheck$expandTyvarsInType)($tyvarIdsToType, $state, $2)), ($state = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((($type)[0] === "TypeExact")
      ? ((() => {
        const $usr = ($type)[1];
        const $args = ($type)[2];
        return ($sd0$Types$TypedAst$TypeExact)($usr, ($core$List$map)($rec, $args));
      }))()
      : ((($type)[0] === "TypeFn")
        ? ((() => {
          const $ins = ($type)[1];
          const $out = ($type)[2];
          return ($sd0$Types$TypedAst$TypeFn)(($sd0$Types$TypedAst$mapPars)($rec, $ins), ((() => {
            const $0 = $out;
            return (Object.assign)({}, $0, ({
              raw: ($rec)($0.raw),
            }));
          }))());
        }))()
        : (((($type)[0] === "TypeRecord") && ((($type)[1])[0] === "Nothing"))
          ? ((() => {
            const $attrs = ($type)[2];
            return ($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, ($core$Dict$map)((($k, $v) => {
              return ($rec)($v);
            }), $attrs));
          }))()
          : ((($type)[0] === "TypeVar")
            ? ((() => {
              const $id = ($type)[1];
              const $$try1 = ($core$Dict$get)($id, $tyvarIdsToType);
              return ((($$try1)[0] === "Nothing")
                ? ($sd0$Compiler$TypeCheck$bug)("this is not supposed to happen")
                : ((($$try1)[0] === "Just")
                  ? ((() => {
                    const $ty = ($$try1)[1];
                    return $ty;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 381:12', (sp_toHuman)($$try1))));
            }))()
            : (((($type)[0] === "TypeRecord") && ((($type)[1])[0] === "Just"))
              ? ((() => {
                const $id = (($type)[1])[1];
                const $attrs = ($type)[2];
                return ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($id), ($core$Dict$map)((($k, $v) => {
                  return ($rec)($v);
                }), $attrs));
              }))()
              : ((($type)[0] === "TypeError")
                ? $sd0$Types$TypedAst$TypeError
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 370:4', (sp_toHuman)($type)))))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$translateUni = (($originalIdToNewId, $originalUni) => {
  return ((($originalUni)[0] === "Depends")
    ? ((() => {
      const $originalId = ($originalUni)[1];
      const $$try1 = ($core$Dict$get)($originalId, $originalIdToNewId);
      return ((($$try1)[0] === "Just")
        ? ((() => {
          const $newId = ($$try1)[1];
          return ($sd0$Types$Ast$Depends)($newId);
        }))()
        : ((($$try1)[0] === "Nothing")
          ? $originalUni
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 398:12', (sp_toHuman)($$try1))));
    }))()
    : (true
      ? $originalUni
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 396:4', (sp_toHuman)($originalUni))));
});

const $sd0$Compiler$TypeCheck$translateFullType = (($env, $argsByName, $originalIdToNewId, $state, $caFull) => {
  return ([
    ({
      raw: ((__re__ = ($sd0$Compiler$TypeCheck$translateRawType)($env, $argsByName, $originalIdToNewId, $state, $caFull.raw)), ($state = (__re__)[1]), (__re__)[0]),
      uni: ($sd0$Compiler$TypeCheck$translateUni)($originalIdToNewId, $caFull.uni),
    }),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$translateRawType = (($env, $argsByName, $originalIdToNewId, $state, $caType) => {
  const $rec = (($4) => {
    return ((__re__ = ($sd0$Compiler$TypeCheck$translateRawType)($env, $argsByName, $originalIdToNewId, $state, $4)), ($state = (__re__)[1]), (__re__)[0]);
  });
  return ([
    ((($caType)[0] === "TypeFn")
      ? ((() => {
        const $pos = ($caType)[1];
        const $caPars = ($caType)[2];
        const $caOut = ($caType)[3];
        const $zzz = (($caPar) => {
          return ((($caPar)[0] === "ParRe")
            ? ((() => {
              const $caRaw = ($caPar)[1];
              return ($sd0$Types$TypedAst$ParRe)(($rec)($caRaw));
            }))()
            : ((($caPar)[0] === "ParSp")
              ? ((() => {
                const $caFull = ($caPar)[1];
                return ($sd0$Types$TypedAst$ParSp)(((__re__ = ($sd0$Compiler$TypeCheck$translateFullType)($env, $argsByName, $originalIdToNewId, $state, $caFull)), ($state = (__re__)[1]), (__re__)[0]));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 428:20', (sp_toHuman)($caPar))));
        });
        const $taArgs = ($core$List$map)($zzz, $caPars);
        return ($sd0$Types$TypedAst$TypeFn)($taArgs, ((__re__ = ($sd0$Compiler$TypeCheck$translateFullType)($env, $argsByName, $originalIdToNewId, $state, $caOut)), ($state = (__re__)[1]), (__re__)[0]));
      }))()
      : ((($caType)[0] === "TypeRecord")
        ? ((() => {
          const $pos = ($caType)[1];
          const $caAttrs = ($caType)[2];
          return ($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, ($core$Dict$map)((($name, $v) => {
            return ($rec)($v);
          }), $caAttrs));
        }))()
        : ((($caType)[0] === "TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($caType)[1];
            const $name = ($caType)[2];
            const $$try2 = ($core$Dict$get)($name, $argsByName);
            return ((($$try2)[0] === "Nothing")
              ? ((() => {
                ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorUndefinedTypeVariable)($name), $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $sd0$Types$TypedAst$TypeError;
              }))()
              : ((($$try2)[0] === "Just")
                ? ((() => {
                  const $raw = ($$try2)[1];
                  return $raw;
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 443:12', (sp_toHuman)($$try2))));
          }))()
          : ((($caType)[0] === "TypeNamed")
            ? ((() => {
              const $pos = ($caType)[1];
              const $usr = ($caType)[2];
              const $pars = ($caType)[3];
              const $expandedPars = ($core$List$map)($rec, $pars);
              const $$try1 = ($core$Dict$get)($usr, $env.expandedAliases);
              return ((($$try1)[0] === "Nothing")
                ? ($sd0$Types$TypedAst$TypeExact)($usr, $expandedPars)
                : ((($$try1)[0] === "Just")
                  ? ((() => {
                    const $expandedAlias = ($$try1)[1];
                    return ((sp_not_equal)(($core$List$length)($expandedAlias.pars), ($core$List$length)($expandedPars))
                      ? ((() => {
                        ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorWrongNumberOfTypeArguments)($usr, $expandedAlias.pars, $expandedPars), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return $sd0$Types$TypedAst$TypeError;
                      }))()
                      : ((() => {
                        const $tyvarIdsToType = ($core$Dict$fromList)(($core$List$map2)($core$Tuple$pair, $expandedAlias.pars, $expandedPars));
                        return ((__re__ = ($sd0$Compiler$TypeCheck$expandTyvarsInType)($tyvarIdsToType, $state, $expandedAlias.type)), ($state = (__re__)[1]), (__re__)[0]);
                      }))());
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 457:12', (sp_toHuman)($$try1))));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 423:4', (sp_toHuman)($caType)))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$translateAnnotation = (($env, $state, $ca) => {
  const $nameToType = ($core$Dict$map)((($k, $v) => {
    return ($sd0$Types$TypedAst$TypeVar)($v);
  }), $env.annotatedTyvarsByName);
  return ([
    ((__re__ = ($sd0$Compiler$TypeCheck$translateRawType)($env, $nameToType, $env.annotatedUnivarsByOriginalId, $state, $ca)), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferPatternAny = (($env, $pos, $uni, $$maybeAnnotation, $state) => {
  const $maybeAnnotation = $$maybeAnnotation.maybeAnnotation;
  const $maybeName = $$maybeAnnotation.maybeName;
  const $raw = ((($maybeAnnotation)[0] === "Nothing")
    ? ((__re__ = ($sd0$Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0])
    : ((($maybeAnnotation)[0] === "Just")
      ? ((() => {
        const $annotation = ($maybeAnnotation)[1];
        return ((__re__ = ($sd0$Compiler$TypeCheck$translateAnnotation)($env, $state, $annotation)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1574:8', (sp_toHuman)($maybeAnnotation))));
  const $type = ({
    raw: $raw,
    uni: $uni,
  });
  const $envWithVariable = ((($maybeName)[0] === "Nothing")
    ? $env
    : ((($maybeName)[0] === "Just")
      ? ((() => {
        const $name = ($maybeName)[1];
        const $variable = ({
          definedAt: $pos,
          freeTyvars: $core$Dict$empty,
          freeUnivars: $core$Dict$empty,
          type: $type,
        });
        const $0 = $env;
        return (Object.assign)({}, $0, ({
          variables: ($core$Dict$insert)(($sd0$Types$Ast$RefLocal)($name), $variable, $0.variables),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1585:8', (sp_toHuman)($maybeName))));
  const $typedPattern = ($sd0$Types$TypedAst$PatternAny)($pos, ({
    maybeName: $maybeName,
    type: $type,
  }));
  return ([
    ({
      env: $envWithVariable,
      maybeFullAnnotation: $maybeAnnotation,
      patternType: $raw,
      typedPattern: $typedPattern,
    }),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$list_eachWithIndex2 = (($index, $aa, $bb, $f) => {
  const $$try1 = ({
    first: $aa,
    second: $bb,
  });
  return (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Cons"))
    ? ((() => {
      const $a = ($$try1.first)[1];
      const $at = ($$try1.first)[2];
      const $b = ($$try1.second)[1];
      const $bt = ($$try1.second)[2];
      ($f)($index, $a, $b);
      return ($sd0$Compiler$TypeCheck$list_eachWithIndex2)(($index + 1), $at, $bt, $f);
    }))()
    : (true
      ? null
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 57:4', (sp_toHuman)($$try1))));
});

const $sd0$Compiler$TypeCheck$inferPattern = (($env, $uni, $pattern, $state) => {
  return ([
    ((($pattern)[0] === "PatternAny")
      ? ((() => {
        const $pos = ($pattern)[1];
        const $args = ($pattern)[2];
        return ((__re__ = ($sd0$Compiler$TypeCheck$inferPatternAny)($env, $pos, $uni, $args, $state)), ($state = (__re__)[1]), (__re__)[0]);
      }))()
      : ((($pattern)[0] === "PatternLiteralText")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $text = ($pattern)[2];
          return ({
            env: $env,
            maybeFullAnnotation: $core$Maybe$Nothing,
            patternType: $sd0$Compiler$TypeCheck$coreTypeText,
            typedPattern: ($sd0$Types$TypedAst$PatternLiteralText)($pos, $text),
          });
        }))()
        : ((($pattern)[0] === "PatternLiteralNumber")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $n = ($pattern)[2];
            return ({
              env: $env,
              maybeFullAnnotation: $core$Maybe$Nothing,
              patternType: $sd0$Compiler$TypeCheck$coreTypeNumber,
              typedPattern: ($sd0$Types$TypedAst$PatternLiteralNumber)($pos, $n),
            });
          }))()
          : ((($pattern)[0] === "PatternConstructor")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $usr = ($pattern)[2];
              const $arguments = ($pattern)[3];
              const $$argumentOuts = ((($0) => {
                return ($core$List$forReversed)($0, $arguments, (($arg, $$argOuts) => {
                  const $argOuts = $$argOuts.first;
                  const $envX = $$argOuts.second;
                  const $out = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($envX, $uni, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return ({
                    first: (sp_cons)($out, $argOuts),
                    second: $out.env,
                  });
                }));
              }))(({
                first: $core$Core$Nil,
                second: $env,
              }));
              const $newEnv = $$argumentOuts.second;
              const $argumentOuts = $$argumentOuts.first;
              const $typedArguments = ($core$List$map)((($out) => {
                return $out.typedPattern;
              }), $argumentOuts);
              const $argumentTypes = ($core$List$map)((($out) => {
                return $out.patternType;
              }), $argumentOuts);
              const $finalType = ((() => {
                const $$try1 = ($sd0$Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
                return ((($$try1)[0] === "Nothing")
                  ? ((() => {
                    ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $sd0$Types$TypedAst$TypeError;
                  }))()
                  : ((($$try1)[0] === "Just")
                    ? ((() => {
                      const $cons = ($$try1)[1];
                      const $x = ((__re__ = ($sd0$Compiler$TypeCheck$generalize)($env, $pos, ($sd0$Types$Ast$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $$parTypes = ((() => {
                        const $$try2 = $x.raw;
                        return ((($$try2)[0] === "TypeFn")
                          ? ((() => {
                            const $ins = ($$try2)[1];
                            const $out = ($$try2)[2];
                            return ({
                              first: $ins,
                              second: $out.raw,
                            });
                          }))()
                          : (true
                            ? ({
                              first: $core$Core$Nil,
                              second: $x.raw,
                            })
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1521:28', (sp_toHuman)($$try2))));
                      }))();
                      const $returnType = $$parTypes.second;
                      const $parTypes = $$parTypes.first;
                      ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)(($core$List$length)($parTypes), ($core$List$length)($arguments)), $env, $pos, $sd0$Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      ($sd0$Compiler$TypeCheck$list_eachWithIndex2)(0, $parTypes, $argumentTypes, (($index, $parType, $argType) => {
                        return ((($parType)[0] === "ParRe")
                          ? ((() => {
                            const $raw = ($parType)[1];
                            return ($sd0$Compiler$TypeCheck$bug)("cons can't recycle?!");
                          }))()
                          : ((($parType)[0] === "ParSp")
                            ? ((() => {
                              const $full = ($parType)[1];
                              return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, ($sd0$Compiler$TypeCheck$Why_Argument)($index), $full.raw, $argType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            }))()
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1528:28', (sp_toHuman)($parType))));
                      }));
                      return $returnType;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1510:16', (sp_toHuman)($$try1))));
              }))();
              return ({
                env: $newEnv,
                maybeFullAnnotation: $core$Maybe$Nothing,
                patternType: $finalType,
                typedPattern: ($sd0$Types$TypedAst$PatternConstructor)($pos, $usr, $typedArguments),
              });
            }))()
            : ((($pattern)[0] === "PatternRecord")
              ? ((() => {
                const $pos = ($pattern)[1];
                const $completeness = ($pattern)[2];
                const $pas = ($pattern)[3];
                const $$newEnv = ((($0) => {
                  return ($core$Dict$for)($0, $pas, (($name, $pa, $$dict) => {
                    const $dict = $$dict.first;
                    const $envX = $$dict.second;
                    const $out = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($envX, $uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ({
                      first: ($core$Dict$insert)($name, $out, $dict),
                      second: $out.env,
                    });
                  }));
                }))(({
                  first: $core$Dict$empty,
                  second: $env,
                }));
                const $newEnv = $$newEnv.second;
                const $outs = $$newEnv.first;
                const $patternExt = ((($completeness)[0] === "Complete")
                  ? $core$Maybe$Nothing
                  : ((($completeness)[0] === "Partial")
                    ? ($core$Maybe$Just)(((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]))
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1554:16', (sp_toHuman)($completeness))));
                const $raw = ($sd0$Types$TypedAst$TypeRecord)($patternExt, ((($1) => {
                  return ($core$Dict$map)((($name, $out) => {
                    return $out.patternType;
                  }), $1);
                }))($outs));
                return ({
                  env: $newEnv,
                  maybeFullAnnotation: $core$Maybe$Nothing,
                  patternType: $raw,
                  typedPattern: ($sd0$Types$TypedAst$PatternRecord)($pos, ((($1) => {
                    return ($core$Dict$map)((($k, $o) => {
                      return ({
                        first: $o.typedPattern,
                        second: $o.patternType,
                      });
                    }), $1);
                  }))($outs)),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1470:4', (sp_toHuman)($pattern))))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$fullTypeError = ({
  raw: $sd0$Types$TypedAst$TypeError,
  uni: $sd0$Types$Ast$Uni,
});

const $sd0$Compiler$TypeCheck$patternError = (($pos) => {
  return ($sd0$Types$TypedAst$PatternAny)($pos, ({
    maybeName: $core$Maybe$Nothing,
    type: $sd0$Compiler$TypeCheck$fullTypeError,
  }));
});

const $sd0$Compiler$TypeCheck$checkPatternConstructor = (($env, $pos, $expectedType, $usr, $arguments, $state) => {
  const $insertArgsOnError = (($0) => {
    return ($core$List$for)($0, $arguments, (($arg, $envX) => {
      const $out = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($envX, $expectedType.uni, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
      return $out.env;
    }));
  });
  const $$try1 = ($sd0$Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
  return ([
    ((($$try1)[0] === "Nothing")
      ? ((() => {
        ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
        return ({
          first: ($sd0$Compiler$TypeCheck$patternError)($pos),
          second: ($insertArgsOnError)($env),
        });
      }))()
      : ((($$try1)[0] === "Just")
        ? ((() => {
          const $instance = ($$try1)[1];
          const $fullType_ = ((__re__ = ($sd0$Compiler$TypeCheck$generalize)($env, $pos, ($sd0$Types$Ast$RefGlobal)($usr), ((() => {
            const $0 = $instance;
            return (Object.assign)({}, $0, ({
              freeUnivars: $core$Dict$empty,
            }));
          }))(), $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $fullType = ((() => {
            const $0 = $fullType_;
            return (Object.assign)({}, $0, ({
              raw: ($sd0$Compiler$TypeCheck$replaceUnivarRec)(1, $expectedType.uni, $0.raw),
            }));
          }))();
          const $$requiredOut = ((() => {
            const $$try2 = $fullType.raw;
            return ((($$try2)[0] === "TypeFn")
              ? ((() => {
                const $ax = ($$try2)[1];
                const $o = ($$try2)[2];
                return ({
                  first: $ax,
                  second: $o,
                });
              }))()
              : (true
                ? ({
                  first: $core$Core$Nil,
                  second: $fullType,
                })
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1734:16', (sp_toHuman)($$try2))));
          }))();
          const $requiredOut = $$requiredOut.second;
          const $requiredParTypes = $$requiredOut.first;
          return ((sp_not_equal)(($core$List$length)($arguments), ($core$List$length)($requiredParTypes))
            ? ((() => {
              ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: ($sd0$Compiler$TypeCheck$patternError)($pos),
                second: ($insertArgsOnError)($env),
              });
            }))()
            : ((() => {
              const $checkArg = (($$arg, $$args) => {
                const $arg = $$arg.first;
                const $parType = $$arg.second;
                const $envX = $$args.first;
                const $args = $$args.second;
                const $$envX1 = ((($parType)[0] === "ParSp")
                  ? ((() => {
                    const $full = ($parType)[1];
                    return ((__re__ = ($sd0$Compiler$TypeCheck$checkPattern)($envX, $full, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($parType)[0] === "ParRe")
                    ? ((() => {
                      const $raw = ($parType)[1];
                      return ($sd0$Compiler$TypeCheck$bug)("should not happen???");
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1746:28', (sp_toHuman)($parType))));
                const $envX1 = $$envX1.second;
                const $taArg = $$envX1.first;
                return ({
                  first: $envX1,
                  second: (sp_cons)($taArg, $args),
                });
              });
              const $$newEnv = ((($0) => {
                return ($core$List$forReversed)($0, ($core$List$map2)($core$Tuple$pair, $arguments, $requiredParTypes), $checkArg);
              }))(({
                first: $env,
                second: $core$Core$Nil,
              }));
              const $typedArgs = $$newEnv.second;
              const $newEnv = $$newEnv.first;
              ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_CalledAsFunction, $requiredOut.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: ($sd0$Types$TypedAst$PatternConstructor)($pos, $usr, $typedArgs),
                second: $newEnv,
              });
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1718:4', (sp_toHuman)($$try1)))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$checkPatternRecord = (($env, $pos, $expectedType, $completeness, $pas, $state) => {
  const $$uni = $expectedType;
  const $uni = $$uni.uni;
  const $$try1 = $expectedType.raw;
  return ([
    (((($$try1)[0] === "TypeRecord") && ((($$try1)[1])[0] === "Nothing"))
      ? ((() => {
        const $attrs = ($$try1)[2];
        const $$both = ($core$Dict$onlyBothOnly)($pas, $attrs);
        const $typeOnly = $$both.third;
        const $both = $$both.second;
        const $paOnly = $$both.first;
        ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($paOnly, $core$Dict$empty), $env, $pos, $sd0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation, $state)), ($state = (__re__)[1]), (__re__)[0]);
        ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)(((sp_not_equal)($typeOnly, $core$Dict$empty) && (sp_equal)($completeness, $sd0$Types$CanonicalAst$Complete)), $env, $pos, $sd0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation, $state)), ($state = (__re__)[1]), (__re__)[0]);
        const $$envF = ((($0) => {
          return ($core$Dict$for)($0, $both, (($name, $$pa, $$acc) => {
            const $pa = $$pa.first;
            const $raw = $$pa.second;
            const $acc = $$acc.first;
            const $envX = $$acc.second;
            const $$envX0 = ((__re__ = ($sd0$Compiler$TypeCheck$checkPattern)(((() => {
              const $0 = $envX;
              return (Object.assign)({}, $0, ({
                context: ($sd0$Compiler$TypeCheck$Context_AttributeName)($name, $env.context),
              }));
            }))(), ({
              raw: $raw,
              uni: $uni,
            }), $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $envX0 = $$envX0.second;
            const $taPa = $$envX0.first;
            return ({
              first: ($core$Dict$insert)($name, ({
                first: $taPa,
                second: $raw,
              }), $acc),
              second: ((() => {
                const $0 = $envX0;
                return (Object.assign)({}, $0, ({
                  context: $env.context,
                }));
              }))(),
            });
          }));
        }))(({
          first: $core$Dict$empty,
          second: $env,
        }));
        const $envF = $$envF.second;
        const $taPas = $$envF.first;
        return ({
          first: ($sd0$Types$TypedAst$PatternRecord)($pos, $taPas),
          second: $envF,
        });
      }))()
      : (((($$try1)[0] === "TypeRecord") && ((($$try1)[1])[0] === "Just"))
        ? ((() => {
          const $tyvarId = (($$try1)[1])[1];
          const $a = ($$try1)[2];
          return ($sd0$Compiler$TypeCheck$bug)("can't annotate extensible types");
        }))()
        : (true
          ? ((() => {
            ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorNotCompatibleWithRecord, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $envF = ((($0) => {
              return ($core$Dict$for)($0, $pas, (($name, $pa, $envX) => {
                const $out = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($envX, $expectedType.uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $out.env;
              }));
            }))($env);
            return ({
              first: ($sd0$Compiler$TypeCheck$patternError)($pos),
              second: $envF,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1669:4', (sp_toHuman)($$try1))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$checkPattern = (($env, $expectedType, $pattern, $state) => {
  const $$try1 = ({
    first: $pattern,
    second: $expectedType.raw,
  });
  return ([
    ((($$try1.first)[0] === "PatternAny")
      ? ((() => {
        const $pos = ($$try1.first)[1];
        const $maybeAnnotation = ($$try1.first)[2].maybeAnnotation;
        const $maybeName = ($$try1.first)[2].maybeName;
        const $newEnv = ((($maybeName)[0] === "Nothing")
          ? $env
          : ((($maybeName)[0] === "Just")
            ? ((() => {
              const $name = ($maybeName)[1];
              const $variable = ({
                definedAt: $pos,
                freeTyvars: $core$Dict$empty,
                freeUnivars: $core$Dict$empty,
                type: $expectedType,
              });
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: ($core$Dict$insert)(($sd0$Types$Ast$RefLocal)($name), $variable, $0.variables),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1621:16', (sp_toHuman)($maybeName))));
        return ({
          first: ($sd0$Types$TypedAst$PatternAny)($pos, ({
            maybeName: $maybeName,
            type: $expectedType,
          })),
          second: $newEnv,
        });
      }))()
      : (((($$try1.first)[0] === "PatternLiteralText") && ((($$try1.second)[0] === "TypeExact") && ((($$try1.second)[2])[0] === "Nil")))
        ? ((() => {
          const $pos = ($$try1.first)[1];
          const $text = ($$try1.first)[2];
          const $typeUsr = ($$try1.second)[1];
          ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, $sd0$Compiler$CoreTypes$textDef.usr), $env, $pos, ($sd0$Compiler$TypeCheck$ErrorIncompatiblePattern)($pattern, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
          return ({
            first: ($sd0$Types$TypedAst$PatternLiteralText)($pos, $text),
            second: $env,
          });
        }))()
        : (((($$try1.first)[0] === "PatternLiteralNumber") && ((($$try1.second)[0] === "TypeExact") && ((($$try1.second)[2])[0] === "Nil")))
          ? ((() => {
            const $pos = ($$try1.first)[1];
            const $text = ($$try1.first)[2];
            const $typeUsr = ($$try1.second)[1];
            ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, $sd0$Compiler$CoreTypes$numberDef.usr), $env, $pos, ($sd0$Compiler$TypeCheck$ErrorIncompatiblePattern)($pattern, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: ($sd0$Types$TypedAst$PatternLiteralNumber)($pos, $text),
              second: $env,
            });
          }))()
          : ((($$try1.first)[0] === "PatternConstructor")
            ? ((() => {
              const $pos = ($$try1.first)[1];
              const $usr = ($$try1.first)[2];
              const $arguments = ($$try1.first)[3];
              return ((__re__ = ($sd0$Compiler$TypeCheck$checkPatternConstructor)($env, $pos, $expectedType, $usr, $arguments, $state)), ($state = (__re__)[1]), (__re__)[0]);
            }))()
            : ((($$try1.first)[0] === "PatternRecord")
              ? ((() => {
                const $pos = ($$try1.first)[1];
                const $completeness = ($$try1.first)[2];
                const $pas = ($$try1.first)[3];
                return ((__re__ = ($sd0$Compiler$TypeCheck$checkPatternRecord)($env, $pos, $expectedType, $completeness, $pas, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1617:4', (sp_toHuman)($$try1))))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$checkParameter = (($env, $expectedParType, $par, $state) => {
  return ([
    ((($par)[0] === "ParameterPattern")
      ? ((() => {
        const $originalUni = ($par)[1];
        const $pa = ($par)[2];
        const $$env1 = ((($expectedParType)[0] === "ParRe")
          ? ((() => {
            ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, ($sd0$Types$CanonicalAst$patternPos)($pa), $sd0$Compiler$TypeCheck$ErrorRecyclingDoesNotMatch, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $o = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($env, $sd0$Types$Ast$Uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: ({
                raw: $o.patternType,
                uni: $sd0$Types$Ast$Uni,
              }),
              second: ({
                first: $o.typedPattern,
                second: $o.env,
              }),
            });
          }))()
          : ((($expectedParType)[0] === "ParSp")
            ? ((() => {
              const $full = ($expectedParType)[1];
              const $uni = ($sd0$Compiler$TypeCheck$translateUni)($env.annotatedUnivarsByOriginalId, $originalUni);
              ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($uni, $full.uni), $env, ($sd0$Types$CanonicalAst$patternPos)($pa), ($sd0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter)($uni, $full), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return ({
                first: $full,
                second: ((__re__ = ($sd0$Compiler$TypeCheck$checkPattern)($env, $full, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1084:16', (sp_toHuman)($expectedParType))));
        const $env1 = $$env1.second.second;
        const $typedPa = $$env1.second.first;
        const $fullType = $$env1.first;
        return ({
          first: ($sd0$Types$TypedAst$ParameterPattern)($fullType, $typedPa),
          second: $env1,
        });
      }))()
      : ((($par)[0] === "ParameterPlaceholder")
        ? ((() => {
          const $name = ($par)[1];
          const $num = ($par)[2];
          return ((($expectedParType)[0] === "ParRe")
            ? (sp_todo)("TA.ParRe")
            : ((($expectedParType)[0] === "ParSp")
              ? ((() => {
                const $type = ($expectedParType)[1];
                const $pa = ($sd0$Types$TypedAst$PatternAny)($sd0$Types$Pos$G, ({
                  maybeName: ($core$Maybe$Just)($name),
                  type: $type,
                }));
                const $variable = ({
                  definedAt: $sd0$Types$Pos$G,
                  freeTyvars: $core$Dict$empty,
                  freeUnivars: $core$Dict$empty,
                  type: $type,
                });
                return ({
                  first: ($sd0$Types$TypedAst$ParameterPattern)($type, $pa),
                  second: ((() => {
                    const $0 = $env;
                    return (Object.assign)({}, $0, ({
                      variables: ($core$Dict$insert)(($sd0$Types$Ast$RefLocal)($name), $variable, $0.variables),
                    }));
                  }))(),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1099:12', (sp_toHuman)($expectedParType))));
        }))()
        : ((($par)[0] === "ParameterRecycle")
          ? ((() => {
            const $pos = ($par)[1];
            const $name = ($par)[2];
            const $expectedRaw = ((($expectedParType)[0] === "ParSp")
              ? ((() => {
                const $full = ($expectedParType)[1];
                ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorRecyclingDoesNotMatch, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $sd0$Types$TypedAst$TypeError;
              }))()
              : ((($expectedParType)[0] === "ParRe")
                ? ((() => {
                  const $raw = ($expectedParType)[1];
                  return $raw;
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1119:16', (sp_toHuman)($expectedParType))));
            const $variable = ({
              definedAt: $pos,
              freeTyvars: $core$Dict$empty,
              freeUnivars: $core$Dict$empty,
              type: ({
                raw: $expectedRaw,
                uni: $sd0$Types$Ast$Uni,
              }),
            });
            const $localEnv = ((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: ($core$Dict$insert)(($sd0$Types$Ast$RefLocal)($name), $variable, $0.variables),
              }));
            }))();
            return ({
              first: ($sd0$Types$TypedAst$ParameterRecycle)($pos, $expectedRaw, $name),
              second: $localEnv,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1079:4', (sp_toHuman)($par))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$addConstraint = (($env, $pos, $id, $uni, $state) => {
  const $eq = ({
    context: $sd0$Compiler$TypeCheck$Context_Global,
    id: $id,
    pos: $pos,
    uni: $uni,
    why: "-",
  });
  return ([
    ((__re__ = (array_push)($state.univarEqualities, $eq)), ($state.univarEqualities = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$uniCanBeCastTo = (($$given) => {
  const $given = $$given.given;
  const $required = $$given.required;
  const $$try1 = ({
    first: $given,
    second: $required,
  });
  return ((($$try1.second)[0] === "Imm")
    ? $sd0$Compiler$TypeCheck$CanBeCastYes
    : ((($$try1.first)[0] === "Uni")
      ? $sd0$Compiler$TypeCheck$CanBeCastYes
      : (((($$try1.first)[0] === "Imm") && (($$try1.second)[0] === "Uni"))
        ? ($sd0$Compiler$TypeCheck$CanBeCastNo)($core$Core$Nil)
        : (((($$try1.first)[0] === "Depends") && (($$try1.second)[0] === "Uni"))
          ? ((() => {
            const $a = ($$try1.first)[1];
            return ($sd0$Compiler$TypeCheck$CanBeCastNo)(($core$Core$Cons)(({
              first: $a,
              second: $sd0$Types$Ast$Uni,
            }), $core$Core$Nil));
          }))()
          : (((($$try1.first)[0] === "Depends") && (($$try1.second)[0] === "Depends"))
            ? ((() => {
              const $a = ($$try1.first)[1];
              const $b = ($$try1.second)[1];
              return ((sp_equal)($a, $b)
                ? $sd0$Compiler$TypeCheck$CanBeCastYes
                : ($sd0$Compiler$TypeCheck$CanBeCastNo)(($core$Core$Cons)(({
                  first: $a,
                  second: ($sd0$Types$Ast$Depends)($b),
                }), ($core$Core$Cons)(({
                  first: $b,
                  second: ($sd0$Types$Ast$Depends)($a),
                }), $core$Core$Nil))));
            }))()
            : (((($$try1.first)[0] === "Imm") && (($$try1.second)[0] === "Depends"))
              ? ((() => {
                const $b = ($$try1.second)[1];
                return ($sd0$Compiler$TypeCheck$CanBeCastNo)(($core$Core$Cons)(({
                  first: $b,
                  second: $sd0$Types$Ast$Imm,
                }), $core$Core$Nil));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 496:4', (sp_toHuman)($$try1))))))));
});

const $sd0$Compiler$TypeCheck$checkUni = (($env, $pos, $$fix, $state) => {
  const $fix = $$fix.fix;
  const $mut = $$fix.mut;
  const $$try1 = ($sd0$Compiler$TypeCheck$uniCanBeCastTo)(({
    given: $mut,
    required: $fix,
  }));
  return ([
    ((($$try1)[0] === "CanBeCastYes")
      ? null
      : (((($$try1)[0] === "CanBeCastNo") && ((($$try1)[1])[0] === "Nil"))
        ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatch)(({
          fix: $fix,
          mut: $mut,
        })), $state)), ($state = (__re__)[1]), (__re__)[0])
        : (((($$try1)[0] === "CanBeCastNo") && ((($$try1)[1])[0] === "Cons"))
          ? ((() => {
            const $univarId = (($$try1)[1])[1].first;
            const $uni = (($$try1)[1])[1].second;
            const $tail = (($$try1)[1])[2];
            return ((__re__ = ($sd0$Compiler$TypeCheck$addConstraint)($env, $pos, $univarId, $uni, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 526:4', (sp_toHuman)($$try1))))),
    $state,
  ]);
});

const $sd0$Compiler$CoreTypes$boolDef = ((() => {
  const $usr = ($sd0$Compiler$CoreTypes$makeUsr)("Bool");
  return ({
    constructors: ((($2) => {
      return ($core$Dict$insert)("False", ({
        ins: $core$Core$Nil,
        out: $sd0$Compiler$CoreTypes$bool,
        pos: $sd0$Compiler$CoreTypes$p,
        typeUsr: $usr,
      }), $2);
    }))(((($2) => {
      return ($core$Dict$insert)("True", ({
        ins: $core$Core$Nil,
        out: $sd0$Compiler$CoreTypes$bool,
        pos: $sd0$Compiler$CoreTypes$p,
        typeUsr: $usr,
      }), $2);
    }))($core$Dict$empty)),
    directTypeDeps: $core$Set$empty,
    pars: $core$Core$Nil,
    usr: $usr,
  });
}))();

const $sd0$Compiler$TypeCheck$coreTypeBool = ($sd0$Types$TypedAst$TypeExact)($sd0$Compiler$CoreTypes$boolDef.usr, $core$Core$Nil);

const $sd0$Compiler$TypeCheck$getVariableByRef = (($ref, $env) => {
  return ($core$Dict$get)($ref, $env.variables);
});

const $sd0$Compiler$TypeCheck$inferUni = (($a, $b) => {
  const $$try1 = ({
    first: $a,
    second: $b,
  });
  return ((($$try1.first)[0] === "Imm")
    ? $sd0$Types$Ast$Imm
    : ((($$try1.second)[0] === "Imm")
      ? $sd0$Types$Ast$Imm
      : (((($$try1.first)[0] === "Depends") && (($$try1.second)[0] === "Depends"))
        ? ((() => {
          const $aId = ($$try1.first)[1];
          const $bId = ($$try1.second)[1];
          return $sd0$Types$Ast$Imm;
        }))()
        : ((($$try1.second)[0] === "Depends")
          ? $b
          : (true
            ? $sd0$Types$Ast$Uni
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 577:4', (sp_toHuman)($$try1)))))));
});

const $sd0$Types$CanonicalAst$expressionPos = (($exp) => {
  return ((($exp)[0] === "LiteralNumber")
    ? ((() => {
      const $p = ($exp)[1];
      return $p;
    }))()
    : ((($exp)[0] === "LiteralText")
      ? ((() => {
        const $p = ($exp)[1];
        return $p;
      }))()
      : ((($exp)[0] === "Variable")
        ? ((() => {
          const $p = ($exp)[1];
          return $p;
        }))()
        : ((($exp)[0] === "Constructor")
          ? ((() => {
            const $p = ($exp)[1];
            return $p;
          }))()
          : ((($exp)[0] === "Fn")
            ? ((() => {
              const $p = ($exp)[1];
              return $p;
            }))()
            : ((($exp)[0] === "Call")
              ? ((() => {
                const $p = ($exp)[1];
                return $p;
              }))()
              : ((($exp)[0] === "Record")
                ? ((() => {
                  const $p = ($exp)[1];
                  return $p;
                }))()
                : ((($exp)[0] === "RecordAccess")
                  ? ((() => {
                    const $p = ($exp)[1];
                    return $p;
                  }))()
                  : ((($exp)[0] === "LetIn")
                    ? ((() => {
                      const $def = ($exp)[1];
                      const $e = ($exp)[2];
                      return ($sd0$Types$CanonicalAst$expressionPos)($e);
                    }))()
                    : ((($exp)[0] === "If")
                      ? ((() => {
                        const $p = ($exp)[1];
                        return $p;
                      }))()
                      : ((($exp)[0] === "Try")
                        ? ((() => {
                          const $p = ($exp)[1];
                          return $p;
                        }))()
                        : ((($exp)[0] === "DestroyIn")
                          ? $sd0$Types$Pos$G
                          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/CanonicalAst.sp 225:4', (sp_toHuman)($exp))))))))))))));
});

const $sd0$Compiler$TypeCheck$doTry = (($env, $pos, $expectedRaw, $value, $caPatternsAndExpressions, $state) => {
  const $$typedValue = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $valueType = $$typedValue.second;
  const $typedValue = $$typedValue.first;
  const $$patternsAndExpressions = ((($0) => {
    return ($core$List$forReversed)($0, $caPatternsAndExpressions, (($$exp, $$acc) => {
      const $u = $$exp.first;
      const $pa = $$exp.second;
      const $exp = $$exp.third;
      const $uniX = $$acc.first;
      const $acc = $$acc.second;
      const $patternOut = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($env, $u, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_TryPattern, $patternOut.patternType, $valueType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
      ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($env, $pos, ({
        fix: $u,
        mut: $valueType.uni,
      }), $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $newEnv = ((() => {
        const $0 = $patternOut.env;
        return (Object.assign)({}, $0, ({
          context: $sd0$Compiler$TypeCheck$Context_TryBranch,
        }));
      }))();
      const $$expressionType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($newEnv, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $expressionType = $$expressionType.second;
      const $typedExpression = $$expressionType.first;
      ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($newEnv, ($sd0$Types$CanonicalAst$expressionPos)($exp), $sd0$Compiler$TypeCheck$Why_TryExpression, $expectedRaw, $expressionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
      const $uf = ($sd0$Compiler$TypeCheck$inferUni)($uniX, $expressionType.uni);
      const $l = (sp_cons)(({
        first: $patternOut.typedPattern,
        second: $typedExpression,
      }), $acc);
      return ({
        first: $uf,
        second: $l,
      });
    }));
  }))(({
    first: $sd0$Types$Ast$Uni,
    second: $core$Core$Nil,
  }));
  const $patternsAndExpressions = $$patternsAndExpressions.second;
  const $uni = $$patternsAndExpressions.first;
  return ([
    ({
      first: ($sd0$Types$TypedAst$Try)($pos, ({
        patternsAndExpressions: $patternsAndExpressions,
        value: $typedValue,
        valueType: $valueType,
      })),
      second: ({
        raw: $expectedRaw,
        uni: $uni,
      }),
    }),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferParam = (($env, $parIndex, $par, $state) => {
  return ([
    ((($par)[0] === "ParameterRecycle")
      ? ((() => {
        const $pos = ($par)[1];
        const $name = ($par)[2];
        const $raw = ($sd0$Types$TypedAst$TypeVar)(((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]));
        const $instance = ({
          definedAt: $pos,
          freeTyvars: $core$Dict$empty,
          freeUnivars: $core$Dict$empty,
          type: ({
            raw: $raw,
            uni: $sd0$Types$Ast$Uni,
          }),
        });
        const $newEnv = ((() => {
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            variables: ($core$Dict$insert)(($sd0$Types$Ast$RefLocal)($name), $instance, $0.variables),
          }));
        }))();
        return ({
          first: ($sd0$Types$TypedAst$ParameterRecycle)($pos, $raw, $name),
          second: ($sd0$Types$TypedAst$ParRe)($raw),
          third: $newEnv,
        });
      }))()
      : ((($par)[0] === "ParameterPattern")
        ? ((() => {
          const $uni = ($par)[1];
          const $pa = ($par)[2];
          const $out = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)($env, $uni, $pa, $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $full = ({
            raw: $out.patternType,
            uni: $uni,
          });
          return ({
            first: ($sd0$Types$TypedAst$ParameterPattern)($full, $out.typedPattern),
            second: ($sd0$Types$TypedAst$ParSp)($full),
            third: $out.env,
          });
        }))()
        : ((($par)[0] === "ParameterPlaceholder")
          ? ((() => {
            const $name = ($par)[1];
            const $num = ($par)[2];
            const $univarId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $raw = ((__re__ = ($sd0$Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $type = ({
              raw: $raw,
              uni: ($sd0$Types$Ast$Depends)($univarId),
            });
            const $instance = ({
              definedAt: $sd0$Types$Pos$G,
              freeTyvars: $core$Dict$empty,
              freeUnivars: $core$Dict$empty,
              type: $type,
            });
            const $newEnv = ((() => {
              const $0 = $env;
              return (Object.assign)({}, $0, ({
                variables: ($core$Dict$insert)(($sd0$Types$Ast$RefLocal)($name), $instance, $0.variables),
              }));
            }))();
            const $pa = ($sd0$Types$TypedAst$PatternAny)($sd0$Types$Pos$G, ({
              maybeName: ($core$Maybe$Just)($name),
              type: $type,
            }));
            return ({
              first: ($sd0$Types$TypedAst$ParameterPattern)($type, $pa),
              second: ($sd0$Types$TypedAst$ParSp)($type),
              third: $newEnv,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 863:4', (sp_toHuman)($par))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferFn = (($env, $pos, $caPars, $body, $state) => {
  let $typedPars = (array_fromList)($core$Core$Nil);
  let $parTypes = (array_fromList)($core$Core$Nil);
  let $parIndex = 0;
  const $newEnv = ($core$List$for)($env, $caPars, (($par, $envX) => {
    const $$envX1 = ((__re__ = ($sd0$Compiler$TypeCheck$inferParam)($envX, ((__re__ = (basics_cloneUni)($parIndex)), ($parIndex = (__re__)[1]), (__re__)[0]), $par, $state)), ($state = (__re__)[1]), (__re__)[0]);
    const $envX1 = $$envX1.third;
    const $parType = $$envX1.second;
    const $typedPar = $$envX1.first;
    ((__re__ = (array_push)($typedPars, $typedPar)), ($typedPars = (__re__)[1]), (__re__)[0]);
    ((__re__ = (array_push)($parTypes, $parType)), ($parTypes = (__re__)[1]), (__re__)[0]);
    ($parIndex += 1);
    return $envX1;
  }));
  const $$bodyType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)(((() => {
    const $0 = $newEnv;
    return (Object.assign)({}, $0, ({
      context: ($sd0$Compiler$TypeCheck$Context_FnBody)($pos, $env.context),
    }));
  }))(), $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $bodyType = $$bodyType.second;
  const $typedBody = $$bodyType.first;
  const $type = ($sd0$Types$TypedAst$TypeFn)(((__re__ = (array_toList)($parTypes)), ($parTypes = (__re__)[1]), (__re__)[0]), $bodyType);
  const $exp = ($sd0$Types$TypedAst$Fn)($pos, ((__re__ = (array_toList)($typedPars)), ($typedPars = (__re__)[1]), (__re__)[0]), $typedBody, $bodyType);
  return ([
    ({
      first: $exp,
      second: ({
        raw: $type,
        uni: $sd0$Types$Ast$Uni,
      }),
    }),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferRecord = (($env, $pos, $maybeExt, $caAttrs, $state) => {
  const $taAttrs = ($core$Dict$map)((($name, $value) => {
    return ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        context: ($sd0$Compiler$TypeCheck$Context_Argument)($name, $0.context),
      }));
    }))(), $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
  }), $caAttrs);
  const $typedAttrs = ($core$Dict$map)((($k, $v) => {
    return ($core$Tuple$first)($v);
  }), $taAttrs);
  const $attrTypes = ($core$Dict$map)((($k, $$t) => {
    const $t = $$t.second;
    return $t.raw;
  }), $taAttrs);
  const $uni = ((($0) => {
    return ($core$Dict$for)($0, $taAttrs, (($k, $$full, $u) => {
      const $full = $$full.second;
      return ($sd0$Compiler$TypeCheck$inferUni)($full.uni, $u);
    }));
  }))($sd0$Types$Ast$Uni);
  return ([
    ((($maybeExt)[0] === "Nothing")
      ? ({
        first: ($sd0$Types$TypedAst$Record)($pos, $core$Maybe$Nothing, $typedAttrs),
        second: ({
          raw: ($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, $attrTypes),
          uni: $uni,
        }),
      })
      : ((($maybeExt)[0] === "Just")
        ? ((() => {
          const $caExt = ($maybeExt)[1];
          const $$extType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $caExt, $state)), ($state = (__re__)[1]), (__re__)[0]);
          const $extType = $$extType.second;
          const $typedExt = $$extType.first;
          const $finalType = ((() => {
            const $$try1 = $extType.raw;
            return (((($$try1)[0] === "TypeRecord") && ((($$try1)[1])[0] === "Nothing"))
              ? ((() => {
                const $fixedTypes = ($$try1)[2];
                ($core$Dict$each)($attrTypes, (($name, $valueType) => {
                  const $$try2 = ($core$Dict$get)($name, $fixedTypes);
                  return ((($$try2)[0] === "Nothing")
                    ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute)($name), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : ((($$try2)[0] === "Just")
                      ? ((() => {
                        const $ty = ($$try2)[1];
                        return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_Record, $ty, $valueType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1032:28', (sp_toHuman)($$try2))));
                }));
                return $extType.raw;
              }))()
              : (((($$try1)[0] === "TypeRecord") && ((($$try1)[1])[0] === "Just"))
                ? ((() => {
                  const $tyvarId = (($$try1)[1])[1];
                  const $extensionAttrTypes = ($$try1)[2];
                  const $$both = ($core$Dict$onlyBothOnly)($attrTypes, $extensionAttrTypes);
                  const $extensionOnly = $$both.third;
                  const $both = $$both.second;
                  const $expressionOnly = $$both.first;
                  ($core$Dict$each)($both, (($name, $$extAttr) => {
                    const $inAttr = $$extAttr.first;
                    const $extAttr = $$extAttr.second;
                    return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_Record, $inAttr, $extAttr, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }));
                  const $newExtId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                  return ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($newExtId), ($core$Dict$join)($attrTypes, $extensionOnly));
                }))()
                : ((($$try1)[0] === "TypeVar")
                  ? ((() => {
                    const $id = ($$try1)[1];
                    const $ty = ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0])), $attrTypes);
                    ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_RecordExt, $extType.raw, $ty, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $ty;
                  }))()
                  : (true
                    ? ((() => {
                      ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorNotCompatibleWithRecord, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return $sd0$Types$TypedAst$TypeError;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1029:16', (sp_toHuman)($$try1))))));
          }))();
          return ({
            first: ($sd0$Types$TypedAst$Record)($pos, ($core$Maybe$Just)($typedExt), $typedAttrs),
            second: ({
              raw: $finalType,
              uni: ($sd0$Compiler$TypeCheck$inferUni)($uni, $extType.uni),
            }),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1019:4', (sp_toHuman)($maybeExt)))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferRecordAccess = (($env, $pos, $attrName, $inferredType, $state) => {
  return ([
    (((($inferredType)[0] === "TypeRecord") && ((($inferredType)[1])[0] === "Nothing"))
      ? ((() => {
        const $attrTypes = ($inferredType)[2];
        const $$try2 = ($core$Dict$get)($attrName, $attrTypes);
        return ((($$try2)[0] === "Just")
          ? ((() => {
            const $type = ($$try2)[1];
            return $type;
          }))()
          : ((($$try2)[0] === "Nothing")
            ? ((() => {
              ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute)($attrName), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return $sd0$Types$TypedAst$TypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 956:12', (sp_toHuman)($$try2))));
      }))()
      : (((($inferredType)[0] === "TypeRecord") && ((($inferredType)[1])[0] === "Just"))
        ? ((() => {
          const $tyvarId = (($inferredType)[1])[1];
          const $extensionAttrTypes = ($inferredType)[2];
          const $$try1 = ($core$Dict$get)($attrName, $extensionAttrTypes);
          return ((($$try1)[0] === "Just")
            ? ((() => {
              const $type = ($$try1)[1];
              return $type;
            }))()
            : ((($$try1)[0] === "Nothing")
              ? ((() => {
                const $newExtId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $newAttrType = ((__re__ = ($sd0$Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]);
                const $type = ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($newExtId), ($core$Dict$insert)($attrName, $newAttrType, $extensionAttrTypes));
                ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_RecordAccess, ($sd0$Types$TypedAst$TypeVar)($tyvarId), $type, $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $newAttrType;
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 965:12', (sp_toHuman)($$try1))));
        }))()
        : ((($inferredType)[0] === "TypeVar")
          ? ((() => {
            const $id = ($inferredType)[1];
            const $newExtId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $newAttrType = ($sd0$Types$TypedAst$TypeVar)(((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]));
            const $type = ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($newExtId), ($core$Dict$ofOne)($attrName, $newAttrType));
            ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_RecordAccess, $inferredType, $type, $state)), ($state = (__re__)[1]), (__re__)[0]);
            return $newAttrType;
          }))()
          : (true
            ? ((() => {
              ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord)($attrName, $inferredType), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return $sd0$Types$TypedAst$TypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 954:4', (sp_toHuman)($inferredType)))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferExpression = (($env, $caExpression, $state) => {
  return ([
    ((($caExpression)[0] === "LiteralNumber")
      ? ((() => {
        const $pos = ($caExpression)[1];
        const $n = ($caExpression)[2];
        return ({
          first: ($sd0$Types$TypedAst$LiteralNumber)($pos, $n),
          second: ({
            raw: $sd0$Compiler$TypeCheck$coreTypeNumber,
            uni: $sd0$Types$Ast$Uni,
          }),
        });
      }))()
      : ((($caExpression)[0] === "LiteralText")
        ? ((() => {
          const $pos = ($caExpression)[1];
          const $text = ($caExpression)[2];
          return ({
            first: ($sd0$Types$TypedAst$LiteralText)($pos, $text),
            second: ({
              raw: $sd0$Compiler$TypeCheck$coreTypeText,
              uni: $sd0$Types$Ast$Uni,
            }),
          });
        }))()
        : ((($caExpression)[0] === "Variable")
          ? ((() => {
            const $pos = ($caExpression)[1];
            const $ref = ($caExpression)[2];
            const $ty = ((() => {
              const $$try2 = ($sd0$Compiler$TypeCheck$getVariableByRef)($ref, $env);
              return ((($$try2)[0] === "Nothing")
                ? ((() => {
                  ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return $sd0$Compiler$TypeCheck$fullTypeError;
                }))()
                : ((($$try2)[0] === "Just")
                  ? ((() => {
                    const $var = ($$try2)[1];
                    const $t = ((__re__ = ($sd0$Compiler$TypeCheck$generalize)($env, $pos, $ref, $var, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $t;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 726:16', (sp_toHuman)($$try2))));
            }))();
            return ({
              first: ($sd0$Types$TypedAst$Variable)($pos, $ref),
              second: $ty,
            });
          }))()
          : ((($caExpression)[0] === "Constructor")
            ? ((() => {
              const $pos = ($caExpression)[1];
              const $usr = ($caExpression)[2];
              const $ty = ((() => {
                const $$try1 = ($sd0$Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
                return ((($$try1)[0] === "Nothing")
                  ? ((() => {
                    ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return $sd0$Compiler$TypeCheck$fullTypeError;
                  }))()
                  : ((($$try1)[0] === "Just")
                    ? ((() => {
                      const $cons = ($$try1)[1];
                      return ((__re__ = ($sd0$Compiler$TypeCheck$generalize)($env, $pos, ($sd0$Types$Ast$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 742:16', (sp_toHuman)($$try1))));
              }))();
              return ({
                first: ($sd0$Types$TypedAst$Constructor)($pos, $usr),
                second: ((() => {
                  const $0 = $ty;
                  return (Object.assign)({}, $0, ({
                    uni: $sd0$Types$Ast$Uni,
                  }));
                }))(),
              });
            }))()
            : ((($caExpression)[0] === "Fn")
              ? ((() => {
                const $pos = ($caExpression)[1];
                const $caPars = ($caExpression)[2];
                const $body = ($caExpression)[3];
                return ((__re__ = ($sd0$Compiler$TypeCheck$inferFn)($env, $pos, $caPars, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : ((($caExpression)[0] === "Call")
                ? ((() => {
                  const $pos = ($caExpression)[1];
                  const $reference = ($caExpression)[2];
                  const $args = ($caExpression)[3];
                  return ((__re__ = ($sd0$Compiler$TypeCheck$doCall)($env, $pos, $core$Maybe$Nothing, $reference, $args, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : ((($caExpression)[0] === "Record")
                  ? ((() => {
                    const $pos = ($caExpression)[1];
                    const $maybeExt = ($caExpression)[2];
                    const $attrs = ($caExpression)[3];
                    return ((__re__ = ($sd0$Compiler$TypeCheck$inferRecord)($env, $pos, $maybeExt, $attrs, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($caExpression)[0] === "RecordAccess")
                    ? ((() => {
                      const $pos = ($caExpression)[1];
                      const $attrName = ($caExpression)[2];
                      const $recordExpression = ($caExpression)[3];
                      const $$inferredType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $recordExpression, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      const $inferredType = $$inferredType.second;
                      const $typedExpr = $$inferredType.first;
                      return ({
                        first: ($sd0$Types$TypedAst$RecordAccess)($pos, $attrName, $typedExpr),
                        second: ((() => {
                          const $0 = $inferredType;
                          return (Object.assign)({}, $0, ({
                            raw: ((__re__ = ($sd0$Compiler$TypeCheck$inferRecordAccess)($env, $pos, $attrName, $0.raw, $state)), ($state = (__re__)[1]), (__re__)[0]),
                          }));
                        }))(),
                      });
                    }))()
                    : ((($caExpression)[0] === "LetIn")
                      ? ((() => {
                        const $def = ($caExpression)[1];
                        const $rest = ($caExpression)[2];
                        const $$defEnv = ((__re__ = ($sd0$Compiler$TypeCheck$doDefinition)($sd0$Types$Ast$RefLocal, $env, $def, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $defEnv = $$defEnv.second;
                        const $typedDef = $$defEnv.first;
                        const $$restType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($defEnv, $rest, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $restType = $$restType.second;
                        const $typedRest = $$restType.first;
                        return ({
                          first: ($sd0$Types$TypedAst$LetIn)($typedDef, $typedRest, $restType),
                          second: $restType,
                        });
                      }))()
                      : ((($caExpression)[0] === "If")
                        ? ((() => {
                          const $pos = ($caExpression)[1];
                          const $condition = ($caExpression)[2].condition;
                          const $false = ($caExpression)[2].false;
                          const $true = ($caExpression)[2].true;
                          const $$conditionType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: $sd0$Compiler$TypeCheck$Context_IfCondition,
                            }));
                          }))(), $condition, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $conditionType = $$conditionType.second;
                          const $typedCondition = $$conditionType.first;
                          ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_IfCondition, $sd0$Compiler$TypeCheck$coreTypeBool, $conditionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $$trueType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: $sd0$Compiler$TypeCheck$Context_IfTrue,
                            }));
                          }))(), $true, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $trueType = $$trueType.second;
                          const $typedTrue = $$trueType.first;
                          const $$falseType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)(((() => {
                            const $0 = $env;
                            return (Object.assign)({}, $0, ({
                              context: $sd0$Compiler$TypeCheck$Context_IfFalse,
                            }));
                          }))(), $false, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $falseType = $$falseType.second;
                          const $typedFalse = $$falseType.first;
                          ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_IfBranches, $trueType.raw, $falseType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $expression = ($sd0$Types$TypedAst$If)($pos, ({
                            condition: $typedCondition,
                            false: $typedFalse,
                            true: $typedTrue,
                          }));
                          const $uni = ($sd0$Compiler$TypeCheck$inferUni)($trueType.uni, $falseType.uni);
                          return ({
                            first: $expression,
                            second: ({
                              raw: $trueType.raw,
                              uni: $uni,
                            }),
                          });
                        }))()
                        : ((($caExpression)[0] === "Try")
                          ? ((() => {
                            const $pos = ($caExpression)[1];
                            const $patternsAndExpressions = ($caExpression)[2].patternsAndExpressions;
                            const $value = ($caExpression)[2].value;
                            return ((__re__ = ($sd0$Compiler$TypeCheck$doTry)($env, $pos, ((__re__ = ($sd0$Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]), $value, $patternsAndExpressions, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : ((($caExpression)[0] === "DestroyIn")
                            ? ((() => {
                              const $name = ($caExpression)[1];
                              const $expression = ($caExpression)[2];
                              const $$expressionType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $expression, $state)), ($state = (__re__)[1]), (__re__)[0]);
                              const $expressionType = $$expressionType.second;
                              const $typedExpression = $$expressionType.first;
                              return ({
                                first: ($sd0$Types$TypedAst$DestroyIn)($name, $typedExpression),
                                second: $expressionType,
                              });
                            }))()
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 713:4', (sp_toHuman)($caExpression)))))))))))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$inferArgument = (($env, $arg, $state) => {
  return ([
    ((($arg)[0] === "ArgumentExpression")
      ? ((() => {
        const $exp = ($arg)[1];
        const $$expType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
        const $expType = $$expType.second;
        const $typedExp = $$expType.first;
        return ($sd0$Types$TypedAst$ArgumentExpression)($expType, $typedExp);
      }))()
      : ((($arg)[0] === "ArgumentRecycle")
        ? ((() => {
          const $pos = ($arg)[1];
          const $name = ($arg)[2];
          const $attrPath = ($arg)[3];
          const $ref = ($sd0$Types$Ast$RefLocal)($name);
          const $raw = ((() => {
            const $$try1 = ($sd0$Compiler$TypeCheck$getVariableByRef)($ref, $env);
            return ((($$try1)[0] === "Nothing")
              ? ((() => {
                ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0]);
                return $sd0$Types$TypedAst$TypeError;
              }))()
              : ((($$try1)[0] === "Just")
                ? ((() => {
                  const $var = ($$try1)[1];
                  return ((($0) => {
                    return ($core$List$for)($0, $attrPath, (($attrName, $tyAcc) => {
                      return ((__re__ = ($sd0$Compiler$TypeCheck$inferRecordAccess)($env, $pos, $attrName, $tyAcc, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }));
                  }))($var.type.raw);
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1437:16', (sp_toHuman)($$try1))));
          }))();
          return ($sd0$Types$TypedAst$ArgumentRecycle)($pos, $raw, $attrPath, $name);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1425:4', (sp_toHuman)($arg)))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$doCall = (($env, $pos, $maybeExpectedType, $reference, $givenArgs, $state) => {
  const $$inferredReferenceType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $reference, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $inferredReferenceType = $$inferredReferenceType.second;
  const $typedReference = $$inferredReferenceType.first;
  const $typedArguments = ((($1) => {
    return ($core$List$map)((($arg) => {
      return ((__re__ = ($sd0$Compiler$TypeCheck$inferArgument)($env, $arg, $state)), ($state = (__re__)[1]), (__re__)[0]);
    }), $1);
  }))($givenArgs);
  const $toTypeArg = (($arg) => {
    return ((($arg)[0] === "ArgumentExpression")
      ? ((() => {
        const $full = ($arg)[1];
        return ($sd0$Types$TypedAst$ParSp)($full);
      }))()
      : ((($arg)[0] === "ArgumentRecycle")
        ? ((() => {
          const $raw = ($arg)[2];
          return ($sd0$Types$TypedAst$ParRe)($raw);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1358:8', (sp_toHuman)($arg))));
  });
  const $expectedReturnType = ((() => {
    const $$try1 = $inferredReferenceType.raw;
    return ((($$try1)[0] === "TypeFn")
      ? ((() => {
        const $parTypes = ($$try1)[1];
        const $outType = ($$try1)[2];
        const $given = ($core$List$length)($typedArguments);
        const $expected = ($core$List$length)($parTypes);
        return ((sp_not_equal)($expected, $given)
          ? ((() => {
            ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorWrongNumberOfArguments)(({
              expected: $expected,
              given: $given,
              reference: $reference,
            })), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return $sd0$Compiler$TypeCheck$fullTypeError;
          }))()
          : ((() => {
            ($sd0$Compiler$TypeCheck$list_eachWithIndex2)(0, $typedArguments, $parTypes, (($index, $givenArg, $parType) => {
              const $$try2 = ({
                first: $givenArg,
                second: $parType,
              });
              return (((($$try2.first)[0] === "ArgumentRecycle") && (($$try2.second)[0] === "ParRe"))
                ? ((() => {
                  const $p = ($$try2.first)[1];
                  const $givenRaw = ($$try2.first)[2];
                  const $attrPath = ($$try2.first)[3];
                  const $name = ($$try2.first)[4];
                  const $inferredRaw = ($$try2.second)[1];
                  const $$try3 = ($sd0$Compiler$TypeCheck$getVariableByRef)(($sd0$Types$Ast$RefLocal)($name), $env);
                  return ((($$try3)[0] === "Nothing")
                    ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $p, ($sd0$Compiler$TypeCheck$ErrorVariableNotFound)(($sd0$Types$Ast$RefLocal)($name)), $state)), ($state = (__re__)[1]), (__re__)[0])
                    : ((($$try3)[0] === "Just")
                      ? ((() => {
                        const $instance = ($$try3)[1];
                        ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($instance.type.uni, $sd0$Types$Ast$Uni), $env, $p, $sd0$Compiler$TypeCheck$ErrorShouldBeUnique, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, ($sd0$Compiler$TypeCheck$Why_Argument)($index), $givenRaw, $inferredRaw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1375:32', (sp_toHuman)($$try3))));
                }))()
                : (((($$try2.first)[0] === "ArgumentExpression") && (($$try2.second)[0] === "ParSp"))
                  ? ((() => {
                    const $givenFull = ($$try2.first)[1];
                    const $expr = ($$try2.first)[2];
                    const $inferredFull = ($$try2.second)[1];
                    ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($env, $pos, ({
                      fix: $inferredFull.uni,
                      mut: $givenFull.uni,
                    }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, ($sd0$Compiler$TypeCheck$Why_Argument)($index), $inferredFull.raw, $givenFull.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (true
                    ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchArgument, $state)), ($state = (__re__)[1]), (__re__)[0])
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1373:24', (sp_toHuman)($$try2)))));
            }));
            return ((($maybeExpectedType)[0] === "Nothing")
              ? $outType
              : ((($maybeExpectedType)[0] === "Just")
                ? ((() => {
                  const $e = ($maybeExpectedType)[1];
                  ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($env, $pos, ({
                    fix: $e.uni,
                    mut: $outType.uni,
                  }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                  ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_Annotation, $outType.raw, $e.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return $e;
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1391:20', (sp_toHuman)($maybeExpectedType))));
          }))());
      }))()
      : ((($$try1)[0] === "TypeVar")
        ? ((() => {
          const $id = ($$try1)[1];
          const $returnType = ((($maybeExpectedType)[0] === "Just")
            ? ((() => {
              const $e = ($maybeExpectedType)[1];
              return $e;
            }))()
            : ((($maybeExpectedType)[0] === "Nothing")
              ? ({
                raw: ((__re__ = ($sd0$Compiler$TypeCheck$newRawType)($state)), ($state = (__re__)[1]), (__re__)[0]),
                uni: $sd0$Types$Ast$Imm,
              })
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1400:20', (sp_toHuman)($maybeExpectedType))));
          const $refTy = ($sd0$Types$TypedAst$TypeFn)(($core$List$map)($toTypeArg, $typedArguments), $returnType);
          ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_CalledAsFunction, $refTy, $inferredReferenceType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
          return $returnType;
        }))()
        : ((($$try1)[0] === "TypeError")
          ? $sd0$Compiler$TypeCheck$fullTypeError
          : (true
            ? ((() => {
              const $z = $$try1;
              ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorCallingANonFunction)($z), $state)), ($state = (__re__)[1]), (__re__)[0]);
              return $sd0$Compiler$TypeCheck$fullTypeError;
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1363:8', (sp_toHuman)($$try1))))));
  }))();
  return ([
    ({
      first: ($sd0$Types$TypedAst$Call)($pos, $typedReference, $typedArguments),
      second: $expectedReturnType,
    }),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$checkExpression = (($env, $expectedType, $caExpression, $state) => {
  const $$try1 = ({
    first: $caExpression,
    second: $expectedType.raw,
  });
  return ([
    (((($$try1.first)[0] === "LiteralNumber") && ((($$try1.second)[0] === "TypeExact") && ((($$try1.second)[2])[0] === "Nil")))
      ? ((() => {
        const $pos = ($$try1.first)[1];
        const $n = ($$try1.first)[2];
        const $typeUsr = ($$try1.second)[1];
        ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, $sd0$Compiler$CoreTypes$numberDef.usr), $env, $pos, ($sd0$Compiler$TypeCheck$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
        return ($sd0$Types$TypedAst$LiteralNumber)($pos, $n);
      }))()
      : (((($$try1.first)[0] === "LiteralText") && ((($$try1.second)[0] === "TypeExact") && ((($$try1.second)[2])[0] === "Nil")))
        ? ((() => {
          const $pos = ($$try1.first)[1];
          const $text = ($$try1.first)[2];
          const $typeUsr = ($$try1.second)[1];
          ((__re__ = ($sd0$Compiler$TypeCheck$addErrorIf)((sp_not_equal)($typeUsr, $sd0$Compiler$CoreTypes$textDef.usr), $env, $pos, ($sd0$Compiler$TypeCheck$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
          return ($sd0$Types$TypedAst$LiteralText)($pos, $text);
        }))()
        : ((($$try1.first)[0] === "Variable")
          ? ((() => {
            const $pos = ($$try1.first)[1];
            const $ref = ($$try1.first)[2];
            const $__bleh__ = ((() => {
              const $$try4 = ($sd0$Compiler$TypeCheck$getVariableByRef)($ref, $env);
              return ((($$try4)[0] === "Nothing")
                ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorVariableNotFound)($ref), $state)), ($state = (__re__)[1]), (__re__)[0])
                : ((($$try4)[0] === "Just")
                  ? ((() => {
                    const $var = ($$try4)[1];
                    const $full = ((__re__ = ($sd0$Compiler$TypeCheck$generalize)($env, $pos, $ref, $var, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($env, $pos, ({
                      fix: $expectedType.uni,
                      mut: $full.uni,
                    }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_Annotation, $full.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1164:16', (sp_toHuman)($$try4))));
            }))();
            return ($sd0$Types$TypedAst$Variable)($pos, $ref);
          }))()
          : ((($$try1.first)[0] === "Constructor")
            ? ((() => {
              const $pos = ($$try1.first)[1];
              const $usr = ($$try1.first)[2];
              const $bleh = ((() => {
                const $$try3 = ($sd0$Compiler$TypeCheck$getConstructorByUsr)($usr, $env);
                return ((($$try3)[0] === "Nothing")
                  ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorConstructorNotFound)($usr), $state)), ($state = (__re__)[1]), (__re__)[0])
                  : ((($$try3)[0] === "Just")
                    ? ((() => {
                      const $cons = ($$try3)[1];
                      const $full = ((__re__ = ($sd0$Compiler$TypeCheck$generalize)($env, $pos, ($sd0$Types$Ast$RefGlobal)($usr), $cons, $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_Annotation, $full.raw, $expectedType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1178:16', (sp_toHuman)($$try3))));
              }))();
              return ($sd0$Types$TypedAst$Constructor)($pos, $usr);
            }))()
            : (((($$try1.first)[0] === "Fn") && (($$try1.second)[0] === "TypeFn"))
              ? ((() => {
                const $pos = ($$try1.first)[1];
                const $pars = ($$try1.first)[2];
                const $body = ($$try1.first)[3];
                const $parTypes = ($$try1.second)[1];
                const $out = ($$try1.second)[2];
                return ((sp_not_equal)(($core$List$length)($pars), ($core$List$length)($parTypes))
                  ? ((() => {
                    ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorWrongNumberOfParameters, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ($sd0$Types$TypedAst$Error)($pos);
                  }))()
                  : ((() => {
                    let $typedPars = (array_fromList)($core$Core$Nil);
                    let $parIndex = 0;
                    const $localEnv = ((($0) => {
                      return ($core$List$for)($0, ($core$List$map2)($core$Tuple$pair, $pars, $parTypes), (($$par, $envX) => {
                        const $par = $$par.first;
                        const $parType = $$par.second;
                        const $$envX1 = ((__re__ = ($sd0$Compiler$TypeCheck$checkParameter)(((() => {
                          const $0 = $envX;
                          return (Object.assign)({}, $0, ({
                            context: ($sd0$Compiler$TypeCheck$Context_FnPar)(((__re__ = (basics_cloneUni)($parIndex)), ($parIndex = (__re__)[1]), (__re__)[0]), $0.context),
                          }));
                        }))(), $parType, $par, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $envX1 = $$envX1.second;
                        const $typedPar = $$envX1.first;
                        ((__re__ = (array_push)($typedPars, $typedPar)), ($typedPars = (__re__)[1]), (__re__)[0]);
                        ($parIndex += 1);
                        const $0 = $envX1;
                        return (Object.assign)({}, $0, ({
                          context: $envX.context,
                        }));
                      }));
                    }))($env);
                    const $typedBody = ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)($localEnv, $out, $body, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    return ($sd0$Types$TypedAst$Fn)($pos, ((__re__ = (array_toList)($typedPars)), ($typedPars = (__re__)[1]), (__re__)[0]), $typedBody, $out);
                  }))());
              }))()
              : ((($$try1.first)[0] === "Call")
                ? ((() => {
                  const $pos = ($$try1.first)[1];
                  const $reference = ($$try1.first)[2];
                  const $args = ($$try1.first)[3];
                  return ($core$Tuple$first)(((__re__ = ($sd0$Compiler$TypeCheck$doCall)($env, $pos, ($core$Maybe$Just)($expectedType), $reference, $args, $state)), ($state = (__re__)[1]), (__re__)[0]));
                }))()
                : (((($$try1.first)[0] === "Record") && (((($$try1.first)[2])[0] === "Just") && ((($$try1.second)[0] === "TypeRecord") && ((($$try1.second)[1])[0] === "Nothing"))))
                  ? ((() => {
                    const $pos = ($$try1.first)[1];
                    const $ext = (($$try1.first)[2])[1];
                    const $valueByName = ($$try1.first)[3];
                    const $typeByName = ($$try1.second)[2];
                    const $typedExt = ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)($env, $expectedType, $ext, $state)), ($state = (__re__)[1]), (__re__)[0]);
                    const $zzz = (($attrName, $attrExpr) => {
                      const $$try2 = ($core$Dict$get)($attrName, $typeByName);
                      return ((($$try2)[0] === "Nothing")
                        ? ((() => {
                          ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          return ($core$Tuple$first)(((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $attrExpr, $state)), ($state = (__re__)[1]), (__re__)[0]));
                        }))()
                        : ((($$try2)[0] === "Just")
                          ? ((() => {
                            const $attrType = ($$try2)[1];
                            const $fullAttrType = ({
                              raw: $attrType,
                              uni: $expectedType.uni,
                            });
                            return ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: ($sd0$Compiler$TypeCheck$Context_AttributeName)($attrName, $0.context),
                              }));
                            }))(), $fullAttrType, $attrExpr, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1235:20', (sp_toHuman)($$try2))));
                    });
                    const $typedValueByName = ($core$Dict$map)($zzz, $valueByName);
                    return ($sd0$Types$TypedAst$Record)($pos, ($core$Maybe$Just)($typedExt), $typedValueByName);
                  }))()
                  : (((($$try1.first)[0] === "Record") && (((($$try1.first)[2])[0] === "Nothing") && ((($$try1.second)[0] === "TypeRecord") && ((($$try1.second)[1])[0] === "Nothing"))))
                    ? ((() => {
                      const $pos = ($$try1.first)[1];
                      const $valueByName = ($$try1.first)[3];
                      const $typeByName = ($$try1.second)[2];
                      const $$aOnly = ($core$Dict$onlyBothOnly)($valueByName, $typeByName);
                      const $bOnly = $$aOnly.third;
                      const $both = $$aOnly.second;
                      const $aOnly = $$aOnly.first;
                      ((sp_not_equal)($aOnly, $core$Dict$empty)
                        ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation, $state)), ($state = (__re__)[1]), (__re__)[0])
                        : ((sp_not_equal)($bOnly, $core$Dict$empty)
                          ? ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, $sd0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation, $state)), ($state = (__re__)[1]), (__re__)[0])
                          : null));
                      const $typedAttrs = ((($1) => {
                        return ($core$Dict$map)((($name, $$type) => {
                          const $value = $$type.first;
                          const $type = $$type.second;
                          return ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)($env, ({
                            raw: $type,
                            uni: $expectedType.uni,
                          }), $value, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        }), $1);
                      }))($both);
                      return ($sd0$Types$TypedAst$Record)($pos, $core$Maybe$Nothing, $typedAttrs);
                    }))()
                    : ((($$try1.first)[0] === "RecordAccess")
                      ? ((() => {
                        const $pos = ($$try1.first)[1];
                        const $attrName = ($$try1.first)[2];
                        const $exp = ($$try1.first)[3];
                        const $$expressionType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($env, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $expressionType = $$expressionType.second;
                        const $typedExpression = $$expressionType.first;
                        const $newId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
                        const $requiredType = ((($1) => {
                          return ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($newId), $1);
                        }))(((($1) => {
                          return ($core$Dict$ofOne)($attrName, $1);
                        }))($expectedType.raw));
                        ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_RecordAccess, $expressionType.raw, $requiredType, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($env, $pos, ({
                          fix: $expectedType.uni,
                          mut: $expressionType.uni,
                        }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                        return ($sd0$Types$TypedAst$RecordAccess)($pos, $attrName, $typedExpression);
                      }))()
                      : ((($$try1.first)[0] === "LetIn")
                        ? ((() => {
                          const $def = ($$try1.first)[1];
                          const $rest = ($$try1.first)[2];
                          const $$defEnv = ((__re__ = ($sd0$Compiler$TypeCheck$doDefinition)($sd0$Types$Ast$RefLocal, $env, $def, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          const $defEnv = $$defEnv.second;
                          const $typedDef = $$defEnv.first;
                          const $typedRest = ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)($defEnv, $expectedType, $rest, $state)), ($state = (__re__)[1]), (__re__)[0]);
                          return ($sd0$Types$TypedAst$LetIn)($typedDef, $typedRest, $expectedType);
                        }))()
                        : ((($$try1.first)[0] === "If")
                          ? ((() => {
                            const $pos = ($$try1.first)[1];
                            const $condition = ($$try1.first)[2].condition;
                            const $false = ($$try1.first)[2].false;
                            const $true = ($$try1.first)[2].true;
                            const $$conditionType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: $sd0$Compiler$TypeCheck$Context_IfCondition,
                              }));
                            }))(), $condition, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $conditionType = $$conditionType.second;
                            const $typedCondition = $$conditionType.first;
                            ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($env, $pos, $sd0$Compiler$TypeCheck$Why_IfCondition, $sd0$Compiler$TypeCheck$coreTypeBool, $conditionType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $typedTrue = ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: $sd0$Compiler$TypeCheck$Context_IfTrue,
                              }));
                            }))(), $expectedType, $true, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            const $typedFalse = ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)(((() => {
                              const $0 = $env;
                              return (Object.assign)({}, $0, ({
                                context: $sd0$Compiler$TypeCheck$Context_IfFalse,
                              }));
                            }))(), $expectedType, $false, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ($sd0$Types$TypedAst$If)($pos, ({
                              condition: $typedCondition,
                              false: $typedFalse,
                              true: $typedTrue,
                            }));
                          }))()
                          : ((($$try1.first)[0] === "Try")
                            ? ((() => {
                              const $pos = ($$try1.first)[1];
                              const $patternsAndExpressions = ($$try1.first)[2].patternsAndExpressions;
                              const $value = ($$try1.first)[2].value;
                              const $$fullType = ((__re__ = ($sd0$Compiler$TypeCheck$doTry)($env, $pos, $expectedType.raw, $value, $patternsAndExpressions, $state)), ($state = (__re__)[1]), (__re__)[0]);
                              const $fullType = $$fullType.second;
                              const $typedExp = $$fullType.first;
                              ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($env, $pos, ({
                                fix: $expectedType.uni,
                                mut: $fullType.uni,
                              }), $state)), ($state = (__re__)[1]), (__re__)[0]);
                              return $typedExp;
                            }))()
                            : ((($$try1.first)[0] === "DestroyIn")
                              ? ((() => {
                                const $name = ($$try1.first)[1];
                                const $exp = ($$try1.first)[2];
                                return ((($1) => {
                                  return ($sd0$Types$TypedAst$DestroyIn)($name, $1);
                                }))(((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)($env, $expectedType, $exp, $state)), ($state = (__re__)[1]), (__re__)[0]));
                              }))()
                              : ((($$try1.second)[0] === "TypeError")
                                ? ($sd0$Types$TypedAst$Error)(($sd0$Types$CanonicalAst$expressionPos)($caExpression))
                                : (true
                                  ? ((() => {
                                    const $pos = ($sd0$Types$CanonicalAst$expressionPos)($caExpression);
                                    ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $pos, ($sd0$Compiler$TypeCheck$ErrorIncompatibleTypes)($caExpression, $expectedType), $state)), ($state = (__re__)[1]), (__re__)[0]);
                                    return ($sd0$Types$TypedAst$Error)($pos);
                                  }))()
                                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 1145:4', (sp_toHuman)($$try1))))))))))))))))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$doDefinition = (($nameToRef, $env, $def, $state) => {
  const $$annotatedUnivarsByOriginalId = ((($0) => {
    return ($core$Dict$for)($0, $def.univars, (($originalId, _1, $$aus) => {
      const $fus = $$aus.first;
      const $aus = $$aus.second;
      const $$try3 = ($core$Dict$get)($originalId, $env.annotatedUnivarsByOriginalId);
      return ((($$try3)[0] === "Just")
        ? ({
          first: $fus,
          second: $aus,
        })
        : ((($$try3)[0] === "Nothing")
          ? ((() => {
            const $univarId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $univar = ({
              originalId: $originalId,
            });
            return ({
              first: ($core$Dict$insert)($univarId, $univar, $fus),
              second: ($core$Dict$insert)($originalId, $univarId, $aus),
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 602:12', (sp_toHuman)($$try3))));
    }));
  }))(({
    first: $core$Dict$empty,
    second: $env.annotatedUnivarsByOriginalId,
  }));
  const $annotatedUnivarsByOriginalId = $$annotatedUnivarsByOriginalId.second;
  const $freeUnivars = $$annotatedUnivarsByOriginalId.first;
  const $$annotatedTyvarsByName = ((($0) => {
    return ($core$Dict$for)($0, $def.tyvars, (($tyvarName, $caTyvar, $$atByName) => {
      const $ftById = $$atByName.first;
      const $atByName = $$atByName.second;
      const $$try2 = ($core$Dict$get)($tyvarName, $env.annotatedTyvarsByName);
      return ((($$try2)[0] === "Just")
        ? ({
          first: $ftById,
          second: $atByName,
        })
        : ((($$try2)[0] === "Nothing")
          ? ((() => {
            const $tyvarId = ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]);
            const $tyvar = ({
              allowFunctions: $caTyvar.allowFunctions,
              generalizedAt: $sd0$Types$Pos$G,
              generalizedFor: ($sd0$Types$Ast$RefLocal)(""),
              originalName: $tyvarName,
            });
            return ({
              first: ($core$Dict$insert)($tyvarId, $tyvar, $ftById),
              second: ($core$Dict$insert)($tyvarName, $tyvarId, $atByName),
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 618:12', (sp_toHuman)($$try2))));
    }));
  }))(({
    first: $core$Dict$empty,
    second: $env.annotatedTyvarsByName,
  }));
  const $annotatedTyvarsByName = $$annotatedTyvarsByName.second;
  const $freeTyvars = $$annotatedTyvarsByName.first;
  const $uni = $def.uni;
  const $patternOut = ((__re__ = ($sd0$Compiler$TypeCheck$inferPattern)(((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      annotatedTyvarsByName: $annotatedTyvarsByName,
      annotatedUnivarsByOriginalId: $annotatedUnivarsByOriginalId,
    }));
  }))(), $uni, $def.pattern, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $envWithContext = ((() => {
    const $0 = $patternOut.env;
    return (Object.assign)({}, $0, ({
      context: ($sd0$Compiler$TypeCheck$Context_LetInBody)(($core$Dict$keys)(($sd0$Types$TypedAst$patternNames)($patternOut.typedPattern))),
    }));
  }))();
  const $$bodyType = ($def.native
    ? ({
      first: ($sd0$Types$TypedAst$LiteralText)($sd0$Types$Pos$N, "native"),
      second: ({
        raw: $patternOut.patternType,
        uni: $uni,
      }),
    })
    : ((() => {
      const $$try1 = $patternOut.maybeFullAnnotation;
      return ((($$try1)[0] === "Just")
        ? ((() => {
          const $annotationType = ($$try1)[1];
          const $raw = ((__re__ = ($sd0$Compiler$TypeCheck$translateAnnotation)($envWithContext, $state, $annotationType)), ($state = (__re__)[1]), (__re__)[0]);
          const $full = ({
            raw: $raw,
            uni: $uni,
          });
          return ({
            first: ((__re__ = ($sd0$Compiler$TypeCheck$checkExpression)($envWithContext, $full, $def.body, $state)), ($state = (__re__)[1]), (__re__)[0]),
            second: $full,
          });
        }))()
        : ((($$try1)[0] === "Nothing")
          ? ((() => {
            const $$inferredType = ((__re__ = ($sd0$Compiler$TypeCheck$inferExpression)($envWithContext, $def.body, $state)), ($state = (__re__)[1]), (__re__)[0]);
            const $inferredType = $$inferredType.second;
            const $typed = $$inferredType.first;
            const $pos = ($sd0$Types$CanonicalAst$patternPos)($def.pattern);
            ((__re__ = ($sd0$Compiler$TypeCheck$addEquality)($envWithContext, $pos, $sd0$Compiler$TypeCheck$Why_LetIn, $patternOut.patternType, $inferredType.raw, $state)), ($state = (__re__)[1]), (__re__)[0]);
            ((__re__ = ($sd0$Compiler$TypeCheck$checkUni)($envWithContext, $pos, ({
              fix: $uni,
              mut: $inferredType.uni,
            }), $state)), ($state = (__re__)[1]), (__re__)[0]);
            return ({
              first: $typed,
              second: $inferredType,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 656:12', (sp_toHuman)($$try1))));
    }))());
  const $bodyType = $$bodyType.second;
  const $typedBody = $$bodyType.first;
  const $instance = (($name, $$pos) => {
    const $pos = $$pos.pos;
    const $type = $$pos.type;
    return ({
      definedAt: $pos,
      freeTyvars: $freeTyvars,
      freeUnivars: $freeUnivars,
      type: $type,
    });
  });
  const $type = ((() => {
    const $0 = $bodyType;
    return (Object.assign)({}, $0, ({
      uni: $def.uni,
    }));
  }))();
  return ([
    ({
      first: ({
        body: $typedBody,
        directValueDeps: $def.directValueDeps,
        freeTyvars: $freeTyvars,
        freeUnivars: $freeUnivars,
        isFullyAnnotated: (sp_not_equal)($patternOut.maybeFullAnnotation, $core$Maybe$Nothing),
        native: $def.native,
        pattern: $patternOut.typedPattern,
        type: $type,
      }),
      second: ((() => {
        const $0 = $patternOut.env;
        return (Object.assign)({}, $0, ({
          annotatedTyvarsByName: $env.annotatedTyvarsByName,
          annotatedUnivarsByOriginalId: $env.annotatedUnivarsByOriginalId,
          variables: ((($0) => {
            return ($core$Dict$for)($0, ($sd0$Types$TypedAst$patternNames)($patternOut.typedPattern), (($name, $stuff, $vars) => {
              return ($core$Dict$insert)(($nameToRef)($name), ($instance)($name, $stuff), $vars);
            }));
          }))($0.variables),
        }));
      }))(),
    }),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$initState = (($lastUnificationVarId) => {
  return ({
    equalities: (array_fromList)($core$Core$Nil),
    errors: (array_fromList)($core$Core$Nil),
    lastUnificationVarId: $lastUnificationVarId,
    tyvarsById: (hash_fromList)($core$Core$Nil),
    univarEqualities: (array_fromList)($core$Core$Nil),
    univarsById: (hash_fromList)($core$Core$Nil),
  });
});

const $sd0$Compiler$TypeCheck$makeInferenceAndCheckError = (($env, $$context) => {
  const $pos = $$context.first;
  const $context = $$context.second;
  const $error = $$context.third;
  return ($sd0$Compiler$Error$Simple)($pos, (($eenv) => {
    return ($core$Core$Cons)((sp_toHuman)($error), ($core$Core$Cons)((sp_toHuman)($context), $core$Core$Nil));
  }));
});

const $sd0$Human$Type$display = (($indent, $tree) => {
  return ((($tree)[0] === "Span")
    ? ((() => {
      const $content = ($tree)[2];
      return ($indent + $content);
    }))()
    : (((($tree)[0] === "Block") && ((($tree)[1])[0] === "NotIndented"))
      ? ((() => {
        const $content = ($tree)[2];
        return ((($1) => {
          return ($core$Text$join)("\n", $1);
        }))(((($1) => {
          return ($core$List$map)((($1) => {
            return ($sd0$Human$Type$display)($indent, $1);
          }), $1);
        }))($content));
      }))()
      : (((($tree)[0] === "Block") && ((($tree)[1])[0] === "IndentedWithHeader"))
        ? ((() => {
          const $header = (($tree)[1])[1];
          const $content = ($tree)[2];
          const $head = ($indent + $header);
          const $tail = ((($1) => {
            return ($core$List$map)((($1) => {
              return ($sd0$Human$Type$display)(($indent + "    "), $1);
            }), $1);
          }))($content);
          return ((($1) => {
            return ($core$Text$join)("\n", $1);
          }))((sp_cons)($head, $tail));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 45:4', (sp_toHuman)($tree)))));
});

const $sd0$Human$Type$maybeSpan = (($complexityAcc, $textAcc, $content) => {
  return (($complexityAcc > 20)
    ? $core$Maybe$Nothing
    : ((($content)[0] === "Nil")
      ? ($core$Maybe$Just)(((($1) => {
        return ($sd0$Human$Type$Span)($complexityAcc, $1);
      }))(((($1) => {
        return ($core$Text$join)("", $1);
      }))(($core$List$reverse)($textAcc))))
      : (((($content)[0] === "Cons") && ((($content)[1])[0] === "Span"))
        ? ((() => {
          const $complexity = (($content)[1])[1];
          const $snippet = (($content)[1])[2];
          const $tail = ($content)[2];
          return ($sd0$Human$Type$maybeSpan)(($complexity + $complexityAcc), (sp_cons)($snippet, $textAcc), $tail);
        }))()
        : (true
          ? $core$Maybe$Nothing
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 72:6', (sp_toHuman)($content))))));
});

const $sd0$Human$Type$text = (($text) => {
  return ($sd0$Human$Type$Span)((text_length)($text), $text);
});

const $sd0$Human$Type$rowOrIndented = (($header, $content) => {
  const $$try1 = ($sd0$Human$Type$maybeSpan)(0, $core$Core$Nil, (sp_cons)(($sd0$Human$Type$text)(($header + " ")), $content));
  return ((($$try1)[0] === "Just")
    ? ((() => {
      const $span = ($$try1)[1];
      return $span;
    }))()
    : ((($$try1)[0] === "Nothing")
      ? ($sd0$Human$Type$Block)(($sd0$Human$Type$IndentedWithHeader)($header), $content)
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 116:4', (sp_toHuman)($$try1))));
});

const $sd0$Human$Type$uniToText = (($env, $uni) => {
  return ((($uni)[0] === "Imm")
    ? ""
    : ((($uni)[0] === "Uni")
      ? "!"
      : ((($uni)[0] === "Depends")
        ? ((() => {
          const $n = ($uni)[1];
          return ((text_fromNumber)($n) + "?");
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 196:4', (sp_toHuman)($uni)))));
});

const $sd0$Human$Type$doFullType = (($env, $$raw) => {
  const $raw = $$raw.raw;
  const $uni = $$raw.uni;
  return ($sd0$Human$Type$rowOrIndented)(($sd0$Human$Type$uniToText)($env, $uni), ($core$Core$Cons)(($sd0$Human$Type$doRawType)($env, $raw), $core$Core$Nil));
});

const $sd0$Human$Type$rowOrHead = $sd0$Human$Type$rowOrIndented;

const $sd0$Human$Type$doParType = (($env, $parType) => {
  return ((($parType)[0] === "ParSp")
    ? ((() => {
      const $full = ($parType)[1];
      return ($sd0$Human$Type$doFullType)($env, $full);
    }))()
    : ((($parType)[0] === "ParRe")
      ? ((() => {
        const $raw = ($parType)[1];
        return ($sd0$Human$Type$rowOrHead)("@", ($core$Core$Cons)(($sd0$Human$Type$doRawType)($env, $raw), $core$Core$Nil));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 285:4', (sp_toHuman)($parType))));
});

const $sd0$Human$Type$list_intersperse = (($separator, $items, $acc) => {
  return ((($items)[0] === "Nil")
    ? ($core$List$reverse)($acc)
    : (((($items)[0] === "Cons") && ((($items)[2])[0] === "Nil"))
      ? ((() => {
        const $last = ($items)[1];
        return ($core$List$reverse)((sp_cons)($last, $acc));
      }))()
      : ((($items)[0] === "Cons")
        ? ((() => {
          const $head = ($items)[1];
          const $tail = ($items)[2];
          return ($sd0$Human$Type$list_intersperse)($separator, $tail, (sp_cons)($separator, (sp_cons)($head, $acc)));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 8:4', (sp_toHuman)($items)))));
});

const $sd0$Human$Type$list = (($$close) => {
  const $close = $$close.close;
  const $items = $$close.items;
  const $open = $$close.open;
  const $separator = $$close.separator;
  const $zero = ((text_length)($open) + (text_length)($close));
  const $$try1 = ($sd0$Human$Type$maybeSpan)($zero, ($core$Core$Cons)(($open + " "), $core$Core$Nil), ($sd0$Human$Type$list_intersperse)(($sd0$Human$Type$text)($separator), $items, $core$Core$Nil));
  return (((($$try1)[0] === "Just") && ((($$try1)[1])[0] === "Span"))
    ? ((() => {
      const $com = (($$try1)[1])[1];
      const $t = (($$try1)[1])[2];
      return ($sd0$Human$Type$Span)($com, ($t + $close));
    }))()
    : (true
      ? ((($1) => {
        return ($sd0$Human$Type$Block)($sd0$Human$Type$NotIndented, $1);
      }))(($core$List$concat)(($core$Core$Cons)(($core$Core$Cons)(($sd0$Human$Type$text)($open), $core$Core$Nil), ($core$Core$Cons)(((($1) => {
        return ($core$List$map)((($c) => {
          return ($sd0$Human$Type$rowOrHead)($separator, ($core$Core$Cons)($c, $core$Core$Nil));
        }), $1);
      }))($items), ($core$Core$Cons)(($core$Core$Cons)(($sd0$Human$Type$text)((" " + $close)), $core$Core$Nil), $core$Core$Nil)))))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 157:4', (sp_toHuman)($$try1))));
});

const $sd0$Human$Type$separatedBy = (($separator, $content) => {
  const $$try1 = ($sd0$Human$Type$maybeSpan)(0, $core$Core$Nil, ($sd0$Human$Type$list_intersperse)(($sd0$Human$Type$text)($separator), $content, $core$Core$Nil));
  return ((($$try1)[0] === "Just")
    ? ((() => {
      const $span = ($$try1)[1];
      return $span;
    }))()
    : ((($$try1)[0] === "Nothing")
      ? ((($1) => {
        return ($sd0$Human$Type$Block)($sd0$Human$Type$NotIndented, $1);
      }))(((($1) => {
        return ($core$List$map)((($c) => {
          return ($sd0$Human$Type$rowOrIndented)($separator, ($core$Core$Cons)($c, $core$Core$Nil));
        }), $1);
      }))($content))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 141:4', (sp_toHuman)($$try1))));
});

const $sd0$Human$Type$tyvarIdToText = (($env, $id) => {
  return (text_fromNumber)($id);
});

const $sd0$Human$Type$usrToText = (($env, $usr) => {
  const $$name = $usr;
  const $name = ($$name)[2];
  const $umr = ($$name)[1];
  return $name;
});

const $sd0$Human$Type$doRawType = (($env, $raw) => {
  return ((($raw)[0] === "TypeExact")
    ? ((() => {
      const $usr = ($raw)[1];
      const $raws = ($raw)[2];
      return ($sd0$Human$Type$rowOrIndented)(($sd0$Human$Type$usrToText)($env, $usr), ($core$List$map)((($1) => {
        return ($sd0$Human$Type$doRawType)($env, $1);
      }), $raws));
    }))()
    : ((($raw)[0] === "TypeFn")
      ? ((() => {
        const $parTypes = ($raw)[1];
        const $full = ($raw)[2];
        return ((($1) => {
          return ($sd0$Human$Type$rowOrIndented)("fn", $1);
        }))(($core$Core$Cons)(($sd0$Human$Type$separatedBy)(",", ($core$List$map)((($1) => {
          return ($sd0$Human$Type$doParType)($env, $1);
        }), $parTypes)), ($core$Core$Cons)(($sd0$Human$Type$rowOrIndented)(":", ($core$Core$Cons)(($sd0$Human$Type$doFullType)($env, $full), $core$Core$Nil)), $core$Core$Nil)));
      }))()
      : ((($raw)[0] === "TypeVar")
        ? ((() => {
          const $tyvarId = ($raw)[1];
          return ($sd0$Human$Type$text)((text_fromNumber)($tyvarId));
        }))()
        : ((($raw)[0] === "TypeRecord")
          ? ((() => {
            const $maybeExtId = ($raw)[1];
            const $attrs = ($raw)[2];
            const $doAttr = (($$name) => {
              const $name = $$name.first;
              const $r = $$name.second;
              return ($sd0$Human$Type$rowOrHead)(($name + " as"), ($core$Core$Cons)(($sd0$Human$Type$doRawType)($env, $r), $core$Core$Nil));
            });
            const $open = ((($maybeExtId)[0] === "Just")
              ? ((() => {
                const $tyvarId = ($maybeExtId)[1];
                return ("{ " + (($sd0$Human$Type$tyvarIdToText)($env, $tyvarId) + " with"));
              }))()
              : ((($maybeExtId)[0] === "Nothing")
                ? "{"
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 258:16', (sp_toHuman)($maybeExtId))));
            return ($sd0$Human$Type$list)(({
              close: "}",
              items: ((($1) => {
                return ($core$List$map)($doAttr, $1);
              }))(($core$Dict$toList)($attrs)),
              open: $open,
              separator: ",",
            }));
          }))()
          : ((($raw)[0] === "TypeError")
            ? ($sd0$Human$Type$text)("???")
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Human/Type.sp 205:4', (sp_toHuman)($raw)))))));
});

const $sd0$Compiler$TypeCheck$typeToHuman = (($env, $raw) => {
  return ((($1) => {
    return ($sd0$Human$Type$display)("", $1);
  }))(((($1) => {
    return ($sd0$Human$Type$doRawType)({}, $1);
  }))($raw));
});

const $sd0$Compiler$TypeCheck$makeResolutionError = (($env, $caModule, $$context) => {
  const $context = ($$context.first)[1];
  const $pos = ($$context.first)[2];
  const $why = ($$context.first)[3];
  const $t1 = ($$context.first)[4];
  const $t2 = ($$context.first)[5];
  const $message = $$context.second;
  return ($sd0$Compiler$Error$Simple)($pos, (($eenv) => {
    return ($core$Core$Cons)($message, ($core$Core$Cons)((sp_toHuman)($context), ($core$Core$Cons)((sp_toHuman)($why), ($core$Core$Cons)(($sd0$Compiler$TypeCheck$typeToHuman)($env, $t1), ($core$Core$Cons)("", ($core$Core$Cons)(($sd0$Compiler$TypeCheck$typeToHuman)($env, $t2), $core$Core$Nil))))));
  }));
});

const $sd0$Compiler$TypeCheck$addErErrorIf = (($test, $equality, $message, $state) => {
  return ($test
    ? ((() => {
      const $0 = $state;
      return (Object.assign)({}, $0, ({
        errors: (sp_cons)(({
          first: $equality,
          second: $message,
        }), $0.errors),
      }));
    }))()
    : $state);
});

const $sd0$Compiler$TypeCheck$compareParTypes = (($currentEquality, $index, $p1, $p2, $state0) => {
  const $$context = $currentEquality;
  const $f2 = ($$context)[5];
  const $f1 = ($$context)[4];
  const $why = ($$context)[3];
  const $pos = ($$context)[2];
  const $context = ($$context)[1];
  const $$try1 = ({
    first: $p1,
    second: $p2,
  });
  return (((($$try1.first)[0] === "ParRe") && (($$try1.second)[0] === "ParRe"))
    ? ((() => {
      const $raw1 = ($$try1.first)[1];
      const $raw2 = ($$try1.second)[1];
      const $eq = ($sd0$Compiler$TypeCheck$Equality)($context, $pos, ($sd0$Compiler$TypeCheck$Why_FunctionInput)($index, $why), $raw1, $raw2);
      const $0 = $state0;
      return (Object.assign)({}, $0, ({
        equalities: (sp_cons)($eq, $0.equalities),
      }));
    }))()
    : (((($$try1.first)[0] === "ParSp") && (($$try1.second)[0] === "ParSp"))
      ? ((() => {
        const $full1 = ($$try1.first)[1];
        const $full2 = ($$try1.second)[1];
        const $eq = ($sd0$Compiler$TypeCheck$Equality)($context, $pos, ($sd0$Compiler$TypeCheck$Why_FunctionInput)($index, $why), $full1.raw, $full2.raw);
        const $state1 = ((() => {
          const $$try2 = ($sd0$Compiler$TypeCheck$uniCanBeCastTo)(({
            given: $full1.uni,
            required: $full2.uni,
          }));
          return ((($$try2)[0] === "CanBeCastYes")
            ? $state0
            : (((($$try2)[0] === "CanBeCastNo") && ((($$try2)[1])[0] === "Nil"))
              ? ((($2) => {
                return ($sd0$Compiler$TypeCheck$addErError)($currentEquality, ("Function call par " + ((text_fromNumber)($index) + " with wrong uniqueness")), $2);
              }))($state0)
              : (((($$try2)[0] === "CanBeCastNo") && ((($$try2)[1])[0] === "Cons"))
                ? ((() => {
                  const $id = (($$try2)[1])[1].first;
                  const $uni = (($$try2)[1])[1].second;
                  const $tail = (($$try2)[1])[2];
                  const $0 = $state0;
                  return (Object.assign)({}, $0, ({
                    univarEqualities: (sp_cons)(({
                      context: $context,
                      id: $id,
                      pos: $pos,
                      uni: $uni,
                      why: "fn arg",
                    }), $0.univarEqualities),
                  }));
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2302:16', (sp_toHuman)($$try2)))));
        }))();
        const $0 = $state1;
        return (Object.assign)({}, $0, ({
          equalities: (sp_cons)($eq, $0.equalities),
        }));
      }))()
      : (true
        ? ($sd0$Compiler$TypeCheck$addErError)(($sd0$Compiler$TypeCheck$Equality)($context, $pos, ($sd0$Compiler$TypeCheck$Why_FunctionInput)($index, $why), $f1, $f2), "recycling does not match", $state0)
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2290:4', (sp_toHuman)($$try1)))));
});

const $sd0$Compiler$TypeCheck$list_forWithIndex2 = (($c, $index, $aa, $bb, $f) => {
  const $$try1 = ({
    first: $aa,
    second: $bb,
  });
  return (((($$try1.first)[0] === "Cons") && (($$try1.second)[0] === "Cons"))
    ? ((() => {
      const $a = ($$try1.first)[1];
      const $at = ($$try1.first)[2];
      const $b = ($$try1.second)[1];
      const $bt = ($$try1.second)[2];
      return ($sd0$Compiler$TypeCheck$list_forWithIndex2)(($f)($index, $a, $b, $c), ($index + 1), $at, $bt, $f);
    }))()
    : (true
      ? $c
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 68:4', (sp_toHuman)($$try1))));
});

const $sd0$Types$TypedAst$toRaw = (($par) => {
  return ((($par)[0] === "ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return $raw;
    }))()
    : ((($par)[0] === "ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 311:4', (sp_toHuman)($par))));
});

const $sd0$Compiler$TypeCheck$occurs = (($tyvarId, $type) => {
  const $rec = (($1) => {
    return ($sd0$Compiler$TypeCheck$occurs)($tyvarId, $1);
  });
  return ((($type)[0] === "TypeFn")
    ? ((() => {
      const $ins = ($type)[1];
      const $out = ($type)[2];
      return (($core$List$any)((($t) => {
        return ($rec)(($sd0$Types$TypedAst$toRaw)($t));
      }), $ins) || ($rec)($out.raw));
    }))()
    : ((($type)[0] === "TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return (sp_equal)($id, $tyvarId);
      }))()
      : ((($type)[0] === "TypeExact")
        ? ((() => {
          const $usr = ($type)[1];
          const $args = ($type)[2];
          return ($core$List$any)($rec, $args);
        }))()
        : ((($type)[0] === "TypeRecord")
          ? ((() => {
            const $attrs = ($type)[2];
            return ($core$Dict$any)((($k, $v) => {
              return ($rec)($v);
            }), $attrs);
          }))()
          : ((($type)[0] === "TypeError")
            ? false
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2482:4', (sp_toHuman)($type)))))));
});

const $sd0$Compiler$TypeCheck$replaceUnificationVariable = (($equality, $tyvarId, $replacingType, $state) => {
  const $isSame = ((($replacingType)[0] === "TypeVar")
    ? ((() => {
      const $tyvarId2 = ($replacingType)[1];
      return (sp_equal)($tyvarId, $tyvarId2);
    }))()
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2448:8', (sp_toHuman)($replacingType))));
  return ($isSame
    ? $state
    : (($sd0$Compiler$TypeCheck$occurs)($tyvarId, $replacingType)
      ? ($sd0$Compiler$TypeCheck$addErError)($equality, "circular!?", $state)
      : ((() => {
        const $zzz = (($$context) => {
          const $context = ($$context)[1];
          const $pos = ($$context)[2];
          const $why = ($$context)[3];
          const $t1 = ($$context)[4];
          const $t2 = ($$context)[5];
          return ($sd0$Compiler$TypeCheck$Equality)($context, $pos, $why, ($sd0$Compiler$TypeCheck$applySubstitutionToType)($tyvarId, $replacingType, $t1), ($sd0$Compiler$TypeCheck$applySubstitutionToType)($tyvarId, $replacingType, $t2));
        });
        const $equalities = ($core$List$map)($zzz, $state.equalities);
        const $substitutions = ((($2) => {
          return ($core$Dict$insert)($tyvarId, $replacingType, $2);
        }))(((($1) => {
          return ($core$Dict$map)(((_0, $type) => {
            return ($sd0$Compiler$TypeCheck$applySubstitutionToType)($tyvarId, $replacingType, $type);
          }), $1);
        }))($state.substitutions));
        const $0 = $state;
        return (Object.assign)({}, $0, ({
          equalities: $equalities,
          substitutions: $substitutions,
        }));
      }))()));
});

const $sd0$Compiler$TypeCheck$solveRecordExt = (($equality, $swapEquality, $tyvar1, $attrs1, $attrs2, $state) => {
  const $$context = $equality;
  const $why = ($$context)[3];
  const $pos = ($$context)[2];
  const $context = ($$context)[1];
  const $newState = ((($0) => {
    return ($core$Dict$for)($0, $attrs1, (($name, $type1, $s) => {
      const $$try1 = ($core$Dict$get)($name, $attrs2);
      return ((($$try1)[0] === "Nothing")
        ? ((($2) => {
          return ($sd0$Compiler$TypeCheck$addErError)($equality, ("missing attribute " + $name), $2);
        }))($state)
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $type2 = ($$try1)[1];
            const $$a = ($swapEquality
              ? ({
                first: $type2,
                second: $type1,
              })
              : ({
                first: $type1,
                second: $type2,
              }));
            const $b = $$a.second;
            const $a = $$a.first;
            const $0 = $state;
            return (Object.assign)({}, $0, ({
              equalities: (sp_cons)(($sd0$Compiler$TypeCheck$Equality)(($sd0$Compiler$TypeCheck$Context_AttributeName)($name, $context), $pos, $why, $a, $b), $0.equalities),
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2434:12', (sp_toHuman)($$try1))));
    }));
  }))($state);
  return ($sd0$Compiler$TypeCheck$replaceUnificationVariable)($equality, $tyvar1, ($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, $attrs2), $newState);
});

const $sd0$Compiler$TypeCheck$solveOneEquality = (($head, $state) => {
  const $$context = $head;
  const $raw2 = ($$context)[5];
  const $raw1 = ($$context)[4];
  const $why = ($$context)[3];
  const $pos = ($$context)[2];
  const $context = ($$context)[1];
  const $$try1 = ({
    first: $raw1,
    second: $raw2,
  });
  return ((($$try1.first)[0] === "TypeVar")
    ? ((() => {
      const $tyvarId = ($$try1.first)[1];
      const $t2 = $$try1.second;
      return ((($3) => {
        return ($sd0$Compiler$TypeCheck$replaceUnificationVariable)($head, $tyvarId, $t2, $3);
      }))($state);
    }))()
    : ((($$try1.second)[0] === "TypeVar")
      ? ((() => {
        const $t1 = $$try1.first;
        const $tyvarId = ($$try1.second)[1];
        return ((($3) => {
          return ($sd0$Compiler$TypeCheck$replaceUnificationVariable)($head, $tyvarId, $t1, $3);
        }))($state);
      }))()
      : (((($$try1.first)[0] === "TypeExact") && (($$try1.second)[0] === "TypeExact"))
        ? ((() => {
          const $usr1 = ($$try1.first)[1];
          const $args1 = ($$try1.first)[2];
          const $usr2 = ($$try1.second)[1];
          const $args2 = ($$try1.second)[2];
          return ((sp_not_equal)($usr1, $usr2)
            ? ($sd0$Compiler$TypeCheck$addErError)($head, "types are incompatible2", $state)
            : ((() => {
              const $newEqualities = ($core$List$indexedMap2)((($index, $a, $b) => {
                return ($sd0$Compiler$TypeCheck$Equality)($context, $pos, ($sd0$Compiler$TypeCheck$Why_TypeArgument)($usr1, $index, $why), $a, $b);
              }), $args2, $args1);
              const $0 = $state;
              return (Object.assign)({}, $0, ({
                equalities: ($core$List$append)($0.equalities, $newEqualities),
              }));
            }))());
        }))()
        : (((($$try1.first)[0] === "TypeFn") && (($$try1.second)[0] === "TypeFn"))
          ? ((() => {
            const $pars1 = ($$try1.first)[1];
            const $out1 = ($$try1.first)[2];
            const $pars2 = ($$try1.second)[1];
            const $out2 = ($$try1.second)[2];
            return ((sp_not_equal)(($core$List$length)($pars1), ($core$List$length)($pars2))
              ? ((($2) => {
                return ($sd0$Compiler$TypeCheck$addErError)($head, "functions expect a different number of arguments", $2);
              }))($state)
              : ((() => {
                const $outEquality = ($sd0$Compiler$TypeCheck$Equality)($context, $pos, ($sd0$Compiler$TypeCheck$Why_FunctionOutput)($why), $out1.raw, $out2.raw);
                const $s1 = ((() => {
                  const $$try2 = ($sd0$Compiler$TypeCheck$uniCanBeCastTo)(({
                    given: $out2.uni,
                    required: $out1.uni,
                  }));
                  return ((($$try2)[0] === "CanBeCastYes")
                    ? $state
                    : (((($$try2)[0] === "CanBeCastNo") && ((($$try2)[1])[0] === "Nil"))
                      ? ((($2) => {
                        return ($sd0$Compiler$TypeCheck$addErError)($head, "the function return type have different uniqueness", $2);
                      }))($state)
                      : (((($$try2)[0] === "CanBeCastNo") && ((($$try2)[1])[0] === "Cons"))
                        ? ((() => {
                          const $id = (($$try2)[1])[1].first;
                          const $uni = (($$try2)[1])[1].second;
                          const $tail = (($$try2)[1])[2];
                          const $0 = $state;
                          return (Object.assign)({}, $0, ({
                            univarEqualities: (sp_cons)(({
                              context: $context,
                              id: $id,
                              pos: $pos,
                              uni: $uni,
                              why: "fn out",
                            }), $0.univarEqualities),
                          }));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2363:28', (sp_toHuman)($$try2)))));
                }))();
                return ((($0) => {
                  return ($sd0$Compiler$TypeCheck$list_forWithIndex2)($0, 0, $pars1, $pars2, (($1, $2, $3, $4) => {
                    return ($sd0$Compiler$TypeCheck$compareParTypes)($head, $1, $2, $3, $4);
                  }));
                }))(((() => {
                  const $0 = $s1;
                  return (Object.assign)({}, $0, ({
                    equalities: (sp_cons)($outEquality, $0.equalities),
                  }));
                }))());
              }))());
          }))()
          : (((($$try1.first)[0] === "TypeRecord") && (((($$try1.first)[1])[0] === "Nothing") && ((($$try1.second)[0] === "TypeRecord") && ((($$try1.second)[1])[0] === "Nothing"))))
            ? ((() => {
              const $attrs1 = ($$try1.first)[2];
              const $attrs2 = ($$try1.second)[2];
              const $$both = ($core$Dict$onlyBothOnly)($attrs1, $attrs2);
              const $only2 = $$both.third;
              const $both = $$both.second;
              const $only1 = $$both.first;
              const $equalities = ((($0) => {
                return ($core$Dict$for)($0, $both, (($attrName, $$attrType1, $eqs) => {
                  const $attrType1 = $$attrType1.first;
                  const $attrType2 = $$attrType1.second;
                  return (sp_cons)(($sd0$Compiler$TypeCheck$Equality)($context, $pos, ($sd0$Compiler$TypeCheck$Why_Attribute)($why), $attrType1, $attrType2), $eqs);
                }));
              }))($state.equalities);
              return ((($3) => {
                return ($sd0$Compiler$TypeCheck$addErErrorIf)(((sp_not_equal)($only1, $core$Dict$empty) || (sp_not_equal)($only2, $core$Dict$empty)), $head, "record attrs don't match", $3);
              }))(((() => {
                const $0 = $state;
                return (Object.assign)({}, $0, ({
                  equalities: $equalities,
                }));
              }))());
            }))()
            : (((($$try1.first)[0] === "TypeRecord") && (((($$try1.first)[1])[0] === "Just") && ((($$try1.second)[0] === "TypeRecord") && ((($$try1.second)[1])[0] === "Nothing"))))
              ? ((() => {
                const $tyvar1 = (($$try1.first)[1])[1];
                const $attrs1 = ($$try1.first)[2];
                const $attrs2 = ($$try1.second)[2];
                return ($sd0$Compiler$TypeCheck$solveRecordExt)($head, false, $tyvar1, $attrs1, $attrs2, $state);
              }))()
              : (((($$try1.first)[0] === "TypeRecord") && (((($$try1.first)[1])[0] === "Nothing") && ((($$try1.second)[0] === "TypeRecord") && ((($$try1.second)[1])[0] === "Just"))))
                ? ((() => {
                  const $attrs1 = ($$try1.first)[2];
                  const $tyvar2 = (($$try1.second)[1])[1];
                  const $attrs2 = ($$try1.second)[2];
                  return ($sd0$Compiler$TypeCheck$solveRecordExt)($head, true, $tyvar2, $attrs2, $attrs1, $state);
                }))()
                : (((($$try1.first)[0] === "TypeRecord") && (((($$try1.first)[1])[0] === "Just") && ((($$try1.second)[0] === "TypeRecord") && ((($$try1.second)[1])[0] === "Just"))))
                  ? ((() => {
                    const $tyvar1 = (($$try1.first)[1])[1];
                    const $attrs1 = ($$try1.first)[2];
                    const $tyvar2 = (($$try1.second)[1])[1];
                    const $attrs2 = ($$try1.second)[2];
                    const $$both = ($core$Dict$onlyBothOnly)($attrs1, $attrs2);
                    const $only2 = $$both.third;
                    const $both = $$both.second;
                    const $only1 = $$both.first;
                    const $newTyvarId = ($state.lastUnificationVarId + 1);
                    const $newType = ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)($newTyvarId), ($core$Dict$join)($attrs1, $only2));
                    return ((($0) => {
                      return ($core$Dict$for)($0, $both, (($name, $$t1, $s) => {
                        const $t1 = $$t1.first;
                        const $t2 = $$t1.second;
                        const $0 = $s;
                        return (Object.assign)({}, $0, ({
                          equalities: (sp_cons)(($sd0$Compiler$TypeCheck$Equality)(($sd0$Compiler$TypeCheck$Context_AttributeName)($name, $context), $pos, $why, $t1, $t1), $0.equalities),
                        }));
                      }));
                    }))(((($3) => {
                      return ($sd0$Compiler$TypeCheck$replaceUnificationVariable)($head, $tyvar2, $newType, $3);
                    }))(((($3) => {
                      return ($sd0$Compiler$TypeCheck$replaceUnificationVariable)($head, $tyvar1, $newType, $3);
                    }))(((() => {
                      const $0 = $state;
                      return (Object.assign)({}, $0, ({
                        lastUnificationVarId: $newTyvarId,
                      }));
                    }))())));
                  }))()
                  : ((($$try1.first)[0] === "TypeError")
                    ? $state
                    : ((($$try1.second)[0] === "TypeError")
                      ? $state
                      : (true
                        ? ((($2) => {
                          return ($sd0$Compiler$TypeCheck$addErError)($head, "types are incompatible1", $2);
                        }))($state)
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2332:14', (sp_toHuman)($$try1)))))))))))));
});

const $sd0$Compiler$TypeCheck$solveEqualities = (($oldState) => {
  const $$try1 = $oldState.equalities;
  return ((($$try1)[0] === "Nil")
    ? $oldState
    : ((($$try1)[0] === "Cons")
      ? ((() => {
        const $head = ($$try1)[1];
        const $tail = ($$try1)[2];
        return ($sd0$Compiler$TypeCheck$solveEqualities)(((($1) => {
          return ($sd0$Compiler$TypeCheck$solveOneEquality)($head, $1);
        }))(((() => {
          const $0 = $oldState;
          return (Object.assign)({}, $0, ({
            equalities: $tail,
          }));
        }))()));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2316:4', (sp_toHuman)($$try1))));
});

const $sd0$Compiler$TypeCheck$addSub = (($newId, $newUni, $subs) => {
  const $replace = (($id, $uni) => {
    return ((($uni)[0] === "Depends")
      ? ((() => {
        const $blah = ($uni)[1];
        return ((sp_equal)($blah, $newId)
          ? $newUni
          : $uni);
      }))()
      : (true
        ? $uni
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2210:8', (sp_toHuman)($uni))));
  });
  return ((($2) => {
    return ($core$Dict$insert)($newId, $newUni, $2);
  }))(((($1) => {
    return ($core$Dict$map)($replace, $1);
  }))($subs));
});

const $sd0$Compiler$TypeCheck$solveUniquenessConstraint = (($env, $eq, $state, $subs) => {
  const $$try1 = ($core$Dict$get)($eq.id, $subs);
  return ([
    ((($$try1)[0] === "Nothing")
      ? ($sd0$Compiler$TypeCheck$addSub)($eq.id, $eq.uni, $subs)
      : ((($$try1)[0] === "Just")
        ? ((() => {
          const $subUni = ($$try1)[1];
          return ((sp_equal)($subUni, $eq.uni)
            ? $subs
            : ((() => {
              const $$try2 = ({
                first: $subUni,
                second: $eq.uni,
              });
              return ((($$try2.first)[0] === "Depends")
                ? ((() => {
                  const $subId = ($$try2.first)[1];
                  return ($sd0$Compiler$TypeCheck$addSub)($subId, $eq.uni, $subs);
                }))()
                : ((($$try2.second)[0] === "Depends")
                  ? ((() => {
                    const $newId = ($$try2.second)[1];
                    return ($sd0$Compiler$TypeCheck$addSub)($newId, $subUni, $subs);
                  }))()
                  : (true
                    ? ((() => {
                      ((__re__ = ($sd0$Compiler$TypeCheck$addError)($env, $eq.pos, ($sd0$Compiler$TypeCheck$ErrorUnresolvableUniqueness)($eq, $subUni), $state)), ($state = (__re__)[1]), (__re__)[0]);
                      return $subs;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2231:16', (sp_toHuman)($$try2)))));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2222:4', (sp_toHuman)($$try1)))),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$solveUniquenessConstraints = (($env, $eqs, $state, $subs) => {
  return ([
    ((($eqs)[0] === "Nil")
      ? $subs
      : ((($eqs)[0] === "Cons")
        ? ((() => {
          const $head = ($eqs)[1];
          const $tail = ($eqs)[2];
          return ((($3) => {
            return ((__re__ = ($sd0$Compiler$TypeCheck$solveUniquenessConstraints)($env, $tail, $state, $3)), ($state = (__re__)[1]), (__re__)[0]);
          }))(((($3) => {
            return ((__re__ = ($sd0$Compiler$TypeCheck$solveUniquenessConstraint)($env, $head, $state, $3)), ($state = (__re__)[1]), (__re__)[0]);
          }))($subs));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2246:4', (sp_toHuman)($eqs)))),
    $state,
  ]);
});

const $sd0$Types$TypedAst$resolveArg = (($saf, $arg) => {
  return ((($arg)[0] === "ArgumentExpression")
    ? ((() => {
      const $full = ($arg)[1];
      const $expr = ($arg)[2];
      return ($sd0$Types$TypedAst$ArgumentExpression)(($sd0$Types$TypedAst$resolveFull)($saf, $full), ($sd0$Types$TypedAst$resolveExpression)($saf, $expr));
    }))()
    : ((($arg)[0] === "ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $attrPath = ($arg)[3];
        const $name = ($arg)[4];
        return ($sd0$Types$TypedAst$ArgumentRecycle)($p, ($sd0$Types$TypedAst$resolveRaw)($saf, $raw), $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 211:4', (sp_toHuman)($arg))));
});

const $sd0$Types$TypedAst$resolvePattern = (($saf, $pattern) => {
  return ((($pattern)[0] === "PatternLiteralNumber")
    ? ((() => {
      const $pos = ($pattern)[1];
      return $pattern;
    }))()
    : ((($pattern)[0] === "PatternLiteralText")
      ? ((() => {
        const $pos = ($pattern)[1];
        return $pattern;
      }))()
      : ((($pattern)[0] === "PatternAny")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $stuff = ($pattern)[2];
          return ($sd0$Types$TypedAst$PatternAny)($pos, ((() => {
            const $0 = $stuff;
            return (Object.assign)({}, $0, ({
              type: ($sd0$Types$TypedAst$resolveFull)($saf, $0.type),
            }));
          }))());
        }))()
        : ((($pattern)[0] === "PatternConstructor")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $usr = ($pattern)[2];
            const $ps = ($pattern)[3];
            return ($sd0$Types$TypedAst$PatternConstructor)($pos, $usr, ($core$List$map)((($1) => {
              return ($sd0$Types$TypedAst$resolvePattern)($saf, $1);
            }), $ps));
          }))()
          : ((($pattern)[0] === "PatternRecord")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $ps = ($pattern)[2];
              return ($sd0$Types$TypedAst$PatternRecord)($pos, ($core$Dict$map)((($k, $$p) => {
                const $p = $$p.first;
                const $t = $$p.second;
                return ({
                  first: ($sd0$Types$TypedAst$resolvePattern)($saf, $p),
                  second: ($sd0$Types$TypedAst$resolveRaw)($saf, $t),
                });
              }), $ps));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 276:4', (sp_toHuman)($pattern)))))));
});

const $sd0$Types$TypedAst$resolvePar = (($saf, $par) => {
  return ((($par)[0] === "ParameterPattern")
    ? ((() => {
      const $full = ($par)[1];
      const $pa = ($par)[2];
      return ($sd0$Types$TypedAst$ParameterPattern)(($sd0$Types$TypedAst$resolveFull)($saf, $full), ($sd0$Types$TypedAst$resolvePattern)($saf, $pa));
    }))()
    : ((($par)[0] === "ParameterRecycle")
      ? ((() => {
        const $p = ($par)[1];
        const $raw = ($par)[2];
        const $name = ($par)[3];
        return ($sd0$Types$TypedAst$ParameterRecycle)($p, ($sd0$Types$TypedAst$resolveRaw)($saf, $raw), $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 221:4', (sp_toHuman)($par))));
});

const $sd0$Types$TypedAst$resolveExpression = (($saf, $expression) => {
  const $rec = (($1) => {
    return ($sd0$Types$TypedAst$resolveExpression)($saf, $1);
  });
  return ((($expression)[0] === "LiteralNumber")
    ? $expression
    : ((($expression)[0] === "LiteralText")
      ? $expression
      : ((($expression)[0] === "Variable")
        ? $expression
        : ((($expression)[0] === "Constructor")
          ? $expression
          : ((($expression)[0] === "Fn")
            ? ((() => {
              const $p = ($expression)[1];
              const $pars = ($expression)[2];
              const $body = ($expression)[3];
              const $bodyType = ($expression)[4];
              return ($sd0$Types$TypedAst$Fn)($p, ($core$List$map)((($1) => {
                return ($sd0$Types$TypedAst$resolvePar)($saf, $1);
              }), $pars), ($rec)($body), ($sd0$Types$TypedAst$resolveFull)($saf, $bodyType));
            }))()
            : ((($expression)[0] === "Call")
              ? ((() => {
                const $p = ($expression)[1];
                const $ref = ($expression)[2];
                const $args = ($expression)[3];
                return ($sd0$Types$TypedAst$Call)($p, ($rec)($ref), ($core$List$map)((($1) => {
                  return ($sd0$Types$TypedAst$resolveArg)($saf, $1);
                }), $args));
              }))()
              : ((($expression)[0] === "Record")
                ? ((() => {
                  const $p = ($expression)[1];
                  const $maybeExt = ($expression)[2];
                  const $attrs = ($expression)[3];
                  return ($sd0$Types$TypedAst$Record)($p, ($core$Maybe$map)($rec, $maybeExt), ($core$Dict$map)((($k, $v) => {
                    return ($rec)($v);
                  }), $attrs));
                }))()
                : ((($expression)[0] === "RecordAccess")
                  ? ((() => {
                    const $p = ($expression)[1];
                    const $name = ($expression)[2];
                    const $exp = ($expression)[3];
                    return ($sd0$Types$TypedAst$RecordAccess)($p, $name, ($rec)($exp));
                  }))()
                  : ((($expression)[0] === "LetIn")
                    ? ((() => {
                      const $def = ($expression)[1];
                      const $rest = ($expression)[2];
                      const $restType = ($expression)[3];
                      return ($sd0$Types$TypedAst$LetIn)(($sd0$Types$TypedAst$resolveValueDef)($saf, $def), ($rec)($rest), ($sd0$Types$TypedAst$resolveFull)($saf, $restType));
                    }))()
                    : ((($expression)[0] === "If")
                      ? ((() => {
                        const $p = ($expression)[1];
                        const $condition = ($expression)[2].condition;
                        const $false = ($expression)[2].false;
                        const $true = ($expression)[2].true;
                        return ($sd0$Types$TypedAst$If)($p, ({
                          condition: ($rec)($condition),
                          false: ($rec)($false),
                          true: ($rec)($true),
                        }));
                      }))()
                      : ((($expression)[0] === "Try")
                        ? ((() => {
                          const $p = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          return ($sd0$Types$TypedAst$Try)($p, ({
                            patternsAndExpressions: ($core$List$map)((($2) => {
                              return ($core$Tuple$mapBoth)((($1) => {
                                return ($sd0$Types$TypedAst$resolvePattern)($saf, $1);
                              }), $rec, $2);
                            }), $patternsAndExpressions),
                            value: ($rec)($value),
                            valueType: ($sd0$Types$TypedAst$resolveFull)($saf, $valueType),
                          }));
                        }))()
                        : ((($expression)[0] === "DestroyIn")
                          ? ((() => {
                            const $n = ($expression)[1];
                            const $e = ($expression)[2];
                            return ($sd0$Types$TypedAst$DestroyIn)($n, ($rec)($e));
                          }))()
                          : ((($expression)[0] === "Error")
                            ? ((() => {
                              const $p = ($expression)[1];
                              return $expression;
                            }))()
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 234:4', (sp_toHuman)($expression)))))))))))))));
});

const $sd0$Types$TypedAst$resolveValueDef = (($saf, $def) => {
  const $0 = $def;
  return (Object.assign)({}, $0, ({
    body: ($sd0$Types$TypedAst$resolveExpression)($saf, $0.body),
    pattern: ($sd0$Types$TypedAst$resolvePattern)($saf, $0.pattern),
    type: ($sd0$Types$TypedAst$resolveFull)($saf, $0.type),
  }));
});

const $sd0$Compiler$TypeCheck$doRootDefinition = (($lastUnificationVarId, $errors, $module, $env, $def) => {
  let $state = ($sd0$Compiler$TypeCheck$initState)(((__re__ = (basics_cloneUni)($lastUnificationVarId)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  const $nameToRef = (($name) => {
    return ($sd0$Types$Ast$RefGlobal)(($sd0$Types$Meta$USR)($module.umr, $name));
  });
  (sp_benchStart)(null);
  const $$envF = ((__re__ = ($sd0$Compiler$TypeCheck$doDefinition)($nameToRef, $env, $def, $state)), ($state = (__re__)[1]), (__re__)[0]);
  const $envF = $$envF.second;
  const $typedDef = $$envF.first;
  (sp_benchStop)("type inference");
  (sp_benchStart)(null);
  const $erState0 = ({
    equalities: ((__re__ = (array_toList)($state.equalities)), ($state.equalities = (__re__)[1]), (__re__)[0]),
    errors: $core$Core$Nil,
    lastUnificationVarId: ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]),
    substitutions: $core$Dict$empty,
    univarEqualities: ((__re__ = (array_toList)($state.univarEqualities)), ($state.univarEqualities = (__re__)[1]), (__re__)[0]),
  });
  const $erStateF = ((($st) => {
    return ($core$List$for)($st, $st.equalities, (($eq, $s) => {
      return ($sd0$Compiler$TypeCheck$addErError)($eq, "unresolved", $s);
    }));
  }))(($sd0$Compiler$TypeCheck$solveEqualities)($erState0));
  (sp_benchStop)("equalities resolution");
  (sp_benchStart)(null);
  const $univarSubs = ((__re__ = ($sd0$Compiler$TypeCheck$solveUniquenessConstraints)($env, $erStateF.univarEqualities, $state, $core$Dict$empty)), ($state = (__re__)[1]), (__re__)[0]);
  (sp_benchStop)("uniqueness resolution");
  (sp_benchStart)(null);
  const $subsAsFns = ({
    ty: (($tyvarId) => {
      return ($core$Dict$get)($tyvarId, $erStateF.substitutions);
    }),
    uni: (($univarId) => {
      return ($core$Dict$get)($univarId, $univarSubs);
    }),
  });
  const $resolvedValueDef = ($sd0$Types$TypedAst$resolveValueDef)($subsAsFns, $typedDef);
  (sp_benchStop)("def resolution");
  ($lastUnificationVarId = ((__re__ = (basics_cloneUni)($state.lastUnificationVarId)), ($state.lastUnificationVarId = (__re__)[1]), (__re__)[0]));
  ((__re__ = (array_each)($state.errors, (($err) => {
    return ((__re__ = (array_push)($errors, ($sd0$Compiler$TypeCheck$makeInferenceAndCheckError)($env, $err))), ($errors = (__re__)[1]), (__re__)[0]);
  }))), ($state.errors = (__re__)[1]), (__re__)[0]);
  ($core$List$each)($erStateF.errors, (($err) => {
    return ((__re__ = (array_push)($errors, ($sd0$Compiler$TypeCheck$makeResolutionError)($env, $module, $err))), ($errors = (__re__)[1]), (__re__)[0]);
  }));
  return ([
    ({
      first: $resolvedValueDef,
      second: $envF,
    }),
    $lastUnificationVarId,
    $errors,
  ]);
});

const $sd0$Compiler$TypeCheck$insertAnnotatedAndNonAnnotated = (($pa, $def, $$ann) => {
  const $ann = $$ann.first;
  const $nonAnn = $$ann.second;
  const $isFullyAnnotated = ((($1) => {
    return ($core$List$all)((($stuff) => {
      return (sp_not_equal)($stuff.maybeAnnotation, $core$Maybe$Nothing);
    }), $1);
  }))(($core$Dict$values)(($sd0$Types$CanonicalAst$patternNames)($pa)));
  return ($isFullyAnnotated
    ? ({
      first: (sp_cons)($def, $ann),
      second: $nonAnn,
    })
    : ({
      first: $ann,
      second: (sp_cons)($def, $nonAnn),
    }));
});

const $sd0$Compiler$TypeCheck$doModule = (($lastUnificationVarId, $env, $caModule) => {
  const $$annotated = ($core$Dict$for)(({
    first: $core$Core$Nil,
    second: $core$Core$Nil,
  }), $caModule.valueDefs, $sd0$Compiler$TypeCheck$insertAnnotatedAndNonAnnotated);
  const $nonAnnotated = $$annotated.second;
  const $annotated = $$annotated.first;
  ((($core$List$length)($nonAnnotated) > 1)
    ? ($sd0$Compiler$TypeCheck$bug)("Right now the compiler supports only one root-level non-annotated value per module. =(")
    : null);
  const $allOrdered = ($core$List$concat)(($core$Core$Cons)($nonAnnotated, ($core$Core$Cons)($annotated, $core$Core$Nil)));
  let $errors = (array_fromList)($core$Core$Nil);
  const $$envF = ((($0) => {
    return ($core$List$for)($0, $allOrdered, (($def, $$accum) => {
      const $accum = $$accum.first;
      const $env0 = $$accum.second;
      const $$env1 = ((__re__ = ($sd0$Compiler$TypeCheck$doRootDefinition)($lastUnificationVarId, $errors, $caModule, $env0, $def)), ($lastUnificationVarId = (__re__)[1]), ($errors = (__re__)[2]), (__re__)[0]);
      const $env1 = $$env1.second;
      const $typedDef = $$env1.first;
      return ({
        first: ($core$Dict$insert)($def.pattern, $typedDef, $accum),
        second: $env1,
      });
    }));
  }))(({
    first: $core$Dict$empty,
    second: $env,
  }));
  const $envF = $$envF.second;
  const $valueDefs = $$envF.first;
  const $typedModule = ({
    asText: $caModule.asText,
    umr: $caModule.umr,
    valueDefs: $valueDefs,
  });
  const $errs = ((__re__ = (array_toList)($errors)), ($errors = (__re__)[1]), (__re__)[0]);
  return ([
    ((sp_equal)($errs, $core$Core$Nil)
      ? ($core$Result$Ok)($typedModule)
      : ($core$Result$Err)(($sd0$Compiler$Error$Nested)($errs))),
    $lastUnificationVarId,
  ]);
});

const $sd0$Compiler$CoreTypes$listDef = ((() => {
  const $usr = ($sd0$Compiler$CoreTypes$makeUsr)("List");
  const $item = ($sd0$Types$CanonicalAst$TypeAnnotationVariable)($sd0$Compiler$CoreTypes$p, "item");
  const $nilDef = ({
    ins: $core$Core$Nil,
    out: ($sd0$Compiler$CoreTypes$list)($item),
    pos: $sd0$Compiler$CoreTypes$p,
    typeUsr: $usr,
  });
  const $consDef = ({
    ins: ($core$Core$Cons)($item, ($core$Core$Cons)(($sd0$Compiler$CoreTypes$list)($item), $core$Core$Nil)),
    out: ($sd0$Compiler$CoreTypes$list)($item),
    pos: $sd0$Compiler$CoreTypes$p,
    typeUsr: $usr,
  });
  return ({
    constructors: ((($2) => {
      return ($core$Dict$insert)("Cons", $consDef, $2);
    }))(((($2) => {
      return ($core$Dict$insert)("Nil", $nilDef, $2);
    }))($core$Dict$empty)),
    directTypeDeps: $core$Set$empty,
    pars: ($core$Core$Cons)(($sd0$Types$Pos$At)($sd0$Types$Pos$G, "item"), $core$Core$Nil),
    usr: $usr,
  });
}))();

const $sd0$Compiler$CoreTypes$noneDef = ((() => {
  const $usr = ($sd0$Compiler$CoreTypes$makeUsr)($sd0$Compiler$CoreTypes$noneName);
  return ({
    constructors: ($core$Dict$ofOne)($sd0$Compiler$CoreTypes$noneName, ({
      ins: $core$Core$Nil,
      out: $sd0$Compiler$CoreTypes$none,
      pos: $sd0$Compiler$CoreTypes$p,
      typeUsr: $usr,
    })),
    directTypeDeps: $core$Set$empty,
    pars: $core$Core$Nil,
    usr: $usr,
  });
}))();

const $sd0$Compiler$CoreTypes$allDefs = ($core$Core$Cons)($sd0$Compiler$CoreTypes$noneDef, ($core$Core$Cons)($sd0$Compiler$CoreTypes$boolDef, ($core$Core$Cons)($sd0$Compiler$CoreTypes$listDef, ($core$Core$Cons)($sd0$Compiler$CoreTypes$textDef, ($core$Core$Cons)($sd0$Compiler$CoreTypes$numberDef, $core$Core$Nil)))));

const $sd0$Types$TypedAst$typeTyvars = (($type) => {
  return ((($type)[0] === "TypeExact")
    ? ((() => {
      const $usr = ($type)[1];
      const $args = ($type)[2];
      return ($core$List$for)($core$Dict$empty, $args, (($a, $acc) => {
        return ($core$Dict$join)(($sd0$Types$TypedAst$typeTyvars)($a), $acc);
      }));
    }))()
    : ((($type)[0] === "TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return ($core$Dict$ofOne)($id, null);
      }))()
      : (((($type)[0] === "TypeRecord") && ((($type)[1])[0] === "Nothing"))
        ? ((() => {
          const $attrs = ($type)[2];
          return ($core$Dict$for)($core$Dict$empty, $attrs, (($k, $a, $d) => {
            return ($core$Dict$join)(($sd0$Types$TypedAst$typeTyvars)($a), $d);
          }));
        }))()
        : (((($type)[0] === "TypeRecord") && ((($type)[1])[0] === "Just"))
          ? ((() => {
            const $id = (($type)[1])[1];
            const $attrs = ($type)[2];
            return ((($0) => {
              return ($core$Dict$for)($0, $attrs, (($k, $a, $d) => {
                return ($core$Dict$join)(($sd0$Types$TypedAst$typeTyvars)($a), $d);
              }));
            }))(($core$Dict$ofOne)($id, null));
          }))()
          : ((($type)[0] === "TypeError")
            ? $core$Dict$empty
            : ((($type)[0] === "TypeFn")
              ? ((() => {
                const $ins = ($type)[1];
                const $out = ($type)[2];
                return ((($0) => {
                  return ($core$List$for)($0, $ins, (($in, $a) => {
                    return ($core$Dict$join)(($sd0$Types$TypedAst$typeTyvars)(($sd0$Types$TypedAst$toRaw)($in)), $a);
                  }));
                }))(($sd0$Types$TypedAst$typeTyvars)($out.raw));
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 340:4', (sp_toHuman)($type))))))));
});

const $sd0$Compiler$TypeCheck$addConstructorToGlobalEnv = (($state, $paramsByName, $freeTyvars, $name, $caConstructor, $env) => {
  const $$umr = $caConstructor.typeUsr;
  const $umr = ($$umr)[1];
  const $ins = ((($1) => {
    return ($core$List$map)((($in) => {
      return ($sd0$Types$CanonicalAst$ParSp)(({
        raw: $in,
        uni: ($sd0$Types$Ast$Depends)(1),
      }));
    }), $1);
  }))($caConstructor.ins);
  const $caRaw = ((sp_equal)($ins, $core$Core$Nil)
    ? $caConstructor.out
    : ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$G, $ins, ({
      raw: $caConstructor.out,
      uni: ($sd0$Types$Ast$Depends)(1),
    })));
  const $raw = ((__re__ = ($sd0$Compiler$TypeCheck$translateRawType)($env, $paramsByName, $core$Dict$empty, $state, $caRaw)), ($state = (__re__)[1]), (__re__)[0]);
  const $consTyvars = ($sd0$Types$TypedAst$typeTyvars)($raw);
  const $taConstructor = ({
    definedAt: $sd0$Types$Pos$G,
    freeTyvars: ((($1) => {
      return ($core$Dict$filter)((($k, $v) => {
        return ($core$Dict$member)($k, $consTyvars);
      }), $1);
    }))($freeTyvars),
    freeUnivars: ($core$Dict$ofOne)(1, ({
      originalId: 1,
    })),
    type: ($sd0$Types$Ast$toImm)($raw),
  });
  const $0 = $env;
  return ([
    (Object.assign)({}, $0, ({
      constructors: ($core$Dict$insert)(($sd0$Types$Meta$USR)($umr, $name), $taConstructor, $0.constructors),
    })),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$addUnionTypeAndConstructorsToGlobalEnv = (($state, _1, $caUnionDef, $env) => {
  const $paramsByName = ($core$Dict$fromList)(((($1) => {
    return ($core$List$indexedMap)((($index, $$name) => {
      const $pos = ($$name)[1];
      const $name = ($$name)[2];
      return ({
        first: $name,
        second: ($sd0$Types$TypedAst$TypeVar)(-($index)),
      });
    }), $1);
  }))($caUnionDef.pars));
  const $makeTyvar = (($index, $$name) => {
    const $pos = ($$name)[1];
    const $name = ($$name)[2];
    return ({
      first: -($index),
      second: ({
        allowFunctions: true,
        generalizedAt: $sd0$Types$Pos$G,
        generalizedFor: ($sd0$Types$Ast$RefLocal)(""),
        originalName: $name,
      }),
    });
  });
  const $freeTyvars = ($core$Dict$fromList)(((($1) => {
    return ($core$List$indexedMap)($makeTyvar, $1);
  }))($caUnionDef.pars));
  return ([
    ((($0) => {
      return ($core$Dict$for)($0, $caUnionDef.constructors, (($3, $4, $5) => {
        return ((__re__ = ($sd0$Compiler$TypeCheck$addConstructorToGlobalEnv)($state, $paramsByName, $freeTyvars, $3, $4, $5)), ($state = (__re__)[1]), (__re__)[0]);
      }));
    }))(((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        exactTypes: ($core$Dict$insert)($caUnionDef.usr, $caUnionDef.pars, $0.exactTypes),
      }));
    }))()),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$addValueToGlobalEnv = (($state, $umr, $def, $env) => {
  const $nameToIdAndClasses = ((() => {
    const $zzzz = (($name, $$allowFunctions) => {
      const $allowFunctions = $$allowFunctions.allowFunctions;
      return ({
        first: ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]),
        second: ({
          allowFunctions: $allowFunctions,
          generalizedAt: $sd0$Types$Pos$G,
          generalizedFor: ($sd0$Types$Ast$RefLocal)(""),
          originalName: $name,
        }),
      });
    });
    return ($core$Dict$map)($zzzz, $def.tyvars);
  }))();
  const $nameToType = ($core$Dict$map)((($k, $$classes) => {
    const $id = $$classes.first;
    const $classes = $$classes.second;
    return ($sd0$Types$TypedAst$TypeVar)($id);
  }), $nameToIdAndClasses);
  const $tyvarIdToClasses = ($core$Dict$fromList)(($core$Dict$values)($nameToIdAndClasses));
  const $originalIdToNewIdAndUnivar = ((($1) => {
    return ($core$Dict$map)((($originalId, _1) => {
      return ({
        first: ((__re__ = ($sd0$Compiler$TypeCheck$newTyvarId)($state)), ($state = (__re__)[1]), (__re__)[0]),
        second: ({
          originalId: $originalId,
        }),
      });
    }), $1);
  }))($def.univars);
  const $originalIdToUniqueness = ((($1) => {
    return ($core$Dict$map)((($originalId, $$newId) => {
      const $newId = $$newId.first;
      const $univar = $$newId.second;
      return $newId;
    }), $1);
  }))($originalIdToNewIdAndUnivar);
  const $freeUnivars = ($core$Dict$fromList)(($core$Dict$values)($originalIdToNewIdAndUnivar));
  return ([
    ($core$Dict$for)($env, ($sd0$Types$CanonicalAst$patternNames)($def.pattern), (($valueName, $valueStuff, $envX) => {
      const $$try1 = $valueStuff.maybeAnnotation;
      return ((($$try1)[0] === "Nothing")
        ? $envX
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $annotation = ($$try1)[1];
            const $raw = ((__re__ = ($sd0$Compiler$TypeCheck$translateRawType)($env, $nameToType, $originalIdToUniqueness, $state, $annotation)), ($state = (__re__)[1]), (__re__)[0]);
            const $instance = ({
              definedAt: $valueStuff.pos,
              freeTyvars: ($core$Dict$intersect)($tyvarIdToClasses, ($sd0$Types$TypedAst$typeTyvars)($raw)),
              freeUnivars: $freeUnivars,
              type: ({
                raw: $raw,
                uni: $sd0$Types$Ast$Imm,
              }),
            });
            const $ref = ($sd0$Types$Ast$RefGlobal)(((($1) => {
              return ($sd0$Types$Meta$USR)($umr, $1);
            }))($valueName));
            const $0 = $envX;
            return (Object.assign)({}, $0, ({
              variables: ($core$Dict$insert)($ref, $instance, $0.variables),
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2013:8', (sp_toHuman)($$try1))));
    })),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$initEnv = ({
  annotatedTyvarsByName: $core$Dict$empty,
  annotatedUnivarsByOriginalId: $core$Dict$empty,
  constructors: $core$Dict$empty,
  context: $sd0$Compiler$TypeCheck$Context_Global,
  exactTypes: $core$Dict$empty,
  expandedAliases: $core$Dict$empty,
  variables: $core$Dict$empty,
});

const $sd0$Compiler$TypeCheck$namedParsToIdParsAndDict = (($atPars) => {
  const $idPars = ((($1) => {
    return ($core$List$indexedMap)((($index, $atName) => {
      return -($index);
    }), $1);
  }))($atPars);
  const $typeByName = ($core$Dict$fromList)(((($1) => {
    return ($core$List$indexedMap)((($index, $$name) => {
      const $pos = ($$name)[1];
      const $name = ($$name)[2];
      return ({
        first: $name,
        second: ($sd0$Types$TypedAst$TypeVar)(-($index)),
      });
    }), $1);
  }))($atPars));
  return ({
    first: $idPars,
    second: $typeByName,
  });
});

const $sd0$Compiler$TypeCheck$expandAndInsertAlias = (($state, $allAliases, $usr, $aliasAccum) => {
  const $aliasDef = ((() => {
    const $$try1 = ($core$Dict$get)($usr, $allAliases);
    return ((($$try1)[0] === "Just")
      ? ((() => {
        const $def = ($$try1)[1];
        return $def;
      }))()
      : ((($$try1)[0] === "Nothing")
        ? ($sd0$Compiler$TypeCheck$bug)("alias not found")
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2118:8', (sp_toHuman)($$try1))));
  }))();
  const $$pars = ($sd0$Compiler$TypeCheck$namedParsToIdParsAndDict)($aliasDef.pars);
  const $typeByName = $$pars.second;
  const $pars = $$pars.first;
  const $originalIdToNewId = $core$Dict$empty;
  const $type = ((__re__ = ($sd0$Compiler$TypeCheck$translateRawType)(((() => {
    const $0 = $sd0$Compiler$TypeCheck$initEnv;
    return (Object.assign)({}, $0, ({
      expandedAliases: $aliasAccum,
    }));
  }))(), $typeByName, $originalIdToNewId, $state, $aliasDef.type)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ($core$Dict$insert)($usr, ({
      pars: $pars,
      type: $type,
    }), $aliasAccum),
    $state,
  ]);
});

const $sd0$Compiler$TypeCheck$getAliasDependencies = (($allAliases, $aliasDef) => {
  return ((($1) => {
    return ($core$Dict$map)((($k, $v) => {
      return null;
    }), $1);
  }))(((($1) => {
    return ($core$Dict$filter)((($usr, _1) => {
      return ($core$Dict$member)($usr, $allAliases);
    }), $1);
  }))($aliasDef.directTypeDeps));
});

const $sd0$Compiler$TypeCheck$initStateAndGlobalEnv = (($allModules) => {
  let $state = ($sd0$Compiler$TypeCheck$initState)(0);
  const $allAliases = ((($0) => {
    return ($core$List$for)($0, $allModules, (($mod, $zz) => {
      return ($core$Dict$for)($zz, $mod.aliasDefs, (($name, $aliasDef, $d) => {
        return ($core$Dict$insert)($aliasDef.usr, $aliasDef, $d);
      }));
    }));
  }))($core$Dict$empty);
  const $$circulars = ($sd0$RefHierarchy$reorder)((($1) => {
    return ($sd0$Compiler$TypeCheck$getAliasDependencies)($allAliases, $1);
  }), $allAliases);
  const $orderedAliases = $$circulars.second;
  const $circulars = $$circulars.first;
  ((sp_not_equal)($circulars, $core$Core$Nil)
    ? ((() => {
      (sp_log)("=========> ERROR circulars aliases!!", $circulars);
      return ($core$List$each)($circulars, (($circular) => {
        return ((__re__ = (array_push)($state.errors, ({
          first: $sd0$Types$Pos$G,
          second: $sd0$Compiler$TypeCheck$Context_Global,
          third: ($sd0$Compiler$TypeCheck$ErrorCircularAlias)($circular),
        }))), ($state.errors = (__re__)[1]), (__re__)[0]);
      }));
    }))()
    : null);
  const $expandedAliases = ((($0) => {
    return ($core$List$for)($0, $orderedAliases, (($2, $3) => {
      return ((__re__ = ($sd0$Compiler$TypeCheck$expandAndInsertAlias)($state, $allAliases, $2, $3)), ($state = (__re__)[1]), (__re__)[0]);
    }));
  }))($core$Dict$empty);
  const $doStuff = (($caModule, $env) => {
    return ((($0) => {
      return ($core$Dict$for)($0, $caModule.valueDefs, (($pattern, $v, $a) => {
        return ((__re__ = ($sd0$Compiler$TypeCheck$addValueToGlobalEnv)($state, $caModule.umr, $v, $a)), ($state = (__re__)[1]), (__re__)[0]);
      }));
    }))(((($0) => {
      return ($core$Dict$for)($0, $caModule.unionDefs, (($1, $2, $3) => {
        return ((__re__ = ($sd0$Compiler$TypeCheck$addUnionTypeAndConstructorsToGlobalEnv)($state, $1, $2, $3)), ($state = (__re__)[1]), (__re__)[0]);
      }));
    }))($env));
  });
  const $env = ((($0) => {
    return ($core$List$for)($0, $allModules, $doStuff);
  }))(((($0) => {
    return ($core$List$for)($0, $sd0$Compiler$CoreTypes$allDefs, (($2, $3) => {
      return ((__re__ = ($sd0$Compiler$TypeCheck$addUnionTypeAndConstructorsToGlobalEnv)($state, null, $2, $3)), ($state = (__re__)[1]), (__re__)[0]);
    }));
  }))(((() => {
    const $0 = $sd0$Compiler$TypeCheck$initEnv;
    return (Object.assign)({}, $0, ({
      expandedAliases: $expandedAliases,
    }));
  }))()));
  const $$try1 = ((__re__ = (array_toList)($state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]);
  return ((($$try1)[0] === "Nil")
    ? ($core$Result$Ok)(({
      first: $state.lastUnificationVarId,
      second: $env,
    }))
    : (true
      ? ((() => {
        const $list = $$try1;
        return ($core$Result$Err)(($sd0$Compiler$Error$Nested)(((($1) => {
          return ($core$List$map)((($1) => {
            return ($sd0$Compiler$TypeCheck$makeInferenceAndCheckError)($env, $1);
          }), $1);
        }))($list)));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck.sp 2187:4', (sp_toHuman)($$try1))));
});

const $sd0$Compiler$UniquenessCheck$addPatternToEnv = (($state, $pattern, $env) => {
  const $names = ($sd0$Types$TypedAst$patternNames)($pattern);
  const $insertVariable = (($name, $$pos, $z) => {
    const $pos = $$pos.pos;
    const $type = $$pos.type;
    const $mode = ((sp_equal)($type.uni, $sd0$Types$Ast$Imm)
      ? $sd0$Compiler$UniquenessCheck$Immutable
      : ($sd0$Compiler$UniquenessCheck$Unique)($sd0$Compiler$UniquenessCheck$Available));
    const $variable = ({
      definedAt: $pos,
      mode: $mode,
      name: $name,
      required: $core$Dict$empty,
      type: $type,
    });
    return ($core$Dict$insert)($name, $variable, $z);
  });
  const $localEnv = ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      variables: ($core$Dict$for)($0.variables, $names, $insertVariable),
    }));
  }))();
  const $uniques = ((($1) => {
    return ($core$Dict$map)((($n, $s) => {
      return $s.pos;
    }), $1);
  }))(((($1) => {
    return ($core$Dict$filter)((($n, $s) => {
      return (sp_not_equal)($s.type.uni, $sd0$Types$Ast$Imm);
    }), $1);
  }))($names));
  return ([
    ({
      first: ($core$Dict$keys)($names),
      second: $uniques,
      third: $localEnv,
    }),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$consumeInEnv = (($spent, $env) => {
  const $translate = (($name, $variable) => {
    const $$try1 = ($core$Dict$get)($name, $spent);
    return ((($$try1)[0] === "Nothing")
      ? $variable
      : ((($$try1)[0] === "Just")
        ? ((() => {
          const $pos = ($$try1)[1];
          const $0 = $variable;
          return (Object.assign)({}, $0, ({
            mode: ($sd0$Compiler$UniquenessCheck$Unique)(($sd0$Compiler$UniquenessCheck$ConsumedAt)($pos)),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 266:12', (sp_toHuman)($$try1))));
  });
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: ($core$Dict$map)($translate, $0.variables),
  }));
});

const $sd0$Compiler$UniquenessCheck$addError = (($pos, $state, $messageConstructor) => {
  return ([
    ((__re__ = (array_push)($state.errors, ($sd0$Compiler$Error$Simple)($pos, $messageConstructor))), ($state.errors = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorMutatingAConsumed = (($name, $p2, $p1, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($p1, $state, (($eenv) => {
      const $$block = ($sd0$Compiler$Error$posToHuman)($eenv, $p2);
      const $location = $$block.location;
      const $block = $$block.block;
      return ($core$Core$Cons)(("This code spends the unique variable `" + ($name + ("`, but `" + ($name + "` is being used again here:")))), ($core$Core$Cons)("", ($core$Core$Cons)($block, ($core$Core$Cons)("", ($core$Core$Cons)("If you want to use a unique more than once, you need to use a function that recycles it.", ($core$Core$Cons)("TODO: link to uniqueness wiki page", $core$Core$Nil))))));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorMutatingAnImmutable = (($name, $p, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($p, $state, (($eenv) => {
      return ($core$Core$Cons)(($name + " is immutable, but you are trying to mutate it"), $core$Core$Nil);
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorMutatingTwice = (($name, $p1, $p2, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($p1, $state, (($eenv) => {
      const $$block = ($sd0$Compiler$Error$posToHuman)($eenv, $p2);
      const $location = $$block.location;
      const $block = $$block.block;
      return ($core$Core$Cons)(($name + " is already being mutated here: "), ($core$Core$Cons)($block, ($core$Core$Cons)("You can't use the same unique twice in the same function call", ($core$Core$Cons)("TODO: link to wiki explaining why", $core$Core$Nil))));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorReferencingConsumedVariable = (($name, $pos, $consumedPos, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($pos, $state, (($eenv) => {
      const $$block = ($sd0$Compiler$Error$posToHuman)($eenv, $pos);
      const $location = $$block.location;
      const $block = $$block.block;
      const $cons = ($sd0$Compiler$Error$posToHuman)($eenv, $consumedPos);
      return ($core$Core$Cons)(("You can't reference again the variable `" + ($name + "` because it was used already here:")), ($core$Core$Cons)($cons.block, $core$Core$Nil));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorUndefinedVariable = (($p, $name, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($p, $state, (($eenv) => {
      return ($core$Core$Cons)(("undefined variable: " + $name), $core$Core$Nil);
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$doArgument = (($env, $state, $pos, $doneSoFar) => {
  const $$try1 = $doneSoFar.resolved;
  return ([
    ((($$try1)[0] === "ArgumentExpression")
      ? ((() => {
        const $fullType = ($$try1)[1];
        const $expr = ($$try1)[2];
        const $doneExpression = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $expr)), ($state = (__re__)[1]), (__re__)[0]);
        ($core$Dict$each)($doneExpression.spent, (($name, $p1) => {
          const $$try5 = ($core$Dict$get)($name, $doneSoFar.spent);
          return ((($$try5)[0] === "Nothing")
            ? null
            : ((($$try5)[0] === "Just")
              ? ((() => {
                const $p2 = ($$try5)[1];
                return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorReferencingConsumedVariable)($name, $p1, $p2, $state)), ($state = (__re__)[1]), (__re__)[0]);
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 375:16', (sp_toHuman)($$try5))));
        }));
        return ({
          recycled: $doneSoFar.recycled,
          required: ($core$Dict$join)($doneExpression.required, $doneSoFar.required),
          resolved: ($sd0$Types$TypedAst$ArgumentExpression)($fullType, $doneExpression.resolved),
          spent: ($core$Dict$join)($doneExpression.spent, $doneSoFar.spent),
        });
      }))()
      : ((($$try1)[0] === "ArgumentRecycle")
        ? ((() => {
          const $p1 = ($$try1)[1];
          const $rawType = ($$try1)[2];
          const $attrPath = ($$try1)[3];
          const $name = ($$try1)[4];
          const $x = ((() => {
            const $$try3 = ($core$Dict$get)($name, $env.variables);
            return ((($$try3)[0] === "Nothing")
              ? ((__re__ = ($sd0$Compiler$UniquenessCheck$errorUndefinedVariable)($p1, $name, $state)), ($state = (__re__)[1]), (__re__)[0])
              : ((($$try3)[0] === "Just")
                ? ((() => {
                  const $variable = ($$try3)[1];
                  const $$try4 = $variable.mode;
                  return (((($$try4)[0] === "Unique") && ((($$try4)[1])[0] === "Available"))
                    ? null
                    : ((($$try4)[0] === "Immutable")
                      ? ((__re__ = ($sd0$Compiler$UniquenessCheck$errorMutatingAnImmutable)($name, $p1, $state)), ($state = (__re__)[1]), (__re__)[0])
                      : (((($$try4)[0] === "Unique") && ((($$try4)[1])[0] === "ConsumedAt"))
                        ? ((() => {
                          const $p2 = (($$try4)[1])[1];
                          return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorMutatingAConsumed)($name, $p1, $p2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                        }))()
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 395:20', (sp_toHuman)($$try4)))));
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 392:14', (sp_toHuman)($$try3))));
          }))();
          const $y = ((() => {
            const $$try2 = ($core$Dict$get)($name, $doneSoFar.recycled);
            return ((($$try2)[0] === "Nothing")
              ? null
              : ((($$try2)[0] === "Just")
                ? ((() => {
                  const $p2 = ($$try2)[1];
                  return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorMutatingTwice)($name, $p1, $p2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 401:14', (sp_toHuman)($$try2))));
          }))();
          const $0 = $doneSoFar;
          return (Object.assign)({}, $0, ({
            recycled: ($core$Dict$insert)($name, $p1, $doneSoFar.recycled),
            resolved: ($sd0$Types$TypedAst$ArgumentRecycle)($p1, $rawType, $attrPath, $name),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 367:4', (sp_toHuman)($$try1)))),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions = (($callPos, $name, $required, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($callPos, $state, (($eenv) => {
      return ($core$Core$Cons)(("This function call could allow some unique values (" + (((($1) => {
        return ($core$Text$join)(", ", $1);
      }))(($core$Dict$keys)($required)) + ")")), ($core$Core$Cons)(("to be recycled by a functions contained in the argument `" + ($name + "` outside of the scope where they were declared.")), ($core$Core$Cons)("This would be BAD. [TODO link to wiki]", ($core$Core$Cons)("TODO improve this explanation.", $core$Core$Nil))));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$uniOutInit = (($a) => {
  return ({
    recycled: $core$Dict$empty,
    required: $core$Dict$empty,
    resolved: $a,
    spent: $core$Dict$empty,
  });
});

const $sd0$Compiler$UniquenessCheck$uniOutMap = (($f, $$recycled) => {
  const $recycled = $$recycled.recycled;
  const $required = $$recycled.required;
  const $resolved = $$recycled.resolved;
  const $spent = $$recycled.spent;
  return ({
    recycled: $recycled,
    required: $required,
    resolved: ($f)($resolved),
    spent: $spent,
  });
});

const $sd0$Types$TypedAst$typeAllowsFunctions = (($testId, $type) => {
  return ((($type)[0] === "TypeFn")
    ? ((() => {
      const $ins = ($type)[1];
      const $out = ($type)[2];
      return true;
    }))()
    : ((($type)[0] === "TypeVar")
      ? ((() => {
        const $id = ($type)[1];
        return ($testId)($id);
      }))()
      : ((($type)[0] === "TypeExact")
        ? ((() => {
          const $usr = ($type)[1];
          const $args = ($type)[2];
          return ($core$List$any)((($1) => {
            return ($sd0$Types$TypedAst$typeAllowsFunctions)($testId, $1);
          }), $args);
        }))()
        : ((($type)[0] === "TypeRecord")
          ? ((() => {
            const $attrs = ($type)[2];
            return ($core$Dict$any)((($k, $v) => {
              return ($sd0$Types$TypedAst$typeAllowsFunctions)($testId, $v);
            }), $attrs);
          }))()
          : ((($type)[0] === "TypeError")
            ? true
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/TypedAst.sp 353:4', (sp_toHuman)($type)))))));
});

const $sd0$Compiler$UniquenessCheck$doCall = (($env, $state, $pos, $reference, $arguments) => {
  const $doneReference = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $reference)), ($state = (__re__)[1]), (__re__)[0]);
  const $doneArgs = ((($0) => {
    return ($core$List$forReversed)($0, $arguments, (($arg, $acc) => {
      return ((($1) => {
        return ($sd0$Compiler$UniquenessCheck$uniOutMap)((($resolvedArg) => {
          return (sp_cons)($resolvedArg, $acc.resolved);
        }), $1);
      }))(((($3) => {
        return ((__re__ = ($sd0$Compiler$UniquenessCheck$doArgument)($env, $state, $pos, $3)), ($state = (__re__)[1]), (__re__)[0]);
      }))(((($1) => {
        return ($sd0$Compiler$UniquenessCheck$uniOutMap)(((_0) => {
          return $arg;
        }), $1);
      }))($acc)));
    }));
  }))(($sd0$Compiler$UniquenessCheck$uniOutInit)($core$Core$Nil));
  const $asRecyclingFunction = (($arg) => {
    return ((($arg)[0] === "ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $path = ($arg)[3];
        const $name = ($arg)[4];
        return (($sd0$Types$TypedAst$typeAllowsFunctions)((($tyvarId) => {
          return false;
        }), $raw)
          ? ($core$Maybe$Just)($name)
          : $core$Maybe$Nothing);
      }))()
      : ((($arg)[0] === "ArgumentExpression")
        ? $core$Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 332:8', (sp_toHuman)($arg))));
  });
  (((sp_not_equal)($doneArgs.required, $core$Dict$empty) || (sp_not_equal)($doneReference.required, $core$Dict$empty))
    ? ($core$List$each)(($core$List$filterMap)($asRecyclingFunction, $arguments), (($name) => {
      return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions)($pos, $name, ($core$Dict$join)($doneArgs.required, $doneReference.required), $state)), ($state = (__re__)[1]), (__re__)[0]);
    }))
    : null);
  return ([
    ({
      recycled: ($core$Dict$join)($doneReference.recycled, $doneArgs.recycled),
      required: $doneArgs.required,
      resolved: ($sd0$Types$TypedAst$Call)($pos, $doneReference.resolved, $doneArgs.resolved),
      spent: ($core$Dict$join)($doneReference.spent, $doneArgs.spent),
    }),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$doParameter = (($state, $par, $acc) => {
  return ([
    ((($par)[0] === "ParameterPattern")
      ? ((() => {
        const $fullType = ($par)[1];
        const $pa = ($par)[2];
        const $$addedVars = ((__re__ = ($sd0$Compiler$UniquenessCheck$addPatternToEnv)($state, $pa, $acc.localEnv)), ($state = (__re__)[1]), (__re__)[0]);
        const $localEnv = $$addedVars.third;
        const $uniques = $$addedVars.second;
        const $addedVars = $$addedVars.first;
        const $0 = $acc;
        return (Object.assign)({}, $0, ({
          localEnv: $localEnv,
          parsToBeSpent: ($core$Dict$join)($uniques, $0.parsToBeSpent),
        }));
      }))()
      : ((($par)[0] === "ParameterRecycle")
        ? ((() => {
          const $pos = ($par)[1];
          const $rawType = ($par)[2];
          const $name = ($par)[3];
          const $var = ({
            definedAt: $pos,
            mode: ($sd0$Compiler$UniquenessCheck$Unique)($sd0$Compiler$UniquenessCheck$Available),
            name: $name,
            required: $core$Dict$empty,
            type: ({
              raw: $rawType,
              uni: $sd0$Types$Ast$Uni,
            }),
          });
          const $0 = $acc;
          return (Object.assign)({}, $0, ({
            localEnv: ((() => {
              const $1 = $acc.localEnv;
              return (Object.assign)({}, $1, ({
                variables: ($core$Dict$insert)($name, $var, $1.variables),
              }));
            }))(),
            parsToBeRecycled: ($core$Dict$insert)($name, $pos, $0.parsToBeRecycled),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 424:4', (sp_toHuman)($par)))),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorConsumingRecycledParameters = (($pos, $spentThatShouldHaveBeenRecycled, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($pos, $state, (($eenv) => {
      return ($core$Core$Cons)("errorConsumingRecycledParameters", ($core$Core$Cons)((sp_toHuman)($spentThatShouldHaveBeenRecycled), $core$Core$Nil));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques = (($functionPos, $spentFromParent, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($functionPos, $state, (($eenv) => {
      const $zzz = (($$name) => {
        const $name = $$name.first;
        const $spentPos = $$name.second;
        const $$block = ($sd0$Compiler$Error$posToHuman)($eenv, $spentPos);
        const $location = $$block.location;
        const $block = $$block.block;
        return ($block + "\n");
      });
      const $blocks = ((($1) => {
        return ($core$List$map)($zzz, $1);
      }))(((($1) => {
        return (list_sortBy)($core$Tuple$second, $1);
      }))(($core$Dict$toList)($spentFromParent)));
      return ($core$List$concat)(($core$Core$Cons)(($core$Core$Cons)(("This function is spending the unique variable `" + (((($1) => {
        return ($core$Text$join)("`, `", $1);
      }))(($core$Dict$keys)($spentFromParent)) + "`")), $core$Core$Nil), ($core$Core$Cons)(($core$Core$Cons)("", $core$Core$Nil), ($core$Core$Cons)($blocks, ($core$Core$Cons)(($core$Core$Cons)("However, functions cannot spend uniques that were declared outside their body.", $core$Core$Nil), $core$Core$Nil)))));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope = (($name, $$fnPos, $state) => {
  const $fnPos = $$fnPos.fnPos;
  const $usedAt = $$fnPos.usedAt;
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($fnPos, $state, (($eenv) => {
      const $$block = ($sd0$Compiler$Error$posToHuman)($eenv, $usedAt);
      const $location = $$block.location;
      const $block = $$block.block;
      return ($core$Core$Cons)(("This expression needs to access the unique variable `" + ($name + "` because it uses it here:")), ($core$Core$Cons)("", ($core$Core$Cons)($block, ($core$Core$Cons)("", ($core$Core$Cons)(("The problem is that returning a function from the expression could allow accessing `" + ($name + ("` from outside of where `" + ($name + "` was declared.")))), ($core$Core$Cons)("This would be BAD. [TODO link to wiki]", $core$Core$Nil))))));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$doFn = (($env, $pos, $state, $pars, $body, $bodyType) => {
  const $$localEnv = ((($0) => {
    return ($core$List$for)($0, $pars, (($1, $2) => {
      return ((__re__ = ($sd0$Compiler$UniquenessCheck$doParameter)($state, $1, $2)), ($state = (__re__)[1]), (__re__)[0]);
    }));
  }))(({
    localEnv: $env,
    parsToBeRecycled: $core$Dict$empty,
    parsToBeSpent: $core$Dict$empty,
  }));
  const $parsToBeSpent = $$localEnv.parsToBeSpent;
  const $parsToBeRecycled = $$localEnv.parsToBeRecycled;
  const $localEnv = $$localEnv.localEnv;
  const $doneBody = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($localEnv, $state, $body)), ($state = (__re__)[1]), (__re__)[0]);
  const $exprWithDestruction = ((($0) => {
    return ($core$Dict$for)($0, $parsToBeSpent, (($name, _1, $exp) => {
      return (($core$Dict$member)($name, $doneBody.spent)
        ? $exp
        : ($sd0$Types$TypedAst$DestroyIn)($name, $exp));
    }));
  }))($doneBody.resolved);
  const $spentThatShouldHaveBeenRecycled = ($core$Dict$intersect)($doneBody.spent, $parsToBeRecycled);
  ((sp_not_equal)($spentThatShouldHaveBeenRecycled, $core$Dict$empty)
    ? ((__re__ = ($sd0$Compiler$UniquenessCheck$errorConsumingRecycledParameters)($pos, $spentThatShouldHaveBeenRecycled, $state)), ($state = (__re__)[1]), (__re__)[0])
    : null);
  const $spentFromParent = ($core$Dict$diff)($doneBody.spent, $parsToBeSpent);
  (((sp_equal)($spentThatShouldHaveBeenRecycled, $core$Dict$empty) && (sp_not_equal)($spentFromParent, $core$Dict$empty))
    ? ((__re__ = ($sd0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques)($pos, $spentFromParent, $state)), ($state = (__re__)[1]), (__re__)[0])
    : null);
  const $required = ((($0) => {
    return ($core$Dict$diff)($0, $parsToBeRecycled);
  }))(((($1) => {
    return ($core$Dict$join)($doneBody.required, $1);
  }))(((($1) => {
    return ($core$Dict$map)((($k, $usedAt) => {
      return ({
        fnPos: $pos,
        usedAt: $usedAt,
      });
    }), $1);
  }))($doneBody.recycled)));
  (($sd0$Types$TypedAst$typeAllowsFunctions)((($tyvarId) => {
    return false;
  }), $bodyType.raw)
    ? ($core$Dict$each)(($core$Dict$join)($parsToBeRecycled, $parsToBeSpent), (($varName, $parPos) => {
      const $$try1 = ($core$Dict$get)($varName, $doneBody.required);
      return ((($$try1)[0] === "Nothing")
        ? null
        : ((($$try1)[0] === "Just")
          ? ((() => {
            const $r = ($$try1)[1];
            return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope)($varName, $r, $state)), ($state = (__re__)[1]), (__re__)[0]);
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 772:12', (sp_toHuman)($$try1))));
    }))
    : null);
  return ([
    ({
      recycled: ($core$Dict$diff)($doneBody.recycled, $parsToBeRecycled),
      required: $required,
      resolved: ($sd0$Types$TypedAst$Fn)($pos, $pars, $exprWithDestruction, $bodyType),
      spent: $core$Dict$empty,
    }),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$requireInEnv = (($varNames, $required, $env) => {
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: ((($0) => {
      return ($core$List$for)($0, $varNames, (($name, $a) => {
        return ($core$Dict$update)($name, (($1) => {
          return ($core$Maybe$map)((($var) => {
            const $1 = $var;
            return (Object.assign)({}, $1, ({
              required: $required,
            }));
          }), $1);
        }), $a);
      }));
    }))($0.variables),
  }));
});

const $sd0$Compiler$UniquenessCheck$doExpression = (($env, $state, $expression) => {
  const $re = ($sd0$Compiler$UniquenessCheck$uniOutInit)($expression);
  return ([
    ((($expression)[0] === "LiteralText")
      ? ((() => {
        const $pos = ($expression)[1];
        const $l = ($expression)[2];
        return $re;
      }))()
      : ((($expression)[0] === "LiteralNumber")
        ? ((() => {
          const $pos = ($expression)[1];
          const $l = ($expression)[2];
          return $re;
        }))()
        : (((($expression)[0] === "Variable") && ((($expression)[2])[0] === "RefGlobal"))
          ? ((() => {
            const $pos = ($expression)[1];
            return $re;
          }))()
          : (((($expression)[0] === "Variable") && ((($expression)[2])[0] === "RefLocal"))
            ? ((() => {
              const $pos = ($expression)[1];
              const $name = (($expression)[2])[1];
              const $$try3 = ($core$Dict$get)($name, $env.variables);
              return ((($$try3)[0] === "Nothing")
                ? ((() => {
                  ((__re__ = ($sd0$Compiler$UniquenessCheck$errorUndefinedVariable)($pos, $name, $state)), ($state = (__re__)[1]), (__re__)[0]);
                  return $re;
                }))()
                : ((($$try3)[0] === "Just")
                  ? ((() => {
                    const $variable = ($$try3)[1];
                    const $$try4 = $variable.mode;
                    return ((($$try4)[0] === "Immutable")
                      ? ({
                        recycled: $core$Dict$empty,
                        required: $variable.required,
                        resolved: $expression,
                        spent: $core$Dict$empty,
                      })
                      : (((($$try4)[0] === "Unique") && ((($$try4)[1])[0] === "Available"))
                        ? ({
                          recycled: $core$Dict$empty,
                          required: $variable.required,
                          resolved: $expression,
                          spent: ($core$Dict$ofOne)($name, $pos),
                        })
                        : (((($$try4)[0] === "Unique") && ((($$try4)[1])[0] === "ConsumedAt"))
                          ? ((() => {
                            const $consumedPos = (($$try4)[1])[1];
                            ((__re__ = ($sd0$Compiler$UniquenessCheck$errorReferencingConsumedVariable)($name, $pos, $consumedPos, $state)), ($state = (__re__)[1]), (__re__)[0]);
                            return ({
                              recycled: $core$Dict$empty,
                              required: $variable.required,
                              resolved: $expression,
                              spent: ($core$Dict$ofOne)($name, $pos),
                            });
                          }))()
                          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 474:20', (sp_toHuman)($$try4)))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 468:12', (sp_toHuman)($$try3))));
            }))()
            : ((($expression)[0] === "Constructor")
              ? ((() => {
                const $pos = ($expression)[1];
                const $usr = ($expression)[2];
                return $re;
              }))()
              : ((($expression)[0] === "Fn")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $pars = ($expression)[2];
                  const $body = ($expression)[3];
                  const $bodyType = ($expression)[4];
                  return ((__re__ = ($sd0$Compiler$UniquenessCheck$doFn)($env, $pos, $state, $pars, $body, $bodyType)), ($state = (__re__)[1]), (__re__)[0]);
                }))()
                : ((($expression)[0] === "Call")
                  ? ((() => {
                    const $pos = ($expression)[1];
                    const $reference = ($expression)[2];
                    const $arguments = ($expression)[3];
                    return ((__re__ = ($sd0$Compiler$UniquenessCheck$doCall)($env, $state, $pos, $reference, $arguments)), ($state = (__re__)[1]), (__re__)[0]);
                  }))()
                  : ((($expression)[0] === "If")
                    ? ((() => {
                      const $pos = ($expression)[1];
                      const $condition = ($expression)[2].condition;
                      const $false = ($expression)[2].false;
                      const $true = ($expression)[2].true;
                      const $doneCondition = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $condition)), ($state = (__re__)[1]), (__re__)[0]);
                      const $newEnv = ($sd0$Compiler$UniquenessCheck$consumeInEnv)($doneCondition.spent, $env);
                      const $doneTrue = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($newEnv, $state, $true)), ($state = (__re__)[1]), (__re__)[0]);
                      const $doneFalse = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($newEnv, $state, $false)), ($state = (__re__)[1]), (__re__)[0]);
                      const $finalTrueExpression = ((($0) => {
                        return ($core$Dict$for)($0, $doneFalse.spent, (($name, _1, $exp) => {
                          return (($core$Dict$member)($name, $doneTrue.spent)
                            ? $exp
                            : ($sd0$Types$TypedAst$DestroyIn)($name, $exp));
                        }));
                      }))($doneTrue.resolved);
                      const $finalFalseExpression = ((($0) => {
                        return ($core$Dict$for)($0, $doneTrue.spent, (($name, _1, $exp) => {
                          return (($core$Dict$member)($name, $doneFalse.spent)
                            ? $exp
                            : ($sd0$Types$TypedAst$DestroyIn)($name, $exp));
                        }));
                      }))($doneFalse.resolved);
                      const $finalExpression = ($sd0$Types$TypedAst$If)($pos, ({
                        condition: $doneCondition.resolved,
                        false: $finalFalseExpression,
                        true: $finalTrueExpression,
                      }));
                      return ({
                        recycled: ((($1) => {
                          return ($core$Dict$join)($doneFalse.recycled, $1);
                        }))(((($1) => {
                          return ($core$Dict$join)($doneTrue.recycled, $1);
                        }))($doneCondition.recycled)),
                        required: ((($1) => {
                          return ($core$Dict$join)($doneFalse.required, $1);
                        }))(((($1) => {
                          return ($core$Dict$join)($doneTrue.required, $1);
                        }))($doneCondition.required)),
                        resolved: $finalExpression,
                        spent: ((($1) => {
                          return ($core$Dict$join)($doneFalse.spent, $1);
                        }))(((($1) => {
                          return ($core$Dict$join)($doneTrue.spent, $1);
                        }))($doneCondition.spent)),
                      });
                    }))()
                    : ((($expression)[0] === "Try")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                        const $value = ($expression)[2].value;
                        const $valueType = ($expression)[2].valueType;
                        const $doneValue = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $value)), ($state = (__re__)[1]), (__re__)[0]);
                        const $newEnv = ($sd0$Compiler$UniquenessCheck$consumeInEnv)($doneValue.spent, $env);
                        const $zzz = (($$block) => {
                          const $pattern = $$block.first;
                          const $block = $$block.second;
                          const $$addedVars = ((__re__ = ($sd0$Compiler$UniquenessCheck$addPatternToEnv)($state, $pattern, $newEnv)), ($state = (__re__)[1]), (__re__)[0]);
                          const $env0 = $$addedVars.third;
                          const $mutables_should_be_empty = $$addedVars.second;
                          const $addedVars = $$addedVars.first;
                          const $localEnv = ($sd0$Compiler$UniquenessCheck$requireInEnv)($addedVars, $doneValue.required, $env0);
                          return ((($1) => {
                            return ($sd0$Compiler$UniquenessCheck$uniOutMap)((($expr) => {
                              return ({
                                first: $pattern,
                                second: $expr,
                              });
                            }), $1);
                          }))(((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($localEnv, $state, $block)), ($state = (__re__)[1]), (__re__)[0]));
                        });
                        const $donePatternsAndBlocks = ((($1) => {
                          return ($core$List$map)($zzz, $1);
                        }))($patternsAndExpressions);
                        const $allRecycled = ((($0) => {
                          return ($core$List$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                            return ($core$Dict$join)($d.recycled, $a);
                          }));
                        }))($core$Dict$empty);
                        const $allRequired = ((($0) => {
                          return ($core$List$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                            return ($core$Dict$join)($d.required, $a);
                          }));
                        }))($core$Dict$empty);
                        const $allSpent = ((($0) => {
                          return ($core$List$for)($0, $donePatternsAndBlocks, (($d, $a) => {
                            return ($core$Dict$join)($d.spent, $a);
                          }));
                        }))($core$Dict$empty);
                        const $newPatternsAndBlocks = ((() => {
                          const $xxx = (($$blockExpression) => {
                            const $recycled = $$blockExpression.recycled;
                            const $required = $$blockExpression.required;
                            const $pattern = $$blockExpression.resolved.first;
                            const $blockExpression = $$blockExpression.resolved.second;
                            const $spent = $$blockExpression.spent;
                            const $finalBlock = ((($0) => {
                              return ($core$Dict$for)($0, $allSpent, (($name, _1, $exp) => {
                                return (($core$Dict$member)($name, $spent)
                                  ? $exp
                                  : ($sd0$Types$TypedAst$DestroyIn)($name, $exp));
                              }));
                            }))($blockExpression);
                            return ({
                              first: $pattern,
                              second: $finalBlock,
                            });
                          });
                          return ($core$List$map)($xxx, $donePatternsAndBlocks);
                        }))();
                        return ({
                          recycled: $allRecycled,
                          required: $allRequired,
                          resolved: ($sd0$Types$TypedAst$Try)($pos, ({
                            patternsAndExpressions: $newPatternsAndBlocks,
                            value: $doneValue.resolved,
                            valueType: $valueType,
                          })),
                          spent: $allSpent,
                        });
                      }))()
                      : ((($expression)[0] === "Record")
                        ? ((() => {
                          const $pos = ($expression)[1];
                          const $maybeExtending = ($expression)[2];
                          const $attrValueByName = ($expression)[3];
                          const $doneExt = ((($maybeExtending)[0] === "Nothing")
                            ? ($sd0$Compiler$UniquenessCheck$uniOutInit)($core$Maybe$Nothing)
                            : ((($maybeExtending)[0] === "Just")
                              ? ((() => {
                                const $extending = ($maybeExtending)[1];
                                return ((($1) => {
                                  return ($sd0$Compiler$UniquenessCheck$uniOutMap)($core$Maybe$Just, $1);
                                }))(((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $extending)), ($state = (__re__)[1]), (__re__)[0]));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 615:16', (sp_toHuman)($maybeExtending))));
                          const $doneAttrs = ((($0) => {
                            return ($core$Dict$for)($0, $attrValueByName, (($name, $value, $doneSoFar) => {
                              const $$recycled = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $value)), ($state = (__re__)[1]), (__re__)[0]);
                              const $spent = $$recycled.spent;
                              const $resolved = $$recycled.resolved;
                              const $required = $$recycled.required;
                              const $recycled = $$recycled.recycled;
                              const $consumedTwice = ($core$Dict$merge)((($k, $v, $d) => {
                                return $d;
                              }), (($k, $a, $b, $d) => {
                                return ($core$Dict$insert)($k, ({
                                  first: $a,
                                  second: $b,
                                }), $d);
                              }), (($k, $v, $d) => {
                                return $d;
                              }), $spent, $doneSoFar.spent, $core$Dict$empty);
                              ($core$Dict$each)($consumedTwice, (($n, $$p1) => {
                                const $p1 = $$p1.first;
                                const $p2 = $$p1.second;
                                return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorReferencingConsumedVariable)($n, $p1, $p2, $state)), ($state = (__re__)[1]), (__re__)[0]);
                              }));
                              return ({
                                recycled: ($core$Dict$join)($recycled, $doneSoFar.recycled),
                                required: ($core$Dict$join)($required, $doneSoFar.required),
                                resolved: ($core$Dict$insert)($name, $resolved, $doneSoFar.resolved),
                                spent: ($core$Dict$join)($spent, $doneSoFar.spent),
                              });
                            }));
                          }))(($sd0$Compiler$UniquenessCheck$uniOutInit)($core$Dict$empty));
                          return ({
                            recycled: ($core$Dict$join)($doneExt.recycled, $doneAttrs.recycled),
                            required: ($core$Dict$join)($doneExt.required, $doneAttrs.required),
                            resolved: ($sd0$Types$TypedAst$Record)($pos, $doneExt.resolved, $doneAttrs.resolved),
                            spent: ($core$Dict$join)($doneExt.spent, $doneAttrs.spent),
                          });
                        }))()
                        : ((($expression)[0] === "RecordAccess")
                          ? ((() => {
                            const $pos = ($expression)[1];
                            const $name = ($expression)[2];
                            const $expr = ($expression)[3];
                            return ((($1) => {
                              return ($sd0$Compiler$UniquenessCheck$uniOutMap)((($2) => {
                                return ($sd0$Types$TypedAst$RecordAccess)($pos, $name, $2);
                              }), $1);
                            }))(((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $expr)), ($state = (__re__)[1]), (__re__)[0]));
                          }))()
                          : ((($expression)[0] === "LetIn")
                            ? ((() => {
                              const $valueDef = ($expression)[1];
                              const $rest = ($expression)[2];
                              const $restType = ($expression)[3];
                              const $$addedVars = ((__re__ = ($sd0$Compiler$UniquenessCheck$addPatternToEnv)($state, $valueDef.pattern, $env)), ($state = (__re__)[1]), (__re__)[0]);
                              const $env1 = $$addedVars.third;
                              const $uniques = $$addedVars.second;
                              const $addedVars = $$addedVars.first;
                              const $doneDefBody = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env1, $state, $valueDef.body)), ($state = (__re__)[1]), (__re__)[0]);
                              const $localEnv = ((($2) => {
                                return ($sd0$Compiler$UniquenessCheck$requireInEnv)($addedVars, $doneDefBody.required, $2);
                              }))(((($1) => {
                                return ($sd0$Compiler$UniquenessCheck$consumeInEnv)($doneDefBody.spent, $1);
                              }))($env1));
                              const $doneExpression = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($localEnv, $state, $rest)), ($state = (__re__)[1]), (__re__)[0]);
                              (($sd0$Types$TypedAst$typeAllowsFunctions)((($tyvarId) => {
                                return false;
                              }), $restType.raw)
                                ? ($core$List$each)($addedVars, (($varName) => {
                                  const $$try2 = ($core$Dict$get)($varName, $doneExpression.required);
                                  return ((($$try2)[0] === "Nothing")
                                    ? null
                                    : ((($$try2)[0] === "Just")
                                      ? ((() => {
                                        const $r = ($$try2)[1];
                                        return ((__re__ = ($sd0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope)($varName, $r, $state)), ($state = (__re__)[1]), (__re__)[0]);
                                      }))()
                                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 688:20', (sp_toHuman)($$try2))));
                                }))
                                : null);
                              const $finalExpression = ((($0) => {
                                return ($core$Dict$for)($0, $uniques, (($name, $pos, $exp) => {
                                  const $$try1 = ($core$Dict$get)($name, $doneExpression.spent);
                                  return ((($$try1)[0] === "Just")
                                    ? $exp
                                    : ((($$try1)[0] === "Nothing")
                                      ? ($sd0$Types$TypedAst$DestroyIn)($name, $exp)
                                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 697:20', (sp_toHuman)($$try1))));
                                }));
                              }))(($sd0$Types$TypedAst$LetIn)(((() => {
                                const $0 = $valueDef;
                                return (Object.assign)({}, $0, ({
                                  body: $doneDefBody.resolved,
                                }));
                              }))(), $doneExpression.resolved, $restType));
                              const $spent = ((($1) => {
                                return ($core$Dict$join)($doneDefBody.spent, $1);
                              }))(((($0) => {
                                return ($core$Dict$for)($0, $uniques, (($name, _1, $d) => {
                                  return ($core$Dict$remove)($name, $d);
                                }));
                              }))($doneExpression.spent));
                              return ({
                                recycled: ($core$Dict$join)($doneDefBody.recycled, $doneExpression.recycled),
                                required: $doneExpression.required,
                                resolved: $finalExpression,
                                spent: $spent,
                              });
                            }))()
                            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/UniquenessCheck.sp 457:4', (sp_toHuman)($expression)))))))))))))),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$doModule = (($module) => {
  (sp_benchStart)(null);
  let $state = ({
    errors: (array_fromList)($core$Core$Nil),
  });
  const $env = ({
    variables: $core$Dict$empty,
  });
  const $do = ((_0, $def) => {
    const $doneExpression = ((__re__ = ($sd0$Compiler$UniquenessCheck$doExpression)($env, $state, $def.body)), ($state = (__re__)[1]), (__re__)[0]);
    const $0 = $def;
    return (Object.assign)({}, $0, ({
      body: $doneExpression.resolved,
    }));
  });
  const $newModule = ((() => {
    const $0 = $module;
    return (Object.assign)({}, $0, ({
      valueDefs: ($core$Dict$map)($do, $0.valueDefs),
    }));
  }))();
  const $errors = ((__re__ = (array_toList)($state.errors)), ($state.errors = (__re__)[1]), (__re__)[0]);
  (sp_benchStop)("uniqueness check");
  return ((sp_equal)($errors, $core$Core$Nil)
    ? ($core$Result$Ok)($newModule)
    : ($core$Result$Err)(($sd0$Compiler$Error$Nested)($errors)));
});

const $sd0$Prelude$compare = ({
  nonFn: ($core$Core$Cons)("a", $core$Core$Nil),
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)(($sd0$Prelude$tyVar)("a"), ($core$Core$Cons)(($sd0$Prelude$tyVar)("a"), $core$Core$Nil)), $sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$coreUsr)("compare"),
});

const $sd0$Prelude$debugUsr = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, "Debug"), $1);
});

const $sd0$Prelude$debugBenchStart = ({
  nonFn: $core$Core$Nil,
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)($sd0$Compiler$CoreTypes$none, $core$Core$Nil), $sd0$Compiler$CoreTypes$none),
  usr: ($sd0$Prelude$debugUsr)("benchStart"),
});

const $sd0$Prelude$debugBenchStop = ({
  nonFn: $core$Core$Nil,
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)($sd0$Compiler$CoreTypes$text, $core$Core$Nil), $sd0$Compiler$CoreTypes$none),
  usr: ($sd0$Prelude$debugUsr)("benchStop"),
});

const $sd0$Prelude$debugLog = ({
  nonFn: $core$Core$Nil,
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)($sd0$Compiler$CoreTypes$text, ($core$Core$Cons)(($sd0$Prelude$tyVar)("a"), $core$Core$Nil)), ($sd0$Prelude$tyVar)("a")),
  usr: ($sd0$Prelude$debugUsr)("log"),
});

const $sd0$Prelude$debugToHuman = ({
  nonFn: $core$Core$Nil,
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)(($sd0$Prelude$tyVar)("a"), $core$Core$Nil), $sd0$Compiler$CoreTypes$text),
  usr: ($sd0$Prelude$debugUsr)("toHuman"),
});

const $sd0$Prelude$debugTodo = ({
  nonFn: $core$Core$Nil,
  type: ($sd0$Types$CanonicalAst$TypeFn)($sd0$Types$Pos$N, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParSp)(({
    raw: $sd0$Compiler$CoreTypes$text,
    uni: $sd0$Types$Ast$Imm,
  })), $core$Core$Nil), ({
    raw: ($sd0$Types$CanonicalAst$TypeAnnotationVariable)($sd0$Types$Pos$N, "a"),
    uni: $sd0$Types$Ast$Uni,
  })),
  usr: ($sd0$Prelude$debugUsr)("todo"),
});

const $sd0$Prelude$functions = ($core$Core$Cons)($sd0$Prelude$compare, ($core$Core$Cons)($sd0$Prelude$debugTodo, ($core$Core$Cons)($sd0$Prelude$debugLog, ($core$Core$Cons)($sd0$Prelude$debugToHuman, ($core$Core$Cons)($sd0$Prelude$debugBenchStart, ($core$Core$Cons)($sd0$Prelude$debugBenchStop, $core$Core$Nil))))));

const $sd0$Prelude$insertInModule = (($usr, $type, $nonFn, $mo) => {
  const $$name = $usr;
  const $name = ($$name)[2];
  const $umr = ($$name)[1];
  return ((sp_equal)($name, "")
    ? $mo
    : ((() => {
      const $zzz = (($tyvarName, $pos) => {
        return ({
          allowFunctions: ($core$Basics$not)(($core$List$member)($tyvarName, $nonFn)),
        });
      });
      const $tyvars = ((($1) => {
        return ($core$Dict$map)($zzz, $1);
      }))(($sd0$Types$CanonicalAst$typeTyvars)($type));
      const $def = ({
        body: ($sd0$Types$CanonicalAst$LiteralText)($sd0$Types$Pos$N, $name),
        directConsDeps: $core$Dict$empty,
        directTypeDeps: $core$Dict$empty,
        directValueDeps: $core$Dict$empty,
        native: true,
        pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Types$Pos$N, ({
          maybeAnnotation: ($core$Maybe$Just)($type),
          maybeName: ($core$Maybe$Just)($name),
        })),
        tyvars: $tyvars,
        uni: $sd0$Types$Ast$Imm,
        univars: $core$Dict$empty,
      });
      const $update = (($maybeModule) => {
        return ((($module) => {
          return ($core$Maybe$Just)(((() => {
            const $0 = $module;
            return (Object.assign)({}, $0, ({
              valueDefs: ($core$Dict$insert)($def.pattern, $def, $0.valueDefs),
            }));
          }))());
        }))(((($1) => {
          return ($core$Maybe$withDefault)(({
            aliasDefs: $core$Dict$empty,
            asText: "",
            umr: $umr,
            unionDefs: $core$Dict$empty,
            valueDefs: $core$Dict$empty,
          }), $1);
        }))($maybeModule));
      });
      return ($core$Dict$update)($umr, $update, $mo);
    }))());
});

const $sd0$Prelude$insertBinop = (($binop, $m) => {
  return ($sd0$Prelude$insertInModule)($binop.usr, $binop.type, $binop.nonFn, $m);
});

const $sd0$Prelude$insertFunction = (($function, $m) => {
  return ($sd0$Prelude$insertInModule)($function.usr, $function.type, $function.nonFn, $m);
});

const $sd0$Prelude$insertUnop = (($unop, $m) => {
  return ($sd0$Prelude$insertInModule)($unop.usr, $unop.type, $core$Core$Nil, $m);
});

const $sd0$Prelude$unaryPlus = ({
  symbol: "0 +",
  type: ($sd0$Prelude$tyFn)(($core$Core$Cons)($sd0$Compiler$CoreTypes$number, $core$Core$Nil), $sd0$Compiler$CoreTypes$number),
  usr: ($sd0$Prelude$numberUsr)("unaryPlus"),
});

const $sd0$Prelude$coreModulesByUmr = ((($0) => {
  return ($core$List$for)($0, $sd0$Prelude$functions, $sd0$Prelude$insertFunction);
}))(((($0) => {
  return ($core$List$for)($0, $sd0$Prelude$binops, $sd0$Prelude$insertBinop);
}))(((($1) => {
  return ($sd0$Prelude$insertUnop)($sd0$Prelude$unaryMinus, $1);
}))(((($1) => {
  return ($sd0$Prelude$insertUnop)($sd0$Prelude$unaryPlus, $1);
}))($core$Dict$empty))));

const $sd0$Compile$compileMain = (($pars) => {
  const $entryModulePath = (path_resolve)(($core$Core$Cons)($pars.entryModulePath, $core$Core$Nil));
  const $entryModuleDir = (path_dirname)($entryModulePath);
  return (($posix$IO$onSuccess)((($maybeProjectRoot) => {
    const $projectRoot = ($core$Maybe$withDefault)($entryModuleDir, $maybeProjectRoot);
    return (($posix$IO$onSuccess)((($meta) => {
      const $maybeEntryUmr = ((($1) => {
        return ($core$List$find)((($umr) => {
          return (sp_equal)(($sd0$Compile$umrToFileName)("", $umr), $entryModulePath);
        }), $1);
      }))(($core$Dict$values)($meta.moduleVisibleAsToUmr));
      const $entryUsr = ((($maybeEntryUmr)[0] === "Nothing")
        ? (sp_todo)(("Error: you are asking me to compile module " + ($entryModulePath + " but I can't find it anywhere.")))
        : ((($maybeEntryUmr)[0] === "Just")
          ? ((() => {
            const $umr = ($maybeEntryUmr)[1];
            return ($sd0$Types$Meta$USR)($umr, "main");
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 355:8', (sp_toHuman)($maybeEntryUmr))));
      return (($posix$IO$onSuccess)((($maybeCorelibParent) => {
        const $corePath = ((($maybeCorelibParent)[0] === "Nothing")
          ? (sp_todo)(("Error: I expect to find the " + ($sd0$Compile$libDirectoryName + (" directory next to the spcc executable " + ($pars.selfPath + " but I can't find it.")))))
          : ((($maybeCorelibParent)[0] === "Just")
            ? ((() => {
              const $p = ($maybeCorelibParent)[1];
              return (path_resolve)(($core$Core$Cons)($p, ($core$Core$Cons)($sd0$Compile$libDirectoryName, $core$Core$Nil)));
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 373:8', (sp_toHuman)($maybeCorelibParent))));
        const $outputFile = ($core$Maybe$withDefault)($pars.platform.defaultOutputPath, $pars.maybeOutputPath);
        (sp_log)("Loading modules...", "");
        const $loadAllModules = (io_parallel)(((($1) => {
          return ($core$List$map)((($umr) => {
            return ($sd0$Compile$loadModule)($meta, $umr, ($sd0$Compile$umrToFileName)($corePath, $umr));
          }), $1);
        }))(($core$Dict$values)($meta.moduleVisibleAsToUmr)));
        return (($posix$IO$onSuccess)((($userModules) => {
          const $modules = ((($0) => {
            return ($core$List$for)($0, $userModules, (($module, $d) => {
              const $zzz = (($maybeCore) => {
                return ((($maybeCore)[0] === "Nothing")
                  ? ($core$Maybe$Just)($module)
                  : ((($maybeCore)[0] === "Just")
                    ? ((() => {
                      const $core = ($maybeCore)[1];
                      return ($core$Maybe$Just)(($sd0$Compile$mergeWithCore)($core, $module));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compile.sp 400:16', (sp_toHuman)($maybeCore))));
              });
              return ($core$Dict$update)($module.umr, $zzz, $d);
            }));
          }))($sd0$Prelude$coreModulesByUmr);
          const $eenv = ((() => {
            const $getName = (($n) => {
              const $$name = $n.umr;
              const $name = ($$name)[2];
              const $source = ($$name)[1];
              return $name;
            });
            return ({
              moduleByName: ($core$List$for)($core$Dict$empty, ($core$Dict$values)($modules), (($m, $d) => {
                return ($core$Dict$insert)(($getName)($m), ({
                  content: $m.asText,
                  fsPath: ($sd0$Compile$umrToFileName)($corePath, $m.umr),
                }), $d);
              })),
            });
          }))();
          (sp_log)("Solving globals...", "");
          return (($sd0$Compile$onResSuccess)($eenv, (($$luv) => {
            const $luv = $$luv.first;
            const $typeCheckGlobalEnv = $$luv.second;
            (sp_log)("Type checking...", "");
            let $lastUnificationVarId = (basics_cloneImm)($luv);
            return (($posix$IO$onSuccess)((($typedModules) => {
              (sp_log)("Uniqueness check...", "");
              return (($posix$IO$onSuccess)((($modulesWithDestruction) => {
                (sp_log)("Emittable AST...", "");
                return (($sd0$Compile$onResSuccess)($eenv, (($$emittableStatements) => {
                  const $meState = $$emittableStatements.first;
                  const $emittableStatements = $$emittableStatements.second;
                  let $emittableState = (basics_cloneImm)($meState);
                  (sp_log)("= Platform specific stuff =", "");
                  const $js = ((__re__ = ($pars.platform.compile)(({
                    constructors: ($core$Dict$toList)(($core$Dict$map)((($k, $v) => {
                      return $v.type;
                    }), $typeCheckGlobalEnv.constructors)),
                    errorEnv: $eenv,
                  }), $entryUsr, $emittableState, $emittableStatements)), ($emittableState = (__re__)[1]), (__re__)[0]);
                  return (($posix$IO$onSuccess)(((_0) => {
                    return ((($0) => {
                      return (io_writeStdout)($0);
                    }))(("---> " + ($outputFile + " written. =)")));
                  })))((io_writeFile)($outputFile, $js));
                })))(((($1) => {
                  return ($core$Result$mapError)((($e) => {
                    return (sp_todo)("MakeEmittable.translateAll returned Err");
                  }), $1);
                }))(($sd0$Compiler$MakeEmittable$translateAll)($modulesWithDestruction)));
              })))((io_parallel)(((($1) => {
                return ($core$List$map)((($m) => {
                  return ((($1) => {
                    return ($sd0$Compile$resToIo)($eenv, $1);
                  }))(($sd0$Compiler$UniquenessCheck$doModule)($m));
                }), $1);
              }))($typedModules)));
            })))((io_parallel)(((($1) => {
              return ($core$List$map)((($m) => {
                return ((($1) => {
                  return ($sd0$Compile$resToIo)($eenv, $1);
                }))(((__re__ = ($sd0$Compiler$TypeCheck$doModule)($lastUnificationVarId, $typeCheckGlobalEnv, $m)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]));
              }), $1);
            }))(($core$Dict$values)($modules))));
          })))(($sd0$Compiler$TypeCheck$initStateAndGlobalEnv)(($core$Dict$values)($modules)));
        })))($loadAllModules);
      })))(((($1) => {
        return ($sd0$Compile$searchAncestorDirectories)((($$fileName) => {
          const $isDirectory = $$fileName.first;
          const $fileName = $$fileName.second;
          return ($isDirectory && (sp_equal)($fileName, $sd0$Compile$libDirectoryName));
        }), $1);
      }))((path_dirname)((path_resolve)(($core$Core$Cons)($pars.selfPath, $core$Core$Nil)))));
    })))(($sd0$Compile$loadMeta)($pars.env, $pars.platform, $entryModuleDir, $projectRoot));
  })))(((($1) => {
    return ($sd0$Compile$searchAncestorDirectories)((($$fileName) => {
      const $isDirectory = $$fileName.first;
      const $fileName = $$fileName.second;
      return (($core$Basics$not)($isDirectory) && (sp_equal)($fileName, $sd0$Compile$modulesFileName));
    }), $1);
  }))($entryModuleDir));
});

const $sd0$Compile$coreDirName = "core";

const $sd0$Compile$sdItemToUMR = (($source, $fileName) => {
  return ((($1) => {
    return ($sd0$Types$Meta$UMR)($source, $1);
  }))(((($2) => {
    return ($core$Text$replace)(".sp", "", $2);
  }))($fileName));
});

const $sd0$Compiler$CoreTypes$false = ($sd0$Compiler$CoreTypes$makeUsr)("False");

const $sd0$Compiler$CoreTypes$true = ($sd0$Compiler$CoreTypes$makeUsr)("True");

const $sd0$Compiler$CoreTypes$usrToVariable = (($u) => {
  return ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$CoreTypes$p, ($sd0$Types$Ast$RefGlobal)($u));
});

const $sd0$Compiler$Error$emph = (($1) => {
  return ($sd0$Compiler$Error$formatWrap)("emphasys", $1);
});

const $sd0$Compiler$Lexer$addOneIndentToken = (($kind, $state) => {
  const $pos = ((__re__ = ($sd0$Compiler$Lexer$getPos)($state)), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ((__re__ = (array_push)($state.tokens, ($sd0$Types$Token$Token)($sd0$Types$Token$N, $pos, $pos, $kind))), ($state.tokens = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$Lexer_Test$tests = ($sd0$Test$Group)("Lexer", $core$Core$Nil);

const $sd0$Test$codeTest = (($toText, $title, $code, $functionToTest, $ce) => {
  const $$toMaybeError = $ce;
  const $toMaybeError = ($$toMaybeError)[1];
  return ($sd0$Test$Single)($title, $code, ((_0) => {
    return ($sd0$Test$maybeToOutcome)(((($1) => {
      return ($toMaybeError)($toText, $1);
    }))(($functionToTest)($code)));
  }));
});

const $sd0$Compiler$MakeCanonical_Test$codeTest = (($1, $2, $3, $4) => {
  return ($sd0$Test$codeTest)(sp_toHuman, $1, $2, $3, $4);
});

const $sd0$Compiler$TestHelpers$formattedToStrippedText = (($formatted) => {
  const $strip = (($fmt) => {
    return ((($fmt)[0] === "FormattedText_Default")
      ? ((() => {
        const $t = ($fmt)[1];
        return $t;
      }))()
      : ((($fmt)[0] === "FormattedText_Emphasys")
        ? ((() => {
          const $t = ($fmt)[1];
          return $t;
        }))()
        : ((($fmt)[0] === "FormattedText_Warning")
          ? ((() => {
            const $t = ($fmt)[1];
            return $t;
          }))()
          : ((($fmt)[0] === "FormattedText_Decoration")
            ? ((() => {
              const $t = ($fmt)[1];
              return $t;
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TestHelpers.sp 35:8', (sp_toHuman)($fmt))))));
  });
  return ((($1) => {
    return ($core$Text$join)("", $1);
  }))(((($1) => {
    return ($core$List$map)($strip, $1);
  }))($formatted));
});

const $sd0$DefaultModules$asText = "library =\n    source = \"core:prelude\"\n\n    module =\n        path = Core\n        importAs = Core\n        globalTypes =\n            None\n            Bool\n            Text\n            Number\n        globalValues =\n            None\n            True\n            False\n            mut\n\n    module =\n        path = List\n        importAs = List\n\n    module =\n        path = Maybe\n        importAs = Maybe\n        globalTypes =\n            Maybe\n        globalValues =\n           Just\n           Nothing\n\n    module =\n        path = Text\n        importAs = Text\n\n    module =\n        path = Tuple\n        importAs = Tuple\n\n    module =\n        path = Debug\n        importAs = Debug\n        globalValues =\n            log\n            todo\n\n    module =\n        path = Basics\n        globalTypes =\n            Int\n        globalValues =\n            assert\n            clamp\n            identity\n            modBy\n            min\n            max\n\n    module =\n        path = Dict\n        importAs = Dict\n        globalTypes = Dict\n\n    module =\n        path = Set\n        importAs = Set\n        globalTypes = Set\n\n    module =\n        path = Result\n        importAs = Result\n        globalTypes = Result\n        globalValues =\n            Ok\n            Err";

const $sd0$ModulesFile$textToMeta = (($sponName, $sponContent) => {
  return ((($1) => {
    return ($core$Result$map)($sd0$ModulesFile$toMeta, $1);
  }))(((($1) => {
    return ($sd0$ModulesFile$textToModulesFile)($sponName, $1);
  }))($sponContent));
});

const $sd0$Compiler$TestHelpers$meta = ((() => {
  const $eenv = ({
    moduleByName: ($core$Dict$ofOne)("DefaultModules", ({
      content: $sd0$DefaultModules$asText,
      fsPath: "<DefaultModules>",
    })),
  });
  const $metaResult = ((($1) => {
    return ($core$Result$mapError)((($e) => {
      return ($sd0$Compiler$TestHelpers$formattedToStrippedText)(((($1) => {
        return ($sd0$Compiler$Error$toFormattedText)($eenv, $1);
      }))($e));
    }), $1);
  }))(((($1) => {
    return ($sd0$ModulesFile$textToMeta)("DefaultModules", $1);
  }))($sd0$DefaultModules$asText));
  return ((($metaResult)[0] === "Err")
    ? ((() => {
      const $e = ($metaResult)[1];
      (sp_log)(("Error in DefaultModules.sp: " + $e), null);
      return (sp_todo)("error loading DefaultModules.sp");
    }))()
    : ((($metaResult)[0] === "Ok")
      ? ((() => {
        const $m = ($metaResult)[1];
        return $m;
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TestHelpers.sp 86:4', (sp_toHuman)($metaResult))));
}))();

const $sd0$Compiler$TestHelpers$moduleName = "(test)";

const $sd0$Compiler$TestHelpers$source = ($sd0$Types$Meta$SourceDir)("<Test>");

const $sd0$Compiler$MakeCanonical_Test$params = ({
  meta: $sd0$Compiler$TestHelpers$meta,
  name: $sd0$Compiler$TestHelpers$moduleName,
  source: $sd0$Compiler$TestHelpers$source,
  stripLocations: true,
});

const $sd0$Compiler$TestHelpers$dummyErrorEnv = (($code) => {
  return ({
    moduleByName: ($core$Dict$ofOne)($sd0$Compiler$TestHelpers$moduleName, ({
      content: $code,
      fsPath: "<TestPath>",
    })),
  });
});

const $sd0$Compiler$TestHelpers$resErrorToStrippedText = (($code, $res) => {
  const $errorToText = (($e) => {
    return ($sd0$Compiler$TestHelpers$formattedToStrippedText)(((($1) => {
      return ($sd0$Compiler$Error$toFormattedText)(($sd0$Compiler$TestHelpers$dummyErrorEnv)($code), $1);
    }))($e));
  });
  return ($core$Result$mapError)($errorToText, $res);
});

const $sd0$Compiler$MakeCanonical_Test$textToModule = (($code) => {
  return ((($1) => {
    return ($sd0$Compiler$TestHelpers$resErrorToStrippedText)($code, $1);
  }))(((($1) => {
    return ($sd0$Compiler$MakeCanonical$textToCanonicalModule)($sd0$Compiler$MakeCanonical_Test$params, $1);
  }))($code));
});

const $sd0$Compiler$MakeCanonical_Test$firstDefinition = (($code) => {
  return (($core$Result$onOk)((($mod) => {
    return ((($1) => {
      return ($core$Result$fromMaybe)("firstDefinition fail", $1);
    }))(($core$List$head)(($core$Dict$values)($mod.valueDefs)));
  })))(($sd0$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sd0$Compiler$MakeCanonical_Test$firstEvaluation = (($name) => {
  return (($code) => {
    return (($core$Result$onOk)((($def) => {
      return ($core$Result$Ok)($def.body);
    })))(($sd0$Compiler$MakeCanonical_Test$firstDefinition)($code));
  });
});

const $sd0$Test$isOk = ($sd0$Test$CodeExpectation)((($toText, $result) => {
  return ((($result)[0] === "Err")
    ? ((() => {
      const $e = ($result)[1];
      return ($core$Maybe$Just)($e);
    }))()
    : ((($result)[0] === "Ok")
      ? ((() => {
        const $actualOk = ($result)[1];
        return $core$Maybe$Nothing;
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 70:8', (sp_toHuman)($result))));
}));

const $sd0$Compiler$MakeCanonical_Test$annotations = ($sd0$Test$Group)("Annotations", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("annotation on unique value", "x =\n  !a as Number =\n    3\n  a", $sd0$Compiler$MakeCanonical_Test$firstDefinition, $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("annotation on immutable value", "b as Number =\n  3", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("b"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("annotation of recycling function", "b as fn @Result e a: !Result e a =\n  3", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("b"), $sd0$Test$isOk), $core$Core$Nil))));

const $sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps = (($code) => {
  return ((($1) => {
    return ($core$Result$map)((($v) => {
      const $0 = $v;
      return (Object.assign)({}, $0, ({
        directConsDeps: $core$Dict$empty,
        directTypeDeps: $core$Dict$empty,
        directValueDeps: $core$Dict$empty,
      }));
    }), $1);
  }))(($sd0$Compiler$MakeCanonical_Test$firstDefinition)($code));
});

const $sd0$Compiler$MakeCanonical_Test$p = $sd0$Types$Pos$T;

const $sd0$Compiler$MakeCanonical_Test$argumentPlaceholders = ($sd0$Test$Group)("Argument placeholders", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("Base", "f = f __ __", $sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps, ($sd0$Test$isOkAndEqualTo)(({
  body: ($sd0$Types$CanonicalAst$Fn)($sd0$Compiler$MakeCanonical_Test$p, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParameterPlaceholder)("0", 0), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParameterPlaceholder)("1", 1), $core$Core$Nil)), ($sd0$Types$CanonicalAst$Call)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$Ast$RefGlobal)(($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)(($sd0$Types$Meta$SourceDir)("<Test>"), "(test)"), "f"))), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$Ast$RefLocal)("0"))), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$Ast$RefLocal)("1"))), $core$Core$Nil)))),
  directConsDeps: $core$Dict$empty,
  directTypeDeps: $core$Dict$empty,
  directValueDeps: $core$Dict$empty,
  native: false,
  pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
    maybeAnnotation: $core$Maybe$Nothing,
    maybeName: ($core$Maybe$Just)("f"),
  })),
  tyvars: $core$Dict$empty,
  uni: $sd0$Types$Ast$Imm,
  univars: $core$Dict$empty,
}))), $core$Core$Nil));

const $sd0$Test$freeform = (($test) => {
  return ($sd0$Test$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "Err")
      ? ((() => {
        const $e = ($result)[1];
        return ($core$Maybe$Just)($e);
      }))()
      : ((($result)[0] === "Ok")
        ? ((() => {
          const $actualOk = ($result)[1];
          return ($test)($actualOk);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 63:4', (sp_toHuman)($result))));
  }));
});

const $sd0$Compiler$MakeCanonical_Test$shouldHaveSameAB = (($getter) => {
  return ($sd0$Test$freeform)((($$a) => {
    const $a = $$a.first;
    const $b = $$a.second;
    return ((sp_equal)(($getter)($a), ($getter)($b))
      ? $core$Maybe$Nothing
      : ($core$Maybe$Just)(((($1) => {
        return ($core$Text$join)("\n", $1);
      }))(($core$Core$Cons)("The two don't match:", ($core$Core$Cons)((sp_toHuman)(($getter)($a)), ($core$Core$Cons)((sp_toHuman)(($getter)($b)), $core$Core$Nil))))));
  }));
});

const $sd0$Compiler$MakeCanonical_Test$transformAB = (($code) => {
  const $findAB = (($mod) => {
    const $$try1 = ((($1) => {
      return (list_sortBy)((($def) => {
        return $def.pattern;
      }), $1);
    }))(($core$Dict$values)($mod.valueDefs));
    return (((($$try1)[0] === "Cons") && (((($$try1)[2])[0] === "Cons") && (((($$try1)[2])[2])[0] === "Nil")))
      ? ((() => {
        const $a = ($$try1)[1];
        const $b = (($$try1)[2])[1];
        return ($core$Maybe$Just)(({
          first: $a,
          second: $b,
        }));
      }))()
      : (true
        ? $core$Maybe$Nothing
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/MakeCanonical_Test.sp 79:8', (sp_toHuman)($$try1))));
  });
  return (($core$Result$onOk)((($x) => {
    return ((($1) => {
      return ($core$Result$fromMaybe)("findAB fail", $1);
    }))(($findAB)($x));
  })))(($sd0$Compiler$MakeCanonical_Test$textToModule)($code));
});

const $sd0$Compiler$MakeCanonical_Test$binops = ($sd0$Test$Group)("Binops", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("left associativity", "a = v >> f >> g\nb = (v >> f) >> g", $sd0$Compiler$MakeCanonical_Test$transformAB, ($sd0$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
}))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("right associativity", "a = v :: f :: g\nb = v :: (f :: g)", $sd0$Compiler$MakeCanonical_Test$transformAB, ($sd0$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
}))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("precedence", "a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4", $sd0$Compiler$MakeCanonical_Test$transformAB, ($sd0$Compiler$MakeCanonical_Test$shouldHaveSameAB)((($x) => {
  return $x.body;
}))), $core$Core$Nil))));

const $sd0$Compiler$TestHelpers$moduleUmr = ($sd0$Types$Meta$UMR)($sd0$Compiler$TestHelpers$source, $sd0$Compiler$TestHelpers$moduleName);

const $sd0$Compiler$TestHelpers$rootLocal = (($name) => {
  return ($sd0$Types$Ast$RefGlobal)(($sd0$Types$Meta$USR)($sd0$Compiler$TestHelpers$moduleUmr, $name));
});

const $sd0$Compiler$MakeCanonical_Test$functions = ($sd0$Test$Group)("Functions", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("[rec] function with call", "a =\n    fn x:\n        add x 1", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("f"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$Fn)($sd0$Compiler$MakeCanonical_Test$p, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParameterPattern)($sd0$Types$Ast$Imm, ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
  maybeAnnotation: $core$Maybe$Nothing,
  maybeName: ($core$Maybe$Just)("x"),
}))), $core$Core$Nil), ($sd0$Types$CanonicalAst$Call)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("add")), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$Ast$RefLocal)("x"))), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 1)), $core$Core$Nil)))))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("[rec] function with two arguments", "f =\n  fn a, b: 1", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("f"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$Fn)($sd0$Compiler$MakeCanonical_Test$p, ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParameterPattern)($sd0$Types$Ast$Imm, ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
  maybeAnnotation: $core$Maybe$Nothing,
  maybeName: ($core$Maybe$Just)("a"),
}))), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ParameterPattern)($sd0$Types$Ast$Imm, ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
  maybeAnnotation: $core$Maybe$Nothing,
  maybeName: ($core$Maybe$Just)("b"),
}))), $core$Core$Nil)), ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 1)))), $core$Core$Nil)));

const $sd0$Types$Meta$spCorePath = "Core";

const $sd0$Types$Meta$spCoreUmr = ($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, $sd0$Types$Meta$spCorePath);

const $sd0$Types$Meta$spCoreUSR = (($1) => {
  return ($sd0$Types$Meta$USR)($sd0$Types$Meta$spCoreUmr, $1);
});

const $sd0$Compiler$TestHelpers$caBool = ($sd0$Types$CanonicalAst$TypeNamed)($sd0$Types$Pos$T, ($sd0$Types$Meta$spCoreUSR)("Bool"), $core$Core$Nil);

const $sd0$Compiler$MakeCanonical_Test$lists = ($sd0$Test$Group)("Lists", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("list type sugar", "l as [ Bool ] =\n  l", $sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps, ($sd0$Test$isOkAndEqualTo)(({
  body: ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("l")),
  directConsDeps: $core$Dict$empty,
  directTypeDeps: $core$Dict$empty,
  directValueDeps: $core$Dict$empty,
  native: false,
  pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
    maybeAnnotation: ($core$Maybe$Just)(($sd0$Compiler$CoreTypes$list)($sd0$Compiler$TestHelpers$caBool)),
    maybeName: ($core$Maybe$Just)("l"),
  })),
  tyvars: $core$Dict$empty,
  uni: $sd0$Types$Ast$Imm,
  univars: $core$Dict$empty,
}))), $core$Core$Nil));

const $sd0$Test$errorContains = (($snippets) => {
  return ($sd0$Test$CodeExpectation)((($toText, $result) => {
    return ((($result)[0] === "Ok")
      ? ((() => {
        const $ok = ($result)[1];
        return ($core$Maybe$Just)(("I was expecting an error, but got: Ok " + ($toText)($ok)));
      }))()
      : ((($result)[0] === "Err")
        ? ((() => {
          const $e = ($result)[1];
          const $missing = ((($1) => {
            return ($core$List$filter)((($sn) => {
              return ($core$Basics$not)(($core$Text$contains)($sn, $e));
            }), $1);
          }))($snippets);
          return ((sp_equal)($missing, $core$Core$Nil)
            ? $core$Maybe$Nothing
            : ((() => {
              const $indentedError = ((($1) => {
                return ($core$Text$join)("\n", $1);
              }))(((($1) => {
                return ($core$List$map)((($l) => {
                  return ("    " + $l);
                }), $1);
              }))(((($1) => {
                return (text_split)("\n", $1);
              }))($e)));
              return ($core$Maybe$Just)(("Error message:\n\n" + ($indentedError + ("\n\nis missing snippets: " + ($core$Text$join)(", ", $missing)))));
            }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 103:6', (sp_toHuman)($result))));
  }));
});

const $sd0$Compiler$MakeCanonical_Test$moduleAndAttributePaths = ((() => {
  const $accept = (($s) => {
    return ($sd0$Compiler$MakeCanonical_Test$codeTest)($s, ("a = " + $s), $sd0$Compiler$MakeCanonical_Test$firstDefinition, $sd0$Test$isOk);
  });
  const $reject = (($s, $m) => {
    return ($sd0$Compiler$MakeCanonical_Test$codeTest)($s, ("a = " + $s), $sd0$Compiler$MakeCanonical_Test$firstDefinition, ($sd0$Test$errorContains)(($core$Core$Cons)($m, $core$Core$Nil)));
  });
  return ($sd0$Test$Group)("Module and Attribute Paths", ($core$Core$Cons)(($accept)("blah.blah.blah"), ($core$Core$Cons)(($reject)("Blah.Blah.blah", "constructor"), ($core$Core$Cons)(($reject)("blah.Blah.blah", "case"), ($core$Core$Cons)(($reject)("List.blah.Blah", "lower"), ($core$Core$Cons)(($reject)("List..blah", "space"), ($core$Core$Cons)(($reject)(".Blah", "upper"), ($core$Core$Cons)(($reject)(".blah.blah", "shorthand"), ($core$Core$Cons)(($reject)(".blah", "shorthand"), ($core$Core$Cons)(($reject)("...", ""), ($core$Core$Cons)(($accept)("x .. y"), $core$Core$Nil)))))))))));
}))();

const $sd0$Compiler$MakeCanonical_Test$nonFunction = ($sd0$Test$Group)("NonFunction", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("one", "funz as a with a NonFunction =\n    1", $sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps, ($sd0$Test$isOkAndEqualTo)(({
  body: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 1),
  directConsDeps: $core$Dict$empty,
  directTypeDeps: $core$Dict$empty,
  directValueDeps: $core$Dict$empty,
  native: false,
  pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
    maybeAnnotation: ($core$Maybe$Just)(($sd0$Types$CanonicalAst$TypeAnnotationVariable)($sd0$Compiler$MakeCanonical_Test$p, "a")),
    maybeName: ($core$Maybe$Just)("funz"),
  })),
  tyvars: ($core$Dict$ofOne)("a", ({
    allowFunctions: false,
  })),
  uni: $sd0$Types$Ast$Imm,
  univars: $core$Dict$empty,
}))), $core$Core$Nil));

const $sd0$Compiler$MakeCanonical_Test$patterns = ($sd0$Test$Group)("Patterns", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("Record patterns can be partial", "a =\n  { with c } = d", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("[reg] record patterns are NOT extensible", "a =\n  { b with c } = d", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$errorContains)(($core$Core$Cons)("extend pattern", $core$Core$Nil))), $core$Core$Nil)));

const $sd0$Compiler$MakeCanonical_Test$pipes = ($sd0$Test$Group)("Pipes", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("sendLeft is inlined", "a = thing >> function", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$Call)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("function")), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("thing"))), $core$Core$Nil)))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("sendRight is inlined", "a = function << thing", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$Call)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("function")), ($core$Core$Cons)(($sd0$Types$CanonicalAst$ArgumentExpression)(($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("thing"))), $core$Core$Nil)))), $core$Core$Nil)));

const $sd0$Compiler$MakeCanonical_Test$polymorphicUniques = ($sd0$Test$Group)("Polymorphic Uniques", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("In pattern", "scope =\n    1?f as a = meh", $sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps, ($sd0$Test$isOkAndEqualTo)(({
  body: ($sd0$Types$CanonicalAst$LetIn)(({
    body: ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("meh")),
    directConsDeps: $core$Dict$empty,
    directTypeDeps: $core$Dict$empty,
    directValueDeps: $core$Dict$empty,
    native: false,
    pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
      maybeAnnotation: ($core$Maybe$Just)(($sd0$Types$CanonicalAst$TypeAnnotationVariable)($sd0$Compiler$MakeCanonical_Test$p, "a")),
      maybeName: ($core$Maybe$Just)("f"),
    })),
    tyvars: ($core$Dict$ofOne)("a", ({
      allowFunctions: true,
    })),
    uni: ($sd0$Types$Ast$Depends)(1),
    univars: ($core$Dict$ofOne)(1, null),
  }), ($sd0$Types$CanonicalAst$Constructor)($sd0$Types$Pos$G, $sd0$Compiler$CoreTypes$noneValue)),
  directConsDeps: $core$Dict$empty,
  directTypeDeps: $core$Dict$empty,
  directValueDeps: $core$Dict$empty,
  native: false,
  pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
    maybeAnnotation: $core$Maybe$Nothing,
    maybeName: ($core$Maybe$Just)("scope"),
  })),
  tyvars: $core$Dict$empty,
  uni: $sd0$Types$Ast$Imm,
  univars: $core$Dict$empty,
}))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("In annotation", "isOk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = meh", (($t) => {
  return ((($1) => {
    return ($core$Result$map)((($x) => {
      return $x.univars;
    }), $1);
  }))(($sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps)($t));
}), ($sd0$Test$isOkAndEqualTo)(($core$Dict$fromList)(($core$Core$Cons)(({
  first: 1,
  second: null,
}), ($core$Core$Cons)(({
  first: 2,
  second: null,
}), $core$Core$Nil))))), $core$Core$Nil)));

const $sd0$Compiler$MakeCanonical_Test$valueDef = (($name, $body) => {
  return ({
    body: $body,
    directConsDeps: $core$Dict$empty,
    directTypeDeps: $core$Dict$empty,
    directValueDeps: $core$Dict$empty,
    native: false,
    pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Types$Pos$G, ({
      maybeAnnotation: $core$Maybe$Nothing,
      maybeName: ($core$Maybe$Just)($name),
    })),
    tyvars: $core$Dict$empty,
    uni: $sd0$Types$Ast$Imm,
    univars: $core$Dict$empty,
  });
});

const $sd0$Compiler$MakeCanonical_Test$records = ($sd0$Test$Group)("Records", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("functional update", "a = { m with b, c = 1 }", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$LetIn)(($sd0$Compiler$MakeCanonical_Test$valueDef)("0", ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("m"))), ($sd0$Types$CanonicalAst$Record)($sd0$Compiler$MakeCanonical_Test$p, ($core$Maybe$Just)(($sd0$Types$CanonicalAst$Variable)($sd0$Types$Pos$G, ($sd0$Types$Ast$RefLocal)("0"))), ($core$Dict$fromList)(($core$Core$Cons)(({
  first: "c",
  second: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 1),
}), ($core$Core$Cons)(({
  first: "b",
  second: ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("b")),
}), $core$Core$Nil))))))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("update shorthand", "b = { a with y = .x }", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("b"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$LetIn)(($sd0$Compiler$MakeCanonical_Test$valueDef)("0", ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("a"))), ($sd0$Types$CanonicalAst$Record)($sd0$Compiler$MakeCanonical_Test$p, ($core$Maybe$Just)(($sd0$Types$CanonicalAst$Variable)($sd0$Types$Pos$G, ($sd0$Types$Ast$RefLocal)("0"))), ($core$Dict$fromList)(($core$Core$Cons)(({
  first: "y",
  second: ($sd0$Types$CanonicalAst$RecordAccess)($sd0$Compiler$MakeCanonical_Test$p, "x", ($sd0$Types$CanonicalAst$Variable)($sd0$Types$Pos$G, ($sd0$Types$Ast$RefLocal)("0"))),
}), $core$Core$Nil)))))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("annotation, extensible", "a as { b with x as Bool } =\n  a", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$errorContains)(($core$Core$Cons)("disabled", $core$Core$Nil))), $core$Core$Nil))));

const $sd0$Compiler$TestHelpers$caNumber = ($sd0$Types$CanonicalAst$TypeNamed)($sd0$Types$Pos$T, ($sd0$Types$Meta$spCoreUSR)("Number"), $core$Core$Nil);

const $sd0$Compiler$MakeCanonical_Test$tuples = ($sd0$Test$Group)("Tuples", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("tuple2", "a = 1 & 2", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$Record)($sd0$Compiler$MakeCanonical_Test$p, $core$Maybe$Nothing, ($core$Dict$fromList)(($core$Core$Cons)(({
  first: "first",
  second: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 1),
}), ($core$Core$Cons)(({
  first: "second",
  second: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 2),
}), $core$Core$Nil)))))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("tuple3", "a = 1 & 2 & 3", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$isOkAndEqualTo)(($sd0$Types$CanonicalAst$Record)($sd0$Compiler$MakeCanonical_Test$p, $core$Maybe$Nothing, ($core$Dict$fromList)(($core$Core$Cons)(({
  first: "first",
  second: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 1),
}), ($core$Core$Cons)(({
  first: "second",
  second: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 2),
}), ($core$Core$Cons)(({
  first: "third",
  second: ($sd0$Types$CanonicalAst$LiteralNumber)($sd0$Compiler$MakeCanonical_Test$p, 3),
}), $core$Core$Nil))))))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("tuple4", "a = 1 & 2 & 3 & 4", ($sd0$Compiler$MakeCanonical_Test$firstEvaluation)("a"), ($sd0$Test$errorContains)(($core$Core$Cons)("use a record", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("tuple2 type", "a as Number & Number =\n  a", $sd0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps, ($sd0$Test$isOkAndEqualTo)(({
  body: ($sd0$Types$CanonicalAst$Variable)($sd0$Compiler$MakeCanonical_Test$p, ($sd0$Compiler$TestHelpers$rootLocal)("a")),
  directConsDeps: $core$Dict$empty,
  directTypeDeps: $core$Dict$empty,
  directValueDeps: $core$Dict$empty,
  native: false,
  pattern: ($sd0$Types$CanonicalAst$PatternAny)($sd0$Compiler$MakeCanonical_Test$p, ({
    maybeAnnotation: ($core$Maybe$Just)(((($1) => {
      return ($sd0$Types$CanonicalAst$TypeRecord)($sd0$Compiler$MakeCanonical_Test$p, $1);
    }))(((($2) => {
      return ($core$Dict$insert)("second", $sd0$Compiler$TestHelpers$caNumber, $2);
    }))(((($2) => {
      return ($core$Dict$insert)("first", $sd0$Compiler$TestHelpers$caNumber, $2);
    }))($core$Dict$empty)))),
    maybeName: ($core$Maybe$Just)("a"),
  })),
  tyvars: $core$Dict$empty,
  uni: $sd0$Types$Ast$Imm,
  univars: $core$Dict$empty,
}))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("tuple4, type", "a as Blah & Blah & Blah & Blah =\n  a", $sd0$Compiler$MakeCanonical_Test$firstDefinition, ($sd0$Test$errorContains)(($core$Core$Cons)("use a record", $core$Core$Nil))), $core$Core$Nil))))));

const $sd0$Compiler$MakeCanonical_Test$unionTypes = ($sd0$Test$Group)("Union types", ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("tuples op precedence", "union A = X Bool & Bool", $sd0$Compiler$MakeCanonical_Test$textToModule, ($sd0$Test$errorContains)(($core$Core$Cons)("expecting a constructor", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("Tuples op precedence works with parens", "union A = X (Bool & Bool)", $sd0$Compiler$MakeCanonical_Test$textToModule, $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$MakeCanonical_Test$codeTest)("[reg] Should reject uppercase arg name", "union Outcome Token output = A", $sd0$Compiler$MakeCanonical_Test$textToModule, ($sd0$Test$errorContains)(($core$Core$Cons)("must start with a lowercase", $core$Core$Nil))), $core$Core$Nil))));

const $sd0$Compiler$MakeCanonical_Test$tests = ($sd0$Test$Group)("MakeCanonical", ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$unionTypes, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$binops, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$tuples, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$lists, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$moduleAndAttributePaths, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$records, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$patterns, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$annotations, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$pipes, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$functions, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$nonFunction, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$argumentPlaceholders, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$polymorphicUniques, $core$Core$Nil))))))))))))));

const $sd0$Compiler$Parser$surroundMultiline = (($left, $right, $content) => {
  return ($sd0$Compiler$Parser$discardFirst)(($sd0$Compiler$Parser$kind)($left), ($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$discardSecond)($content, ($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$kind)($right)))));
});

const $sd0$Compiler$Parser$typeAnnotation = (($env) => {
  return ($sd0$Compiler$Parser$discardFirst)(($sd0$Compiler$Parser$kind)($sd0$Types$Token$As), ($sd0$Compiler$Parser$inlineOrBelowOrIndented)(($sd0$Compiler$Parser$expr)($env)));
});

const $sd0$Compiler$Parser_Test$codeTest = (($1, $2, $3, $4) => {
  return ($sd0$Test$codeTest)(sp_toHuman, $1, $2, $3, $4);
});

const $sd0$Compiler$Parser_Test$p = $sd0$Types$Pos$T;

const $sd0$Compiler$Parser_Test$tests = ($sd0$Test$Group)("Parser", $core$Core$Nil);

const $sd0$Compiler$Parser_Test$zot = 1;

const $sd0$Compiler$TestHelpers$caList = (($itemType) => {
  return ($sd0$Types$CanonicalAst$TypeNamed)($sd0$Types$Pos$T, ($sd0$Types$Meta$spCoreUSR)("List"), ($core$Core$Cons)($itemType, $core$Core$Nil));
});

const $sd0$Compiler$TestHelpers$caNone = ($sd0$Types$CanonicalAst$TypeNamed)($sd0$Types$Pos$T, ($sd0$Types$Meta$spCoreUSR)("None"), $core$Core$Nil);

const $sd0$Compiler$TestHelpers$localType = (($1) => {
  return ($sd0$Types$Meta$USR)($sd0$Compiler$TestHelpers$moduleUmr, $1);
});

const $sd0$Compiler$TestHelpers$taBool = ($sd0$Types$TypedAst$TypeExact)(($sd0$Types$Meta$spCoreUSR)("Bool"), $core$Core$Nil);

const $sd0$Compiler$TestHelpers$taFunction = (($from, $to) => {
  return ($sd0$Types$TypedAst$TypeFn)(($core$List$map)((($t) => {
    return ($sd0$Types$TypedAst$ParSp)(($sd0$Types$Ast$toImm)($t));
  }), $from), ($sd0$Types$Ast$toImm)($to));
});

const $sd0$Compiler$TestHelpers$taList = (($item) => {
  return ($sd0$Types$TypedAst$TypeExact)(($sd0$Types$Meta$spCoreUSR)("List"), ($core$Core$Cons)($item, $core$Core$Nil));
});

const $sd0$Compiler$TestHelpers$taNone = ($sd0$Types$TypedAst$TypeExact)(($sd0$Types$Meta$spCoreUSR)("None"), $core$Core$Nil);

const $sd0$Compiler$TestHelpers$taNumber = ($sd0$Types$TypedAst$TypeExact)(($sd0$Types$Meta$spCoreUSR)("Number"), $core$Core$Nil);

const $sd0$Compiler$TestHelpers$taTyvar = (($0) => {
  return ($sd0$Types$TypedAst$TypeVar)($0);
});

const $sd0$Compiler$TestHelpers$taTyvarImm = (($0) => {
  return ($sd0$Types$TypedAst$TypeVar)($0);
});

const $sd0$Compiler$TypeCheck_Test$outToHuman = (($out) => {
  return ((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(($core$Core$Cons)(("  tyvars = " + (sp_toHuman)(($core$Dict$toList)($out.freeTyvars))), ($core$Core$Cons)(("  type = " + ($sd0$Human$Type$display)("", ($sd0$Human$Type$doRawType)({}, $out.type))), $core$Core$Nil)));
});

const $sd0$Compiler$TypeCheck_Test$codeTest = (($1, $2, $3, $4) => {
  return ($sd0$Test$codeTest)($sd0$Compiler$TypeCheck_Test$outToHuman, $1, $2, $3, $4);
});

const $sd0$Compiler$TypeCheck_Test$freeTyvarsAnnotated = (($ids) => {
  return ((($0) => {
    return ($core$List$for)($0, $ids, (($$id, $d) => {
      const $id = $$id.first;
      const $originalName = $$id.second;
      return ($core$Dict$insert)($id, ({
        allowFunctions: true,
        generalizedAt: $sd0$Types$Pos$G,
        generalizedFor: ($sd0$Types$Ast$RefLocal)(""),
        originalName: $originalName,
      }), $d);
    }));
  }))($core$Dict$empty);
});

const $sd0$Compiler$TypeCheck_Test$normalizeTyvarId = (($hash, $id) => {
  const $$try1 = ((__re__ = (hash_get)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]);
  return ([
    ((($$try1)[0] === "Just")
      ? ((() => {
        const $nid = ($$try1)[1];
        return $nid;
      }))()
      : ((($$try1)[0] === "Nothing")
        ? ((() => {
          let $maxId = 0;
          ((__re__ = (hash_each)($hash, (($k, $v) => {
            return (($v > ((__re__ = (basics_cloneUni)($maxId)), ($maxId = (__re__)[1]), (__re__)[0]))
              ? ($maxId = (basics_cloneImm)($v))
              : null);
          }))), ($hash = (__re__)[1]), (__re__)[0]);
          const $nid = ($maxId + 1);
          ((__re__ = (hash_insert)($hash, $id, $nid)), ($hash = (__re__)[1]), (__re__)[0]);
          return $nid;
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck_Test.sp 160:4', (sp_toHuman)($$try1)))),
    $hash,
  ]);
});

const $sd0$Compiler$TypeCheck_Test$normalizeType = (($hash, $type) => {
  return ([
    ((($type)[0] === "TypeExact")
      ? ((() => {
        const $usr = ($type)[1];
        const $args = ($type)[2];
        return ($sd0$Types$TypedAst$TypeExact)($usr, ($core$List$map)((($1) => {
          return ((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeType)($hash, $1)), ($hash = (__re__)[1]), (__re__)[0]);
        }), $args));
      }))()
      : ((($type)[0] === "TypeFn")
        ? ((() => {
          const $pars = ($type)[1];
          const $out = ($type)[2];
          return ($sd0$Types$TypedAst$TypeFn)(($sd0$Types$TypedAst$mapPars)((($1) => {
            return ((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeType)($hash, $1)), ($hash = (__re__)[1]), (__re__)[0]);
          }), $pars), ((() => {
            const $0 = $out;
            return (Object.assign)({}, $0, ({
              raw: ((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeType)($hash, $0.raw)), ($hash = (__re__)[1]), (__re__)[0]),
            }));
          }))());
        }))()
        : (((($type)[0] === "TypeRecord") && ((($type)[1])[0] === "Nothing"))
          ? ((() => {
            const $attrs = ($type)[2];
            return ($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, ($core$Dict$map)((($k, $v) => {
              return ((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeType)($hash, $v)), ($hash = (__re__)[1]), (__re__)[0]);
            }), $attrs));
          }))()
          : (((($type)[0] === "TypeRecord") && ((($type)[1])[0] === "Just"))
            ? ((() => {
              const $id = (($type)[1])[1];
              const $attrs = ($type)[2];
              return ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0])), ($core$Dict$map)((($k, $v) => {
                return ((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeType)($hash, $v)), ($hash = (__re__)[1]), (__re__)[0]);
              }), $attrs));
            }))()
            : ((($type)[0] === "TypeVar")
              ? ((() => {
                const $id = ($type)[1];
                return ($sd0$Types$TypedAst$TypeVar)(((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]));
              }))()
              : ((($type)[0] === "TypeError")
                ? $sd0$Types$TypedAst$TypeError
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck_Test.sp 178:4', (sp_toHuman)($type)))))))),
    $hash,
  ]);
});

const $sd0$Compiler$TypeCheck_Test$normalizeOut = (($out) => {
  let $hash = (hash_fromList)($core$Core$Nil);
  return ({
    freeTyvars: ($core$Dict$for)($core$Dict$empty, $out.freeTyvars, (($id, $tc, $d) => {
      return ($core$Dict$insert)(((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeTyvarId)($hash, $id)), ($hash = (__re__)[1]), (__re__)[0]), $tc, $d);
    })),
    type: ((__re__ = ($sd0$Compiler$TypeCheck_Test$normalizeType)($hash, $out.type)), ($hash = (__re__)[1]), (__re__)[0]),
  });
});

const $sd0$Prelude$coreModules = ($core$Dict$values)($sd0$Prelude$coreModulesByUmr);

const $sd0$Compiler$TypeCheck_Test$infer = (($targetName) => {
  return (($code) => {
    const $params = ({
      meta: $sd0$Compiler$TestHelpers$meta,
      name: $sd0$Compiler$TestHelpers$moduleName,
      source: $sd0$Compiler$TestHelpers$source,
      stripLocations: false,
    });
    return (($core$Result$onOk)((($caModule) => {
      const $modules = ($core$List$append)($sd0$Prelude$coreModules, ($core$Core$Cons)($caModule, $core$Core$Nil));
      return (($core$Result$onOk)((($$luv) => {
        const $luv = $$luv.first;
        const $typeCheckGlobalEnv_ = $$luv.second;
        const $typeCheckGlobalEnv = ((() => {
          const $0 = $typeCheckGlobalEnv_;
          return (Object.assign)({}, $0, ({
            variables: ((($2) => {
              return ($core$Dict$insert)(($sd0$Types$Ast$RefGlobal)(($sd0$Types$Meta$USR)($sd0$Compiler$TestHelpers$moduleUmr, "reset")), ({
                definedAt: $sd0$Types$Pos$T,
                freeTyvars: $core$Dict$empty,
                freeUnivars: $core$Dict$empty,
                type: ($sd0$Types$Ast$toImm)(($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($sd0$Compiler$TestHelpers$taNumber, $core$Core$Nil), $sd0$Compiler$TestHelpers$taNone)),
              }), $2);
            }))(((($2) => {
              return ($core$Dict$insert)(($sd0$Types$Ast$RefGlobal)(($sd0$Types$Meta$USR)($sd0$Compiler$TestHelpers$moduleUmr, "add")), ({
                definedAt: $sd0$Types$Pos$T,
                freeTyvars: $core$Dict$empty,
                freeUnivars: $core$Dict$empty,
                type: ($sd0$Types$Ast$toImm)(($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($sd0$Compiler$TestHelpers$taNumber, ($core$Core$Cons)($sd0$Compiler$TestHelpers$taNumber, $core$Core$Nil)), $sd0$Compiler$TestHelpers$taNumber)),
              }), $2);
            }))($0.variables)),
          }));
        }))();
        let $lastUnificationVarId = (basics_cloneImm)($luv);
        return (($core$Result$onOk)((($taModule) => {
          return (($core$Result$onOk)((($moduleWithDestroy) => {
            const $toMatch = (($$def) => {
              const $pattern = $$def.first;
              const $def = $$def.second;
              return (((($pattern)[0] === "PatternAny") && ((($pattern)[2].maybeName)[0] === "Just"))
                ? ((() => {
                  const $maybeAnnotation = ($pattern)[2].maybeAnnotation;
                  const $name = (($pattern)[2].maybeName)[1];
                  return ((sp_equal)($name, $targetName)
                    ? ($core$Maybe$Just)($def)
                    : $core$Maybe$Nothing);
                }))()
                : (true
                  ? $core$Maybe$Nothing
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck_Test.sp 133:8', (sp_toHuman)($pattern))));
            });
            const $matches = ((($1) => {
              return ($core$List$filterMap)($toMatch, $1);
            }))(($core$Dict$toList)($moduleWithDestroy.valueDefs));
            return ((($matches)[0] === "Nil")
              ? ($core$Result$Err)("dict fail")
              : ((($matches)[0] === "Cons")
                ? ((() => {
                  const $def = ($matches)[1];
                  const $tail = ($matches)[2];
                  return ($core$Result$Ok)(($sd0$Compiler$TypeCheck_Test$normalizeOut)(({
                    freeTyvars: $def.freeTyvars,
                    type: $def.type.raw,
                  })));
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Compiler/TypeCheck_Test.sp 144:4', (sp_toHuman)($matches))));
          })))(((($1) => {
            return ($sd0$Compiler$TestHelpers$resErrorToStrippedText)($code, $1);
          }))(($sd0$Compiler$UniquenessCheck$doModule)($taModule)));
        })))(((($1) => {
          return ($sd0$Compiler$TestHelpers$resErrorToStrippedText)($code, $1);
        }))(((($2) => {
          return ((__re__ = ($sd0$Compiler$TypeCheck$doModule)($lastUnificationVarId, $typeCheckGlobalEnv, $2)), ($lastUnificationVarId = (__re__)[1]), (__re__)[0]);
        }))($caModule)));
      })))(((($1) => {
        return ($sd0$Compiler$TestHelpers$resErrorToStrippedText)($code, $1);
      }))(($sd0$Compiler$TypeCheck$initStateAndGlobalEnv)($modules)));
    })))(((($1) => {
      return ($sd0$Compiler$TestHelpers$resErrorToStrippedText)($code, $1);
    }))(($sd0$Compiler$MakeCanonical$textToCanonicalModule)($params, $code)));
  });
});

const $sd0$Compiler$TypeCheck_Test$tyvar = $sd0$Compiler$TestHelpers$taTyvar;

const $sd0$Compiler$TypeCheck_Test$functions = ($sd0$Test$Group)("functions", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Known function with correct params", "a = add 3 1", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: $sd0$Compiler$TestHelpers$taNumber,
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Known function with wrong *number* of args", "a = add False", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$errorContains)(($core$Core$Cons)("Number", ($core$Core$Cons)("Arguments", $core$Core$Nil)))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Known function with wrong params", "a = add False 1", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$errorContains)(($core$Core$Cons)("Bool", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Function inference 1", "a = fn x: add x 1", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($sd0$Compiler$TestHelpers$taNumber, $core$Core$Nil), $sd0$Compiler$TestHelpers$taNumber),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Function inference 2: same as 1, but with swapped args", "a = fn x: add 1 x", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($sd0$Compiler$TestHelpers$taNumber, $core$Core$Nil), $sd0$Compiler$TestHelpers$taNumber),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] fn had type None", "a = fn x: 1", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeFn)(($core$Core$Cons)(($sd0$Types$TypedAst$ParSp)(($sd0$Types$Ast$toImm)(($sd0$Compiler$TypeCheck_Test$tyvar)(1))), $core$Core$Nil), ($sd0$Types$Ast$toUni)($sd0$Compiler$TestHelpers$taNumber)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Multiple arguments are correctly inferred", "a = fn x, y, z: x + y + z", ($sd0$Compiler$TypeCheck_Test$infer)("a"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Annotation should be consistent with mutability", "f as fn @Number: Number = fn a:\n  a", ($sd0$Compiler$TypeCheck_Test$infer)("f"), ($sd0$Test$errorContains)(($core$Core$Cons)("RecyclingDoesNotMatch", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] on is missing tyvars?", "andThen as [a] = []\n\non = andThen", ($sd0$Compiler$TypeCheck_Test$infer)("on"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: $sd0$Compiler$TestHelpers$taBool,
}))), $core$Core$Nil))))))))));

const $sd0$Compiler$TypeCheck_Test$higherOrderTypes = ($sd0$Test$Group)("higher order types", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Parse precedence", "union T a = T a\n\na as fn T a: T a =\n    fn l: l", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: ($sd0$Compiler$TypeCheck_Test$freeTyvarsAnnotated)(($core$Core$Cons)(({
    first: 1,
    second: "a",
  }), $core$Core$Nil)),
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)(($sd0$Types$TypedAst$TypeExact)(($sd0$Compiler$TestHelpers$localType)("T"), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$tyvar)(1), $core$Core$Nil)), $core$Core$Nil), ($sd0$Types$TypedAst$TypeExact)(($sd0$Compiler$TestHelpers$localType)("T"), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$tyvar)(1), $core$Core$Nil))),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Union type constructors", "union X a = L\nl = L", ($sd0$Compiler$TypeCheck_Test$infer)("l"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeExact)(($sd0$Compiler$TestHelpers$localType)("X"), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$tyvar)(1), $core$Core$Nil)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] type check mistakes a union type with free tyvars for a free tyvar?", "union O r e o = O r e o\n\nrun as fn (fn r: O r e o), r: O r e o =\n   fn rToOreo, r:\n   rToOreo r", ($sd0$Compiler$TypeCheck_Test$infer)("run"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Wrong should be Text", "union O o = O Text o\n\nfun as Number: Text: O wrong = _: a:\n    O a a", ($sd0$Compiler$TypeCheck_Test$infer)("fun"), ($sd0$Test$errorContains)(($core$Core$Cons)("wrong", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Should complain about undefined type argument", "union O a = O Text output\nx = 1", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)(($core$Core$Cons)("output", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Named vars can't be refined?", "union Wrap a = W a\n\nf as fn a: Wrap a =\n    fn a: a", ($sd0$Compiler$TypeCheck_Test$infer)("f"), ($sd0$Test$errorContains)(($core$Core$Cons)("Wrap", $core$Core$Nil))), $core$Core$Nil)))))));

const $sd0$Compiler$TypeCheck_Test$if_else = ($sd0$Test$Group)("if..else", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("basic functionality", "x =\n    fn q:\n    if q then 1\n    else 2", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeFn)(($core$Core$Cons)(($sd0$Types$TypedAst$ParSp)(($sd0$Types$Ast$toImm)($sd0$Compiler$TestHelpers$taBool)), $core$Core$Nil), ($sd0$Types$Ast$toUni)($sd0$Compiler$TestHelpers$taNumber)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("rejects non-bool conditions", "x =\n    fn q:\n    if 1 then 1\n    else 2", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)(($core$Core$Cons)("Bool", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks", "x =\n    fn q:\n    if q then 2\n    else False", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)(($core$Core$Cons)("Number", $core$Core$Nil))), $core$Core$Nil))));

const $sd0$Compiler$TypeCheck_Test$misc = ($sd0$Test$Group)("Misc", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Placeholder work with unique args", "stuff as fn !Number: Number = todo \"\"\nv =\n    1 >> stuff __", ($sd0$Compiler$TypeCheck_Test$infer)("v"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: $sd0$Compiler$TestHelpers$taNumber,
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] named tyvars should not \"bleed\" to other definitions", "union DD q =\n    , RBEmpty_elm_builtin\n\nempty as DD key =\n    RBEmpty_elm_builtin\n\nmerge as fn (fn key, b, res: res), res: res =\n  fn rightStep, initialResult:\n\n  stepState as fn key, b, [key & a] & res: [key & a] & res =\n    fn rKey, rValue, q:\n    try q.first as\n      , []: q\n\n  initialResult", ($sd0$Compiler$TypeCheck_Test$infer)("merge"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Constructors not being generalized led to tyvar bleed", "union DD a b = Blah\n\nddget as fn a, DD a b: DD a b =\n    fn a, b:\n    Blah\n\nformatSnippet as Text =\n    try [\"\"] as\n        , [\"emphasys\", s]: s\n\nfmtBlock as Text =\n    try ddget 1 Blah as\n        , Blah:\n            \"\"", ($sd0$Compiler$TypeCheck_Test$infer)("formatSnippet"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Non-annotated variables are not correctly inserted", "n = 3\n\nz as Number = n + 1", ($sd0$Compiler$TypeCheck_Test$infer)("z"), $sd0$Test$isOk), $core$Core$Nil)))));

const $sd0$Compiler$TypeCheck_Test$nonFunction = ($sd0$Test$Group)("NonFunction", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("SKIP (burnedout) Basic functionality", "blah as fn [a]: [a] with a NonFunction =\n  fn a:\n  a\n\nmeh =\n    blah [fn x: x]", ($sd0$Compiler$TypeCheck_Test$infer)("meh"), ($sd0$Test$errorContains)(($core$Core$Cons)("ErrorTypeAllowsFunctions", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("SKIP (burnedout) Constraint is enforced with annotation", "blah as fn [a]: [a] with a NonFunction =\n  fn a: a\n\nmeh as fn b: b =\n    fn a: blah a", ($sd0$Compiler$TypeCheck_Test$infer)("meh"), ($sd0$Test$errorContains)(($core$Core$Cons)("ErrorTypeAllowsFunctions", $core$Core$Nil))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("SKIP (burnedout) Constraint is enforced without annotation", "blah as fn [a]: [a] with a NonFunction =\n    fn a: a\n\nmeh =\n    fn a: blah a", ($sd0$Compiler$TypeCheck_Test$infer)("meh"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: ($core$Dict$ofOne)(1, ({
    allowFunctions: false,
    generalizedAt: $sd0$Types$Pos$G,
    generalizedFor: ($sd0$Types$Ast$RefLocal)(""),
    originalName: "",
  })),
  type: $sd0$Compiler$TestHelpers$taNumber,
}))), $core$Core$Nil))));

const $sd0$Compiler$TypeCheck_Test$patterns = ($sd0$Test$Group)("Patterns", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Constructor unpacking", "union Z a = Z a\n\nidentityFunction =\n   fn a:\n   Z b = Z a\n   b", ($sd0$Compiler$TypeCheck_Test$infer)("identityFunction"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$tyvar)(1), $core$Core$Nil), ($sd0$Compiler$TypeCheck_Test$tyvar)(1)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("List unpacking", "x =\n   fn q:\n   [ first, second ] = q\n   first", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)(($sd0$Compiler$TestHelpers$taList)(($sd0$Compiler$TypeCheck_Test$tyvar)(1)), $core$Core$Nil), ($sd0$Compiler$TypeCheck_Test$tyvar)(1)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Records are correctly unpacked", "x =\n    fn q:\n    { first } = q\n    first", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)(($sd0$Types$TypedAst$TypeRecord)($core$Maybe$Nothing, ($core$Dict$fromList)(($core$Core$Cons)(({
    first: "first",
    second: ($sd0$Compiler$TypeCheck_Test$tyvar)(1),
  }), $core$Core$Nil))), $core$Core$Nil), ($sd0$Compiler$TypeCheck_Test$tyvar)(1)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Constructors should instantiate their variable types", "each as fn [a], (fn a: b): None =\n    fn ls, f:\n    try ls as\n        , Core.Nil: None\n\nresult =\n    1 :: Core.Nil = Core.Nil", ($sd0$Compiler$TypeCheck_Test$infer)("result"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Trying to check against an inferred value?", "tuple as Text & Number =\n    \"\" & 1\n\nx =\n    (a as Text) & (b as Number) =\n        tuple", ($sd0$Compiler$TypeCheck_Test$infer)("x"), $sd0$Test$isOk), $core$Core$Nil))))));

const $sd0$Compiler$TypeCheck_Test$records = ($sd0$Test$Group)("Records", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Attribute access", "a = fn b: b.meh.blah", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)(($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(1), ($core$Dict$ofOne)("meh", ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(2), ($core$Dict$ofOne)("blah", ($sd0$Compiler$TypeCheck_Test$tyvar)(3))))), $core$Core$Nil), ($sd0$Compiler$TypeCheck_Test$tyvar)(3)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Attribute mutation", "a = fn @b: @b.meh.blah += 1", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeFn)(($core$Core$Cons)(($sd0$Types$TypedAst$ParRe)(($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(1), ($core$Dict$ofOne)("meh", ($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(2), ($core$Dict$ofOne)("blah", $sd0$Compiler$TestHelpers$taNumber))))), $core$Core$Nil), ($sd0$Types$Ast$toImm)($sd0$Compiler$TestHelpers$taNone)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Tuple3 direct item mutability", "x =\n    !a = 3 & False & 2\n\n    @a.third += 1", ($sd0$Compiler$TypeCheck_Test$infer)("x"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Tuple2 direct item mutability, annotated", "x =\n   fn _:\n   !a as Number & Number =\n     1 & 2\n\n   @a.first += 1", ($sd0$Compiler$TypeCheck_Test$infer)("x"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("functional update", "a = fn b: { b with x = 1 }", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: $core$Dict$empty,
    type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($re, $core$Core$Nil), $re),
  });
}))(($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(1), ($core$Dict$ofOne)("x", $sd0$Compiler$TestHelpers$taNumber))))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("SKIP(needs reordering) instantiate and refine inferred records", "a = fn t: { t with x = 1 }\nc = a", ($sd0$Compiler$TypeCheck_Test$infer)("c"), ($sd0$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: $core$Dict$empty,
    type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($re, $core$Core$Nil), $re),
  });
}))(($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(1), ($core$Dict$ofOne)("x", $sd0$Compiler$TestHelpers$taNumber))))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] excessive forallness in records", "x =\n  fn q:\n  a = q.first\n  a", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$isOkAndEqualTo)(((($re) => {
  return ({
    freeTyvars: $core$Dict$empty,
    type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)($re, $core$Core$Nil), ($sd0$Compiler$TypeCheck_Test$tyvar)(2)),
  });
}))(($sd0$Types$TypedAst$TypeRecord)(($core$Maybe$Just)(1), ($core$Dict$ofOne)("first", ($sd0$Compiler$TypeCheck_Test$tyvar)(2)))))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] refineType when the record has a non-extensible alias", "alias A = { c as Number, d as Number }\n\nupd as fn A: A = fn a:\n  { a with c = .c + 1 }", ($sd0$Compiler$TypeCheck_Test$infer)("upd"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] infinite recursion on addSubstitution/unify_", "alias B = { l as [Text] }\n\nreadOne as fn B: (Text & B) =\n    fn b:\n    try b.l as\n        , []: \"\" & b\n        , [h, ...t]: h & { b with l = t }", ($sd0$Compiler$TypeCheck_Test$infer)("readOne"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] unifyToNonExtensibleRecord correctly substitutes the record extension", "alias R = { x as Number, y as Number }\n\nrec as fn R: R =\n    fn s:\n\n    if True then\n        { s with y = .y }\n    else\n        rec { s with y = .y }", ($sd0$Compiler$TypeCheck_Test$infer)("rec"), $sd0$Test$isOk), $core$Core$Nil)))))))))));

const $sd0$Compiler$TypeCheck_Test$statements = ($sd0$Test$Group)("statements", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Statement blocks should return the last statement's type", "a =\n  3\n  False", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: $sd0$Compiler$TestHelpers$taBool,
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Definition statement return type None", "a =\n  f = fn x: 3", ($sd0$Compiler$TypeCheck_Test$infer)("a"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: $sd0$Compiler$TestHelpers$taNone,
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Definition statement with annotation return type None", "a as None =\n  f = 3", ($sd0$Compiler$TypeCheck_Test$infer)("a"), $sd0$Test$isOk), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] Annotated declarations are actually typechecked", "x as None =\n    q = 1 + \"\"", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)($core$Core$Nil)), $core$Core$Nil)))));

const $sd0$Compiler$TypeCheck_Test$try_as = ($sd0$Test$Group)("try..as", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("basic functionality", "x =\n    fn q:\n    try q as\n        , True: 2\n        , _: 3", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeFn)(($core$Core$Cons)(($sd0$Types$TypedAst$ParSp)(($sd0$Types$Ast$toImm)($sd0$Compiler$TestHelpers$taBool)), $core$Core$Nil), ($sd0$Types$Ast$toUni)($sd0$Compiler$TestHelpers$taNumber)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("rejects non-matching patterns", "x =\n    fn q:\n    try q as\n        , True: 2\n        , []: 3", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)(($core$Core$Cons)("List", ($core$Core$Cons)("Bool", $core$Core$Nil)))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("rejects non-matching blocks", "x =\n    fn q:\n    try q as\n        , True: 2\n        , False: False", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)(($core$Core$Cons)("Number", ($core$Core$Cons)("Bool", $core$Core$Nil)))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("[reg] actually infers blocks", "x as Number =\n    try \"\" as\n        , \"\": y", ($sd0$Compiler$TypeCheck_Test$infer)("x"), ($sd0$Test$errorContains)(($core$Core$Cons)("y", $core$Core$Nil))), $core$Core$Nil)))));

const $sd0$Compiler$TypeCheck_Test$variableTypes = ($sd0$Test$Group)("Variable types", ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Identity", "id as fn a: a =\n  fn a: a", ($sd0$Compiler$TypeCheck_Test$infer)("id"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: ($sd0$Compiler$TypeCheck_Test$freeTyvarsAnnotated)(($core$Core$Cons)(({
    first: 1,
    second: "a",
  }), $core$Core$Nil)),
  type: ($sd0$Compiler$TestHelpers$taFunction)(($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$tyvar)(1), $core$Core$Nil), ($sd0$Compiler$TypeCheck_Test$tyvar)(1)),
}))), ($core$Core$Cons)(($sd0$Compiler$TypeCheck_Test$codeTest)("Annotated vars are instantiated when referenced", "q as [item] =\n  Core.Nil\n\nr as [Text] =\n      q", ($sd0$Compiler$TypeCheck_Test$infer)("r"), $sd0$Test$isOk), $core$Core$Nil)));

const $sd0$Compiler$TypeCheck_Test$tests = ($sd0$Test$Group)("TypeCheck", ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$functions, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$statements, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$variableTypes, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$higherOrderTypes, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$records, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$patterns, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$try_as, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$if_else, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$nonFunction, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$misc, $core$Core$Nil)))))))))));

const $sd0$Compiler$UniquenessCheck$errorConsumingRecycledParameter = (($name, $pos, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($pos, $state, (($eenv) => {
      return ($core$Core$Cons)(($name + " is passed as recycled, but the function wants to spend it"), $core$Core$Nil);
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Compiler$UniquenessCheck$errorUniqueHasImmType = (($name, $pos, $type, $state) => {
  return ([
    ((__re__ = ($sd0$Compiler$UniquenessCheck$addError)($pos, $state, (($eenv) => {
      return ($core$Core$Cons)(("Variable `" + ($name + "` is unique, but its type is:")), ($core$Core$Cons)((sp_toHuman)($type), $core$Core$Nil));
    }))), ($state = (__re__)[1]), (__re__)[0]),
    $state,
  ]);
});

const $sd0$Human$Type$stack = (($content) => {
  return ($sd0$Human$Type$Block)($sd0$Human$Type$NotIndented, $content);
});

const $sd0$RefHierarchy_Test$valueTest = (($1, $2, $3) => {
  return ($sd0$Test$valueTest)(sp_toHuman, $1, $2, $3);
});

const $sd0$RefHierarchy_Test$canonicalJsTest = ($sd0$RefHierarchy_Test$valueTest)("[reg] THIS SHOULD BE IN CANONICALTOJS", ((_0) => {
  return (basics_compare)(null, null);
}), ($sd0$Test$isOkAndEqualTo)(0));

const $sd0$RefHierarchy_Test$graph1 = ((() => {
  const $x = (($k, $l) => {
    return ({
      first: $k,
      second: ({
        first: $k,
        second: ($core$Set$fromList)($l),
      }),
    });
  });
  return ($core$Dict$fromList)(($core$Core$Cons)(($x)("a", ($core$Core$Cons)("b", ($core$Core$Cons)("d", $core$Core$Nil))), ($core$Core$Cons)(($x)("b", ($core$Core$Cons)("c", ($core$Core$Cons)("e", $core$Core$Nil))), ($core$Core$Cons)(($x)("c", ($core$Core$Cons)("e", ($core$Core$Cons)("d", $core$Core$Nil))), ($core$Core$Cons)(($x)("d", $core$Core$Nil), ($core$Core$Cons)(($x)("e", $core$Core$Nil), $core$Core$Nil))))));
}))();

const $sd0$RefHierarchy_Test$graph2 = ((() => {
  const $x = (($k, $l) => {
    return ({
      first: $k,
      second: ({
        first: $k,
        second: ($core$Set$fromList)($l),
      }),
    });
  });
  return ($core$Dict$fromList)(($core$Core$Cons)(($x)("a", ($core$Core$Cons)("b", ($core$Core$Cons)("d", $core$Core$Nil))), ($core$Core$Cons)(($x)("b", ($core$Core$Cons)("c", ($core$Core$Cons)("e", $core$Core$Nil))), ($core$Core$Cons)(($x)("c", ($core$Core$Cons)("e", ($core$Core$Cons)("d", $core$Core$Nil))), ($core$Core$Cons)(($x)("d", ($core$Core$Cons)("b", $core$Core$Nil)), ($core$Core$Cons)(($x)("e", $core$Core$Nil), $core$Core$Nil))))));
}))();

const $sd0$RefHierarchy_Test$tests = ($sd0$Test$Group)("RefHierarchy", ($core$Core$Cons)($sd0$RefHierarchy_Test$canonicalJsTest, ($core$Core$Cons)(($sd0$RefHierarchy_Test$valueTest)("Basic", ((_0) => {
  return ($sd0$RefHierarchy$reorder)($core$Tuple$second, $sd0$RefHierarchy_Test$graph1);
}), ($sd0$Test$isOkAndEqualTo)(({
  first: $core$Core$Nil,
  second: ($core$Core$Cons)("d", ($core$Core$Cons)("e", ($core$Core$Cons)("c", ($core$Core$Cons)("b", ($core$Core$Cons)("a", $core$Core$Nil))))),
}))), ($core$Core$Cons)(($sd0$RefHierarchy_Test$valueTest)("Circular", ((_0) => {
  return ($sd0$RefHierarchy$reorder)($core$Tuple$second, $sd0$RefHierarchy_Test$graph2);
}), ($sd0$Test$isOkAndEqualTo)(({
  first: ($core$Core$Cons)(($core$Core$Cons)("b", ($core$Core$Cons)("d", ($core$Core$Cons)("c", $core$Core$Nil))), $core$Core$Nil),
  second: ($core$Core$Cons)("d", ($core$Core$Cons)("e", ($core$Core$Cons)("c", ($core$Core$Cons)("b", ($core$Core$Cons)("a", $core$Core$Nil))))),
}))), $core$Core$Nil))));

const $sd1$Uniqueness$codeTest = (($1, $2, $3, $4) => {
  return ($sd0$Test$codeTest)(sp_toHuman, $1, $2, $3, $4);
});

const $sd1$Uniqueness$infer = $sd0$Compiler$TypeCheck_Test$infer;

const $sd1$Uniqueness$howDoesItLookLike = ($sd0$Test$Group)("How does mutability look like?", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Example: maintaining mutable state", "average as fn [Number]: Number =\n    fn numbers:\n\n    # Unique values can be changed in place, ie, \"mutated\"\n    !total as Number =\n        0\n\n    !count as Number =\n        0\n\n    (todo \"List.each\") numbers fn number:\n        @total += number\n        @count += 1\n\n    # In Squarepants division by 0 yields 0\n    total / count", ($sd1$Uniqueness$infer)("average"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("SKIP (needs IO in the test env) Example: File IO", "logToFile as fn @IO, Text: Result IO.Error None =\n    fn @io, content:\n\n    IO.openFile @io IO.Append \"blah.log\"\n    >> isOk fn @fileDescriptor:\n\n    IO.writeFile @io content @fileDescriptor\n\n    # fileDescriptor is automatically closed here", ($sd1$Uniqueness$infer)("logToFile"), $sd0$Test$isOk), $core$Core$Nil)));

const $sd1$Uniqueness$mutation = ($sd0$Test$Group)("Mutation", ($core$Core$Cons)(($sd0$Test$Group)("Uniques can be mutated in place", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Mutation does NOT consume the unique", "scope =\n    !x = 1\n    @x += 1\n    @x += 1", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Recycling requires the unique not to be spent", "scope =\n    !x = 1\n    (todo \"consume\") x\n    @x += 1", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("used again here", $core$Core$Nil))), $core$Core$Nil))), ($core$Core$Cons)(($sd0$Test$Group)("A function can be defined to mutate its arguments", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("base", "funz as fn @Number: None =\n    fn @a:\n    @a += 3\n\nscope =\n    !x = 0\n    funz @x\n    funz @x", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), $core$Core$Nil)), ($core$Core$Cons)(($sd0$Test$Group)("Calling a function that recycles a unique variable temporarily consumes the variable.", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("base", "scope =\n    !x = 0\n    (todo \"funz\") @x @x", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("twice", $core$Core$Nil))), $core$Core$Nil)), $core$Core$Nil))));

const $sd1$Uniqueness$parentScope = ($sd0$Test$Group)("Recycling a variable in the parent scope", ($core$Core$Cons)(($sd0$Test$Group)("A function that recycles any unique belonging to an ancestor scope \"requires\" that unique.", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("LetIns cannot return functions with requirements", "scope =\n    !x =\n        1\n\n    f =\n        fn n:\n        @x += n\n        None\n\n    f", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("x", ($core$Core$Cons)("from outside", $core$Core$Nil)))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Functions cannot return functions with UNIQUE requirements", "f =\n    fn !x:\n    fn n:\n    @x += n\n    None", ($sd1$Uniqueness$infer)("f"), ($sd0$Test$errorContains)(($core$Core$Cons)("x", ($core$Core$Cons)("from outside", $core$Core$Nil)))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Functions cannot return functions with RECYCLED requirements", "f =\n    fn @x:\n    fn n:\n    @x += n\n    None", ($sd1$Uniqueness$infer)("f"), ($sd0$Test$errorContains)(($core$Core$Cons)("x", ($core$Core$Cons)("from outside", $core$Core$Nil)))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("The Array Test", "union Array a = Meh\n\narray_push as fn a, @Array a: None = todo \"\"\n\naddFunctions as fn @Array (fn Int: Int): None =\n    fn @functions:\n\n    !x =\n        1\n\n    f as fn Int: Int =\n        fn n:\n        @x += 1\n        n\n\n    array_push f @functions\n    None", ($sd1$Uniqueness$infer)("addFunctions"), ($sd0$Test$errorContains)(($core$Core$Cons)("x", ($core$Core$Cons)("outside", $core$Core$Nil)))), $core$Core$Nil))))), $core$Core$Nil));

const $sd1$Uniqueness$polymorphism = ($sd0$Test$Group)("Polymorphism", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Basic syntax", "fun as fn (fn 1?a: 2?b), 1?a: 2?b =\n    fn f, 1?a:\n\n    f a", ($sd1$Uniqueness$infer)("fun"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("A function that returns a Uni can be used in place of a function that returns an Imm", "meh as fn (fn None: Number): Number =\n    fn f: f None\n\nblah = meh (fn None: 1)", ($sd1$Uniqueness$infer)("blah"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("A function that returns an Imm CANNOT be used in place of a function that returns an Uni", "meh as fn (fn None: !Number): !Number =\n    fn f: f None\n\nx as Number = 1\n\nblah = meh (fn None: x)", ($sd1$Uniqueness$infer)("blah"), ($sd0$Test$errorContains)(($core$Core$Cons)("return", ($core$Core$Cons)("uniqueness", $core$Core$Nil)))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("a Uni, b Uni", "union Re error payload = Er error, Okk payload\nisOkk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = todo \"\"\n\nscope =\n    !v = isOkk (fn !a: Okk 0) (Okk 0)", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("a Uni, b Imm", "union Result_ error payload = Err_ error, Ok_ payload\nisOk_ as fn (fn 1?a: 2?Result_ error b), 1?Result_ error a: 2?Result_ error b = todo \"\"\nimmB as Number = 1\n\nv = isOk_ (fn !a: Ok_ immB) (Ok_ 0)", ($sd1$Uniqueness$infer)("v"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("No annotation", "na = fn 0?x: x", ($sd1$Uniqueness$infer)("na"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeFn)(($core$Core$Cons)(($sd0$Types$TypedAst$ParSp)(({
    raw: ($sd0$Types$TypedAst$TypeVar)(1),
    uni: ($sd0$Types$Ast$Depends)(0),
  })), $core$Core$Nil), ({
    raw: ($sd0$Types$TypedAst$TypeVar)(1),
    uni: ($sd0$Types$Ast$Depends)(0),
  })),
}))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Generalization", "na as fn 1?a: 1?a =\n    fn 1?x: x\n\nscope as None =\n    !uni = na 0\n\nnone as None =\n    na scope", ($sd1$Uniqueness$infer)("na"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("[rec] variable without any uniqueness flag should be imm", "scope =\n    num = 1\n\n    x as Number = num + 1\n    y as Number = num + 2", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), $core$Core$Nil)))))))));

const $sd1$Uniqueness$records = ($sd0$Test$Group)("Records", ($core$Core$Cons)(($sd0$Test$Group)("The attribute of a mutable record can be accessed as a mutable:", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Simple case", "scope =\n    !record = { x = 0, y = 0 }\n    @record.x += 3", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Reject double reference", "scope =\n    !record = { x = 0, y = 0 }\n    (todo \"\") @record.x @record.y", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("same unique twice in the same function call", $core$Core$Nil))), $core$Core$Nil))), $core$Core$Nil));

const $sd1$Uniqueness$unions = ($sd0$Test$Group)("Unions", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Uniques inside immutables are converted to immutables", "union Z a = Z a\nx = Z 0", ($sd1$Uniqueness$infer)("x"), ($sd0$Test$isOkAndEqualTo)(({
  freeTyvars: $core$Dict$empty,
  type: ($sd0$Types$TypedAst$TypeExact)(($sd0$Compiler$TestHelpers$localType)("Z"), ($core$Core$Cons)($sd0$Compiler$TestHelpers$taNumber, $core$Core$Nil)),
}))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("[reg] Lists of immutables", "i as Number = 1\nx = [ i, i ]", ($sd1$Uniqueness$infer)("x"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("[reg] solveOneEquality can receive switched given/required when evaluating a cast?", "z as [fn None: None] = (fn None: None) :: []", ($sd1$Uniqueness$infer)("z"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("LetIn: Unpack immutable to immutable", "union Z a = Z a\nscope =\n    x = Z 0\n    (Z y) = x", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("LetIn: Unpack unique to immutable", "union Z a = Z a\nscope =\n    !x = Z 0\n    (Z y) = x", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("LetIn: Unpack unique to unique", "union Z a = Z a\nscope =\n    !x = Z 0\n    #!(Z y) = x\n    #@y += 1", ($sd1$Uniqueness$infer)("scope"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("LetIn: Unpack immutable to unique", "union Z a = Z a\nscope =\n    x = Z 0\n    !(Z y) = x", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("y", ($core$Core$Cons)("Unique", $core$Core$Nil)))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Fn: Unpack immutable to immutable", "union Z a = Z a\nf as fn Z a: Z a =\n     fn Z a: Z a", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Fn: Unpack unique to immutable", "union Z a = Z a\nf as fn !(Z a): Z a =\n     fn !(Z a): Z a", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Fn: Unpack unique to unique", "union Z a = Z a\nf as fn !(Z a): !(Z a) =\n     fn !(Z a): Z a", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Fn: Unpack immutable to unique", "union Z a = Z a\nf as fn Z a: !(Z a) =\n     fn Z a: Z a", ($sd1$Uniqueness$infer)("f"), ($sd0$Test$errorContains)(($core$Core$Cons)("Unique", $core$Core$Nil))), $core$Core$Nil))))))))))));

const $sd1$Uniqueness$uniquenessTyping = ($sd0$Test$Group)("Uniqueness Typing", ($core$Core$Cons)(($sd0$Test$Group)("All literal expressions allow uniqueness", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("failure", "f as fn Number: !Number = fn x: x", ($sd1$Uniqueness$infer)("f"), ($sd0$Test$errorContains)(($core$Core$Cons)("ErrorUniquenessDoesNotMatch", $core$Core$Nil))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Number", "f as fn a: !Number = fn _: 1", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Text", "f as fn a: !Text = fn _: \"meh\" ", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Record", "f as fn a: !{} = fn _: {}", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Constructor 1", "f as fn a: !Bool = fn _: True", ($sd1$Uniqueness$infer)("f"), $sd0$Test$isOk), $core$Core$Nil)))))), ($core$Core$Cons)(($sd0$Test$Group)("Conversions", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Immutables cannot be used in place of uniques 2", "scope =\n    x = 1\n    @x += 1", ($sd1$Uniqueness$infer)("a"), ($sd0$Test$errorContains)(($core$Core$Cons)("ErrorShouldBeUnique", $core$Core$Nil))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("Uniques can be implicitly transformed in immutables", "a as Number = 1", ($sd1$Uniqueness$infer)("a"), $sd0$Test$isOk), $core$Core$Nil))), ($core$Core$Cons)(($sd0$Test$Group)("A variable with mutable type must be explicitly declared as mutable with `!`", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("1", "z =\n    !a as Number = 1", ($sd1$Uniqueness$infer)("z"), $sd0$Test$isOk), $core$Core$Nil)), ($core$Core$Cons)(($sd0$Test$Group)("Referencing a mutable variable \"spends\" it", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("base", "scope =\n    !x =\n        1\n\n    !y =\n        # The first time we do it it works!\n        x\n\n    !z =\n        # But here `x` is now spent, so we get a compiler error!\n        x", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("used already here", $core$Core$Nil))), ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("tuple", "scope =\n    !x =\n        1\n\n    !y =\n        x & x", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("used already here", $core$Core$Nil))), $core$Core$Nil))), ($core$Core$Cons)(($sd0$Test$Group)("A function cannot consume uniques outside its own scope.", ($core$Core$Cons)(($sd1$Uniqueness$codeTest)("base", "scope =\n    !x = 1\n    fn z: x", ($sd1$Uniqueness$infer)("scope"), ($sd0$Test$errorContains)(($core$Core$Cons)("outside their body", ($core$Core$Cons)("x", $core$Core$Nil)))), $core$Core$Nil)), $core$Core$Nil))))));

const $sd1$Uniqueness$specs = ($sd0$Test$Group)("Uniqueness", ($core$Core$Cons)($sd1$Uniqueness$howDoesItLookLike, ($core$Core$Cons)($sd1$Uniqueness$uniquenessTyping, ($core$Core$Cons)($sd1$Uniqueness$mutation, ($core$Core$Cons)($sd1$Uniqueness$parentScope, ($core$Core$Cons)($sd1$Uniqueness$polymorphism, ($core$Core$Cons)($sd1$Uniqueness$unions, ($core$Core$Cons)($sd1$Uniqueness$records, $core$Core$Nil))))))));

const $sd0$Main$allTests = ($core$Core$Cons)($sd0$Compiler$Lexer_Test$tests, ($core$Core$Cons)($sd0$Compiler$Parser_Test$tests, ($core$Core$Cons)($sd0$Compiler$MakeCanonical_Test$tests, ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$tests, ($core$Core$Cons)($core$Hash_Test$tests, ($core$Core$Cons)($core$Array_Test$tests, ($core$Core$Cons)($core$List_Test$tests, ($core$Core$Cons)($core$Dict_Test$tests, ($core$Core$Cons)($sd0$RefHierarchy_Test$tests, ($core$Core$Cons)($sd1$Uniqueness$specs, $core$Core$Nil))))))))));

const $sd0$Platforms$Browser$virtualDomModule = (($1) => {
  return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Browser, "VirtualDom"), $1);
});

const $sd0$Platforms$Browser$footer = (($state, $targetUsr) => {
  const $main = ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($state, $targetUsr)), ($state = (__re__)[1]), (__re__)[0]);
  const $updateDomNode = ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($state, ($sd0$Platforms$Browser$virtualDomModule)("updateDomNode"))), ($state = (__re__)[1]), (__re__)[0]);
  return ([
    ("\n// TODO these globals will be a hell of trouble if we want to run more than one app\nlet oldVirtualDom = {}; // TODO this should be properly initialized\nlet model = null;\nlet elementId = null;\n\nfunction dispatch(msgResult) {\n    if (msgResult[0] === \"Ok\") {\n\n        const msg = msgResult[1];\n\n        model = " + ($main + (".update(msg, model);\n\n            // TODO set a flag and use requestAnimationFrame\n            updateDom();\n        } else {\n            console.log('rejecting msg: ', msgResult[1]);\n        }\n    }\n\n\n    function updateDom() {\n        const e = win.document.getElementById(elementId);\n\n        const newVirtualDom = " + ($main + (".view(model);\n\n        " + ($updateDomNode + ("(newVirtualDom, oldVirtualDom, e.childNodes[0]);\n\n        oldVirtualDom = newVirtualDom;\n    }\n\n\n\n    function main(eid) {\n        elementId = eid;\n        model = " + ($main + ".init(null);\n        updateDom();\n    }\n\n\n\n\n\n    win.Squarepants = {\n        main: main,\n    };\n\n})(this);\n    ")))))))),
    $state,
  ]);
});

const $sd0$Platforms$Browser$header = "(function (win) {\n";

const $sd0$Platforms$Browser$overrides = ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsCreateTextNode"),
  second: "virtualDom_jsCreateTextNode",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsCreateElement"),
  second: "virtualDom_jsCreateElement",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsReplaceWith"),
  second: "virtualDom_jsReplaceWith",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsAppendChild"),
  second: "virtualDom_jsAppendChild",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsSetAttribute"),
  second: "virtualDom_jsSetAttribute",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsRemoveAttribute"),
  second: "virtualDom_jsRemoveAttribute",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsAddEventListener"),
  second: "virtualDom_jsAddEventListener",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("jsRemoveEventListener"),
  second: "virtualDom_jsRemoveEventListener",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("eventToText"),
  second: "virtualDom_eventToText",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("eventToFloat"),
  second: "virtualDom_eventToFloat",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("setChild"),
  second: "virtualDom_setChild",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("removeAllChildrenStartingFromIndex"),
  second: "virtualDom_removeAllChildrenStartingFromIndex",
}), ($core$Core$Cons)(({
  first: ($sd0$Platforms$Browser$virtualDomModule)("unsafeExecuteJavaScript"),
  second: "virtualDom_unsafeExecuteJavaScript",
}), $core$Core$Nil)))))))))))));

const $sd0$Platforms$Browser$runtime = "const crawlObject = (path, type, object) => {\n\n    while(path[0] === 'Cons') {\n\n        const head = path[1];\n        const tail = path[2];\n\n        const o = object[head];\n\n        if (o === undefined) {\n            return [ 'Err', 'no field named: ' + head ];\n        }\n\n        object = o;\n        path = path[2];\n    }\n\n    return typeof object === type\n        ? [ 'Ok', object ]\n        : [ 'Err', 'wrong type: ' + typeof object ]\n        ;\n}\n\n\nconst virtualDom_eventToText = (path, event) => crawlObject(path, 'string', event);\nconst virtualDom_eventToFloat = (path, event) => crawlObject(path, 'number', event);\n\n// TODO ensure that those who must return None actually return None (ie, null)\nconst virtualDom_jsCreateTextNode = (content) => document.createTextNode(content);\nconst virtualDom_jsCreateElement = (tag) => document.createElement(tag);\nconst virtualDom_jsReplaceWith = (new_, old) => { old.replaceWith(new_); return new_; }\nconst virtualDom_jsAppendChild = (pars) => pars.parent.appendChild(pars.child);\nconst virtualDom_jsSetAttribute = (name, value, node) => node.setAttribute(name, value);\nconst virtualDom_jsRemoveAttribute = (name, node) => node.removeAttribute(name);\n\n\nconst virtualDom_setChild = (upd, index, parentNode) => {\n    const child = parentNode.childNodes[index];\n    child && upd(child);\n};\n\n\nconst virtualDom_removeAllChildrenStartingFromIndex = (index, parentNode) => {\n    while(parentNode.childNodes[index]) {\n      parentNode.removeChild(parentNode.childNodes[index]);\n    }\n}\n\n\n// an EventHandler is a function that takes an Event and produces a msg\nconst virtualDom_jsAddEventListener = (eventName, handler, node) => {\n\n    node.squarepantsEventHandlers = node.squarepantsEventHandlers || {};\n\n    if (node.squarepantsEventHandlers[eventName]) {\n      node.removeEventListener(eventName, node.squarepantsEventHandlers[eventName]);\n    }\n\n    const onEvent = (event) => dispatch(handler(event));\n    node.squarepantsEventHandlers[eventName] = onEvent;\n    node.addEventListener(eventName, onEvent);\n};\n\nconst virtualDom_jsRemoveEventListener = (eventName, handler, node) => {\n    node.removeEventListener(eventName, node.squarepantsEventHandlers[eventName]);\n    node.squarepantsEventHandlers[eventName] = undefined;\n}\n\nconst virtualDom_unsafeExecuteJavaScript = (functionName, argument) => {\n    let error = null;\n\n    try {\n        const fn = functionName.split('.').reduce((obj, name) => obj[name], window);\n        fn(argument);\n    } catch (e) {\n      error = e;\n    }\n\n    return error\n        ? [ 'Err', error.message ]\n        : [ 'Ok', null ]\n}\n";

const $sd0$Targets$Javascript$EmittableToJs$accessAttrs = (($attrPath, $e) => {
  return ($core$List$for)($e, $attrPath, $sd0$Types$JavascriptAst$AccessWithDot);
});

const $sd0$Targets$Javascript$EmittableToJs$accessArrayIndex = (($index, $j) => {
  return ((($0) => {
    return ($sd0$Types$JavascriptAst$AccessWithBrackets)($0, $j);
  }))(($sd0$Types$JavascriptAst$Literal)((text_fromNumber)($index)));
});

const $sd0$Targets$Javascript$EmittableToJs$literalString = (($str) => {
  const $escaped = ((($2) => {
    return ($core$Text$replace)("\"", "\\\"", $2);
  }))(((($2) => {
    return ($core$Text$replace)("\n", "\\n", $2);
  }))($str));
  return ($sd0$Types$JavascriptAst$Literal)(("\"" + ($escaped + "\"")));
});

const $sd0$Targets$Javascript$EmittableToJs$recycleTempVariable = ($sd0$Types$JavascriptAst$Var)("__re__");

const $sd0$Targets$Javascript$EmittableToJs$translateVariable = (($env, $variableName) => {
  const $$try1 = ($core$Dict$get)($variableName, $env.overrides);
  return (((($$try1)[0] === "Just") && ((($$try1)[1])[0] === "Override"))
    ? ((() => {
      const $call = (($$try1)[1])[1].call;
      const $value = (($$try1)[1])[1].value;
      return ($value)($env);
    }))()
    : ((($$try1)[0] === "Nothing")
      ? ($sd0$Types$JavascriptAst$Var)($variableName)
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 176:4', (sp_toHuman)($$try1))));
});

const $sd0$Targets$Javascript$EmittableToJs$makeCall = (($env, $jaRef, $args) => {
  const $call = ((($1) => {
    return ($sd0$Types$JavascriptAst$Call)($jaRef, $1);
  }))(((($1) => {
    return ($core$List$map)((($2) => {
      return ($sd0$Targets$Javascript$EmittableToJs$translateArg)(({
        nativeBinop: false,
      }), $env, $2);
    }), $1);
  }))($args));
  const $asRecycled = (($arg) => {
    return ((($arg)[0] === "ArgumentSpend")
      ? $core$Maybe$Nothing
      : ((($arg)[0] === "ArgumentRecycle")
        ? ((() => {
          const $attrPath = ($arg)[1];
          const $name = ($arg)[2];
          return ($core$Maybe$Just)(((($1) => {
            return ($sd0$Targets$Javascript$EmittableToJs$accessAttrs)($attrPath, $1);
          }))(($sd0$Targets$Javascript$EmittableToJs$translateVariable)($env, $name)));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 293:8', (sp_toHuman)($arg))));
  });
  const $recycledArgs = ($core$List$filterMap)($asRecycled, $args);
  return ((sp_equal)($recycledArgs, $core$Core$Nil)
    ? $call
    : ((() => {
      const $zzz = (($index, $arg) => {
        const $bracketIndex = ($sd0$Types$JavascriptAst$Literal)((text_fromNumber)(($index + 1)));
        return ($sd0$Types$JavascriptAst$Binop)("=", $arg, ($sd0$Types$JavascriptAst$AccessWithBrackets)($bracketIndex, $sd0$Targets$Javascript$EmittableToJs$recycleTempVariable));
      });
      return ($sd0$Types$JavascriptAst$Comma)(($core$List$concat)(($core$Core$Cons)(($core$Core$Cons)(($sd0$Types$JavascriptAst$Binop)("=", $sd0$Targets$Javascript$EmittableToJs$recycleTempVariable, $call), $core$Core$Nil), ($core$Core$Cons)(((($1) => {
        return ($core$List$indexedMap)($zzz, $1);
      }))($recycledArgs), ($core$Core$Cons)(($core$Core$Cons)(($sd0$Types$JavascriptAst$AccessWithBrackets)(($sd0$Types$JavascriptAst$Literal)("0"), $sd0$Targets$Javascript$EmittableToJs$recycleTempVariable), $core$Core$Nil), $core$Core$Nil)))));
    }))());
});

const $sd0$Targets$Javascript$EmittableToJs$translateExpression = (($env, $eaExpression) => {
  return ((($eaExpression)[0] === "Variable")
    ? ((() => {
      const $name = ($eaExpression)[1];
      return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Targets$Javascript$EmittableToJs$translateVariable)($env, $name));
    }))()
    : ((($eaExpression)[0] === "Call")
      ? ((() => {
        const $ref = ($eaExpression)[1];
        const $args = ($eaExpression)[2];
        const $maybeNativeOverride = ((($ref)[0] === "Variable")
          ? ((() => {
            const $name = ($ref)[1];
            return ($core$Dict$get)($name, $env.overrides);
          }))()
          : (true
            ? $core$Maybe$Nothing
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 348:16', (sp_toHuman)($ref))));
        return (((($maybeNativeOverride)[0] === "Just") && ((($maybeNativeOverride)[1])[0] === "Override"))
          ? ((() => {
            const $call = (($maybeNativeOverride)[1])[1].call;
            return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($call)($env, $args));
          }))()
          : ((($maybeNativeOverride)[0] === "Nothing")
            ? ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Targets$Javascript$EmittableToJs$makeCall)($env, ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $ref), $args))
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 352:12', (sp_toHuman)($maybeNativeOverride))));
      }))()
      : ((($eaExpression)[0] === "Fn")
        ? ((() => {
          const $eaArgs = ($eaExpression)[1];
          const $body = ($eaExpression)[2];
          const $argsWithNames = ((() => {
            const $zzz = (($index, $$maybeName) => {
              const $re = $$maybeName.first;
              const $maybeName = $$maybeName.second;
              return ((($maybeName)[0] === "Just")
                ? ((() => {
                  const $name = ($maybeName)[1];
                  return ({
                    first: $re,
                    second: $name,
                  });
                }))()
                : ((($maybeName)[0] === "Nothing")
                  ? ({
                    first: $re,
                    second: ("_" + (text_fromNumber)($index)),
                  })
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 365:20', (sp_toHuman)($maybeName))));
            });
            return ((($1) => {
              return ($core$List$indexedMap)($zzz, $1);
            }))($eaArgs);
          }))();
          const $recycledPars = ((($1) => {
            return ($core$List$map)((($$name) => {
              const $name = $$name.second;
              return ($sd0$Types$JavascriptAst$Var)($name);
            }), $1);
          }))(((($1) => {
            return ($core$List$filter)($core$Tuple$first, $1);
          }))($argsWithNames));
          const $statementsRaw = ((() => {
            const $$try4 = ($sd0$Targets$Javascript$EmittableToJs$translateExpression)($env, $body);
            return ((($$try4)[0] === "Inline")
              ? ((() => {
                const $expr = ($$try4)[1];
                return ($core$Core$Cons)(($sd0$Types$JavascriptAst$Return)($expr), $core$Core$Nil);
              }))()
              : ((($$try4)[0] === "Block")
                ? ((() => {
                  const $block = ($$try4)[1];
                  return $block;
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 377:16', (sp_toHuman)($$try4))));
          }))();
          const $statementsFinal = ((sp_equal)($recycledPars, $core$Core$Nil)
            ? $statementsRaw
            : ((() => {
              const $addRecycled = (($stat) => {
                return ((($stat)[0] === "Return")
                  ? ((() => {
                    const $e = ($stat)[1];
                    return ($sd0$Types$JavascriptAst$Return)(($sd0$Types$JavascriptAst$Array)((sp_cons)($e, $recycledPars)));
                  }))()
                  : (true
                    ? $stat
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 391:24', (sp_toHuman)($stat))));
              });
              return ($core$List$map)($addRecycled, $statementsRaw);
            }))());
          return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$BlockLambda)(($core$List$map)($core$Tuple$second, $argsWithNames), $statementsFinal));
        }))()
        : ((($eaExpression)[0] === "LetIn")
          ? ((() => {
            const $inExpression = ($eaExpression)[1].inExpression;
            const $letExpression = ($eaExpression)[1].letExpression;
            const $maybeName = ($eaExpression)[1].maybeName;
            const $type = ($eaExpression)[1].type;
            const $inStatements = ((() => {
              const $$try3 = ($sd0$Targets$Javascript$EmittableToJs$translateExpression)($env, $inExpression);
              return ((($$try3)[0] === "Block")
                ? ((() => {
                  const $stats = ($$try3)[1];
                  return $stats;
                }))()
                : ((($$try3)[0] === "Inline")
                  ? ((() => {
                    const $jaExpression = ($$try3)[1];
                    return ($core$Core$Cons)(($sd0$Types$JavascriptAst$Return)($jaExpression), $core$Core$Nil);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 403:16', (sp_toHuman)($$try3))));
            }))();
            return ((($maybeName)[0] === "Nothing")
              ? ((() => {
                const $$try2 = ($sd0$Targets$Javascript$EmittableToJs$translateExpression)($env, $letExpression);
                return ((($$try2)[0] === "Inline")
                  ? ((() => {
                    const $expr = ($$try2)[1];
                    return ($sd0$Targets$Javascript$EmittableToJs$Block)((sp_cons)(($sd0$Types$JavascriptAst$Eval)($expr), $inStatements));
                  }))()
                  : ((($$try2)[0] === "Block")
                    ? ((() => {
                      const $stats = ($$try2)[1];
                      return ($sd0$Targets$Javascript$EmittableToJs$Block)(($core$List$concat)(($core$Core$Cons)($stats, ($core$Core$Cons)($inStatements, $core$Core$Nil))));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 409:20', (sp_toHuman)($$try2))));
              }))()
              : ((($maybeName)[0] === "Just")
                ? ((() => {
                  const $name = ($maybeName)[1];
                  const $letStatement = ((($2) => {
                    return ($sd0$Types$JavascriptAst$Define)((sp_equal)($type.uni, $sd0$Types$Ast$Uni), $name, $2);
                  }))(((($1) => {
                    return ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $1);
                  }))($letExpression));
                  return ($sd0$Targets$Javascript$EmittableToJs$Block)((sp_cons)($letStatement, $inStatements));
                }))()
                : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 407:12', (sp_toHuman)($maybeName))));
          }))()
          : ((($eaExpression)[0] === "LiteralText")
            ? ((() => {
              const $string = ($eaExpression)[1];
              return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Targets$Javascript$EmittableToJs$literalString)($string));
            }))()
            : ((($eaExpression)[0] === "LiteralNumber")
              ? ((() => {
                const $num = ($eaExpression)[1];
                return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$Literal)((text_fromNumber)($num)));
              }))()
              : ((($eaExpression)[0] === "Conditional")
                ? ((() => {
                  const $test = ($eaExpression)[1];
                  const $true = ($eaExpression)[2];
                  const $false = ($eaExpression)[3];
                  return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$Conditional)(($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $test), ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $true), ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $false)));
                }))()
                : ((($eaExpression)[0] === "And")
                  ? ((() => {
                    const $eaTests = ($eaExpression)[1];
                    const $jaTests = ($core$List$map)((($1) => {
                      return ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $1);
                    }), $eaTests);
                    const $$try1 = ($core$List$reverse)($jaTests);
                    return ((($$try1)[0] === "Nil")
                      ? ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$Literal)("true"))
                      : ((($$try1)[0] === "Cons")
                        ? ((() => {
                          const $head = ($$try1)[1];
                          const $tail = ($$try1)[2];
                          return ($sd0$Targets$Javascript$EmittableToJs$Inline)(((($0) => {
                            return ($core$List$for)($0, $tail, (($test, $expr) => {
                              return ($sd0$Types$JavascriptAst$Binop)("&&", $test, $expr);
                            }));
                          }))($head));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 445:12', (sp_toHuman)($$try1))));
                  }))()
                  : ((($eaExpression)[0] === "ShallowEqual")
                    ? ((() => {
                      const $a = ($eaExpression)[1];
                      const $b = ($eaExpression)[2];
                      return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$Binop)("===", ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $a), ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $b)));
                    }))()
                    : ((($eaExpression)[0] === "LiteralArray")
                      ? ((() => {
                        const $items = ($eaExpression)[1];
                        return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$Array)(((($1) => {
                          return ($core$List$map)((($1) => {
                            return ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $1);
                          }), $1);
                        }))($items)));
                      }))()
                      : ((($eaExpression)[0] === "ArrayAccess")
                        ? ((() => {
                          const $index = ($eaExpression)[1];
                          const $array = ($eaExpression)[2];
                          return ($sd0$Targets$Javascript$EmittableToJs$Inline)(((($1) => {
                            return ($sd0$Targets$Javascript$EmittableToJs$accessArrayIndex)($index, $1);
                          }))(((($1) => {
                            return ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $1);
                          }))($array)));
                        }))()
                        : ((($eaExpression)[0] === "Constructor")
                          ? ((() => {
                            const $name = ($eaExpression)[1];
                            return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Targets$Javascript$EmittableToJs$translateVariable)($env, $name));
                          }))()
                          : ((($eaExpression)[0] === "ConstructorAccess")
                            ? ((() => {
                              const $argIndex = ($eaExpression)[1];
                              const $value = ($eaExpression)[2];
                              return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Targets$Javascript$EmittableToJs$accessArrayIndex)(($argIndex + 1), ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $value)));
                            }))()
                            : ((($eaExpression)[0] === "IsConstructor")
                              ? ((() => {
                                const $name = ($eaExpression)[1];
                                const $eaValue = ($eaExpression)[2];
                                const $jaValue = ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $eaValue);
                                const $jaExpr = (("True" === $name)
                                  ? $jaValue
                                  : (("False" === $name)
                                    ? ($sd0$Types$JavascriptAst$Unop)("!", $jaValue)
                                    : (true
                                      ? ($sd0$Types$JavascriptAst$Binop)("===", ($sd0$Targets$Javascript$EmittableToJs$accessArrayIndex)(0, $jaValue), ($sd0$Targets$Javascript$EmittableToJs$literalString)($name))
                                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 487:16', (sp_toHuman)($name)))));
                                return ($sd0$Targets$Javascript$EmittableToJs$Inline)($jaExpr);
                              }))()
                              : ((($eaExpression)[0] === "LiteralRecord")
                                ? ((() => {
                                  const $maybeExtend = ($eaExpression)[1];
                                  const $attrNamesAndValues = ($eaExpression)[2];
                                  const $obj = ($sd0$Types$JavascriptAst$Record)(((($0) => {
                                    return ($core$List$for)($0, $attrNamesAndValues, (($$name, $d) => {
                                      const $name = $$name.first;
                                      const $value = $$name.second;
                                      return ($core$Dict$insert)($name, ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $value), $d);
                                    }));
                                  }))($core$Dict$empty));
                                  return ((($maybeExtend)[0] === "Nothing")
                                    ? ($sd0$Targets$Javascript$EmittableToJs$Inline)($obj)
                                    : ((($maybeExtend)[0] === "Just")
                                      ? ((() => {
                                        const $extend = ($maybeExtend)[1];
                                        return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$Call)(($sd0$Types$JavascriptAst$Var)("Object.assign"), ($core$Core$Cons)(($sd0$Types$JavascriptAst$Record)($core$Dict$empty), ($core$Core$Cons)(($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $extend), ($core$Core$Cons)($obj, $core$Core$Nil)))));
                                      }))()
                                      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 507:12', (sp_toHuman)($maybeExtend))));
                                }))()
                                : ((($eaExpression)[0] === "RecordAccess")
                                  ? ((() => {
                                    const $attrName = ($eaExpression)[1];
                                    const $value = ($eaExpression)[2];
                                    return ($sd0$Targets$Javascript$EmittableToJs$Inline)(($sd0$Types$JavascriptAst$AccessWithDot)($attrName, ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $value)));
                                  }))()
                                  : ((($eaExpression)[0] === "MissingPattern")
                                    ? ((() => {
                                      const $pos = ($eaExpression)[1];
                                      const $value = ($eaExpression)[2];
                                      const $human = ($sd0$Compiler$Error$posToHuman)($env.errorEnv, $pos);
                                      return ($sd0$Targets$Javascript$EmittableToJs$Inline)(((($1) => {
                                        return ($sd0$Types$JavascriptAst$Call)(($sd0$Types$JavascriptAst$Literal)("sp_throw"), $1);
                                      }))(($core$Core$Cons)(($sd0$Types$JavascriptAst$Literal)("'Missing pattern in try..as'"), ($core$Core$Cons)(($sd0$Types$JavascriptAst$Literal)(("'" + ($human.location + "'"))), ($core$Core$Cons)(($sd0$Types$JavascriptAst$Call)(($sd0$Types$JavascriptAst$Literal)("sp_toHuman"), ($core$Core$Cons)(($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $value), $core$Core$Nil)), $core$Core$Nil)))));
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 341:4', (sp_toHuman)($eaExpression)))))))))))))))))));
});

const $sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression = (($env, $expr) => {
  const $$try1 = ($sd0$Targets$Javascript$EmittableToJs$translateExpression)($env, $expr);
  return ((($$try1)[0] === "Inline")
    ? ((() => {
      const $e = ($$try1)[1];
      return $e;
    }))()
    : ((($$try1)[0] === "Block")
      ? ((() => {
        const $block = ($$try1)[1];
        return ($sd0$Types$JavascriptAst$Call)(($sd0$Types$JavascriptAst$BlockLambda)($core$Core$Nil, $block), $core$Core$Nil);
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 275:4', (sp_toHuman)($$try1))));
});

const $sd0$Targets$Javascript$EmittableToJs$translateArg = (($stuff, $env, $eaExpression) => {
  return ((($eaExpression)[0] === "ArgumentSpend")
    ? ((() => {
      const $e = ($eaExpression)[1];
      return ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $e);
    }))()
    : ((($eaExpression)[0] === "ArgumentRecycle")
      ? ((() => {
        const $attrPath = ($eaExpression)[1];
        const $name = ($eaExpression)[2];
        return ($sd0$Targets$Javascript$EmittableToJs$accessAttrs)($attrPath, ($sd0$Types$JavascriptAst$Var)($name));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 192:4', (sp_toHuman)($eaExpression))));
});

const $sd0$Targets$Javascript$EmittableToJs$binop = (($jsOp) => {
  return ($sd0$Targets$Javascript$EmittableToJs$Override)(({
    call: (($env, $arguments) => {
      return (((($arguments)[0] === "Cons") && (((($arguments)[2])[0] === "Cons") && (((($arguments)[2])[2])[0] === "Nil")))
        ? ((() => {
          const $right = ($arguments)[1];
          const $left = (($arguments)[2])[1];
          return ($sd0$Types$JavascriptAst$Binop)($jsOp, ($sd0$Targets$Javascript$EmittableToJs$translateArg)(({
            nativeBinop: true,
          }), $env, $right), ($sd0$Targets$Javascript$EmittableToJs$translateArg)(({
            nativeBinop: true,
          }), $env, $left));
        }))()
        : (true
          ? (sp_todo)(("compiler bug: wrong number of arguments for binop" + (sp_toHuman)(({
            arguments: $arguments,
            jsOp: $jsOp,
          }))))
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 141:8', (sp_toHuman)($arguments))));
    }),
    value: (($env) => {
      return (sp_todo)(("binop " + ($jsOp + " has no raw value")));
    }),
  }));
});

const $sd0$Targets$Javascript$EmittableToJs$constructor = (($jsValue) => {
  return ($sd0$Targets$Javascript$EmittableToJs$Override)(({
    call: (($env, $args) => {
      return ($sd0$Targets$Javascript$EmittableToJs$makeCall)($env, ($sd0$Types$JavascriptAst$Var)($jsValue), $args);
    }),
    value: (($env) => {
      return ($sd0$Types$JavascriptAst$Var)($jsValue);
    }),
  }));
});

const $sd0$Targets$Javascript$EmittableToJs$function = (($jaName) => {
  return ($sd0$Targets$Javascript$EmittableToJs$Override)(({
    call: (($env, $args) => {
      return ($sd0$Targets$Javascript$EmittableToJs$makeCall)($env, ($sd0$Types$JavascriptAst$Var)($jaName), $args);
    }),
    value: (($env) => {
      return ($sd0$Types$JavascriptAst$Var)($jaName);
    }),
  }));
});

const $sd0$Targets$Javascript$EmittableToJs$unaryMinus = ($sd0$Targets$Javascript$EmittableToJs$Override)(({
  call: (($env, $arguments) => {
    return (((($arguments)[0] === "Cons") && (((($arguments)[1])[0] === "ArgumentSpend") && ((($arguments)[2])[0] === "Nil")))
      ? ((() => {
        const $arg = (($arguments)[1])[1];
        return ($sd0$Types$JavascriptAst$Unop)("-", ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $arg));
      }))()
      : (true
        ? (sp_todo)("compiler bug: wrong number of arguments for unop")
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 124:8', (sp_toHuman)($arguments))));
  }),
  value: (($env) => {
    return (sp_todo)("unaryMinus has no raw value");
  }),
}));

const $sd0$Targets$Javascript$EmittableToJs$unaryPlus = ($sd0$Targets$Javascript$EmittableToJs$Override)(({
  call: (($env, $arguments) => {
    return (((($arguments)[0] === "Cons") && (((($arguments)[1])[0] === "ArgumentSpend") && ((($arguments)[2])[0] === "Nil")))
      ? ((() => {
        const $arg = (($arguments)[1])[1];
        return ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $arg);
      }))()
      : (true
        ? (sp_todo)("compiler bug: wrong number of arguments for unop")
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 108:8', (sp_toHuman)($arguments))));
  }),
  value: (($env) => {
    return (sp_todo)("unaryPlus has no raw value");
  }),
}));

const $sd0$Targets$Javascript$EmittableToJs$coreOverrides = (($emState) => {
  const $corelib = (($m, $n) => {
    return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Core, $m), $n);
  });
  return ([
    ((($1) => {
      return ($core$Dict$mapKeys)((($1) => {
        return ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($emState, $1)), ($emState = (__re__)[1]), (__re__)[0]);
      }), $1);
    }))(($core$Dict$fromList)(($core$Core$Cons)(({
      first: $sd0$Prelude$unaryPlus.usr,
      second: $sd0$Targets$Javascript$EmittableToJs$unaryPlus,
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$unaryMinus.usr,
      second: $sd0$Targets$Javascript$EmittableToJs$unaryMinus,
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$add.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("+"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$multiply.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("*"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$subtract.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("-"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$mutableAssign.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("="),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$mutableAdd.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("+="),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$mutableSubtract.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("-="),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$textConcat.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("+"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$greaterThan.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)(">"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$lesserThan.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("<"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$greaterOrEqualThan.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)(">="),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$lesserOrEqualThan.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("<="),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$or_.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("||"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$and_.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$binop)("&&"),
    }), ($core$Core$Cons)(({
      first: $sd0$Compiler$CoreTypes$true,
      second: ($sd0$Targets$Javascript$EmittableToJs$constructor)("true"),
    }), ($core$Core$Cons)(({
      first: $sd0$Compiler$CoreTypes$false,
      second: ($sd0$Targets$Javascript$EmittableToJs$constructor)("false"),
    }), ($core$Core$Cons)(({
      first: $sd0$Compiler$CoreTypes$noneValue,
      second: ($sd0$Targets$Javascript$EmittableToJs$constructor)("null"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$divide.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_divide"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$listCons.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_cons"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$equal.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_equal"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$notEqual.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_not_equal"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Basics", "modBy"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("basics_modBy"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Basics", "round"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("Math.round"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Basics", "cloneImm"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("basics_cloneImm"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Basics", "cloneUni"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("basics_cloneUni"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$debugLog.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_log"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$debugTodo.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_todo"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$debugToHuman.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_toHuman"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$debugBenchStart.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_benchStart"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$debugBenchStop.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("sp_benchStop"),
    }), ($core$Core$Cons)(({
      first: $sd0$Prelude$compare.usr,
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("basics_compare"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "fromNumber"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_fromNumber"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "toNumber"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_toNumber"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "split"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_split"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "length"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_length"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "slice"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_slice"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "startsWith"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_startsWith"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "startsWithRegex"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_startsWithRegex"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "replaceRegex"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_replaceRegex"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "trimLeft"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_trimLeft"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "dropLeft"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_dropLeft"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Text", "forEach"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("text_forEach"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Hash", "fromList"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("hash_fromList"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Hash", "insert"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("hash_insert"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Hash", "remove"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("hash_remove"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Hash", "get"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("hash_get"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Hash", "for"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("hash_for"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Hash", "each"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("hash_each"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "each"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_each"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "push"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_push"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "pop"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_pop"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "get"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_get"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "set"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_set"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "sortBy"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_sortBy"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "fromList"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_fromList"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("Array", "toList"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("array_toList"),
    }), ($core$Core$Cons)(({
      first: ($corelib)("List", "sortBy"),
      second: ($sd0$Targets$Javascript$EmittableToJs$function)("list_sortBy"),
    }), $core$Core$Nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))),
    $emState,
  ]);
});

const $sd0$Targets$Javascript$EmittableToJs$constructorArgumentName = (($i) => {
  return ("$" + (text_fromNumber)($i));
});

const $sd0$Targets$Javascript$EmittableToJs$translateConstructor = (($emState, $$full) => {
  const $usr = $$full.first;
  const $full = $$full.second;
  const $taType = $full.raw;
  const $$slug = $usr;
  const $slug = ($$slug)[2];
  const $arrayHead = ($sd0$Targets$Javascript$EmittableToJs$literalString)($slug);
  const $definitionBody = ((($taType)[0] === "TypeFn")
    ? ((() => {
      const $pars = ($taType)[1];
      const $out = ($taType)[2];
      const $argNames = ((($1) => {
        return ($core$List$indexedMap)((($index, $name) => {
          return ($sd0$Targets$Javascript$EmittableToJs$constructorArgumentName)(($index + 1));
        }), $1);
      }))($pars);
      return ((($1) => {
        return ($sd0$Types$JavascriptAst$SimpleLambda)($argNames, $1);
      }))(($sd0$Types$JavascriptAst$Array)((sp_cons)($arrayHead, ($core$List$map)($sd0$Types$JavascriptAst$Var, $argNames))));
    }))()
    : (true
      ? ($sd0$Types$JavascriptAst$Array)(($core$Core$Cons)($arrayHead, $core$Core$Nil))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 551:8', (sp_toHuman)($taType))));
  const $usrAsText = ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($emState, $usr)), ($emState = (__re__)[1]), (__re__)[0]);
  return ([
    ($sd0$Types$JavascriptAst$Define)(false, $usrAsText, $definitionBody),
    $emState,
  ]);
});

const $sd0$Targets$Javascript$EmittableToJs$translateDef = (($env, $def) => {
  const $$try1 = ($core$Dict$get)($def.name, $env.overrides);
  return ((($$try1)[0] === "Just")
    ? $core$Maybe$Nothing
    : ((($$try1)[0] === "Nothing")
      ? ($core$Maybe$Just)(($sd0$Types$JavascriptAst$Define)(false, $def.name, ($sd0$Targets$Javascript$EmittableToJs$translateExpressionToExpression)($env, $def.expr)))
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/EmittableToJs.sp 573:4', (sp_toHuman)($$try1))));
});

const $sd0$Targets$Javascript$EmittableToJs$translateAll = (($emState, $pars) => {
  const $$constructors = $pars;
  const $platformOverrides = $$constructors.platformOverrides;
  const $errorEnv = $$constructors.errorEnv;
  const $eaDefs = $$constructors.eaDefs;
  const $constructors = $$constructors.constructors;
  const $jaConstructors = ($core$List$map)((($1) => {
    return ((__re__ = ($sd0$Targets$Javascript$EmittableToJs$translateConstructor)($emState, $1)), ($emState = (__re__)[1]), (__re__)[0]);
  }), $constructors);
  const $env = ({
    errorEnv: $errorEnv,
    overrides: ((($0) => {
      return ($core$List$for)($0, $platformOverrides, (($$runtimeName, $d) => {
        const $usr = $$runtimeName.first;
        const $runtimeName = $$runtimeName.second;
        return ($core$Dict$insert)(((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($emState, $usr)), ($emState = (__re__)[1]), (__re__)[0]), ($sd0$Targets$Javascript$EmittableToJs$function)($runtimeName), $d);
      }));
    }))(((__re__ = ($sd0$Targets$Javascript$EmittableToJs$coreOverrides)($emState)), ($emState = (__re__)[1]), (__re__)[0])),
  });
  const $jaStatements = ($core$List$filterMap)((($1) => {
    return ($sd0$Targets$Javascript$EmittableToJs$translateDef)($env, $1);
  }), $eaDefs);
  return ([
    ($core$List$concat)(($core$Core$Cons)($jaConstructors, ($core$Core$Cons)($jaStatements, $core$Core$Nil))),
    $emState,
  ]);
});

const $sd0$Targets$Javascript$JsToText$id = (($level) => {
  return ($core$Text$repeat)($level, "  ");
});

const $sd0$Targets$Javascript$JsToText$emitBlock = (($l, $block) => {
  const $lines = ((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($1) => {
      return ($sd0$Targets$Javascript$JsToText$emitStatement)(($l + 1), $1);
    }), $1);
  }))($block));
  return ("{\n" + ($lines + ("\n" + (($sd0$Targets$Javascript$JsToText$id)($l) + "}"))));
});

const $sd0$Targets$Javascript$JsToText$emitExpr = (($l, $expression) => {
  return ((($expression)[0] === "Literal")
    ? ((() => {
      const $s = ($expression)[1];
      return $s;
    }))()
    : ((($expression)[0] === "Var")
      ? ((() => {
        const $n = ($expression)[1];
        return $n;
      }))()
      : ((($expression)[0] === "Call")
        ? ((() => {
          const $ref = ($expression)[1];
          const $args = ($expression)[2];
          return ("(" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $ref) + (")(" + (($core$Text$join)(", ", ($core$List$map)((($1) => {
            return ($sd0$Targets$Javascript$JsToText$emitExpr)($l, $1);
          }), $args)) + ")"))));
        }))()
        : ((($expression)[0] === "Unop")
          ? ((() => {
            const $op = ($expression)[1];
            const $left = ($expression)[2];
            return ($op + ("(" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $left) + ")")));
          }))()
          : ((($expression)[0] === "Binop")
            ? ((() => {
              const $op = ($expression)[1];
              const $left = ($expression)[2];
              const $right = ($expression)[3];
              return ("(" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $left) + (" " + ($op + (" " + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $right) + ")"))))));
            }))()
            : ((($expression)[0] === "Mutop")
              ? ((() => {
                const $op = ($expression)[1];
                const $yield = ($expression)[2];
                const $left = ($expression)[3];
                const $right = ($expression)[4];
                return ("(" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $left) + (" " + ($op + (" " + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $right) + (", " + ($yield + ")"))))))));
              }))()
              : ((($expression)[0] === "SimpleLambda")
                ? ((() => {
                  const $params = ($expression)[1];
                  const $expr = ($expression)[2];
                  return ("((" + (($core$Text$join)(", ", $params) + (") => " + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $expr) + ")"))));
                }))()
                : ((($expression)[0] === "BlockLambda")
                  ? ((() => {
                    const $params = ($expression)[1];
                    const $stats = ($expression)[2];
                    return ("((" + (($core$Text$join)(", ", $params) + (") => " + (($sd0$Targets$Javascript$JsToText$emitBlock)($l, $stats) + ")"))));
                  }))()
                  : ((($expression)[0] === "Record")
                    ? ((() => {
                      const $attrs = ($expression)[1];
                      return ((sp_equal)($attrs, $core$Dict$empty)
                        ? "{}"
                        : ((($a) => {
                          return ("({\n" + (($core$Text$join)("\n", $a) + ("\n" + (($sd0$Targets$Javascript$JsToText$id)($l) + "})"))));
                        }))(((($1) => {
                          return ($core$List$map)((($$key) => {
                            const $key = $$key.first;
                            const $value = $$key.second;
                            return (($sd0$Targets$Javascript$JsToText$id)(($l + 1)) + ($key + (": " + (($sd0$Targets$Javascript$JsToText$emitExpr)(($l + 1), $value) + ","))));
                          }), $1);
                        }))(((($1) => {
                          return (list_sortBy)($core$Tuple$first, $1);
                        }))(($core$Dict$toList)($attrs)))));
                    }))()
                    : ((($expression)[0] === "AccessWithDot")
                      ? ((() => {
                        const $name = ($expression)[1];
                        const $e = ($expression)[2];
                        return (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $e) + ("." + $name));
                      }))()
                      : ((($expression)[0] === "AccessWithBrackets")
                        ? ((() => {
                          const $i = ($expression)[1];
                          const $expr = ($expression)[2];
                          return ("(" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $expr) + (")[" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $i) + "]"))));
                        }))()
                        : ((($expression)[0] === "Conditional")
                          ? ((() => {
                            const $p = ($expression)[1];
                            const $true = ($expression)[2];
                            const $false = ($expression)[3];
                            return (("(" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $p) + "\n")) + ((($sd0$Targets$Javascript$JsToText$id)(($l + 1)) + ("? " + ($sd0$Targets$Javascript$JsToText$emitExpr)(($l + 1), $true))) + ("\n" + ((($sd0$Targets$Javascript$JsToText$id)(($l + 1)) + (": " + ($sd0$Targets$Javascript$JsToText$emitExpr)(($l + 1), $false))) + ")"))));
                          }))()
                          : ((($expression)[0] === "Array")
                            ? ((() => {
                              const $items = ($expression)[1];
                              return ((sp_equal)($items, $core$Core$Nil)
                                ? "[]"
                                : ((($0) => {
                                  return ((($a) => {
                                    return ("([\n" + (($core$Text$join)("\n", $a) + ("\n" + (($sd0$Targets$Javascript$JsToText$id)($l) + "])"))));
                                  }))($0);
                                }))(((($1) => {
                                  return ($core$List$map)((($i) => {
                                    return (($sd0$Targets$Javascript$JsToText$id)(($l + 1)) + (($sd0$Targets$Javascript$JsToText$emitExpr)(($l + 1), $i) + ","));
                                  }), $1);
                                }))($items)));
                            }))()
                            : ((($expression)[0] === "Comma")
                              ? ((() => {
                                const $expr = ($expression)[1];
                                return ("(" + (($core$Text$join)(", ", ($core$List$map)((($1) => {
                                  return ($sd0$Targets$Javascript$JsToText$emitExpr)($l, $1);
                                }), $expr)) + ")"));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/JsToText.sp 43:4', (sp_toHuman)($expression))))))))))))))));
});

const $sd0$Targets$Javascript$JsToText$emitStatement = (($l, $stat) => {
  const $std = (($mid, $expr) => {
    return (($sd0$Targets$Javascript$JsToText$id)($l) + ($mid + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $expr) + ";")));
  });
  return ((($stat)[0] === "Eval")
    ? ((() => {
      const $e = ($stat)[1];
      return ($std)("", $e);
    }))()
    : ((($stat)[0] === "Return")
      ? ((() => {
        const $e = ($stat)[1];
        return ($std)("return ", $e);
      }))()
      : ((($stat)[0] === "Define")
        ? ((() => {
          const $isReassignable = ($stat)[1];
          const $name = ($stat)[2];
          const $e = ($stat)[3];
          const $modifier = ($isReassignable
            ? "let"
            : "const");
          return ($std)(($modifier + (" " + ($name + " = "))), $e);
        }))()
        : ((($stat)[0] === "If")
          ? ((() => {
            const $condition = ($stat)[1];
            const $block = ($stat)[2];
            return (($sd0$Targets$Javascript$JsToText$id)($l) + ("if (" + (($sd0$Targets$Javascript$JsToText$emitExpr)($l, $condition) + (") " + ($sd0$Targets$Javascript$JsToText$emitBlock)($l, $block)))));
          }))()
          : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Targets/Javascript/JsToText.sp 15:4', (sp_toHuman)($stat))))));
});

const $sd0$Targets$Javascript$Runtime$listCons = "Cons";

const $sd0$Targets$Javascript$Runtime$listNil = "Nil";

const $sd0$Targets$Javascript$Runtime$nativeDefinitions = ("let __re__;\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n/*  HACK\n\n    TODO this is super brittle\n    once we have a proper Platform system in place, the platform can probably\n    use its internal Meta to figure out the proper constructor\n\n*/\nconst maybe_nothing = [ \"Nothing\" ];\nconst maybe_just = (a) => [ \"Just\", a ];\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a, b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i], b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k], b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a, b) => {\n  return !sp_equal(a, b);\n}\n\n\nconst basics_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = basics_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = basics_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (right, left) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\n// TODO remove this and handle it like any other op?\nconst basics_modBy = (a, b) => b % a;\n\n\nconst basics_cloneImm = sp_clone;\n\n\nconst basics_cloneUni = (uni) =>\n    [ sp_clone(uni), uni ];\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message, thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\n// TODO how should benchmark work in a browser?\ntypeof process !== 'undefined' && process.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.info(\"\");\n        console.info(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.info(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst id = (n) => '    '.repeat(n);\n\n\nconst sp_toHuman = (a, l = 0) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a, l) || sp_toHumanAsUnion(a, l);\n\n  if (typeof a === 'function') {\n    return '<fn ' + a.length + '>';\n  }\n\n  if (typeof a === 'object') {\n    let acc = '{\\n';\n    for (let key in a)\n        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\\n';\n\n    return acc + id(l) + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a, l) => {\n\n  if (a.length === 1) {\n      return a[0];\n  }\n\n  let acc = a[0] + '\\n';\n\n  a.slice(1).forEach(arg => {\n\n      const sub = sp_toHuman(arg, l + 1);\n      if (!sub.startsWith('{') && sub.indexOf('\\n') > -1)\n          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\\n';\n      else\n          acc += id(l + 1) + sub + '\\n';\n\n  })\n\n  return acc;\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list, l) => {\n  if (list[0] === '" + ($sd0$Targets$Javascript$Runtime$listCons + ("' && list.length === 3) {\n    arrayAccum.push(sp_toHuman(list[1], l));\n    return sp_toHumanAsList(arrayAccum, list[2], l);\n  }\n\n  if (list[0] === '" + ($sd0$Targets$Javascript$Runtime$listNil + ("')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ? maybe_nothing : maybe_just(n);\n}\n\nconst text_split = (separator, target) => arrayToListLow(target.split(separator));\n\nconst text_length = (s) => s.length;\n\nconst text_slice = (start, end, s) => s.slice(start, end);\n\nconst text_startsWith = (sub, s) => s.startsWith(sub);\n\nconst text_startsWithRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp('^' + regex);\n  } catch (e) {\n    return () => \"\"\n  }\n\n  return (s) => {\n    let m = s.match(re);\n    return m ? m[0] : \"\";\n  }\n}\n\nconst text_replaceRegex = (regex) => {\n  let re;\n  try {\n    re = new RegExp(regex, 'g');\n  } catch (e) {\n    return () => \"\"\n  }\n\n  return (replacer, s) => s.replace(re, replacer);\n}\n\nconst text_trimLeft = (s) => s.trimLeft();\n\nconst text_dropLeft = (n, s) => s.slice(n);\n\nconst text_forEach = (s, f) => {\n  for (let i of s) f(i);\n  return null;\n}\n\n\n//\n// Hashes\n//\n\nconst hash_fromList = (list) => {\n  const hash = {};\n\n  // TODO iteration instead of recursion\n  const rec = (ls) => {\n    if (ls[0] === '" + ($sd0$Targets$Javascript$Runtime$listNil + ("')\n      return hash;\n\n    const { first, second } = ls[1];\n\n    hash[JSON.stringify(first)] = [first, second];\n\n    return rec(ls[2]);\n  };\n\n  return rec(list);\n}\n\n\nconst hash_insert = (hash, key, value) => {\n    hash[JSON.stringify(key)] = [key, value];\n    return [null, hash];\n}\n\n\nconst hash_remove = (hash, key) => {\n    delete hash[JSON.stringify(key)];\n    return [null, hash];\n}\n\n\nconst hash_get = (hash, key) => {\n    const r = hash[JSON.stringify(key)];\n    return [r === undefined ? maybe_nothing : maybe_just(r[1]), hash];\n}\n\n\nconst hash_for = (hash, f, acc) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        acc = f(kv[0], kv[1], acc);\n    }\n    return [acc, hash];\n}\n\n\nconst hash_each = (hash, f) => {\n    for (let k in hash) {\n        const kv = hash[k];\n        f(kv[0], kv[1]);\n    }\n    return [null, hash];\n}\n\n\n//\n// Arrays\n//\n\nconst array_each = (array, f) => {\n    array.forEach(f);\n    return [null, array];\n}\n\nconst array_push = (array, item) => {\n    array.push(item);\n    return [null, array];\n}\n\nconst array_pop = (a) => {\n    return [a.length ? maybe_just(a.pop()) : maybe_nothing, a];\n}\n\nconst array_get = (array, index) => {\n    const r = array[index];\n    return [r === undefined ? maybe_nothing : maybe_just(r), array];\n}\n\nconst array_set = (a, index, item) => {\n    if (index < 0) return false;\n    if (index >= a.length) return [false, a];\n    a[index] = item;\n    return [true, a];\n}\n\nconst array_sortBy = (arr, f) => {\n    arr.sort((a, b) => basics_compare(f(a), f(b)));\n    return [null, arr];\n}\n\nconst arrayToListLow = (arr) => {\n  const length = arr.length;\n  let list = [ '" + ($sd0$Targets$Javascript$Runtime$listNil + ("' ];\n  for (let i = length - 1; i >= 0; i--) {\n      list = [ '" + ($sd0$Targets$Javascript$Runtime$listCons + ("', arr[i], list ];\n  }\n  return list;\n}\n\nconst array_toList = (arr) => [arrayToListLow(arr), arr];\n\n\nconst arrayFromListLow = (list) => {\n  const array = [];\n  const rec = (ls) => {\n    if (ls[0] === '" + ($sd0$Targets$Javascript$Runtime$listNil + ("')\n      return array;\n\n    array.push(ls[1]);\n    return rec(ls[2]);\n  };\n\n  return rec(list);\n}\n\nconst array_fromList = arrayFromListLow;\n\n\n//\n// Lists\n//\n\n\nconst sp_cons = (item, list) => {\n  return [ '" + ($sd0$Targets$Javascript$Runtime$listCons + "', item, list];\n}\n\nconst list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f(a), f(b))));\n    "))))))))))))));

const $sd0$Platforms$Browser$compile = (($getRidOfMe, $targetUsr, $emState, $emittableStatements) => {
  const $$constructors = $getRidOfMe;
  const $eenv = $$constructors.errorEnv;
  const $constructors = $$constructors.constructors;
  const $jaStatements = ((__re__ = ($sd0$Targets$Javascript$EmittableToJs$translateAll)($emState, ({
    constructors: $constructors,
    eaDefs: $emittableStatements,
    errorEnv: $eenv,
    platformOverrides: $sd0$Platforms$Browser$overrides,
  }))), ($emState = (__re__)[1]), (__re__)[0]);
  const $statements = ((($1) => {
    return ($core$Text$join)("\n\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($1) => {
      return ($sd0$Targets$Javascript$JsToText$emitStatement)(0, $1);
    }), $1);
  }))($jaStatements));
  return ([
    ($sd0$Platforms$Browser$header + ($sd0$Targets$Javascript$Runtime$nativeDefinitions + ($sd0$Platforms$Browser$runtime + ($statements + ((__re__ = ($sd0$Platforms$Browser$footer)($emState, $targetUsr)), ($emState = (__re__)[1]), (__re__)[0]))))),
    $emState,
  ]);
});

const $sd0$Platforms$Browser$modules = "\nlibrary =\n    source = \"core:browser\"\n\n    module =\n        path = Browser";

const $sd0$Platforms$Browser$platform = ({
  compile: $sd0$Platforms$Browser$compile,
  defaultModules: ($sd0$DefaultModules$asText + $sd0$Platforms$Browser$modules),
  defaultOutputPath: "index.js",
  name: "browser",
  quickstart: "TODO",
});

const $sd0$Platforms$Posix$header = "#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096\n\n//Error.stackTraceLimit = 100;\n\nconst { performance } = require('perf_hooks');\n\n";

const $sd0$Platforms$Posix$overrides = ((() => {
  const $ioModule = (($1) => {
    return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Posix, "IO"), $1);
  });
  const $pathModule = (($1) => {
    return ($sd0$Types$Meta$USR)(($sd0$Types$Meta$UMR)($sd0$Types$Meta$Posix, "Path"), $1);
  });
  return ($core$Core$Cons)(({
    first: ($ioModule)("parallel"),
    second: "io_parallel",
  }), ($core$Core$Cons)(({
    first: ($ioModule)("readDir"),
    second: "io_readDir",
  }), ($core$Core$Cons)(({
    first: ($ioModule)("readFile"),
    second: "io_readFile",
  }), ($core$Core$Cons)(({
    first: ($ioModule)("writeFile"),
    second: "io_writeFile",
  }), ($core$Core$Cons)(({
    first: ($ioModule)("writeStdout"),
    second: "io_writeStdout",
  }), ($core$Core$Cons)(({
    first: ($ioModule)("writeStderr"),
    second: "io_writeStderr",
  }), ($core$Core$Cons)(({
    first: ($pathModule)("dirname"),
    second: "path_dirname",
  }), ($core$Core$Cons)(({
    first: ($pathModule)("resolve"),
    second: "path_resolve",
  }), $core$Core$Nil))))))));
}))();

const $sd0$Platforms$Posix$posixRuntime = "\n//\n// Platform: IO\n//\nconst fs = require('fs');\nconst path = require('path');\n\nconst io_wrap = (f) => [ \"IO.IO\", f ];\n\nconst io_parallel = (iosAsList) => io_wrap((never) => {\n    // as [IO a]: IO [a]\n\n    const ios = arrayFromListLow(iosAsList);\n\n    // TODO actually run them in parallel!\n\n    let arr = [];\n    for (let io of ios) {\n        const r = io[1](never);\n        if (r[0] === \"Ok\")\n            arr.push(r[1]);\n        else\n            return $core$Result$Err(r[1]);\n    }\n\n    return $core$Result$Ok(arrayToListLow(arr));\n});\n\n\nconst io_readDir = (dirPath) => io_wrap((never) => {\n    // as Text: IO [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return $core$Result$Err(e.message);\n    }\n\n    return $core$Result$Ok(arrayToListLow(entries.map((dirent) => ({\n        first: dirent.isDirectory(),\n        second: dirent.name,\n    }))));\n});\n\n\nconst io_readFile = (path) => io_wrap((never) => {\n    // as Text: IO Text\n\n    var content;\n    try {\n        content = fs.readFileSync(path, 'utf8');\n    } catch (e) {\n        return $core$Result$Err(e.message);\n    }\n\n    return $core$Result$Ok(content);\n});\n\n\nconst io_writeFile = (path, content) => io_wrap((never) => {\n    // as Text: Text: IO Int\n\n    try {\n        fs.writeFileSync(path, content);\n    } catch (e) {\n        return $core$Result$Err(e.message);\n    }\n\n    return $core$Result$Ok(0);\n});\n\n\nconst io_writeStdout = (content) => io_wrap((never) => {\n    // as Text: IO Int\n\n    console.info(content);\n    return $core$Result$Ok(0);\n});\n\n\nconst io_writeStderr = (content) => io_wrap((never) => {\n    // as Text: IO Int\n\n    console.error(content);\n    return $core$Result$Ok(-1);\n});\n\n\nconst path_resolve = (p) => path.resolve(...arrayFromListLow(p));\n\n\nconst path_dirname = path.dirname;\n";

const $sd0$Platforms$Posix$compile = (($getRidOfMe, $targetUsr, $emState, $emittableStatements) => {
  const $$constructors = $getRidOfMe;
  const $eenv = $$constructors.errorEnv;
  const $constructors = $$constructors.constructors;
  (sp_log)("Creating JS AST...", "");
  const $jaStatements = ((__re__ = ($sd0$Targets$Javascript$EmittableToJs$translateAll)($emState, ({
    constructors: $constructors,
    eaDefs: $emittableStatements,
    errorEnv: $eenv,
    platformOverrides: $sd0$Platforms$Posix$overrides,
  }))), ($emState = (__re__)[1]), (__re__)[0]);
  (sp_log)("Emitting JS...", "");
  const $callMain = ("const args = arrayToListLow(process.argv.slice(1));\nconst out = " + (((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($emState, $targetUsr)), ($emState = (__re__)[1]), (__re__)[0]) + "({}, args)[1]('never');\n        if (out[0] === 'Ok') {\n            process.exitCode = out[1];\n        } else {\n            console.error(out[1]);\n            process.exitCode = 1;\n        }\n        "));
  const $statements = ((($1) => {
    return ($core$Text$join)("\n\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($1) => {
      return ($sd0$Targets$Javascript$JsToText$emitStatement)(0, $1);
    }), $1);
  }))($jaStatements));
  return ([
    ($sd0$Platforms$Posix$header + ($sd0$Targets$Javascript$Runtime$nativeDefinitions + ($sd0$Platforms$Posix$posixRuntime + ($statements + $callMain)))),
    $emState,
  ]);
});

const $sd0$Platforms$Posix$posixModules = "\nlibrary =\n    source = \"core:posix\"\n\n    module =\n        path = IO\n        globalTypes = IO\n\n    module =\n        path = Path";

const $sd0$Platforms$Posix$platform = ({
  compile: $sd0$Platforms$Posix$compile,
  defaultModules: ($sd0$DefaultModules$asText + $sd0$Platforms$Posix$posixModules),
  defaultOutputPath: "nodeExecutable.js",
  name: "posix",
  quickstart: "TODO",
});

const $sd0$Platforms$RawJavaScript$compile = (($getRidOfMe, $targetUsr, $emState, $emittableStatements) => {
  const $$constructors = $getRidOfMe;
  const $eenv = $$constructors.errorEnv;
  const $constructors = $$constructors.constructors;
  (sp_log)("Creating JS AST...", "");
  const $jaStatements = ((__re__ = ($sd0$Targets$Javascript$EmittableToJs$translateAll)($emState, ({
    constructors: $constructors,
    eaDefs: $emittableStatements,
    errorEnv: $eenv,
    platformOverrides: $core$Core$Nil,
  }))), ($emState = (__re__)[1]), (__re__)[0]);
  (sp_log)("Emitting JS...", "");
  const $statements = ((($1) => {
    return ($core$Text$join)("\n\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($1) => {
      return ($sd0$Targets$Javascript$JsToText$emitStatement)(0, $1);
    }), $1);
  }))($jaStatements));
  const $main = ((__re__ = ($sd0$Compiler$MakeEmittable$translateUsr)($emState, $targetUsr)), ($emState = (__re__)[1]), (__re__)[0]);
  return ([
    ("(function() {\n" + ($sd0$Targets$Javascript$Runtime$nativeDefinitions + ($statements + ("\n return " + ($main + ";\n })();"))))),
    $emState,
  ]);
});

const $sd0$Platforms$RawJavaScript$platform = ({
  compile: $sd0$Platforms$RawJavaScript$compile,
  defaultModules: $sd0$DefaultModules$asText,
  defaultOutputPath: "squarepants.mjs",
  name: "rawjs",
  quickstart: "TODO",
});

const $sd0$Main$availablePlatforms = ($core$Core$Cons)($sd0$Platforms$Posix$platform, ($core$Core$Cons)($sd0$Platforms$RawJavaScript$platform, ($core$Core$Cons)($sd0$Platforms$Browser$platform, $core$Core$Nil)));

const $sd0$Main$cliDefaults = ({
  platform: $sd0$Platforms$Posix$platform,
});

const $sd0$Main$parsePlatformName = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "Nothing")
    ? ($core$Result$Err)("Please specify a platform name, for example: `--platform=posix`")
    : ((($maybeValue)[0] === "Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        const $$try1 = ($core$List$find)((($p) => {
          return (sp_equal)($p.name, $value);
        }), $sd0$Main$availablePlatforms);
        return ((($$try1)[0] === "Nothing")
          ? ($core$Result$Err)(("I don't know this platform name: `" + ($value + ("`\n\n  Valid platform names are:\n\n                    " + ((($1) => {
            return ($core$Text$join)("\n", $1);
          }))(($core$List$map)((($p) => {
            return ("    " + $p.name);
          }), $sd0$Main$availablePlatforms))))))
          : ((($$try1)[0] === "Just")
            ? ((() => {
              const $platform = ($$try1)[1];
              return ($core$Result$Ok)(((() => {
                const $0 = $cliState;
                return (Object.assign)({}, $0, ({
                  platform: $platform,
                }));
              }))());
            }))()
            : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 157:12', (sp_toHuman)($$try1))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 152:4', (sp_toHuman)($maybeValue))));
});

const $sd0$Main$cliOptions = ($core$Core$Cons)(({
  info: "select build platform",
  name: "--platform",
  parser: $sd0$Main$parsePlatformName,
}), $core$Core$Nil);

const $sd0$Main$indent = (($s) => {
  return ((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($l) => {
      return ("  " + $l);
    }), $1);
  }))(((($1) => {
    return (text_split)("\n", $1);
  }))($s)));
});

const $sd0$Main$parseArguments = (($options, $args, $initState) => {
  const $$optionTexts = ($core$List$partition)((($1) => {
    return (text_startsWith)("--", $1);
  }), $args);
  const $others = $$optionTexts.second;
  const $optionTexts = $$optionTexts.first;
  const $findOption = (($optionText, $state) => {
    const $$try1 = (text_split)("=", $optionText);
    return ((($$try1)[0] === "Nil")
      ? ($core$Result$Ok)($state)
      : ((($$try1)[0] === "Cons")
        ? ((() => {
          const $optionName = ($$try1)[1];
          const $rest = ($$try1)[2];
          const $$try2 = ($core$List$find)((($o) => {
            return (sp_equal)($o.name, $optionName);
          }), $options);
          return ((($$try2)[0] === "Nothing")
            ? ($core$Result$Err)(("Unknown option " + $optionName))
            : ((($$try2)[0] === "Just")
              ? ((() => {
                const $option = ($$try2)[1];
                const $value = ((sp_equal)($rest, $core$Core$Nil)
                  ? $core$Maybe$Nothing
                  : ($core$Maybe$Just)(($core$Text$join)("=", $rest)));
                return ($option.parser)($value, $state);
              }))()
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 45:16', (sp_toHuman)($$try2))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 40:8', (sp_toHuman)($$try1))));
  });
  return ((($1) => {
    return ($core$Result$map)((($1) => {
      return ($core$Tuple$pair)($others, $1);
    }), $1);
  }))(((($0) => {
    return ($core$List$forRes)($0, $optionTexts, $findOption);
  }))($initState));
});

const $sd0$Main$order = (($outcome) => {
  return ((($outcome)[0] === "Success")
    ? 0
    : ((($outcome)[0] === "Skipped")
      ? 1
      : ((($outcome)[0] === "Error")
        ? 2
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 88:4', (sp_toHuman)($outcome)))));
});

const $sd0$Term$green = ($sd0$Term$color)("\x1b[32m");

const $sd0$Main$testOutcomeToText = (($name, $code, $outcome) => {
  return ((($outcome)[0] === "Success")
    ? ($sd0$Term$green)(("* PASS: " + $name))
    : ((($outcome)[0] === "Skipped")
      ? ($sd0$Term$yellow)(("* skip: " + $name))
      : ((($outcome)[0] === "Error")
        ? ((() => {
          const $error = ($outcome)[1];
          return (($sd0$Term$red)(("FAIL ! " + $name)) + ("\n" + (($sd0$Main$indent)($code) + ("\n" + ($sd0$Main$indent)($error)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 75:4', (sp_toHuman)($outcome)))));
});

const $sd0$Test$getName = (($test) => {
  return ((($test)[0] === "Single")
    ? ((() => {
      const $n = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return $n;
    }))()
    : ((($test)[0] === "Group")
      ? ((() => {
        const $n = ($test)[1];
        const $ls = ($test)[2];
        return $n;
      }))()
      : ((($test)[0] === "NotNow")
        ? ((() => {
          const $t = ($test)[1];
          return ($sd0$Test$getName)($t);
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 149:4', (sp_toHuman)($test)))));
});

const $sd0$Test$outcomesRec = (($path, $test, $accum) => {
  return ((($test)[0] === "Single")
    ? ((() => {
      const $name = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return (sp_cons)(({
        code: $code,
        getOutcome: $f,
        name: ($path + $name),
      }), $accum);
    }))()
    : ((($test)[0] === "NotNow")
      ? ((() => {
        const $t = ($test)[1];
        const $thing = ({
          code: "",
          getOutcome: ((_0) => {
            return $sd0$Test$Skipped;
          }),
          name: ($path + ($sd0$Test$getName)($t)),
        });
        return (sp_cons)($thing, $accum);
      }))()
      : ((($test)[0] === "Group")
        ? ((() => {
          const $pathSegment = ($test)[1];
          const $ts = ($test)[2];
          return ($core$List$for)($accum, $ts, (($1, $2) => {
            return ($sd0$Test$outcomesRec)(($path + ($pathSegment + " / ")), $1, $2);
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 134:4', (sp_toHuman)($test)))));
});

const $sd0$Test$flattenAndRun = (($tests) => {
  const $flattened = ((($1) => {
    return ($core$List$map)((($r) => {
      return (($core$Text$contains)("SKIP", $r.name)
        ? ((() => {
          const $0 = $r;
          return (Object.assign)({}, $0, ({
            getOutcome: ((_0) => {
              return $sd0$Test$Skipped;
            }),
          }));
        }))()
        : $r);
    }), $1);
  }))(($sd0$Test$outcomesRec)("", ($sd0$Test$Group)("", $tests), $core$Core$Nil));
  const $onlies = ((($1) => {
    return ($core$List$filter)((($r) => {
      return ($core$Text$contains)("ONLY", $r.name);
    }), $1);
  }))($flattened);
  const $runnable = ((sp_not_equal)($onlies, $core$Core$Nil)
    ? $onlies
    : $flattened);
  const $runTest = (($r) => {
    const $$code = $r;
    const $name = $$code.name;
    const $getOutcome = $$code.getOutcome;
    const $code = $$code.code;
    return ({
      code: $code,
      name: $name,
      outcome: ($getOutcome)(null),
    });
  });
  return ($core$List$map)($runTest, $runnable);
});

const $sd0$Main$selftestMain = ((_0) => {
  return (io_writeStdout)(((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($x) => {
      return ($sd0$Main$testOutcomeToText)($x.name, $x.code, $x.outcome);
    }), $1);
  }))(((($1) => {
    return (list_sortBy)((($x) => {
      return ({
        first: ($sd0$Main$order)($x.outcome),
        second: $x.name,
      });
    }), $1);
  }))(($sd0$Test$flattenAndRun)($sd0$Main$allTests)))));
});

const $sd0$Main$main = (($env, $args) => {
  const $$try1 = ($sd0$Main$parseArguments)($sd0$Main$cliOptions, $args, $sd0$Main$cliDefaults);
  return ((($$try1)[0] === "Err")
    ? ((() => {
      const $message = ($$try1)[1];
      return ($posix$IO$fail)($message);
    }))()
    : ((($$try1)[0] === "Ok")
      ? ((() => {
        const $args = ($$try1)[1].first;
        const $cliState = ($$try1)[1].second;
        return (((($args)[0] === "Cons") && (((($args)[2])[0] === "Cons") && ("selftest" === (($args)[2])[1])))
          ? ((() => {
            const $self = ($args)[1];
            const $tail = (($args)[2])[2];
            return ($sd0$Main$selftestMain)(null);
          }))()
          : (((($args)[0] === "Cons") && ((($args)[2])[0] === "Cons"))
            ? ((() => {
              const $self = ($args)[1];
              const $head = (($args)[2])[1];
              const $tail = (($args)[2])[2];
              const $mainModulePath = $head;
              const $maybeOutputPath = ($core$List$head)($tail);
              return ($sd0$Compile$compileMain)(({
                entryModulePath: $mainModulePath,
                env: $env,
                maybeOutputPath: $maybeOutputPath,
                platform: $cliState.platform,
                selfPath: $self,
              }));
            }))()
            : (true
              ? (io_writeStdout)("\nHi! This is the Squarepants compiler!\n\nTo compile something, write:\n\n    squarepants pathToMainModule.sp\n")
              : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 217:12', (sp_toHuman)($args)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 212:4', (sp_toHuman)($$try1))));
});

const $sd0$Main$parseCli = (($args) => {
  return (((($args)[0] === "Cons") && (((($args)[2])[0] === "Cons") && ("selftest" === (($args)[2])[1])))
    ? ((() => {
      const $self = ($args)[1];
      const $tail = (($args)[2])[2];
      return $sd0$Main$Selftest;
    }))()
    : (((($args)[0] === "Cons") && ((($args)[2])[0] === "Cons"))
      ? ((() => {
        const $self = ($args)[1];
        const $head = (($args)[2])[1];
        const $tail = (($args)[2])[2];
        return ($sd0$Main$Compile)(({
          mainModulePath: $head,
          maybeOutputPath: ($core$List$head)($tail),
          self: $self,
        }));
      }))()
      : (true
        ? $sd0$Main$Help
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Main.sp 188:4', (sp_toHuman)($args)))));
});

const $sd0$SPLib$Parser$higherOr = (($parser) => {
  return (($higher) => {
    return ($sd0$SPLib$Parser$oneOf)(($core$Core$Cons)($higher, ($core$Core$Cons)($parser, $core$Core$Nil)));
  });
});

const $sd0$SPLib$Parser$map = (($f, $p) => {
  return (($sd0$SPLib$Parser$andThen)((($b) => {
    return ($sd0$SPLib$Parser$accept)(($f)($b));
  })))($p);
});

const $sd0$SPLib$Parser$tuple2 = (($pa, $pb) => {
  return (($sd0$SPLib$Parser$andThen)((($a) => {
    return (($sd0$SPLib$Parser$andThen)((($b) => {
      return ($sd0$SPLib$Parser$accept)(({
        first: $a,
        second: $b,
      }));
    })))($pb);
  })))($pa);
});

const $sd0$SPLib$Parser$oneOrMore = (($p) => {
  return ($sd0$SPLib$Parser$tuple2)($p, ($sd0$SPLib$Parser$zeroOrMore)($p));
});

const $sd0$SPLib$Parser$tuple3 = (($pa, $pb, $pc) => {
  return (($sd0$SPLib$Parser$andThen)((($a) => {
    return (($sd0$SPLib$Parser$andThen)((($b) => {
      return (($sd0$SPLib$Parser$andThen)((($c) => {
        return ($sd0$SPLib$Parser$accept)(({
          first: $a,
          second: $b,
          third: $c,
        }));
      })))($pc);
    })))($pb);
  })))($pa);
});

const $sd0$SPON$logHead = (($statements) => {
  ((($statements)[0] === "Cons")
    ? ((() => {
      const $head = ($statements)[1];
      const $tail = ($statements)[2];
      (sp_log)("LOG", $head);
      return null;
    }))()
    : ((($statements)[0] === "Nil")
      ? (sp_log)("LOG", null)
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/SPON.sp 88:4', (sp_toHuman)($statements))));
  return ($sd0$SPON$Accepted)($statements, null);
});

const $sd0$TempMain$allTests = ($core$Core$Cons)($sd0$Compiler$TypeCheck_Test$tests, $core$Core$Nil);

const $sd0$TempMain$indent = (($s) => {
  return ((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($l) => {
      return ("  " + $l);
    }), $1);
  }))(((($1) => {
    return (text_split)("\n", $1);
  }))($s)));
});

const $sd0$TempMain$order = (($outcome) => {
  return ((($outcome)[0] === "Success")
    ? 0
    : ((($outcome)[0] === "Skipped")
      ? 1
      : ((($outcome)[0] === "Error")
        ? 2
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/TempMain.sp 43:4', (sp_toHuman)($outcome)))));
});

const $sd0$TempMain$testOutcomeToText = (($name, $code, $outcome) => {
  return ((($outcome)[0] === "Success")
    ? ($sd0$Term$green)(("* PASS: " + $name))
    : ((($outcome)[0] === "Skipped")
      ? ($sd0$Term$yellow)(("* skip: " + $name))
      : ((($outcome)[0] === "Error")
        ? ((() => {
          const $error = ($outcome)[1];
          return (($sd0$Term$red)(("FAIL ! " + $name)) + ("\n" + (($sd0$TempMain$indent)($code) + ("\n" + ($sd0$TempMain$indent)($error)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/TempMain.sp 30:4', (sp_toHuman)($outcome)))));
});

const $sd0$TempMain$selftestMain = ((_0) => {
  return (io_writeStdout)(((($1) => {
    return ($core$Text$join)("\n", $1);
  }))(((($1) => {
    return ($core$List$map)((($x) => {
      return ($sd0$TempMain$testOutcomeToText)($x.name, $x.code, $x.outcome);
    }), $1);
  }))(((($1) => {
    return (list_sortBy)((($x) => {
      return ({
        first: ($sd0$TempMain$order)($x.outcome),
        second: $x.name,
      });
    }), $1);
  }))(((($0) => {
    return ($sd0$Test$flattenAndRun)($0);
  }))($sd0$TempMain$allTests)))));
});

const $sd0$TempMain$main = (($env, $args) => {
  return ($sd0$TempMain$selftestMain)(null);
});

const $sd0$Test$errorsFirst = (($outcome) => {
  return ((($outcome)[0] === "Error")
    ? ((() => {
      const $e = ($outcome)[1];
      return -(1);
    }))()
    : ((($outcome)[0] === "Skipped")
      ? 0
      : ((($outcome)[0] === "Success")
        ? 1
        : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Test.sp 186:4', (sp_toHuman)($outcome)))));
});

const $sd0$Types$Pos$drop = (($x) => {
  const $$a = $x;
  const $a = ($$a)[2];
  const $pos = ($$a)[1];
  return $a;
});

const $sd0$Types$Pos$end = (($pos) => {
  return ((($pos)[0] === "P")
    ? ((() => {
      const $m = ($pos)[1];
      const $s = ($pos)[2];
      const $e = ($pos)[3];
      return $e;
    }))()
    : (true
      ? 0
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/Pos.sp 38:4', (sp_toHuman)($pos))));
});

const $sd0$Types$Pos$start = (($pos) => {
  return ((($pos)[0] === "P")
    ? ((() => {
      const $m = ($pos)[1];
      const $s = ($pos)[2];
      const $e = ($pos)[3];
      return $s;
    }))()
    : (true
      ? 0
      : (sp_throw)('Missing pattern in try..as', '/home/nw/stuff/unstable/src/Types/Pos.sp 31:4', (sp_toHuman)($pos))));
});

const $sd0$Types$TypedAst$initModule = (($asText, $umr) => {
  return ({
    asText: $asText,
    umr: $umr,
    valueDefs: $core$Dict$empty,
  });
});

const $sd1$Uniqueness$valueTest = (($1, $2, $3) => {
  return ($sd0$Test$valueTest)(sp_toHuman, $1, $2, $3);
});const args = arrayToListLow(process.argv.slice(1));
const out = $sd0$Main$main({}, args)[1]('never');
        if (out[0] === 'Ok') {
            process.exitCode = out[1];
        } else {
            console.error(out[1]);
            process.exitCode = 1;
        }
        