#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096

//Error.stackTraceLimit = 100;

const { performance } = require('perf_hooks');

let __re__;


const sp_clone = (src) => {
 if (Array.isArray(src))
   return src.map(sp_clone);

 if (typeof(src) === 'object') {
   const dest = {};
   for (let k in src) { dest[k] = sp_clone(src[k]); }
   return dest;
 }

 return src;
}


//
// Basic ops
//


const sp_equal = (a, b) => {
  if (a === b)
    return true

  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;

    const l = a.length;
    if (l !== b.length) return false;

    let i = 0;
    while (i < l) {
      if (!sp_equal(a[i], b[i])) return false;
      ++i;
    }

    return true;
  }

  if (typeof(a) === 'object') {
    if (typeof(b) !== 'object') return false;

    const keys = Object.keys(a);
    const l = keys.length;
    if (l !== Object.keys(b).length) return false;

    let i = 0;
    while (i < l) {
      let k = keys[i];
      if (!sp_equal(a[k], b[k])) return false;
      ++i;
    }

    return true;
  }

  return false;
}


const sp_not_equal = (a, b) => {
  return !sp_equal(a, b);
}


const basics_compare = (a, b) => {

  // union type
  if (Array.isArray(a)) {
    // compare constructor names
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    for (let i = 1; i < a.length; i++) {
        const cmp = basics_compare(a[i], b[i]);
        if (cmp) return cmp;
    }
    return 0;
  }

  // None is represented as null
  if (a === null)
      return 0;

  if (typeof a === 'object') {
    const keys = Object.keys(a).sort();
    for (let k of keys) {
        const cmp = basics_compare(a[k], b[k]);
        if (cmp) return cmp;
    }
    return 0;
  }

  if (a > b) return 1;
  if (a < b) return -1;
  return 0;
}

const sp_divide = (left, right) => {
  if (right === 0) return 0;
  return left / right;
}


// TODO remove this and handle it like any other op?
const basics_modBy = (a, b) => b % a;


const basics_cloneImm = sp_clone;


const basics_cloneUni = sp_clone;


//
// Debug
//


const sp_todo = (message) => {
  throw new Error("TODO: " + message);
}


const sp_log = (message, thing) => {
  console.log(message, sp_toHuman(thing));
  return thing;
}


const sp_throw = function (errorName) {
    console.error(...arguments);
    throw new Error(errorName);
}


//
// Benchmarking
//


var debug_benchStartTime = null;
var debug_benchStartStack = null;
var debug_benchEntries = {};


const pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;


const fmt = (n) => {
    const s = Math.floor(n) + '';
    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));
}


// TODO how should benchmark work in a browser?
typeof process !== 'undefined' && process.on('beforeExit', (code) => {
    if (debug_benchStartStack !== null)
        console.error(`ERROR: a benchmark has been started but not stopped!
Start was at:${debug_benchStartStack}`);

    const ks = Object.keys(debug_benchEntries);
    if (ks.length) {
        console.error("");
        console.error("Benchmark results:");
        ks.sort().forEach(k => {
            const entry = debug_benchEntries[k];
            console.error(
                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',
                    '   ',
                    'Runs:', pad(6, '' + entry.n),
                    '   ',
                    'Key:', k,
            );
        });
    }
});


const sp_benchStart = (none) => {
    if (debug_benchStartStack !== null)
        throw new Error(`
benchStart called when a benchmark is already ongoing!
Previous benchStart call was ${debug_benchStartStack}
`);

    debug_benchStartStack = new Error().stack;
    debug_benchStartTime = performance.now();
}


const sp_benchStop = (name) => {
    const now = performance.now();

    if (debug_benchStartStack === null)
        throw new Error("benchStop called while no benchmark is ongoing!");

    debug_benchStartStack = null;

    const dt = now - debug_benchStartTime;

    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };
    entry.dt += dt;
    entry.n += 1;
    debug_benchEntries[name] = entry;
}




//
// To Human
//


const id = (n) => '    '.repeat(n);


const sp_toHuman = (a, l = 0) => {

  if (Array.isArray(a))
    return sp_toHumanAsList([], a, l) || sp_toHumanAsDict(a, l) || sp_toHumanAsUnion(a, l);

  if (typeof a === 'function') {
    return '<fn ' + a.length + '>';
  }

  if (typeof a === 'object') {
    let acc = '{\n';
    for (let key in a)
        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\n';

    return acc + id(l) + '}';
  }

  return JSON.stringify(a, null, 0);
}


const sp_toHumanAsUnion = (a, l) => {

  if (a.length === 1) {
      return a[0];
  }

  let acc = a[0] + '\n';

  a.slice(1).forEach(arg => {

      const sub = sp_toHuman(arg, l + 1);
      if (!sub.startsWith('{') && sub.indexOf('\n') > -1)
          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\n';
      else
          acc += id(l + 1) + sub + '\n';

  })

  return acc;
}


const sp_toHumanAsList = (arrayAccum, list, l) => {
  if (list[0] === '$Cons' && list.length === 3) {
    arrayAccum.push(sp_toHuman(list[1], l));
    return sp_toHumanAsList(arrayAccum, list[2], l);
  }

  if (list[0] === '$Nil')
    return '[' + arrayAccum.join(', ') + ']';

  return false;
}

const sp_toHumanAsDict = (dict, l) => {
  if (dict[0] === 'RBNode_elm_builtin') {
      return 'DICT' + sp_toHumanAsList([], $core$Dict$toList(dict), l);
  }

  return false;
}


//
// Text
//


const text_fromNumber = (n) => '' + n;

const text_toNumber = (t) => {
    const n = +t;

    return isNaN(n) ?c0$Maybe$Nothing$0:c0$Maybe$Just$0.usr(n);
    }

    const text_toLower = (s) => s.toLowerCase()

    const text_toUpper = (s) => s.toUpperCase()

    const text_split = (separator, target) => arrayToListLow(target.split(separator));

    const text_length = (s) => s.length;

    const text_slice = (start, end, s) => s.slice(start, end);

    const text_startsWith = (sub, s) => s.startsWith(sub);

    const text_startsWithRegex = (regex) => {
      let re, f;
      try {
        re = new RegExp('^' + regex, 's');
      } catch (e) {
        f = () => "";
      }

      f = (s) => {
        let m = s.match(re);
        return m ? m[0] : "";
      };

      return { ctx: [], usr: f };
    }

    const text_replaceRegex = (regex) => {
      let re, f;
      try {
        re = new RegExp(regex, 'g');
      } catch (e) {
        f = () => ""
      }

      f = (replacer, s) => s.replace(re, replacer);

      return { ctx: [], usr: f };
    }

    const text_trimLeft = (s) => s.trimLeft();

    const text_dropLeft = (n, s) => s.slice(n);

    const text_forEach = (s, f) => {
      for (let i of s) f.usr(...f.ctx, i);
      return null;
    }


    //
    // Hashes
    //

    const hash_pop = (hash) => {
        for (let key in hash) {
            const [actualKey, value] = hash[key];
            delete hash[key];
            return c0$Maybe$Just$0.usr({ first: actualKey, second: value });
        }

        return c0$Maybe$Nothing$0;
        }


        const hash_fromList = (list) => {
          const hash = {};

          // TODO iteration instead of recursion
          const rec = (ls) => {
            if (ls[0] === '$Nil')
              return hash;

            const { first, second } = ls[1];

            hash[JSON.stringify(first)] = [first, second];

            return rec(ls[2]);
          };

          return rec(list);
        }


        const hash_insert = (hash, key, value) => {
            hash[JSON.stringify(key)] = [key, value];
            return null;
        }


        const hash_remove = (hash, key) => {
            delete hash[JSON.stringify(key)];
            return null;
        }


        const hash_get = (hash, key) => {
            const r = hash[JSON.stringify(key)];
            return r === undefined ?
    c0$Maybe$Nothing$0:c0$Maybe$Just$0.usr(r[1]);
    }


    const hash_for = (hash, f, acc) => {
        for (let k in hash) {
            const kv = hash[k];
            acc = f.usr(...f.ctx, kv[0], kv[1], acc);
        }
        return acc;
    }


    const hash_each = (hash, f) => {
        for (let k in hash) {
            const kv = hash[k];
            f.usr(...f.ctx, kv[0], kv[1]);
        }
        return null;
    }


    //
    // Arrays
    //

    const array_each = (array, f) => {
        array.forEach((e) => f.usr(...f.ctx, e));
        return null;
    }

    const array_push = (array, item) => {
        array.push(item);
        return null;
    }

    const array_pop = (a) => {
        return a.length ?c0$Maybe$Just$0.usr(a.pop()) :c0$Maybe$Nothing$0;
    }

    const array_get = (array, index) => {
        const r = array[index];
        return r === undefined ?c0$Maybe$Nothing$0:c0$Maybe$Just$0.usr(r);
    }

    const array_set = (a, index, item) => {
        if (index < 0) return false;
        if (index >= a.length) return false;
        a[index] = item;
        return true;
    }

    const array_sortBy = (arr, f) => {
        arr.sort((a, b) => basics_compare(f.usr(...f.ctx, a), f.usr(...f.ctx, b)));
        return null;
    }

    const arrayToListLow = (arr) => {
      const length = arr.length;
      let list = [ '$Nil' ];
      for (let i = length - 1; i >= 0; i--) {
          list = [ '$Cons', arr[i], list ];
      }
      return list;
    }

    const array_toList = arrayToListLow;


    const arrayFromListLow = (list) => {
      const array = [];
      const rec = (ls) => {
        if (ls[0] === '$Nil')
          return array;

        array.push(ls[1]);
        return rec(ls[2]);
      };

      return rec(list);
    }

    const array_fromList = arrayFromListLow;


    //
    // Lists
    //


    const sp_cons = (item, list) => {
      return [ '$Cons', item, list];
    }

    const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f.usr(...f.ctx, a), f.usr(...f.ctx, b))));


    //
    // Dynamic loading
    //
    const self_load = (requestedTypeHumanized, pars, variantConstructor) => {

        const re = (s) => s.replace(/[" \n]/g, '');

        const actualTypeHumanized = sp_toHuman(pars.type);
        if (re(actualTypeHumanized) !== re(requestedTypeHumanized)) {
            return c0$Result$Err$0.usr(pars.type);
            }

            const tUsrToString = (tUsr) => array_fromList(tUsr).join('$');

            const js = c0$BuildInfo$compile(arrayToListLow([]), pars);

            //   { name1, name2, name3, ... } = externals;
            const unpackExterns = ''; //'const { ' + pars.externalValues.map((e) => tUsrToString(e.usr)).join(', ') + ' } = externs;';

            const body = `{ ${unpackExterns}
${js}; return ${tUsrToString(pars.entryUsr)}; }`;

            const arg = {};
            //pars.externalValues.forEach((e) => arg[tUsrToString(e.usr)] = e.self.value);

            return c0$Result$Ok$0.usr (variantConstructor(Function('externs', body)(arg)));
        };


    
//
// Platform: IO
//
const fs = require('fs');
const path = require('path');

const io_readDir = (io, dirPath) => {
    // as @IO, Text: Re [Bool & Text]

    var entries;
    try {
        entries = fs.readdirSync(dirPath, { withFileTypes: true });
    } catch (e) {
        return c0$Result$Err$0.usr(e.message);
        }

        return c0$Result$Ok$0.usr(arrayToListLow(entries.map((dirent) => ({
            first: dirent.isDirectory(),
            second: dirent.name,
        }))));
    };


    const io_readFile = (io, path) => {
        // as @IO, Text: Re Text

        var content;
        try {
            content = fs.readFileSync(path, 'utf8');
        } catch (e) {
            return c0$Result$Err$0.usr(e.message);
        }

        return c0$Result$Ok$0.usr(content);
    };


    const io_writeFile = (io, path, content) => {
        // as @IO, Text, Text: Re Int

        try {
            fs.writeFileSync(path, content);
        } catch (e) {
            return c0$Result$Err$0.usr(e.message);
        }

        return c0$Result$Ok$0.usr(0);
    };


    const io_readStdin = (io) => {
        // as @IO: Re Text

        try {
            return c0$Result$Ok$0.usr(fs.readFileSync(0, 'utf8'));
        } catch (e) {
            return c0$Result$Err$0.usr(e.message);
        }
    };


    const io_writeStdout = (io, content) => {
        // as @IO, Text: Re None

        try {
            fs.writeFileSync(1, content);
        } catch (e) {
            return c0$Result$Err$0.usr(e.message);
        }

        return c0$Result$Ok$0.usr(null);
    };


    const io_writeStderr = (io, content) => {
        // as @IO, Text: Re Int

        try {
            fs.writeFileSync(2, content);
        } catch (e) {
            return c0$Result$Err$0.usr(e.message);
        }

        return c0$Result$Ok$0.usr(null);
    };


    const path_resolve = (p) => path.resolve(...arrayFromListLow(p));

    const path_join = (p) => path.join(...arrayFromListLow(p));

    const path_dirname = path.dirname;

const c0$Compiler$Ast$Depends$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Depends",
    $1,
  ])),
});

const c0$Compiler$Ast$Imm$0 = ([
  "$Imm",
]);

const c0$Compiler$Ast$RefGlobal$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$RefGlobal",
    $1,
  ])),
});

const c0$Compiler$Ast$RefLocal$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$RefLocal",
    $1,
  ])),
});

const c0$Compiler$Ast$RefPlaceholder$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$RefPlaceholder",
    $1,
  ])),
});

const c0$Compiler$Ast$Uni$0 = ([
  "$Uni",
]);

const c0$Compiler$CanonicalAst$ArgumentExpression$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ArgumentExpression",
    $1,
  ])),
});

const c0$Compiler$CanonicalAst$ArgumentRecycle$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$ArgumentRecycle",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$Call$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Call",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$Complete$0 = ([
  "$Complete",
]);

const c0$Compiler$CanonicalAst$Constructor$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Constructor",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$Fn$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Fn",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$If$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$If",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$Introspect$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Introspect",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$LetIn$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LetIn",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$LiteralNumber$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralNumber",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$LiteralText$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralText",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$ParRe$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ParRe",
    $1,
  ])),
});

const c0$Compiler$CanonicalAst$ParSp$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ParSp",
    $1,
  ])),
});

const c0$Compiler$CanonicalAst$ParameterPattern$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ParameterPattern",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$ParameterPlaceholder$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ParameterPlaceholder",
    $1,
  ])),
});

const c0$Compiler$CanonicalAst$ParameterRecycle$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ParameterRecycle",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$Partial$0 = ([
  "$Partial",
]);

const c0$Compiler$CanonicalAst$PatternAny$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$PatternAny",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$PatternConstructor$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$PatternConstructor",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$PatternLiteralNumber$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$PatternLiteralNumber",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$PatternLiteralText$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$PatternLiteralText",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$PatternRecord$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$PatternRecord",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$Record$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Record",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$RecordAccess$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$RecordAccess",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$Try$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Try",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$TypeAnnotationVariable$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$TypeAnnotationVariable",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$TypeError$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$TypeError",
    $1,
  ])),
});

const c0$Compiler$CanonicalAst$TypeFn$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$TypeFn",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$TypeNamed$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$TypeNamed",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$CanonicalAst$TypeRecord$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$TypeRecord",
    $1,
    $2,
  ])),
});

const c0$Compiler$CanonicalAst$Variable$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Variable",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$And$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$And",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$ArgumentRecycle$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$ArgumentRecycle",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$EmittableAst$ArgumentSpend$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ArgumentSpend",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$Call$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Call",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$Conditional$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Conditional",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$EmittableAst$Constructor$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Constructor",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$ConstructorAccess$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ConstructorAccess",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$GlobalVariable$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$GlobalVariable",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$Introspect$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Introspect",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$IsConstructor$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$IsConstructor",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$IsLiteralNumber$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$IsLiteralNumber",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$IsLiteralText$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$IsLiteralText",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$Lambda$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Lambda",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$LetIn$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$LetIn",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$LiteralNumber$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$LiteralNumber",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$LiteralRecord$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralRecord",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$LiteralText$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$LiteralText",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$LocalVariable$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$LocalVariable",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$MissingPattern$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$MissingPattern",
    $1,
    $2,
  ])),
});

const c0$Compiler$EmittableAst$PlaceholderVariable$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$PlaceholderVariable",
    $1,
  ])),
});

const c0$Compiler$EmittableAst$RecordAccess$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$RecordAccess",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$AliasDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$AliasDef",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Aligned$0 = ([
  "$Aligned",
]);

const c0$Compiler$FormattableAst$ArgumentPlaceholder$0 = ([
  "$ArgumentPlaceholder",
]);

const c0$Compiler$FormattableAst$BinopChain$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$BinopChain",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$Call$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Call",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$CommentStatement$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$CommentStatement",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Constructor$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Constructor",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Evaluation$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Evaluation",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Expression$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Expression",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$FormattableAst$Fn$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Fn",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$FormattableAst$If$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$If",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Indented$0 = ([
  "$Indented",
]);

const c0$Compiler$FormattableAst$Inline$0 = ([
  "$Inline",
]);

const c0$Compiler$FormattableAst$InlineWithId$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$InlineWithId",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Introspect$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Introspect",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$FormattableAst$List$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$List",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$LiteralNumber$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralNumber",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$LiteralText$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralText",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$Lowercase$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Lowercase",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Native$0 = ([
  "$Native",
]);

const c0$Compiler$FormattableAst$Poly$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Poly",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$Record$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Record",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$RecordShorthand$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$RecordShorthand",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ResolvedArgumentPlaceholder",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Statements$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Statements",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$Try$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Try",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$UnionDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$UnionDef",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$UnopCall$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$UnopCall",
    $1,
    $2,
  ])),
});

const c0$Compiler$FormattableAst$Uppercase$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Uppercase",
    $1,
  ])),
});

const c0$Compiler$FormattableAst$ValueDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ValueDef",
    $1,
  ])),
});

const c0$Compiler$Meta$UMR$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$UMR",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$Meta$USR$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$USR",
    $1,
    $2,
  ])),
});

const c0$Compiler$Meta$ConstructorDependency$0 = ([
  "$ConstructorDependency",
]);

const c0$Compiler$Meta$Core$0 = ([
  "$Core",
]);

const c0$Compiler$Meta$ImportsPath$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ImportsPath",
    $1,
    $2,
  ])),
});

const c0$Compiler$Meta$Installed$0 = ([
  "$Installed",
]);

const c0$Compiler$Meta$LocationLibrary$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LocationLibrary",
    $1,
    $2,
  ])),
});

const c0$Compiler$Meta$LocationSourceDir$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$LocationSourceDir",
    $1,
  ])),
});

const c0$Compiler$Meta$TypeDependency$0 = ([
  "$TypeDependency",
]);

const c0$Compiler$Meta$User$0 = ([
  "$User",
]);

const c0$Compiler$Meta$ValueDependency$0 = ([
  "$ValueDependency",
]);

const c0$Compiler$Op$Left$0 = ([
  "$Left",
]);

const c0$Compiler$Op$NonAssociative$0 = ([
  "$NonAssociative",
]);

const c0$Compiler$Op$Right$0 = ([
  "$Right",
]);

const c0$Compiler$Op$UnopMinus$0 = ([
  "$UnopMinus",
]);

const c0$Compiler$Op$UnopPlus$0 = ([
  "$UnopPlus",
]);

const c0$Compiler$Op$UnopRecycle$0 = ([
  "$UnopRecycle",
]);

const c0$Compiler$Op$UnopUnique$0 = ([
  "$UnopUnique",
]);

const c0$Compiler$Pos$At$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$At",
    $1,
    $2,
  ])),
});

const c0$Compiler$Pos$End$0 = ([
  "$End",
]);

const c0$Compiler$Pos$G$0 = ([
  "$G",
]);

const c0$Compiler$Pos$I$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$I",
    $1,
  ])),
});

const c0$Compiler$Pos$N$0 = ([
  "$N",
]);

const c0$Compiler$Pos$P$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$P",
    $1,
    $2,
  ])),
});

const c0$Compiler$Pos$S$0 = ([
  "$S",
]);

const c0$Compiler$Pos$T$0 = ([
  "$T",
]);

const c0$Compiler$Token$ArgumentPlaceholder$0 = ([
  "$ArgumentPlaceholder",
]);

const c0$Compiler$Token$As$0 = ([
  "$As",
]);

const c0$Compiler$Token$Binop$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Binop",
    $1,
    $2,
  ])),
});

const c0$Compiler$Token$BlockEnd$0 = ([
  "$BlockEnd",
]);

const c0$Compiler$Token$BlockStart$0 = ([
  "$BlockStart",
]);

const c0$Compiler$Token$Closed$0 = ([
  "$Closed",
]);

const c0$Compiler$Token$Colon$0 = ([
  "$Colon",
]);

const c0$Compiler$Token$Comma$0 = ([
  "$Comma",
]);

const c0$Compiler$Token$Comment$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Comment",
    $1,
  ])),
});

const c0$Compiler$Token$Constructor$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Constructor",
    $1,
  ])),
});

const c0$Compiler$Token$CurlyBrace$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$CurlyBrace",
    $1,
    $2,
  ])),
});

const c0$Compiler$Token$Defop$0 = ([
  "$Defop",
]);

const c0$Compiler$Token$Else$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Else",
    $1,
  ])),
});

const c0$Compiler$Token$Fn$0 = ([
  "$Fn",
]);

const c0$Compiler$Token$If$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$If",
    $1,
  ])),
});

const c0$Compiler$Token$Lowercase$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Lowercase",
    $1,
  ])),
});

const c0$Compiler$Token$NewSiblingLine$0 = ([
  "$NewSiblingLine",
]);

const c0$Compiler$Token$NumberLiteral$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$NumberLiteral",
    $1,
    $2,
  ])),
});

const c0$Compiler$Token$Open$0 = ([
  "$Open",
]);

const c0$Compiler$Token$RecordShorthand$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$RecordShorthand",
    $1,
  ])),
});

const c0$Compiler$Token$RoundParen$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$RoundParen",
    $1,
  ])),
});

const c0$Compiler$Token$SingleQuote$0 = ([
  "$SingleQuote",
]);

const c0$Compiler$Token$Sp_introspect$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Sp_introspect",
    $1,
  ])),
});

const c0$Compiler$Token$SquareBracket$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$SquareBracket",
    $1,
    $2,
  ])),
});

const c0$Compiler$Token$TextLiteral$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$TextLiteral",
    $1,
    $2,
  ])),
});

const c0$Compiler$Token$Then$0 = ([
  "$Then",
]);

const c0$Compiler$Token$This_is_sp_native$0 = ([
  "$This_is_sp_native",
]);

const c0$Compiler$Token$ThreeDots$0 = ([
  "$ThreeDots",
]);

const c0$Compiler$Token$Token$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Token",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$Token$TripleQuote$0 = ([
  "$TripleQuote",
]);

const c0$Compiler$Token$Try$0 = ([
  "$Try",
]);

const c0$Compiler$Token$Type$0 = ([
  "$Type",
]);

const c0$Compiler$Token$TypeOpen$0 = ([
  "$TypeOpen",
]);

const c0$Compiler$Token$UniquenessPolymorphismBinop$0 = ([
  "$UniquenessPolymorphismBinop",
]);

const c0$Compiler$Token$Unop$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Unop",
    $1,
  ])),
});

const c0$Compiler$Token$Uppercase$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Uppercase",
    $1,
  ])),
});

const c0$Compiler$Token$Value$0 = ([
  "$Value",
]);

const c0$Compiler$Token$With$0 = ([
  "$With",
]);

const c0$Compiler$TypedAst$ArgumentExpression$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ArgumentExpression",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$ArgumentRecycle$0 = ({
  ctx: [],
  usr: (($1, $2, $3, $4) => ([
    "$ArgumentRecycle",
    $1,
    $2,
    $3,
    $4,
  ])),
});

const c0$Compiler$TypedAst$Call$0 = ({
  ctx: [],
  usr: (($1, $2, $3, $4) => ([
    "$Call",
    $1,
    $2,
    $3,
    $4,
  ])),
});

const c0$Compiler$TypedAst$Constructor$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Constructor",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$DestroyIn$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$DestroyIn",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$Error$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Error",
    $1,
  ])),
});

const c0$Compiler$TypedAst$If$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$If",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$Introspect$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Introspect",
    $1,
  ])),
});

const c0$Compiler$TypedAst$Lambda$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Lambda",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$LetIn$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$LetIn",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$LiteralNumber$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralNumber",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$LiteralText$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$LiteralText",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$ParRe$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ParRe",
    $1,
  ])),
});

const c0$Compiler$TypedAst$ParSp$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ParSp",
    $1,
  ])),
});

const c0$Compiler$TypedAst$ParameterPattern$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ParameterPattern",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$ParameterPlaceholder$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ParameterPlaceholder",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$ParameterRecycle$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$ParameterRecycle",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$PatternAny$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$PatternAny",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$PatternConstructor$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$PatternConstructor",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$PatternLiteralNumber$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$PatternLiteralNumber",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$PatternLiteralText$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$PatternLiteralText",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$PatternRecord$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$PatternRecord",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$Record$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Record",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$RecordAccess$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$RecordAccess",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$Try$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Try",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$TypeError$0 = ([
  "$TypeError",
]);

const c0$Compiler$TypedAst$TypeExact$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$TypeExact",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$TypeFn$0 = ({
  ctx: [],
  usr: (($1, $2, $3, $4) => ([
    "$TypeFn",
    $1,
    $2,
    $3,
    $4,
  ])),
});

const c0$Compiler$TypedAst$TypeRecord$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$TypeRecord",
    $1,
    $2,
    $3,
  ])),
});

const c0$Compiler$TypedAst$TypeVar$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$TypeVar",
    $1,
    $2,
  ])),
});

const c0$Compiler$TypedAst$Variable$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Variable",
    $1,
    $2,
  ])),
});

const c0$Core$Cons$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Cons",
    $1,
    $2,
  ])),
});

const c0$Core$False$0 = ([
  "$False",
]);

const c0$Core$Nil$0 = ([
  "$Nil",
]);

const c0$Core$None$0 = ([
  "$None",
]);

const c0$Core$True$0 = ([
  "$True",
]);

const c0$Dict$Black$0 = ([
  "$Black",
]);

const c0$Dict$Empty$0 = ([
  "$Empty",
]);

const c0$Dict$Node$0 = ({
  ctx: [],
  usr: (($1, $2, $3, $4, $5) => ([
    "$Node",
    $1,
    $2,
    $3,
    $4,
    $5,
  ])),
});

const c0$Dict$Red$0 = ([
  "$Red",
]);

const c0$Maybe$Just$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Just",
    $1,
  ])),
});

const c0$Maybe$Nothing$0 = ([
  "$Nothing",
]);

const c0$Result$Err$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Err",
    $1,
  ])),
});

const c0$Result$Ok$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Ok",
    $1,
  ])),
});

const c0$Self$OpaqueType$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$OpaqueType",
    $1,
  ])),
});

const c0$Self$OpenAliasType$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$OpenAliasType",
    $1,
  ])),
});

const c0$Self$OpenVarType$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$OpenVarType",
    $1,
  ])),
});

const c0$Self$Value$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Value",
    $1,
  ])),
});

const c0$Self_Test$Integer$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Integer",
    $1,
  ])),
});

const i2$Test$CodeExpectation$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$CodeExpectation",
    $1,
  ])),
});

const i2$Test$Error$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Error",
    $1,
  ])),
});

const i2$Test$Group$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Group",
    $1,
    $2,
  ])),
});

const i2$Test$NotNow$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$NotNow",
    $1,
  ])),
});

const i2$Test$Single$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Single",
    $1,
    $2,
    $3,
  ])),
});

const i2$Test$Skipped$0 = ([
  "$Skipped",
]);

const i2$Test$Success$0 = ([
  "$Success",
]);

const u0$Compiler$Error$FormattedText_Decoration$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$FormattedText_Decoration",
    $1,
  ])),
});

const u0$Compiler$Error$FormattedText_Default$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$FormattedText_Default",
    $1,
  ])),
});

const u0$Compiler$Error$FormattedText_Emphasys$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$FormattedText_Emphasys",
    $1,
  ])),
});

const u0$Compiler$Error$FormattedText_Warning$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$FormattedText_Warning",
    $1,
  ])),
});

const u0$Compiler$Error$HighlightBlock$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$HighlightBlock",
    $1,
  ])),
});

const u0$Compiler$Error$HighlightWord$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$HighlightWord",
    $1,
  ])),
});

const u0$Compiler$Error$Nested$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Nested",
    $1,
  ])),
});

const u0$Compiler$Error$Raw$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Raw",
    $1,
  ])),
});

const u0$Compiler$Error$Simple$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Simple",
    $1,
    $2,
    $3,
  ])),
});

const u0$Compiler$LazyBuild$AliasDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$AliasDef",
    $1,
  ])),
});

const u0$Compiler$LazyBuild$ConstructorDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ConstructorDef",
    $1,
  ])),
});

const u0$Compiler$LazyBuild$MissingDef$0 = ([
  "$MissingDef",
]);

const u0$Compiler$LazyBuild$ValueDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ValueDef",
    $1,
  ])),
});

const u0$Compiler$LazyBuild$VariantTypeDef$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$VariantTypeDef",
    $1,
  ])),
});

const u0$Compiler$Lexer$BlockComment$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$BlockComment",
    $1,
  ])),
});

const u0$Compiler$Lexer$ContentOpeningBlockComment$0 = ([
  "$ContentOpeningBlockComment",
]);

const u0$Compiler$Lexer$ContentOpeningQuotes_One$0 = ([
  "$ContentOpeningQuotes_One",
]);

const u0$Compiler$Lexer$ContentOpeningQuotes_Two$0 = ([
  "$ContentOpeningQuotes_Two",
]);

const u0$Compiler$Lexer$Default$0 = ([
  "$Default",
]);

const u0$Compiler$Lexer$Dot_One$0 = ([
  "$Dot_One",
]);

const u0$Compiler$Lexer$Dot_Two$0 = ([
  "$Dot_Two",
]);

const u0$Compiler$Lexer$Indent$0 = ([
  "$Indent",
]);

const u0$Compiler$Lexer$LineComment$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$LineComment",
    $1,
  ])),
});

const u0$Compiler$Lexer$Mutable$0 = ([
  "$Mutable",
]);

const u0$Compiler$Lexer$NoTabsOrSpacesYet$0 = ([
  "$NoTabsOrSpacesYet",
]);

const u0$Compiler$Lexer$NumberLiteral$0 = ([
  "$NumberLiteral",
]);

const u0$Compiler$Lexer$SingleQuote$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$SingleQuote",
    $1,
  ])),
});

const u0$Compiler$Lexer$Spaces$0 = ([
  "$Spaces",
]);

const u0$Compiler$Lexer$Squiggles$0 = ([
  "$Squiggles",
]);

const u0$Compiler$Lexer$Tabs$0 = ([
  "$Tabs",
]);

const u0$Compiler$Lexer$TripleQuote$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$TripleQuote",
    $1,
  ])),
});

const u0$Compiler$Lexer$Word$0 = ([
  "$Word",
]);

const u0$Compiler$MakeEmittable$GenerateName$0 = ([
  "$GenerateName",
]);

const u0$Compiler$MakeEmittable$NoNamedVariables$0 = ([
  "$NoNamedVariables",
]);

const u0$Compiler$MakeEmittable$TrivialPattern$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$TrivialPattern",
    $1,
    $2,
  ])),
});

const u0$Compiler$Parser$E_full$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$E_full",
    $1,
  ])),
});

const u0$Compiler$Parser$E_under$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$E_under",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$CanBeCastNo$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$CanBeCastNo",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$CanBeCastYes$0 = ([
  "$CanBeCastYes",
]);

const u0$Compiler$TypeCheck$Context_Argument$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Context_Argument",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$Context_AttributeName$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Context_AttributeName",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$Context_FnBody$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Context_FnBody",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$Context_Global$0 = ([
  "$Context_Global",
]);

const u0$Compiler$TypeCheck$Context_IfCondition$0 = ([
  "$Context_IfCondition",
]);

const u0$Compiler$TypeCheck$Context_IfFalse$0 = ([
  "$Context_IfFalse",
]);

const u0$Compiler$TypeCheck$Context_IfTrue$0 = ([
  "$Context_IfTrue",
]);

const u0$Compiler$TypeCheck$Context_LetInBody$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Context_LetInBody",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$Context_TryBranch$0 = ([
  "$Context_TryBranch",
]);

const u0$Compiler$TypeCheck$ErrorCallingANonFunction$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorCallingANonFunction",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorConstructorNotFound$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorConstructorNotFound",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorIncompatiblePattern$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ErrorIncompatiblePattern",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$ErrorModuleNotFound$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorModuleNotFound",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorNotCompatibleWithRecord$0 = ([
  "$ErrorNotCompatibleWithRecord",
]);

const u0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorRecordDoesNotHaveAttribute",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorRecordHasAttributesNotInAnnotation",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorRecordIsMissingAttibutesInAnnotation",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorRecyclingDoesNotMatch$0 = ([
  "$ErrorRecyclingDoesNotMatch",
]);

const u0$Compiler$TypeCheck$ErrorShouldBeUnique$0 = ([
  "$ErrorShouldBeUnique",
]);

const u0$Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ErrorTryingToAccessAttributeOfNonRecord",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$ErrorTypeNotFound$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorTypeNotFound",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorTyvarNotIndependent$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorTyvarNotIndependent",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatch$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorUniquenessDoesNotMatch",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchArgument$0 = ([
  "$ErrorUniquenessDoesNotMatchArgument",
]);

const u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ErrorUniquenessDoesNotMatchParameter",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$ErrorUnresolvableUniqueness$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$ErrorUnresolvableUniqueness",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$ErrorVariableNotFound$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorVariableNotFound",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorWrongNumberOfArguments$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ErrorWrongNumberOfArguments",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments$0 = ([
  "$ErrorWrongNumberOfConstructorArguments",
]);

const u0$Compiler$TypeCheck$ErrorWrongNumberOfParameters$0 = ([
  "$ErrorWrongNumberOfParameters",
]);

const u0$Compiler$TypeCheck$Why_Annotation$0 = ([
  "$Why_Annotation",
]);

const u0$Compiler$TypeCheck$Why_Argument$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Why_Argument",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$Why_Attribute$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Why_Attribute",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$Why_CalledAsFunction$0 = ([
  "$Why_CalledAsFunction",
]);

const u0$Compiler$TypeCheck$Why_FunctionInput$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Why_FunctionInput",
    $1,
    $2,
  ])),
});

const u0$Compiler$TypeCheck$Why_FunctionOutput$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Why_FunctionOutput",
    $1,
  ])),
});

const u0$Compiler$TypeCheck$Why_IfBranches$0 = ([
  "$Why_IfBranches",
]);

const u0$Compiler$TypeCheck$Why_IfCondition$0 = ([
  "$Why_IfCondition",
]);

const u0$Compiler$TypeCheck$Why_LetIn$0 = ([
  "$Why_LetIn",
]);

const u0$Compiler$TypeCheck$Why_Record$0 = ([
  "$Why_Record",
]);

const u0$Compiler$TypeCheck$Why_RecordAccess$0 = ([
  "$Why_RecordAccess",
]);

const u0$Compiler$TypeCheck$Why_RecordExt$0 = ([
  "$Why_RecordExt",
]);

const u0$Compiler$TypeCheck$Why_TryExpression$0 = ([
  "$Why_TryExpression",
]);

const u0$Compiler$TypeCheck$Why_TryPattern$0 = ([
  "$Why_TryPattern",
]);

const u0$Compiler$TypeCheck$Why_TypeArgument$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Why_TypeArgument",
    $1,
    $2,
    $3,
  ])),
});

const u0$Compiler$UniquenessCheck$Available$0 = ([
  "$Available",
]);

const u0$Compiler$UniquenessCheck$ConsumedAt$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ConsumedAt",
    $1,
  ])),
});

const u0$Compiler$UniquenessCheck$Immutable$0 = ([
  "$Immutable",
]);

const u0$Compiler$UniquenessCheck$Unique$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Unique",
    $1,
  ])),
});

const u0$ImportsFile$Core$0 = ([
  "$Core",
]);

const u0$ImportsFile$Dir$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Dir",
    $1,
  ])),
});

const u0$ImportsFile$Installed$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Installed",
    $1,
  ])),
});

const u0$ImportsFile$Lib$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Lib",
    $1,
  ])),
});

const u0$ImportsFile$Local$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Local",
    $1,
  ])),
});

const u0$SPLib$Format$Blank$0 = ([
  "$Blank",
]);

const u0$SPLib$Format$CommentIgnoreIndent$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$CommentIgnoreIndent",
    $1,
  ])),
});

const u0$SPLib$Format$CommentWithIndent$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$CommentWithIndent",
    $1,
  ])),
});

const u0$SPLib$Format$Empty$0 = ([
  "$Empty",
]);

const u0$SPLib$Format$Indented$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Indented",
    $1,
    $2,
  ])),
});

const u0$SPLib$Format$MustBreakAtEnd$0 = ([
  "$MustBreakAtEnd",
]);

const u0$SPLib$Format$NoRequiredBreaks$0 = ([
  "$NoRequiredBreaks",
]);

const u0$SPLib$Format$Row$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Row",
    $1,
    $2,
  ])),
});

const u0$SPLib$Format$SingleLine$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$SingleLine",
    $1,
    $2,
  ])),
});

const u0$SPLib$Format$Space$0 = ([
  "$Space",
]);

const u0$SPLib$Format$Stack$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Stack",
    $1,
    $2,
  ])),
});

const u0$SPLib$Format$Text_$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Text_",
    $1,
  ])),
});

const u0$SPLib$Parser$Aborted$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Aborted",
    $1,
    $2,
  ])),
});

const u0$SPLib$Parser$Accepted$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Accepted",
    $1,
    $2,
  ])),
});

const u0$SPLib$Parser$Rejected$0 = ([
  "$Rejected",
]);

const u0$SPLib$SPON$Accepted$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Accepted",
    $1,
    $2,
  ])),
});

const u0$SPLib$SPON$Failed$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Failed",
    $1,
  ])),
});

const u0$SPLib$SPON$Rejected$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Rejected",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$AccessWithBrackets$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$AccessWithBrackets",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$AccessWithDot$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$AccessWithDot",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$Array$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Array",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$Binop$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Binop",
    $1,
    $2,
    $3,
  ])),
});

const u0$Targets$Javascript$Ast$BlockLambda$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$BlockLambda",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$Call$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Call",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$Comma$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Comma",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$Conditional$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Conditional",
    $1,
    $2,
    $3,
  ])),
});

const u0$Targets$Javascript$Ast$Define$0 = ({
  ctx: [],
  usr: (($1, $2, $3) => ([
    "$Define",
    $1,
    $2,
    $3,
  ])),
});

const u0$Targets$Javascript$Ast$Eval$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Eval",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$If$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$If",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$Literal$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Literal",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$Mutop$0 = ({
  ctx: [],
  usr: (($1, $2, $3, $4) => ([
    "$Mutop",
    $1,
    $2,
    $3,
    $4,
  ])),
});

const u0$Targets$Javascript$Ast$Record$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Record",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$Return$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Return",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$SimpleLambda$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$SimpleLambda",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$ThreeDots$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$ThreeDots",
    $1,
  ])),
});

const u0$Targets$Javascript$Ast$Unop$0 = ({
  ctx: [],
  usr: (($1, $2) => ([
    "$Unop",
    $1,
    $2,
  ])),
});

const u0$Targets$Javascript$Ast$Var$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Var",
    $1,
  ])),
});

const u0$Targets$Javascript$EmittableToJs$Block$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Block",
    $1,
  ])),
});

const u0$Targets$Javascript$EmittableToJs$Inline$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Inline",
    $1,
  ])),
});

const u0$Targets$Javascript$EmittableToJs$Override$0 = ({
  ctx: [],
  usr: (($1) => ([
    "$Override",
    $1,
  ])),
});

const i2$Test$maybeToOutcome$1 = (($m) => {
  return ((($m)[0] === "$Just")
    ? ((() => {
      const $e = ($m)[1];
      return (i2$Test$Error$0.usr)(...(i2$Test$Error$0.ctx), $e);
    }))()
    : ((($m)[0] === "$Nothing")
      ? i2$Test$Success$0
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 15:4', (sp_toHuman)($m))));
});

const i2$Test$maybeToOutcome$0 = ({
  ctx: [],
  usr: i2$Test$maybeToOutcome$1,
});

const i2$Test$valueTest$2 = (($generateValue, $toMaybeError, $toText, _0) => {
  return (i2$Test$maybeToOutcome$0.usr)(...(i2$Test$maybeToOutcome$0.ctx), ($toMaybeError.usr)(...($toMaybeError.ctx), $toText, (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ($generateValue.usr)(...($generateValue.ctx), null))));
});

const i2$Test$valueTest$1 = (($toText, $title, $generateValue, $ce) => {
  const $5 = $ce;
  const $toMaybeError = ($5)[1];
  return (i2$Test$Single$0.usr)(...(i2$Test$Single$0.ctx), $title, "", ({
    ctx: ([
      $generateValue,
      $toMaybeError,
      $toText,
    ]),
    usr: i2$Test$valueTest$2,
  }));
});

const i2$Test$valueTest$0 = ({
  ctx: [],
  usr: i2$Test$valueTest$1,
});

const c0$Array_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const c0$Array_Test$valueTest$0 = ({
  ctx: [],
  usr: c0$Array_Test$valueTest$1,
});

const c0$Text$join$2 = (($sep, $ls, $acc) => {
  const $rec = ({
    ctx: ([
      $sep,
    ]),
    usr: c0$Text$join$2,
  });
  return ((($ls)[0] === "$Nil")
    ? $acc
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $t = ($ls)[2];
        return ($rec.usr)(...($rec.ctx), $t, (($acc + $sep) + $h));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 139:16', (sp_toHuman)($ls))));
});

const c0$Text$join$1 = (($sep, $listOfText) => {
  return ((($listOfText)[0] === "$Nil")
    ? ""
    : ((($listOfText)[0] === "$Cons")
      ? ((() => {
        const $head = ($listOfText)[1];
        const $tail = ($listOfText)[2];
        const $rec = ({
          ctx: ([
            $sep,
          ]),
          usr: c0$Text$join$2,
        });
        return ($rec.usr)(...($rec.ctx), $tail, $head);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 131:4', (sp_toHuman)($listOfText))));
});

const c0$Text$join$0 = ({
  ctx: [],
  usr: c0$Text$join$1,
});

const i2$Test$isOkAndEqualTo$2 = (($expectedOk, $toText, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $actualOk = ($result)[1];
        return ((sp_equal)($actualOk, $expectedOk)
          ? c0$Maybe$Nothing$0
          : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "expected = ", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($toText.usr)(...($toText.ctx), $expectedOk), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "actual = ", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($toText.usr)(...($toText.ctx), $actualOk), c0$Core$Nil$0))))))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 73:8', (sp_toHuman)($result))));
});

const i2$Test$isOkAndEqualTo$1 = (($expectedOk) => {
  return (i2$Test$CodeExpectation$0.usr)(...(i2$Test$CodeExpectation$0.ctx), ({
    ctx: ([
      $expectedOk,
    ]),
    usr: i2$Test$isOkAndEqualTo$2,
  }));
});

const i2$Test$isOkAndEqualTo$0 = ({
  ctx: [],
  usr: i2$Test$isOkAndEqualTo$1,
});

const c0$Array_Test$tests$9 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0));
  (array_push)($a, "b");
  (array_push)($a, "c");
  return (array_toList)($a);
});

const c0$Array_Test$tests$8 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "y", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "z", c0$Core$Nil$0))));
  const $b = (array_pop)($a);
  const $c = (array_pop)($a);
  const $l = (array_toList)($a);
  return ({
    b: $b,
    c: $c,
    l: $l,
  });
});

const c0$Array_Test$tests$7 = ((_0) => {
  let $a = (array_fromList)(c0$Core$Nil$0);
  const $b = (array_pop)($a);
  const $l = (array_toList)($a);
  return ({
    b: $b,
    l: $l,
  });
});

const c0$Array_Test$tests$6 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "p", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "q", c0$Core$Nil$0)));
  return (array_get)($a, 1);
});

const c0$Array_Test$tests$5 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "p", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "q", c0$Core$Nil$0)));
  return (array_get)($a, 3);
});

const c0$Array_Test$tests$4 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 8, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 9, c0$Core$Nil$0)));
  const $r = (array_set)($a, 0, 10);
  const $l = (array_toList)($a);
  return ({
    l: $l,
    r: $r,
  });
});

const c0$Array_Test$tests$3 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 8, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 9, c0$Core$Nil$0)));
  const $r = (array_set)($a, 3, 10);
  const $l = (array_toList)($a);
  return ({
    l: $l,
    r: $r,
  });
});

const c0$Array_Test$tests$2 = (($x) => {
  return -($x);
});

const c0$Array_Test$tests$1 = ((_0) => {
  let $a = (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 55, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 99, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 22, c0$Core$Nil$0))));
  (array_sortBy)($a, ({
    ctx: [],
    usr: c0$Array_Test$tests$2,
  }));
  return (array_toList)($a);
});

const c0$Array_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Array", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "push", ({
  ctx: [],
  usr: c0$Array_Test$tests$9,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "pop 1", ({
  ctx: [],
  usr: c0$Array_Test$tests$8,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  b: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "z"),
  c: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "y"),
  l: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", c0$Core$Nil$0),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "pop empty", ({
  ctx: [],
  usr: c0$Array_Test$tests$7,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  b: c0$Maybe$Nothing$0,
  l: c0$Core$Nil$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "get Just", ({
  ctx: [],
  usr: c0$Array_Test$tests$6,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "q"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "get Nothing", ({
  ctx: [],
  usr: c0$Array_Test$tests$5,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), c0$Maybe$Nothing$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "set success", ({
  ctx: [],
  usr: c0$Array_Test$tests$4,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  l: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 10, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 9, c0$Core$Nil$0)),
  r: true,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "set fail", ({
  ctx: [],
  usr: c0$Array_Test$tests$3,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  l: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 8, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 9, c0$Core$Nil$0)),
  r: false,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Array_Test$valueTest$0.usr)(...(c0$Array_Test$valueTest$0.ctx), "sortBy", ({
  ctx: [],
  usr: c0$Array_Test$tests$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 99, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 55, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 22, c0$Core$Nil$0))))), c0$Core$Nil$0)))))))));

const c0$Basics$identity$1 = (($a) => {
  return $a;
});

const c0$Basics$identity$0 = ({
  ctx: [],
  usr: c0$Basics$identity$1,
});

const c0$Basics$applyIf$1 = (($condition, $f) => {
  return ($condition
    ? $f
    : c0$Basics$identity$0);
});

const c0$Basics$applyIf$0 = ({
  ctx: [],
  usr: c0$Basics$applyIf$1,
});

const c0$Basics$clamp$1 = (($low, $high, $n) => {
  return (($n < $low)
    ? $low
    : (($n > $high)
      ? $high
      : $n));
});

const c0$Basics$clamp$0 = ({
  ctx: [],
  usr: c0$Basics$clamp$1,
});

const c0$Basics$max$1 = (($a, $b) => {
  return (($a > $b)
    ? $a
    : $b);
});

const c0$Basics$max$0 = ({
  ctx: [],
  usr: c0$Basics$max$1,
});

const c0$Basics$min$1 = (($a, $b) => {
  return (($a < $b)
    ? $a
    : $b);
});

const c0$Basics$min$0 = ({
  ctx: [],
  usr: c0$Basics$min$1,
});

const c0$Basics$not$1 = (($b) => {
  return ($b
    ? false
    : true);
});

const c0$Basics$not$0 = ({
  ctx: [],
  usr: c0$Basics$not$1,
});

const c0$Compiler$Ast$toImm$1 = (($raw) => {
  return ({
    raw: $raw,
    uni: c0$Compiler$Ast$Imm$0,
  });
});

const c0$Compiler$Ast$toImm$0 = ({
  ctx: [],
  usr: c0$Compiler$Ast$toImm$1,
});

const c0$Compiler$Ast$toUni$1 = (($raw) => {
  return ({
    raw: $raw,
    uni: c0$Compiler$Ast$Uni$0,
  });
});

const c0$Compiler$Ast$toUni$0 = ({
  ctx: [],
  usr: c0$Compiler$Ast$toUni$1,
});

const c0$Compiler$CanonicalAst$expressionPos$1 = (($exp) => {
  return ((($exp)[0] === "$LiteralNumber")
    ? ((() => {
      const $p = ($exp)[1];
      return $p;
    }))()
    : ((($exp)[0] === "$LiteralText")
      ? ((() => {
        const $p = ($exp)[1];
        return $p;
      }))()
      : ((($exp)[0] === "$Variable")
        ? ((() => {
          const $p = ($exp)[1];
          return $p;
        }))()
        : ((($exp)[0] === "$Constructor")
          ? ((() => {
            const $p = ($exp)[1];
            return $p;
          }))()
          : ((($exp)[0] === "$Fn")
            ? ((() => {
              const $p = ($exp)[1];
              return $p;
            }))()
            : ((($exp)[0] === "$Call")
              ? ((() => {
                const $p = ($exp)[1];
                return $p;
              }))()
              : ((($exp)[0] === "$Record")
                ? ((() => {
                  const $p = ($exp)[1];
                  return $p;
                }))()
                : ((($exp)[0] === "$RecordAccess")
                  ? ((() => {
                    const $p = ($exp)[1];
                    return $p;
                  }))()
                  : ((($exp)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($exp)[1];
                      const $e = ($exp)[2];
                      return (c0$Compiler$CanonicalAst$expressionPos$0.usr)(...(c0$Compiler$CanonicalAst$expressionPos$0.ctx), $e);
                    }))()
                    : ((($exp)[0] === "$If")
                      ? ((() => {
                        const $p = ($exp)[1];
                        return $p;
                      }))()
                      : ((($exp)[0] === "$Try")
                        ? ((() => {
                          const $p = ($exp)[1];
                          return $p;
                        }))()
                        : ((($exp)[0] === "$Introspect")
                          ? ((() => {
                            const $p = ($exp)[1];
                            return $p;
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 294:4', (sp_toHuman)($exp))))))))))))));
});

const c0$Compiler$CanonicalAst$expressionPos$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$expressionPos$1,
});

const c0$Dict$empty$0 = c0$Dict$Empty$0;

const c0$Compiler$CanonicalAst$initModule$1 = (($fsPath, $umr, $asText) => {
  return ({
    aliasDefs: c0$Dict$empty$0,
    asText: $asText,
    constructorDefs: c0$Dict$empty$0,
    fsPath: $fsPath,
    umr: $umr,
    umrToAlias: c0$Dict$empty$0,
    usrToGlobal: c0$Dict$empty$0,
    valueDefs: c0$Dict$empty$0,
    variantTypeDefs: c0$Dict$empty$0,
  });
});

const c0$Compiler$CanonicalAst$initModule$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$initModule$1,
});

const c0$Compiler$CanonicalAst$parTypeToRaw$1 = (($p) => {
  return ((($p)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($p)[1];
      return $raw;
    }))()
    : ((($p)[0] === "$ParSp")
      ? ((() => {
        const $full = ($p)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 174:4', (sp_toHuman)($p))));
});

const c0$Compiler$CanonicalAst$parTypeToRaw$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$parTypeToRaw$1,
});

const c0$Dict$for$1 = (($acc, $dict, $func) => {
  return ((($dict)[0] === "$Empty")
    ? $acc
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ($func.usr)(...($func.ctx), $key, $value, (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $acc, $left, $func)), $right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 361:4', (sp_toHuman)($dict))));
});

const c0$Dict$for$0 = ({
  ctx: [],
  usr: c0$Dict$for$1,
});

const c0$List$for$1 = (($init, $aList, $function) => {
  return ((($aList)[0] === "$Nil")
    ? $init
    : ((($aList)[0] === "$Cons")
      ? ((() => {
        const $h = ($aList)[1];
        const $tail = ($aList)[2];
        return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ($function.usr)(...($function.ctx), $h, $init), $tail, $function);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 80:4', (sp_toHuman)($aList))));
});

const c0$List$for$0 = ({
  ctx: [],
  usr: c0$List$for$1,
});

const c0$Compiler$CanonicalAst$patternNames$3 = (($rec, $0) => {
  return ($rec.usr)(...($rec.ctx), $0, c0$Core$Nil$0);
});

const c0$Compiler$CanonicalAst$patternNames$2 = (($rec, $k, $v, $a) => {
  return ($rec.usr)(...($rec.ctx), $v, $a);
});

const c0$Compiler$CanonicalAst$patternNames$1 = (($p, $acc) => {
  const $rec = ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$patternNames$1,
  });
  return (((($p)[0] === "$PatternAny") && ((($p)[2])[0] === "$Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return $acc;
    }))()
    : (((($p)[0] === "$PatternAny") && ((($p)[2])[0] === "$Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $name = (($p)[2])[1];
        const $maybeAnnotation = ($p)[3];
        return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
          maybeAnnotation: $maybeAnnotation,
          name: $name,
          pos: $pos,
        }), $acc);
      }))()
      : ((($p)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return $acc;
        }))()
        : ((($p)[0] === "$PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return $acc;
          }))()
          : ((($p)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $path = ($p)[2];
              const $ps = ($p)[3];
              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $acc, $ps, $rec);
            }))()
            : ((($p)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[3];
                return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $acc, $ps, ({
                  ctx: ([
                    $rec,
                  ]),
                  usr: c0$Compiler$CanonicalAst$patternNames$2,
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 281:8', (sp_toHuman)($p))))))));
});

const c0$Compiler$CanonicalAst$patternNames$0 = ((() => {
  const $rec = ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$patternNames$1,
  });
  return ({
    ctx: ([
      $rec,
    ]),
    usr: c0$Compiler$CanonicalAst$patternNames$3,
  });
}))();

const c0$Compiler$CanonicalAst$patternPos$1 = (($pa) => {
  return ((($pa)[0] === "$PatternAny")
    ? ((() => {
      const $p = ($pa)[1];
      return $p;
    }))()
    : ((($pa)[0] === "$PatternLiteralText")
      ? ((() => {
        const $p = ($pa)[1];
        return $p;
      }))()
      : ((($pa)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $p = ($pa)[1];
          return $p;
        }))()
        : ((($pa)[0] === "$PatternConstructor")
          ? ((() => {
            const $p = ($pa)[1];
            return $p;
          }))()
          : ((($pa)[0] === "$PatternRecord")
            ? ((() => {
              const $p = ($pa)[1];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 248:4', (sp_toHuman)($pa)))))));
});

const c0$Compiler$CanonicalAst$patternPos$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$patternPos$1,
});

const c0$Compiler$CanonicalAst$typePos$1 = (($0) => {
  return ((($0)[0] === "$TypeNamed")
    ? ((() => {
      const $p = ($0)[1];
      return $p;
    }))()
    : ((($0)[0] === "$TypeFn")
      ? ((() => {
        const $p = ($0)[1];
        return $p;
      }))()
      : ((($0)[0] === "$TypeRecord")
        ? ((() => {
          const $p = ($0)[1];
          return $p;
        }))()
        : ((($0)[0] === "$TypeAnnotationVariable")
          ? ((() => {
            const $p = ($0)[1];
            return $p;
          }))()
          : ((($0)[0] === "$TypeError")
            ? ((() => {
              const $p = ($0)[1];
              return $p;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 194:4', (sp_toHuman)($0)))))));
});

const c0$Compiler$CanonicalAst$typePos$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$typePos$1,
});

const c0$Dict$balance$1 = (($color, $key, $value, $left, $right) => {
  return (((($right)[0] === "$Node") && ((($right)[1])[0] === "$Red"))
    ? ((() => {
      const $rK = ($right)[2];
      const $rV = ($right)[3];
      const $rLeft = ($right)[4];
      const $rRight = ($right)[5];
      return (((($left)[0] === "$Node") && ((($left)[1])[0] === "$Red"))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $lLeft = ($left)[4];
          const $lRight = ($left)[5];
          return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $key, $value, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $lK, $lV, $lLeft, $lRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $rK, $rV, $rLeft, $rRight));
        }))()
        : (true
          ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $rK, $rV, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $key, $value, $left, $rLeft), $rRight)
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 84:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? (((($left)[0] === "$Node") && (((($left)[1])[0] === "$Red") && (((($left)[4])[0] === "$Node") && (((($left)[4])[1])[0] === "$Red"))))
        ? ((() => {
          const $lK = ($left)[2];
          const $lV = ($left)[3];
          const $llK = (($left)[4])[2];
          const $llV = (($left)[4])[3];
          const $llLeft = (($left)[4])[4];
          const $llRight = (($left)[4])[5];
          const $lRight = ($left)[5];
          return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $llK, $llV, $llLeft, $llRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $key, $value, $lRight, $right));
        }))()
        : (true
          ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $key, $value, $left, $right)
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 89:12', (sp_toHuman)($left))))
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 81:4', (sp_toHuman)($right))));
});

const c0$Dict$balance$0 = ({
  ctx: [],
  usr: c0$Dict$balance$1,
});

const c0$Dict$insertHelp$1 = (($key, $value, $dict) => {
  return ((($dict)[0] === "$Empty")
    ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $key, $value, c0$Dict$Empty$0, c0$Dict$Empty$0)
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $nColor = ($dict)[1];
        const $nKey = ($dict)[2];
        const $nValue = ($dict)[3];
        const $nLeft = ($dict)[4];
        const $nRight = ($dict)[5];
        const $4 = (basics_compare)($key, $nKey);
        return ((1 === $4)
          ? (c0$Dict$balance$0.usr)(...(c0$Dict$balance$0.ctx), $nColor, $nKey, $nValue, $nLeft, (c0$Dict$insertHelp$0.usr)(...(c0$Dict$insertHelp$0.ctx), $key, $value, $nRight))
          : ((0 === $4)
            ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $nColor, $nKey, $value, $nLeft, $nRight)
            : (true
              ? (c0$Dict$balance$0.usr)(...(c0$Dict$balance$0.ctx), $nColor, $nKey, $nValue, (c0$Dict$insertHelp$0.usr)(...(c0$Dict$insertHelp$0.ctx), $key, $value, $nLeft), $nRight)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 73:12', (sp_toHuman)($4)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 65:4', (sp_toHuman)($dict))));
});

const c0$Dict$insertHelp$0 = ({
  ctx: [],
  usr: c0$Dict$insertHelp$1,
});

const c0$Dict$insert$1 = (($key, $value, $dict) => {
  const $4 = (c0$Dict$insertHelp$0.usr)(...(c0$Dict$insertHelp$0.ctx), $key, $value, $dict);
  return (((($4)[0] === "$Node") && ((($4)[1])[0] === "$Red"))
    ? ((() => {
      const $k = ($4)[2];
      const $v = ($4)[3];
      const $l = ($4)[4];
      const $r = ($4)[5];
      return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $4;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 58:4', (sp_toHuman)($4))));
});

const c0$Dict$insert$0 = ({
  ctx: [],
  usr: c0$Dict$insert$1,
});

const c0$Dict$join$1 = (($0, $1) => {
  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $0, $1, c0$Dict$insert$0);
});

const c0$Dict$join$0 = ({
  ctx: [],
  usr: c0$Dict$join$1,
});

const c0$Dict$ofOne$1 = (($key, $value) => {
  return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $key, $value, c0$Dict$Empty$0, c0$Dict$Empty$0);
});

const c0$Dict$ofOne$0 = ({
  ctx: [],
  usr: c0$Dict$ofOne$1,
});

const c0$Dict$forReversed$1 = (($acc, $t, $func) => {
  return ((($t)[0] === "$Empty")
    ? $acc
    : ((($t)[0] === "$Node")
      ? ((() => {
        const $key = ($t)[2];
        const $value = ($t)[3];
        const $left = ($t)[4];
        const $right = ($t)[5];
        return (c0$Dict$forReversed$0.usr)(...(c0$Dict$forReversed$0.ctx), ($func.usr)(...($func.ctx), $key, $value, (c0$Dict$forReversed$0.usr)(...(c0$Dict$forReversed$0.ctx), $acc, $right, $func)), $left, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 383:4', (sp_toHuman)($t))));
});

const c0$Dict$forReversed$0 = ({
  ctx: [],
  usr: c0$Dict$forReversed$1,
});

const c0$Dict$values$2 = (($key, $value, $valueList) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $value, $valueList);
});

const c0$Dict$values$1 = (($0) => {
  return (c0$Dict$forReversed$0.usr)(...(c0$Dict$forReversed$0.ctx), c0$Core$Nil$0, $0, ({
    ctx: [],
    usr: c0$Dict$values$2,
  }));
});

const c0$Dict$values$0 = ({
  ctx: [],
  usr: c0$Dict$values$1,
});

const c0$List$reverse$1 = (($aList) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Core$Nil$0, $aList, c0$Core$Cons$0);
});

const c0$List$reverse$0 = ({
  ctx: [],
  usr: c0$List$reverse$1,
});

const c0$List$forReversed$2 = (($f, $acc, $ctr, $ls) => {
  const $foldrHelper = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$forReversed$2,
  });
  return ((($ls)[0] === "$Nil")
    ? $acc
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $a = ($ls)[1];
        const $r1 = ($ls)[2];
        return ((($r1)[0] === "$Nil")
          ? ($f.usr)(...($f.ctx), $a, $acc)
          : ((($r1)[0] === "$Cons")
            ? ((() => {
              const $b = ($r1)[1];
              const $r2 = ($r1)[2];
              return ((($r2)[0] === "$Nil")
                ? ($f.usr)(...($f.ctx), $a, ($f.usr)(...($f.ctx), $b, $acc))
                : ((($r2)[0] === "$Cons")
                  ? ((() => {
                    const $c = ($r2)[1];
                    const $r3 = ($r2)[2];
                    return ((($r3)[0] === "$Nil")
                      ? ($f.usr)(...($f.ctx), $a, ($f.usr)(...($f.ctx), $b, ($f.usr)(...($f.ctx), $c, $acc)))
                      : ((($r3)[0] === "$Cons")
                        ? ((() => {
                          const $d = ($r3)[1];
                          const $r4 = ($r3)[2];
                          const $res = (($ctr > 500)
                            ? (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $acc, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $r4), $f)
                            : ($foldrHelper.usr)(...($foldrHelper.ctx), $acc, ($ctr + 1), $r4));
                          return ($f.usr)(...($f.ctx), $a, ($f.usr)(...($f.ctx), $b, ($f.usr)(...($f.ctx), $c, ($f.usr)(...($f.ctx), $d, $res))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 125:32', (sp_toHuman)($r3))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 119:24', (sp_toHuman)($r2))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 113:16', (sp_toHuman)($r1))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 107:8', (sp_toHuman)($ls))));
});

const c0$List$forReversed$1 = (($init, $list, $f) => {
  const $foldrHelper = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$forReversed$2,
  });
  return ($foldrHelper.usr)(...($foldrHelper.ctx), $init, 0, $list);
});

const c0$List$forReversed$0 = ({
  ctx: [],
  usr: c0$List$forReversed$1,
});

const c0$List$map$2 = (($f, $x, $acc) => {
  return (sp_cons)(($f.usr)(...($f.ctx), $x), $acc);
});

const c0$List$map$1 = (($f, $list) => {
  return (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), c0$Core$Nil$0, $list, ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$map$2,
  }));
});

const c0$List$map$0 = ({
  ctx: [],
  usr: c0$List$map$1,
});

const c0$Compiler$CanonicalAst$typeTyvars$3 = (($item, $acc) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $acc, (c0$Compiler$CanonicalAst$typeTyvars$0.usr)(...(c0$Compiler$CanonicalAst$typeTyvars$0.ctx), $item));
});

const c0$Compiler$CanonicalAst$typeTyvars$2 = (($list) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $list, ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$typeTyvars$3,
  }));
});

const c0$Compiler$CanonicalAst$typeTyvars$1 = (($raw) => {
  const $fromList = ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$typeTyvars$2,
  });
  return ((($raw)[0] === "$TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList.usr)(...($fromList.ctx), $args);
    }))()
    : ((($raw)[0] === "$TypeFn")
      ? ((() => {
        const $pars = ($raw)[2];
        const $to = ($raw)[3];
        return ($fromList.usr)(...($fromList.ctx), (sp_cons)($to.raw, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), c0$Compiler$CanonicalAst$parTypeToRaw$0, $pars)));
      }))()
      : ((($raw)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($raw)[2];
          return ($fromList.usr)(...($fromList.ctx), (c0$Dict$values$0.usr)(...(c0$Dict$values$0.ctx), $attrs));
        }))()
        : ((($raw)[0] === "$TypeAnnotationVariable")
          ? ((() => {
            const $pos = ($raw)[1];
            const $name = ($raw)[2];
            return (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $name, $pos);
          }))()
          : ((($raw)[0] === "$TypeError")
            ? c0$Dict$empty$0
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 185:4', (sp_toHuman)($raw)))))));
});

const c0$Compiler$CanonicalAst$typeTyvars$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$typeTyvars$1,
});

const c0$Compiler$CanonicalAst$typeUnivars$5 = (($insertUni, $par, $acc) => {
  return ((($par)[0] === "$ParRe")
    ? $acc
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return ($insertUni.usr)(...($insertUni.ctx), $full.uni, (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $acc, (c0$Compiler$CanonicalAst$typeUnivars$0.usr)(...(c0$Compiler$CanonicalAst$typeUnivars$0.ctx), $full.raw)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 216:8', (sp_toHuman)($par))));
});

const c0$Compiler$CanonicalAst$typeUnivars$4 = (($uni, $acc) => {
  return ((($uni)[0] === "$Depends")
    ? ((() => {
      const $uid = ($uni)[1];
      return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $uid, null, $acc);
    }))()
    : (true
      ? $acc
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 210:8', (sp_toHuman)($uni))));
});

const c0$Compiler$CanonicalAst$typeUnivars$3 = (($item, $acc) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $acc, (c0$Compiler$CanonicalAst$typeUnivars$0.usr)(...(c0$Compiler$CanonicalAst$typeUnivars$0.ctx), $item));
});

const c0$Compiler$CanonicalAst$typeUnivars$2 = (($list) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $list, ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$typeUnivars$3,
  }));
});

const c0$Compiler$CanonicalAst$typeUnivars$1 = (($raw) => {
  const $fromList = ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$typeUnivars$2,
  });
  const $insertUni = ({
    ctx: [],
    usr: c0$Compiler$CanonicalAst$typeUnivars$4,
  });
  const $parUnivars = ({
    ctx: ([
      $insertUni,
    ]),
    usr: c0$Compiler$CanonicalAst$typeUnivars$5,
  });
  return ((($raw)[0] === "$TypeNamed")
    ? ((() => {
      const $args = ($raw)[3];
      return ($fromList.usr)(...($fromList.ctx), $args);
    }))()
    : ((($raw)[0] === "$TypeRecord")
      ? ((() => {
        const $attrs = ($raw)[2];
        return ($fromList.usr)(...($fromList.ctx), (c0$Dict$values$0.usr)(...(c0$Dict$values$0.ctx), $attrs));
      }))()
      : ((($raw)[0] === "$TypeAnnotationVariable")
        ? ((() => {
          const $pos = ($raw)[1];
          const $name = ($raw)[2];
          return c0$Dict$empty$0;
        }))()
        : ((($raw)[0] === "$TypeError")
          ? c0$Dict$empty$0
          : ((($raw)[0] === "$TypeFn")
            ? ((() => {
              const $pars = ($raw)[2];
              const $to = ($raw)[3];
              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ($insertUni.usr)(...($insertUni.ctx), $to.uni, c0$Dict$empty$0), $pars, $parUnivars);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/CanonicalAst.sp 226:4', (sp_toHuman)($raw)))))));
});

const c0$Compiler$CanonicalAst$typeUnivars$0 = ({
  ctx: [],
  usr: c0$Compiler$CanonicalAst$typeUnivars$1,
});

const c0$Compiler$EmittableAst$translateName$1 = (($name) => {
  return ((text_startsWith)("'", $name)
    ? ((() => {
      const $head = (text_slice)(1, 2, $name);
      const $rest = (text_slice)(2, 9999, $name);
      return ((text_toUpper)($head) + $rest);
    }))()
    : $name);
});

const c0$Compiler$EmittableAst$translateName$0 = ({
  ctx: [],
  usr: c0$Compiler$EmittableAst$translateName$1,
});

const c0$Compiler$EmittableAst$translateRoot$1 = (($0) => {
  return ((($0)[0] === "$Core")
    ? "c"
    : ((($0)[0] === "$User")
      ? "u"
      : ((($0)[0] === "$Installed")
        ? "i"
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/EmittableAst.sp 89:4', (sp_toHuman)($0)))));
});

const c0$Compiler$EmittableAst$translateRoot$0 = ({
  ctx: [],
  usr: c0$Compiler$EmittableAst$translateRoot$1,
});

const c0$List$append$1 = (($xs, $ys) => {
  return ((($ys)[0] === "$Nil")
    ? $xs
    : (true
      ? (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), $ys, $xs, c0$Core$Cons$0)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 228:4', (sp_toHuman)($ys))));
});

const c0$List$append$0 = ({
  ctx: [],
  usr: c0$List$append$1,
});

const c0$List$concat$1 = (($lists) => {
  return (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), c0$Core$Nil$0, $lists, c0$List$append$0);
});

const c0$List$concat$0 = ({
  ctx: [],
  usr: c0$List$concat$1,
});

const c0$Compiler$EmittableAst$translateUsr$1 = (($usr, $id) => {
  const $3 = $usr;
  const $name = ($3)[2];
  const $modulePath = (($3)[1])[3];
  const $sourceDirId = (($3)[1])[2];
  const $root = (($3)[1])[1];
  return (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((c0$Compiler$EmittableAst$translateRoot$0.usr)(...(c0$Compiler$EmittableAst$translateRoot$0.ctx), $root) + (text_fromNumber)($sourceDirId)), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (text_split)("/", $modulePath), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$EmittableAst$translateName$0.usr)(...(c0$Compiler$EmittableAst$translateName$0.ctx), $name), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (text_fromNumber)($id), c0$Core$Nil$0), c0$Core$Nil$0)))));
});

const c0$Compiler$EmittableAst$translateUsr$0 = ({
  ctx: [],
  usr: c0$Compiler$EmittableAst$translateUsr$1,
});

const c0$Compiler$FormattableAst$binopChainAllBinops$1 = (($f, $ls) => {
  const $3 = $ls.second;
  return ((($3)[0] === "$Nil")
    ? true
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $sep = ($3)[1].first;
        const $item = ($3)[1].second;
        const $tail = ($3)[2];
        return (($f.usr)(...($f.ctx), $sep)
          ? (c0$Compiler$FormattableAst$binopChainAllBinops$0.usr)(...(c0$Compiler$FormattableAst$binopChainAllBinops$0.ctx), $f, ({
            first: $item,
            second: $tail,
          }))
          : false);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 175:4', (sp_toHuman)($3))));
});

const c0$Compiler$FormattableAst$binopChainAllBinops$0 = ({
  ctx: [],
  usr: c0$Compiler$FormattableAst$binopChainAllBinops$1,
});

const c0$Tuple$second$1 = (($t) => {
  return $t.second;
});

const c0$Tuple$second$0 = ({
  ctx: [],
  usr: c0$Tuple$second$1,
});

const c0$Compiler$FormattableAst$binopChainExpressions$1 = (($1) => {
  const $head = $1.first;
  const $tuples = $1.second;
  return (sp_cons)($head, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), c0$Tuple$second$0, $tuples));
});

const c0$Compiler$FormattableAst$binopChainExpressions$0 = ({
  ctx: [],
  usr: c0$Compiler$FormattableAst$binopChainExpressions$1,
});

const c0$Compiler$FormattableAst$binopChainReverse$2 = (($rec, $0) => {
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, $0);
});

const c0$Compiler$FormattableAst$binopChainReverse$1 = (($acc, $1) => {
  const $oddItem = $1.first;
  const $remainder = $1.second;
  const $rec = ({
    ctx: [],
    usr: c0$Compiler$FormattableAst$binopChainReverse$1,
  });
  return ((($remainder)[0] === "$Nil")
    ? ({
      first: $oddItem,
      second: $acc,
    })
    : ((($remainder)[0] === "$Cons")
      ? ((() => {
        const $sep = ($remainder)[1].first;
        const $item = ($remainder)[1].second;
        const $tail = ($remainder)[2];
        return ($rec.usr)(...($rec.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
          first: $sep,
          second: $oddItem,
        }), $acc), ({
          first: $item,
          second: $tail,
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 166:8', (sp_toHuman)($remainder))));
});

const c0$Compiler$FormattableAst$binopChainReverse$0 = ((() => {
  const $rec = ({
    ctx: [],
    usr: c0$Compiler$FormattableAst$binopChainReverse$1,
  });
  return ({
    ctx: ([
      $rec,
    ]),
    usr: c0$Compiler$FormattableAst$binopChainReverse$2,
  });
}))();

const c0$Compiler$FormattableAst$statementPos$1 = (($statement) => {
  return ((($statement)[0] === "$CommentStatement")
    ? ((() => {
      const $end = ($statement)[1].end;
      const $start = ($statement)[1].start;
      return (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), $start, $end);
    }))()
    : (((($statement)[0] === "$Evaluation") && ((($statement)[1])[0] === "$Expression"))
      ? ((() => {
        const $pos = (($statement)[1])[2];
        const $expr_ = (($statement)[1])[3];
        return $pos;
      }))()
      : (((($statement)[0] === "$ValueDef") && ((($statement)[1].pattern)[0] === "$Expression"))
        ? ((() => {
          const $body = ($statement)[1].body;
          const $nonFn = ($statement)[1].nonFn;
          const $pos = (($statement)[1].pattern)[2];
          const $expr_ = (($statement)[1].pattern)[3];
          return $pos;
        }))()
        : ((($statement)[0] === "$AliasDef")
          ? ((() => {
            const $args = ($statement)[1].args;
            const $name = ($statement)[1].name;
            const $type = ($statement)[1].type;
            return $name.first;
          }))()
          : ((($statement)[0] === "$UnionDef")
            ? ((() => {
              const $args = ($statement)[1].args;
              const $constructors = ($statement)[1].constructors;
              const $name = ($statement)[1].name;
              return $name.first;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/FormattableAst.sp 189:4', (sp_toHuman)($statement)))))));
});

const c0$Compiler$FormattableAst$statementPos$0 = ({
  ctx: [],
  usr: c0$Compiler$FormattableAst$statementPos$1,
});

const c0$Compiler$Meta$initImports$0 = ({
  globalNameToLocation: c0$Dict$empty$0,
  moduleAliasToLocation: c0$Dict$empty$0,
  modulePathToLocation: c0$Dict$empty$0,
  platforms: c0$Dict$empty$0,
});

const c0$Dict$get$1 = (($targetKey, $dict) => {
  return ((($dict)[0] === "$Empty")
    ? c0$Maybe$Nothing$0
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        const $3 = (basics_compare)($targetKey, $key);
        return ((1 === $3)
          ? (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $targetKey, $right)
          : ((0 === $3)
            ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $value)
            : (true
              ? (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $targetKey, $left)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 25:12', (sp_toHuman)($3)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 19:4', (sp_toHuman)($dict))));
});

const c0$Dict$get$0 = ({
  ctx: [],
  usr: c0$Dict$get$1,
});

const c0$List$filterMap$2 = (($f, $a, $acc) => {
  const $3 = ($f.usr)(...($f.ctx), $a);
  return ((($3)[0] === "$Just")
    ? ((() => {
      const $b = ($3)[1];
      return (sp_cons)($b, $acc);
    }))()
    : ((($3)[0] === "$Nothing")
      ? $acc
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 347:8', (sp_toHuman)($3))));
});

const c0$List$filterMap$1 = (($f, $la) => {
  const $update = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$filterMap$2,
  });
  return (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), c0$Core$Nil$0, $la, $update);
});

const c0$List$filterMap$0 = ({
  ctx: [],
  usr: c0$List$filterMap$1,
});

const c0$Result$onOk$2 = (($f, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), $e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $a = ($result)[1];
        return ($f.usr)(...($f.ctx), $a);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 16:4', (sp_toHuman)($result))));
});

const c0$Result$onOk$1 = (($f) => {
  return ({
    ctx: ([
      $f,
    ]),
    usr: c0$Result$onOk$2,
  });
});

const c0$Result$onOk$0 = ({
  ctx: [],
  usr: c0$Result$onOk$1,
});

const c0$Compiler$Meta$resolveLocation$2 = (($maybeReferencedModuleAlias, $modulePath, $pars, $referencedName, $modulesByPath) => {
  const $2 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $modulePath, $modulesByPath);
  return ((($2)[0] === "$Nothing")
    ? ((($maybeReferencedModuleAlias)[0] === "$Just")
      ? ((() => {
        const $referencedModuleAlias = ($maybeReferencedModuleAlias)[1];
        return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($pars.makeError.usr)(...($pars.makeError.ctx), (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), c0$Basics$identity$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((sp_equal)($referencedModuleAlias, $modulePath)
          ? c0$Maybe$Nothing$0
          : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (((("imports.sp translates `" + $referencedModuleAlias) + "` as `") + $modulePath) + "`"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (("However, library $directoryPathOfLibrary does not expose any " + $modulePath) + " module.")), c0$Core$Nil$0)))));
      }))()
      : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
        ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($pars.makeError.usr)(...($pars.makeError.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((("Library cannot find: " + $modulePath) + " which contains ") + $referencedName), c0$Core$Nil$0)))
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 282:24', (sp_toHuman)($maybeReferencedModuleAlias))))
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $moduleUsrByName = ($2)[1];
        const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $referencedName, $moduleUsrByName);
        return ((($3)[0] === "$Just")
          ? ((() => {
            const $exportOptions = ($3)[1];
            return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $exportOptions.usr);
          }))()
          : ((($3)[0] === "$Nothing")
            ? ((($maybeReferencedModuleAlias)[0] === "$Just")
              ? ((() => {
                const $referencedModuleAlias = ($maybeReferencedModuleAlias)[1];
                return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($pars.makeError.usr)(...($pars.makeError.ctx), ((sp_equal)($referencedModuleAlias, $modulePath)
                  ? (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((($modulePath + " in library $directoryPathOfLibrary does not expose any `") + $referencedName) + "`."), c0$Core$Nil$0)
                  : (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (((("imports.sp translates `" + $referencedModuleAlias) + "` as `") + $modulePath) + "`"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (((("However, " + $modulePath) + " in library $directoryPathOfLibrary does not expose any `") + $referencedName) + "`."), c0$Core$Nil$0)))));
              }))()
              : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
                ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($pars.makeError.usr)(...($pars.makeError.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (($referencedName + " is not in ") + $modulePath), c0$Core$Nil$0)))
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 310:32', (sp_toHuman)($maybeReferencedModuleAlias))))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 304:24', (sp_toHuman)($3))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 279:16', (sp_toHuman)($2))));
});

const c0$Compiler$Meta$resolveLocation$1 = (($pars, $location, $maybeReferencedModuleAlias, $referencedName) => {
  return ((($location)[0] === "$LocationSourceDir")
    ? ((() => {
      const $umr = ($location)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $umr, $referencedName));
    }))()
    : ((($location)[0] === "$LocationLibrary")
      ? ((() => {
        const $importsPath = ($location)[1];
        const $modulePath = ($location)[2];
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $maybeReferencedModuleAlias,
            $modulePath,
            $pars,
            $referencedName,
          ]),
          usr: c0$Compiler$Meta$resolveLocation$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $maybeReferencedModuleAlias,
            $modulePath,
            $pars,
            $referencedName,
          ]),
          usr: c0$Compiler$Meta$resolveLocation$2,
        })).ctx), ($pars.loadExports.usr)(...($pars.loadExports.ctx), $importsPath));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 263:4', (sp_toHuman)($location))));
});

const c0$Compiler$Meta$resolveLocation$0 = ({
  ctx: [],
  usr: c0$Compiler$Meta$resolveLocation$1,
});

const c0$Compiler$Meta$resolve$1 = (($pars, $maybeReferencedModuleAlias, $referencedName) => {
  return ((($maybeReferencedModuleAlias)[0] === "$Just")
    ? ((() => {
      const $alias = ($maybeReferencedModuleAlias)[1];
      const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $alias, $pars.currentImports.moduleAliasToLocation);
      return ((($4)[0] === "$Nothing")
        ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($pars.makeError.usr)(...($pars.makeError.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("I cannot find the module: " + $alias), c0$Core$Nil$0)))
        : ((($4)[0] === "$Just")
          ? ((() => {
            const $location = ($4)[1];
            return (c0$Compiler$Meta$resolveLocation$0.usr)(...(c0$Compiler$Meta$resolveLocation$0.ctx), $pars, $location, $maybeReferencedModuleAlias, $referencedName);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 243:12', (sp_toHuman)($4))));
    }))()
    : ((($maybeReferencedModuleAlias)[0] === "$Nothing")
      ? ((() => {
        const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $referencedName, $pars.currentImports.globalNameToLocation);
        return ((($4)[0] === "$Nothing")
          ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $pars.currentModule, $referencedName))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $location = ($4)[1];
              return (c0$Compiler$Meta$resolveLocation$0.usr)(...(c0$Compiler$Meta$resolveLocation$0.ctx), $pars, $location, $maybeReferencedModuleAlias, $referencedName);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 256:12', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 240:4', (sp_toHuman)($maybeReferencedModuleAlias))));
});

const c0$Compiler$Meta$resolve$0 = ({
  ctx: [],
  usr: c0$Compiler$Meta$resolve$1,
});

const c0$Compiler$Meta$rootDirectoryToPath$1 = (($paths, $rootDirectory) => {
  return ((($rootDirectory)[0] === "$Core")
    ? $paths.core
    : ((($rootDirectory)[0] === "$User")
      ? $paths.project
      : ((($rootDirectory)[0] === "$Installed")
        ? $paths.installed
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Meta.sp 127:4', (sp_toHuman)($rootDirectory)))));
});

const c0$Compiler$Meta$rootDirectoryToPath$0 = ({
  ctx: [],
  usr: c0$Compiler$Meta$rootDirectoryToPath$1,
});

const c0$Compiler$Op$precedence_addittive$0 = 7;

const c0$Compiler$Op$precedence_application$0 = 9;

const c0$Compiler$Op$precedence_comparison$0 = 6;

const c0$Compiler$Op$precedence_cons$0 = 3;

const c0$Compiler$Op$precedence_function$0 = 0;

const c0$Compiler$Op$precedence_logical$0 = 5;

const c0$Compiler$Op$precedence_multiplicative$0 = 8;

const c0$Compiler$Op$precedence_mutop$0 = 1;

const c0$Compiler$Op$precedence_pipe$0 = 2;

const c0$Compiler$Op$precedence_tuple$0 = 4;

const c0$Compiler$Pos$range$1 = (($a, $b) => {
  const $3 = ({
    first: $a,
    second: $b,
  });
  return (((($3.first)[0] === "$P") && (($3.second)[0] === "$P"))
    ? ((() => {
      const $sa = ($3.first)[1];
      const $ea = ($3.first)[2];
      const $sb = ($3.second)[1];
      const $eb = ($3.second)[2];
      return (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), (c0$Basics$min$0.usr)(...(c0$Basics$min$0.ctx), $sa, $sb), (c0$Basics$max$0.usr)(...(c0$Basics$max$0.ctx), $ea, $eb));
    }))()
    : ((($3.first)[0] === "$P")
      ? $a
      : (true
        ? $b
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/Pos.sp 46:4', (sp_toHuman)($3)))));
});

const c0$Compiler$Pos$range$0 = ({
  ctx: [],
  usr: c0$Compiler$Pos$range$1,
});

const c0$Compiler$TypedAst$mapPars$2 = (($f, $par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), ($f.usr)(...($f.ctx), $raw));
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), ((() => {
          const $0 = $full;
          return (Object.assign)({}, $0, ({
            raw: ($f.usr)(...($f.ctx), $0.raw),
          }));
        }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 399:8', (sp_toHuman)($par))));
});

const c0$Compiler$TypedAst$mapPars$1 = (($f, $pars) => {
  const $zzz = ({
    ctx: ([
      $f,
    ]),
    usr: c0$Compiler$TypedAst$mapPars$2,
  });
  return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $zzz, $pars);
});

const c0$Compiler$TypedAst$mapPars$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$mapPars$1,
});

const c0$Compiler$TypedAst$normalizeTyvarId$2 = (($maxId, $k, $v) => {
  return (($v > (basics_cloneUni)($maxId.hack))
    ? ($maxId.hack = (basics_cloneImm)($v))
    : null);
});

const c0$Compiler$TypedAst$normalizeTyvarId$1 = (($hash, $id) => {
  const $3 = (hash_get)($hash, $id);
  return ((($3)[0] === "$Just")
    ? ((() => {
      const $nid = ($3)[1];
      return $nid;
    }))()
    : ((($3)[0] === "$Nothing")
      ? ((() => {
        let $maxId = ({
          hack: 0,
        });
        (hash_each)($hash, ({
          ctx: ([
            $maxId,
          ]),
          usr: c0$Compiler$TypedAst$normalizeTyvarId$2,
        }));
        const $nid = ($maxId.hack + 1);
        (hash_insert)($hash, $id, $nid);
        return $nid;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 459:4', (sp_toHuman)($3))));
});

const c0$Compiler$TypedAst$normalizeTyvarId$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$normalizeTyvarId$1,
});

const c0$Dict$map$1 = (($func, $dict) => {
  return ((($dict)[0] === "$Empty")
    ? c0$Dict$Empty$0
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $key, ($func.usr)(...($func.ctx), $key, $value), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), $func, $left), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), $func, $right));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 317:4', (sp_toHuman)($dict))));
});

const c0$Dict$map$0 = ({
  ctx: [],
  usr: c0$Dict$map$1,
});

const c0$Compiler$TypedAst$normalizeType$5 = (($hash, $0) => {
  return (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $0);
});

const c0$Compiler$TypedAst$normalizeType$4 = (($hash, $0) => {
  return (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $0);
});

const c0$Compiler$TypedAst$normalizeType$3 = (($hash, $k, $v) => {
  return (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $v);
});

const c0$Compiler$TypedAst$normalizeType$2 = (($hash, $k, $v) => {
  return (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $v);
});

const c0$Compiler$TypedAst$normalizeType$1 = (($hash, $type) => {
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $p = ($type)[1];
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), $p, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
        ctx: ([
          $hash,
        ]),
        usr: c0$Compiler$TypedAst$normalizeType$5,
      }), $args));
    }))()
    : ((($type)[0] === "$TypeFn")
      ? ((() => {
        const $p = ($type)[1];
        const $instances = ($type)[2];
        const $pars = ($type)[3];
        const $out = ($type)[4];
        return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $p, $instances, (c0$Compiler$TypedAst$mapPars$0.usr)(...(c0$Compiler$TypedAst$mapPars$0.ctx), ({
          ctx: ([
            $hash,
          ]),
          usr: c0$Compiler$TypedAst$normalizeType$4,
        }), $pars), ((() => {
          const $0 = $out;
          return (Object.assign)({}, $0, ({
            raw: (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $0.raw),
          }));
        }))());
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[2])[0] === "$Nothing"))
        ? ((() => {
          const $p = ($type)[1];
          const $attrs = ($type)[3];
          return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, c0$Maybe$Nothing$0, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
            ctx: ([
              $hash,
            ]),
            usr: c0$Compiler$TypedAst$normalizeType$3,
          }), $attrs));
        }))()
        : (((($type)[0] === "$TypeRecord") && ((($type)[2])[0] === "$Just"))
          ? ((() => {
            const $p = ($type)[1];
            const $id = (($type)[2])[1];
            const $attrs = ($type)[3];
            return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$TypedAst$normalizeTyvarId$0.usr)(...(c0$Compiler$TypedAst$normalizeTyvarId$0.ctx), $hash, $id)), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
              ctx: ([
                $hash,
              ]),
              usr: c0$Compiler$TypedAst$normalizeType$2,
            }), $attrs));
          }))()
          : ((($type)[0] === "$TypeVar")
            ? ((() => {
              const $p = ($type)[1];
              const $id = ($type)[2];
              return (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $p, (c0$Compiler$TypedAst$normalizeTyvarId$0.usr)(...(c0$Compiler$TypedAst$normalizeTyvarId$0.ctx), $hash, $id));
            }))()
            : ((($type)[0] === "$TypeError")
              ? c0$Compiler$TypedAst$TypeError$0
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 484:4', (sp_toHuman)($type))))))));
});

const c0$Compiler$TypedAst$normalizeType$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$normalizeType$1,
});

const c0$Compiler$TypedAst$patternNames$3 = (($x, $a) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $x), $a);
});

const c0$Compiler$TypedAst$patternNames$2 = (($k, $2, $a) => {
  const $pa = $2.first;
  const $ty = $2.second;
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $a, (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $pa));
});

const c0$Compiler$TypedAst$patternNames$1 = (($p) => {
  return (((($p)[0] === "$PatternAny") && ((($p)[2].maybeName)[0] === "$Nothing"))
    ? ((() => {
      const $pos = ($p)[1];
      return c0$Dict$empty$0;
    }))()
    : (((($p)[0] === "$PatternAny") && ((($p)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $pos = ($p)[1];
        const $n = (($p)[2].maybeName)[1];
        const $type = ($p)[2].type;
        return (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $n, ({
          pos: $pos,
          type: $type,
        }));
      }))()
      : ((($p)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $pos = ($p)[1];
          return c0$Dict$empty$0;
        }))()
        : ((($p)[0] === "$PatternLiteralText")
          ? ((() => {
            const $pos = ($p)[1];
            return c0$Dict$empty$0;
          }))()
          : ((($p)[0] === "$PatternConstructor")
            ? ((() => {
              const $pos = ($p)[1];
              const $usr = ($p)[2];
              const $ps = ($p)[3];
              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $ps, ({
                ctx: [],
                usr: c0$Compiler$TypedAst$patternNames$3,
              }));
            }))()
            : ((($p)[0] === "$PatternRecord")
              ? ((() => {
                const $pos = ($p)[1];
                const $ps = ($p)[2];
                return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $ps, ({
                  ctx: [],
                  usr: c0$Compiler$TypedAst$patternNames$2,
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 418:4', (sp_toHuman)($p))))))));
});

const c0$Compiler$TypedAst$patternNames$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$patternNames$1,
});

const c0$Compiler$TypedAst$resolveParType$1 = (($saf, $par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $raw));
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $full));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 198:4', (sp_toHuman)($par))));
});

const c0$Compiler$TypedAst$resolveParType$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveParType$1,
});

const c0$Compiler$TypedAst$resolveRaw$4 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolveParType$0.usr)(...(c0$Compiler$TypedAst$resolveParType$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveRaw$3 = (($rec, $k, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const c0$Compiler$TypedAst$resolveRaw$2 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveRaw$1 = (($saf, $raw) => {
  const $rec = ({
    ctx: ([
      $saf,
    ]),
    usr: c0$Compiler$TypedAst$resolveRaw$2,
  });
  return ((($raw)[0] === "$TypeVar")
    ? ((() => {
      const $id = ($raw)[2];
      const $3 = ($saf.ty.usr)(...($saf.ty.ctx), $id);
      return ((($3)[0] === "$Nothing")
        ? $raw
        : ((($3)[0] === "$Just")
          ? ((() => {
            const $replacement = ($3)[1];
            return $replacement;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 219:12', (sp_toHuman)($3))));
    }))()
    : ((($raw)[0] === "$TypeExact")
      ? ((() => {
        const $p = ($raw)[1];
        const $usr = ($raw)[2];
        const $pars = ($raw)[3];
        return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), $p, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $rec, $pars));
      }))()
      : ((($raw)[0] === "$TypeFn")
        ? ((() => {
          const $p = ($raw)[1];
          const $setId = ($raw)[2];
          const $pars = ($raw)[3];
          const $out = ($raw)[4];
          return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $p, ($saf.lSet.usr)(...($saf.lSet.ctx), $setId), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
            ctx: ([
              $saf,
            ]),
            usr: c0$Compiler$TypedAst$resolveRaw$4,
          }), $pars), (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $out));
        }))()
        : ((($raw)[0] === "$TypeRecord")
          ? ((() => {
            const $p = ($raw)[1];
            const $maybeId = ($raw)[2];
            const $attrs0 = ($raw)[3];
            const $attrs1 = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
              ctx: ([
                $rec,
              ]),
              usr: c0$Compiler$TypedAst$resolveRaw$3,
            }), $attrs0);
            return ((($maybeId)[0] === "$Nothing")
              ? (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, c0$Maybe$Nothing$0, $attrs1)
              : ((($maybeId)[0] === "$Just")
                ? ((() => {
                  const $id = ($maybeId)[1];
                  const $3 = ($saf.ty.usr)(...($saf.ty.ctx), $id);
                  return ((($3)[0] === "$Nothing")
                    ? (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $id), $attrs1)
                    : (((($3)[0] === "$Just") && ((($3)[1])[0] === "$TypeRecord"))
                      ? ((() => {
                        const $maybeNewId = (($3)[1])[2];
                        const $newAttrs = (($3)[1])[3];
                        return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, $maybeNewId, (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $newAttrs, $attrs1));
                      }))()
                      : (((($3)[0] === "$Just") && ((($3)[1])[0] === "$TypeVar"))
                        ? ((() => {
                          const $newId = (($3)[1])[2];
                          return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $newId), $attrs1);
                        }))()
                        : (true
                          ? c0$Compiler$TypedAst$TypeError$0
                          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 239:20', (sp_toHuman)($3))))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 233:12', (sp_toHuman)($maybeId))));
          }))()
          : ((($raw)[0] === "$TypeError")
            ? c0$Compiler$TypedAst$TypeError$0
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 216:4', (sp_toHuman)($raw)))))));
});

const c0$Compiler$TypedAst$resolveRaw$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveRaw$1,
});

const c0$Compiler$TypedAst$resolveUni$1 = (($uniSub, $uni) => {
  return ((($uni)[0] === "$Depends")
    ? ((() => {
      const $id = ($uni)[1];
      const $3 = ($uniSub.usr)(...($uniSub.ctx), $id);
      return ((($3)[0] === "$Nothing")
        ? $uni
        : ((($3)[0] === "$Just")
          ? ((() => {
            const $u = ($3)[1];
            return $u;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 188:12', (sp_toHuman)($3))));
    }))()
    : (true
      ? $uni
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 185:4', (sp_toHuman)($uni))));
});

const c0$Compiler$TypedAst$resolveUni$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveUni$1,
});

const c0$Compiler$TypedAst$resolveFull$1 = (($saf, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return ({
    raw: (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $raw),
    uni: (c0$Compiler$TypedAst$resolveUni$0.usr)(...(c0$Compiler$TypedAst$resolveUni$0.ctx), $saf.uni, $uni),
  });
});

const c0$Compiler$TypedAst$resolveFull$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveFull$1,
});

const c0$Compiler$TypedAst$resolvePattern$3 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolvePattern$0.usr)(...(c0$Compiler$TypedAst$resolvePattern$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolvePattern$2 = (($saf, $k, $1) => {
  const $p = $1.first;
  const $t = $1.second;
  return ({
    first: (c0$Compiler$TypedAst$resolvePattern$0.usr)(...(c0$Compiler$TypedAst$resolvePattern$0.ctx), $saf, $p),
    second: (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $t),
  });
});

const c0$Compiler$TypedAst$resolvePattern$1 = (($saf, $pattern) => {
  return ((($pattern)[0] === "$PatternLiteralNumber")
    ? ((() => {
      const $pos = ($pattern)[1];
      return $pattern;
    }))()
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $pos = ($pattern)[1];
        return $pattern;
      }))()
      : ((($pattern)[0] === "$PatternAny")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $stuff = ($pattern)[2];
          return (c0$Compiler$TypedAst$PatternAny$0.usr)(...(c0$Compiler$TypedAst$PatternAny$0.ctx), $pos, ((() => {
            const $0 = $stuff;
            return (Object.assign)({}, $0, ({
              type: (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $0.type),
            }));
          }))());
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $usr = ($pattern)[2];
            const $ps = ($pattern)[3];
            return (c0$Compiler$TypedAst$PatternConstructor$0.usr)(...(c0$Compiler$TypedAst$PatternConstructor$0.ctx), $pos, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
              ctx: ([
                $saf,
              ]),
              usr: c0$Compiler$TypedAst$resolvePattern$3,
            }), $ps));
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $ps = ($pattern)[2];
              return (c0$Compiler$TypedAst$PatternRecord$0.usr)(...(c0$Compiler$TypedAst$PatternRecord$0.ctx), $pos, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                ctx: ([
                  $saf,
                ]),
                usr: c0$Compiler$TypedAst$resolvePattern$2,
              }), $ps));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 332:4', (sp_toHuman)($pattern)))))));
});

const c0$Compiler$TypedAst$resolvePattern$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolvePattern$1,
});

const c0$Compiler$TypedAst$resolveLocalDef$1 = (($saf, $def) => {
  return ({
    body: (c0$Compiler$TypedAst$resolveExpression$0.usr)(...(c0$Compiler$TypedAst$resolveExpression$0.ctx), $saf, $def.body),
    pattern: (c0$Compiler$TypedAst$resolvePattern$0.usr)(...(c0$Compiler$TypedAst$resolvePattern$0.ctx), $saf, $def.pattern),
    type: (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $def.type),
  });
});

const c0$Compiler$TypedAst$resolveLocalDef$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveLocalDef$1,
});

const c0$Maybe$map$1 = (($f, $m) => {
  return ((($m)[0] === "$Nothing")
    ? c0$Maybe$Nothing$0
    : ((($m)[0] === "$Just")
      ? ((() => {
        const $v = ($m)[1];
        return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ($f.usr)(...($f.ctx), $v));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 16:4', (sp_toHuman)($m))));
});

const c0$Maybe$map$0 = ({
  ctx: [],
  usr: c0$Maybe$map$1,
});

const c0$Tuple$mapBoth$1 = (($fa, $fb, $t) => {
  return ({
    first: ($fa.usr)(...($fa.ctx), $t.first),
    second: ($fb.usr)(...($fb.ctx), $t.second),
  });
});

const c0$Tuple$mapBoth$0 = ({
  ctx: [],
  usr: c0$Tuple$mapBoth$1,
});

const c0$Compiler$TypedAst$resolveExpression$7 = (($saf, $name, $type) => {
  return (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $type);
});

const c0$Compiler$TypedAst$resolveExpression$6 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolveArg$0.usr)(...(c0$Compiler$TypedAst$resolveArg$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveExpression$5 = (($rec, $k, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const c0$Compiler$TypedAst$resolveExpression$4 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolvePattern$0.usr)(...(c0$Compiler$TypedAst$resolvePattern$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveExpression$3 = (($rec, $saf, $0) => {
  return (c0$Tuple$mapBoth$0.usr)(...(c0$Tuple$mapBoth$0.ctx), ({
    ctx: ([
      $saf,
    ]),
    usr: c0$Compiler$TypedAst$resolveExpression$4,
  }), $rec, $0);
});

const c0$Compiler$TypedAst$resolveExpression$2 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolveExpression$0.usr)(...(c0$Compiler$TypedAst$resolveExpression$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveExpression$1 = (($saf, $expression) => {
  const $rec = ({
    ctx: ([
      $saf,
    ]),
    usr: c0$Compiler$TypedAst$resolveExpression$2,
  });
  return ((($expression)[0] === "$LiteralNumber")
    ? $expression
    : ((($expression)[0] === "$LiteralText")
      ? $expression
      : ((($expression)[0] === "$Variable")
        ? $expression
        : ((($expression)[0] === "$Constructor")
          ? $expression
          : ((($expression)[0] === "$Lambda")
            ? ((() => {
              const $pos = ($expression)[1];
              const $pars = ($expression)[2];
              return (c0$Compiler$TypedAst$Lambda$0.usr)(...(c0$Compiler$TypedAst$Lambda$0.ctx), $pos, ((() => {
                const $0 = $pars;
                return (Object.assign)({}, $0, ({
                  context: (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                    ctx: ([
                      $saf,
                    ]),
                    usr: c0$Compiler$TypedAst$resolveExpression$7,
                  }), $0.context),
                }));
              }))());
            }))()
            : ((($expression)[0] === "$Call")
              ? ((() => {
                const $p = ($expression)[1];
                const $setId = ($expression)[2];
                const $ref = ($expression)[3];
                const $args = ($expression)[4];
                return (c0$Compiler$TypedAst$Call$0.usr)(...(c0$Compiler$TypedAst$Call$0.ctx), $p, ($saf.lSet.usr)(...($saf.lSet.ctx), $setId), ($rec.usr)(...($rec.ctx), $ref), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                  ctx: ([
                    $saf,
                  ]),
                  usr: c0$Compiler$TypedAst$resolveExpression$6,
                }), $args));
              }))()
              : ((($expression)[0] === "$Record")
                ? ((() => {
                  const $p = ($expression)[1];
                  const $maybeExt = ($expression)[2];
                  const $attrs = ($expression)[3];
                  return (c0$Compiler$TypedAst$Record$0.usr)(...(c0$Compiler$TypedAst$Record$0.ctx), $p, (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), $rec, $maybeExt), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                    ctx: ([
                      $rec,
                    ]),
                    usr: c0$Compiler$TypedAst$resolveExpression$5,
                  }), $attrs));
                }))()
                : ((($expression)[0] === "$RecordAccess")
                  ? ((() => {
                    const $p = ($expression)[1];
                    const $name = ($expression)[2];
                    const $exp = ($expression)[3];
                    return (c0$Compiler$TypedAst$RecordAccess$0.usr)(...(c0$Compiler$TypedAst$RecordAccess$0.ctx), $p, $name, ($rec.usr)(...($rec.ctx), $exp));
                  }))()
                  : ((($expression)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($expression)[1];
                      const $rest = ($expression)[2];
                      const $restType = ($expression)[3];
                      return (c0$Compiler$TypedAst$LetIn$0.usr)(...(c0$Compiler$TypedAst$LetIn$0.ctx), (c0$Compiler$TypedAst$resolveLocalDef$0.usr)(...(c0$Compiler$TypedAst$resolveLocalDef$0.ctx), $saf, $def), ($rec.usr)(...($rec.ctx), $rest), (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $restType));
                    }))()
                    : ((($expression)[0] === "$If")
                      ? ((() => {
                        const $p = ($expression)[1];
                        const $condition = ($expression)[2].condition;
                        const $false = ($expression)[2].false;
                        const $true = ($expression)[2].true;
                        return (c0$Compiler$TypedAst$If$0.usr)(...(c0$Compiler$TypedAst$If$0.ctx), $p, ({
                          condition: ($rec.usr)(...($rec.ctx), $condition),
                          false: ($rec.usr)(...($rec.ctx), $false),
                          true: ($rec.usr)(...($rec.ctx), $true),
                        }));
                      }))()
                      : ((($expression)[0] === "$Try")
                        ? ((() => {
                          const $p = ($expression)[1];
                          const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                          const $value = ($expression)[2].value;
                          const $valueType = ($expression)[2].valueType;
                          return (c0$Compiler$TypedAst$Try$0.usr)(...(c0$Compiler$TypedAst$Try$0.ctx), $p, ({
                            patternsAndExpressions: (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                              ctx: ([
                                $rec,
                                $saf,
                              ]),
                              usr: c0$Compiler$TypedAst$resolveExpression$3,
                            }), $patternsAndExpressions),
                            value: ($rec.usr)(...($rec.ctx), $value),
                            valueType: (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $valueType),
                          }));
                        }))()
                        : ((($expression)[0] === "$DestroyIn")
                          ? ((() => {
                            const $n = ($expression)[1];
                            const $e = ($expression)[2];
                            return (c0$Compiler$TypedAst$DestroyIn$0.usr)(...(c0$Compiler$TypedAst$DestroyIn$0.ctx), $n, ($rec.usr)(...($rec.ctx), $e));
                          }))()
                          : ((($expression)[0] === "$Error")
                            ? ((() => {
                              const $p = ($expression)[1];
                              return $expression;
                            }))()
                            : ((($expression)[0] === "$Introspect")
                              ? $expression
                              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 278:4', (sp_toHuman)($expression))))))))))))))));
});

const c0$Compiler$TypedAst$resolveExpression$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveExpression$1,
});

const c0$Compiler$TypedAst$resolveArg$1 = (($saf, $arg) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $full = ($arg)[1];
      const $expr = ($arg)[2];
      return (c0$Compiler$TypedAst$ArgumentExpression$0.usr)(...(c0$Compiler$TypedAst$ArgumentExpression$0.ctx), (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $full), (c0$Compiler$TypedAst$resolveExpression$0.usr)(...(c0$Compiler$TypedAst$resolveExpression$0.ctx), $saf, $expr));
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $p = ($arg)[1];
        const $raw = ($arg)[2];
        const $attrPath = ($arg)[3];
        const $name = ($arg)[4];
        return (c0$Compiler$TypedAst$ArgumentRecycle$0.usr)(...(c0$Compiler$TypedAst$ArgumentRecycle$0.ctx), $p, (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $raw), $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 260:4', (sp_toHuman)($arg))));
});

const c0$Compiler$TypedAst$resolveArg$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveArg$1,
});

const c0$Compiler$TypedAst$resolvePar$1 = (($saf, $par) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $full = ($par)[1];
      const $pa = ($par)[2];
      return (c0$Compiler$TypedAst$ParameterPattern$0.usr)(...(c0$Compiler$TypedAst$ParameterPattern$0.ctx), (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $full), (c0$Compiler$TypedAst$resolvePattern$0.usr)(...(c0$Compiler$TypedAst$resolvePattern$0.ctx), $saf, $pa));
    }))()
    : ((($par)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $full = ($par)[1];
        const $n = ($par)[2];
        return (c0$Compiler$TypedAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$TypedAst$ParameterPlaceholder$0.ctx), (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $full), $n);
      }))()
      : ((($par)[0] === "$ParameterRecycle")
        ? ((() => {
          const $p = ($par)[1];
          const $raw = ($par)[2];
          const $name = ($par)[3];
          return (c0$Compiler$TypedAst$ParameterRecycle$0.usr)(...(c0$Compiler$TypedAst$ParameterRecycle$0.ctx), $p, (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $raw), $name);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 267:4', (sp_toHuman)($par)))));
});

const c0$Compiler$TypedAst$resolvePar$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolvePar$1,
});

const c0$Compiler$TypedAst$resolveLambda$2 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolvePar$0.usr)(...(c0$Compiler$TypedAst$resolvePar$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveLambda$1 = (($saf, $lam) => {
  return ({
    body: (c0$Compiler$TypedAst$resolveExpression$0.usr)(...(c0$Compiler$TypedAst$resolveExpression$0.ctx), $saf, $lam.body),
    lambdaSetId: ($saf.lSet.usr)(...($saf.lSet.ctx), $lam.lambdaSetId),
    pars: (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
      ctx: ([
        $saf,
      ]),
      usr: c0$Compiler$TypedAst$resolveLambda$2,
    }), $lam.pars),
    returnType: (c0$Compiler$TypedAst$resolveFull$0.usr)(...(c0$Compiler$TypedAst$resolveFull$0.ctx), $saf, $lam.returnType),
  });
});

const c0$Compiler$TypedAst$resolveLambda$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveLambda$1,
});

const c0$Dict$moveRedLeft$1 = (($dict) => {
  return (((($dict)[0] === "$Node") && (((($dict)[4])[0] === "$Node") && (((($dict)[5])[0] === "$Node") && ((((($dict)[5])[4])[0] === "$Node") && ((((($dict)[5])[4])[1])[0] === "$Red")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $lLeft = (($dict)[4])[4];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rlK = ((($dict)[5])[4])[2];
      const $rlV = ((($dict)[5])[4])[3];
      const $rlL = ((($dict)[5])[4])[4];
      const $rlR = ((($dict)[5])[4])[5];
      const $rRight = (($dict)[5])[5];
      return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $rlK, $rlV, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, $lLeft, $lRight), $rlL), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $rK, $rV, $rlR, $rRight));
    }))()
    : (((($dict)[0] === "$Node") && (((($dict)[4])[0] === "$Node") && ((($dict)[5])[0] === "$Node")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "$Black")
          ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, $lLeft, $lRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "$Red")
            ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, $lLeft, $lRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 212:12', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 206:4', (sp_toHuman)($dict)))));
});

const c0$Dict$moveRedLeft$0 = ({
  ctx: [],
  usr: c0$Dict$moveRedLeft$1,
});

const c0$Dict$getMin$1 = (($dict) => {
  return ((($dict)[0] === "$Node")
    ? ((() => {
      const $left = ($dict)[4];
      return ((($left)[0] === "$Node")
        ? (c0$Dict$getMin$0.usr)(...(c0$Dict$getMin$0.ctx), $left)
        : (true
          ? $dict
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 165:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? $dict
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 162:4', (sp_toHuman)($dict))));
});

const c0$Dict$getMin$0 = ({
  ctx: [],
  usr: c0$Dict$getMin$1,
});

const c0$Dict$removeMin$1 = (($dict) => {
  return ((($dict)[0] === "$Node")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((($left)[0] === "$Node")
        ? ((() => {
          const $lColor = ($left)[1];
          const $lLeft = ($left)[4];
          return ((($lColor)[0] === "$Black")
            ? (((($lLeft)[0] === "$Node") && ((($lLeft)[1])[0] === "$Red"))
              ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $key, $value, (c0$Dict$removeMin$0.usr)(...(c0$Dict$removeMin$0.ctx), $left), $right)
              : (true
                ? ((() => {
                  const $2 = (c0$Dict$moveRedLeft$0.usr)(...(c0$Dict$moveRedLeft$0.ctx), $dict);
                  return ((($2)[0] === "$Node")
                    ? ((() => {
                      const $nColor = ($2)[1];
                      const $nKey = ($2)[2];
                      const $nValue = ($2)[3];
                      const $nLeft = ($2)[4];
                      const $nRight = ($2)[5];
                      return (c0$Dict$balance$0.usr)(...(c0$Dict$balance$0.ctx), $nColor, $nKey, $nValue, (c0$Dict$removeMin$0.usr)(...(c0$Dict$removeMin$0.ctx), $nLeft), $nRight);
                    }))()
                    : ((($2)[0] === "$Empty")
                      ? c0$Dict$Empty$0
                      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 190:36', (sp_toHuman)($2))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 184:28', (sp_toHuman)($lLeft))))
            : (true
              ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $key, $value, (c0$Dict$removeMin$0.usr)(...(c0$Dict$removeMin$0.ctx), $left), $right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 181:20', (sp_toHuman)($lColor))));
        }))()
        : (true
          ? c0$Dict$Empty$0
          : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 178:12', (sp_toHuman)($left))));
    }))()
    : (true
      ? c0$Dict$Empty$0
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 175:4', (sp_toHuman)($dict))));
});

const c0$Dict$removeMin$0 = ({
  ctx: [],
  usr: c0$Dict$removeMin$1,
});

const c0$Dict$removeHelpEQGT$1 = (($targetKey, $dict) => {
  return ((($dict)[0] === "$Node")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $value = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return ((sp_equal)($targetKey, $key)
        ? ((() => {
          const $3 = (c0$Dict$getMin$0.usr)(...(c0$Dict$getMin$0.ctx), $right);
          return ((($3)[0] === "$Node")
            ? ((() => {
              const $minKey = ($3)[2];
              const $minValue = ($3)[3];
              return (c0$Dict$balance$0.usr)(...(c0$Dict$balance$0.ctx), $color, $minKey, $minValue, $left, (c0$Dict$removeMin$0.usr)(...(c0$Dict$removeMin$0.ctx), $right));
            }))()
            : ((($3)[0] === "$Empty")
              ? c0$Dict$Empty$0
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 150:16', (sp_toHuman)($3))));
        }))()
        : (c0$Dict$balance$0.usr)(...(c0$Dict$balance$0.ctx), $color, $key, $value, $left, (c0$Dict$removeHelp$0.usr)(...(c0$Dict$removeHelp$0.ctx), $targetKey, $right)));
    }))()
    : ((($dict)[0] === "$Empty")
      ? c0$Dict$Empty$0
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 146:4', (sp_toHuman)($dict))));
});

const c0$Dict$removeHelpEQGT$0 = ({
  ctx: [],
  usr: c0$Dict$removeHelpEQGT$1,
});

const c0$Dict$moveRedRight$1 = (($dict) => {
  return (((($dict)[0] === "$Node") && (((($dict)[4])[0] === "$Node") && ((((($dict)[4])[4])[0] === "$Node") && (((((($dict)[4])[4])[1])[0] === "$Red") && ((($dict)[5])[0] === "$Node")))))
    ? ((() => {
      const $clr = ($dict)[1];
      const $k = ($dict)[2];
      const $v = ($dict)[3];
      const $lClr = (($dict)[4])[1];
      const $lK = (($dict)[4])[2];
      const $lV = (($dict)[4])[3];
      const $llK = ((($dict)[4])[4])[2];
      const $llV = ((($dict)[4])[4])[3];
      const $llLeft = ((($dict)[4])[4])[4];
      const $llRight = ((($dict)[4])[4])[5];
      const $lRight = (($dict)[4])[5];
      const $rClr = (($dict)[5])[1];
      const $rK = (($dict)[5])[2];
      const $rV = (($dict)[5])[3];
      const $rLeft = (($dict)[5])[4];
      const $rRight = (($dict)[5])[5];
      return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $llK, $llV, $llLeft, $llRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, $lRight, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $rK, $rV, $rLeft, $rRight)));
    }))()
    : (((($dict)[0] === "$Node") && (((($dict)[4])[0] === "$Node") && ((($dict)[5])[0] === "$Node")))
      ? ((() => {
        const $clr = ($dict)[1];
        const $k = ($dict)[2];
        const $v = ($dict)[3];
        const $lClr = (($dict)[4])[1];
        const $lK = (($dict)[4])[2];
        const $lV = (($dict)[4])[3];
        const $lLeft = (($dict)[4])[4];
        const $lRight = (($dict)[4])[5];
        const $rClr = (($dict)[5])[1];
        const $rK = (($dict)[5])[2];
        const $rV = (($dict)[5])[3];
        const $rLeft = (($dict)[5])[4];
        const $rRight = (($dict)[5])[5];
        return ((($clr)[0] === "$Black")
          ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, $lLeft, $lRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $rK, $rV, $rLeft, $rRight))
          : ((($clr)[0] === "$Red")
            ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $lK, $lV, $lLeft, $lRight), (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $rK, $rV, $rLeft, $rRight))
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 228:12', (sp_toHuman)($clr))));
      }))()
      : (true
        ? $dict
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 222:4', (sp_toHuman)($dict)))));
});

const c0$Dict$moveRedRight$0 = ({
  ctx: [],
  usr: c0$Dict$moveRedRight$1,
});

const c0$Dict$removeHelpPrepEQGT$1 = (($targetKey, $dict, $color, $key, $value, $left, $right) => {
  return (((($left)[0] === "$Node") && ((($left)[1])[0] === "$Red"))
    ? ((() => {
      const $lK = ($left)[2];
      const $lV = ($left)[3];
      const $lLeft = ($left)[4];
      const $lRight = ($left)[5];
      return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $lK, $lV, $lLeft, (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Red$0, $key, $value, $lRight, $right));
    }))()
    : (true
      ? (((($right)[0] === "$Node") && (((($right)[1])[0] === "$Black") && (((($right)[4])[0] === "$Node") && (((($right)[4])[1])[0] === "$Black"))))
        ? (c0$Dict$moveRedRight$0.usr)(...(c0$Dict$moveRedRight$0.ctx), $dict)
        : (((($right)[0] === "$Node") && (((($right)[1])[0] === "$Black") && ((($right)[4])[0] === "$Empty")))
          ? (c0$Dict$moveRedRight$0.usr)(...(c0$Dict$moveRedRight$0.ctx), $dict)
          : (true
            ? $dict
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 138:12', (sp_toHuman)($right)))))
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 132:4', (sp_toHuman)($left))));
});

const c0$Dict$removeHelpPrepEQGT$0 = ({
  ctx: [],
  usr: c0$Dict$removeHelpPrepEQGT$1,
});

const c0$Dict$removeHelp$1 = (($targetKey, $dict) => {
  return ((($dict)[0] === "$Empty")
    ? c0$Dict$Empty$0
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $color = ($dict)[1];
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ((sp_equal)((basics_compare)($targetKey, $key), (0 - 1))
          ? (((($left)[0] === "$Node") && ((($left)[1])[0] === "$Black"))
            ? ((() => {
              const $lLeft = ($left)[4];
              return (((($lLeft)[0] === "$Node") && ((($lLeft)[1])[0] === "$Red"))
                ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $key, $value, (c0$Dict$removeHelp$0.usr)(...(c0$Dict$removeHelp$0.ctx), $targetKey, $left), $right)
                : (true
                  ? ((() => {
                    const $3 = (c0$Dict$moveRedLeft$0.usr)(...(c0$Dict$moveRedLeft$0.ctx), $dict);
                    return ((($3)[0] === "$Node")
                      ? ((() => {
                        const $nColor = ($3)[1];
                        const $nKey = ($3)[2];
                        const $nValue = ($3)[3];
                        const $nLeft = ($3)[4];
                        const $nRight = ($3)[5];
                        return (c0$Dict$balance$0.usr)(...(c0$Dict$balance$0.ctx), $nColor, $nKey, $nValue, (c0$Dict$removeHelp$0.usr)(...(c0$Dict$removeHelp$0.ctx), $targetKey, $nLeft), $nRight);
                      }))()
                      : ((($3)[0] === "$Empty")
                        ? c0$Dict$Empty$0
                        : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 120:32', (sp_toHuman)($3))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 114:24', (sp_toHuman)($lLeft))));
            }))()
            : (true
              ? (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), $color, $key, $value, (c0$Dict$removeHelp$0.usr)(...(c0$Dict$removeHelp$0.ctx), $targetKey, $left), $right)
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 111:16', (sp_toHuman)($left))))
          : (c0$Dict$removeHelpEQGT$0.usr)(...(c0$Dict$removeHelpEQGT$0.ctx), $targetKey, (c0$Dict$removeHelpPrepEQGT$0.usr)(...(c0$Dict$removeHelpPrepEQGT$0.ctx), $targetKey, $dict, $color, $key, $value, $left, $right)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 104:4', (sp_toHuman)($dict))));
});

const c0$Dict$removeHelp$0 = ({
  ctx: [],
  usr: c0$Dict$removeHelp$1,
});

const c0$Dict$remove$1 = (($key, $dict) => {
  const $3 = (c0$Dict$removeHelp$0.usr)(...(c0$Dict$removeHelp$0.ctx), $key, $dict);
  return (((($3)[0] === "$Node") && ((($3)[1])[0] === "$Red"))
    ? ((() => {
      const $k = ($3)[2];
      const $v = ($3)[3];
      const $l = ($3)[4];
      const $r = ($3)[5];
      return (c0$Dict$Node$0.usr)(...(c0$Dict$Node$0.ctx), c0$Dict$Black$0, $k, $v, $l, $r);
    }))()
    : (true
      ? ((() => {
        const $x = $3;
        return $x;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 97:4', (sp_toHuman)($3))));
});

const c0$Dict$remove$0 = ({
  ctx: [],
  usr: c0$Dict$remove$1,
});

const c0$Dict$update$1 = (($targetKey, $alter, $dictionary) => {
  const $4 = ($alter.usr)(...($alter.ctx), (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $targetKey, $dictionary));
  return ((($4)[0] === "$Just")
    ? ((() => {
      const $value = ($4)[1];
      return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $targetKey, $value, $dictionary);
    }))()
    : ((($4)[0] === "$Nothing")
      ? (c0$Dict$remove$0.usr)(...(c0$Dict$remove$0.ctx), $targetKey, $dictionary)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 238:4', (sp_toHuman)($4))));
});

const c0$Dict$update$0 = ({
  ctx: [],
  usr: c0$Dict$update$1,
});

const c0$Maybe$withDefault$1 = (($default, $maybe) => {
  return ((($maybe)[0] === "$Just")
    ? ((() => {
      const $v = ($maybe)[1];
      return $v;
    }))()
    : ((($maybe)[0] === "$Nothing")
      ? $default
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 50:4', (sp_toHuman)($maybe))));
});

const c0$Maybe$withDefault$0 = ({
  ctx: [],
  usr: c0$Maybe$withDefault$1,
});

const c0$Set$empty$0 = c0$Dict$empty$0;

const c0$Set$join$0 = c0$Dict$join$0;

const c0$Compiler$TypedAst$resolveLambdaSetConstraints$3 = (($requiredLambdas, $0) => {
  return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Set$join$0.usr)(...(c0$Set$join$0.ctx), $requiredLambdas, (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Set$empty$0, $0)));
});

const c0$Compiler$TypedAst$resolveLambdaSetConstraints$2 = (($saf, $oldId, $requiredLambdas, $resolvedConstraints) => {
  const $newId = ($saf.lSet.usr)(...($saf.lSet.ctx), $oldId);
  return (c0$Dict$update$0.usr)(...(c0$Dict$update$0.ctx), $newId, ({
    ctx: ([
      $requiredLambdas,
    ]),
    usr: c0$Compiler$TypedAst$resolveLambdaSetConstraints$3,
  }), $resolvedConstraints);
});

const c0$Compiler$TypedAst$resolveLambdaSetConstraints$1 = (($saf, $constraints) => {
  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $constraints, ({
    ctx: ([
      $saf,
    ]),
    usr: c0$Compiler$TypedAst$resolveLambdaSetConstraints$2,
  }));
});

const c0$Compiler$TypedAst$resolveLambdaSetConstraints$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveLambdaSetConstraints$1,
});

const c0$Compiler$TypedAst$resolveRootDef$3 = (($saf, $id, $lambda) => {
  return (c0$Compiler$TypedAst$resolveLambda$0.usr)(...(c0$Compiler$TypedAst$resolveLambda$0.ctx), $saf, $lambda);
});

const c0$Compiler$TypedAst$resolveRootDef$2 = (($saf, $0) => {
  return (c0$Compiler$TypedAst$resolveExpression$0.usr)(...(c0$Compiler$TypedAst$resolveExpression$0.ctx), $saf, $0);
});

const c0$Compiler$TypedAst$resolveRootDef$1 = (($saf, $def) => {
  return ({
    body: (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), ({
      ctx: ([
        $saf,
      ]),
      usr: c0$Compiler$TypedAst$resolveRootDef$2,
    }), $def.body),
    directDeps: $def.directDeps,
    freeTyvars: $def.freeTyvars,
    freeUnivars: $def.freeUnivars,
    lambdaSetConstraints: (c0$Compiler$TypedAst$resolveLambdaSetConstraints$0.usr)(...(c0$Compiler$TypedAst$resolveLambdaSetConstraints$0.ctx), $saf, $def.lambdaSetConstraints),
    lambdas: (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
      ctx: ([
        $saf,
      ]),
      usr: c0$Compiler$TypedAst$resolveRootDef$3,
    }), $def.lambdas),
    name: $def.name,
    type: (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $saf, $def.type),
  });
});

const c0$Compiler$TypedAst$resolveRootDef$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$resolveRootDef$1,
});

const c0$Compiler$TypedAst$rootLambdaRef$0 = 0;

const c0$Compiler$TypedAst$stripTypePos$2 = (($rec, $k, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const c0$Compiler$TypedAst$stripTypePos$1 = (($raw) => {
  const $rec = c0$Compiler$TypedAst$stripTypePos$0;
  const $pos = c0$Compiler$Pos$T$0;
  return ((($raw)[0] === "$TypeVar")
    ? ((() => {
      const $id = ($raw)[2];
      return (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $pos, $id);
    }))()
    : ((($raw)[0] === "$TypeExact")
      ? ((() => {
        const $usr = ($raw)[2];
        const $pars = ($raw)[3];
        return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), $pos, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $rec, $pars));
      }))()
      : ((($raw)[0] === "$TypeFn")
        ? ((() => {
          const $instances = ($raw)[2];
          const $pars = ($raw)[3];
          const $out = ($raw)[4];
          return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $pos, $instances, (c0$Compiler$TypedAst$mapPars$0.usr)(...(c0$Compiler$TypedAst$mapPars$0.ctx), $rec, $pars), ((() => {
            const $0 = $out;
            return (Object.assign)({}, $0, ({
              raw: ($rec.usr)(...($rec.ctx), $0.raw),
            }));
          }))());
        }))()
        : ((($raw)[0] === "$TypeRecord")
          ? ((() => {
            const $maybeId = ($raw)[2];
            const $attrs0 = ($raw)[3];
            return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $pos, $maybeId, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
              ctx: ([
                $rec,
              ]),
              usr: c0$Compiler$TypedAst$stripTypePos$2,
            }), $attrs0));
          }))()
          : ((($raw)[0] === "$TypeError")
            ? c0$Compiler$TypedAst$TypeError$0
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 501:4', (sp_toHuman)($raw)))))));
});

const c0$Compiler$TypedAst$stripTypePos$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$stripTypePos$1,
});

const c0$Compiler$TypedAst$toRaw$1 = (($par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return $raw;
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return $full.raw;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 390:4', (sp_toHuman)($par))));
});

const c0$Compiler$TypedAst$toRaw$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$toRaw$1,
});

const c0$Dict$any$1 = (($f, $dict) => {
  return ((($dict)[0] === "$Node")
    ? ((() => {
      const $color = ($dict)[1];
      const $key = ($dict)[2];
      const $v = ($dict)[3];
      const $left = ($dict)[4];
      const $right = ($dict)[5];
      return (($f.usr)(...($f.ctx), $key, $v)
        ? true
        : ((c0$Dict$any$0.usr)(...(c0$Dict$any$0.ctx), $f, $left) || (c0$Dict$any$0.usr)(...(c0$Dict$any$0.ctx), $f, $right)));
    }))()
    : ((($dict)[0] === "$Empty")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 412:4', (sp_toHuman)($dict))));
});

const c0$Dict$any$0 = ({
  ctx: [],
  usr: c0$Dict$any$1,
});

const c0$List$any$1 = (($fun, $list) => {
  return ((($list)[0] === "$Nil")
    ? false
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($fun.usr)(...($fun.ctx), $h)
          ? true
          : (c0$List$any$0.usr)(...(c0$List$any$0.ctx), $fun, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 3:4', (sp_toHuman)($list))));
});

const c0$List$any$0 = ({
  ctx: [],
  usr: c0$List$any$1,
});

const c0$Compiler$TypedAst$typeAllowsFunctions$3 = (($testId, $0) => {
  return (c0$Compiler$TypedAst$typeAllowsFunctions$0.usr)(...(c0$Compiler$TypedAst$typeAllowsFunctions$0.ctx), $testId, $0);
});

const c0$Compiler$TypedAst$typeAllowsFunctions$2 = (($testId, $k, $v) => {
  return (c0$Compiler$TypedAst$typeAllowsFunctions$0.usr)(...(c0$Compiler$TypedAst$typeAllowsFunctions$0.ctx), $testId, $v);
});

const c0$Compiler$TypedAst$typeAllowsFunctions$1 = (($testId, $type) => {
  return ((($type)[0] === "$TypeFn")
    ? ((() => {
      const $ins = ($type)[3];
      const $out = ($type)[4];
      return true;
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[2];
        return ($testId.usr)(...($testId.ctx), $id);
      }))()
      : ((($type)[0] === "$TypeExact")
        ? ((() => {
          const $usr = ($type)[2];
          const $args = ($type)[3];
          return (c0$List$any$0.usr)(...(c0$List$any$0.ctx), ({
            ctx: ([
              $testId,
            ]),
            usr: c0$Compiler$TypedAst$typeAllowsFunctions$3,
          }), $args);
        }))()
        : ((($type)[0] === "$TypeRecord")
          ? ((() => {
            const $attrs = ($type)[3];
            return (c0$Dict$any$0.usr)(...(c0$Dict$any$0.ctx), ({
              ctx: ([
                $testId,
              ]),
              usr: c0$Compiler$TypedAst$typeAllowsFunctions$2,
            }), $attrs);
          }))()
          : ((($type)[0] === "$TypeError")
            ? true
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 449:4', (sp_toHuman)($type)))))));
});

const c0$Compiler$TypedAst$typeAllowsFunctions$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$typeAllowsFunctions$1,
});

const c0$Set$ofOne$1 = (($0) => {
  return (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $0, null);
});

const c0$Set$ofOne$0 = ({
  ctx: [],
  usr: c0$Set$ofOne$1,
});

const c0$Compiler$TypedAst$typeLambdaSets$4 = (($a, $acc) => {
  return (c0$Set$join$0.usr)(...(c0$Set$join$0.ctx), (c0$Compiler$TypedAst$typeLambdaSets$0.usr)(...(c0$Compiler$TypedAst$typeLambdaSets$0.ctx), $a), $acc);
});

const c0$Compiler$TypedAst$typeLambdaSets$3 = (($k, $a, $acc) => {
  return (c0$Set$join$0.usr)(...(c0$Set$join$0.ctx), (c0$Compiler$TypedAst$typeLambdaSets$0.usr)(...(c0$Compiler$TypedAst$typeLambdaSets$0.ctx), $a), $acc);
});

const c0$Compiler$TypedAst$typeLambdaSets$2 = (($in, $acc) => {
  return (c0$Set$join$0.usr)(...(c0$Set$join$0.ctx), (c0$Compiler$TypedAst$typeLambdaSets$0.usr)(...(c0$Compiler$TypedAst$typeLambdaSets$0.ctx), (c0$Compiler$TypedAst$toRaw$0.usr)(...(c0$Compiler$TypedAst$toRaw$0.ctx), $in)), $acc);
});

const c0$Compiler$TypedAst$typeLambdaSets$1 = (($0) => {
  return ((($0)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($0)[2];
      const $args = ($0)[3];
      return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Set$empty$0, $args, ({
        ctx: [],
        usr: c0$Compiler$TypedAst$typeLambdaSets$4,
      }));
    }))()
    : ((($0)[0] === "$TypeVar")
      ? c0$Set$empty$0
      : ((($0)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($0)[3];
          return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Set$empty$0, $attrs, ({
            ctx: [],
            usr: c0$Compiler$TypedAst$typeLambdaSets$3,
          }));
        }))()
        : ((($0)[0] === "$TypeError")
          ? c0$Set$empty$0
          : ((($0)[0] === "$TypeFn")
            ? ((() => {
              const $setId = ($0)[2];
              const $ins = ($0)[3];
              const $out = ($0)[4];
              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Set$join$0.usr)(...(c0$Set$join$0.ctx), (c0$Set$ofOne$0.usr)(...(c0$Set$ofOne$0.ctx), $setId), (c0$Compiler$TypedAst$typeLambdaSets$0.usr)(...(c0$Compiler$TypedAst$typeLambdaSets$0.ctx), $out.raw)), $ins, ({
                ctx: [],
                usr: c0$Compiler$TypedAst$typeLambdaSets$2,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 439:4', (sp_toHuman)($0)))))));
});

const c0$Compiler$TypedAst$typeLambdaSets$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$typeLambdaSets$1,
});

const c0$Compiler$TypedAst$typeTyvars$5 = (($a, $acc) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $a), $acc);
});

const c0$Compiler$TypedAst$typeTyvars$4 = (($k, $a, $d) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $a), $d);
});

const c0$Compiler$TypedAst$typeTyvars$3 = (($k, $a, $d) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $a), $d);
});

const c0$Compiler$TypedAst$typeTyvars$2 = (($in, $a) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), (c0$Compiler$TypedAst$toRaw$0.usr)(...(c0$Compiler$TypedAst$toRaw$0.ctx), $in)), $a);
});

const c0$Compiler$TypedAst$typeTyvars$1 = (($type) => {
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $args, ({
        ctx: [],
        usr: c0$Compiler$TypedAst$typeTyvars$5,
      }));
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[2];
        return (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $id, null);
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[2])[0] === "$Nothing"))
        ? ((() => {
          const $attrs = ($type)[3];
          return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $attrs, ({
            ctx: [],
            usr: c0$Compiler$TypedAst$typeTyvars$4,
          }));
        }))()
        : (((($type)[0] === "$TypeRecord") && ((($type)[2])[0] === "$Just"))
          ? ((() => {
            const $id = (($type)[2])[1];
            const $attrs = ($type)[3];
            return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $id, null), $attrs, ({
              ctx: [],
              usr: c0$Compiler$TypedAst$typeTyvars$3,
            }));
          }))()
          : ((($type)[0] === "$TypeFn")
            ? ((() => {
              const $ins = ($type)[3];
              const $out = ($type)[4];
              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $out.raw), $ins, ({
                ctx: [],
                usr: c0$Compiler$TypedAst$typeTyvars$2,
              }));
            }))()
            : ((($type)[0] === "$TypeError")
              ? c0$Dict$empty$0
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Compiler/TypedAst.sp 429:4', (sp_toHuman)($type))))))));
});

const c0$Compiler$TypedAst$typeTyvars$0 = ({
  ctx: [],
  usr: c0$Compiler$TypedAst$typeTyvars$1,
});

const c0$Dict$diff$2 = (($k, $v, $t) => {
  return (c0$Dict$remove$0.usr)(...(c0$Dict$remove$0.ctx), $k, $t);
});

const c0$Dict$diff$1 = (($t1, $t2) => {
  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $t1, $t2, ({
    ctx: [],
    usr: c0$Dict$diff$2,
  }));
});

const c0$Dict$diff$0 = ({
  ctx: [],
  usr: c0$Dict$diff$1,
});

const c0$Dict$each$1 = (($dict, $func) => {
  return ((($dict)[0] === "$Empty")
    ? null
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $key = ($dict)[2];
        const $value = ($dict)[3];
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        ($func.usr)(...($func.ctx), $key, $value);
        (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $left, $func);
        return (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $right, $func);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 346:4', (sp_toHuman)($dict))));
});

const c0$Dict$each$0 = ({
  ctx: [],
  usr: c0$Dict$each$1,
});

const c0$Dict$filter$2 = (($isGood, $k, $v, $d) => {
  return (($isGood.usr)(...($isGood.ctx), $k, $v)
    ? (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $k, $v, $d)
    : $d);
});

const c0$Dict$filter$1 = (($isGood, $dict) => {
  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $dict, ({
    ctx: ([
      $isGood,
    ]),
    usr: c0$Dict$filter$2,
  }));
});

const c0$Dict$filter$0 = ({
  ctx: [],
  usr: c0$Dict$filter$1,
});

const c0$Dict$fromList$2 = (($keyAndValue, $dict) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $keyAndValue.first, $keyAndValue.second, $dict);
});

const c0$Dict$fromList$1 = (($0) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $0, ({
    ctx: [],
    usr: c0$Dict$fromList$2,
  }));
});

const c0$Dict$fromList$0 = ({
  ctx: [],
  usr: c0$Dict$fromList$1,
});

const c0$Dict$member$1 = (($key, $dict) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $key, $dict);
  return ((($3)[0] === "$Just")
    ? true
    : ((($3)[0] === "$Nothing")
      ? false
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 33:4', (sp_toHuman)($3))));
});

const c0$Dict$member$0 = ({
  ctx: [],
  usr: c0$Dict$member$1,
});

const c0$Dict$intersect$2 = (($t2, $k, _1) => {
  return (c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $k, $t2);
});

const c0$Dict$intersect$1 = (($t1, $t2) => {
  return (c0$Dict$filter$0.usr)(...(c0$Dict$filter$0.ctx), ({
    ctx: ([
      $t2,
    ]),
    usr: c0$Dict$intersect$2,
  }), $t1);
});

const c0$Dict$intersect$0 = ({
  ctx: [],
  usr: c0$Dict$intersect$1,
});

const c0$Dict$keys$2 = (($key, $value, $keyList) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $key, $keyList);
});

const c0$Dict$keys$1 = (($0) => {
  return (c0$Dict$forReversed$0.usr)(...(c0$Dict$forReversed$0.ctx), c0$Core$Nil$0, $0, ({
    ctx: [],
    usr: c0$Dict$keys$2,
  }));
});

const c0$Dict$keys$0 = ({
  ctx: [],
  usr: c0$Dict$keys$1,
});

const c0$Dict$toList$2 = (($f, $0) => {
  return (c0$Dict$forReversed$0.usr)(...(c0$Dict$forReversed$0.ctx), c0$Core$Nil$0, $0, $f);
});

const c0$Dict$toList$1 = (($key, $value, $list) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: $key,
    second: $value,
  }), $list);
});

const c0$Dict$toList$0 = ((() => {
  const $f = ({
    ctx: [],
    usr: c0$Dict$toList$1,
  });
  return ({
    ctx: ([
      $f,
    ]),
    usr: c0$Dict$toList$2,
  });
}))();

const c0$Dict$merge$3 = (($leftStep, $t, $res) => {
  const $3 = $t;
  const $v = $3.second;
  const $k = $3.first;
  return ($leftStep.usr)(...($leftStep.ctx), $k, $v, $res);
});

const c0$Dict$merge$2 = (($bothStep, $leftStep, $rightStep, $rKey, $rValue, $q) => {
  const $stepState = ({
    ctx: ([
      $bothStep,
      $leftStep,
      $rightStep,
    ]),
    usr: c0$Dict$merge$2,
  });
  const $4 = $q;
  const $res = $4.second;
  const $list = $4.first;
  return ((($list)[0] === "$Nil")
    ? ({
      first: $list,
      second: ($rightStep.usr)(...($rightStep.ctx), $rKey, $rValue, $res),
    })
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $lKey = ($list)[1].first;
        const $lValue = ($list)[1].second;
        const $rest = ($list)[2];
        const $5 = (basics_compare)($lKey, $rKey);
        return ((1 === $5)
          ? ({
            first: $list,
            second: ($rightStep.usr)(...($rightStep.ctx), $rKey, $rValue, $res),
          })
          : ((0 === $5)
            ? ({
              first: $rest,
              second: ($bothStep.usr)(...($bothStep.ctx), $lKey, $lValue, $rValue, $res),
            })
            : (true
              ? ($stepState.usr)(...($stepState.ctx), $rKey, $rValue, ({
                first: $rest,
                second: ($leftStep.usr)(...($leftStep.ctx), $lKey, $lValue, $res),
              }))
              : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 278:16', (sp_toHuman)($5)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 272:8', (sp_toHuman)($list))));
});

const c0$Dict$merge$1 = (($leftStep, $bothStep, $rightStep, $leftDict, $rightDict, $initialResult) => {
  const $stepState = ({
    ctx: ([
      $bothStep,
      $leftStep,
      $rightStep,
    ]),
    usr: c0$Dict$merge$2,
  });
  const $7 = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ({
    first: (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $leftDict),
    second: $initialResult,
  }), $rightDict, $stepState);
  const $intermediateResult = $7.second;
  const $leftovers = $7.first;
  const $liftLeftStep = ({
    ctx: ([
      $leftStep,
    ]),
    usr: c0$Dict$merge$3,
  });
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $intermediateResult, $leftovers, $liftLeftStep);
});

const c0$Dict$merge$0 = ({
  ctx: [],
  usr: c0$Dict$merge$1,
});

const c0$Dict$onlyBothOnly$4 = (($key, $a, $b, $1) => {
  const $aOnly = $1.first;
  const $both = $1.second;
  const $bOnly = $1.third;
  return ({
    first: $aOnly,
    second: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $key, ({
      first: $a,
      second: $b,
    }), $both),
    third: $bOnly,
  });
});

const c0$Dict$onlyBothOnly$3 = (($key, $b, $1) => {
  const $aOnly = $1.first;
  const $both = $1.second;
  const $bOnly = $1.third;
  return ({
    first: $aOnly,
    second: $both,
    third: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $key, $b, $bOnly),
  });
});

const c0$Dict$onlyBothOnly$2 = (($key, $a, $1) => {
  const $aOnly = $1.first;
  const $both = $1.second;
  const $bOnly = $1.third;
  return ({
    first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $key, $a, $aOnly),
    second: $both,
    third: $bOnly,
  });
});

const c0$Dict$onlyBothOnly$1 = (($da, $db) => {
  const $onAOnly = ({
    ctx: [],
    usr: c0$Dict$onlyBothOnly$2,
  });
  const $onBOnly = ({
    ctx: [],
    usr: c0$Dict$onlyBothOnly$3,
  });
  const $onBoth = ({
    ctx: [],
    usr: c0$Dict$onlyBothOnly$4,
  });
  return (c0$Dict$merge$0.usr)(...(c0$Dict$merge$0.ctx), $onAOnly, $onBoth, $onBOnly, $da, $db, ({
    first: c0$Dict$empty$0,
    second: c0$Dict$empty$0,
    third: c0$Dict$empty$0,
  }));
});

const c0$Dict$onlyBothOnly$0 = ({
  ctx: [],
  usr: c0$Dict$onlyBothOnly$1,
});

const c0$Dict$size$2 = (($sizeHelp, $0) => {
  return ($sizeHelp.usr)(...($sizeHelp.ctx), 0, $0);
});

const c0$Dict$size$1 = (($n, $dict) => {
  const $sizeHelp = ({
    ctx: [],
    usr: c0$Dict$size$1,
  });
  return ((($dict)[0] === "$Empty")
    ? $n
    : ((($dict)[0] === "$Node")
      ? ((() => {
        const $left = ($dict)[4];
        const $right = ($dict)[5];
        return ($sizeHelp.usr)(...($sizeHelp.ctx), ($sizeHelp.usr)(...($sizeHelp.ctx), ($n + 1), $right), $left);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Dict.sp 41:8', (sp_toHuman)($dict))));
});

const c0$Dict$size$0 = ((() => {
  const $sizeHelp = ({
    ctx: [],
    usr: c0$Dict$size$1,
  });
  return ({
    ctx: ([
      $sizeHelp,
    ]),
    usr: c0$Dict$size$2,
  });
}))();

const c0$Dict_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const c0$Dict_Test$valueTest$0 = ({
  ctx: [],
  usr: c0$Dict_Test$valueTest$1,
});

const c0$Dict_Test$insertAndGet$2 = ((_0) => {
  return (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), 2, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), 1, c0$Dict$empty$0)));
});

const c0$Dict_Test$insertAndGet$1 = ((_0) => {
  return (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "c"), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), 2, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), 1, c0$Dict$empty$0)));
});

const c0$Dict_Test$insertAndGet$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "insertAndGet", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Dict_Test$valueTest$0.usr)(...(c0$Dict_Test$valueTest$0.ctx), "get, success", ({
  ctx: [],
  usr: c0$Dict_Test$insertAndGet$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Dict_Test$valueTest$0.usr)(...(c0$Dict_Test$valueTest$0.ctx), "get, fail", ({
  ctx: [],
  usr: c0$Dict_Test$insertAndGet$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), c0$Maybe$Nothing$0)), c0$Core$Nil$0)));

const c0$Dict_Test$lists$2 = ((_0) => {
  return (list_sortBy)(c0$Basics$identity$0, (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), c0$Maybe$Nothing$0, 2, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), 2, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), 1, c0$Dict$empty$0)))));
});

const c0$Dict_Test$lists$1 = ((_0) => {
  return (list_sortBy)(c0$Basics$identity$0, (c0$Dict$values$0.usr)(...(c0$Dict$values$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), ({
    a: 3,
  }), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), ({
    a: 1,
  }), c0$Dict$empty$0))));
});

const c0$Dict_Test$lists$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "lists", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Dict_Test$valueTest$0.usr)(...(c0$Dict_Test$valueTest$0.ctx), "keys", ({
  ctx: [],
  usr: c0$Dict_Test$lists$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Maybe$Nothing$0, c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Dict_Test$valueTest$0.usr)(...(c0$Dict_Test$valueTest$0.ctx), "values", ({
  ctx: [],
  usr: c0$Dict_Test$lists$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  a: 1,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  a: 3,
}), c0$Core$Nil$0)))), c0$Core$Nil$0)));

const c0$Dict_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Dict", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Dict_Test$insertAndGet$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Dict_Test$lists$0, c0$Core$Nil$0)));

const c0$Hash$for_$1 = (($a, $h, $f) => {
  return (hash_for)($h, $f, $a);
});

const c0$Hash$for_$0 = ({
  ctx: [],
  usr: c0$Hash$for_$1,
});

const c0$Hash$toList$2 = (($k, $v, $l) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: $k,
    second: $v,
  }), $l);
});

const c0$Hash$toList$1 = (($h) => {
  return (hash_for)($h, ({
    ctx: [],
    usr: c0$Hash$toList$2,
  }), c0$Core$Nil$0);
});

const c0$Hash$toList$0 = ({
  ctx: [],
  usr: c0$Hash$toList$1,
});

const c0$Hash_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const c0$Hash_Test$valueTest$0 = ({
  ctx: [],
  usr: c0$Hash_Test$valueTest$1,
});

const c0$List$each$1 = (($ls, $f) => {
  return ((($ls)[0] === "$Nil")
    ? null
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $tail = ($ls)[2];
        ($f.usr)(...($f.ctx), $h);
        return (c0$List$each$0.usr)(...(c0$List$each$0.ctx), $tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 372:4', (sp_toHuman)($ls))));
});

const c0$List$each$0 = ({
  ctx: [],
  usr: c0$List$each$1,
});

const c0$List$range$2 = (($low, $accum, $up) => {
  const $rec = ({
    ctx: ([
      $low,
    ]),
    usr: c0$List$range$2,
  });
  return (($up > $low)
    ? ($rec.usr)(...($rec.ctx), (sp_cons)($up, $accum), ($up - 1))
    : ((sp_equal)($up, $low)
      ? (sp_cons)($up, $accum)
      : $accum));
});

const c0$List$range$1 = (($low, $high) => {
  const $rec = ({
    ctx: ([
      $low,
    ]),
    usr: c0$List$range$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, $high);
});

const c0$List$range$0 = ({
  ctx: [],
  usr: c0$List$range$1,
});

const c0$Tuple$first$1 = (($t) => {
  return $t.first;
});

const c0$Tuple$first$0 = ({
  ctx: [],
  usr: c0$Tuple$first$1,
});

const c0$Hash_Test$tests$12 = ((_0) => {
  let $h = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: 2,
  }), c0$Core$Nil$0));
  (hash_insert)($h, 2, 3);
  return $h;
});

const c0$Hash_Test$tests$11 = ((_0) => {
  let $h = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 3,
    second: 4,
  }), c0$Core$Nil$0)));
  (hash_remove)($h, 1);
  return $h;
});

const c0$Hash_Test$tests$10 = ((_0) => {
  let $h = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 3,
    second: 4,
  }), c0$Core$Nil$0)));
  return (hash_get)($h, 1);
});

const c0$Hash_Test$tests$9 = ((_0) => {
  let $h = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 3,
    second: 4,
  }), c0$Core$Nil$0)));
  return (hash_get)($h, 66);
});

const c0$Hash_Test$tests$8 = (($k, $v, $a) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: $v,
    second: $k,
  }), $a);
});

const c0$Hash_Test$tests$7 = ((_0) => {
  let $hash = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), true),
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: c0$Maybe$Nothing$0,
    second: 4,
  }), c0$Core$Nil$0)));
  return (list_sortBy)(c0$Tuple$first$0, (hash_for)($hash, ({
    ctx: [],
    usr: c0$Hash_Test$tests$8,
  }), c0$Core$Nil$0));
});

const c0$Hash_Test$tests$6 = (($a, $k, _0) => {
  return (array_push)($a, $k);
});

const c0$Hash_Test$tests$5 = (($a, $k, $v) => {
  return (c0$List$each$0.usr)(...(c0$List$each$0.ctx), (c0$List$range$0.usr)(...(c0$List$range$0.ctx), 1, $v), ({
    ctx: ([
      $a,
      $k,
    ]),
    usr: c0$Hash_Test$tests$6,
  }));
});

const c0$Hash_Test$tests$4 = ((_0) => {
  let $a = (array_fromList)(c0$Core$Nil$0);
  let $hash = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), true),
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: c0$Maybe$Nothing$0,
    second: 1,
  }), c0$Core$Nil$0)));
  (hash_each)($hash, ({
    ctx: ([
      $a,
    ]),
    usr: c0$Hash_Test$tests$5,
  }));
  (array_sortBy)($a, c0$Basics$identity$0);
  return $a;
});

const c0$Hash_Test$tests$3 = ((_0) => {
  let $h = (hash_fromList)(c0$Core$Nil$0);
  const $r = (hash_pop)($h);
  return ({
    first: $r,
    second: $h,
  });
});

const c0$Hash_Test$tests$2 = ((_0) => {
  let $h = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ({
      b: c0$Maybe$Nothing$0,
    }),
    second: 2,
  }), c0$Core$Nil$0));
  const $r = (hash_pop)($h);
  return ({
    first: $r,
    second: $h,
  });
});

const c0$Hash_Test$tests$1 = ((_0) => {
  let $h = (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ({
      b: c0$Maybe$Nothing$0,
    }),
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ({
      b: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 4),
    }),
    second: 8,
  }), c0$Core$Nil$0)));
  const $r = (hash_pop)($h);
  return ({
    first: $r,
    second: $h,
  });
});

const c0$Hash_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Hash", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "insert", ({
  ctx: [],
  usr: c0$Hash_Test$tests$12,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 1,
  second: 2,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 2,
  second: 3,
}), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "remove", ({
  ctx: [],
  usr: c0$Hash_Test$tests$11,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 3,
  second: 4,
}), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "get Just", ({
  ctx: [],
  usr: c0$Hash_Test$tests$10,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 2))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "get Nothing", ({
  ctx: [],
  usr: c0$Hash_Test$tests$9,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), c0$Maybe$Nothing$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "for", ({
  ctx: [],
  usr: c0$Hash_Test$tests$7,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 2,
  second: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), true),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 4,
  second: c0$Maybe$Nothing$0,
}), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "each", ({
  ctx: [],
  usr: c0$Hash_Test$tests$4,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (array_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), true), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), true), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Maybe$Nothing$0, c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "pop (empty)", ({
  ctx: [],
  usr: c0$Hash_Test$tests$3,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  first: c0$Maybe$Nothing$0,
  second: (hash_fromList)(c0$Core$Nil$0),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "pop (one element)", ({
  ctx: [],
  usr: c0$Hash_Test$tests$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    first: ({
      b: c0$Maybe$Nothing$0,
    }),
    second: 2,
  })),
  second: (hash_fromList)(c0$Core$Nil$0),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Hash_Test$valueTest$0.usr)(...(c0$Hash_Test$valueTest$0.ctx), "pop (several element)", ({
  ctx: [],
  usr: c0$Hash_Test$tests$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    first: ({
      b: c0$Maybe$Nothing$0,
    }),
    second: 2,
  })),
  second: (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ({
      b: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 4),
    }),
    second: 8,
  }), c0$Core$Nil$0)),
}))), c0$Core$Nil$0))))))))));

const c0$List$concatMap$1 = (($f, $list) => {
  return (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $f, $list));
});

const c0$List$concatMap$0 = ({
  ctx: [],
  usr: c0$List$concatMap$1,
});

const c0$List$drop$1 = (($n, $ls) => {
  return ((sp_equal)($n, 0)
    ? $ls
    : ((($ls)[0] === "$Nil")
      ? c0$Core$Nil$0
      : ((($ls)[0] === "$Cons")
        ? ((() => {
          const $h = ($ls)[1];
          const $tail = ($ls)[2];
          return (c0$List$drop$0.usr)(...(c0$List$drop$0.ctx), ($n - 1), $tail);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 418:8', (sp_toHuman)($ls)))));
});

const c0$List$drop$0 = ({
  ctx: [],
  usr: c0$List$drop$1,
});

const c0$List$filter$2 = (($f, $item, $acc) => {
  return (($f.usr)(...($f.ctx), $item)
    ? (sp_cons)($item, $acc)
    : $acc);
});

const c0$List$filter$1 = (($f, $ls) => {
  return (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), c0$Core$Nil$0, $ls, ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$filter$2,
  }));
});

const c0$List$filter$0 = ({
  ctx: [],
  usr: c0$List$filter$1,
});

const c0$List$find$1 = (($test, $list) => {
  return ((($list)[0] === "$Nil")
    ? c0$Maybe$Nothing$0
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (($test.usr)(...($test.ctx), $h)
          ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $h)
          : (c0$List$find$0.usr)(...(c0$List$find$0.ctx), $test, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 24:4', (sp_toHuman)($list))));
});

const c0$List$find$0 = ({
  ctx: [],
  usr: c0$List$find$1,
});

const c0$List$forRes$1 = (($accum, $ls, $f) => {
  return ((($ls)[0] === "$Nil")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $accum)
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $h = ($ls)[1];
        const $t = ($ls)[2];
        const $4 = ($f.usr)(...($f.ctx), $h, $accum);
        return ((($4)[0] === "$Err")
          ? ((() => {
            const $x = ($4)[1];
            return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), $x);
          }))()
          : ((($4)[0] === "$Ok")
            ? ((() => {
              const $newAccum = ($4)[1];
              return (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), $newAccum, $t, $f);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 185:12', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 179:4', (sp_toHuman)($ls))));
});

const c0$List$forRes$0 = ({
  ctx: [],
  usr: c0$List$forRes$1,
});

const c0$List$head$1 = (($list) => {
  return ((($list)[0] === "$Nil")
    ? c0$Maybe$Nothing$0
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $h);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 255:4', (sp_toHuman)($list))));
});

const c0$List$head$0 = ({
  ctx: [],
  usr: c0$List$head$1,
});

const c0$List$indexBy$2 = (($getIndex, $i, $a) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), ($getIndex.usr)(...($getIndex.ctx), $i), $i, $a);
});

const c0$List$indexBy$1 = (($getIndex, $list) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $list, ({
    ctx: ([
      $getIndex,
    ]),
    usr: c0$List$indexBy$2,
  }));
});

const c0$List$indexBy$0 = ({
  ctx: [],
  usr: c0$List$indexBy$1,
});

const c0$List$indexedEach2$2 = (($rec, $0, $1, $2) => {
  return ($rec.usr)(...($rec.ctx), 0, $0, $1, $2);
});

const c0$List$indexedEach2$1 = (($index, $aa, $bb, $f) => {
  const $rec = ({
    ctx: [],
    usr: c0$List$indexedEach2$1,
  });
  const $5 = ({
    first: $aa,
    second: $bb,
  });
  return (((($5.first)[0] === "$Cons") && (($5.second)[0] === "$Cons"))
    ? ((() => {
      const $a = ($5.first)[1];
      const $at = ($5.first)[2];
      const $b = ($5.second)[1];
      const $bt = ($5.second)[2];
      ($f.usr)(...($f.ctx), $index, $a, $b);
      return ($rec.usr)(...($rec.ctx), ($index + 1), $at, $bt, $f);
    }))()
    : (true
      ? null
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 386:8', (sp_toHuman)($5))));
});

const c0$List$indexedEach2$0 = ((() => {
  const $rec = ({
    ctx: [],
    usr: c0$List$indexedEach2$1,
  });
  return ({
    ctx: ([
      $rec,
    ]),
    usr: c0$List$indexedEach2$2,
  });
}))();

const c0$List$indexedFor$2 = (($function, $item, $1) => {
  const $index = $1.first;
  const $accum = $1.second;
  return ({
    first: ($index + 1),
    second: ($function.usr)(...($function.ctx), $index, $item, $accum),
  });
});

const c0$List$indexedFor$1 = (($init, $aList, $function) => {
  return (c0$Tuple$second$0.usr)(...(c0$Tuple$second$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
    first: 0,
    second: $init,
  }), $aList, ({
    ctx: ([
      $function,
    ]),
    usr: c0$List$indexedFor$2,
  })));
});

const c0$List$indexedFor$0 = ({
  ctx: [],
  usr: c0$List$indexedFor$1,
});

const c0$List$indexedMap$2 = (($f, $accum, $n, $list) => {
  const $rec = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$indexedMap$2,
  });
  return ((($list)[0] === "$Nil")
    ? (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $accum)
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ($rec.usr)(...($rec.ctx), (sp_cons)(($f.usr)(...($f.ctx), $n, $h), $accum), ($n + 1), $t);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 208:8', (sp_toHuman)($list))));
});

const c0$List$indexedMap$1 = (($f, $aa) => {
  const $rec = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$indexedMap$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, 0, $aa);
});

const c0$List$indexedMap$0 = ({
  ctx: [],
  usr: c0$List$indexedMap$1,
});

const c0$List$intersperse$2 = (($rec, $0, $1) => {
  return ($rec.usr)(...($rec.ctx), $0, $1, c0$Core$Nil$0);
});

const c0$List$intersperse$1 = (($separator, $items, $acc) => {
  const $rec = ({
    ctx: [],
    usr: c0$List$intersperse$1,
  });
  return ((($items)[0] === "$Nil")
    ? (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $acc)
    : (((($items)[0] === "$Cons") && ((($items)[2])[0] === "$Nil"))
      ? ((() => {
        const $last_ = ($items)[1];
        return (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (sp_cons)($last_, $acc));
      }))()
      : ((($items)[0] === "$Cons")
        ? ((() => {
          const $h = ($items)[1];
          const $tail = ($items)[2];
          return ($rec.usr)(...($rec.ctx), $separator, $tail, (sp_cons)($separator, (sp_cons)($h, $acc)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 460:8', (sp_toHuman)($items)))));
});

const c0$List$intersperse$0 = ((() => {
  const $rec = ({
    ctx: [],
    usr: c0$List$intersperse$1,
  });
  return ({
    ctx: ([
      $rec,
    ]),
    usr: c0$List$intersperse$2,
  });
}))();

const c0$List$last$1 = (($list) => {
  return ((($list)[0] === "$Nil")
    ? c0$Maybe$Nothing$0
    : (((($list)[0] === "$Cons") && ((($list)[2])[0] === "$Nil"))
      ? ((() => {
        const $h = ($list)[1];
        return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $h);
      }))()
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $h = ($list)[1];
          const $t = ($list)[2];
          return (c0$List$last$0.usr)(...(c0$List$last$0.ctx), $t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 262:4', (sp_toHuman)($list)))));
});

const c0$List$last$0 = ({
  ctx: [],
  usr: c0$List$last$1,
});

const c0$List$length$2 = ((_0, $a) => {
  return ($a + 1);
});

const c0$List$length$1 = (($list) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), 0, $list, ({
    ctx: [],
    usr: c0$List$length$2,
  }));
});

const c0$List$length$0 = ({
  ctx: [],
  usr: c0$List$length$1,
});

const c0$List$map2$2 = (($f, $accum, $ax, $bx) => {
  const $rec = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$map2$2,
  });
  const $4 = ({
    first: $ax,
    second: $bx,
  });
  return (((($4.first)[0] === "$Cons") && (($4.second)[0] === "$Cons"))
    ? ((() => {
      const $ahead = ($4.first)[1];
      const $atail = ($4.first)[2];
      const $bhead = ($4.second)[1];
      const $btail = ($4.second)[2];
      return ($rec.usr)(...($rec.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($f.usr)(...($f.ctx), $ahead, $bhead), $accum), $atail, $btail);
    }))()
    : (true
      ? (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $accum)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 162:8', (sp_toHuman)($4))));
});

const c0$List$map2$1 = (($f, $aa, $bb) => {
  const $rec = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$map2$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, $aa, $bb);
});

const c0$List$map2$0 = ({
  ctx: [],
  usr: c0$List$map2$1,
});

const c0$Result$map$1 = (($f, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), $e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $a = ($result)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ($f.usr)(...($f.ctx), $a));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 8:4', (sp_toHuman)($result))));
});

const c0$Result$map$0 = ({
  ctx: [],
  usr: c0$Result$map$1,
});

const c0$List$mapRes$3 = (($acc, $b) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $b, $acc);
});

const c0$List$mapRes$2 = (($f, $a, $acc) => {
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), ({
    ctx: ([
      $acc,
    ]),
    usr: c0$List$mapRes$3,
  }), ($f.usr)(...($f.ctx), $a));
});

const c0$List$mapRes$1 = (($f, $list) => {
  const $fun = ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$mapRes$2,
  });
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), c0$List$reverse$0, (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), c0$Core$Nil$0, $list, $fun));
});

const c0$List$mapRes$0 = ({
  ctx: [],
  usr: c0$List$mapRes$1,
});

const c0$List$member$1 = (($a, $list) => {
  return ((($list)[0] === "$Nil")
    ? false
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $t = ($list)[2];
        return ((sp_equal)($a, $h)
          ? true
          : (c0$List$member$0.usr)(...(c0$List$member$0.ctx), $a, $t));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 52:4', (sp_toHuman)($list))));
});

const c0$List$member$0 = ({
  ctx: [],
  usr: c0$List$member$1,
});

const c0$List$minimum$1 = (($list) => {
  return ((($list)[0] === "$Cons")
    ? ((() => {
      const $x = ($list)[1];
      const $xs = ($list)[2];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $x, $xs, c0$Basics$min$0));
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 425:4', (sp_toHuman)($list))));
});

const c0$List$minimum$0 = ({
  ctx: [],
  usr: c0$List$minimum$1,
});

const c0$List$partition$2 = (($f, $item, $1) => {
  const $true = $1.first;
  const $false = $1.second;
  return (($f.usr)(...($f.ctx), $item)
    ? ({
      first: (sp_cons)($item, $true),
      second: $false,
    })
    : ({
      first: $true,
      second: (sp_cons)($item, $false),
    }));
});

const c0$List$partition$1 = (($f, $ls) => {
  return (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), ({
    first: c0$Core$Nil$0,
    second: c0$Core$Nil$0,
  }), $ls, ({
    ctx: ([
      $f,
    ]),
    usr: c0$List$partition$2,
  }));
});

const c0$List$partition$0 = ({
  ctx: [],
  usr: c0$List$partition$1,
});

const c0$List$partitionWhile$2 = (($f, $xs, $acc, $rest) => {
  const $rec = ({
    ctx: ([
      $f,
      $xs,
    ]),
    usr: c0$List$partitionWhile$2,
  });
  return ((($rest)[0] === "$Nil")
    ? ({
      first: $xs,
      second: c0$Core$Nil$0,
    })
    : ((($rest)[0] === "$Cons")
      ? ((() => {
        const $h = ($rest)[1];
        const $tail = ($rest)[2];
        return (($f.usr)(...($f.ctx), $h)
          ? ($rec.usr)(...($rec.ctx), (sp_cons)($h, $acc), $tail)
          : ({
            first: (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $acc),
            second: $rest,
          }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 472:8', (sp_toHuman)($rest))));
});

const c0$List$partitionWhile$1 = (($f, $xs) => {
  const $rec = ({
    ctx: ([
      $f,
      $xs,
    ]),
    usr: c0$List$partitionWhile$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, $xs);
});

const c0$List$partitionWhile$0 = ({
  ctx: [],
  usr: c0$List$partitionWhile$1,
});

const c0$List$repeat$2 = (($a, $c, $acc) => {
  const $rec = ({
    ctx: ([
      $a,
    ]),
    usr: c0$List$repeat$2,
  });
  return (($c > 0)
    ? ($rec.usr)(...($rec.ctx), ($c - 1), (sp_cons)($a, $acc))
    : $acc);
});

const c0$List$repeat$1 = (($n, $a) => {
  const $rec = ({
    ctx: ([
      $a,
    ]),
    usr: c0$List$repeat$2,
  });
  return ($rec.usr)(...($rec.ctx), $n, c0$Core$Nil$0);
});

const c0$List$repeat$0 = ({
  ctx: [],
  usr: c0$List$repeat$1,
});

const c0$List$takeReverse$1 = (($n, $list, $kept) => {
  return (($n < 1)
    ? $kept
    : ((($list)[0] === "$Nil")
      ? $kept
      : ((($list)[0] === "$Cons")
        ? ((() => {
          const $x = ($list)[1];
          const $xs = ($list)[2];
          return (c0$List$takeReverse$0.usr)(...(c0$List$takeReverse$0.ctx), ($n - 1), $xs, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $x, $kept));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 315:8', (sp_toHuman)($list)))));
});

const c0$List$takeReverse$0 = ({
  ctx: [],
  usr: c0$List$takeReverse$1,
});

const c0$List$takeTailRec$1 = (($n, $list) => {
  return (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (c0$List$takeReverse$0.usr)(...(c0$List$takeReverse$0.ctx), $n, $list, c0$Core$Nil$0));
});

const c0$List$takeTailRec$0 = ({
  ctx: [],
  usr: c0$List$takeTailRec$1,
});

const c0$List$takeFast$1 = (($ctr, $n, $list) => {
  return (($n < 1)
    ? c0$Core$Nil$0
    : ((() => {
      const $4 = ({
        first: $n,
        second: $list,
      });
      return ((($4.second)[0] === "$Nil")
        ? $list
        : (((1 === $4.first) && (($4.second)[0] === "$Cons"))
          ? ((() => {
            const $x = ($4.second)[1];
            return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $x, c0$Core$Nil$0);
          }))()
          : (((2 === $4.first) && ((($4.second)[0] === "$Cons") && ((($4.second)[2])[0] === "$Cons")))
            ? ((() => {
              const $x = ($4.second)[1];
              const $y = (($4.second)[2])[1];
              return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $x, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $y, c0$Core$Nil$0));
            }))()
            : (((3 === $4.first) && ((($4.second)[0] === "$Cons") && (((($4.second)[2])[0] === "$Cons") && (((($4.second)[2])[2])[0] === "$Cons"))))
              ? ((() => {
                const $x = ($4.second)[1];
                const $y = (($4.second)[2])[1];
                const $z = ((($4.second)[2])[2])[1];
                return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $x, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $y, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $z, c0$Core$Nil$0)));
              }))()
              : (((($4.second)[0] === "$Cons") && (((($4.second)[2])[0] === "$Cons") && ((((($4.second)[2])[2])[0] === "$Cons") && ((((($4.second)[2])[2])[2])[0] === "$Cons"))))
                ? ((() => {
                  const $x = ($4.second)[1];
                  const $y = (($4.second)[2])[1];
                  const $z = ((($4.second)[2])[2])[1];
                  const $w = (((($4.second)[2])[2])[2])[1];
                  const $tl = (((($4.second)[2])[2])[2])[2];
                  const $cons = c0$Core$Cons$0;
                  return (($ctr > 1000)
                    ? ($cons.usr)(...($cons.ctx), $x, ($cons.usr)(...($cons.ctx), $y, ($cons.usr)(...($cons.ctx), $z, ($cons.usr)(...($cons.ctx), $w, (c0$List$takeTailRec$0.usr)(...(c0$List$takeTailRec$0.ctx), ($n - 4), $tl)))))
                    : ($cons.usr)(...($cons.ctx), $x, ($cons.usr)(...($cons.ctx), $y, ($cons.usr)(...($cons.ctx), $z, ($cons.usr)(...($cons.ctx), $w, (c0$List$takeFast$0.usr)(...(c0$List$takeFast$0.ctx), ($ctr + 1), ($n - 4), $tl))))));
                }))()
                : (true
                  ? $list
                  : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 278:8', (sp_toHuman)($4))))))));
    }))());
});

const c0$List$takeFast$0 = ({
  ctx: [],
  usr: c0$List$takeFast$1,
});

const c0$List$take$1 = (($0, $1) => {
  return (c0$List$takeFast$0.usr)(...(c0$List$takeFast$0.ctx), 0, $0, $1);
});

const c0$List$take$0 = ({
  ctx: [],
  usr: c0$List$take$1,
});

const c0$List$takeWhile$2 = (($test, $accum, $list) => {
  const $rec = ({
    ctx: ([
      $test,
    ]),
    usr: c0$List$takeWhile$2,
  });
  return ((($list)[0] === "$Nil")
    ? (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $accum)
    : ((($list)[0] === "$Cons")
      ? ((() => {
        const $h = ($list)[1];
        const $tail = ($list)[2];
        return (($test.usr)(...($test.ctx), $h)
          ? ($rec.usr)(...($rec.ctx), (sp_cons)($h, $accum), $tail)
          : (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $accum));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/List.sp 324:8', (sp_toHuman)($list))));
});

const c0$List$takeWhile$1 = (($test, $its) => {
  const $rec = ({
    ctx: ([
      $test,
    ]),
    usr: c0$List$takeWhile$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, $its);
});

const c0$List$takeWhile$0 = ({
  ctx: [],
  usr: c0$List$takeWhile$1,
});

const c0$List_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const c0$List_Test$valueTest$0 = ({
  ctx: [],
  usr: c0$List_Test$valueTest$1,
});

const c0$List_Test$concat$1 = ((_0) => {
  return (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 3, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 4, c0$Core$Nil$0)), c0$Core$Nil$0)));
});

const c0$List_Test$concat$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "concat", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List_Test$valueTest$0.usr)(...(c0$List_Test$valueTest$0.ctx), "concats two lists", ({
  ctx: [],
  usr: c0$List_Test$concat$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 3, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 4, c0$Core$Nil$0)))))), c0$Core$Nil$0));

const c0$List_Test$sortBy$3 = ((_0) => {
  return (list_sortBy)(c0$Basics$identity$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 23), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Maybe$Nothing$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 11), c0$Core$Nil$0))));
});

const c0$List_Test$sortBy$2 = ((_0) => {
  return (list_sortBy)(c0$Basics$identity$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 23,
    second: 1,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: 2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 11,
    second: 3,
  }), c0$Core$Nil$0))));
});

const c0$List_Test$sortBy$1 = ((_0) => {
  return (list_sortBy)(c0$Basics$identity$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "z",
    second: "a",
    third: "2",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "a",
    second: "b",
    third: "33",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "z",
    second: "a",
    third: "1",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "z",
    second: "b",
    third: "3",
  }), c0$Core$Nil$0)))));
});

const c0$List_Test$sortBy$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "sortBy", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List_Test$valueTest$0.usr)(...(c0$List_Test$valueTest$0.ctx), "Can actually sort stuff", ({
  ctx: [],
  usr: c0$List_Test$sortBy$3,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 11), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 23), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Maybe$Nothing$0, c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List_Test$valueTest$0.usr)(...(c0$List_Test$valueTest$0.ctx), "Correctly orders tuple-2", ({
  ctx: [],
  usr: c0$List_Test$sortBy$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 1,
  second: 2,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 11,
  second: 3,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: 23,
  second: 1,
}), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List_Test$valueTest$0.usr)(...(c0$List_Test$valueTest$0.ctx), "Correctly orders tuple-3", ({
  ctx: [],
  usr: c0$List_Test$sortBy$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "a",
  second: "b",
  third: "33",
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "z",
  second: "a",
  third: "1",
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "z",
  second: "a",
  third: "2",
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "z",
  second: "b",
  third: "3",
}), c0$Core$Nil$0)))))), c0$Core$Nil$0))));

const c0$List_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "List", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$List_Test$sortBy$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$List_Test$concat$0, c0$Core$Nil$0)));

const c0$Maybe$onJust$2 = (($f, $ma) => {
  return ((($ma)[0] === "$Nothing")
    ? c0$Maybe$Nothing$0
    : ((($ma)[0] === "$Just")
      ? ((() => {
        const $a = ($ma)[1];
        return ($f.usr)(...($f.ctx), $a);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 9:4', (sp_toHuman)($ma))));
});

const c0$Maybe$onJust$1 = (($f) => {
  return ({
    ctx: ([
      $f,
    ]),
    usr: c0$Maybe$onJust$2,
  });
});

const c0$Maybe$onJust$0 = ({
  ctx: [],
  usr: c0$Maybe$onJust$1,
});

const c0$Maybe$toResult$1 = (($e, $maybeA) => {
  return ((($maybeA)[0] === "$Just")
    ? ((() => {
      const $a = ($maybeA)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : ((($maybeA)[0] === "$Nothing")
      ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), $e)
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Maybe.sp 36:4', (sp_toHuman)($maybeA))));
});

const c0$Maybe$toResult$0 = ({
  ctx: [],
  usr: c0$Maybe$toResult$1,
});

const c0$Result$fromMaybe$1 = (($err, $maybe) => {
  return ((($maybe)[0] === "$Nothing")
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), $err)
    : ((($maybe)[0] === "$Just")
      ? ((() => {
        const $a = ($maybe)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 38:4', (sp_toHuman)($maybe))));
});

const c0$Result$fromMaybe$0 = ({
  ctx: [],
  usr: c0$Result$fromMaybe$1,
});

const c0$Result$mapError$1 = (($f, $result) => {
  return ((($result)[0] === "$Ok")
    ? ((() => {
      const $a = ($result)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : ((($result)[0] === "$Err")
      ? ((() => {
        const $e1 = ($result)[1];
        return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($f.usr)(...($f.ctx), $e1));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Result.sp 31:4', (sp_toHuman)($result))));
});

const c0$Result$mapError$0 = ({
  ctx: [],
  usr: c0$Result$mapError$1,
});

const c0$Self_Test$load$1 = ((_0) => {
  const $usr = (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (c0$Compiler$Meta$UMR$0.usr)(...(c0$Compiler$Meta$UMR$0.ctx), c0$Compiler$Meta$User$0, 5, "DynamicLoad"), "aNumberValue");
  const $translatedUsr = (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, 0);
  const $numberSelf = {"def":["$OpaqueType",{"constructors":["$Empty"],"pars":["$Nil"],"usr":["$USR",["$UMR",["$Core"],0,"Core"],"Number"]}],"usr":["$USR",["$UMR",["$Core"],0,"Core"],"Number"]};
  const $numberType = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, $numberSelf.usr, c0$Core$Nil$0);
  const $def = ({
    context: c0$Dict$empty$0,
    deps: c0$Dict$empty$0,
    expr: (c0$Compiler$EmittableAst$LiteralNumber$0.usr)(...(c0$Compiler$EmittableAst$LiteralNumber$0.ctx), 42),
    freeTyvars: c0$Dict$empty$0,
    freeUnivars: c0$Dict$empty$0,
    lambdaSetConstraints: c0$Dict$empty$0,
    parameters: c0$Core$Nil$0,
    returnType: ({
      raw: $numberType,
      uni: c0$Compiler$Ast$Imm$0,
    }),
    usr: $translatedUsr,
  });
  const $pars = ({
    constructors: c0$Core$Nil$0,
    defs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $def, c0$Core$Nil$0),
    entryUsr: $translatedUsr,
    type: $numberType,
  });
  return (self_load)("$TypeExact    ($P        10        16    )    ($USR        ($UMR            $Core            0            Core        )        Number    )    []", $pars, c0$Self_Test$Integer$0);
});

const c0$Self_Test$load$0 = ({
  ctx: [],
  usr: c0$Self_Test$load$1,
});

const c0$Self_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const c0$Self_Test$valueTest$0 = ({
  ctx: [],
  usr: c0$Self_Test$valueTest$1,
});

const c0$Self_Test$base$0 = (c0$Self_Test$valueTest$0.usr)(...(c0$Self_Test$valueTest$0.ctx), "Can actually sort stuff", c0$Self_Test$load$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Self_Test$Integer$0.usr)(...(c0$Self_Test$Integer$0.ctx), 42))));

const c0$Self_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "SKIP (needs an overhaul) Self", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Self_Test$base$0, c0$Core$Nil$0));

const c0$Set$for$2 = (($f, $k, _1, $d) => {
  return ($f.usr)(...($f.ctx), $k, $d);
});

const c0$Set$for$1 = (($init, $set, $f) => {
  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $init, $set, ({
    ctx: ([
      $f,
    ]),
    usr: c0$Set$for$2,
  }));
});

const c0$Set$for$0 = ({
  ctx: [],
  usr: c0$Set$for$1,
});

const c0$Set$insert$1 = (($0, $1) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $0, null, $1);
});

const c0$Set$insert$0 = ({
  ctx: [],
  usr: c0$Set$insert$1,
});

const c0$Set$fromList$1 = (($0) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Set$empty$0, $0, c0$Set$insert$0);
});

const c0$Set$fromList$0 = ({
  ctx: [],
  usr: c0$Set$fromList$1,
});

const c0$Set$member$0 = c0$Dict$member$0;

const c0$Set$remove$0 = c0$Dict$remove$0;

const c0$Text$contains$1 = (($sub, $str) => {
  const $3 = (text_split)($sub, $str);
  return (((($3)[0] === "$Cons") && ((($3)[2])[0] === "$Nil"))
    ? false
    : (true
      ? true
      : (sp_throw)('Missing pattern in try..as', 'corelib/src/Text.sp 120:4', (sp_toHuman)($3))));
});

const c0$Text$contains$0 = ({
  ctx: [],
  usr: c0$Text$contains$1,
});

const c0$Text$repeat$1 = (($n, $s) => {
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$repeat$0.usr)(...(c0$List$repeat$0.ctx), $n, $s));
});

const c0$Text$repeat$0 = ({
  ctx: [],
  usr: c0$Text$repeat$1,
});

const c0$Text$padLeft$1 = (($minLength, $pad, $s) => {
  const $textLength = (text_length)($s);
  return (($textLength < $minLength)
    ? ((() => {
      const $times = (sp_divide)(($minLength - $textLength), (text_length)($pad));
      return ((c0$Text$repeat$0.usr)(...(c0$Text$repeat$0.ctx), $times, $pad) + $s);
    }))()
    : $s);
});

const c0$Text$padLeft$0 = ({
  ctx: [],
  usr: c0$Text$padLeft$1,
});

const c0$Text$replace$1 = (($toRemove, $toPut, $s) => {
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), $toPut, (text_split)($toRemove, $s));
});

const c0$Text$replace$0 = ({
  ctx: [],
  usr: c0$Text$replace$1,
});

const c0$Text$trimRight$1 = (($re, $0) => {
  return ($re.usr)(...($re.ctx), "", $0);
});

const c0$Text$trimRight$0 = ((() => {
  const $re = (text_replaceRegex)("[ ]*$");
  return ({
    ctx: ([
      $re,
    ]),
    usr: c0$Text$trimRight$1,
  });
}))();

const c0$Tuple$mapFirst$1 = (($f, $t) => {
  return ({
    first: ($f.usr)(...($f.ctx), $t.first),
    second: $t.second,
  });
});

const c0$Tuple$mapFirst$0 = ({
  ctx: [],
  usr: c0$Tuple$mapFirst$1,
});

const c0$Tuple$mapSecond$1 = (($f, $t) => {
  return ({
    first: $t.first,
    second: ($f.usr)(...($f.ctx), $t.second),
  });
});

const c0$Tuple$mapSecond$0 = ({
  ctx: [],
  usr: c0$Tuple$mapSecond$1,
});

const c0$Tuple$pair$1 = (($a, $b) => {
  return ({
    first: $a,
    second: $b,
  });
});

const c0$Tuple$pair$0 = ({
  ctx: [],
  usr: c0$Tuple$pair$1,
});

const i2$Test$codeTest$2 = (($code, $functionToTest, $toMaybeError, $toText, _0) => {
  return (i2$Test$maybeToOutcome$0.usr)(...(i2$Test$maybeToOutcome$0.ctx), ($toMaybeError.usr)(...($toMaybeError.ctx), $toText, ($functionToTest.usr)(...($functionToTest.ctx), $code)));
});

const i2$Test$codeTest$1 = (($toText, $title, $code, $functionToTest, $ce) => {
  const $6 = $ce;
  const $toMaybeError = ($6)[1];
  return (i2$Test$Single$0.usr)(...(i2$Test$Single$0.ctx), $title, $code, ({
    ctx: ([
      $code,
      $functionToTest,
      $toMaybeError,
      $toText,
    ]),
    usr: i2$Test$codeTest$2,
  }));
});

const i2$Test$codeTest$0 = ({
  ctx: [],
  usr: i2$Test$codeTest$1,
});

const i2$Test$errorContains$4 = (($l) => {
  return ("    " + $l);
});

const i2$Test$errorContains$3 = (($e, $sn) => {
  return (c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), (c0$Text$contains$0.usr)(...(c0$Text$contains$0.ctx), $sn, $e));
});

const i2$Test$errorContains$2 = (($snippets, $toText, $result) => {
  return ((($result)[0] === "$Ok")
    ? ((() => {
      const $ok = ($result)[1];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ("I was expecting an error, but got: Ok " + ($toText.usr)(...($toText.ctx), $ok)));
    }))()
    : ((($result)[0] === "$Err")
      ? ((() => {
        const $e = ($result)[1];
        const $missing = (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
          ctx: ([
            $e,
          ]),
          usr: i2$Test$errorContains$3,
        }), $snippets);
        return ((sp_equal)($missing, c0$Core$Nil$0)
          ? c0$Maybe$Nothing$0
          : ((() => {
            const $indentedError = (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
              ctx: [],
              usr: i2$Test$errorContains$4,
            }), (text_split)("\n", $e)));
            return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ((("Error message:\n\n" + $indentedError) + "\n\nis missing snippets: ") + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", $missing)));
          }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 96:8', (sp_toHuman)($result))));
});

const i2$Test$errorContains$1 = (($snippets) => {
  return (i2$Test$CodeExpectation$0.usr)(...(i2$Test$CodeExpectation$0.ctx), ({
    ctx: ([
      $snippets,
    ]),
    usr: i2$Test$errorContains$2,
  }));
});

const i2$Test$errorContains$0 = ({
  ctx: [],
  usr: i2$Test$errorContains$1,
});

const i2$Test$getName$1 = (($test) => {
  return ((($test)[0] === "$Single")
    ? ((() => {
      const $n = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return $n;
    }))()
    : ((($test)[0] === "$Group")
      ? ((() => {
        const $n = ($test)[1];
        const $ls = ($test)[2];
        return $n;
      }))()
      : ((($test)[0] === "$NotNow")
        ? ((() => {
          const $t = ($test)[1];
          return (i2$Test$getName$0.usr)(...(i2$Test$getName$0.ctx), $t);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 145:4', (sp_toHuman)($test)))));
});

const i2$Test$getName$0 = ({
  ctx: [],
  usr: i2$Test$getName$1,
});

const i2$Test$outcomesRec$3 = ((_0) => {
  return i2$Test$Skipped$0;
});

const i2$Test$outcomesRec$2 = (($path, $pathSegment, $0, $1) => {
  return (i2$Test$outcomesRec$0.usr)(...(i2$Test$outcomesRec$0.ctx), (($path + $pathSegment) + " / "), $0, $1);
});

const i2$Test$outcomesRec$1 = (($path, $test, $accum) => {
  return ((($test)[0] === "$Single")
    ? ((() => {
      const $name = ($test)[1];
      const $code = ($test)[2];
      const $f = ($test)[3];
      return (sp_cons)(({
        code: $code,
        getOutcome: $f,
        name: ($path + $name),
      }), $accum);
    }))()
    : ((($test)[0] === "$NotNow")
      ? ((() => {
        const $t = ($test)[1];
        const $thing = ({
          code: "",
          getOutcome: ({
            ctx: [],
            usr: i2$Test$outcomesRec$3,
          }),
          name: ($path + (i2$Test$getName$0.usr)(...(i2$Test$getName$0.ctx), $t)),
        });
        return (sp_cons)($thing, $accum);
      }))()
      : ((($test)[0] === "$Group")
        ? ((() => {
          const $pathSegment = ($test)[1];
          const $ts = ($test)[2];
          return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $accum, $ts, ({
            ctx: ([
              $path,
              $pathSegment,
            ]),
            usr: i2$Test$outcomesRec$2,
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 128:4', (sp_toHuman)($test)))));
});

const i2$Test$outcomesRec$0 = ({
  ctx: [],
  usr: i2$Test$outcomesRec$1,
});

const i2$Test$flattenAndRun$5 = (($r) => {
  const $2 = $r;
  const $name = $2.name;
  const $getOutcome = $2.getOutcome;
  const $code = $2.code;
  return ({
    code: $code,
    name: $name,
    outcome: ($getOutcome.usr)(...($getOutcome.ctx), null),
  });
});

const i2$Test$flattenAndRun$4 = (($r) => {
  return (c0$Text$contains$0.usr)(...(c0$Text$contains$0.ctx), "ONLY", $r.name);
});

const i2$Test$flattenAndRun$3 = ((_0) => {
  return i2$Test$Skipped$0;
});

const i2$Test$flattenAndRun$2 = (($r) => {
  return ((c0$Text$contains$0.usr)(...(c0$Text$contains$0.ctx), "SKIP", $r.name)
    ? ((() => {
      const $0 = $r;
      return (Object.assign)({}, $0, ({
        getOutcome: ({
          ctx: [],
          usr: i2$Test$flattenAndRun$3,
        }),
      }));
    }))()
    : $r);
});

const i2$Test$flattenAndRun$1 = (($tests) => {
  const $flattened = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: i2$Test$flattenAndRun$2,
  }), (i2$Test$outcomesRec$0.usr)(...(i2$Test$outcomesRec$0.ctx), "", (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "", $tests), c0$Core$Nil$0));
  const $onlies = (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
    ctx: [],
    usr: i2$Test$flattenAndRun$4,
  }), $flattened);
  const $runnable = ((sp_not_equal)($onlies, c0$Core$Nil$0)
    ? $onlies
    : $flattened);
  const $runTest = ({
    ctx: [],
    usr: i2$Test$flattenAndRun$5,
  });
  return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $runTest, $runnable);
});

const i2$Test$flattenAndRun$0 = ({
  ctx: [],
  usr: i2$Test$flattenAndRun$1,
});

const i2$Test$freeform$2 = (($test, $toText, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $actualOk = ($result)[1];
        return ($test.usr)(...($test.ctx), $actualOk);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 57:5', (sp_toHuman)($result))));
});

const i2$Test$freeform$1 = (($test) => {
  return (i2$Test$CodeExpectation$0.usr)(...(i2$Test$CodeExpectation$0.ctx), ({
    ctx: ([
      $test,
    ]),
    usr: i2$Test$freeform$2,
  }));
});

const i2$Test$freeform$0 = ({
  ctx: [],
  usr: i2$Test$freeform$1,
});

const i2$Test$isOk$1 = (($toText, $result) => {
  return ((($result)[0] === "$Err")
    ? ((() => {
      const $e = ($result)[1];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $e);
    }))()
    : ((($result)[0] === "$Ok")
      ? ((() => {
        const $actualOk = ($result)[1];
        return c0$Maybe$Nothing$0;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/test/Test.sp 65:8', (sp_toHuman)($result))));
});

const i2$Test$isOk$0 = (i2$Test$CodeExpectation$0.usr)(...(i2$Test$CodeExpectation$0.ctx), ({
  ctx: [],
  usr: i2$Test$isOk$1,
}));

const i3$IO$reToStderr$1 = (($io, $re) => {
  return ((($re)[0] === "$Ok")
    ? 0
    : ((($re)[0] === "$Err")
      ? ((() => {
        const $error = ($re)[1];
        (io_writeStderr)($io, ($error + "\n"));
        return 1;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'installedLibraries/posix/IO.sp 23:4', (sp_toHuman)($re))));
});

const i3$IO$reToStderr$0 = ({
  ctx: [],
  usr: i3$IO$reToStderr$1,
});

const u0$BuildMain$asModule$1 = (($tuple) => {
  const $2 = $tuple;
  const $name = $2.second;
  const $isDirectory = $2.first;
  return (($isDirectory || (sp_not_equal)(((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$").usr)(...((text_startsWithRegex)("[A-Z][a-zA-Z0-9_]*[.]sp$").ctx), $name), $name))
    ? c0$Maybe$Nothing$0
    : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Text$replace$0.usr)(...(c0$Text$replace$0.ctx), ".sp", "", $name)));
});

const u0$BuildMain$asModule$0 = ({
  ctx: [],
  usr: u0$BuildMain$asModule$1,
});

const u0$BuildMain$asModuleDirectory$1 = (($tuple) => {
  const $2 = $tuple;
  const $name = $2.second;
  const $isDirectory = $2.first;
  return (($isDirectory && (sp_equal)(((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$").usr)(...((text_startsWithRegex)("^[A-Z][a-zA-Z0-9_]*$").ctx), $name), $name))
    ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name)
    : c0$Maybe$Nothing$0);
});

const u0$BuildMain$asModuleDirectory$0 = ({
  ctx: [],
  usr: u0$BuildMain$asModuleDirectory$1,
});

const u0$BuildMain$defaultCorelibDir$0 = "corelib";

const u0$Compiler$CoreDefs$pathId$0 = 0;

const u0$Compiler$CoreDefs$makeUmr$1 = (($0) => {
  return (c0$Compiler$Meta$UMR$0.usr)(...(c0$Compiler$Meta$UMR$0.ctx), c0$Compiler$Meta$Core$0, u0$Compiler$CoreDefs$pathId$0, $0);
});

const u0$Compiler$CoreDefs$makeUmr$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$makeUmr$1,
});

const u0$Compiler$CoreDefs$umr$0 = (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Core");

const u0$BuildMain$getEntryUsr$2 = (($importsPath) => {
  return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Entry point can't be in an installed library!", c0$Core$Nil$0)));
});

const u0$BuildMain$getEntryUsr$1 = (($projectImports, $entryModule) => {
  return (c0$Compiler$Meta$resolve$0.usr)(...(c0$Compiler$Meta$resolve$0.ctx), ({
    currentImports: $projectImports,
    currentModule: u0$Compiler$CoreDefs$umr$0,
    loadExports: ({
      ctx: [],
      usr: u0$BuildMain$getEntryUsr$2,
    }),
    makeError: u0$Compiler$Error$Raw$0,
  }), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $entryModule), "main");
});

const u0$BuildMain$getEntryUsr$0 = ({
  ctx: [],
  usr: u0$BuildMain$getEntryUsr$1,
});

const u0$BuildMain$idToDirs$1 = (($state, $id) => {
  const $3 = (hash_get)($state.idToSourcePath, $id);
  return ((($3)[0] === "$Nothing")
    ? (sp_todo)("compiler error: no idToSourcePath")
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $sourcePath = ($3)[1];
        return $sourcePath;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 270:4', (sp_toHuman)($3))));
});

const u0$BuildMain$idToDirs$0 = ({
  ctx: [],
  usr: u0$BuildMain$idToDirs$1,
});

const u0$BuildMain$importsFileName$0 = "imports.sp";

const u0$BuildMain$installedDir$0 = "installedLibraries";

const u0$BuildMain$ioToRes$2 = (($err) => {
  return (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $err, c0$Core$Nil$0));
});

const u0$BuildMain$ioToRes$1 = (($0) => {
  return (c0$Result$mapError$0.usr)(...(c0$Result$mapError$0.ctx), ({
    ctx: [],
    usr: u0$BuildMain$ioToRes$2,
  }), $0);
});

const u0$BuildMain$ioToRes$0 = ({
  ctx: [],
  usr: u0$BuildMain$ioToRes$1,
});

const u0$Compiler$CoreDefs$defToType$1 = (($def, $pars) => {
  return (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), c0$Compiler$Pos$N$0, $def.usr, $pars);
});

const u0$Compiler$CoreDefs$defToType$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$defToType$1,
});

const u0$Compiler$CoreDefs$usr$1 = (($0) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), u0$Compiler$CoreDefs$umr$0, $0);
});

const u0$Compiler$CoreDefs$usr$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$usr$1,
});

const u0$Compiler$CoreDefs$numberUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Number");

const u0$Compiler$CoreDefs$numberDef$0 = ({
  constructors: c0$Dict$empty$0,
  pars: c0$Core$Nil$0,
  usr: u0$Compiler$CoreDefs$numberUsr$0,
});

const u0$Compiler$CoreDefs$number$0 = (u0$Compiler$CoreDefs$defToType$0.usr)(...(u0$Compiler$CoreDefs$defToType$0.ctx), u0$Compiler$CoreDefs$numberDef$0, c0$Core$Nil$0);

const u0$Compiler$CoreDefs$typeBinopUnique$1 = (($ty) => {
  return (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$N$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $ty)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $ty)), c0$Core$Nil$0)), (c0$Compiler$Ast$toUni$0.usr)(...(c0$Compiler$Ast$toUni$0.ctx), $ty));
});

const u0$Compiler$CoreDefs$typeBinopUnique$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$typeBinopUnique$1,
});

const u0$Compiler$CoreDefs$add$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_addittive$0,
  symbol: "+",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$number$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "add"),
});

const u0$Compiler$CoreDefs$boolName$0 = "Bool";

const u0$Compiler$CoreDefs$nameToType$1 = (($name, $args) => {
  return (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), c0$Compiler$Pos$N$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), $name), $args);
});

const u0$Compiler$CoreDefs$nameToType$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$nameToType$1,
});

const u0$Compiler$CoreDefs$boolType$0 = (u0$Compiler$CoreDefs$nameToType$0.usr)(...(u0$Compiler$CoreDefs$nameToType$0.ctx), u0$Compiler$CoreDefs$boolName$0, c0$Core$Nil$0);

const u0$Compiler$CoreDefs$and_$0 = ({
  associativity: c0$Compiler$Op$Right$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_logical$0,
  symbol: "and",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "and_"),
});

const u0$Compiler$CoreDefs$divide$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_multiplicative$0,
  symbol: "/",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$number$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "divide"),
});

const u0$Compiler$CoreDefs$tyVar$1 = (($0) => {
  return (c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.usr)(...(c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.ctx), c0$Compiler$Pos$N$0, $0);
});

const u0$Compiler$CoreDefs$tyVar$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$tyVar$1,
});

const u0$Compiler$CoreDefs$tyFn$2 = (($p) => {
  return (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $p));
});

const u0$Compiler$CoreDefs$tyFn$1 = (($pars, $to) => {
  return (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$N$0, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$CoreDefs$tyFn$2,
  }), $pars), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $to));
});

const u0$Compiler$CoreDefs$tyFn$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$tyFn$1,
});

const u0$Compiler$CoreDefs$typeBinop$1 = (($left, $right, $return) => {
  return (u0$Compiler$CoreDefs$tyFn$0.usr)(...(u0$Compiler$CoreDefs$tyFn$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $left, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $right, c0$Core$Nil$0)), $return);
});

const u0$Compiler$CoreDefs$typeBinop$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$typeBinop$1,
});

const u0$Compiler$CoreDefs$equal$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0),
  precedence: c0$Compiler$Op$precedence_comparison$0,
  symbol: "==",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "equal"),
});

const u0$Compiler$CoreDefs$greaterOrEqualThan$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0),
  precedence: c0$Compiler$Op$precedence_comparison$0,
  symbol: ">=",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "greaterOrEqualThan"),
});

const u0$Compiler$CoreDefs$greaterThan$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0),
  precedence: c0$Compiler$Op$precedence_comparison$0,
  symbol: ">",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "greaterThan"),
});

const u0$Compiler$CoreDefs$lesserOrEqualThan$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0),
  precedence: c0$Compiler$Op$precedence_comparison$0,
  symbol: "<=",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "lesserOrEqualThan"),
});

const u0$Compiler$CoreDefs$lesserThan$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0),
  precedence: c0$Compiler$Op$precedence_comparison$0,
  symbol: "<",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "lesserThan"),
});

const u0$Compiler$CoreDefs$listName$0 = "List";

const u0$Compiler$CoreDefs$listType$1 = (($item) => {
  return (u0$Compiler$CoreDefs$nameToType$0.usr)(...(u0$Compiler$CoreDefs$nameToType$0.ctx), u0$Compiler$CoreDefs$listName$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $item, c0$Core$Nil$0));
});

const u0$Compiler$CoreDefs$listType$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$listType$1,
});

const u0$Compiler$CoreDefs$listCons$0 = ((() => {
  const $item = (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "item");
  return ({
    associativity: c0$Compiler$Op$Right$0,
    nonFn: c0$Core$Nil$0,
    precedence: c0$Compiler$Op$precedence_cons$0,
    symbol: "::",
    type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), $item, (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), $item), (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), $item)),
    usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "stack"),
  });
}))();

const u0$Compiler$CoreDefs$multiply$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_multiplicative$0,
  symbol: "*",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$number$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "multiply"),
});

const u0$Compiler$CoreDefs$noneTypeName$0 = "None";

const u0$Compiler$CoreDefs$noneType$0 = (u0$Compiler$CoreDefs$nameToType$0.usr)(...(u0$Compiler$CoreDefs$nameToType$0.ctx), u0$Compiler$CoreDefs$noneTypeName$0, c0$Core$Nil$0);

const u0$Compiler$CoreDefs$mutableAdd$0 = ({
  associativity: c0$Compiler$Op$NonAssociative$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_mutop$0,
  symbol: "+=",
  type: (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$N$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParRe$0.usr)(...(c0$Compiler$CanonicalAst$ParRe$0.ctx), u0$Compiler$CoreDefs$number$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), ({
    raw: u0$Compiler$CoreDefs$number$0,
    uni: c0$Compiler$Ast$Imm$0,
  })), c0$Core$Nil$0)), ({
    raw: u0$Compiler$CoreDefs$noneType$0,
    uni: c0$Compiler$Ast$Imm$0,
  })),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "mutableAdd"),
});

const u0$Compiler$CoreDefs$mutableAssign$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_mutop$0,
  symbol: ":=",
  type: (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$N$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParRe$0.usr)(...(c0$Compiler$CanonicalAst$ParRe$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), ({
    raw: (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"),
    uni: c0$Compiler$Ast$Uni$0,
  })), c0$Core$Nil$0)), ({
    raw: u0$Compiler$CoreDefs$noneType$0,
    uni: c0$Compiler$Ast$Imm$0,
  })),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "mutableAssign"),
});

const u0$Compiler$CoreDefs$mutableSubtract$0 = ({
  associativity: c0$Compiler$Op$NonAssociative$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_mutop$0,
  symbol: "-=",
  type: (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$N$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParRe$0.usr)(...(c0$Compiler$CanonicalAst$ParRe$0.ctx), u0$Compiler$CoreDefs$number$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), ({
    raw: u0$Compiler$CoreDefs$number$0,
    uni: c0$Compiler$Ast$Imm$0,
  })), c0$Core$Nil$0)), ({
    raw: u0$Compiler$CoreDefs$noneType$0,
    uni: c0$Compiler$Ast$Imm$0,
  })),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "mutableSubtract"),
});

const u0$Compiler$CoreDefs$notEqual$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0),
  precedence: c0$Compiler$Op$precedence_comparison$0,
  symbol: "/=",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "notEqual"),
});

const u0$Compiler$CoreDefs$or_$0 = ({
  associativity: c0$Compiler$Op$Right$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_logical$0,
  symbol: "or",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$boolType$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "or_"),
});

const u0$Compiler$CoreDefs$sendLeft$0 = ({
  associativity: c0$Compiler$Op$Right$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_pipe$0,
  symbol: "<<",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyFn$0.usr)(...(u0$Compiler$CoreDefs$tyFn$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), c0$Core$Nil$0), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "b")), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "b")),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "sendLeft"),
});

const u0$Compiler$CoreDefs$sendRight$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_pipe$0,
  symbol: ">>",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyFn$0.usr)(...(u0$Compiler$CoreDefs$tyFn$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), c0$Core$Nil$0), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "b")), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "b")),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "sendRight"),
});

const u0$Compiler$CoreDefs$subtract$0 = ({
  associativity: c0$Compiler$Op$Left$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_addittive$0,
  symbol: "-",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$number$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "subtract"),
});

const u0$Compiler$CoreDefs$textUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Text");

const u0$Compiler$CoreDefs$textDef$0 = ({
  constructors: c0$Dict$empty$0,
  pars: c0$Core$Nil$0,
  usr: u0$Compiler$CoreDefs$textUsr$0,
});

const u0$Compiler$CoreDefs$text$0 = (u0$Compiler$CoreDefs$defToType$0.usr)(...(u0$Compiler$CoreDefs$defToType$0.ctx), u0$Compiler$CoreDefs$textDef$0, c0$Core$Nil$0);

const u0$Compiler$CoreDefs$textConcat$0 = ({
  associativity: c0$Compiler$Op$Right$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_addittive$0,
  symbol: "..",
  type: (u0$Compiler$CoreDefs$typeBinopUnique$0.usr)(...(u0$Compiler$CoreDefs$typeBinopUnique$0.ctx), u0$Compiler$CoreDefs$text$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "concat"),
});

const u0$Compiler$CoreDefs$tuple$0 = ({
  associativity: c0$Compiler$Op$NonAssociative$0,
  nonFn: c0$Core$Nil$0,
  precedence: c0$Compiler$Op$precedence_tuple$0,
  symbol: "&",
  type: (u0$Compiler$CoreDefs$typeBinop$0.usr)(...(u0$Compiler$CoreDefs$typeBinop$0.ctx), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "b"), (c0$Compiler$CanonicalAst$TypeRecord$0.usr)(...(c0$Compiler$CanonicalAst$TypeRecord$0.ctx), c0$Compiler$Pos$N$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "second", (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "b"), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "first", (u0$Compiler$CoreDefs$tyVar$0.usr)(...(u0$Compiler$CoreDefs$tyVar$0.ctx), "a"), c0$Dict$empty$0)))),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "<& is just sugar>"),
});

const u0$Compiler$CoreDefs$binops$0 = (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$and_$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$or_$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$textConcat$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$listCons$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$tuple$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$add$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$subtract$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$multiply$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$divide$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$mutableAssign$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$mutableAdd$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$mutableSubtract$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$equal$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$notEqual$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$lesserThan$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$greaterThan$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$lesserOrEqualThan$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$greaterOrEqualThan$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$sendRight$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$sendLeft$0, c0$Core$Nil$0))))))))))))))))))));

const u0$Compiler$CoreDefs$boolUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Bool");

const u0$Compiler$CoreDefs$falseName$0 = "'false";

const u0$Compiler$CoreDefs$falseUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), u0$Compiler$CoreDefs$falseName$0);

const u0$Compiler$CoreDefs$falseDef$0 = ({
  constructorUsr: u0$Compiler$CoreDefs$falseUsr$0,
  directDeps: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), u0$Compiler$CoreDefs$boolUsr$0, c0$Compiler$Meta$TypeDependency$0),
  ins: c0$Core$Nil$0,
  name: u0$Compiler$CoreDefs$falseName$0,
  out: u0$Compiler$CoreDefs$boolType$0,
  pos: c0$Compiler$Pos$N$0,
  variantTypeUsr: u0$Compiler$CoreDefs$boolUsr$0,
});

const u0$Compiler$CoreDefs$trueName$0 = "'true";

const u0$Compiler$CoreDefs$trueUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), u0$Compiler$CoreDefs$trueName$0);

const u0$Compiler$CoreDefs$trueDef$0 = ({
  constructorUsr: u0$Compiler$CoreDefs$trueUsr$0,
  directDeps: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), u0$Compiler$CoreDefs$boolUsr$0, c0$Compiler$Meta$TypeDependency$0),
  ins: c0$Core$Nil$0,
  name: u0$Compiler$CoreDefs$trueName$0,
  out: u0$Compiler$CoreDefs$boolType$0,
  pos: c0$Compiler$Pos$N$0,
  variantTypeUsr: u0$Compiler$CoreDefs$boolUsr$0,
});

const u0$Compiler$CoreDefs$boolDef$0 = ({
  constructors: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), u0$Compiler$CoreDefs$falseName$0, u0$Compiler$CoreDefs$falseDef$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), u0$Compiler$CoreDefs$trueName$0, u0$Compiler$CoreDefs$trueDef$0, c0$Dict$empty$0)),
  pars: c0$Core$Nil$0,
  usr: u0$Compiler$CoreDefs$boolUsr$0,
});

const u0$Compiler$CoreDefs$consName$0 = "'cons";

const u0$Compiler$CoreDefs$consUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), u0$Compiler$CoreDefs$consName$0);

const u0$Compiler$CoreDefs$listItem$0 = (c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.usr)(...(c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.ctx), c0$Compiler$Pos$N$0, "item");

const u0$Compiler$CoreDefs$listUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "List");

const u0$Compiler$CoreDefs$consDef$0 = ({
  constructorUsr: u0$Compiler$CoreDefs$consUsr$0,
  directDeps: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), u0$Compiler$CoreDefs$listUsr$0, c0$Compiler$Meta$TypeDependency$0),
  ins: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$listItem$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), u0$Compiler$CoreDefs$listItem$0), c0$Core$Nil$0)),
  name: u0$Compiler$CoreDefs$consName$0,
  out: (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), u0$Compiler$CoreDefs$listItem$0),
  pos: c0$Compiler$Pos$N$0,
  variantTypeUsr: u0$Compiler$CoreDefs$listUsr$0,
});

const u0$Compiler$MakeCanonical$typeDeps$3 = (($k, $v, $a) => {
  return (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $v, $a);
});

const u0$Compiler$MakeCanonical$typeDeps$2 = (($par, $z) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $raw, $z);
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $full.raw, $z);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 90:16', (sp_toHuman)($par))));
});

const u0$Compiler$MakeCanonical$typeDeps$1 = (($type, $acc) => {
  return ((($type)[0] === "$TypeNamed")
    ? ((() => {
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, c0$Compiler$Meta$TypeDependency$0, $acc), $args, u0$Compiler$MakeCanonical$typeDeps$0);
    }))()
    : ((($type)[0] === "$TypeAnnotationVariable")
      ? $acc
      : ((($type)[0] === "$TypeRecord")
        ? ((() => {
          const $attrs = ($type)[2];
          return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $acc, $attrs, ({
            ctx: [],
            usr: u0$Compiler$MakeCanonical$typeDeps$3,
          }));
        }))()
        : ((($type)[0] === "$TypeError")
          ? $acc
          : ((($type)[0] === "$TypeFn")
            ? ((() => {
              const $params = ($type)[2];
              const $to = ($type)[3];
              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $to.raw, $acc), $params, ({
                ctx: [],
                usr: u0$Compiler$MakeCanonical$typeDeps$2,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 72:4', (sp_toHuman)($type)))))));
});

const u0$Compiler$MakeCanonical$typeDeps$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$typeDeps$1,
});

const u0$Compiler$CoreDefs$insert$2 = (($nonFn, $n, $pos) => {
  return ({
    nonFn: ((c0$Set$member$0.usr)(...(c0$Set$member$0.ctx), $n, $nonFn)
      ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Pos$N$0)
      : c0$Maybe$Nothing$0),
  });
});

const u0$Compiler$CoreDefs$insert$1 = (($4, $raw, $nonFnAsList, $dict) => {
  const $name = ($4)[2];
  const $nonFn = (c0$Set$fromList$0.usr)(...(c0$Set$fromList$0.ctx), $nonFnAsList);
  const $tyvars = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: ([
      $nonFn,
    ]),
    usr: u0$Compiler$CoreDefs$insert$2,
  }), (c0$Compiler$CanonicalAst$typeTyvars$0.usr)(...(c0$Compiler$CanonicalAst$typeTyvars$0.ctx), $raw));
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, ({
    directDeps: (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $raw, c0$Dict$empty$0),
    maybeAnnotation: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
      raw: $raw,
      tyvars: $tyvars,
      univars: c0$Dict$empty$0,
    })),
    maybeBody: c0$Maybe$Nothing$0,
    name: $name,
    namePos: c0$Compiler$Pos$N$0,
  }), $dict);
});

const u0$Compiler$CoreDefs$insert$0 = ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$insert$1,
});

const u0$Compiler$CoreDefs$nilName$0 = "'nil";

const u0$Compiler$CoreDefs$nilUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), u0$Compiler$CoreDefs$nilName$0);

const u0$Compiler$CoreDefs$nilDef$0 = ({
  constructorUsr: u0$Compiler$CoreDefs$nilUsr$0,
  directDeps: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), u0$Compiler$CoreDefs$listUsr$0, c0$Compiler$Meta$TypeDependency$0),
  ins: c0$Core$Nil$0,
  name: u0$Compiler$CoreDefs$nilName$0,
  out: (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), u0$Compiler$CoreDefs$listItem$0),
  pos: c0$Compiler$Pos$N$0,
  variantTypeUsr: u0$Compiler$CoreDefs$listUsr$0,
});

const u0$Compiler$CoreDefs$listDef$0 = ({
  constructors: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), u0$Compiler$CoreDefs$consName$0, u0$Compiler$CoreDefs$consDef$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), u0$Compiler$CoreDefs$nilName$0, u0$Compiler$CoreDefs$nilDef$0, c0$Dict$empty$0)),
  pars: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "item",
    second: c0$Compiler$Pos$N$0,
  }), c0$Core$Nil$0),
  usr: u0$Compiler$CoreDefs$listUsr$0,
});

const u0$Compiler$CoreDefs$noneConsName$0 = "'none";

const u0$Compiler$CoreDefs$noneConsUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), u0$Compiler$CoreDefs$noneConsName$0);

const u0$Compiler$CoreDefs$noneTypeUsr$0 = (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), u0$Compiler$CoreDefs$noneTypeName$0);

const u0$Compiler$CoreDefs$noneConsDef$0 = ({
  constructorUsr: u0$Compiler$CoreDefs$noneConsUsr$0,
  directDeps: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), u0$Compiler$CoreDefs$noneTypeUsr$0, c0$Compiler$Meta$TypeDependency$0),
  ins: c0$Core$Nil$0,
  name: u0$Compiler$CoreDefs$noneConsName$0,
  out: u0$Compiler$CoreDefs$noneType$0,
  pos: c0$Compiler$Pos$N$0,
  variantTypeUsr: u0$Compiler$CoreDefs$noneTypeUsr$0,
});

const u0$Compiler$CoreDefs$noneTypeDef$0 = ({
  constructors: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), u0$Compiler$CoreDefs$noneConsName$0, u0$Compiler$CoreDefs$noneConsDef$0),
  pars: c0$Core$Nil$0,
  usr: u0$Compiler$CoreDefs$noneTypeUsr$0,
});

const u0$Compiler$CoreDefs$unaryMinus$0 = ({
  symbol: "0 -",
  type: (u0$Compiler$CoreDefs$tyFn$0.usr)(...(u0$Compiler$CoreDefs$tyFn$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$number$0, c0$Core$Nil$0), u0$Compiler$CoreDefs$number$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "unaryMinus"),
});

const u0$Compiler$CoreDefs$unaryPlus$0 = ({
  symbol: "0 +",
  type: (u0$Compiler$CoreDefs$tyFn$0.usr)(...(u0$Compiler$CoreDefs$tyFn$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$number$0, c0$Core$Nil$0), u0$Compiler$CoreDefs$number$0),
  usr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "unaryPlus"),
});

const u0$Compiler$CoreDefs$coreModule$4 = (($unop, $dict) => {
  return (u0$Compiler$CoreDefs$insert$0.usr)(...(u0$Compiler$CoreDefs$insert$0.ctx), $unop.usr, $unop.type, c0$Core$Nil$0, $dict);
});

const u0$Compiler$CoreDefs$coreModule$3 = (($binop, $dict) => {
  return (u0$Compiler$CoreDefs$insert$0.usr)(...(u0$Compiler$CoreDefs$insert$0.ctx), $binop.usr, $binop.type, $binop.nonFn, $dict);
});

const u0$Compiler$CoreDefs$coreModule$2 = (($def, $dict) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $def.name, $def, $dict);
});

const u0$Compiler$CoreDefs$coreModule$1 = (($def, $dict) => {
  const $3 = $def.usr;
  const $name = ($3)[2];
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $def, $dict);
});

const u0$Compiler$CoreDefs$coreModule$0 = ((() => {
  const $variantTypeDefs = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$textDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$numberDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$noneTypeDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$boolDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$listDef$0, c0$Core$Nil$0))))), ({
    ctx: [],
    usr: u0$Compiler$CoreDefs$coreModule$1,
  }));
  const $constructorDefs = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$noneConsDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$trueDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$falseDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$nilDef$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$consDef$0, c0$Core$Nil$0))))), ({
    ctx: [],
    usr: u0$Compiler$CoreDefs$coreModule$2,
  }));
  const $valueDefs = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$unaryPlus$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$CoreDefs$unaryMinus$0, c0$Core$Nil$0)), ({
    ctx: [],
    usr: u0$Compiler$CoreDefs$coreModule$4,
  })), u0$Compiler$CoreDefs$binops$0, ({
    ctx: [],
    usr: u0$Compiler$CoreDefs$coreModule$3,
  }));
  return ({
    aliasDefs: c0$Dict$empty$0,
    asText: "<core module>",
    constructorDefs: $constructorDefs,
    fsPath: "<core module>",
    umr: u0$Compiler$CoreDefs$umr$0,
    umrToAlias: c0$Dict$empty$0,
    usrToGlobal: c0$Dict$empty$0,
    valueDefs: $valueDefs,
    variantTypeDefs: $variantTypeDefs,
  });
}))();

const u0$Compiler$MakeCanonical$initEnv$1 = (($ro) => {
  return ({
    maybeShorthandTarget: c0$Maybe$Nothing$0,
    nextGeneratedVariableName: 0,
    nonFn: c0$Dict$empty$0,
    ro: $ro,
    values: c0$Dict$empty$0,
  });
});

const u0$Compiler$MakeCanonical$initEnv$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$initEnv$1,
});

const u0$Compiler$Error$res$1 = (($mod, $pos, $desc) => {
  return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), $mod, $pos, $desc));
});

const u0$Compiler$Error$res$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$res$1,
});

const u0$Compiler$MakeCanonical$error$1 = (($env, $pos, $msg) => {
  return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $env.ro.errorModule, $pos, $msg);
});

const u0$Compiler$MakeCanonical$error$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$error$1,
});

const u0$Compiler$MakeCanonical$insertPatternNames$3 = (($env, $isRoot, $paName, $vs) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $paName.name, $vs);
  return ((($3)[0] === "$Just")
    ? ((() => {
      const $duplicateName = ($3)[1];
      return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $paName.pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("A variable named `" + $paName.name) + "` has already been defined."), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "You need to find a less ambiguous name.", c0$Core$Nil$0)));
    }))()
    : ((($3)[0] === "$Nothing")
      ? ((() => {
        const $shadowsAGlobal = ((() => {
          const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $paName.name, $env.ro.imports.globalNameToLocation);
          return ((($4)[0] === "$Nothing")
            ? false
            : ((($4)[0] === "$Just")
              ? ((() => {
                const $location = ($4)[1];
                return ((c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), $isRoot)
                  ? true
                  : ((() => {
                    const $5 = ($env.ro.resolveToUsr.usr)(...($env.ro.resolveToUsr.ctx), c0$Compiler$Pos$G$0, c0$Maybe$Nothing$0, $paName.name);
                    return ((($5)[0] === "$Err")
                      ? true
                      : (((($5)[0] === "$Ok") && ((($5)[1])[0] === "$USR"))
                        ? ((() => {
                          const $umr = (($5)[1])[1];
                          const $name = (($5)[1])[2];
                          return (sp_not_equal)($umr, $env.ro.umr);
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 889:32', (sp_toHuman)($5))));
                  }))());
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 875:20', (sp_toHuman)($4))));
        }))();
        return ((c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), $shadowsAGlobal)
          ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $paName.name, ({
            isRoot: $isRoot,
            pos: $paName.pos,
          }), $vs))
          : (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $paName.pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("There is already a global variable named `" + $paName.name) + "`."), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "You need to find a different name, or modify imports.sp", c0$Core$Nil$0))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 861:8', (sp_toHuman)($3))));
});

const u0$Compiler$MakeCanonical$insertPatternNames$2 = (($env, $values) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      values: $values,
    }));
  }))());
});

const u0$Compiler$MakeCanonical$insertPatternNames$1 = (($isRoot, $pattern, $env) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$insertPatternNames$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$insertPatternNames$2,
  })).ctx), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), $env.values, (c0$Compiler$CanonicalAst$patternNames$0.usr)(...(c0$Compiler$CanonicalAst$patternNames$0.ctx), $pattern), ({
    ctx: ([
      $env,
      $isRoot,
    ]),
    usr: u0$Compiler$MakeCanonical$insertPatternNames$3,
  })));
});

const u0$Compiler$MakeCanonical$insertPatternNames$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$insertPatternNames$1,
});

const u0$Compiler$MakeCanonical$erroro$1 = (($ro, $pos, $msg) => {
  return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $ro.errorModule, $pos, $msg);
});

const u0$Compiler$MakeCanonical$erroro$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$erroro$1,
});

const u0$Compiler$MakeCanonical$translateAttributeName$1 = (($ro, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Lowercase")
    ? ((() => {
      const $attrPath = ($expr_)[1].attrPath;
      const $maybeModule = ($expr_)[1].maybeModule;
      const $maybeType = ($expr_)[1].maybeType;
      const $name = ($expr_)[1].name;
      return ((sp_not_equal)($maybeModule, c0$Maybe$Nothing$0)
        ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Attribute names must be single words", c0$Core$Nil$0))
        : ((sp_not_equal)($attrPath, c0$Core$Nil$0)
          ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Attribute names can't contain dots", c0$Core$Nil$0))
          : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
            first: $pos,
            second: $name,
            third: $maybeType,
          }))));
    }))()
    : (true
      ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need a lowercase attribute name here", c0$Core$Nil$0))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 287:4', (sp_toHuman)($expr_))));
});

const u0$Compiler$MakeCanonical$translateAttributeName$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateAttributeName$1,
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$3 = (($caAttrs, $faAttr, $name, $pos, $ro, $caType) => {
  return ((sp_not_equal)($faAttr.maybeExpr, c0$Maybe$Nothing$0)
    ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need a type here; `=` is for assignign values", c0$Core$Nil$0))
    : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $caType, $caAttrs)));
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$2 = (($caAttrs, $faAttr, $ro, $1) => {
  const $pos = $1.first;
  const $name = $1.second;
  const $maybeFaType = $1.third;
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $caAttrs)
    ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("Duplicate attribute name: " + $name), c0$Core$Nil$0))
    : ((($maybeFaType)[0] === "$Nothing")
      ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("I need to see the type of this attribute, `" + $name) + " as TheType`"), c0$Core$Nil$0))
      : ((($maybeFaType)[0] === "$Just")
        ? ((() => {
          const $faType = ($maybeFaType)[1];
          return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
            ctx: ([
              $caAttrs,
              $faAttr,
              $name,
              $pos,
              $ro,
            ]),
            usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$3,
          })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
            ctx: ([
              $caAttrs,
              $faAttr,
              $name,
              $pos,
              $ro,
            ]),
            usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$3,
          })).ctx), (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $ro, $faType));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1334:8', (sp_toHuman)($maybeFaType)))));
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$1 = (($ro, $faAttr, $caAttrs) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caAttrs,
      $faAttr,
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caAttrs,
      $faAttr,
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$2,
  })).ctx), (u0$Compiler$MakeCanonical$translateAttributeName$0.usr)(...(u0$Compiler$MakeCanonical$translateAttributeName$0.ctx), $ro, $faAttr.name));
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$1,
});

const u0$Compiler$MakeCanonical$translatePoly$1 = (($ro, $expr) => {
  const $3 = $expr;
  const $expr_ = ($3)[3];
  const $pos = ($3)[2];
  return (((($expr_)[0] === "$UnopCall") && ((($expr_)[1])[0] === "$UnopUnique"))
    ? ((() => {
      const $e = ($expr_)[2];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
        first: c0$Compiler$Ast$Uni$0,
        second: $e,
      }));
    }))()
    : ((($expr_)[0] === "$Poly")
      ? ((() => {
        const $numberAsString = ($expr_)[1];
        const $e = ($expr_)[2];
        const $4 = (text_toNumber)($numberAsString);
        return ((($4)[0] === "$Nothing")
          ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need an integer number here", c0$Core$Nil$0))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $n = ($4)[1];
              return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
                first: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), $n),
                second: $e,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1380:12', (sp_toHuman)($4))));
      }))()
      : (true
        ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
          first: c0$Compiler$Ast$Imm$0,
          second: $expr,
        }))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1374:4', (sp_toHuman)($expr_)))));
});

const u0$Compiler$MakeCanonical$translatePoly$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translatePoly$1,
});

const u0$Compiler$MakeCanonical$translateFullType$3 = (($uni, $raw) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    raw: $raw,
    uni: $uni,
  }));
});

const u0$Compiler$MakeCanonical$translateFullType$2 = (($ro, $1) => {
  const $uni = $1.first;
  const $e = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullType$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullType$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $ro, $e));
});

const u0$Compiler$MakeCanonical$translateFullType$1 = (($ro, $expr) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullType$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullType$2,
  })).ctx), (u0$Compiler$MakeCanonical$translatePoly$0.usr)(...(u0$Compiler$MakeCanonical$translatePoly$0.ctx), $ro, $expr));
});

const u0$Compiler$MakeCanonical$translateFullType$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateFullType$1,
});

const u0$Compiler$MakeCanonical$translateTuple$3 = (($2, $z) => {
  const $p = ($2)[2];
  return (c0$Compiler$Pos$range$0.usr)(...(c0$Compiler$Pos$range$0.ctx), $p, $z);
});

const u0$Compiler$MakeCanonical$translateTuple$2 = (($faExpressions, $ro, $items) => {
  const $pos = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Compiler$Pos$G$0, $faExpressions, ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateTuple$3,
  }));
  return (((($items)[0] === "$Cons") && (((($items)[2])[0] === "$Cons") && (((($items)[2])[2])[0] === "$Nil")))
    ? ((() => {
      const $ca1 = ($items)[1];
      const $ca2 = (($items)[2])[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "second", $ca2, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "first", $ca1, c0$Dict$empty$0)));
    }))()
    : (((($items)[0] === "$Cons") && (((($items)[2])[0] === "$Cons") && ((((($items)[2])[2])[0] === "$Cons") && ((((($items)[2])[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $ca1 = ($items)[1];
        const $ca2 = (($items)[2])[1];
        const $ca3 = ((($items)[2])[2])[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "third", $ca3, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "second", $ca2, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "first", $ca1, c0$Dict$empty$0))));
      }))()
      : (true
        ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "tuples can be only of size 2 or 3, use a record instead", c0$Core$Nil$0))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 412:4', (sp_toHuman)($items)))));
});

const u0$Compiler$MakeCanonical$translateTuple$1 = (($ro, $translate, $chain) => {
  const $faExpressions = (c0$Compiler$FormattableAst$binopChainExpressions$0.usr)(...(c0$Compiler$FormattableAst$binopChainExpressions$0.ctx), $chain);
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $faExpressions,
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTuple$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $faExpressions,
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTuple$2,
  })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), $translate, $faExpressions));
});

const u0$Compiler$MakeCanonical$translateTuple$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateTuple$1,
});

const u0$Compiler$MakeCanonical$translateTypeFunctionParameter$1 = (($ro, $expression) => {
  const $3 = $expression;
  const $expr_ = ($3)[3];
  return (((($expr_)[0] === "$UnopCall") && ((($expr_)[1])[0] === "$UnopRecycle"))
    ? ((() => {
      const $faOperand = ($expr_)[2];
      return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), c0$Compiler$CanonicalAst$ParRe$0, (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $ro, $faOperand));
    }))()
    : (true
      ? (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), c0$Compiler$CanonicalAst$ParSp$0, (u0$Compiler$MakeCanonical$translateFullType$0.usr)(...(u0$Compiler$MakeCanonical$translateFullType$0.ctx), $ro, $expression))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1356:4', (sp_toHuman)($expr_))));
});

const u0$Compiler$MakeCanonical$translateTypeFunctionParameter$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateTypeFunctionParameter$1,
});

const u0$Compiler$MakeCanonical$translateRawType$13 = (($pos, $usr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), $pos, $usr, c0$Core$Nil$0));
});

const u0$Compiler$MakeCanonical$translateRawType$12 = (($ro, $0) => {
  return (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $ro, $0);
});

const u0$Compiler$MakeCanonical$translateRawType$11 = (($caArgs, $pos, $usr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), $pos, $usr, $caArgs));
});

const u0$Compiler$MakeCanonical$translateRawType$10 = (($maybeModule, $name, $pos, $ro, $caArgs) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caArgs,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRawType$11,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caArgs,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRawType$11,
  })).ctx), ($ro.resolveToUsr.usr)(...($ro.resolveToUsr.ctx), $pos, $maybeModule, $name));
});

const u0$Compiler$MakeCanonical$translateRawType$9 = (($caItem) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), $caItem));
});

const u0$Compiler$MakeCanonical$translateRawType$8 = (($ro, $0, $1) => {
  return (u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$0.usr)(...(u0$Compiler$MakeCanonical$translateAndInsertRecordAttributeType$0.ctx), $ro, $0, $1);
});

const u0$Compiler$MakeCanonical$translateRawType$7 = (($pos, $caAttrs) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$TypeRecord$0.usr)(...(c0$Compiler$CanonicalAst$TypeRecord$0.ctx), $pos, $caAttrs));
});

const u0$Compiler$MakeCanonical$translateRawType$6 = (($ro, $0) => {
  return (u0$Compiler$MakeCanonical$translateTypeFunctionParameter$0.usr)(...(u0$Compiler$MakeCanonical$translateTypeFunctionParameter$0.ctx), $ro, $0);
});

const u0$Compiler$MakeCanonical$translateRawType$5 = (($caParams, $pos, $caReturn) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), $pos, $caParams, $caReturn));
});

const u0$Compiler$MakeCanonical$translateRawType$4 = (($faReturn, $pos, $ro, $caParams) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caParams,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRawType$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caParams,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRawType$5,
  })).ctx), (u0$Compiler$MakeCanonical$translateFullType$0.usr)(...(u0$Compiler$MakeCanonical$translateFullType$0.ctx), $ro, $faReturn));
});

const u0$Compiler$MakeCanonical$translateRawType$3 = (($ro, $0) => {
  return (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $ro, $0);
});

const u0$Compiler$MakeCanonical$translateRawType$2 = (($pos, $recordAttrs) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$TypeRecord$0.usr)(...(c0$Compiler$CanonicalAst$TypeRecord$0.ctx), $pos, $recordAttrs));
});

const u0$Compiler$MakeCanonical$translateRawType$1 = (($ro, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Uppercase")
    ? ((() => {
      const $maybeModule = ($expr_)[1].maybeModule;
      const $name = ($expr_)[1].name;
      return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $pos,
        ]),
        usr: u0$Compiler$MakeCanonical$translateRawType$13,
      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $pos,
        ]),
        usr: u0$Compiler$MakeCanonical$translateRawType$13,
      })).ctx), ($ro.resolveToUsr.usr)(...($ro.resolveToUsr.ctx), $pos, $maybeModule, $name));
    }))()
    : ((($expr_)[0] === "$Lowercase")
      ? ((() => {
        const $attrPath = ($expr_)[1].attrPath;
        const $maybeModule = ($expr_)[1].maybeModule;
        const $maybeType = ($expr_)[1].maybeType;
        const $name = ($expr_)[1].name;
        return ((sp_not_equal)($maybeType, c0$Maybe$Nothing$0)
          ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Can't really specify the type of a type.", c0$Core$Nil$0))
          : ((sp_not_equal)($maybeModule, c0$Maybe$Nothing$0)
            ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "no modules for tyvars!", c0$Core$Nil$0))
            : ((sp_not_equal)($attrPath, c0$Core$Nil$0)
              ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "no attributes for tyvars!", c0$Core$Nil$0))
              : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.usr)(...(c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.ctx), $pos, $name)))));
      }))()
      : (((($expr_)[0] === "$Call") && ((($expr_)[1])[0] === "$Expression"))
        ? ((() => {
          const $refPos = (($expr_)[1])[2];
          const $ref = (($expr_)[1])[3];
          const $faArgs = ($expr_)[2];
          return ((($ref)[0] === "$Uppercase")
            ? ((() => {
              const $maybeModule = ($ref)[1].maybeModule;
              const $name = ($ref)[1].name;
              return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $maybeModule,
                  $name,
                  $pos,
                  $ro,
                ]),
                usr: u0$Compiler$MakeCanonical$translateRawType$10,
              })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $maybeModule,
                  $name,
                  $pos,
                  $ro,
                ]),
                usr: u0$Compiler$MakeCanonical$translateRawType$10,
              })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                ctx: ([
                  $ro,
                ]),
                usr: u0$Compiler$MakeCanonical$translateRawType$12,
              }), $faArgs));
            }))()
            : (true
              ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $refPos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need an Uppercase type name here", c0$Core$Nil$0))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1418:12', (sp_toHuman)($ref))));
        }))()
        : ((($expr_)[0] === "$List")
          ? ((() => {
            const $dotsAndItems = ($expr_)[2];
            return ((($dotsAndItems)[0] === "$Nil")
              ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "You need to specify the type of the List items", c0$Core$Nil$0))
              : (((($dotsAndItems)[0] === "$Cons") && ((($dotsAndItems)[2])[0] === "$Nil"))
                ? ((() => {
                  const $hasDots = ($dotsAndItems)[1].first;
                  const $faItem = ($dotsAndItems)[1].second;
                  return ($hasDots
                    ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "No need to use dots here", c0$Core$Nil$0))
                    : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                      ctx: [],
                      usr: u0$Compiler$MakeCanonical$translateRawType$9,
                    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                      ctx: [],
                      usr: u0$Compiler$MakeCanonical$translateRawType$9,
                    })).ctx), (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $ro, $faItem)));
                }))()
                : (true
                  ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "List items must all have the same type, so you can specify only one type", c0$Core$Nil$0))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1432:12', (sp_toHuman)($dotsAndItems)))));
          }))()
          : ((($expr_)[0] === "$Record")
            ? ((() => {
              const $attrs = ($expr_)[1].attrs;
              const $maybeExtension = ($expr_)[1].maybeExtension;
              return ((sp_not_equal)($maybeExtension, c0$Maybe$Nothing$0)
                ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Experimentally, extensible type annotations are disabled", c0$Core$Nil$0))
                : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $pos,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateRawType$7,
                })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $pos,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateRawType$7,
                })).ctx), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), c0$Dict$empty$0, $attrs, ({
                  ctx: ([
                    $ro,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateRawType$8,
                }))));
            }))()
            : ((($expr_)[0] === "$Fn")
              ? ((() => {
                const $faParams = ($expr_)[2];
                const $faReturn = ($expr_)[3];
                return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $faReturn,
                    $pos,
                    $ro,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateRawType$4,
                })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $faReturn,
                    $pos,
                    $ro,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateRawType$4,
                })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                  ctx: ([
                    $ro,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateRawType$6,
                }), $faParams));
              }))()
              : ((($expr_)[0] === "$BinopChain")
                ? ((() => {
                  const $precedence = ($expr_)[1];
                  const $chain = ($expr_)[2];
                  return ((sp_equal)($precedence, c0$Compiler$Op$precedence_tuple$0)
                    ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                      ctx: ([
                        $pos,
                      ]),
                      usr: u0$Compiler$MakeCanonical$translateRawType$2,
                    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                      ctx: ([
                        $pos,
                      ]),
                      usr: u0$Compiler$MakeCanonical$translateRawType$2,
                    })).ctx), (u0$Compiler$MakeCanonical$translateTuple$0.usr)(...(u0$Compiler$MakeCanonical$translateTuple$0.ctx), $ro, ({
                      ctx: ([
                        $ro,
                      ]),
                      usr: u0$Compiler$MakeCanonical$translateRawType$3,
                    }), $chain))
                    : (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "This operator can't be used in type definitions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($expr_), c0$Core$Nil$0))));
                }))()
                : (true
                  ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Not sure what's up with this type =|", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($expr_), c0$Core$Nil$0)))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1400:4', (sp_toHuman)($expr_))))))))));
});

const u0$Compiler$MakeCanonical$translateRawType$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateRawType$1,
});

const u0$Compiler$MakeCanonical$translateConstructor$9 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $env.ro, $0);
});

const u0$Compiler$MakeCanonical$translateConstructor$8 = (($env, $1) => {
  const $n = $1.first;
  const $p = $1.second;
  return (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), $env.ro.errorModule, $p, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("Undeclared type variable: " + $n), c0$Core$Nil$0));
});

const u0$Compiler$MakeCanonical$translateConstructor$7 = (($constructors, $ins, $name, $pos, $varType, $varUsr, $newEnv) => {
  const $directDeps = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $varUsr, c0$Compiler$Meta$TypeDependency$0), $ins, u0$Compiler$MakeCanonical$typeDeps$0);
  const $2 = $varUsr;
  const $umr = ($2)[1];
  const $c = ({
    constructorUsr: (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $umr, $name),
    directDeps: $directDeps,
    ins: $ins,
    name: $name,
    out: $varType,
    pos: $pos,
    variantTypeUsr: $varUsr,
  });
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $c, $constructors),
    second: $newEnv,
  }));
});

const u0$Compiler$MakeCanonical$translateConstructor$6 = (($constructors, $env, $ins, $name, $pos, $varType, $varUsr, _0) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $ins,
      $name,
      $pos,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$7,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $ins,
      $name,
      $pos,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$7,
  })).ctx), (u0$Compiler$MakeCanonical$insertPatternNames$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternNames$0.ctx), true, (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name), c0$Maybe$Nothing$0), $env));
});

const u0$Compiler$MakeCanonical$translateConstructor$5 = (($in, $dict) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$CanonicalAst$typeTyvars$0.usr)(...(c0$Compiler$CanonicalAst$typeTyvars$0.ctx), $in), $dict);
});

const u0$Compiler$MakeCanonical$translateConstructor$4 = (($constructors, $env, $name, $pos, $varPars, $varType, $varUsr, $ins) => {
  const $tyvars = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $ins, ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateConstructor$5,
  }));
  const $undeclaredTyvars = (c0$Dict$diff$0.usr)(...(c0$Dict$diff$0.ctx), $tyvars, $varPars);
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $ins,
      $name,
      $pos,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$6,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $ins,
      $name,
      $pos,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$6,
  })).ctx), ((sp_equal)($undeclaredTyvars, c0$Dict$empty$0)
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null)
    : ((() => {
      const $toError = ({
        ctx: ([
          $env,
        ]),
        usr: u0$Compiler$MakeCanonical$translateConstructor$8,
      });
      return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Nested$0.usr)(...(u0$Compiler$Error$Nested$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $toError, (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $undeclaredTyvars))));
    }))()));
});

const u0$Compiler$MakeCanonical$translateConstructor$3 = (($constructors, $env, $faPars, $name, $pos, $varPars, $varType, $varUsr, _0) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $name,
      $pos,
      $varPars,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $name,
      $pos,
      $varPars,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$4,
  })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$9,
  }), $faPars));
});

const u0$Compiler$MakeCanonical$translateConstructor$2 = (($constructors, $env, $pos, $varPars, $varType, $varUsr, $1) => {
  const $name = $1.first;
  const $faPars = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $faPars,
      $name,
      $pos,
      $varPars,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $faPars,
      $name,
      $pos,
      $varPars,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$3,
  })).ctx), ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $constructors)
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("constructor " + $name) + " is duplicate"), c0$Core$Nil$0))
    : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null)));
});

const u0$Compiler$MakeCanonical$translateConstructor$1 = (($varType, $varUsr, $varPars, $2, $1) => {
  const $pos = ($2)[2];
  const $expr_ = ($2)[3];
  const $constructors = $1.first;
  const $env = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $pos,
      $varPars,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $constructors,
      $env,
      $pos,
      $varPars,
      $varType,
      $varUsr,
    ]),
    usr: u0$Compiler$MakeCanonical$translateConstructor$2,
  })).ctx), (((($expr_)[0] === "$Constructor") && ((($expr_)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($expr_)[1].name;
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
        first: $name,
        second: c0$Core$Nil$0,
      }));
    }))()
    : (((($expr_)[0] === "$Call") && (((($expr_)[1])[0] === "$Expression") && ((((($expr_)[1])[3])[0] === "$Constructor") && ((((($expr_)[1])[3])[1].maybeModule)[0] === "$Nothing"))))
      ? ((() => {
        const $name = ((($expr_)[1])[3])[1].name;
        const $pars = ($expr_)[2];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
          first: $name,
          second: $pars,
        }));
      }))()
      : (true
        ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need a 'constructor name here!", c0$Core$Nil$0))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1488:4', (sp_toHuman)($expr_))))));
});

const u0$Compiler$MakeCanonical$translateConstructor$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateConstructor$1,
});

const u0$Compiler$MakeCanonical$argumentDeps$1 = (($arg, $deps) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $e = ($arg)[1];
      return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $e, $deps);
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? $deps
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 202:4', (sp_toHuman)($arg))));
});

const u0$Compiler$MakeCanonical$argumentDeps$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$argumentDeps$1,
});

const u0$Compiler$MakeCanonical$patternDeps$2 = (($k, $v, $a) => {
  return (u0$Compiler$MakeCanonical$patternDeps$0.usr)(...(u0$Compiler$MakeCanonical$patternDeps$0.ctx), $v, $a);
});

const u0$Compiler$MakeCanonical$patternDeps$1 = (($pattern, $deps) => {
  return ((($pattern)[0] === "$PatternConstructor")
    ? ((() => {
      const $usr = ($pattern)[2];
      const $ps = ($pattern)[3];
      return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, c0$Compiler$Meta$ConstructorDependency$0, $deps), $ps, u0$Compiler$MakeCanonical$patternDeps$0);
    }))()
    : ((($pattern)[0] === "$PatternRecord")
      ? ((() => {
        const $completeness = ($pattern)[2];
        const $ps = ($pattern)[3];
        return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $deps, $ps, ({
          ctx: [],
          usr: u0$Compiler$MakeCanonical$patternDeps$2,
        }));
      }))()
      : (((($pattern)[0] === "$PatternAny") && ((($pattern)[3])[0] === "$Just"))
        ? ((() => {
          const $annotation = (($pattern)[3])[1];
          return (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $annotation.raw, $deps);
        }))()
        : (((($pattern)[0] === "$PatternAny") && ((($pattern)[3])[0] === "$Nothing"))
          ? $deps
          : ((($pattern)[0] === "$PatternLiteralNumber")
            ? $deps
            : ((($pattern)[0] === "$PatternLiteralText")
              ? $deps
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 97:4', (sp_toHuman)($pattern))))))));
});

const u0$Compiler$MakeCanonical$patternDeps$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$patternDeps$1,
});

const u0$Compiler$MakeCanonical$parameterDeps$1 = (($par, $deps) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $pa = ($par)[2];
      return (u0$Compiler$MakeCanonical$patternDeps$0.usr)(...(u0$Compiler$MakeCanonical$patternDeps$0.ctx), $pa, $deps);
    }))()
    : (true
      ? $deps
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 209:4', (sp_toHuman)($par))));
});

const u0$Compiler$MakeCanonical$parameterDeps$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$parameterDeps$1,
});

const u0$Compiler$MakeCanonical$expressionDeps$5 = (($name, $v, $a) => {
  return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $v, $a);
});

const u0$Compiler$MakeCanonical$expressionDeps$4 = (($name, $v, $a) => {
  return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $v, $a);
});

const u0$Compiler$MakeCanonical$expressionDeps$3 = (($name, $v, $a) => {
  return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $v, $a);
});

const u0$Compiler$MakeCanonical$expressionDeps$2 = (($2, $d) => {
  const $u = $2.first;
  const $p = $2.second;
  const $b = $2.third;
  return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $b, (u0$Compiler$MakeCanonical$patternDeps$0.usr)(...(u0$Compiler$MakeCanonical$patternDeps$0.ctx), $p, $d));
});

const u0$Compiler$MakeCanonical$expressionDeps$1 = (($expression, $deps) => {
  return ((($expression)[0] === "$LiteralNumber")
    ? $deps
    : ((($expression)[0] === "$LiteralText")
      ? $deps
      : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
        ? ((() => {
          const $usr = (($expression)[2])[1];
          return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, c0$Compiler$Meta$ValueDependency$0, $deps);
        }))()
        : ((($expression)[0] === "$Variable")
          ? $deps
          : ((($expression)[0] === "$Constructor")
            ? ((() => {
              const $usr = ($expression)[2];
              return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, c0$Compiler$Meta$ConstructorDependency$0, $deps);
            }))()
            : ((($expression)[0] === "$Fn")
              ? ((() => {
                const $pars = ($expression)[2];
                const $body = ($expression)[3];
                return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $body, (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $deps, $pars, u0$Compiler$MakeCanonical$parameterDeps$0));
              }))()
              : (((($expression)[0] === "$Record") && ((($expression)[2])[0] === "$Nothing"))
                ? ((() => {
                  const $exprByName = ($expression)[3];
                  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $deps, $exprByName, ({
                    ctx: [],
                    usr: u0$Compiler$MakeCanonical$expressionDeps$5,
                  }));
                }))()
                : (((($expression)[0] === "$Record") && ((($expression)[2])[0] === "$Just"))
                  ? ((() => {
                    const $expr = (($expression)[2])[1];
                    const $exprByName = ($expression)[3];
                    return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $expr, $deps), $exprByName, ({
                      ctx: [],
                      usr: u0$Compiler$MakeCanonical$expressionDeps$4,
                    }));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $exprByName = ($expression)[3];
                      return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $deps, $exprByName, ({
                        ctx: [],
                        usr: u0$Compiler$MakeCanonical$expressionDeps$3,
                      }));
                    }))()
                    : ((($expression)[0] === "$RecordAccess")
                      ? ((() => {
                        const $e = ($expression)[3];
                        return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $e, $deps);
                      }))()
                      : ((($expression)[0] === "$Call")
                        ? ((() => {
                          const $e0 = ($expression)[2];
                          const $args = ($expression)[3];
                          return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $e0, $deps), $args, u0$Compiler$MakeCanonical$argumentDeps$0);
                        }))()
                        : ((($expression)[0] === "$If")
                          ? ((() => {
                            const $args = ($expression)[2];
                            return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $args.false, (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $args.true, (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $args.condition, $deps)));
                          }))()
                          : ((($expression)[0] === "$Try")
                            ? ((() => {
                              const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                              const $value = ($expression)[2].value;
                              const $addDeps = ({
                                ctx: [],
                                usr: u0$Compiler$MakeCanonical$expressionDeps$2,
                              });
                              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $value, $deps), $patternsAndExpressions, $addDeps);
                            }))()
                            : ((($expression)[0] === "$LetIn")
                              ? ((() => {
                                const $valueDef = ($expression)[1];
                                const $e = ($expression)[2];
                                return (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $e, (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $valueDef.body, (u0$Compiler$MakeCanonical$patternDeps$0.usr)(...(u0$Compiler$MakeCanonical$patternDeps$0.ctx), $valueDef.pattern, $deps)));
                              }))()
                              : ((($expression)[0] === "$Introspect")
                                ? ((() => {
                                  const $introspect = ($expression)[2];
                                  const $usr = ($expression)[3];
                                  const $dependencyType = ((($introspect)[0] === "$Value")
                                    ? c0$Compiler$Meta$ValueDependency$0
                                    : ((($introspect)[0] === "$Type")
                                      ? c0$Compiler$Meta$TypeDependency$0
                                      : ((($introspect)[0] === "$TypeOpen")
                                        ? c0$Compiler$Meta$TypeDependency$0
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 189:16', (sp_toHuman)($introspect)))));
                                  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, $dependencyType, $deps);
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 123:4', (sp_toHuman)($expression)))))))))))))))));
});

const u0$Compiler$MakeCanonical$expressionDeps$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$expressionDeps$1,
});

const u0$Compiler$MakeCanonical$escapeLiteralText$1 = (($singleOrTriple, $l) => {
  return ((($singleOrTriple)[0] === "$SingleQuote")
    ? $l
    : ((($singleOrTriple)[0] === "$TripleQuote")
      ? (c0$Text$replace$0.usr)(...(c0$Text$replace$0.ctx), "\n", "\\n", (c0$Text$replace$0.usr)(...(c0$Text$replace$0.ctx), "\"", "\\\"", $l))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 556:8', (sp_toHuman)($singleOrTriple))));
});

const u0$Compiler$MakeCanonical$escapeLiteralText$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$escapeLiteralText$1,
});

const u0$Compiler$MakeCanonical$isPlaceholder$1 = (($1) => {
  const $expr = ($1)[3];
  return ((($expr)[0] === "$ArgumentPlaceholder")
    ? true
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1101:4', (sp_toHuman)($expr))));
});

const u0$Compiler$MakeCanonical$isPlaceholder$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$isPlaceholder$1,
});

const u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$3 = (($ex, $x) => {
  return ($ex.usr)(...($ex.ctx), (c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.usr)(...(c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.ctx), $x));
});

const u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$2 = (($pos, $0) => {
  return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $pos, $0);
});

const u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$1 = (($env, $pos, $placeholdersCount, $body) => {
  const $ex = ({
    ctx: ([
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$2,
  });
  return (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, ($ex.usr)(...($ex.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Inline$0, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $ex,
    ]),
    usr: u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$3,
  }), (c0$List$range$0.usr)(...(c0$List$range$0.ctx), 0, ($placeholdersCount - 1))), ($ex.usr)(...($ex.ctx), $body))));
});

const u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$1,
});

const u0$Compiler$MakeCanonical$maybeInlinePlaceholders$2 = (($innerArg, $1) => {
  const $remainingOuterArgs = $1.first;
  const $argsAccum = $1.second;
  const $3 = ({
    first: $innerArg,
    second: $remainingOuterArgs,
  });
  return (((($3.first)[0] === "$ArgumentExpression") && (((($3.first)[1])[0] === "$Variable") && ((((($3.first)[1])[2])[0] === "$RefPlaceholder") && (($3.second)[0] === "$Cons"))))
    ? ((() => {
      const $next = ($3.second)[1];
      const $restOuterArgs = ($3.second)[2];
      return ({
        first: $restOuterArgs,
        second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $next, $argsAccum),
      });
    }))()
    : (true
      ? ((() => {
        const $arg = $3.first;
        return ({
          first: $remainingOuterArgs,
          second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $arg, $argsAccum),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 837:16', (sp_toHuman)($3))));
});

const u0$Compiler$MakeCanonical$maybeInlinePlaceholders$1 = (($ref, $outerArgs) => {
  return (((($ref)[0] === "$Fn") && ((($ref)[3])[0] === "$Call"))
    ? ((() => {
      const $params = ($ref)[2];
      const $pos = (($ref)[3])[1];
      const $nestedRef = (($ref)[3])[2];
      const $innerArgs = (($ref)[3])[3];
      const $replaceArg = ({
        ctx: [],
        usr: u0$Compiler$MakeCanonical$maybeInlinePlaceholders$2,
      });
      const $3 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
        first: $outerArgs,
        second: c0$Core$Nil$0,
      }), $innerArgs, $replaceArg);
      const $reversedNewArgs = $3.second;
      const $remainingOuterArgs = $3.first;
      return ((sp_equal)($remainingOuterArgs, c0$Core$Nil$0)
        ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, $nestedRef, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $reversedNewArgs)))
        : c0$Maybe$Nothing$0);
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 832:4', (sp_toHuman)($ref))));
});

const u0$Compiler$MakeCanonical$maybeInlinePlaceholders$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$maybeInlinePlaceholders$1,
});

const u0$Compiler$MakeCanonical$translateArgument$2 = (($caExpr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), $caExpr));
});

const u0$Compiler$MakeCanonical$translateArgument$1 = (($env, $faExpression) => {
  const $3 = $faExpression;
  const $expr = ($3)[3];
  const $pos = ($3)[2];
  return (((($expr)[0] === "$UnopCall") && (((($expr)[1])[0] === "$UnopRecycle") && ((($expr)[2])[0] === "$Expression")))
    ? ((() => {
      const $faOperand = (($expr)[2])[3];
      return ((($faOperand)[0] === "$Lowercase")
        ? ((() => {
          const $attrPath = ($faOperand)[1].attrPath;
          const $maybeModule = ($faOperand)[1].maybeModule;
          const $maybeType = ($faOperand)[1].maybeType;
          const $name = ($faOperand)[1].name;
          return ((sp_not_equal)($maybeType, c0$Maybe$Nothing$0)
            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Sorry, at least for now annotations are not supported here", c0$Core$Nil$0))
            : ((sp_not_equal)($maybeModule, c0$Maybe$Nothing$0)
              ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Only values declared inside a function scope can be mutated!", c0$Core$Nil$0))
              : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$ArgumentRecycle$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentRecycle$0.ctx), $pos, $name, $attrPath))));
        }))()
        : (true
          ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I can recycle only variables!", c0$Core$Nil$0))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1073:12', (sp_toHuman)($faOperand))));
    }))()
    : ((($expr)[0] === "$ArgumentPlaceholder")
      ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "compiler error: this should have been eliminated already", c0$Core$Nil$0))
      : ((($expr)[0] === "$ResolvedArgumentPlaceholder")
        ? ((() => {
          const $n = ($expr)[1];
          return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $pos, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), $n))));
        }))()
        : (true
          ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
            ctx: [],
            usr: u0$Compiler$MakeCanonical$translateArgument$2,
          })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
            ctx: [],
            usr: u0$Compiler$MakeCanonical$translateArgument$2,
          })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faExpression))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1070:4', (sp_toHuman)($expr))))));
});

const u0$Compiler$MakeCanonical$translateArgument$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateArgument$1,
});

const u0$Compiler$MakeCanonical$resolvePipe$5 = (($2, $acc) => {
  const $sep = $2.first;
  const $faExp = $2.second;
  const $3 = $faExp;
  const $p = ($3)[2];
  return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $p, (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), $faExp, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $acc, c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical$resolvePipe$4 = (($sep) => {
  return (sp_equal)($sep.usr, u0$Compiler$CoreDefs$sendLeft$0.usr);
});

const u0$Compiler$MakeCanonical$resolvePipe$3 = (($2, $acc) => {
  const $sep = $2.first;
  const $faExp = $2.second;
  const $3 = $faExp;
  const $p = ($3)[2];
  return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $p, (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), $faExp, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $acc, c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical$resolvePipe$2 = (($sep) => {
  return (sp_equal)($sep.usr, u0$Compiler$CoreDefs$sendRight$0.usr);
});

const u0$Compiler$MakeCanonical$resolvePipe$1 = (($env, $pos, $opChain) => {
  return ((c0$Compiler$FormattableAst$binopChainAllBinops$0.usr)(...(c0$Compiler$FormattableAst$binopChainAllBinops$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$resolvePipe$2,
  }), $opChain)
    ? ((() => {
      const $4 = $opChain;
      const $chainTail = $4.second;
      const $head = $4.first;
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $head, $chainTail, ({
        ctx: [],
        usr: u0$Compiler$MakeCanonical$resolvePipe$3,
      })));
    }))()
    : ((c0$Compiler$FormattableAst$binopChainAllBinops$0.usr)(...(c0$Compiler$FormattableAst$binopChainAllBinops$0.ctx), ({
      ctx: [],
      usr: u0$Compiler$MakeCanonical$resolvePipe$4,
    }), $opChain)
      ? ((() => {
        const $4 = (c0$Compiler$FormattableAst$binopChainReverse$0.usr)(...(c0$Compiler$FormattableAst$binopChainReverse$0.ctx), $opChain);
        const $body = $4.second;
        const $last = $4.first;
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $last, $body, ({
          ctx: [],
          usr: u0$Compiler$MakeCanonical$resolvePipe$5,
        })));
      }))()
      : (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Mixing `>>` and `<<` is ambiguous. Use parens!", c0$Core$Nil$0))));
});

const u0$Compiler$MakeCanonical$resolvePipe$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$resolvePipe$1,
});

const u0$Compiler$MakeCanonical$sameDirectionAs$1 = (($a, $b) => {
  return ((sp_equal)($a.symbol, $b.symbol)
    ? true
    : ((() => {
      const $3 = $a.symbol;
      return ((">" === $3)
        ? (sp_equal)($b.symbol, ">=")
        : ((">=" === $3)
          ? (sp_equal)($b.symbol, ">")
          : (("<" === $3)
            ? (sp_equal)($b.symbol, "<=")
            : (("<=" === $3)
              ? (sp_equal)($b.symbol, "<")
              : (true
                ? false
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1270:8', (sp_toHuman)($3)))))));
    }))());
});

const u0$Compiler$MakeCanonical$sameDirectionAs$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$sameDirectionAs$1,
});

const u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$3 = (($caLeft, $op, $pos, $caRight) => {
  const $caRef = (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $op.pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $op.usr));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, $caRef, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $caLeft, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), $caRight), c0$Core$Nil$0))));
});

const u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$2 = (($env, $faRight, $faTail, $op, $pos, $caLeft) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caLeft,
      $op,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caLeft,
      $op,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.ctx), $env, $pos, ({
    first: $faRight,
    second: $faTail,
  })));
});

const u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$1 = (($env, $pos, $1) => {
  const $faLeft = $1.first;
  const $faOpsAndRight = $1.second;
  return ((($faOpsAndRight)[0] === "$Nil")
    ? (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faLeft)
    : ((($faOpsAndRight)[0] === "$Cons")
      ? ((() => {
        const $op = ($faOpsAndRight)[1].first;
        const $faRight = ($faOpsAndRight)[1].second;
        const $faTail = ($faOpsAndRight)[2];
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $faRight,
            $faTail,
            $op,
            $pos,
          ]),
          usr: u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $faRight,
            $faTail,
            $op,
            $pos,
          ]),
          usr: u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$2,
        })).ctx), (u0$Compiler$MakeCanonical$translateArgument$0.usr)(...(u0$Compiler$MakeCanonical$translateArgument$0.ctx), $env, $faLeft));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1280:4', (sp_toHuman)($faOpsAndRight))));
});

const u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$1,
});

const u0$Compiler$MakeCanonical$translateComparison$2 = (($firstSep, $0) => {
  return (u0$Compiler$MakeCanonical$sameDirectionAs$0.usr)(...(u0$Compiler$MakeCanonical$sameDirectionAs$0.ctx), $firstSep, $0);
});

const u0$Compiler$MakeCanonical$translateComparison$1 = (($env, $pos, $opChain) => {
  const $4 = $opChain.second;
  return ((($4)[0] === "$Nil")
    ? (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $opChain.first)
    : (((($4)[0] === "$Cons") && ((($4)[2])[0] === "$Nil"))
      ? ((() => {
        const $sep = ($4)[1].first;
        const $second = ($4)[1].second;
        return (u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.ctx), $env, $pos, $opChain);
      }))()
      : ((($4)[0] === "$Cons")
        ? ((() => {
          const $firstSep = ($4)[1].first;
          const $second = ($4)[1].second;
          const $moar = ($4)[2];
          return ((c0$Compiler$FormattableAst$binopChainAllBinops$0.usr)(...(c0$Compiler$FormattableAst$binopChainAllBinops$0.ctx), ({
            ctx: ([
              $firstSep,
            ]),
            usr: u0$Compiler$MakeCanonical$translateComparison$2,
          }), $opChain)
            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO: not (yet) implemented: compops expansion", c0$Core$Nil$0))
            : (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "can't mix comparison ops with different direction", c0$Core$Nil$0)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1217:4', (sp_toHuman)($4)))));
});

const u0$Compiler$MakeCanonical$translateComparison$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateComparison$1,
});

const u0$Compiler$MakeCanonical$translateBinopChainRec$2 = (($env, $leftAccum, $op, $pos, $tail, $caRight) => {
  return (u0$Compiler$MakeCanonical$translateBinopChainRec$0.usr)(...(u0$Compiler$MakeCanonical$translateBinopChainRec$0.ctx), $env, $pos, (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $op.pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $op.usr)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), $leftAccum), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $caRight, c0$Core$Nil$0))), $tail);
});

const u0$Compiler$MakeCanonical$translateBinopChainRec$1 = (($env, $pos, $leftAccum, $opsAndRight) => {
  return ((($opsAndRight)[0] === "$Nil")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $leftAccum)
    : ((($opsAndRight)[0] === "$Cons")
      ? ((() => {
        const $op = ($opsAndRight)[1].first;
        const $faRight = ($opsAndRight)[1].second;
        const $tail = ($opsAndRight)[2];
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $leftAccum,
            $op,
            $pos,
            $tail,
          ]),
          usr: u0$Compiler$MakeCanonical$translateBinopChainRec$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $leftAccum,
            $op,
            $pos,
            $tail,
          ]),
          usr: u0$Compiler$MakeCanonical$translateBinopChainRec$2,
        })).ctx), (u0$Compiler$MakeCanonical$translateArgument$0.usr)(...(u0$Compiler$MakeCanonical$translateArgument$0.ctx), $env, $faRight));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1305:4', (sp_toHuman)($opsAndRight))));
});

const u0$Compiler$MakeCanonical$translateBinopChainRec$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateBinopChainRec$1,
});

const u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$2 = (($env, $opsAndRight, $pos, $caLeft) => {
  return (u0$Compiler$MakeCanonical$translateBinopChainRec$0.usr)(...(u0$Compiler$MakeCanonical$translateBinopChainRec$0.ctx), $env, $pos, $caLeft, $opsAndRight);
});

const u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$1 = (($env, $pos, $1) => {
  const $left = $1.first;
  const $opsAndRight = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $opsAndRight,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $opsAndRight,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$2,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $left));
});

const u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$1,
});

const u0$Compiler$MakeCanonical$translateLogical$3 = (($sep) => {
  return (sp_equal)($sep.usr, u0$Compiler$CoreDefs$and_$0.usr);
});

const u0$Compiler$MakeCanonical$translateLogical$2 = (($sep) => {
  return (sp_equal)($sep.usr, u0$Compiler$CoreDefs$or_$0.usr);
});

const u0$Compiler$MakeCanonical$translateLogical$1 = (($env, $pos, $opChain) => {
  const $allSame = ((c0$Compiler$FormattableAst$binopChainAllBinops$0.usr)(...(c0$Compiler$FormattableAst$binopChainAllBinops$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateLogical$3,
  }), $opChain) || (c0$Compiler$FormattableAst$binopChainAllBinops$0.usr)(...(c0$Compiler$FormattableAst$binopChainAllBinops$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateLogical$2,
  }), $opChain));
  return ($allSame
    ? (u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.ctx), $env, $pos, $opChain)
    : (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Mixing `and` and `or` is ambiguous. Use parens!", c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical$translateLogical$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateLogical$1,
});

const u0$Compiler$MakeCanonical$translateMutop$3 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateArgument$0.usr)(...(u0$Compiler$MakeCanonical$translateArgument$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateMutop$2 = (($caRef, $pos, $caArgs) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, $caRef, $caArgs));
});

const u0$Compiler$MakeCanonical$translateMutop$1 = (($env, $pos, $1) => {
  const $left = $1.first;
  const $chainTail = $1.second;
  return ((($chainTail)[0] === "$Nil")
    ? (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $left)
    : (((($chainTail)[0] === "$Cons") && ((($chainTail)[2])[0] === "$Nil"))
      ? ((() => {
        const $op = ($chainTail)[1].first;
        const $right = ($chainTail)[1].second;
        const $caRef = (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $op.pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $op.usr));
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $caRef,
            $pos,
          ]),
          usr: u0$Compiler$MakeCanonical$translateMutop$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $caRef,
            $pos,
          ]),
          usr: u0$Compiler$MakeCanonical$translateMutop$2,
        })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
          ctx: ([
            $env,
          ]),
          usr: u0$Compiler$MakeCanonical$translateMutop$3,
        }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $left, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $right, c0$Core$Nil$0))));
      }))()
      : (true
        ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "mutops can't be chained", c0$Core$Nil$0))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1247:4', (sp_toHuman)($chainTail)))));
});

const u0$Compiler$MakeCanonical$translateMutop$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateMutop$1,
});

const u0$Compiler$MakeCanonical$translateTupleExpression$6 = (($first, $pos, $second) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), $pos, c0$Maybe$Nothing$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "second", $second, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "first", $first, c0$Dict$empty$0))));
});

const u0$Compiler$MakeCanonical$translateTupleExpression$5 = (($env, $pos, $two, $first) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $first,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTupleExpression$6,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $first,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTupleExpression$6,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $two));
});

const u0$Compiler$MakeCanonical$translateTupleExpression$4 = (($first, $pos, $second, $third) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), $pos, c0$Maybe$Nothing$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "third", $third, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "second", $second, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "first", $first, c0$Dict$empty$0)))));
});

const u0$Compiler$MakeCanonical$translateTupleExpression$3 = (($env, $first, $pos, $three, $second) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $first,
      $pos,
      $second,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTupleExpression$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $first,
      $pos,
      $second,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTupleExpression$4,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $three));
});

const u0$Compiler$MakeCanonical$translateTupleExpression$2 = (($env, $pos, $three, $two, $first) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $first,
      $pos,
      $three,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTupleExpression$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $first,
      $pos,
      $three,
    ]),
    usr: u0$Compiler$MakeCanonical$translateTupleExpression$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $two));
});

const u0$Compiler$MakeCanonical$translateTupleExpression$1 = (($env, $pos, $1) => {
  const $one = $1.first;
  const $chainTail = $1.second;
  return ((($chainTail)[0] === "$Nil")
    ? (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $one)
    : (((($chainTail)[0] === "$Cons") && ((($chainTail)[2])[0] === "$Nil"))
      ? ((() => {
        const $two = ($chainTail)[1].second;
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $pos,
            $two,
          ]),
          usr: u0$Compiler$MakeCanonical$translateTupleExpression$5,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $pos,
            $two,
          ]),
          usr: u0$Compiler$MakeCanonical$translateTupleExpression$5,
        })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $one));
      }))()
      : (((($chainTail)[0] === "$Cons") && (((($chainTail)[2])[0] === "$Cons") && (((($chainTail)[2])[2])[0] === "$Nil")))
        ? ((() => {
          const $two = ($chainTail)[1].second;
          const $three = (($chainTail)[2])[1].second;
          return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
            ctx: ([
              $env,
              $pos,
              $three,
              $two,
            ]),
            usr: u0$Compiler$MakeCanonical$translateTupleExpression$2,
          })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
            ctx: ([
              $env,
              $pos,
              $three,
              $two,
            ]),
            usr: u0$Compiler$MakeCanonical$translateTupleExpression$2,
          })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $one));
        }))()
        : (true
          ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Tuples can't have more than 3 items, use a record instead.", c0$Core$Nil$0))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1181:4', (sp_toHuman)($chainTail))))));
});

const u0$Compiler$MakeCanonical$translateTupleExpression$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateTupleExpression$1,
});

const u0$Compiler$MakeCanonical$translateBinopChain$4 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateBinopChain$3 = (($2, $1) => {
  const $op = $2.first;
  const $exp = $2.second;
  const $cnt = $1.first;
  const $rev = $1.second;
  return ((u0$Compiler$MakeCanonical$isPlaceholder$0.usr)(...(u0$Compiler$MakeCanonical$isPlaceholder$0.ctx), $exp)
    ? ((() => {
      const $3 = $exp;
      const $p = ($3)[2];
      const $c = ($3)[1];
      return ({
        first: ($cnt + 1),
        second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
          first: $op,
          second: (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), $c, $p, (c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.usr)(...(c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.ctx), $cnt)),
        }), $rev),
      });
    }))()
    : ({
      first: $cnt,
      second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
        first: $op,
        second: $exp,
      }), $rev),
    }));
});

const u0$Compiler$MakeCanonical$translateBinopChain$2 = (($pos, $0) => {
  return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $pos, $0);
});

const u0$Compiler$MakeCanonical$translateBinopChain$1 = (($env, $pos, $group, $opChain) => {
  const $toExpression = ({
    ctx: ([
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateBinopChain$2,
  });
  const $5 = ((u0$Compiler$MakeCanonical$isPlaceholder$0.usr)(...(u0$Compiler$MakeCanonical$isPlaceholder$0.ctx), $opChain.first)
    ? ({
      first: 1,
      second: ($toExpression.usr)(...($toExpression.ctx), (c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.usr)(...(c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.ctx), 0)),
    })
    : ({
      first: 0,
      second: $opChain.first,
    }));
  const $head = $5.second;
  const $cnt0 = $5.first;
  const $6 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
    first: $cnt0,
    second: c0$Core$Nil$0,
  }), $opChain.second, ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateBinopChain$3,
  }));
  const $reversedChainTail = $6.second;
  const $placeholdersCount = $6.first;
  return (($placeholdersCount > 0)
    ? (u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0.usr)(...(u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0.ctx), $env, $pos, $placeholdersCount, (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), $group, ({
      first: $head,
      second: (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $reversedChainTail),
    })))
    : ((sp_equal)($group, c0$Compiler$Op$precedence_pipe$0)
      ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $env,
        ]),
        usr: u0$Compiler$MakeCanonical$translateBinopChain$4,
      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $env,
        ]),
        usr: u0$Compiler$MakeCanonical$translateBinopChain$4,
      })).ctx), (u0$Compiler$MakeCanonical$resolvePipe$0.usr)(...(u0$Compiler$MakeCanonical$resolvePipe$0.ctx), $env, $pos, $opChain))
      : ((sp_equal)($group, c0$Compiler$Op$precedence_tuple$0)
        ? (u0$Compiler$MakeCanonical$translateTupleExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateTupleExpression$0.ctx), $env, $pos, $opChain)
        : ((sp_equal)($group, c0$Compiler$Op$precedence_comparison$0)
          ? (u0$Compiler$MakeCanonical$translateComparison$0.usr)(...(u0$Compiler$MakeCanonical$translateComparison$0.ctx), $env, $pos, $opChain)
          : ((sp_equal)($group, c0$Compiler$Op$precedence_logical$0)
            ? (u0$Compiler$MakeCanonical$translateLogical$0.usr)(...(u0$Compiler$MakeCanonical$translateLogical$0.ctx), $env, $pos, $opChain)
            : ((sp_equal)($group, c0$Compiler$Op$precedence_mutop$0)
              ? (u0$Compiler$MakeCanonical$translateMutop$0.usr)(...(u0$Compiler$MakeCanonical$translateMutop$0.ctx), $env, $pos, $opChain)
              : ((sp_equal)($group, c0$Compiler$Op$precedence_addittive$0)
                ? (u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$0.ctx), $env, $pos, $opChain)
                : ((sp_equal)($group, c0$Compiler$Op$precedence_multiplicative$0)
                  ? (u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateLeftAssociativeBinopChain$0.ctx), $env, $pos, $opChain)
                  : (u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateRightAssociativeBinopChain$0.ctx), $env, $pos, $opChain)))))))));
});

const u0$Compiler$MakeCanonical$translateBinopChain$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateBinopChain$1,
});

const u0$Compiler$MakeCanonical$translateNumber$1 = (($ro, $isPercent, $constructor, $pos, $numberAsText) => {
  const $6 = (text_toNumber)((c0$Text$replace$0.usr)(...(c0$Text$replace$0.ctx), "_", "", $numberAsText));
  return ((($6)[0] === "$Nothing")
    ? (u0$Compiler$MakeCanonical$erroro$0.usr)(...(u0$Compiler$MakeCanonical$erroro$0.ctx), $ro, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("invalid number: `" + $numberAsText) + "`"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO link to documentation on valid number formats", c0$Core$Nil$0)))
    : ((($6)[0] === "$Just")
      ? ((() => {
        const $n = ($6)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ($constructor.usr)(...($constructor.ctx), $pos, ($isPercent
          ? (sp_divide)($n, 100)
          : $n)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 985:4', (sp_toHuman)($6))));
});

const u0$Compiler$MakeCanonical$translateNumber$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateNumber$1,
});

const u0$Compiler$MakeCanonical$translateMaybeAnnotation$3 = (($env, $tyvarName, $pos) => {
  return ({
    nonFn: (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $tyvarName, $env.nonFn),
  });
});

const u0$Compiler$MakeCanonical$translateMaybeAnnotation$2 = (($env, $raw) => {
  const $tyvars = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateMaybeAnnotation$3,
  }), (c0$Compiler$CanonicalAst$typeTyvars$0.usr)(...(c0$Compiler$CanonicalAst$typeTyvars$0.ctx), $raw));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    raw: $raw,
    tyvars: $tyvars,
    univars: (c0$Compiler$CanonicalAst$typeUnivars$0.usr)(...(c0$Compiler$CanonicalAst$typeUnivars$0.ctx), $raw),
  })));
});

const u0$Compiler$MakeCanonical$translateMaybeAnnotation$1 = (($env, $maybeFaType) => {
  return ((($maybeFaType)[0] === "$Nothing")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), c0$Maybe$Nothing$0)
    : ((($maybeFaType)[0] === "$Just")
      ? ((() => {
        const $faType = ($maybeFaType)[1];
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
          ]),
          usr: u0$Compiler$MakeCanonical$translateMaybeAnnotation$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
          ]),
          usr: u0$Compiler$MakeCanonical$translateMaybeAnnotation$2,
        })).ctx), (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $env.ro, $faType));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 324:4', (sp_toHuman)($maybeFaType))));
});

const u0$Compiler$MakeCanonical$translateMaybeAnnotation$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateMaybeAnnotation$1,
});

const u0$Compiler$MakeCanonical$translatePatternAny$2 = (($name, $pos, $maybeAnnotation) => {
  const $maybeName = ((sp_equal)($name, "_")
    ? c0$Maybe$Nothing$0
    : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), $pos, $maybeName, $maybeAnnotation));
});

const u0$Compiler$MakeCanonical$translatePatternAny$1 = (($env, $pos, $maybeType, $maybeModule, $name, $attrPath) => {
  return ((sp_not_equal)($attrPath, c0$Core$Nil$0)
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "pattern names can't have type attributes", c0$Core$Nil$0))
    : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $name,
        $pos,
      ]),
      usr: u0$Compiler$MakeCanonical$translatePatternAny$2,
    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $name,
        $pos,
      ]),
      usr: u0$Compiler$MakeCanonical$translatePatternAny$2,
    })).ctx), (u0$Compiler$MakeCanonical$translateMaybeAnnotation$0.usr)(...(u0$Compiler$MakeCanonical$translateMaybeAnnotation$0.ctx), $env, $maybeType)));
});

const u0$Compiler$MakeCanonical$translatePatternAny$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translatePatternAny$1,
});

const u0$Compiler$MakeCanonical$translatePatternConstructor$2 = (($args, $pos, $usr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$PatternConstructor$0.usr)(...(c0$Compiler$CanonicalAst$PatternConstructor$0.ctx), $pos, $usr, $args));
});

const u0$Compiler$MakeCanonical$translatePatternConstructor$1 = (($env, $pos, $maybeModule, $name, $args) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $args,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translatePatternConstructor$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $args,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translatePatternConstructor$2,
  })).ctx), ($env.ro.resolveToUsr.usr)(...($env.ro.resolveToUsr.ctx), $pos, $maybeModule, $name));
});

const u0$Compiler$MakeCanonical$translatePatternConstructor$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translatePatternConstructor$1,
});

const u0$Compiler$MakeCanonical$insertPatternRecordAttribute$3 = (($caAttrs, $caName, $caPattern) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $caName, $caPattern, $caAttrs));
});

const u0$Compiler$MakeCanonical$insertPatternRecordAttribute$2 = (($attr, $caAttrs, $env, $1) => {
  const $pos = $1.first;
  const $caName = $1.second;
  const $maybeFaType = $1.third;
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $caName, $caAttrs)
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("duplicate attribute name in pattern: " + $caName), c0$Core$Nil$0))
    : ((() => {
      const $2 = ({
        first: $attr.maybeExpr,
        second: $maybeFaType,
      });
      return (((($2.first)[0] === "$Just") && ((($2.second)[0] === "$Just") && ((($2.second)[1])[0] === "$Expression")))
        ? ((() => {
          const $typePos = (($2.second)[1])[2];
          return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $typePos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "if you want to annotate the attribute, use { x = y as TheType }", c0$Core$Nil$0));
        }))()
        : (((($2.first)[0] === "$Nothing") && (($2.second)[0] === "$Just"))
          ? ((() => {
            const $faType = ($2.second)[1];
            return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO annotating record attributes needs more thinking", c0$Core$Nil$0));
          }))()
          : (((($2.first)[0] === "$Just") && (($2.second)[0] === "$Nothing"))
            ? ((() => {
              const $faPattern = ($2.first)[1];
              return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $caAttrs,
                  $caName,
                ]),
                usr: u0$Compiler$MakeCanonical$insertPatternRecordAttribute$3,
              })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $caAttrs,
                  $caName,
                ]),
                usr: u0$Compiler$MakeCanonical$insertPatternRecordAttribute$3,
              })).ctx), (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $faPattern));
            }))()
            : (((($2.first)[0] === "$Nothing") && (($2.second)[0] === "$Nothing"))
              ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $caName, (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $caName), c0$Maybe$Nothing$0), $caAttrs))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 351:8', (sp_toHuman)($2))))));
    }))());
});

const u0$Compiler$MakeCanonical$insertPatternRecordAttribute$1 = (($env, $attr, $caAttrs) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attr,
      $caAttrs,
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$insertPatternRecordAttribute$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attr,
      $caAttrs,
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$insertPatternRecordAttribute$2,
  })).ctx), (u0$Compiler$MakeCanonical$translateAttributeName$0.usr)(...(u0$Compiler$MakeCanonical$translateAttributeName$0.ctx), $env.ro, $attr.name));
});

const u0$Compiler$MakeCanonical$insertPatternRecordAttribute$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$insertPatternRecordAttribute$1,
});

const u0$Compiler$MakeCanonical$translatePatternRecord$4 = (($completeness, $pos, $x) => {
  return (c0$Compiler$CanonicalAst$PatternRecord$0.usr)(...(c0$Compiler$CanonicalAst$PatternRecord$0.ctx), $pos, $completeness, $x);
});

const u0$Compiler$MakeCanonical$translatePatternRecord$3 = (($env, $0, $1) => {
  return (u0$Compiler$MakeCanonical$insertPatternRecordAttribute$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternRecordAttribute$0.ctx), $env, $0, $1);
});

const u0$Compiler$MakeCanonical$translatePatternRecord$2 = (($attrs, $env, $pos, $completeness) => {
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), ({
    ctx: ([
      $completeness,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translatePatternRecord$4,
  }), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), c0$Dict$empty$0, $attrs, ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translatePatternRecord$3,
  })));
});

const u0$Compiler$MakeCanonical$translatePatternRecord$1 = (($env, $pos, $maybeMaybeExt, $attrs) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attrs,
      $env,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translatePatternRecord$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attrs,
      $env,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translatePatternRecord$2,
  })).ctx), (((($maybeMaybeExt)[0] === "$Just") && (((($maybeMaybeExt)[1])[0] === "$Just") && (((($maybeMaybeExt)[1])[1])[0] === "$Expression")))
    ? ((() => {
      const $p = ((($maybeMaybeExt)[1])[1])[2];
      const $expr_ = ((($maybeMaybeExt)[1])[1])[3];
      return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $p, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Can't extend patterns", c0$Core$Nil$0));
    }))()
    : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Nothing"))
      ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), c0$Compiler$CanonicalAst$Partial$0)
      : ((($maybeMaybeExt)[0] === "$Nothing")
        ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), c0$Compiler$CanonicalAst$Complete$0)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 383:4', (sp_toHuman)($maybeMaybeExt))))));
});

const u0$Compiler$MakeCanonical$translatePatternRecord$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translatePatternRecord$1,
});

const u0$Compiler$MakeCanonical$translateRawPattern$14 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateRawPattern$13 = (($env, $maybeModule, $name, $pos, $caPars) => {
  return (u0$Compiler$MakeCanonical$translatePatternConstructor$0.usr)(...(u0$Compiler$MakeCanonical$translatePatternConstructor$0.ctx), $env, $pos, $maybeModule, $name, $caPars);
});

const u0$Compiler$MakeCanonical$translateRawPattern$12 = (($env, $1) => {
  const $hasDots = $1.first;
  const $expr = $1.second;
  return (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $expr);
});

const u0$Compiler$MakeCanonical$translateRawPattern$11 = (($pushItem, $reversedCaRest, $caInit) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $caInit, $reversedCaRest, $pushItem));
});

const u0$Compiler$MakeCanonical$translateRawPattern$10 = (($env, $lastFaExpr, $p, $pos, $pushItem, $reversedCaRest) => {
  return ((($lastFaExpr)[0] === "$Lowercase")
    ? ((() => {
      const $attrPath = ($lastFaExpr)[1].attrPath;
      const $maybeModule = ($lastFaExpr)[1].maybeModule;
      const $maybeType = ($lastFaExpr)[1].maybeType;
      const $name = ($lastFaExpr)[1].name;
      return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $pushItem,
          $reversedCaRest,
        ]),
        usr: u0$Compiler$MakeCanonical$translateRawPattern$11,
      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $pushItem,
          $reversedCaRest,
        ]),
        usr: u0$Compiler$MakeCanonical$translateRawPattern$11,
      })).ctx), (u0$Compiler$MakeCanonical$translatePatternAny$0.usr)(...(u0$Compiler$MakeCanonical$translatePatternAny$0.ctx), $env, $pos, $maybeType, $maybeModule, $name, $attrPath));
    }))()
    : (true
      ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $p, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "sorry, I don't understand the dots here...", c0$Core$Nil$0))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 488:24', (sp_toHuman)($lastFaExpr))));
});

const u0$Compiler$MakeCanonical$translateRawPattern$9 = (($env, $1) => {
  const $hasDots = $1.first;
  const $expr = $1.second;
  return (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $expr);
});

const u0$Compiler$MakeCanonical$translateRawPattern$8 = (($p, $pushItem, $reversedCaItems) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Compiler$CanonicalAst$PatternConstructor$0.usr)(...(c0$Compiler$CanonicalAst$PatternConstructor$0.ctx), $p, u0$Compiler$CoreDefs$nilUsr$0, c0$Core$Nil$0), $reversedCaItems, $pushItem));
});

const u0$Compiler$MakeCanonical$translateRawPattern$7 = (($pattern, $last) => {
  return (c0$Compiler$CanonicalAst$PatternConstructor$0.usr)(...(c0$Compiler$CanonicalAst$PatternConstructor$0.ctx), (c0$Compiler$CanonicalAst$patternPos$0.usr)(...(c0$Compiler$CanonicalAst$patternPos$0.ctx), $pattern), u0$Compiler$CoreDefs$consUsr$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $pattern, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $last, c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical$translateRawPattern$6 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateRawPattern$5 = (($pos, $item, $list) => {
  return (c0$Compiler$CanonicalAst$PatternConstructor$0.usr)(...(c0$Compiler$CanonicalAst$PatternConstructor$0.ctx), $pos, u0$Compiler$CoreDefs$consUsr$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $item, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $list, c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical$translateRawPattern$4 = (($env, $pos, $caPas) => {
  const $2 = (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $caPas);
  return ((($2)[0] === "$Cons")
    ? ((() => {
      const $last = ($2)[1];
      const $rest = ($2)[2];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $last, $rest, ({
        ctx: ([
          $pos,
        ]),
        usr: u0$Compiler$MakeCanonical$translateRawPattern$5,
      })));
    }))()
    : ((($2)[0] === "$Nil")
      ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "should not happen: empty cons pattern", c0$Core$Nil$0))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 512:16', (sp_toHuman)($2))));
});

const u0$Compiler$MakeCanonical$translateRawPattern$3 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateRawPattern$2 = (($pos, $recordAttrs) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$PatternRecord$0.usr)(...(c0$Compiler$CanonicalAst$PatternRecord$0.ctx), $pos, c0$Compiler$CanonicalAst$Complete$0, $recordAttrs));
});

const u0$Compiler$MakeCanonical$translateRawPattern$1 = (($env, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$Constructor")
    ? ((() => {
      const $maybeModule = ($expr_)[1].maybeModule;
      const $name = ($expr_)[1].name;
      return (u0$Compiler$MakeCanonical$translatePatternConstructor$0.usr)(...(u0$Compiler$MakeCanonical$translatePatternConstructor$0.ctx), $env, $pos, $maybeModule, $name, c0$Core$Nil$0);
    }))()
    : ((($expr_)[0] === "$Lowercase")
      ? ((() => {
        const $attrPath = ($expr_)[1].attrPath;
        const $maybeModule = ($expr_)[1].maybeModule;
        const $maybeType = ($expr_)[1].maybeType;
        const $name = ($expr_)[1].name;
        return (u0$Compiler$MakeCanonical$translatePatternAny$0.usr)(...(u0$Compiler$MakeCanonical$translatePatternAny$0.ctx), $env, $pos, $maybeType, $maybeModule, $name, $attrPath);
      }))()
      : (((($expr_)[0] === "$Call") && ((($expr_)[1])[0] === "$Expression"))
        ? ((() => {
          const $p = (($expr_)[1])[2];
          const $ref = (($expr_)[1])[3];
          const $faArgs = ($expr_)[2];
          return ((($ref)[0] === "$Constructor")
            ? ((() => {
              const $maybeModule = ($ref)[1].maybeModule;
              const $name = ($ref)[1].name;
              return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $env,
                  $maybeModule,
                  $name,
                  $pos,
                ]),
                usr: u0$Compiler$MakeCanonical$translateRawPattern$13,
              })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $env,
                  $maybeModule,
                  $name,
                  $pos,
                ]),
                usr: u0$Compiler$MakeCanonical$translateRawPattern$13,
              })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                ctx: ([
                  $env,
                ]),
                usr: u0$Compiler$MakeCanonical$translateRawPattern$14,
              }), $faArgs));
            }))()
            : (true
              ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $p, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need 'constructor name here", c0$Core$Nil$0))
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 452:12', (sp_toHuman)($ref))));
        }))()
        : ((($expr_)[0] === "$List")
          ? ((() => {
            const $faItems = ($expr_)[2];
            const $reversedFaItems = (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $faItems);
            const $pushItem = ({
              ctx: [],
              usr: u0$Compiler$MakeCanonical$translateRawPattern$7,
            });
            return ((($reversedFaItems)[0] === "$Nil")
              ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$PatternConstructor$0.usr)(...(c0$Compiler$CanonicalAst$PatternConstructor$0.ctx), $pos, u0$Compiler$CoreDefs$nilUsr$0, c0$Core$Nil$0))
              : (((($reversedFaItems)[0] === "$Cons") && ((($reversedFaItems)[1].second)[0] === "$Expression"))
                ? ((() => {
                  const $lastHasDots = ($reversedFaItems)[1].first;
                  const $p = (($reversedFaItems)[1].second)[2];
                  const $lastFaExpr = (($reversedFaItems)[1].second)[3];
                  const $reversedFaRest = ($reversedFaItems)[2];
                  return ((c0$List$any$0.usr)(...(c0$List$any$0.ctx), c0$Tuple$first$0, $reversedFaRest)
                    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $p, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "only the last item in a list can have ... triple dots", c0$Core$Nil$0))
                    : ((c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), $lastHasDots)
                      ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                        ctx: ([
                          $p,
                          $pushItem,
                        ]),
                        usr: u0$Compiler$MakeCanonical$translateRawPattern$8,
                      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                        ctx: ([
                          $p,
                          $pushItem,
                        ]),
                        usr: u0$Compiler$MakeCanonical$translateRawPattern$8,
                      })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                        ctx: ([
                          $env,
                        ]),
                        usr: u0$Compiler$MakeCanonical$translateRawPattern$9,
                      }), $reversedFaItems))
                      : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                        ctx: ([
                          $env,
                          $lastFaExpr,
                          $p,
                          $pos,
                          $pushItem,
                        ]),
                        usr: u0$Compiler$MakeCanonical$translateRawPattern$10,
                      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                        ctx: ([
                          $env,
                          $lastFaExpr,
                          $p,
                          $pos,
                          $pushItem,
                        ]),
                        usr: u0$Compiler$MakeCanonical$translateRawPattern$10,
                      })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                        ctx: ([
                          $env,
                        ]),
                        usr: u0$Compiler$MakeCanonical$translateRawPattern$12,
                      }), $reversedFaRest))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 471:12', (sp_toHuman)($reversedFaItems))));
          }))()
          : ((($expr_)[0] === "$Record")
            ? ((() => {
              const $attrs = ($expr_)[1].attrs;
              const $maybeExtension = ($expr_)[1].maybeExtension;
              return (u0$Compiler$MakeCanonical$translatePatternRecord$0.usr)(...(u0$Compiler$MakeCanonical$translatePatternRecord$0.ctx), $env, $pos, $maybeExtension, $attrs);
            }))()
            : ((($expr_)[0] === "$BinopChain")
              ? ((() => {
                const $precedence = ($expr_)[1];
                const $chain = ($expr_)[2];
                return ((sp_equal)($precedence, c0$Compiler$Op$precedence_tuple$0)
                  ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                    ctx: ([
                      $pos,
                    ]),
                    usr: u0$Compiler$MakeCanonical$translateRawPattern$2,
                  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                    ctx: ([
                      $pos,
                    ]),
                    usr: u0$Compiler$MakeCanonical$translateRawPattern$2,
                  })).ctx), (u0$Compiler$MakeCanonical$translateTuple$0.usr)(...(u0$Compiler$MakeCanonical$translateTuple$0.ctx), $env.ro, ({
                    ctx: ([
                      $env,
                    ]),
                    usr: u0$Compiler$MakeCanonical$translateRawPattern$3,
                  }), $chain))
                  : ((sp_equal)($precedence, c0$Compiler$Op$precedence_cons$0)
                    ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                      ctx: ([
                        $env,
                        $pos,
                      ]),
                      usr: u0$Compiler$MakeCanonical$translateRawPattern$4,
                    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                      ctx: ([
                        $env,
                        $pos,
                      ]),
                      usr: u0$Compiler$MakeCanonical$translateRawPattern$4,
                    })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                      ctx: ([
                        $env,
                      ]),
                      usr: u0$Compiler$MakeCanonical$translateRawPattern$6,
                    }), (c0$Compiler$FormattableAst$binopChainExpressions$0.usr)(...(c0$Compiler$FormattableAst$binopChainExpressions$0.ctx), $chain)))
                    : (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "This binop can't be used in pattern matching", c0$Core$Nil$0))));
              }))()
              : ((($expr_)[0] === "$LiteralText")
                ? ((() => {
                  const $singleOrTriple = ($expr_)[1];
                  const $l = ($expr_)[2];
                  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$PatternLiteralText$0.usr)(...(c0$Compiler$CanonicalAst$PatternLiteralText$0.ctx), $pos, (u0$Compiler$MakeCanonical$escapeLiteralText$0.usr)(...(u0$Compiler$MakeCanonical$escapeLiteralText$0.ctx), $singleOrTriple, $l)));
                }))()
                : ((($expr_)[0] === "$LiteralNumber")
                  ? ((() => {
                    const $isPercent = ($expr_)[1];
                    const $l = ($expr_)[2];
                    return (u0$Compiler$MakeCanonical$translateNumber$0.usr)(...(u0$Compiler$MakeCanonical$translateNumber$0.ctx), $env.ro, $isPercent, c0$Compiler$CanonicalAst$PatternLiteralNumber$0, $pos, $l);
                  }))()
                  : ((($expr_)[0] === "$Uppercase")
                    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "WUT", c0$Core$Nil$0))
                    : ((($expr_)[0] === "$Statements")
                      ? ((() => {
                        const $stats = ($expr_)[1];
                        return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "WAT", c0$Core$Nil$0));
                      }))()
                      : ((($expr_)[0] === "$Fn")
                        ? ((() => {
                          const $args = ($expr_)[2];
                          const $body = ($expr_)[3];
                          return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Can't pattern match on functions. =(", c0$Core$Nil$0));
                        }))()
                        : ((($expr_)[0] === "$UnopCall")
                          ? ((() => {
                            const $unop = ($expr_)[1];
                            const $expr = ($expr_)[2];
                            return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "This op can't be used in pattern matching", c0$Core$Nil$0));
                          }))()
                          : ((($expr_)[0] === "$If")
                            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "if..then can't be used in pattern matching", c0$Core$Nil$0))
                            : ((($expr_)[0] === "$Try")
                              ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "try..as can't be used in pattern matching", c0$Core$Nil$0))
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 443:4', (sp_toHuman)($expr_))))))))))))))));
});

const u0$Compiler$MakeCanonical$translateRawPattern$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateRawPattern$1,
});

const u0$Compiler$MakeCanonical$translateFullPattern$3 = (($uni, $caPa) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: $uni,
    second: $caPa,
  }));
});

const u0$Compiler$MakeCanonical$translateFullPattern$2 = (($env, $1) => {
  const $uni = $1.first;
  const $e = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullPattern$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullPattern$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateRawPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateRawPattern$0.ctx), $env, $e));
});

const u0$Compiler$MakeCanonical$translateFullPattern$1 = (($env, $expr) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullPattern$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateFullPattern$2,
  })).ctx), (u0$Compiler$MakeCanonical$translatePoly$0.usr)(...(u0$Compiler$MakeCanonical$translatePoly$0.ctx), $env.ro, $expr));
});

const u0$Compiler$MakeCanonical$translateFullPattern$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateFullPattern$1,
});

const u0$Compiler$MakeCanonical$translateLowercase$3 = (($pos, $0, $1) => {
  return (c0$Compiler$CanonicalAst$RecordAccess$0.usr)(...(c0$Compiler$CanonicalAst$RecordAccess$0.ctx), $pos, $0, $1);
});

const u0$Compiler$MakeCanonical$translateLowercase$2 = (($attrPath, $pos, $ref) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $pos, $ref), $attrPath, ({
    ctx: ([
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLowercase$3,
  })));
});

const u0$Compiler$MakeCanonical$translateLowercase$1 = (($env, $pos, $1) => {
  const $attrPath = $1.attrPath;
  const $maybeModule = $1.maybeModule;
  const $maybeType = $1.maybeType;
  const $name = $1.name;
  return ((sp_not_equal)($maybeType, c0$Maybe$Nothing$0)
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "no annotations on var reference", c0$Core$Nil$0))
    : ((() => {
      const $isLocal = ((sp_equal)($maybeModule, c0$Maybe$Nothing$0) && ((() => {
        const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $env.values);
        return ((($4)[0] === "$Nothing")
          ? false
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $paName = ($4)[1];
              return (c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), $paName.isRoot);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 921:16', (sp_toHuman)($4))));
      }))());
      return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $attrPath,
          $pos,
        ]),
        usr: u0$Compiler$MakeCanonical$translateLowercase$2,
      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $attrPath,
          $pos,
        ]),
        usr: u0$Compiler$MakeCanonical$translateLowercase$2,
      })).ctx), ($isLocal
        ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name))
        : (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), c0$Compiler$Ast$RefGlobal$0, ($env.ro.resolveToUsr.usr)(...($env.ro.resolveToUsr.ctx), $pos, $maybeModule, $name))));
    }))());
});

const u0$Compiler$MakeCanonical$translateLowercase$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateLowercase$1,
});

const u0$Compiler$MakeCanonical$translateParameter$2 = (($1) => {
  const $uni = $1.first;
  const $ca = $1.second;
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$ParameterPattern$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPattern$0.ctx), $uni, $ca));
});

const u0$Compiler$MakeCanonical$translateParameter$1 = (($env, $fa) => {
  const $3 = $fa;
  const $faExpr = ($3)[3];
  const $pos = ($3)[2];
  return (((($faExpr)[0] === "$UnopCall") && (((($faExpr)[1])[0] === "$UnopRecycle") && ((($faExpr)[2])[0] === "$Expression")))
    ? ((() => {
      const $p = (($faExpr)[2])[2];
      const $faOperand = (($faExpr)[2])[3];
      return (((($faOperand)[0] === "$Lowercase") && ((($faOperand)[1].maybeType)[0] === "$Nothing"))
        ? ((() => {
          const $attrPath = ($faOperand)[1].attrPath;
          const $maybeModule = ($faOperand)[1].maybeModule;
          const $name = ($faOperand)[1].name;
          return (((sp_not_equal)($maybeModule, c0$Maybe$Nothing$0) || (sp_not_equal)($attrPath, c0$Core$Nil$0))
            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need a lowercase local variable name here... =|", c0$Core$Nil$0))
            : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$ParameterRecycle$0.usr)(...(c0$Compiler$CanonicalAst$ParameterRecycle$0.ctx), $pos, $name)));
        }))()
        : (true
          ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $p, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "@ should be followed by a variable name to recycle!", c0$Core$Nil$0))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 963:12', (sp_toHuman)($faOperand))));
    }))()
    : ((($faExpr)[0] === "$ResolvedArgumentPlaceholder")
      ? ((() => {
        const $n = ($faExpr)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), $n));
      }))()
      : (true
        ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: [],
          usr: u0$Compiler$MakeCanonical$translateParameter$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: [],
          usr: u0$Compiler$MakeCanonical$translateParameter$2,
        })).ctx), (u0$Compiler$MakeCanonical$translateFullPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateFullPattern$0.ctx), $env, $fa))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 960:4', (sp_toHuman)($faExpr)))));
});

const u0$Compiler$MakeCanonical$translateParameter$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateParameter$1,
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$3 = (($caAttrsAccum, $caName, $caExpr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $caName, $caExpr, $caAttrsAccum));
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$2 = (($attr, $caAttrsAccum, $env, $1) => {
  const $pos = $1.first;
  const $caName = $1.second;
  const $maybeFaType = $1.third;
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $caName, $caAttrsAccum)
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("duplicate attribute: " + $caName), c0$Core$Nil$0))
    : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $caAttrsAccum,
        $caName,
      ]),
      usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$3,
    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $caAttrsAccum,
        $caName,
      ]),
      usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$3,
    })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), $attr.name, $attr.maybeExpr))));
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$1 = (($env, $attr, $caAttrsAccum) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attr,
      $caAttrsAccum,
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attr,
      $caAttrsAccum,
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$2,
  })).ctx), (u0$Compiler$MakeCanonical$translateAttributeName$0.usr)(...(u0$Compiler$MakeCanonical$translateAttributeName$0.ctx), $env.ro, $attr.name));
});

const u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$1,
});

const u0$Compiler$MakeCanonical$translateRecord$6 = (($env, $0, $1) => {
  return (u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$0.usr)(...(u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      maybeShorthandTarget: c0$Maybe$Nothing$0,
    }));
  }))(), $0, $1);
});

const u0$Compiler$MakeCanonical$translateRecord$5 = (($pos, $caAttrs) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), $pos, c0$Maybe$Nothing$0, $caAttrs));
});

const u0$Compiler$MakeCanonical$translateRecord$4 = (($newEnv, $0, $1) => {
  return (u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$0.usr)(...(u0$Compiler$MakeCanonical$translateAndInsertRecordAttribute$0.ctx), $newEnv, $0, $1);
});

const u0$Compiler$MakeCanonical$translateRecord$3 = (($caExt, $pos, $var, $varName, $caAttrs) => {
  const $def = ({
    body: $caExt,
    pattern: (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), c0$Compiler$Pos$G$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $varName), c0$Maybe$Nothing$0),
    uni: c0$Compiler$Ast$Imm$0,
  });
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$LetIn$0.usr)(...(c0$Compiler$CanonicalAst$LetIn$0.ctx), $def, (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $var), $caAttrs)));
});

const u0$Compiler$MakeCanonical$translateRecord$2 = (($attrs, $env, $pos, $maybeCaExt) => {
  return ((($maybeCaExt)[0] === "$Nothing")
    ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $pos,
      ]),
      usr: u0$Compiler$MakeCanonical$translateRecord$5,
    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $pos,
      ]),
      usr: u0$Compiler$MakeCanonical$translateRecord$5,
    })).ctx), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), c0$Dict$empty$0, $attrs, ({
      ctx: ([
        $env,
      ]),
      usr: u0$Compiler$MakeCanonical$translateRecord$6,
    })))
    : ((($maybeCaExt)[0] === "$Just")
      ? ((() => {
        const $caExt = ($maybeCaExt)[1];
        const $varName = (text_fromNumber)($env.nextGeneratedVariableName);
        const $var = (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), c0$Compiler$Pos$G$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $varName));
        const $newEnv = ((() => {
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            maybeShorthandTarget: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $var),
            nextGeneratedVariableName: ($0.nextGeneratedVariableName + 1),
          }));
        }))();
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $caExt,
            $pos,
            $var,
            $varName,
          ]),
          usr: u0$Compiler$MakeCanonical$translateRecord$3,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $caExt,
            $pos,
            $var,
            $varName,
          ]),
          usr: u0$Compiler$MakeCanonical$translateRecord$3,
        })).ctx), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), c0$Dict$empty$0, $attrs, ({
          ctx: ([
            $newEnv,
          ]),
          usr: u0$Compiler$MakeCanonical$translateRecord$4,
        })));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1010:4', (sp_toHuman)($maybeCaExt))));
});

const u0$Compiler$MakeCanonical$translateRecord$1 = (($env, $pos, $maybeMaybeExtension, $attrs) => {
  const $zzz = (((($maybeMaybeExtension)[0] === "$Just") && ((($maybeMaybeExtension)[1])[0] === "$Just"))
    ? ((() => {
      const $ext = (($maybeMaybeExtension)[1])[1];
      return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), c0$Maybe$Just$0, (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $ext));
    }))()
    : (((($maybeMaybeExtension)[0] === "$Just") && ((($maybeMaybeExtension)[1])[0] === "$Nothing"))
      ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need to know what record you are updating", c0$Core$Nil$0))
      : ((($maybeMaybeExtension)[0] === "$Nothing")
        ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), c0$Maybe$Nothing$0)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1003:8', (sp_toHuman)($maybeMaybeExtension)))));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attrs,
      $env,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRecord$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $attrs,
      $env,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRecord$2,
  })).ctx), $zzz);
});

const u0$Compiler$MakeCanonical$translateRecord$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateRecord$1,
});

const u0$Compiler$MakeCanonical$translateRecordShorthand$2 = (($pos, $attrName, $expr) => {
  return (c0$Compiler$CanonicalAst$RecordAccess$0.usr)(...(c0$Compiler$CanonicalAst$RecordAccess$0.ctx), $pos, $attrName, $expr);
});

const u0$Compiler$MakeCanonical$translateRecordShorthand$1 = (($env, $pos, $attrPath, $name) => {
  const $5 = $env.maybeShorthandTarget;
  return ((($5)[0] === "$Nothing")
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Record update shorthands must be used inside a record update such as", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("    { aRecord with anAttribute = doSomethingWith ." + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ".", $attrPath)) + " }"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "but we are not inside a record update!", c0$Core$Nil$0))))
    : ((($5)[0] === "$Just")
      ? ((() => {
        const $shorthandTarget = ($5)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $shorthandTarget, (sp_cons)($name, $attrPath), ({
          ctx: ([
            $pos,
          ]),
          usr: u0$Compiler$MakeCanonical$translateRecordShorthand$2,
        })));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 937:8', (sp_toHuman)($5))));
});

const u0$Compiler$MakeCanonical$translateRecordShorthand$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateRecordShorthand$1,
});

const u0$Compiler$MakeCanonical$translateLocalDefinition$5 = (($localEnv, $pattern, $uni, $body) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: $localEnv,
    second: ({
      body: $body,
      pattern: $pattern,
      uni: $uni,
    }),
  }));
});

const u0$Compiler$MakeCanonical$translateLocalDefinition$4 = (($fa, $pattern, $uni, $localEnv) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $localEnv,
      $pattern,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $localEnv,
      $pattern,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$5,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $localEnv, $fa.body));
});

const u0$Compiler$MakeCanonical$translateLocalDefinition$3 = (($env, $fa, $1) => {
  const $uni = $1.first;
  const $pattern = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $fa,
      $pattern,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $fa,
      $pattern,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$4,
  })).ctx), (u0$Compiler$MakeCanonical$insertPatternNames$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternNames$0.ctx), false, $pattern, $env));
});

const u0$Compiler$MakeCanonical$translateLocalDefinition$2 = (($1) => {
  const $pos = $1.first;
  const $name = $1.second;
  return ({
    first: $name,
    second: $pos,
  });
});

const u0$Compiler$MakeCanonical$translateLocalDefinition$1 = (($env, $fa) => {
  const $nonFn = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$2,
  }), $fa.nonFn));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
    ]),
    usr: u0$Compiler$MakeCanonical$translateLocalDefinition$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateFullPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateFullPattern$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      nonFn: $nonFn,
    }));
  }))(), $fa.pattern));
});

const u0$Compiler$MakeCanonical$translateLocalDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateLocalDefinition$1,
});

const u0$Compiler$MakeCanonical$translateStatements$5 = (($caDef, $acc) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$LetIn$0.usr)(...(c0$Compiler$CanonicalAst$LetIn$0.ctx), $caDef, $acc));
});

const u0$Compiler$MakeCanonical$translateStatements$4 = (($env, $tail, $caExpr) => {
  const $caDef = ({
    body: $caExpr,
    pattern: (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), c0$Compiler$Pos$G$0, c0$Maybe$Nothing$0, c0$Maybe$Nothing$0),
    uni: c0$Compiler$Ast$Imm$0,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caDef,
    ]),
    usr: u0$Compiler$MakeCanonical$translateStatements$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caDef,
    ]),
    usr: u0$Compiler$MakeCanonical$translateStatements$5,
  })).ctx), (u0$Compiler$MakeCanonical$translateStatements$0.usr)(...(u0$Compiler$MakeCanonical$translateStatements$0.ctx), $env, $tail));
});

const u0$Compiler$MakeCanonical$translateStatements$3 = (($caDef, $acc) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$LetIn$0.usr)(...(c0$Compiler$CanonicalAst$LetIn$0.ctx), $caDef, $acc));
});

const u0$Compiler$MakeCanonical$translateStatements$2 = (($tail, $1) => {
  const $newEnv = $1.first;
  const $caDef = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caDef,
    ]),
    usr: u0$Compiler$MakeCanonical$translateStatements$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caDef,
    ]),
    usr: u0$Compiler$MakeCanonical$translateStatements$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateStatements$0.usr)(...(u0$Compiler$MakeCanonical$translateStatements$0.ctx), $newEnv, $tail));
});

const u0$Compiler$MakeCanonical$translateStatements$1 = (($env, $stats) => {
  return ((($stats)[0] === "$Nil")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Constructor$0.usr)(...(c0$Compiler$CanonicalAst$Constructor$0.ctx), c0$Compiler$Pos$G$0, u0$Compiler$CoreDefs$noneConsUsr$0))
    : (((($stats)[0] === "$Cons") && (((($stats)[1])[0] === "$Evaluation") && ((($stats)[2])[0] === "$Nil")))
      ? ((() => {
        const $faExpression = (($stats)[1])[1];
        return (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faExpression);
      }))()
      : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$CommentStatement"))
        ? ((() => {
          const $tail = ($stats)[2];
          return (u0$Compiler$MakeCanonical$translateStatements$0.usr)(...(u0$Compiler$MakeCanonical$translateStatements$0.ctx), $env, $tail);
        }))()
        : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$Evaluation"))
          ? ((() => {
            const $faExpr = (($stats)[1])[1];
            const $tail = ($stats)[2];
            return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
              ctx: ([
                $env,
                $tail,
              ]),
              usr: u0$Compiler$MakeCanonical$translateStatements$4,
            })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
              ctx: ([
                $env,
                $tail,
              ]),
              usr: u0$Compiler$MakeCanonical$translateStatements$4,
            })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faExpr));
          }))()
          : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$ValueDef"))
            ? ((() => {
              const $fa = (($stats)[1])[1];
              const $tail = ($stats)[2];
              return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $tail,
                ]),
                usr: u0$Compiler$MakeCanonical$translateStatements$2,
              })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                ctx: ([
                  $tail,
                ]),
                usr: u0$Compiler$MakeCanonical$translateStatements$2,
              })).ctx), (u0$Compiler$MakeCanonical$translateLocalDefinition$0.usr)(...(u0$Compiler$MakeCanonical$translateLocalDefinition$0.ctx), $env, $fa));
            }))()
            : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$AliasDef"))
              ? ((() => {
                const $fa = (($stats)[1])[1];
                const $tail = ($stats)[2];
                return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $fa.name.first, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Aliases can be declared only in the root scope", c0$Core$Nil$0));
              }))()
              : (((($stats)[0] === "$Cons") && ((($stats)[1])[0] === "$UnionDef"))
                ? ((() => {
                  const $fa = (($stats)[1])[1];
                  const $tail = ($stats)[2];
                  return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $fa.name.first, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Types can be declared only in the root scope", c0$Core$Nil$0));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 572:4', (sp_toHuman)($stats)))))))));
});

const u0$Compiler$MakeCanonical$translateStatements$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateStatements$1,
});

const u0$Compiler$MakeCanonical$translateExpression$25 = (($pos, $usr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Constructor$0.usr)(...(c0$Compiler$CanonicalAst$Constructor$0.ctx), $pos, $usr));
});

const u0$Compiler$MakeCanonical$translateExpression$24 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateParameter$0.usr)(...(u0$Compiler$MakeCanonical$translateParameter$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateExpression$23 = (($pos, $par, $envX) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $uni = ($par)[1];
      const $pa = ($par)[2];
      return (u0$Compiler$MakeCanonical$insertPatternNames$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternNames$0.ctx), false, $pa, $envX);
    }))()
    : ((($par)[0] === "$ParameterRecycle")
      ? ((() => {
        const $p = ($par)[1];
        const $name = ($par)[2];
        return (u0$Compiler$MakeCanonical$insertPatternNames$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternNames$0.ctx), false, (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name), c0$Maybe$Nothing$0), $envX);
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? ((() => {
          const $n = ($par)[1];
          return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ((() => {
            const $0 = $envX;
            return (Object.assign)({}, $0, ({
              values: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (text_fromNumber)($n), ({
                isRoot: false,
                pos: $pos,
              }), $0.values),
            }));
          }))());
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 653:16', (sp_toHuman)($par)))));
});

const u0$Compiler$MakeCanonical$translateExpression$22 = (($caParams, $pos, $caBody) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), $pos, $caParams, $caBody));
});

const u0$Compiler$MakeCanonical$translateExpression$21 = (($caParams, $faBody, $pos, $localEnv) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caParams,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$22,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caParams,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$22,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $localEnv, $faBody));
});

const u0$Compiler$MakeCanonical$translateExpression$20 = (($env, $faBody, $pos, $caParams) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caParams,
      $faBody,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$21,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caParams,
      $faBody,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$21,
  })).ctx), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), $env, $caParams, ({
    ctx: ([
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$23,
  })));
});

const u0$Compiler$MakeCanonical$translateExpression$19 = (($env, $0) => {
  return (u0$Compiler$MakeCanonical$translateArgument$0.usr)(...(u0$Compiler$MakeCanonical$translateArgument$0.ctx), $env, $0);
});

const u0$Compiler$MakeCanonical$translateExpression$18 = (($caRef, $pos, $caArgs) => {
  const $2 = (u0$Compiler$MakeCanonical$maybeInlinePlaceholders$0.usr)(...(u0$Compiler$MakeCanonical$maybeInlinePlaceholders$0.ctx), $caRef, $caArgs);
  return ((($2)[0] === "$Just")
    ? ((() => {
      const $call = ($2)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $call);
    }))()
    : (true
      ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, $caRef, $caArgs))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 703:16', (sp_toHuman)($2))));
});

const u0$Compiler$MakeCanonical$translateExpression$17 = (($env, $faArgs, $pos, $caRef) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caRef,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$18,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caRef,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$18,
  })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$19,
  }), $faArgs));
});

const u0$Compiler$MakeCanonical$translateExpression$16 = (($exp, $1) => {
  const $cnt = $1.first;
  const $rev = $1.second;
  return ((u0$Compiler$MakeCanonical$isPlaceholder$0.usr)(...(u0$Compiler$MakeCanonical$isPlaceholder$0.ctx), $exp)
    ? ((() => {
      const $3 = $exp;
      const $p = ($3)[2];
      const $c = ($3)[1];
      return ({
        first: ($cnt + 1),
        second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), $c, $p, (c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.usr)(...(c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.ctx), $cnt)), $rev),
      });
    }))()
    : ({
      first: $cnt,
      second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $exp, $rev),
    }));
});

const u0$Compiler$MakeCanonical$translateExpression$15 = (($c, $pos, $t, $f) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$If$0.usr)(...(c0$Compiler$CanonicalAst$If$0.ctx), $pos, ({
    condition: $c,
    false: $f,
    true: $t,
  })));
});

const u0$Compiler$MakeCanonical$translateExpression$14 = (($c, $env, $false, $pos, $t) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $c,
      $pos,
      $t,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$15,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $c,
      $pos,
      $t,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$15,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $false));
});

const u0$Compiler$MakeCanonical$translateExpression$13 = (($env, $false, $pos, $true, $c) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $c,
      $env,
      $false,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$14,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $c,
      $env,
      $false,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$14,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $true));
});

const u0$Compiler$MakeCanonical$translateExpression$12 = (($pos, $caOperand) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), u0$Compiler$CoreDefs$unaryMinus$0.usr)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), $caOperand), c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical$translateExpression$11 = (($acc, $pos, $caItem) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), $pos, (c0$Compiler$CanonicalAst$Constructor$0.usr)(...(c0$Compiler$CanonicalAst$Constructor$0.ctx), $pos, u0$Compiler$CoreDefs$consUsr$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), $caItem), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), $acc), c0$Core$Nil$0))));
});

const u0$Compiler$MakeCanonical$translateExpression$10 = (($env, $pos, $2, $acc) => {
  const $faItem = $2.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $acc,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$11,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $acc,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$11,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faItem));
});

const u0$Compiler$MakeCanonical$translateExpression$9 = (($env, $pos, $revItems, $caInit) => {
  return (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), $caInit, $revItems, ({
    ctx: ([
      $env,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$10,
  }));
});

const u0$Compiler$MakeCanonical$translateExpression$8 = (($caValue, $pos, $patternsAndExpressions) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Try$0.usr)(...(c0$Compiler$CanonicalAst$Try$0.ctx), $pos, ({
    patternsAndExpressions: $patternsAndExpressions,
    value: $caValue,
  })));
});

const u0$Compiler$MakeCanonical$translateExpression$7 = (($patterns, $pos, $translatePatternAndStatements, $caValue) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caValue,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$8,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caValue,
      $pos,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$8,
  })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), $translatePatternAndStatements, $patterns));
});

const u0$Compiler$MakeCanonical$translateExpression$6 = (($caPattern, $uni, $block) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: $uni,
    second: $caPattern,
    third: $block,
  }));
});

const u0$Compiler$MakeCanonical$translateExpression$5 = (($caPattern, $faExpression, $uni, $localEnv) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caPattern,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$6,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caPattern,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$6,
  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $localEnv, $faExpression));
});

const u0$Compiler$MakeCanonical$translateExpression$4 = (($env, $faExpression, $1) => {
  const $uni = $1.first;
  const $caPattern = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caPattern,
      $faExpression,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $caPattern,
      $faExpression,
      $uni,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$5,
  })).ctx), (u0$Compiler$MakeCanonical$insertPatternNames$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternNames$0.ctx), false, $caPattern, $env));
});

const u0$Compiler$MakeCanonical$translateExpression$3 = (($env, $1) => {
  const $faPattern = $1.first;
  const $faExpression = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $faExpression,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $faExpression,
    ]),
    usr: u0$Compiler$MakeCanonical$translateExpression$4,
  })).ctx), (u0$Compiler$MakeCanonical$translateFullPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateFullPattern$0.ctx), $env, $faPattern));
});

const u0$Compiler$MakeCanonical$translateExpression$2 = (($introspect, $pos, $usr) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Introspect$0.usr)(...(c0$Compiler$CanonicalAst$Introspect$0.ctx), $pos, $introspect, $usr));
});

const u0$Compiler$MakeCanonical$translateExpression$1 = (($env, $1) => {
  const $pos = ($1)[2];
  const $expr_ = ($1)[3];
  return ((($expr_)[0] === "$LiteralNumber")
    ? ((() => {
      const $isPercent = ($expr_)[1];
      const $str = ($expr_)[2];
      return (u0$Compiler$MakeCanonical$translateNumber$0.usr)(...(u0$Compiler$MakeCanonical$translateNumber$0.ctx), $env.ro, $isPercent, c0$Compiler$CanonicalAst$LiteralNumber$0, $pos, $str);
    }))()
    : ((($expr_)[0] === "$LiteralText")
      ? ((() => {
        const $singleOrTriple = ($expr_)[1];
        const $l = ($expr_)[2];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$LiteralText$0.usr)(...(c0$Compiler$CanonicalAst$LiteralText$0.ctx), $pos, (u0$Compiler$MakeCanonical$escapeLiteralText$0.usr)(...(u0$Compiler$MakeCanonical$escapeLiteralText$0.ctx), $singleOrTriple, $l)));
      }))()
      : ((($expr_)[0] === "$Statements")
        ? ((() => {
          const $stats = ($expr_)[1];
          return (u0$Compiler$MakeCanonical$translateStatements$0.usr)(...(u0$Compiler$MakeCanonical$translateStatements$0.ctx), $env, $stats);
        }))()
        : ((($expr_)[0] === "$Lowercase")
          ? ((() => {
            const $pas = ($expr_)[1];
            return (u0$Compiler$MakeCanonical$translateLowercase$0.usr)(...(u0$Compiler$MakeCanonical$translateLowercase$0.ctx), $env, $pos, $pas);
          }))()
          : ((($expr_)[0] === "$Uppercase")
            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Can't reference a type or module here...?", c0$Core$Nil$0))
            : ((($expr_)[0] === "$Constructor")
              ? ((() => {
                const $maybeModule = ($expr_)[1].maybeModule;
                const $name = ($expr_)[1].name;
                return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $pos,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateExpression$25,
                })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $pos,
                  ]),
                  usr: u0$Compiler$MakeCanonical$translateExpression$25,
                })).ctx), ($env.ro.resolveToUsr.usr)(...($env.ro.resolveToUsr.ctx), $pos, $maybeModule, $name));
              }))()
              : ((($expr_)[0] === "$Fn")
                ? ((() => {
                  const $faParams = ($expr_)[2];
                  const $faBody = ($expr_)[3];
                  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                    ctx: ([
                      $env,
                      $faBody,
                      $pos,
                    ]),
                    usr: u0$Compiler$MakeCanonical$translateExpression$20,
                  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                    ctx: ([
                      $env,
                      $faBody,
                      $pos,
                    ]),
                    usr: u0$Compiler$MakeCanonical$translateExpression$20,
                  })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
                    ctx: ([
                      $env,
                    ]),
                    usr: u0$Compiler$MakeCanonical$translateExpression$24,
                  }), $faParams));
                }))()
                : ((($expr_)[0] === "$ResolvedArgumentPlaceholder")
                  ? ((() => {
                    const $n = ($expr_)[1];
                    return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), $pos, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), $n)));
                  }))()
                  : ((($expr_)[0] === "$Call")
                    ? ((() => {
                      const $faRef = ($expr_)[1];
                      const $faArgs = ($expr_)[2];
                      const $3 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
                        first: 0,
                        second: c0$Core$Nil$0,
                      }), $faArgs, ({
                        ctx: [],
                        usr: u0$Compiler$MakeCanonical$translateExpression$16,
                      }));
                      const $reversedArgs = $3.second;
                      const $placeholdersCount = $3.first;
                      return (($placeholdersCount > 0)
                        ? (u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0.usr)(...(u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0.ctx), $env, $pos, $placeholdersCount, (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), $faRef, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $reversedArgs)))
                        : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                          ctx: ([
                            $env,
                            $faArgs,
                            $pos,
                          ]),
                          usr: u0$Compiler$MakeCanonical$translateExpression$17,
                        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                          ctx: ([
                            $env,
                            $faArgs,
                            $pos,
                          ]),
                          usr: u0$Compiler$MakeCanonical$translateExpression$17,
                        })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faRef)));
                    }))()
                    : ((($expr_)[0] === "$If")
                      ? ((() => {
                        const $condition = ($expr_)[1].condition;
                        const $false = ($expr_)[1].false;
                        const $true = ($expr_)[1].true;
                        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                          ctx: ([
                            $env,
                            $false,
                            $pos,
                            $true,
                          ]),
                          usr: u0$Compiler$MakeCanonical$translateExpression$13,
                        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                          ctx: ([
                            $env,
                            $false,
                            $pos,
                            $true,
                          ]),
                          usr: u0$Compiler$MakeCanonical$translateExpression$13,
                        })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $condition));
                      }))()
                      : ((($expr_)[0] === "$UnopCall")
                        ? ((() => {
                          const $opId = ($expr_)[1];
                          const $faOperand = ($expr_)[2];
                          return ((($opId)[0] === "$UnopUnique")
                            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "can't use ! here because REASONS", c0$Core$Nil$0))
                            : ((($opId)[0] === "$UnopRecycle")
                              ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "can recycle only in function calls!", c0$Core$Nil$0))
                              : ((($opId)[0] === "$UnopPlus")
                                ? (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faOperand)
                                : ((($opId)[0] === "$UnopMinus")
                                  ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                    ctx: ([
                                      $pos,
                                    ]),
                                    usr: u0$Compiler$MakeCanonical$translateExpression$12,
                                  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                    ctx: ([
                                      $pos,
                                    ]),
                                    usr: u0$Compiler$MakeCanonical$translateExpression$12,
                                  })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $faOperand))
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 723:12', (sp_toHuman)($opId))))));
                        }))()
                        : ((($expr_)[0] === "$BinopChain")
                          ? ((() => {
                            const $group = ($expr_)[1];
                            const $chain = ($expr_)[2];
                            return (u0$Compiler$MakeCanonical$translateBinopChain$0.usr)(...(u0$Compiler$MakeCanonical$translateBinopChain$0.ctx), $env, $pos, $group, $chain);
                          }))()
                          : ((($expr_)[0] === "$Record")
                            ? ((() => {
                              const $attrs = ($expr_)[1].attrs;
                              const $maybeExtension = ($expr_)[1].maybeExtension;
                              return (u0$Compiler$MakeCanonical$translateRecord$0.usr)(...(u0$Compiler$MakeCanonical$translateRecord$0.ctx), $env, $pos, $maybeExtension, $attrs);
                            }))()
                            : ((($expr_)[0] === "$RecordShorthand")
                              ? ((() => {
                                const $attrPath = ($expr_)[1].attrPath;
                                const $name = ($expr_)[1].name;
                                return (u0$Compiler$MakeCanonical$translateRecordShorthand$0.usr)(...(u0$Compiler$MakeCanonical$translateRecordShorthand$0.ctx), $env, $pos, $attrPath, $name);
                              }))()
                              : ((($expr_)[0] === "$List")
                                ? ((() => {
                                  const $faDotsAndItems = ($expr_)[2];
                                  const $rev = (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $faDotsAndItems);
                                  return ((($rev)[0] === "$Nil")
                                    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$Compiler$CanonicalAst$Constructor$0.usr)(...(c0$Compiler$CanonicalAst$Constructor$0.ctx), $pos, u0$Compiler$CoreDefs$nilUsr$0))
                                    : ((($rev)[0] === "$Cons")
                                      ? ((() => {
                                        const $hasDots = ($rev)[1].first;
                                        const $head = ($rev)[1].second;
                                        const $rest = ($rev)[2];
                                        return ((c0$List$any$0.usr)(...(c0$List$any$0.ctx), c0$Tuple$first$0, $rest)
                                          ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "can use dots only on the last element (for now?)", c0$Core$Nil$0))
                                          : ((() => {
                                            const $3 = ($hasDots
                                              ? ({
                                                first: $head,
                                                second: $rest,
                                              })
                                              : ({
                                                first: (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $pos, (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), false, c0$Core$Nil$0)),
                                                second: $rev,
                                              }));
                                            const $revItems = $3.second;
                                            const $init = $3.first;
                                            return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                              ctx: ([
                                                $env,
                                                $pos,
                                                $revItems,
                                              ]),
                                              usr: u0$Compiler$MakeCanonical$translateExpression$9,
                                            })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                              ctx: ([
                                                $env,
                                                $pos,
                                                $revItems,
                                              ]),
                                              usr: u0$Compiler$MakeCanonical$translateExpression$9,
                                            })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $init));
                                          }))());
                                      }))()
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 753:12', (sp_toHuman)($rev))));
                                }))()
                                : ((($expr_)[0] === "$Try")
                                  ? ((() => {
                                    const $patterns = ($expr_)[1].patterns;
                                    const $value = ($expr_)[1].value;
                                    return ((u0$Compiler$MakeCanonical$isPlaceholder$0.usr)(...(u0$Compiler$MakeCanonical$isPlaceholder$0.ctx), $value)
                                      ? (u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0.usr)(...(u0$Compiler$MakeCanonical$makePartiallyAppliedFunction$0.ctx), $env, $pos, 1, (c0$Compiler$FormattableAst$Try$0.usr)(...(c0$Compiler$FormattableAst$Try$0.ctx), ({
                                        patterns: $patterns,
                                        value: (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $pos, (c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.usr)(...(c0$Compiler$FormattableAst$ResolvedArgumentPlaceholder$0.ctx), 0)),
                                      })))
                                      : ((() => {
                                        const $translatePatternAndStatements = ({
                                          ctx: ([
                                            $env,
                                          ]),
                                          usr: u0$Compiler$MakeCanonical$translateExpression$3,
                                        });
                                        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                          ctx: ([
                                            $patterns,
                                            $pos,
                                            $translatePatternAndStatements,
                                          ]),
                                          usr: u0$Compiler$MakeCanonical$translateExpression$7,
                                        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                          ctx: ([
                                            $patterns,
                                            $pos,
                                            $translatePatternAndStatements,
                                          ]),
                                          usr: u0$Compiler$MakeCanonical$translateExpression$7,
                                        })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $env, $value));
                                      }))());
                                  }))()
                                  : ((($expr_)[0] === "$Native")
                                    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "`this_is_sp_native` can be used only for root level value defs", c0$Core$Nil$0))
                                    : ((($expr_)[0] === "$Introspect")
                                      ? ((() => {
                                        const $introspect = ($expr_)[1];
                                        const $maybeModule = ($expr_)[2];
                                        const $name = ($expr_)[3];
                                        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                          ctx: ([
                                            $introspect,
                                            $pos,
                                          ]),
                                          usr: u0$Compiler$MakeCanonical$translateExpression$2,
                                        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                                          ctx: ([
                                            $introspect,
                                            $pos,
                                          ]),
                                          usr: u0$Compiler$MakeCanonical$translateExpression$2,
                                        })).ctx), ($env.ro.resolveToUsr.usr)(...($env.ro.resolveToUsr.ctx), $pos, $maybeModule, $name));
                                      }))()
                                      : (true
                                        ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "something's wrong here...", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($expr_), c0$Core$Nil$0)))
                                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 622:4', (sp_toHuman)($expr_)))))))))))))))))))));
});

const u0$Compiler$MakeCanonical$translateExpression$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateExpression$1,
});

const u0$Compiler$MakeCanonical$translateRootDefinition$8 = (($body) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $body),
    second: (u0$Compiler$MakeCanonical$expressionDeps$0.usr)(...(u0$Compiler$MakeCanonical$expressionDeps$0.ctx), $body, c0$Dict$empty$0),
  }));
});

const u0$Compiler$MakeCanonical$translateRootDefinition$7 = (($localEnv, $maybeAnnotation, $name, $namePos, $pattern, $1) => {
  const $maybeBody = $1.first;
  const $bodyDeps = $1.second;
  const $directDeps = (u0$Compiler$MakeCanonical$patternDeps$0.usr)(...(u0$Compiler$MakeCanonical$patternDeps$0.ctx), $pattern, $bodyDeps);
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: $localEnv,
    second: ({
      directDeps: $directDeps,
      maybeAnnotation: $maybeAnnotation,
      maybeBody: $maybeBody,
      name: $name,
      namePos: $namePos,
    }),
  }));
});

const u0$Compiler$MakeCanonical$translateRootDefinition$6 = (($fa, $maybeAnnotation, $name, $namePos, $pattern, $localEnv) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $localEnv,
      $maybeAnnotation,
      $name,
      $namePos,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$7,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $localEnv,
      $maybeAnnotation,
      $name,
      $namePos,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$7,
  })).ctx), ((() => {
    const $2 = $fa.body;
    return (((($2)[0] === "$Expression") && ((($2)[3])[0] === "$Native"))
      ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
        first: c0$Maybe$Nothing$0,
        second: c0$Dict$empty$0,
      }))
      : (true
        ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: [],
          usr: u0$Compiler$MakeCanonical$translateRootDefinition$8,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: [],
          usr: u0$Compiler$MakeCanonical$translateRootDefinition$8,
        })).ctx), (u0$Compiler$MakeCanonical$translateExpression$0.usr)(...(u0$Compiler$MakeCanonical$translateExpression$0.ctx), $localEnv, $fa.body))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 265:4', (sp_toHuman)($2))));
  }))());
});

const u0$Compiler$MakeCanonical$translateRootDefinition$5 = (($env, $fa, $pattern, $1) => {
  const $namePos = $1.first;
  const $name = $1.second;
  const $maybeAnnotation = $1.third;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $fa,
      $maybeAnnotation,
      $name,
      $namePos,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$6,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $fa,
      $maybeAnnotation,
      $name,
      $namePos,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$6,
  })).ctx), (u0$Compiler$MakeCanonical$insertPatternNames$0.usr)(...(u0$Compiler$MakeCanonical$insertPatternNames$0.ctx), true, $pattern, $env));
});

const u0$Compiler$MakeCanonical$translateRootDefinition$4 = (($env, $fa, $pattern, _0) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$5,
  })).ctx), (((($pattern)[0] === "$PatternAny") && ((($pattern)[2])[0] === "$Just"))
    ? ((() => {
      const $pos = ($pattern)[1];
      const $name = (($pattern)[2])[1];
      const $maybeAnnotation = ($pattern)[3];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
        first: $pos,
        second: $name,
        third: $maybeAnnotation,
      }));
    }))()
    : (true
      ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, (c0$Compiler$CanonicalAst$patternPos$0.usr)(...(c0$Compiler$CanonicalAst$patternPos$0.ctx), $pattern), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Root-level patterns are not (yet?) supported.", c0$Core$Nil$0))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 258:4', (sp_toHuman)($pattern)))));
});

const u0$Compiler$MakeCanonical$translateRootDefinition$3 = (($env, $fa, $1) => {
  const $uni = $1.first;
  const $pattern = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
      $pattern,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$4,
  })).ctx), ((sp_not_equal)($uni, c0$Compiler$Ast$Imm$0)
    ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, (c0$Compiler$CanonicalAst$patternPos$0.usr)(...(c0$Compiler$CanonicalAst$patternPos$0.ctx), $pattern), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Unique values can be declared only inside functions.", c0$Core$Nil$0))
    : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null)));
});

const u0$Compiler$MakeCanonical$translateRootDefinition$2 = (($1) => {
  const $pos = $1.first;
  const $name = $1.second;
  return ({
    first: $name,
    second: $pos,
  });
});

const u0$Compiler$MakeCanonical$translateRootDefinition$1 = (($env, $fa) => {
  const $nonFn = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$2,
  }), $fa.nonFn));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
      $fa,
    ]),
    usr: u0$Compiler$MakeCanonical$translateRootDefinition$3,
  })).ctx), (u0$Compiler$MakeCanonical$translateFullPattern$0.usr)(...(u0$Compiler$MakeCanonical$translateFullPattern$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      nonFn: $nonFn,
    }));
  }))(), $fa.pattern));
});

const u0$Compiler$MakeCanonical$translateRootDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateRootDefinition$1,
});

const u0$Compiler$MakeCanonical$insertRootStatement$8 = (($caModule, $1) => {
  const $newEnv = $1.first;
  const $def = $1.second;
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: ((() => {
      const $0 = $caModule;
      return (Object.assign)({}, $0, ({
        valueDefs: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $def.name, $def, $0.valueDefs),
      }));
    }))(),
    second: $newEnv,
  }));
});

const u0$Compiler$MakeCanonical$insertRootStatement$7 = (($1) => {
  const $p = $1.first;
  const $n = $1.second;
  return ({
    first: $n,
    second: $p,
  });
});

const u0$Compiler$MakeCanonical$insertRootStatement$6 = (($caModule, $env, $fa, $name, $type) => {
  const $aliasDef = ({
    directDeps: (u0$Compiler$MakeCanonical$typeDeps$0.usr)(...(u0$Compiler$MakeCanonical$typeDeps$0.ctx), $type, c0$Dict$empty$0),
    pars: (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
      ctx: [],
      usr: u0$Compiler$MakeCanonical$insertRootStatement$7,
    }), $fa.args),
    type: $type,
    usr: (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $env.ro.umr, $name),
  });
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: ((() => {
      const $0 = $caModule;
      return (Object.assign)({}, $0, ({
        aliasDefs: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $aliasDef, $0.aliasDefs),
      }));
    }))(),
    second: $env,
  }));
});

const u0$Compiler$MakeCanonical$insertRootStatement$5 = (($caPars, $type, $usr, $0, $1) => {
  return (u0$Compiler$MakeCanonical$translateConstructor$0.usr)(...(u0$Compiler$MakeCanonical$translateConstructor$0.ctx), $type, $usr, (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), $caPars), $0, $1);
});

const u0$Compiler$MakeCanonical$insertRootStatement$4 = (($caModule, $caPars, $name, $usr, $1) => {
  const $constructors = $1.first;
  const $newEnv = $1.second;
  const $varDef = ({
    constructors: $constructors,
    pars: $caPars,
    usr: $usr,
  });
  const $newModule = ((() => {
    const $0 = $caModule;
    return (Object.assign)({}, $0, ({
      constructorDefs: (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $0.constructorDefs, $constructors, c0$Dict$insert$0),
      variantTypeDefs: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $varDef, $0.variantTypeDefs),
    }));
  }))();
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: $newModule,
    second: $newEnv,
  }));
});

const u0$Compiler$MakeCanonical$insertRootStatement$3 = (($1) => {
  const $n = $1.first;
  const $p = $1.second;
  return (c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.usr)(...(c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.ctx), $p, $n);
});

const u0$Compiler$MakeCanonical$insertRootStatement$2 = (($1) => {
  const $p = $1.first;
  const $n = $1.second;
  return ({
    first: $n,
    second: $p,
  });
});

const u0$Compiler$MakeCanonical$insertRootStatement$1 = (($faStatement, $1) => {
  const $caModule = $1.first;
  const $env = $1.second;
  return (((($faStatement)[0] === "$Evaluation") && ((($faStatement)[1])[0] === "$Expression"))
    ? ((() => {
      const $pos = (($faStatement)[1])[2];
      return (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Root Evaluations don't really do much =|", c0$Core$Nil$0));
    }))()
    : ((($faStatement)[0] === "$ValueDef")
      ? ((() => {
        const $d = ($faStatement)[1];
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $caModule,
          ]),
          usr: u0$Compiler$MakeCanonical$insertRootStatement$8,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $caModule,
          ]),
          usr: u0$Compiler$MakeCanonical$insertRootStatement$8,
        })).ctx), (u0$Compiler$MakeCanonical$translateRootDefinition$0.usr)(...(u0$Compiler$MakeCanonical$translateRootDefinition$0.ctx), $env, $d));
      }))()
      : ((($faStatement)[0] === "$AliasDef")
        ? ((() => {
          const $fa = ($faStatement)[1];
          const $3 = $fa.name;
          const $name = $3.second;
          const $pos = $3.first;
          return (((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $caModule.aliasDefs) || (c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $caModule.variantTypeDefs))
            ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $fa.name.first, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($name + " declared twice!"), c0$Core$Nil$0))
            : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
              ctx: ([
                $caModule,
                $env,
                $fa,
                $name,
              ]),
              usr: u0$Compiler$MakeCanonical$insertRootStatement$6,
            })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
              ctx: ([
                $caModule,
                $env,
                $fa,
                $name,
              ]),
              usr: u0$Compiler$MakeCanonical$insertRootStatement$6,
            })).ctx), (u0$Compiler$MakeCanonical$translateRawType$0.usr)(...(u0$Compiler$MakeCanonical$translateRawType$0.ctx), $env.ro, $fa.type)));
        }))()
        : ((($faStatement)[0] === "$UnionDef")
          ? ((() => {
            const $fa = ($faStatement)[1];
            const $3 = $fa.name;
            const $name = $3.second;
            const $pos = $3.first;
            return (((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $caModule.aliasDefs) || (c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $caModule.variantTypeDefs))
              ? (u0$Compiler$MakeCanonical$error$0.usr)(...(u0$Compiler$MakeCanonical$error$0.ctx), $env, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($name + " declared twice!"), c0$Core$Nil$0))
              : ((() => {
                const $caPars = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                  ctx: [],
                  usr: u0$Compiler$MakeCanonical$insertRootStatement$2,
                }), $fa.args);
                const $usr = (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $env.ro.umr, $name);
                const $type = (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), $pos, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                  ctx: [],
                  usr: u0$Compiler$MakeCanonical$insertRootStatement$3,
                }), $caPars));
                return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $caModule,
                    $caPars,
                    $name,
                    $usr,
                  ]),
                  usr: u0$Compiler$MakeCanonical$insertRootStatement$4,
                })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
                  ctx: ([
                    $caModule,
                    $caPars,
                    $name,
                    $usr,
                  ]),
                  usr: u0$Compiler$MakeCanonical$insertRootStatement$4,
                })).ctx), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), ({
                  first: c0$Dict$empty$0,
                  second: $env,
                }), $fa.constructors, ({
                  ctx: ([
                    $caPars,
                    $type,
                    $usr,
                  ]),
                  usr: u0$Compiler$MakeCanonical$insertRootStatement$5,
                })));
              }))());
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical.sp 1561:4', (sp_toHuman)($faStatement))))));
});

const u0$Compiler$MakeCanonical$insertRootStatement$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$insertRootStatement$1,
});

const u0$Compiler$MakeCanonical$translateModule$2 = (($0, $1) => {
  return (u0$Compiler$MakeCanonical$insertRootStatement$0.usr)(...(u0$Compiler$MakeCanonical$insertRootStatement$0.ctx), $0, $1);
});

const u0$Compiler$MakeCanonical$translateModule$1 = (($ro, $faModule) => {
  const $module = (c0$Compiler$CanonicalAst$initModule$0.usr)(...(c0$Compiler$CanonicalAst$initModule$0.ctx), $ro.errorModule.fsPath, $ro.umr, $ro.errorModule.content);
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), c0$Tuple$first$0, (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), ({
    first: $module,
    second: (u0$Compiler$MakeCanonical$initEnv$0.usr)(...(u0$Compiler$MakeCanonical$initEnv$0.ctx), $ro),
  }), $faModule, ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical$translateModule$2,
  })));
});

const u0$Compiler$MakeCanonical$translateModule$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$translateModule$1,
});

const u0$Compiler$Lexer$getPos$1 = (($state) => {
  return (basics_cloneUni)($state.nextPos);
});

const u0$Compiler$Lexer$getPos$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$getPos$1,
});

const u0$Compiler$Lexer$closeOpenBlocks$2 = (($pos, $state, _0) => {
  return (array_push)($state.tokens, (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), $pos, $pos, c0$Compiler$Token$BlockEnd$0));
});

const u0$Compiler$Lexer$closeOpenBlocks$1 = (($state) => {
  const $pos = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
  const $s = (array_toList)($state.indentStack);
  (c0$List$each$0.usr)(...(c0$List$each$0.ctx), $s, ({
    ctx: ([
      $pos,
      $state,
    ]),
    usr: u0$Compiler$Lexer$closeOpenBlocks$2,
  }));
  return (array_push)($state.sections, (array_toList)($state.tokens));
});

const u0$Compiler$Lexer$closeOpenBlocks$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$closeOpenBlocks$1,
});

const u0$Compiler$Lexer$addCommentTokenAbs$1 = (($start, $end, $kind, $state) => {
  ((basics_cloneUni)($state.keepComments)
    ? (array_push)($state.tokens, (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), $start, $end, $kind))
    : null);
  return ($state.tokenStart = (basics_cloneImm)($end));
});

const u0$Compiler$Lexer$addCommentTokenAbs$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addCommentTokenAbs$1,
});

const u0$Compiler$Lexer$addIndentToken$1 = (($pos, $kind, $state) => {
  return (array_push)($state.tokens, (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), $pos, $pos, $kind));
});

const u0$Compiler$Lexer$addIndentToken$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addIndentToken$1,
});

const u0$Compiler$Lexer$updateIndent$2 = (($start, $state, $head) => {
  const $lineIndent = (basics_cloneUni)($state.lineIndent);
  return (($lineIndent > $head.indent)
    ? ((() => {
      const $newIndent = ({
        indent: $lineIndent,
        isBlock: (basics_cloneUni)($state.indentStartsABlock),
      });
      (array_push)($state.indentStack, $newIndent);
      return ((basics_cloneUni)($state.indentStartsABlock)
        ? (u0$Compiler$Lexer$addIndentToken$0.usr)(...(u0$Compiler$Lexer$addIndentToken$0.ctx), $start, c0$Compiler$Token$BlockStart$0, $state)
        : null);
    }))()
    : ($head.isBlock
      ? ((() => {
        const $list = (array_toList)($state.tokens);
        (((sp_not_equal)((basics_cloneUni)($state.lineIndent), 0) || (sp_equal)($list, c0$Core$Nil$0))
          ? null
          : ((() => {
            (array_push)($state.sections, $list);
            return ($state.tokens = (array_fromList)(c0$Core$Nil$0));
          }))());
        return (u0$Compiler$Lexer$addIndentToken$0.usr)(...(u0$Compiler$Lexer$addIndentToken$0.ctx), $start, c0$Compiler$Token$NewSiblingLine$0, $state);
      }))()
      : null));
});

const u0$Compiler$Lexer$updateIndent$1 = (($start, $end, $kind, $state) => {
  const $manageIndent = ({
    ctx: ([
      $start,
      $state,
    ]),
    usr: u0$Compiler$Lexer$updateIndent$2,
  });
  const $5 = (array_pop)($state.indentStack);
  return ((($5)[0] === "$Nothing")
    ? ($manageIndent.usr)(...($manageIndent.ctx), ({
      indent: 0,
      isBlock: true,
    }))
    : ((($5)[0] === "$Just")
      ? ((() => {
        const $head = ($5)[1];
        return (((basics_cloneUni)($state.lineIndent) < $head.indent)
          ? ((() => {
            ($head.isBlock
              ? (u0$Compiler$Lexer$addIndentToken$0.usr)(...(u0$Compiler$Lexer$addIndentToken$0.ctx), $start, c0$Compiler$Token$BlockEnd$0, $state)
              : null);
            return (u0$Compiler$Lexer$updateIndent$0.usr)(...(u0$Compiler$Lexer$updateIndent$0.ctx), $start, $end, $kind, $state);
          }))()
          : ((() => {
            (array_push)($state.indentStack, $head);
            return ($manageIndent.usr)(...($manageIndent.ctx), $head);
          }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 155:4', (sp_toHuman)($5))));
});

const u0$Compiler$Lexer$updateIndent$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$updateIndent$1,
});

const u0$Compiler$Lexer$addContentTokenAbs$1 = (($start, $end, $kind, $state) => {
  ((basics_cloneUni)($state.soFarThereAreNoTokensInThisLine)
    ? ((() => {
      ($state.soFarThereAreNoTokensInThisLine = false);
      return (u0$Compiler$Lexer$updateIndent$0.usr)(...(u0$Compiler$Lexer$updateIndent$0.ctx), $start, $end, $kind, $state);
    }))()
    : null);
  let $indentStartsABlock = ((($kind)[0] === "$Then")
    ? true
    : ((($kind)[0] === "$Else")
      ? true
      : ((($kind)[0] === "$As")
        ? true
        : ((($kind)[0] === "$Colon")
          ? true
          : ((($kind)[0] === "$Defop")
            ? true
            : (true
              ? false
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 185:8', (sp_toHuman)($kind))))))));
  ($state.indentStartsABlock = $indentStartsABlock);
  (array_push)($state.tokens, (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), $start, $end, $kind));
  return ($state.tokenStart = (basics_cloneImm)($end));
});

const u0$Compiler$Lexer$addContentTokenAbs$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addContentTokenAbs$1,
});

const u0$Compiler$Lexer$addContentTokenRel$1 = (($ds, $de, $kind, $state) => {
  const $pos = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
  return (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), ($pos + $ds), ($pos + $de), $kind, $state);
});

const u0$Compiler$Lexer$addContentTokenRel$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addContentTokenRel$1,
});

const u0$Compiler$Lexer$addError$2 = (($end, $message, $start, $0) => {
  return (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), $0, (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), $start, $end), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $message, c0$Core$Nil$0));
});

const u0$Compiler$Lexer$addError$1 = (($message, $state) => {
  const $end = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
  const $start = (basics_cloneUni)($state.tokenStart);
  const $error = ({
    ctx: ([
      $end,
      $message,
      $start,
    ]),
    usr: u0$Compiler$Lexer$addError$2,
  });
  (array_push)($state.errors, $error);
  return ($state.tokenStart = (basics_cloneImm)($end));
});

const u0$Compiler$Lexer$addError$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addError$1,
});

const u0$Compiler$Lexer$getChunk$1 = (($buffer, $state) => {
  const $start = (basics_cloneUni)($state.tokenStart);
  const $end = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
  return ({
    first: $start,
    second: $end,
    third: (text_slice)($start, $end, $buffer),
  });
});

const u0$Compiler$Lexer$getChunk$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$getChunk$1,
});

const u0$Compiler$Lexer$addNumberToken$1 = (($isPercent, $buffer, $state) => {
  const $4 = (u0$Compiler$Lexer$getChunk$0.usr)(...(u0$Compiler$Lexer$getChunk$0.ctx), $buffer, $state);
  const $chunk = $4.third;
  const $end = $4.second;
  const $start = $4.first;
  return (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), $start, $end, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), $isPercent, $chunk), $state);
});

const u0$Compiler$Lexer$addNumberToken$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addNumberToken$1,
});

const u0$Compiler$Lexer$addParenOrCommaToken$2 = (($state, $0) => {
  return (u0$Compiler$Lexer$addContentTokenRel$0.usr)(...(u0$Compiler$Lexer$addContentTokenRel$0.ctx), 0, 1, $0, $state);
});

const u0$Compiler$Lexer$addParenOrCommaToken$1 = (($char, $state) => {
  const $add = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$Lexer$addParenOrCommaToken$2,
  });
  const $line = (basics_cloneUni)($state.line);
  return (("(" === $char)
    ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$RoundParen$0.usr)(...(c0$Compiler$Token$RoundParen$0.ctx), c0$Compiler$Token$Open$0))
    : ((")" === $char)
      ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$RoundParen$0.usr)(...(c0$Compiler$Token$RoundParen$0.ctx), c0$Compiler$Token$Closed$0))
      : (("[" === $char)
        ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), $line, c0$Compiler$Token$Open$0))
        : (("]" === $char)
          ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), $line, c0$Compiler$Token$Closed$0))
          : (("{" === $char)
            ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$CurlyBrace$0.usr)(...(c0$Compiler$Token$CurlyBrace$0.ctx), $line, c0$Compiler$Token$Open$0))
            : (("}" === $char)
              ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$CurlyBrace$0.usr)(...(c0$Compiler$Token$CurlyBrace$0.ctx), $line, c0$Compiler$Token$Closed$0))
              : (("," === $char)
                ? ($add.usr)(...($add.ctx), c0$Compiler$Token$Comma$0)
                : (true
                  ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), (("I can't make sense of this piece of text: `" + $char) + "`"), $state)
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 564:4', (sp_toHuman)($char))))))))));
});

const u0$Compiler$Lexer$addParenOrCommaToken$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addParenOrCommaToken$1,
});

const u0$Compiler$CoreDefs$binopsBySymbol$1 = (($bop, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $bop.symbol, $bop, $d);
});

const u0$Compiler$CoreDefs$binopsBySymbol$0 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, u0$Compiler$CoreDefs$binops$0, ({
  ctx: [],
  usr: u0$Compiler$CoreDefs$binopsBySymbol$1,
}));

const u0$Compiler$Lexer$addSquiggleToken$2 = (($end, $start, $state, $0) => {
  return (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), $start, $end, $0, $state);
});

const u0$Compiler$Lexer$addSquiggleToken$1 = (($buffer, $nextIsSpace, $state) => {
  const $4 = (u0$Compiler$Lexer$getChunk$0.usr)(...(u0$Compiler$Lexer$getChunk$0.ctx), $buffer, $state);
  const $chunk = $4.third;
  const $end = $4.second;
  const $start = $4.first;
  const $add = ({
    ctx: ([
      $end,
      $start,
      $state,
    ]),
    usr: u0$Compiler$Lexer$addSquiggleToken$2,
  });
  return ((":" === $chunk)
    ? ($add.usr)(...($add.ctx), c0$Compiler$Token$Colon$0)
    : (("=" === $chunk)
      ? ($add.usr)(...($add.ctx), c0$Compiler$Token$Defop$0)
      : (("?" === $chunk)
        ? ($add.usr)(...($add.ctx), c0$Compiler$Token$UniquenessPolymorphismBinop$0)
        : (("!" === $chunk)
          ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$Unop$0.usr)(...(c0$Compiler$Token$Unop$0.ctx), c0$Compiler$Op$UnopUnique$0))
          : (("@" === $chunk)
            ? ($add.usr)(...($add.ctx), (c0$Compiler$Token$Unop$0.usr)(...(c0$Compiler$Token$Unop$0.ctx), c0$Compiler$Op$UnopRecycle$0))
            : (("-" === $chunk)
              ? ($add.usr)(...($add.ctx), ($nextIsSpace
                ? (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), (basics_cloneUni)($state.line), u0$Compiler$CoreDefs$subtract$0)
                : (c0$Compiler$Token$Unop$0.usr)(...(c0$Compiler$Token$Unop$0.ctx), c0$Compiler$Op$UnopMinus$0)))
              : (("+" === $chunk)
                ? ($add.usr)(...($add.ctx), ($nextIsSpace
                  ? (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), (basics_cloneUni)($state.line), u0$Compiler$CoreDefs$add$0)
                  : (c0$Compiler$Token$Unop$0.usr)(...(c0$Compiler$Token$Unop$0.ctx), c0$Compiler$Op$UnopPlus$0)))
                : (true
                  ? ((() => {
                    const $op = $chunk;
                    const $5 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $chunk, u0$Compiler$CoreDefs$binopsBySymbol$0);
                    return ((($5)[0] === "$Just")
                      ? ((() => {
                        const $binop = ($5)[1];
                        return ($add.usr)(...($add.ctx), (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), (basics_cloneUni)($state.line), $binop));
                      }))()
                      : ((($5)[0] === "$Nothing")
                        ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), (("Invalid operator: `" + $chunk) + "`"), $state)
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 548:12', (sp_toHuman)($5))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 524:4', (sp_toHuman)($chunk))))))))));
});

const u0$Compiler$Lexer$addSquiggleToken$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addSquiggleToken$1,
});

const u0$Compiler$Lexer$addErrorIf$1 = (($isError, $state, $message) => {
  return ($isError
    ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), $message, $state)
    : null);
});

const u0$Compiler$Lexer$addErrorIf$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addErrorIf$1,
});

const u0$Compiler$Lexer$startsWithUpperChar$1 = (($re, $s) => {
  const $2 = ($re.usr)(...($re.ctx), $s);
  return (("" === $2)
    ? false
    : (true
      ? true
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 316:4', (sp_toHuman)($2))));
});

const u0$Compiler$Lexer$startsWithUpperChar$0 = ((() => {
  const $re = (text_startsWithRegex)("[A-Z]");
  return ({
    ctx: ([
      $re,
    ]),
    usr: u0$Compiler$Lexer$startsWithUpperChar$1,
  });
}))();

const u0$Compiler$Lexer$parseAttr$1 = (($state, $text) => {
  (u0$Compiler$Lexer$addErrorIf$0.usr)(...(u0$Compiler$Lexer$addErrorIf$0.ctx), (u0$Compiler$Lexer$startsWithUpperChar$0.usr)(...(u0$Compiler$Lexer$startsWithUpperChar$0.ctx), $text), $state, "record attributes must start with a lowercase letter");
  return $text;
});

const u0$Compiler$Lexer$parseAttr$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$parseAttr$1,
});

const u0$Compiler$Lexer$parseAttrs$2 = (($state, $0) => {
  return (u0$Compiler$Lexer$parseAttr$0.usr)(...(u0$Compiler$Lexer$parseAttr$0.ctx), $state, $0);
});

const u0$Compiler$Lexer$parseAttrs$1 = (($state, $ts) => {
  return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$Lexer$parseAttrs$2,
  }), $ts);
});

const u0$Compiler$Lexer$parseAttrs$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$parseAttrs$1,
});

const u0$Compiler$Lexer$parseModule$1 = (($state, $text) => {
  return $text;
});

const u0$Compiler$Lexer$parseModule$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$parseModule$1,
});

const u0$Compiler$Lexer$parseNameToWord$1 = (($state, $1) => {
  const $attrPath = $1.attrPath;
  const $main = $1.main;
  const $maybeModule = $1.maybeModule;
  const $3 = (text_split)("'", $main);
  return (((($3)[0] === "$Cons") && (("" === ($3)[1]) && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil"))))
    ? ((() => {
      const $raw = (($3)[2])[1];
      (u0$Compiler$Lexer$addErrorIf$0.usr)(...(u0$Compiler$Lexer$addErrorIf$0.ctx), (sp_not_equal)($attrPath, c0$Core$Nil$0), $state, "Constructors don't have any attribute to access");
      return (c0$Compiler$Token$Constructor$0.usr)(...(c0$Compiler$Token$Constructor$0.ctx), ({
        maybeModule: $maybeModule,
        name: $main,
      }));
    }))()
    : (((($3)[0] === "$Cons") && ((($3)[2])[0] === "$Nil"))
      ? ((() => {
        const $name = ($3)[1];
        return ((u0$Compiler$Lexer$startsWithUpperChar$0.usr)(...(u0$Compiler$Lexer$startsWithUpperChar$0.ctx), $name)
          ? ((() => {
            (u0$Compiler$Lexer$addErrorIf$0.usr)(...(u0$Compiler$Lexer$addErrorIf$0.ctx), (sp_not_equal)($attrPath, c0$Core$Nil$0), $state, "WAT... Type names don't have attributes to access. =|");
            return (c0$Compiler$Token$Uppercase$0.usr)(...(c0$Compiler$Token$Uppercase$0.ctx), ({
              maybeModule: $maybeModule,
              name: $name,
            }));
          }))()
          : (c0$Compiler$Token$Lowercase$0.usr)(...(c0$Compiler$Token$Lowercase$0.ctx), ({
            attrPath: $attrPath,
            maybeModule: $maybeModule,
            name: $name,
          })));
      }))()
      : (true
        ? ((() => {
          (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "apostrophes can be used only at the beginning of a constructor name", $state);
          return (c0$Compiler$Token$Constructor$0.usr)(...(c0$Compiler$Token$Constructor$0.ctx), ({
            maybeModule: c0$Maybe$Nothing$0,
            name: $main,
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 323:4', (sp_toHuman)($3)))));
});

const u0$Compiler$Lexer$parseNameToWord$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$parseNameToWord$1,
});

const u0$Compiler$Lexer$addWord$3 = (($0) => {
  return (sp_equal)($0, "");
});

const u0$Compiler$Lexer$addWord$2 = (($0) => {
  return (sp_equal)($0, "");
});

const u0$Compiler$Lexer$addWord$1 = (($start, $end, $chunk0, $state) => {
  const $5 = ((() => {
    const $6 = (text_split)("...", $chunk0);
    return (((($6)[0] === "$Cons") && (((($6)[2])[0] === "$Cons") && (("" === (($6)[2])[1]) && (((($6)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $c = ($6)[1];
        return ({
          first: $c,
          second: true,
        });
      }))()
      : (((($6)[0] === "$Cons") && ((($6)[2])[0] === "$Nil"))
        ? ((() => {
          const $c = ($6)[1];
          return ({
            first: $c,
            second: false,
          });
        }))()
        : (true
          ? ({
            first: $chunk0,
            second: false,
          })
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 366:8', (sp_toHuman)($6)))));
  }))();
  const $trailingThreeDots = $5.second;
  const $chunk1 = $5.first;
  const $snips = (text_split)(".", $chunk1);
  (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), $start, $end, ((($snips)[0] === "$Nil")
    ? (c0$Compiler$Token$Lowercase$0.usr)(...(c0$Compiler$Token$Lowercase$0.ctx), ({
      attrPath: c0$Core$Nil$0,
      maybeModule: c0$Maybe$Nothing$0,
      name: "THIS IS NOT SUPPOSED TO HAPPEN",
    }))
    : (((($snips)[0] === "$Cons") && ((($snips)[2])[0] === "$Nil"))
      ? ((() => {
        const $main = ($snips)[1];
        return (u0$Compiler$Lexer$parseNameToWord$0.usr)(...(u0$Compiler$Lexer$parseNameToWord$0.ctx), $state, ({
          attrPath: c0$Core$Nil$0,
          main: $main,
          maybeModule: c0$Maybe$Nothing$0,
        }));
      }))()
      : (((($snips)[0] === "$Cons") && (("" === ($snips)[1]) && ((($snips)[2])[0] === "$Cons")))
        ? ((() => {
          const $two = (($snips)[2])[1];
          const $rest = (($snips)[2])[2];
          (u0$Compiler$Lexer$addErrorIf$0.usr)(...(u0$Compiler$Lexer$addErrorIf$0.ctx), (c0$List$any$0.usr)(...(c0$List$any$0.ctx), ({
            ctx: [],
            usr: u0$Compiler$Lexer$addWord$3,
          }), (sp_cons)($two, $rest)), $state, "use spaces around `..` to concatenate Text");
          return (c0$Compiler$Token$RecordShorthand$0.usr)(...(c0$Compiler$Token$RecordShorthand$0.ctx), ({
            attrPath: (u0$Compiler$Lexer$parseAttrs$0.usr)(...(u0$Compiler$Lexer$parseAttrs$0.ctx), $state, $rest),
            name: (u0$Compiler$Lexer$parseAttr$0.usr)(...(u0$Compiler$Lexer$parseAttr$0.ctx), $state, $two),
          }));
        }))()
        : (((($snips)[0] === "$Cons") && ((($snips)[2])[0] === "$Cons"))
          ? ((() => {
            const $one = ($snips)[1];
            const $two = (($snips)[2])[1];
            const $rest = (($snips)[2])[2];
            (u0$Compiler$Lexer$addErrorIf$0.usr)(...(u0$Compiler$Lexer$addErrorIf$0.ctx), (c0$List$any$0.usr)(...(c0$List$any$0.ctx), ({
              ctx: [],
              usr: u0$Compiler$Lexer$addWord$2,
            }), $snips), $state, "use spaces around `..` to concatenate Text");
            return ((u0$Compiler$Lexer$startsWithUpperChar$0.usr)(...(u0$Compiler$Lexer$startsWithUpperChar$0.ctx), $one)
              ? ((() => {
                const $module = (u0$Compiler$Lexer$parseModule$0.usr)(...(u0$Compiler$Lexer$parseModule$0.ctx), $state, $one);
                return (u0$Compiler$Lexer$parseNameToWord$0.usr)(...(u0$Compiler$Lexer$parseNameToWord$0.ctx), $state, ({
                  attrPath: (u0$Compiler$Lexer$parseAttrs$0.usr)(...(u0$Compiler$Lexer$parseAttrs$0.ctx), $state, $rest),
                  main: $two,
                  maybeModule: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $module),
                }));
              }))()
              : (u0$Compiler$Lexer$parseNameToWord$0.usr)(...(u0$Compiler$Lexer$parseNameToWord$0.ctx), $state, ({
                attrPath: (u0$Compiler$Lexer$parseAttrs$0.usr)(...(u0$Compiler$Lexer$parseAttrs$0.ctx), $state, (sp_cons)($two, $rest)),
                main: $one,
                maybeModule: c0$Maybe$Nothing$0,
              })));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 374:4', (sp_toHuman)($snips)))))), $state);
  return ($trailingThreeDots
    ? (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), ($end - 3), $end, c0$Compiler$Token$ThreeDots$0, $state)
    : null);
});

const u0$Compiler$Lexer$addWord$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addWord$1,
});

const u0$Compiler$Lexer$addWordToken$1 = (($buffer, $state) => {
  const $start = (basics_cloneUni)($state.tokenStart);
  const $end = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
  const $chunk = (text_slice)($start, $end, $buffer);
  const $maybeKeywordKind = (("fn" === $chunk)
    ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$Fn$0)
    : (("if" === $chunk)
      ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$If$0.usr)(...(c0$Compiler$Token$If$0.ctx), (basics_cloneUni)($state.line)))
      : (("then" === $chunk)
        ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$Then$0)
        : (("else" === $chunk)
          ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$Else$0.usr)(...(c0$Compiler$Token$Else$0.ctx), (basics_cloneUni)($state.line)))
          : (("try" === $chunk)
            ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$Try$0)
            : (("as" === $chunk)
              ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$As$0)
              : (("with" === $chunk)
                ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$With$0)
                : (("and" === $chunk)
                  ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), (basics_cloneUni)($state.line), u0$Compiler$CoreDefs$and_$0))
                  : (("or" === $chunk)
                    ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), (basics_cloneUni)($state.line), u0$Compiler$CoreDefs$or_$0))
                    : (("__" === $chunk)
                      ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$ArgumentPlaceholder$0)
                      : (("this_is_sp_native" === $chunk)
                        ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Token$This_is_sp_native$0)
                        : (("sp_introspect_value" === $chunk)
                          ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$Sp_introspect$0.usr)(...(c0$Compiler$Token$Sp_introspect$0.ctx), c0$Compiler$Token$Value$0))
                          : (("sp_introspect_type" === $chunk)
                            ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$Sp_introspect$0.usr)(...(c0$Compiler$Token$Sp_introspect$0.ctx), c0$Compiler$Token$Type$0))
                            : (("sp_introspect_type_open" === $chunk)
                              ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$Token$Sp_introspect$0.usr)(...(c0$Compiler$Token$Sp_introspect$0.ctx), c0$Compiler$Token$TypeOpen$0))
                              : (true
                                ? c0$Maybe$Nothing$0
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 445:8', (sp_toHuman)($chunk)))))))))))))))));
  return ((($maybeKeywordKind)[0] === "$Just")
    ? ((() => {
      const $kind = ($maybeKeywordKind)[1];
      return (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), $start, $end, $kind, $state);
    }))()
    : (true
      ? (u0$Compiler$Lexer$addWord$0.usr)(...(u0$Compiler$Lexer$addWord$0.ctx), $start, $end, $chunk, $state)
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 462:4', (sp_toHuman)($maybeKeywordKind))));
});

const u0$Compiler$Lexer$addWordToken$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$addWordToken$1,
});

const u0$Compiler$Lexer$isNumber$1 = (($re, $char) => {
  return (sp_not_equal)(($re.usr)(...($re.ctx), $char), "");
});

const u0$Compiler$Lexer$isNumber$0 = ((() => {
  const $re = (text_startsWithRegex)("[0-9_.]");
  return ({
    ctx: ([
      $re,
    ]),
    usr: u0$Compiler$Lexer$isNumber$1,
  });
}))();

const u0$Compiler$Lexer$isSquiggle$1 = (($char) => {
  return (("=" === $char)
    ? true
    : ((":" === $char)
      ? true
      : (("*" === $char)
        ? true
        : (("+" === $char)
          ? true
          : (("-" === $char)
            ? true
            : (("/" === $char)
              ? true
              : ((">" === $char)
                ? true
                : (("<" === $char)
                  ? true
                  : (("!" === $char)
                    ? true
                    : (("?" === $char)
                      ? true
                      : (("&" === $char)
                        ? true
                        : (("^" === $char)
                          ? true
                          : (("@" === $char)
                            ? true
                            : (("$" === $char)
                              ? true
                              : (true
                                ? false
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 498:4', (sp_toHuman)($char)))))))))))))))));
});

const u0$Compiler$Lexer$isSquiggle$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$isSquiggle$1,
});

const u0$Compiler$Lexer$isWordBody$1 = (($re, $char) => {
  return (sp_not_equal)(($re.usr)(...($re.ctx), $char), "");
});

const u0$Compiler$Lexer$isWordBody$0 = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z./_0-9']");
  return ({
    ctx: ([
      $re,
    ]),
    usr: u0$Compiler$Lexer$isWordBody$1,
  });
}))();

const u0$Compiler$Lexer$isWordStart$1 = (($re, $char) => {
  return (sp_not_equal)(($re.usr)(...($re.ctx), $char), "");
});

const u0$Compiler$Lexer$isWordStart$0 = ((() => {
  const $re = (text_startsWithRegex)("[a-zA-Z._']");
  return ({
    ctx: ([
      $re,
    ]),
    usr: u0$Compiler$Lexer$isWordStart$1,
  });
}))();

const u0$Compiler$Lexer$setMode$1 = (($mode, $state) => {
  return ($state.mode = (basics_cloneImm)($mode));
});

const u0$Compiler$Lexer$setMode$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$setMode$1,
});

const u0$Compiler$Lexer$thereIsABlankAhead$1 = (($offset, $buffer, $state) => {
  const $start = (text_fromNumber)(((basics_cloneUni)($state.nextPos) + $offset));
  const $regex = ((".{" + $start) + "}\n[ ]*(\n|$)");
  return (sp_not_equal)(((text_startsWithRegex)($regex).usr)(...((text_startsWithRegex)($regex).ctx), $buffer), "");
});

const u0$Compiler$Lexer$thereIsABlankAhead$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$thereIsABlankAhead$1,
});

const u0$Compiler$Lexer$tryIndent$1 = (($buffer, $indentChar, $char, $state) => {
  return (((sp_equal)($char, $indentChar) || (sp_equal)($char, ""))
    ? null
    : (((sp_equal)($char, " ") || (sp_equal)($char, "\t"))
      ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "mixing tabs and spaces!", $state)
      : ((sp_equal)($char, "\n")
        ? ((() => {
          ($state.tokenStart = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) + 1));
          return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Indent$0, $state);
        }))()
        : ((sp_equal)($char, "#")
          ? ((() => {
            const $start = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
            const $column = (basics_cloneUni)($state.column);
            return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$LineComment$0.usr)(...(u0$Compiler$Lexer$LineComment$0.ctx), ({
              column: $column,
              start: $start,
            })), $state);
          }))()
          : ((() => {
            ($state.lineIndent = (basics_cloneUni)($state.column));
            (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
            return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
          }))()))));
});

const u0$Compiler$Lexer$tryIndent$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$tryIndent$1,
});

const u0$Compiler$Lexer$unindent$4 = (($minLead, $0) => {
  return (text_dropLeft)($minLead, $0);
});

const u0$Compiler$Lexer$unindent$3 = (($s) => {
  return (sp_not_equal)((text_trimLeft)($s), "");
});

const u0$Compiler$Lexer$unindent$2 = (($re, $line) => {
  return (text_length)(($re.usr)(...($re.ctx), $line));
});

const u0$Compiler$Lexer$unindent$1 = (($raw) => {
  return ((c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), (text_startsWith)("\n", $raw))
    ? $raw
    : ((() => {
      const $multilineText = (text_dropLeft)(1, $raw);
      const $lines = (text_split)("\n", $multilineText);
      const $countLeadingSpaces = ((() => {
        const $re = (text_startsWithRegex)("[ ]*");
        return ({
          ctx: ([
            $re,
          ]),
          usr: u0$Compiler$Lexer$unindent$2,
        });
      }))();
      const $minLead = (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), 0, (c0$List$minimum$0.usr)(...(c0$List$minimum$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $countLeadingSpaces, (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
        ctx: [],
        usr: u0$Compiler$Lexer$unindent$3,
      }), $lines))));
      return ((text_replaceRegex)("\n[ ]*$").usr)(...((text_replaceRegex)("\n[ ]*$").ctx), "", (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
        ctx: ([
          $minLead,
        ]),
        usr: u0$Compiler$Lexer$unindent$4,
      }), $lines)));
    }))());
});

const u0$Compiler$Lexer$unindent$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$unindent$1,
});

const u0$Compiler$Lexer$lexOne$2 = (($char, $column, $nesting, $start, $state, $dn) => {
  return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$BlockComment$0.usr)(...(u0$Compiler$Lexer$BlockComment$0.ctx), ({
    column: $column,
    nesting: ($nesting + $dn),
    previous: $char,
    start: $start,
  })), $state);
});

const u0$Compiler$Lexer$lexOne$1 = (($buffer, $char, $state) => {
  const $pos = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
  let $4 = (basics_cloneUni)($state.mode);
  return ((($4)[0] === "$Indent")
    ? ((() => {
      let $5 = (basics_cloneUni)($state.tabsOrSpaces);
      return ((($5)[0] === "$Tabs")
        ? (u0$Compiler$Lexer$tryIndent$0.usr)(...(u0$Compiler$Lexer$tryIndent$0.ctx), $buffer, "\t", $char, $state)
        : ((($5)[0] === "$Spaces")
          ? (u0$Compiler$Lexer$tryIndent$0.usr)(...(u0$Compiler$Lexer$tryIndent$0.ctx), $buffer, " ", $char, $state)
          : ((($5)[0] === "$NoTabsOrSpacesYet")
            ? ((" " === $char)
              ? ((() => {
                ($state.tabsOrSpaces = u0$Compiler$Lexer$Spaces$0);
                return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
              }))()
              : (("\t" === $char)
                ? ((() => {
                  ($state.tabsOrSpaces = u0$Compiler$Lexer$Tabs$0);
                  return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                }))()
                : (true
                  ? (u0$Compiler$Lexer$tryIndent$0.usr)(...(u0$Compiler$Lexer$tryIndent$0.ctx), $buffer, " ", $char, $state)
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 613:20', (sp_toHuman)($char)))))
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 604:12', (sp_toHuman)($5)))));
    }))()
    : ((($4)[0] === "$Default")
      ? (("" === $char)
        ? null
        : (("." === $char)
          ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Dot_One$0, $state)
          : (("#" === $char)
            ? ((() => {
              const $start = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state);
              const $column = (basics_cloneUni)($state.column);
              return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$LineComment$0.usr)(...(u0$Compiler$Lexer$LineComment$0.ctx), ({
                column: $column,
                start: $start,
              })), $state);
            }))()
            : (("[" === $char)
              ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$ContentOpeningBlockComment$0, $state)
              : (("\"" === $char)
                ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$ContentOpeningQuotes_One$0, $state)
                : (("\n" === $char)
                  ? ((() => {
                    ($state.tokenStart = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) + 1));
                    ($state.soFarThereAreNoTokensInThisLine = true);
                    return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Indent$0, $state);
                  }))()
                  : ((" " === $char)
                    ? ($state.tokenStart = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) + 1))
                    : (true
                      ? ((() => {
                        ($state.tokenStart = (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state));
                        return ((u0$Compiler$Lexer$isWordStart$0.usr)(...(u0$Compiler$Lexer$isWordStart$0.ctx), $char)
                          ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Word$0, $state)
                          : ((u0$Compiler$Lexer$isNumber$0.usr)(...(u0$Compiler$Lexer$isNumber$0.ctx), $char)
                            ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$NumberLiteral$0, $state)
                            : ((u0$Compiler$Lexer$isSquiggle$0.usr)(...(u0$Compiler$Lexer$isSquiggle$0.ctx), $char)
                              ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Squiggles$0, $state)
                              : (u0$Compiler$Lexer$addParenOrCommaToken$0.usr)(...(u0$Compiler$Lexer$addParenOrCommaToken$0.ctx), $char, $state))));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 629:12', (sp_toHuman)($char))))))))))
      : ((($4)[0] === "$Dot_One")
        ? ((sp_equal)($char, ".")
          ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Dot_Two$0, $state)
          : ((u0$Compiler$Lexer$isWordStart$0.usr)(...(u0$Compiler$Lexer$isWordStart$0.ctx), $char)
            ? ((() => {
              ($state.tokenStart = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) - 1));
              return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Word$0, $state);
            }))()
            : ((u0$Compiler$Lexer$isNumber$0.usr)(...(u0$Compiler$Lexer$isNumber$0.ctx), $char)
              ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$NumberLiteral$0, $state)
              : (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "no idea what this is", $state))))
        : ((($4)[0] === "$Dot_Two")
          ? ((sp_equal)($char, ".")
            ? ((() => {
              (u0$Compiler$Lexer$addContentTokenRel$0.usr)(...(u0$Compiler$Lexer$addContentTokenRel$0.ctx), -(1), 1, c0$Compiler$Token$ThreeDots$0, $state);
              return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
            }))()
            : ((() => {
              (u0$Compiler$Lexer$addContentTokenRel$0.usr)(...(u0$Compiler$Lexer$addContentTokenRel$0.ctx), -(1), 1, (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), (basics_cloneUni)($state.line), u0$Compiler$CoreDefs$textConcat$0), $state);
              (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
              return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
            }))())
          : ((($4)[0] === "$Mutable")
            ? ((u0$Compiler$Lexer$isSquiggle$0.usr)(...(u0$Compiler$Lexer$isSquiggle$0.ctx), $char)
              ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Squiggles$0, $state)
              : (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "no idea what this is", $state))
            : ((($4)[0] === "$Word")
              ? ((u0$Compiler$Lexer$isWordBody$0.usr)(...(u0$Compiler$Lexer$isWordBody$0.ctx), $char)
                ? null
                : ((() => {
                  (u0$Compiler$Lexer$addWordToken$0.usr)(...(u0$Compiler$Lexer$addWordToken$0.ctx), $buffer, $state);
                  (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                  return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                }))())
              : ((($4)[0] === "$NumberLiteral")
                ? ((u0$Compiler$Lexer$isNumber$0.usr)(...(u0$Compiler$Lexer$isNumber$0.ctx), $char)
                  ? null
                  : ((sp_equal)($char, "%")
                    ? ((() => {
                      (u0$Compiler$Lexer$addNumberToken$0.usr)(...(u0$Compiler$Lexer$addNumberToken$0.ctx), true, $buffer, $state);
                      return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                    }))()
                    : ((() => {
                      (u0$Compiler$Lexer$addNumberToken$0.usr)(...(u0$Compiler$Lexer$addNumberToken$0.ctx), false, $buffer, $state);
                      (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                      return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                    }))()))
                : ((($4)[0] === "$Squiggles")
                  ? ((u0$Compiler$Lexer$isSquiggle$0.usr)(...(u0$Compiler$Lexer$isSquiggle$0.ctx), $char)
                    ? null
                    : ((() => {
                      (u0$Compiler$Lexer$addSquiggleToken$0.usr)(...(u0$Compiler$Lexer$addSquiggleToken$0.ctx), $buffer, (sp_equal)($char, " "), $state);
                      (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                      return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                    }))())
                  : ((($4)[0] === "$ContentOpeningQuotes_One")
                    ? ((sp_equal)($char, "\"")
                      ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$ContentOpeningQuotes_Two$0, $state)
                      : ((sp_equal)($char, "")
                        ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "there's no closing quotes", $state)
                        : ((() => {
                          ($state.tokenStart = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) - 1));
                          (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$SingleQuote$0.usr)(...(u0$Compiler$Lexer$SingleQuote$0.ctx), ({
                            lastEscape: -(1),
                          })), $state);
                          return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                        }))()))
                    : ((($4)[0] === "$ContentOpeningQuotes_Two")
                      ? ((sp_equal)($char, "\"")
                        ? ((() => {
                          ($state.tokenStart = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) - 2));
                          return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$TripleQuote$0.usr)(...(u0$Compiler$Lexer$TripleQuote$0.ctx), ({
                            closingQuotes: 0,
                            lastEscape: -(1),
                          })), $state);
                        }))()
                        : ((() => {
                          (u0$Compiler$Lexer$addContentTokenRel$0.usr)(...(u0$Compiler$Lexer$addContentTokenRel$0.ctx), -(2), 0, (c0$Compiler$Token$TextLiteral$0.usr)(...(c0$Compiler$Token$TextLiteral$0.ctx), c0$Compiler$Token$SingleQuote$0, ""), $state);
                          (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                          return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                        }))())
                      : ((($4)[0] === "$SingleQuote")
                        ? ((() => {
                          const $lastEscape = ($4)[1].lastEscape;
                          const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                          return ((sp_equal)($char, "")
                            ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "there's no closing quotes", $state)
                            : ($previousIsEscape
                              ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$SingleQuote$0.usr)(...(u0$Compiler$Lexer$SingleQuote$0.ctx), ({
                                lastEscape: $lastEscape,
                              })), $state)
                              : (("\"" === $char)
                                ? ((() => {
                                  const $start = (basics_cloneUni)($state.tokenStart);
                                  const $end = ($pos + 1);
                                  const $value = (text_slice)(($start + 1), ($end - 1), $buffer);
                                  (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), $start, $end, (c0$Compiler$Token$TextLiteral$0.usr)(...(c0$Compiler$Token$TextLiteral$0.ctx), c0$Compiler$Token$SingleQuote$0, $value), $state);
                                  return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                                }))()
                                : (("\\" === $char)
                                  ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$SingleQuote$0.usr)(...(u0$Compiler$Lexer$SingleQuote$0.ctx), ({
                                    lastEscape: $pos,
                                  })), $state)
                                  : (true
                                    ? null
                                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 778:16', (sp_toHuman)($char)))))));
                        }))()
                        : ((($4)[0] === "$TripleQuote")
                          ? ((() => {
                            const $closingQuotes = ($4)[1].closingQuotes;
                            const $lastEscape = ($4)[1].lastEscape;
                            const $previousIsEscape = (sp_equal)($pos, ($lastEscape + 1));
                            return ((sp_equal)($char, "")
                              ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "unterminated triple quotes", $state)
                              : ($previousIsEscape
                                ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$TripleQuote$0.usr)(...(u0$Compiler$Lexer$TripleQuote$0.ctx), ({
                                  closingQuotes: 0,
                                  lastEscape: $lastEscape,
                                })), $state)
                                : (("\"" === $char)
                                  ? ((sp_equal)($closingQuotes, 2)
                                    ? ((() => {
                                      const $start = (basics_cloneUni)($state.tokenStart);
                                      const $end = ($pos + 1);
                                      (u0$Compiler$Lexer$addContentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addContentTokenAbs$0.ctx), $start, $end, (c0$Compiler$Token$TextLiteral$0.usr)(...(c0$Compiler$Token$TextLiteral$0.ctx), c0$Compiler$Token$TripleQuote$0, (u0$Compiler$Lexer$unindent$0.usr)(...(u0$Compiler$Lexer$unindent$0.ctx), (text_slice)(($start + 3), ($end - 3), $buffer))), $state);
                                      return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                                    }))()
                                    : (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$TripleQuote$0.usr)(...(u0$Compiler$Lexer$TripleQuote$0.ctx), ({
                                      closingQuotes: ($closingQuotes + 1),
                                      lastEscape: $lastEscape,
                                    })), $state))
                                  : (("\\" === $char)
                                    ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$TripleQuote$0.usr)(...(u0$Compiler$Lexer$TripleQuote$0.ctx), ({
                                      closingQuotes: 0,
                                      lastEscape: $pos,
                                    })), $state)
                                    : (true
                                      ? (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$TripleQuote$0.usr)(...(u0$Compiler$Lexer$TripleQuote$0.ctx), ({
                                        closingQuotes: 0,
                                        lastEscape: $lastEscape,
                                      })), $state)
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 821:16', (sp_toHuman)($char)))))));
                          }))()
                          : ((($4)[0] === "$LineComment")
                            ? ((() => {
                              const $column = ($4)[1].column;
                              const $start = ($4)[1].start;
                              return (((sp_equal)($char, "\n") || (sp_equal)($char, ""))
                                ? ((() => {
                                  (u0$Compiler$Lexer$addCommentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addCommentTokenAbs$0.ctx), $start, (u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state), (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
                                    indent: $column,
                                    isBlock: false,
                                    isFollowedByBlank: (u0$Compiler$Lexer$thereIsABlankAhead$0.usr)(...(u0$Compiler$Lexer$thereIsABlankAhead$0.ctx), 0, $buffer, $state),
                                  })), $state);
                                  (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                                  return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                                }))()
                                : null);
                            }))()
                            : ((($4)[0] === "$ContentOpeningBlockComment")
                              ? ((sp_equal)($char, "#")
                                ? ((() => {
                                  const $start = ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) - 1);
                                  const $column = ((basics_cloneUni)($state.column) - 1);
                                  return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), (u0$Compiler$Lexer$BlockComment$0.usr)(...(u0$Compiler$Lexer$BlockComment$0.ctx), ({
                                    column: $column,
                                    nesting: 1,
                                    previous: "",
                                    start: $start,
                                  })), $state);
                                }))()
                                : ((() => {
                                  (u0$Compiler$Lexer$addContentTokenRel$0.usr)(...(u0$Compiler$Lexer$addContentTokenRel$0.ctx), -(1), 0, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), (basics_cloneUni)($state.line), c0$Compiler$Token$Open$0), $state);
                                  (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                                  return (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $buffer, $char, $state);
                                }))())
                              : ((($4)[0] === "$BlockComment")
                                ? ((() => {
                                  const $column = ($4)[1].column;
                                  const $nesting = ($4)[1].nesting;
                                  const $previous = ($4)[1].previous;
                                  const $start = ($4)[1].start;
                                  const $continueWithDeltaNesting = ({
                                    ctx: ([
                                      $char,
                                      $column,
                                      $nesting,
                                      $start,
                                      $state,
                                    ]),
                                    usr: u0$Compiler$Lexer$lexOne$2,
                                  });
                                  const $5 = ({
                                    first: $previous,
                                    second: $char,
                                  });
                                  return ((("[" === $5.first) && ("#" === $5.second))
                                    ? ($continueWithDeltaNesting.usr)(...($continueWithDeltaNesting.ctx), 1)
                                    : ((("#" === $5.first) && ("]" === $5.second))
                                      ? (($nesting > 1)
                                        ? ($continueWithDeltaNesting.usr)(...($continueWithDeltaNesting.ctx), -(1))
                                        : ((() => {
                                          (u0$Compiler$Lexer$addCommentTokenAbs$0.usr)(...(u0$Compiler$Lexer$addCommentTokenAbs$0.ctx), $start, ((u0$Compiler$Lexer$getPos$0.usr)(...(u0$Compiler$Lexer$getPos$0.ctx), $state) + 1), (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
                                            indent: $column,
                                            isBlock: true,
                                            isFollowedByBlank: (u0$Compiler$Lexer$thereIsABlankAhead$0.usr)(...(u0$Compiler$Lexer$thereIsABlankAhead$0.ctx), 1, $buffer, $state),
                                          })), $state);
                                          return (u0$Compiler$Lexer$setMode$0.usr)(...(u0$Compiler$Lexer$setMode$0.ctx), u0$Compiler$Lexer$Default$0, $state);
                                        }))())
                                      : (("" === $5.second)
                                        ? (u0$Compiler$Lexer$addError$0.usr)(...(u0$Compiler$Lexer$addError$0.ctx), "unterminated block comment", $state)
                                        : (true
                                          ? ($continueWithDeltaNesting.usr)(...($continueWithDeltaNesting.ctx), 0)
                                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 885:12', (sp_toHuman)($5))))));
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 601:4', (sp_toHuman)($4)))))))))))))))));
});

const u0$Compiler$Lexer$lexOne$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$lexOne$1,
});

const u0$Compiler$Lexer$readStateInit$1 = (($keepComments) => {
  return ({
    column: 0,
    errors: (array_fromList)(c0$Core$Nil$0),
    indentStack: (array_fromList)(c0$Core$Nil$0),
    indentStartsABlock: true,
    keepComments: (basics_cloneImm)($keepComments),
    line: 0,
    lineIndent: 0,
    mode: u0$Compiler$Lexer$Indent$0,
    nextPos: 0,
    sections: (array_fromList)(c0$Core$Nil$0),
    soFarThereAreNoTokensInThisLine: true,
    tabsOrSpaces: u0$Compiler$Lexer$NoTabsOrSpacesYet$0,
    tokenStart: 0,
    tokens: (array_fromList)(c0$Core$Nil$0),
  });
});

const u0$Compiler$Lexer$readStateInit$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$readStateInit$1,
});

const u0$Compiler$Lexer$lexer$3 = (($module, $e) => {
  return ($e.usr)(...($e.ctx), $module);
});

const u0$Compiler$Lexer$lexer$2 = (($moduleCode, $state, $char) => {
  (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $moduleCode, $char, $state);
  ($state.nextPos += 1);
  return ((sp_equal)($char, "\n")
    ? ((() => {
      ($state.line += 1);
      return ($state.column = 0);
    }))()
    : ($state.column += 1));
});

const u0$Compiler$Lexer$lexer$1 = (($keepComments, $module) => {
  const $moduleCode = $module.content;
  let $state = (u0$Compiler$Lexer$readStateInit$0.usr)(...(u0$Compiler$Lexer$readStateInit$0.ctx), $keepComments);
  (text_forEach)($moduleCode, ({
    ctx: ([
      $moduleCode,
      $state,
    ]),
    usr: u0$Compiler$Lexer$lexer$2,
  }));
  (u0$Compiler$Lexer$lexOne$0.usr)(...(u0$Compiler$Lexer$lexOne$0.ctx), $moduleCode, "", $state);
  const $3 = (array_toList)($state.errors);
  return ((($3)[0] === "$Nil")
    ? ((() => {
      (u0$Compiler$Lexer$closeOpenBlocks$0.usr)(...(u0$Compiler$Lexer$closeOpenBlocks$0.ctx), $state);
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (array_toList)($state.sections));
    }))()
    : (true
      ? ((() => {
        const $errors = $3;
        return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Nested$0.usr)(...(u0$Compiler$Error$Nested$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
          ctx: ([
            $module,
          ]),
          usr: u0$Compiler$Lexer$lexer$3,
        }), $errors)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Lexer.sp 993:4', (sp_toHuman)($3))));
});

const u0$Compiler$Lexer$lexer$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer$lexer$1,
});

const u0$Compiler$Parser$makeError$1 = (($env, $farthestParsed, $message) => {
  return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $env.errorModule, ((($farthestParsed)[0] === "$Nil")
    ? (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), 0, 1)
    : (((($farthestParsed)[0] === "$Cons") && ((($farthestParsed)[1])[0] === "$Token"))
      ? ((() => {
        const $start = (($farthestParsed)[1])[1];
        const $end = (($farthestParsed)[1])[2];
        const $k = (($farthestParsed)[1])[3];
        const $rest = ($farthestParsed)[2];
        return (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), $start, $end);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 877:4', (sp_toHuman)($farthestParsed)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $message, c0$Core$Nil$0));
});

const u0$Compiler$Parser$makeError$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$makeError$1,
});

const u0$Compiler$Parser$eatComments$1 = (($readState) => {
  const $2 = $readState.tokens;
  return (((($2)[0] === "$Cons") && (((($2)[1])[0] === "$Token") && (((($2)[1])[3])[0] === "$Comment")))
    ? ((() => {
      const $start = (($2)[1])[1];
      const $end = (($2)[1])[2];
      const $indent = ((($2)[1])[3])[1].indent;
      const $isBlock = ((($2)[1])[3])[1].isBlock;
      const $isFollowedByBlank = ((($2)[1])[3])[1].isFollowedByBlank;
      const $tail = ($2)[2];
      return (u0$Compiler$Parser$eatComments$0.usr)(...(u0$Compiler$Parser$eatComments$0.ctx), ({
        commentsReversed: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
          end: $end,
          indent: $indent,
          isBlock: $isBlock,
          isFollowedByBlank: $isFollowedByBlank,
          start: $start,
        }), $readState.commentsReversed),
        tokens: $tail,
      }));
    }))()
    : (true
      ? $readState
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 24:4', (sp_toHuman)($2))));
});

const u0$Compiler$Parser$eatComments$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$eatComments$1,
});

const u0$SPLib$Parser$accept$2 = (($a, $rejections, $readState) => {
  return ({
    first: $rejections,
    second: (u0$SPLib$Parser$Accepted$0.usr)(...(u0$SPLib$Parser$Accepted$0.ctx), $readState, $a),
  });
});

const u0$SPLib$Parser$accept$1 = (($a) => {
  return ({
    ctx: ([
      $a,
    ]),
    usr: u0$SPLib$Parser$accept$2,
  });
});

const u0$SPLib$Parser$accept$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$accept$1,
});

const u0$Compiler$Parser$ok$0 = u0$SPLib$Parser$accept$0;

const u0$SPLib$Parser$thenWithDefault$3 = (($chainedParser, $fallbackParser, $firstParser, $re0, $readState) => {
  const $3 = ($firstParser.usr)(...($firstParser.ctx), $re0, $readState);
  return ((($3.second)[0] === "$Aborted")
    ? ((() => {
      const $re1 = $3.first;
      const $rs = ($3.second)[1];
      const $reason = ($3.second)[2];
      return ({
        first: $re1,
        second: (u0$SPLib$Parser$Aborted$0.usr)(...(u0$SPLib$Parser$Aborted$0.ctx), $rs, $reason),
      });
    }))()
    : ((($3.second)[0] === "$Rejected")
      ? ((() => {
        const $re1 = $3.first;
        return ($fallbackParser.usr)(...($fallbackParser.ctx), $re1, $readState);
      }))()
      : ((($3.second)[0] === "$Accepted")
        ? ((() => {
          const $re1 = $3.first;
          const $nextReadState = ($3.second)[1];
          const $a = ($3.second)[2];
          return (($chainedParser.usr)(...($chainedParser.ctx), $a).usr)(...(($chainedParser.usr)(...($chainedParser.ctx), $a).ctx), $re1, $nextReadState);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 86:4', (sp_toHuman)($3)))));
});

const u0$SPLib$Parser$thenWithDefault$2 = (($chainedParser, $fallbackParser, $firstParser) => {
  return ({
    ctx: ([
      $chainedParser,
      $fallbackParser,
      $firstParser,
    ]),
    usr: u0$SPLib$Parser$thenWithDefault$3,
  });
});

const u0$SPLib$Parser$thenWithDefault$1 = (($fallbackParser, $chainedParser) => {
  return ({
    ctx: ([
      $chainedParser,
      $fallbackParser,
    ]),
    usr: u0$SPLib$Parser$thenWithDefault$2,
  });
});

const u0$SPLib$Parser$thenWithDefault$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$thenWithDefault$1,
});

const u0$Compiler$Parser$forZeroOrMore$2 = (($getParser, $0) => {
  return (u0$Compiler$Parser$forZeroOrMore$0.usr)(...(u0$Compiler$Parser$forZeroOrMore$0.ctx), $0, $getParser);
});

const u0$Compiler$Parser$forZeroOrMore$1 = (($init, $getParser) => {
  return ((u0$SPLib$Parser$thenWithDefault$0.usr)(...(u0$SPLib$Parser$thenWithDefault$0.ctx), (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $init), ({
    ctx: ([
      $getParser,
    ]),
    usr: u0$Compiler$Parser$forZeroOrMore$2,
  })).usr)(...((u0$SPLib$Parser$thenWithDefault$0.usr)(...(u0$SPLib$Parser$thenWithDefault$0.ctx), (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $init), ({
    ctx: ([
      $getParser,
    ]),
    usr: u0$Compiler$Parser$forZeroOrMore$2,
  })).ctx), ($getParser.usr)(...($getParser.ctx), $init));
});

const u0$Compiler$Parser$forZeroOrMore$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$forZeroOrMore$1,
});

const u0$SPLib$Parser$andThen$3 = (($chainedParser, $firstParser, $re0, $readState) => {
  const $3 = ($firstParser.usr)(...($firstParser.ctx), $re0, $readState);
  return ((($3.second)[0] === "$Accepted")
    ? ((() => {
      const $re1 = $3.first;
      const $nextReadState = ($3.second)[1];
      const $a = ($3.second)[2];
      return (($chainedParser.usr)(...($chainedParser.ctx), $a).usr)(...(($chainedParser.usr)(...($chainedParser.ctx), $a).ctx), $re1, $nextReadState);
    }))()
    : ((($3.second)[0] === "$Rejected")
      ? ((() => {
        const $re1 = $3.first;
        return ({
          first: $re1,
          second: u0$SPLib$Parser$Rejected$0,
        });
      }))()
      : ((($3.second)[0] === "$Aborted")
        ? ((() => {
          const $re1 = $3.first;
          const $rs = ($3.second)[1];
          const $e = ($3.second)[2];
          return ({
            first: $re1,
            second: (u0$SPLib$Parser$Aborted$0.usr)(...(u0$SPLib$Parser$Aborted$0.ctx), $rs, $e),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 75:4', (sp_toHuman)($3)))));
});

const u0$SPLib$Parser$andThen$2 = (($chainedParser, $firstParser) => {
  return ({
    ctx: ([
      $chainedParser,
      $firstParser,
    ]),
    usr: u0$SPLib$Parser$andThen$3,
  });
});

const u0$SPLib$Parser$andThen$1 = (($chainedParser) => {
  return ({
    ctx: ([
      $chainedParser,
    ]),
    usr: u0$SPLib$Parser$andThen$2,
  });
});

const u0$SPLib$Parser$andThen$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$andThen$1,
});

const u0$Compiler$Parser$on$0 = u0$SPLib$Parser$andThen$0;

const u0$Compiler$Parser$oneToken$1 = (($rejections, $rs) => {
  const $readState = (u0$Compiler$Parser$eatComments$0.usr)(...(u0$Compiler$Parser$eatComments$0.ctx), $rs);
  const $3 = $readState.tokens;
  return ((($3)[0] === "$Nil")
    ? ({
      first: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $readState, $rejections),
      second: u0$SPLib$Parser$Rejected$0,
    })
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $token = ($3)[1];
        const $tail = ($3)[2];
        return ({
          first: $rejections,
          second: (u0$SPLib$Parser$Accepted$0.usr)(...(u0$SPLib$Parser$Accepted$0.ctx), ((() => {
            const $0 = $readState;
            return (Object.assign)({}, $0, ({
              tokens: $tail,
            }));
          }))(), $token),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 46:4', (sp_toHuman)($3))));
});

const u0$Compiler$Parser$oneToken$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$oneToken$1,
});

const u0$SPLib$Parser$reject$1 = (($rejections, $readState) => {
  return ({
    first: (sp_cons)($readState, $rejections),
    second: u0$SPLib$Parser$Rejected$0,
  });
});

const u0$SPLib$Parser$reject$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$reject$1,
});

const u0$Compiler$Parser$kind$2 = (($targetKind, $token) => {
  const $2 = $token;
  const $k = ($2)[3];
  return ((sp_equal)($targetKind, $k)
    ? (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $token)
    : u0$SPLib$Parser$reject$0);
});

const u0$Compiler$Parser$kind$1 = (($targetKind) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $targetKind,
    ]),
    usr: u0$Compiler$Parser$kind$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $targetKind,
    ]),
    usr: u0$Compiler$Parser$kind$2,
  })).ctx), u0$Compiler$Parser$oneToken$0);
});

const u0$Compiler$Parser$kind$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$kind$1,
});

const u0$Compiler$Parser$stackCommentsReversedAsStatements$2 = (($comment, $accN) => {
  return (sp_cons)((c0$Compiler$FormattableAst$CommentStatement$0.usr)(...(c0$Compiler$FormattableAst$CommentStatement$0.ctx), $comment), $accN);
});

const u0$Compiler$Parser$stackCommentsReversedAsStatements$1 = (($comments, $acc) => {
  return (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), $acc, $comments, ({
    ctx: [],
    usr: u0$Compiler$Parser$stackCommentsReversedAsStatements$2,
  }));
});

const u0$Compiler$Parser$stackCommentsReversedAsStatements$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$stackCommentsReversedAsStatements$1,
});

const u0$Compiler$Parser$mkLine$1 = (($env, $line) => {
  return ($env.stripLocations
    ? -(1)
    : $line);
});

const u0$Compiler$Parser$mkLine$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$mkLine$1,
});

const u0$Compiler$Parser$pos$1 = (($env, $start, $end) => {
  return ($env.stripLocations
    ? c0$Compiler$Pos$T$0
    : (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), $start, $end));
});

const u0$Compiler$Parser$pos$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$pos$1,
});

const u0$Compiler$Parser$pullCommentsReversed$1 = (($rejections, $rs) => {
  const $readState = (u0$Compiler$Parser$eatComments$0.usr)(...(u0$Compiler$Parser$eatComments$0.ctx), $rs);
  return ({
    first: $rejections,
    second: (u0$SPLib$Parser$Accepted$0.usr)(...(u0$SPLib$Parser$Accepted$0.ctx), ((() => {
      const $0 = $readState;
      return (Object.assign)({}, $0, ({
        commentsReversed: c0$Core$Nil$0,
      }));
    }))(), $readState.commentsReversed),
  });
});

const u0$Compiler$Parser$pullCommentsReversed$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$pullCommentsReversed$1,
});

const u0$Compiler$Parser$binop$3 = (($end, $env, $line, $precedence, $start, $symbol, $usr, $commentsReversed) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    comments: (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $commentsReversed),
    line: (u0$Compiler$Parser$mkLine$0.usr)(...(u0$Compiler$Parser$mkLine$0.ctx), $env, $line),
    pos: (u0$Compiler$Parser$pos$0.usr)(...(u0$Compiler$Parser$pos$0.ctx), $env, $start, $end),
    precedence: $precedence,
    symbol: $symbol,
    usr: $usr,
  }));
});

const u0$Compiler$Parser$binop$2 = (($env, $1) => {
  const $start = ($1)[1];
  const $end = ($1)[2];
  const $k = ($1)[3];
  return ((($k)[0] === "$Binop")
    ? ((() => {
      const $line = ($k)[1];
      const $precedence = ($k)[2].precedence;
      const $symbol = ($k)[2].symbol;
      const $usr = ($k)[2].usr;
      return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
        ctx: ([
          $end,
          $env,
          $line,
          $precedence,
          $start,
          $symbol,
          $usr,
        ]),
        usr: u0$Compiler$Parser$binop$3,
      })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
        ctx: ([
          $end,
          $env,
          $line,
          $precedence,
          $start,
          $symbol,
          $usr,
        ]),
        usr: u0$Compiler$Parser$binop$3,
      })).ctx), u0$Compiler$Parser$pullCommentsReversed$0);
    }))()
    : (true
      ? u0$SPLib$Parser$reject$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 651:4', (sp_toHuman)($k))));
});

const u0$Compiler$Parser$binop$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$binop$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$binop$2,
  })).ctx), u0$Compiler$Parser$oneToken$0);
});

const u0$Compiler$Parser$binop$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$binop$1,
});

const u0$SPLib$Parser$surroundWith$4 = (($p, _0) => {
  return (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), $p);
});

const u0$SPLib$Parser$surroundWith$3 = (($right, $p) => {
  return ((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $p,
    ]),
    usr: u0$SPLib$Parser$surroundWith$4,
  })).usr)(...((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $p,
    ]),
    usr: u0$SPLib$Parser$surroundWith$4,
  })).ctx), $right);
});

const u0$SPLib$Parser$surroundWith$2 = (($parser, $right, _0) => {
  return ((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $right,
    ]),
    usr: u0$SPLib$Parser$surroundWith$3,
  })).usr)(...((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $right,
    ]),
    usr: u0$SPLib$Parser$surroundWith$3,
  })).ctx), $parser);
});

const u0$SPLib$Parser$surroundWith$1 = (($left, $right, $parser) => {
  return ((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $parser,
      $right,
    ]),
    usr: u0$SPLib$Parser$surroundWith$2,
  })).usr)(...((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $parser,
      $right,
    ]),
    usr: u0$SPLib$Parser$surroundWith$2,
  })).ctx), $left);
});

const u0$SPLib$Parser$surroundWith$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$surroundWith$1,
});

const u0$Compiler$Parser$surroundStrict$1 = (($left, $right, $p) => {
  return (u0$SPLib$Parser$surroundWith$0.usr)(...(u0$SPLib$Parser$surroundWith$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), $left), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), $right), $p);
});

const u0$Compiler$Parser$surroundStrict$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$surroundStrict$1,
});

const u0$Compiler$Parser$block$1 = (($0) => {
  return (u0$Compiler$Parser$surroundStrict$0.usr)(...(u0$Compiler$Parser$surroundStrict$0.ctx), c0$Compiler$Token$BlockStart$0, c0$Compiler$Token$BlockEnd$0, $0);
});

const u0$Compiler$Parser$block$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$block$1,
});

const u0$Compiler$Parser$discardFirst$2 = (($b, _0) => {
  return $b;
});

const u0$Compiler$Parser$discardFirst$1 = (($a, $b) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $b,
    ]),
    usr: u0$Compiler$Parser$discardFirst$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $b,
    ]),
    usr: u0$Compiler$Parser$discardFirst$2,
  })).ctx), $a);
});

const u0$Compiler$Parser$discardFirst$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$discardFirst$1,
});

const u0$Compiler$Parser$sib$1 = (($0) => {
  return (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$NewSiblingLine$0), $0);
});

const u0$Compiler$Parser$sib$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$sib$1,
});

const u0$SPLib$Parser$here$1 = (($rejections, $readState) => {
  return ({
    first: $rejections,
    second: (u0$SPLib$Parser$Accepted$0.usr)(...(u0$SPLib$Parser$Accepted$0.ctx), $readState, $readState),
  });
});

const u0$SPLib$Parser$here$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$here$1,
});

const u0$Compiler$Parser$here$1 = (($readState) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ((() => {
    const $2 = $readState.tokens;
    return (((($2)[0] === "$Cons") && ((($2)[1])[0] === "$Token"))
      ? ((() => {
        const $start = (($2)[1])[1];
        const $end = (($2)[1])[2];
        const $rest = ($2)[2];
        return $start;
      }))()
      : ((($2)[0] === "$Nil")
        ? 0
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 77:4', (sp_toHuman)($2))));
  }))());
});

const u0$Compiler$Parser$here$0 = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$Parser$here$1,
})).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$Parser$here$1,
})).ctx), u0$SPLib$Parser$here$0);

const u0$Compiler$Parser$siblingStatements$6 = (($env, $a) => {
  return (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$NewSiblingLine$0), (u0$Compiler$Parser$statementParser$0.usr)(...(u0$Compiler$Parser$statementParser$0.ctx), $env, $a));
});

const u0$Compiler$Parser$siblingStatements$5 = (($env, $reversedStatements, $start, $end) => {
  return (((($reversedStatements)[0] === "$Cons") && (((($reversedStatements)[1])[0] === "$Evaluation") && ((($reversedStatements)[2])[0] === "$Nil")))
    ? ((() => {
      const $e = (($reversedStatements)[1])[1];
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $e);
    }))()
    : (true
      ? ((() => {
        const $many = $reversedStatements;
        return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, (u0$Compiler$Parser$pos$0.usr)(...(u0$Compiler$Parser$pos$0.ctx), $env, $start, $end), (c0$Compiler$FormattableAst$Statements$0.usr)(...(c0$Compiler$FormattableAst$Statements$0.ctx), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $many))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 275:4', (sp_toHuman)($reversedStatements))));
});

const u0$Compiler$Parser$siblingStatements$4 = (($env, $start, $reversedStatements) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $reversedStatements,
      $start,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$5,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $reversedStatements,
      $start,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$5,
  })).ctx), u0$Compiler$Parser$here$0);
});

const u0$Compiler$Parser$siblingStatements$3 = (($env, $start, $acc) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $start,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $start,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$4,
  })).ctx), (u0$Compiler$Parser$forZeroOrMore$0.usr)(...(u0$Compiler$Parser$forZeroOrMore$0.ctx), $acc, ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$6,
  })));
});

const u0$Compiler$Parser$siblingStatements$2 = (($env, $start) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $start,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $start,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$3,
  })).ctx), (u0$Compiler$Parser$statementParser$0.usr)(...(u0$Compiler$Parser$statementParser$0.ctx), $env, c0$Core$Nil$0));
});

const u0$Compiler$Parser$siblingStatements$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$siblingStatements$2,
  })).ctx), u0$Compiler$Parser$here$0);
});

const u0$Compiler$Parser$siblingStatements$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$siblingStatements$1,
});

const u0$SPLib$Parser$oneOf$2 = (($ps, $rejections, $readState) => {
  return ((($ps)[0] === "$Nil")
    ? ({
      first: $rejections,
      second: u0$SPLib$Parser$Rejected$0,
    })
    : ((($ps)[0] === "$Cons")
      ? ((() => {
        const $headParser = ($ps)[1];
        const $tailParsers = ($ps)[2];
        const $3 = ($headParser.usr)(...($headParser.ctx), $rejections, $readState);
        return ((($3.second)[0] === "$Rejected")
          ? ((() => {
            const $re1 = $3.first;
            return ((u0$SPLib$Parser$oneOf$0.usr)(...(u0$SPLib$Parser$oneOf$0.ctx), $tailParsers).usr)(...((u0$SPLib$Parser$oneOf$0.usr)(...(u0$SPLib$Parser$oneOf$0.ctx), $tailParsers).ctx), $re1, $readState);
          }))()
          : (true
            ? ((() => {
              const $acceptedOrAborted = $3;
              return $acceptedOrAborted;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 144:12', (sp_toHuman)($3))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Parser.sp 138:4', (sp_toHuman)($ps))));
});

const u0$SPLib$Parser$oneOf$1 = (($ps) => {
  return ({
    ctx: ([
      $ps,
    ]),
    usr: u0$SPLib$Parser$oneOf$2,
  });
});

const u0$SPLib$Parser$oneOf$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$oneOf$1,
});

const u0$Compiler$Parser$alignedOrInlineStatements$4 = (($e) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: c0$Compiler$FormattableAst$Indented$0,
    second: $e,
  }));
});

const u0$Compiler$Parser$alignedOrInlineStatements$3 = (($e) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: c0$Compiler$FormattableAst$Aligned$0,
    second: $e,
  }));
});

const u0$Compiler$Parser$alignedOrInlineStatements$2 = (($e) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: c0$Compiler$FormattableAst$Inline$0,
    second: $e,
  }));
});

const u0$Compiler$Parser$alignedOrInlineStatements$1 = (($env) => {
  return (u0$SPLib$Parser$oneOf$0.usr)(...(u0$SPLib$Parser$oneOf$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$alignedOrInlineStatements$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$alignedOrInlineStatements$4,
  })).ctx), (u0$Compiler$Parser$block$0.usr)(...(u0$Compiler$Parser$block$0.ctx), (u0$Compiler$Parser$siblingStatements$0.usr)(...(u0$Compiler$Parser$siblingStatements$0.ctx), $env))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$alignedOrInlineStatements$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$alignedOrInlineStatements$3,
  })).ctx), (u0$Compiler$Parser$sib$0.usr)(...(u0$Compiler$Parser$sib$0.ctx), (u0$Compiler$Parser$siblingStatements$0.usr)(...(u0$Compiler$Parser$siblingStatements$0.ctx), $env))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$alignedOrInlineStatements$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$alignedOrInlineStatements$2,
  })).ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)), c0$Core$Nil$0))));
});

const u0$Compiler$Parser$alignedOrInlineStatements$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$alignedOrInlineStatements$1,
});

const u0$Compiler$Parser$discardSecond$3 = (($aa, _0) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $aa);
});

const u0$Compiler$Parser$discardSecond$2 = (($b, $aa) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $aa,
    ]),
    usr: u0$Compiler$Parser$discardSecond$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $aa,
    ]),
    usr: u0$Compiler$Parser$discardSecond$3,
  })).ctx), $b);
});

const u0$Compiler$Parser$discardSecond$1 = (($a, $b) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $b,
    ]),
    usr: u0$Compiler$Parser$discardSecond$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $b,
    ]),
    usr: u0$Compiler$Parser$discardSecond$2,
  })).ctx), $a);
});

const u0$Compiler$Parser$discardSecond$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$discardSecond$1,
});

const u0$Compiler$Parser$indentedOrInlineStatements$1 = (($env) => {
  return (u0$SPLib$Parser$oneOf$0.usr)(...(u0$SPLib$Parser$oneOf$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$block$0.usr)(...(u0$Compiler$Parser$block$0.ctx), (u0$Compiler$Parser$siblingStatements$0.usr)(...(u0$Compiler$Parser$siblingStatements$0.ctx), $env)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env), c0$Core$Nil$0)));
});

const u0$Compiler$Parser$indentedOrInlineStatements$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$indentedOrInlineStatements$1,
});

const u0$Compiler$Parser$inlineOrBelowOrIndented$1 = (($p) => {
  return (u0$SPLib$Parser$oneOf$0.usr)(...(u0$SPLib$Parser$oneOf$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$block$0.usr)(...(u0$Compiler$Parser$block$0.ctx), $p), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$sib$0.usr)(...(u0$Compiler$Parser$sib$0.ctx), $p), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $p, c0$Core$Nil$0))));
});

const u0$Compiler$Parser$inlineOrBelowOrIndented$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$inlineOrBelowOrIndented$1,
});

const u0$SPLib$Parser$maybe$2 = (($x) => {
  return (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $x));
});

const u0$SPLib$Parser$maybe$1 = (($p) => {
  return ((u0$SPLib$Parser$thenWithDefault$0.usr)(...(u0$SPLib$Parser$thenWithDefault$0.ctx), (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), c0$Maybe$Nothing$0), ({
    ctx: [],
    usr: u0$SPLib$Parser$maybe$2,
  })).usr)(...((u0$SPLib$Parser$thenWithDefault$0.usr)(...(u0$SPLib$Parser$thenWithDefault$0.ctx), (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), c0$Maybe$Nothing$0), ({
    ctx: [],
    usr: u0$SPLib$Parser$maybe$2,
  })).ctx), $p);
});

const u0$SPLib$Parser$maybe$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$maybe$1,
});

const u0$Compiler$Parser$maybe$0 = u0$SPLib$Parser$maybe$0;

const u0$Compiler$Parser$maybeNewLine$1 = (($0) => {
  return (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$SPLib$Parser$maybe$0.usr)(...(u0$SPLib$Parser$maybe$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$NewSiblingLine$0)), $0);
});

const u0$Compiler$Parser$maybeNewLine$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$maybeNewLine$1,
});

const u0$SPLib$Parser$zeroOrMore$3 = (($head, $tail) => {
  return (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), (sp_cons)($head, $tail));
});

const u0$SPLib$Parser$zeroOrMore$2 = (($p, $head) => {
  return ((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $head,
    ]),
    usr: u0$SPLib$Parser$zeroOrMore$3,
  })).usr)(...((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), ({
    ctx: ([
      $head,
    ]),
    usr: u0$SPLib$Parser$zeroOrMore$3,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), $p));
});

const u0$SPLib$Parser$zeroOrMore$1 = (($p) => {
  return ((u0$SPLib$Parser$thenWithDefault$0.usr)(...(u0$SPLib$Parser$thenWithDefault$0.ctx), (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), c0$Core$Nil$0), ({
    ctx: ([
      $p,
    ]),
    usr: u0$SPLib$Parser$zeroOrMore$2,
  })).usr)(...((u0$SPLib$Parser$thenWithDefault$0.usr)(...(u0$SPLib$Parser$thenWithDefault$0.ctx), (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), c0$Core$Nil$0), ({
    ctx: ([
      $p,
    ]),
    usr: u0$SPLib$Parser$zeroOrMore$2,
  })).ctx), $p);
});

const u0$SPLib$Parser$zeroOrMore$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$zeroOrMore$1,
});

const u0$Compiler$Parser$oomSeparatedBy$3 = (($head, $tail) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (sp_cons)($head, $tail));
});

const u0$Compiler$Parser$oomSeparatedBy$2 = (($pa, $sep, $head) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $head,
    ]),
    usr: u0$Compiler$Parser$oomSeparatedBy$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $head,
    ]),
    usr: u0$Compiler$Parser$oomSeparatedBy$3,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), $sep, $pa)));
});

const u0$Compiler$Parser$oomSeparatedBy$1 = (($sep, $pa) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $pa,
      $sep,
    ]),
    usr: u0$Compiler$Parser$oomSeparatedBy$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $pa,
      $sep,
    ]),
    usr: u0$Compiler$Parser$oomSeparatedBy$2,
  })).ctx), $pa);
});

const u0$Compiler$Parser$oomSeparatedBy$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$oomSeparatedBy$1,
});

const u0$Compiler$Parser$rawList$1 = (($item) => {
  const $sibsep = (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Comma$0));
  return (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$SPLib$Parser$maybe$0.usr)(...(u0$SPLib$Parser$maybe$0.ctx), $sibsep), (u0$Compiler$Parser$oomSeparatedBy$0.usr)(...(u0$Compiler$Parser$oomSeparatedBy$0.ctx), $sibsep, $item));
});

const u0$Compiler$Parser$rawList$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$rawList$1,
});

const u0$SPLib$Parser$abort$2 = (($error, $rejections, $readState) => {
  return ({
    first: $rejections,
    second: (u0$SPLib$Parser$Aborted$0.usr)(...(u0$SPLib$Parser$Aborted$0.ctx), $readState, $error),
  });
});

const u0$SPLib$Parser$abort$1 = (($error) => {
  return ({
    ctx: ([
      $error,
    ]),
    usr: u0$SPLib$Parser$abort$2,
  });
});

const u0$SPLib$Parser$abort$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$abort$1,
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$38 = (($commentsReversed, $end, $env, $start, $ee) => {
  return ((($ee)[0] === "$E_under")
    ? ((() => {
      const $expr_ = ($ee)[1];
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $commentsReversed), (u0$Compiler$Parser$pos$0.usr)(...(u0$Compiler$Parser$pos$0.ctx), $env, $start, $end), $expr_));
    }))()
    : ((($ee)[0] === "$E_full")
      ? ((() => {
        const $expression = ($ee)[1];
        return ((sp_equal)($commentsReversed, c0$Core$Nil$0)
          ? (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $expression)
          : (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $commentsReversed), (u0$Compiler$Parser$pos$0.usr)(...(u0$Compiler$Parser$pos$0.ctx), $env, $start, $end), (c0$Compiler$FormattableAst$Statements$0.usr)(...(c0$Compiler$FormattableAst$Statements$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$Evaluation$0.usr)(...(c0$Compiler$FormattableAst$Evaluation$0.ctx), $expression), c0$Core$Nil$0)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 545:4', (sp_toHuman)($ee))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$37 = (($attrPath, $expressionOk, $maybeModule, $name, $maybeType) => {
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Lowercase$0.usr)(...(c0$Compiler$FormattableAst$Lowercase$0.ctx), ({
    attrPath: $attrPath,
    maybeModule: $maybeModule,
    maybeType: $maybeType,
    name: $name,
  })));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$36 = (($expressionOk, $isPercent, $s, $maybeUniPoly) => {
  return ($expressionOk.usr)(...($expressionOk.ctx), ((($maybeUniPoly)[0] === "$Nothing")
    ? (c0$Compiler$FormattableAst$LiteralNumber$0.usr)(...(c0$Compiler$FormattableAst$LiteralNumber$0.ctx), $isPercent, $s)
    : ((($maybeUniPoly)[0] === "$Just")
      ? ((() => {
        const $exp = ($maybeUniPoly)[1];
        return (c0$Compiler$FormattableAst$Poly$0.usr)(...(c0$Compiler$FormattableAst$Poly$0.ctx), $s, $exp);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 389:16', (sp_toHuman)($maybeUniPoly)))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$35 = (($e) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (u0$Compiler$Parser$E_full$0.usr)(...(u0$Compiler$Parser$E_full$0.ctx), $e));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$34 = (($expressionOk, $exps, $openRow, $closeRow) => {
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), ($closeRow > $openRow), (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Core$Nil$0, $exps)));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$33 = (($closeBracket, $expressionOk, $openRow, $exps) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $expressionOk,
      $exps,
      $openRow,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$34,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $expressionOk,
      $exps,
      $openRow,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$34,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), $closeBracket));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$32 = (($1) => {
  const $k = ($1)[3];
  return (((($k)[0] === "$SquareBracket") && ((($k)[2])[0] === "$Closed"))
    ? ((() => {
      const $line = ($k)[1];
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $line);
    }))()
    : (true
      ? u0$SPLib$Parser$reject$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 415:20', (sp_toHuman)($k))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$31 = (($exp, $maybeDots) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: (sp_not_equal)($maybeDots, c0$Maybe$Nothing$0),
    second: $exp,
  }));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$30 = (($exp) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $exp,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$31,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $exp,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$31,
  })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$ThreeDots$0)));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$29 = (($attrs, $expressionOk, $maybeExtension, $openRow, $closeRow) => {
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
    attrs: (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Core$Nil$0, $attrs),
    isMultiline: ($closeRow > $openRow),
    maybeExtension: $maybeExtension,
  })));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$28 = (($closeBrace, $expressionOk, $maybeExtension, $openRow, $attrs) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $attrs,
      $expressionOk,
      $maybeExtension,
      $openRow,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$29,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $attrs,
      $expressionOk,
      $maybeExtension,
      $openRow,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$29,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), $closeBrace));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$27 = (($attribute, $closeBrace, $expressionOk, $openRow, $maybeExtension) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $closeBrace,
      $expressionOk,
      $maybeExtension,
      $openRow,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$28,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $closeBrace,
      $expressionOk,
      $maybeExtension,
      $openRow,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$28,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$rawList$0.usr)(...(u0$Compiler$Parser$rawList$0.ctx), $attribute))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$26 = (($1) => {
  const $k = ($1)[3];
  return (((($k)[0] === "$CurlyBrace") && ((($k)[2])[0] === "$Closed"))
    ? ((() => {
      const $line = ($k)[1];
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $line);
    }))()
    : (true
      ? u0$SPLib$Parser$reject$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 441:20', (sp_toHuman)($k))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$25 = (($name, $maybeExpr) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    maybeExpr: $maybeExpr,
    name: $name,
  }));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$24 = (($env, $name) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $name,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$25,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $name,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$25,
  })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Defop$0), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$23 = (($env, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$24,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$24,
  })).ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$22 = (($args, $expressionOk, $1) => {
  const $isMultiline = $1.first;
  const $body = $1.second;
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), $isMultiline, $args, $body));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$21 = (($args, $env, $expressionOk, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $expressionOk,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$22,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $expressionOk,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$22,
  })).ctx), (u0$Compiler$Parser$alignedOrInlineStatements$0.usr)(...(u0$Compiler$Parser$alignedOrInlineStatements$0.ctx), $env));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$20 = (($env, $expressionOk, $args) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $env,
      $expressionOk,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$21,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $env,
      $expressionOk,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$21,
  })).ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Colon$0));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$19 = (($condition, $elseLine, $expressionOk, $ifLine, $true, $1) => {
  const $false = $1.second;
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$If$0.usr)(...(c0$Compiler$FormattableAst$If$0.ctx), ({
    condition: $condition,
    false: $false,
    isMultiline: ($elseLine > $ifLine),
    true: $true,
  })));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$18 = (($condition, $env, $expressionOk, $ifLine, $true, $elseLine) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $elseLine,
      $expressionOk,
      $ifLine,
      $true,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$19,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $elseLine,
      $expressionOk,
      $ifLine,
      $true,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$19,
  })).ctx), (u0$Compiler$Parser$alignedOrInlineStatements$0.usr)(...(u0$Compiler$Parser$alignedOrInlineStatements$0.ctx), $env));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$17 = (($condition, $elseParser, $env, $expressionOk, $ifLine, $1) => {
  const $true = $1.second;
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $env,
      $expressionOk,
      $ifLine,
      $true,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$18,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $env,
      $expressionOk,
      $ifLine,
      $true,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$18,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), $elseParser));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$16 = (($condition, $elseParser, $env, $expressionOk, $ifLine, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $elseParser,
      $env,
      $expressionOk,
      $ifLine,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$17,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $elseParser,
      $env,
      $expressionOk,
      $ifLine,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$17,
  })).ctx), (u0$Compiler$Parser$alignedOrInlineStatements$0.usr)(...(u0$Compiler$Parser$alignedOrInlineStatements$0.ctx), $env));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$15 = (($elseParser, $env, $expressionOk, $ifLine, $condition) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $elseParser,
      $env,
      $expressionOk,
      $ifLine,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$16,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $condition,
      $elseParser,
      $env,
      $expressionOk,
      $ifLine,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$16,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Then$0)));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$14 = (($1) => {
  const $k = ($1)[3];
  return ((($k)[0] === "$Else")
    ? ((() => {
      const $line = ($k)[1];
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $line);
    }))()
    : (true
      ? u0$SPLib$Parser$reject$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 472:20', (sp_toHuman)($k))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$13 = (($expressionOk, $value, $patterns) => {
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Try$0.usr)(...(c0$Compiler$FormattableAst$Try$0.ctx), ({
    patterns: $patterns,
    value: $value,
  })));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$12 = (($expressionOk, $patternAndValue, $value, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $expressionOk,
      $value,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$13,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $expressionOk,
      $value,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$13,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$oomSeparatedBy$0.usr)(...(u0$Compiler$Parser$oomSeparatedBy$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$NewSiblingLine$0), $patternAndValue)));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$11 = (($expressionOk, $patternAndValue, $value) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $expressionOk,
      $patternAndValue,
      $value,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$12,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $expressionOk,
      $patternAndValue,
      $value,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$12,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$As$0)));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$10 = (($p, $value) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: $p,
    second: $value,
  }));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$9 = (($env, $p, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $p,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$10,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $p,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$10,
  })).ctx), (u0$Compiler$Parser$indentedOrInlineStatements$0.usr)(...(u0$Compiler$Parser$indentedOrInlineStatements$0.ctx), $env));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$8 = (($env, $p) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $p,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$9,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $p,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$9,
  })).ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Colon$0));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$7 = (($k) => {
  return (u0$Compiler$Parser$maybeNewLine$0.usr)(...(u0$Compiler$Parser$maybeNewLine$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), $k));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$6 = (($expressionOk, $op, $e) => {
  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), $op, $e));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$5 = (($expressionOk, $introspect, $1) => {
  const $start2 = ($1)[1];
  const $end2 = ($1)[2];
  const $kind2 = ($1)[3];
  const $2 = ({
    first: $introspect,
    second: $kind2,
  });
  return (((($2.first)[0] === "$Type") && (($2.second)[0] === "$Uppercase"))
    ? ((() => {
      const $maybeModule = ($2.second)[1].maybeModule;
      const $name = ($2.second)[1].name;
      return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Introspect$0.usr)(...(c0$Compiler$FormattableAst$Introspect$0.ctx), $introspect, $maybeModule, $name));
    }))()
    : (((($2.first)[0] === "$TypeOpen") && (($2.second)[0] === "$Uppercase"))
      ? ((() => {
        const $maybeModule = ($2.second)[1].maybeModule;
        const $name = ($2.second)[1].name;
        return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Introspect$0.usr)(...(c0$Compiler$FormattableAst$Introspect$0.ctx), $introspect, $maybeModule, $name));
      }))()
      : (((($2.first)[0] === "$Value") && ((($2.second)[0] === "$Lowercase") && ((($2.second)[1].attrPath)[0] === "$Nil")))
        ? ((() => {
          const $maybeModule = ($2.second)[1].maybeModule;
          const $name = ($2.second)[1].name;
          return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Introspect$0.usr)(...(c0$Compiler$FormattableAst$Introspect$0.ctx), $introspect, $maybeModule, $name));
        }))()
        : (true
          ? (u0$SPLib$Parser$abort$0.usr)(...(u0$SPLib$Parser$abort$0.ctx), "innvalid introspect expression")
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 527:16', (sp_toHuman)($2))))));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$4 = (($e) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (u0$Compiler$Parser$E_under$0.usr)(...(u0$Compiler$Parser$E_under$0.ctx), $e));
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$3 = (($commentsReversed, $env, $1) => {
  const $start = ($1)[1];
  const $end = ($1)[2];
  const $kk = ($1)[3];
  const $expressionOk = ({
    ctx: [],
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$4,
  });
  const $b = ((($kk)[0] === "$Lowercase")
    ? ((() => {
      const $attrPath = ($kk)[1].attrPath;
      const $maybeModule = ($kk)[1].maybeModule;
      const $name = ($kk)[1].name;
      return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
        ctx: ([
          $attrPath,
          $expressionOk,
          $maybeModule,
          $name,
        ]),
        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$37,
      })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
        ctx: ([
          $attrPath,
          $expressionOk,
          $maybeModule,
          $name,
        ]),
        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$37,
      })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$As$0), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env))));
    }))()
    : ((($kk)[0] === "$Constructor")
      ? ((() => {
        const $pas = ($kk)[1];
        return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Constructor$0.usr)(...(c0$Compiler$FormattableAst$Constructor$0.ctx), $pas));
      }))()
      : ((($kk)[0] === "$Uppercase")
        ? ((() => {
          const $pas = ($kk)[1];
          return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$Uppercase$0.usr)(...(c0$Compiler$FormattableAst$Uppercase$0.ctx), $pas));
        }))()
        : ((($kk)[0] === "$RecordShorthand")
          ? ((() => {
            const $pas = ($kk)[1];
            return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$RecordShorthand$0.usr)(...(c0$Compiler$FormattableAst$RecordShorthand$0.ctx), $pas));
          }))()
          : ((($kk)[0] === "$ArgumentPlaceholder")
            ? ($expressionOk.usr)(...($expressionOk.ctx), c0$Compiler$FormattableAst$ArgumentPlaceholder$0)
            : ((($kk)[0] === "$NumberLiteral")
              ? ((() => {
                const $isPercent = ($kk)[1];
                const $s = ($kk)[2];
                return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                  ctx: ([
                    $expressionOk,
                    $isPercent,
                    $s,
                  ]),
                  usr: u0$Compiler$Parser$expressionWithUnambiguousStart$36,
                })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                  ctx: ([
                    $expressionOk,
                    $isPercent,
                    $s,
                  ]),
                  usr: u0$Compiler$Parser$expressionWithUnambiguousStart$36,
                })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$discardFirst$0.usr)(...(u0$Compiler$Parser$discardFirst$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$UniquenessPolymorphismBinop$0), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env))));
              }))()
              : ((($kk)[0] === "$TextLiteral")
                ? ((() => {
                  const $singleOrTriple = ($kk)[1];
                  const $s = ($kk)[2];
                  return ($expressionOk.usr)(...($expressionOk.ctx), (c0$Compiler$FormattableAst$LiteralText$0.usr)(...(c0$Compiler$FormattableAst$LiteralText$0.ctx), $singleOrTriple, $s));
                }))()
                : (((($kk)[0] === "$RoundParen") && ((($kk)[1])[0] === "$Open"))
                  ? ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                    ctx: [],
                    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$35,
                  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                    ctx: [],
                    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$35,
                  })).ctx), (u0$Compiler$Parser$discardSecond$0.usr)(...(u0$Compiler$Parser$discardSecond$0.ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), (c0$Compiler$Token$RoundParen$0.usr)(...(c0$Compiler$Token$RoundParen$0.ctx), c0$Compiler$Token$Closed$0)))))
                  : (((($kk)[0] === "$SquareBracket") && ((($kk)[2])[0] === "$Open"))
                    ? ((() => {
                      const $openRow = ($kk)[1];
                      const $item = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                        ctx: [],
                        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$30,
                      })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                        ctx: [],
                        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$30,
                      })).ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env));
                      const $closeBracket = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                        ctx: [],
                        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$32,
                      })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                        ctx: [],
                        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$32,
                      })).ctx), u0$Compiler$Parser$oneToken$0);
                      return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                        ctx: ([
                          $closeBracket,
                          $expressionOk,
                          $openRow,
                        ]),
                        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$33,
                      })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                        ctx: ([
                          $closeBracket,
                          $expressionOk,
                          $openRow,
                        ]),
                        usr: u0$Compiler$Parser$expressionWithUnambiguousStart$33,
                      })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$rawList$0.usr)(...(u0$Compiler$Parser$rawList$0.ctx), $item))));
                    }))()
                    : (((($kk)[0] === "$CurlyBrace") && ((($kk)[2])[0] === "$Open"))
                      ? ((() => {
                        const $openRow = ($kk)[1];
                        const $extension = (u0$Compiler$Parser$discardSecond$0.usr)(...(u0$Compiler$Parser$discardSecond$0.ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$With$0));
                        const $attribute = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: ([
                            $env,
                          ]),
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$23,
                        })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: ([
                            $env,
                          ]),
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$23,
                        })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$NewSiblingLine$0)));
                        const $closeBrace = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: [],
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$26,
                        })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: [],
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$26,
                        })).ctx), u0$Compiler$Parser$oneToken$0);
                        return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: ([
                            $attribute,
                            $closeBrace,
                            $expressionOk,
                            $openRow,
                          ]),
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$27,
                        })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: ([
                            $attribute,
                            $closeBrace,
                            $expressionOk,
                            $openRow,
                          ]),
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$27,
                        })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), $extension)));
                      }))()
                      : ((($kk)[0] === "$Fn")
                        ? ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: ([
                            $env,
                            $expressionOk,
                          ]),
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$20,
                        })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                          ctx: ([
                            $env,
                            $expressionOk,
                          ]),
                          usr: u0$Compiler$Parser$expressionWithUnambiguousStart$20,
                        })).ctx), (u0$Compiler$Parser$rawList$0.usr)(...(u0$Compiler$Parser$rawList$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)))
                        : ((($kk)[0] === "$If")
                          ? ((() => {
                            const $ifLine = ($kk)[1];
                            const $elseParser = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                              ctx: [],
                              usr: u0$Compiler$Parser$expressionWithUnambiguousStart$14,
                            })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                              ctx: [],
                              usr: u0$Compiler$Parser$expressionWithUnambiguousStart$14,
                            })).ctx), u0$Compiler$Parser$oneToken$0);
                            return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                              ctx: ([
                                $elseParser,
                                $env,
                                $expressionOk,
                                $ifLine,
                              ]),
                              usr: u0$Compiler$Parser$expressionWithUnambiguousStart$15,
                            })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                              ctx: ([
                                $elseParser,
                                $env,
                                $expressionOk,
                                $ifLine,
                              ]),
                              usr: u0$Compiler$Parser$expressionWithUnambiguousStart$15,
                            })).ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env));
                          }))()
                          : ((($kk)[0] === "$Try")
                            ? ((() => {
                              const $maybeNewLineKind = ({
                                ctx: [],
                                usr: u0$Compiler$Parser$expressionWithUnambiguousStart$7,
                              });
                              const $patternAndValue = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                ctx: ([
                                  $env,
                                ]),
                                usr: u0$Compiler$Parser$expressionWithUnambiguousStart$8,
                              })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                ctx: ([
                                  $env,
                                ]),
                                usr: u0$Compiler$Parser$expressionWithUnambiguousStart$8,
                              })).ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env));
                              return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                ctx: ([
                                  $expressionOk,
                                  $patternAndValue,
                                ]),
                                usr: u0$Compiler$Parser$expressionWithUnambiguousStart$11,
                              })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                ctx: ([
                                  $expressionOk,
                                  $patternAndValue,
                                ]),
                                usr: u0$Compiler$Parser$expressionWithUnambiguousStart$11,
                              })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)));
                            }))()
                            : ((($kk)[0] === "$Unop")
                              ? ((() => {
                                const $op = ($kk)[1];
                                return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                  ctx: ([
                                    $expressionOk,
                                    $op,
                                  ]),
                                  usr: u0$Compiler$Parser$expressionWithUnambiguousStart$6,
                                })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                  ctx: ([
                                    $expressionOk,
                                    $op,
                                  ]),
                                  usr: u0$Compiler$Parser$expressionWithUnambiguousStart$6,
                                })).ctx), (u0$Compiler$Parser$expressionWithUnambiguousStart$0.usr)(...(u0$Compiler$Parser$expressionWithUnambiguousStart$0.ctx), $env));
                              }))()
                              : ((($kk)[0] === "$This_is_sp_native")
                                ? ($expressionOk.usr)(...($expressionOk.ctx), c0$Compiler$FormattableAst$Native$0)
                                : ((($kk)[0] === "$Sp_introspect")
                                  ? ((() => {
                                    const $introspect = ($kk)[1];
                                    return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                      ctx: ([
                                        $expressionOk,
                                        $introspect,
                                      ]),
                                      usr: u0$Compiler$Parser$expressionWithUnambiguousStart$5,
                                    })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
                                      ctx: ([
                                        $expressionOk,
                                        $introspect,
                                      ]),
                                      usr: u0$Compiler$Parser$expressionWithUnambiguousStart$5,
                                    })).ctx), u0$Compiler$Parser$oneToken$0);
                                  }))()
                                  : (true
                                    ? u0$SPLib$Parser$reject$0
                                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 360:8', (sp_toHuman)($kk)))))))))))))))))));
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $commentsReversed,
      $end,
      $env,
      $start,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$38,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $commentsReversed,
      $end,
      $env,
      $start,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$38,
  })).ctx), $b);
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$2 = (($env, $commentsReversed) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $commentsReversed,
      $env,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $commentsReversed,
      $env,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$3,
  })).ctx), u0$Compiler$Parser$oneToken$0);
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$expressionWithUnambiguousStart$2,
  })).ctx), u0$Compiler$Parser$pullCommentsReversed$0);
});

const u0$Compiler$Parser$expressionWithUnambiguousStart$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$expressionWithUnambiguousStart$1,
});

const u0$Compiler$Parser$posRange$1 = (($exprs) => {
  return ((($exprs)[0] === "$Nil")
    ? c0$Compiler$Pos$G$0
    : (((($exprs)[0] === "$Cons") && ((($exprs)[1])[0] === "$Expression"))
      ? ((() => {
        const $start = (($exprs)[1])[2];
        const $tail = ($exprs)[2];
        const $2 = (c0$List$last$0.usr)(...(c0$List$last$0.ctx), $tail);
        return (((($2)[0] === "$Just") && ((($2)[1])[0] === "$Expression"))
          ? ((() => {
            const $end = (($2)[1])[2];
            return (c0$Compiler$Pos$range$0.usr)(...(c0$Compiler$Pos$range$0.ctx), $start, $end);
          }))()
          : ((($2)[0] === "$Nothing")
            ? $start
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 771:12', (sp_toHuman)($2))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 765:4', (sp_toHuman)($exprs))));
});

const u0$Compiler$Parser$posRange$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$posRange$1,
});

const u0$Compiler$Parser$functionApplication$4 = (($inlineArgs, $ref, $indentedArgs) => {
  const $args = (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $inlineArgs, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Core$Nil$0, $indentedArgs), c0$Core$Nil$0)));
  return ((sp_equal)($args, c0$Core$Nil$0)
    ? (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $ref)
    : ((() => {
      const $p = (u0$Compiler$Parser$posRange$0.usr)(...(u0$Compiler$Parser$posRange$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $ref, $args));
      return (((($ref)[0] === "$Expression") && ((($ref)[3])[0] === "$UnopCall"))
        ? ((() => {
          const $comments = ($ref)[1];
          const $p1 = ($ref)[2];
          const $op = (($ref)[3])[1];
          const $unoped = (($ref)[3])[2];
          return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), $comments, $p1, (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), $op, (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $p, (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), $unoped, $args)))));
        }))()
        : (true
          ? (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $p, (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), $ref, $args)))
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 632:8', (sp_toHuman)($ref))));
    }))());
});

const u0$Compiler$Parser$functionApplication$3 = (($ref, $term, $inlineArgs) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $inlineArgs,
      $ref,
    ]),
    usr: u0$Compiler$Parser$functionApplication$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $inlineArgs,
      $ref,
    ]),
    usr: u0$Compiler$Parser$functionApplication$4,
  })).ctx), (u0$SPLib$Parser$maybe$0.usr)(...(u0$SPLib$Parser$maybe$0.ctx), (u0$Compiler$Parser$block$0.usr)(...(u0$Compiler$Parser$block$0.ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), $term)))));
});

const u0$Compiler$Parser$functionApplication$2 = (($term, $ref) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $ref,
      $term,
    ]),
    usr: u0$Compiler$Parser$functionApplication$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $ref,
      $term,
    ]),
    usr: u0$Compiler$Parser$functionApplication$3,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), $term));
});

const u0$Compiler$Parser$functionApplication$1 = (($env) => {
  const $term = (u0$Compiler$Parser$expressionWithUnambiguousStart$0.usr)(...(u0$Compiler$Parser$expressionWithUnambiguousStart$0.ctx), $env);
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $term,
    ]),
    usr: u0$Compiler$Parser$functionApplication$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $term,
    ]),
    usr: u0$Compiler$Parser$functionApplication$2,
  })).ctx), $term);
});

const u0$Compiler$Parser$functionApplication$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$functionApplication$1,
});

const u0$Compiler$Parser$binopChain$5 = (($left, $rights) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: $left,
    second: $rights,
  }));
});

const u0$Compiler$Parser$binopChain$4 = (($b, $a) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: $b,
    second: $a,
  }));
});

const u0$Compiler$Parser$binopChain$3 = (($app, $b) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $b,
    ]),
    usr: u0$Compiler$Parser$binopChain$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $b,
    ]),
    usr: u0$Compiler$Parser$binopChain$4,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), $app));
});

const u0$Compiler$Parser$binopChain$2 = (($app, $env, $left) => {
  const $binopAndApp = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $app,
    ]),
    usr: u0$Compiler$Parser$binopChain$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $app,
    ]),
    usr: u0$Compiler$Parser$binopChain$3,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$binop$0.usr)(...(u0$Compiler$Parser$binop$0.ctx), $env)));
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $left,
    ]),
    usr: u0$Compiler$Parser$binopChain$5,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $left,
    ]),
    usr: u0$Compiler$Parser$binopChain$5,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), $binopAndApp));
});

const u0$Compiler$Parser$binopChain$1 = (($env) => {
  const $app = (u0$Compiler$Parser$functionApplication$0.usr)(...(u0$Compiler$Parser$functionApplication$0.ctx), $env);
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $app,
      $env,
    ]),
    usr: u0$Compiler$Parser$binopChain$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $app,
      $env,
    ]),
    usr: u0$Compiler$Parser$binopChain$2,
  })).ctx), $app);
});

const u0$Compiler$Parser$binopChain$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$binopChain$1,
});

const u0$Compiler$Parser$chain_append$1 = (($binopAndExpr, $1) => {
  const $left = $1.first;
  const $rights = $1.second;
  return ({
    first: $left,
    second: (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (sp_cons)($binopAndExpr, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $rights))),
  });
});

const u0$Compiler$Parser$chain_append$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$chain_append$1,
});

const u0$Compiler$Parser$blah$3 = (($x) => {
  return $x.second;
});

const u0$Compiler$Parser$blah$2 = (($lowestPrecedence, $1) => {
  const $op = $1.first;
  const $exp = $1.second;
  return ($op.precedence > $lowestPrecedence);
});

const u0$Compiler$Parser$blah$1 = (($lowestPrecedence, $remainingChain, $accChain, $accOp) => {
  const $5 = (c0$List$partitionWhile$0.usr)(...(c0$List$partitionWhile$0.ctx), ({
    ctx: ([
      $lowestPrecedence,
    ]),
    usr: u0$Compiler$Parser$blah$2,
  }), $remainingChain.second);
  const $rest = $5.second;
  const $abovePrecedence = $5.first;
  const $ee = (u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0.usr)(...(u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0.ctx), ({
    first: $remainingChain.first,
    second: $abovePrecedence,
  }));
  const $updatedChain = (u0$Compiler$Parser$chain_append$0.usr)(...(u0$Compiler$Parser$chain_append$0.ctx), ({
    first: $accOp,
    second: $ee,
  }), $accChain);
  return ((($rest)[0] === "$Nil")
    ? ((() => {
      const $p = (u0$Compiler$Parser$posRange$0.usr)(...(u0$Compiler$Parser$posRange$0.ctx), (sp_cons)($updatedChain.first, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
        ctx: [],
        usr: u0$Compiler$Parser$blah$3,
      }), $updatedChain.second)));
      return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $p, (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), $lowestPrecedence, $updatedChain));
    }))()
    : ((($rest)[0] === "$Cons")
      ? ((() => {
        const $op = ($rest)[1].first;
        const $e = ($rest)[1].second;
        const $rem = ($rest)[2];
        return (u0$Compiler$Parser$blah$0.usr)(...(u0$Compiler$Parser$blah$0.ctx), $lowestPrecedence, ({
          first: $e,
          second: $rem,
        }), $updatedChain, $op);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 727:4', (sp_toHuman)($rest))));
});

const u0$Compiler$Parser$blah$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$blah$1,
});

const u0$Compiler$Parser$findLowestPrecedence$2 = (($rec, $chain) => {
  return ($rec.usr)(...($rec.ctx), 1000, $chain.second);
});

const u0$Compiler$Parser$findLowestPrecedence$1 = (($lowest, $exprs) => {
  const $rec = ({
    ctx: [],
    usr: u0$Compiler$Parser$findLowestPrecedence$1,
  });
  return ((($exprs)[0] === "$Nil")
    ? $lowest
    : ((($exprs)[0] === "$Cons")
      ? ((() => {
        const $b = ($exprs)[1].first;
        const $tail = ($exprs)[2];
        return ($rec.usr)(...($rec.ctx), (c0$Basics$min$0.usr)(...(c0$Basics$min$0.ctx), $lowest, $b.precedence), $tail);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 703:8', (sp_toHuman)($exprs))));
});

const u0$Compiler$Parser$findLowestPrecedence$0 = ((() => {
  const $rec = ({
    ctx: [],
    usr: u0$Compiler$Parser$findLowestPrecedence$1,
  });
  return ({
    ctx: ([
      $rec,
    ]),
    usr: u0$Compiler$Parser$findLowestPrecedence$2,
  });
}))();

const u0$Compiler$Parser$reorderAccordingToBinopPrecedence$2 = (($lowestPrecedence, $1) => {
  const $op = $1.first;
  const $exp = $1.second;
  return ($op.precedence > $lowestPrecedence);
});

const u0$Compiler$Parser$reorderAccordingToBinopPrecedence$1 = (($chain) => {
  const $2 = (u0$Compiler$Parser$findLowestPrecedence$0.usr)(...(u0$Compiler$Parser$findLowestPrecedence$0.ctx), $chain);
  return ((1000 === $2)
    ? $chain.first
    : (true
      ? ((() => {
        const $lowestPrecedence = $2;
        const $3 = (c0$List$partitionWhile$0.usr)(...(c0$List$partitionWhile$0.ctx), ({
          ctx: ([
            $lowestPrecedence,
          ]),
          usr: u0$Compiler$Parser$reorderAccordingToBinopPrecedence$2,
        }), $chain.second);
        const $rest = $3.second;
        const $abovePrecedence = $3.first;
        const $left = (u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0.usr)(...(u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0.ctx), ({
          first: $chain.first,
          second: $abovePrecedence,
        }));
        return ((($rest)[0] === "$Nil")
          ? $left
          : ((($rest)[0] === "$Cons")
            ? ((() => {
              const $op = ($rest)[1].first;
              const $ee = ($rest)[1].second;
              const $tail = ($rest)[2];
              return (u0$Compiler$Parser$blah$0.usr)(...(u0$Compiler$Parser$blah$0.ctx), $lowestPrecedence, ({
                first: $ee,
                second: $tail,
              }), ({
                first: $left,
                second: c0$Core$Nil$0,
              }), $op);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 758:12', (sp_toHuman)($rest))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 745:4', (sp_toHuman)($2))));
});

const u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$reorderAccordingToBinopPrecedence$1,
});

const u0$Compiler$Parser$expr$2 = (($x) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0.usr)(...(u0$Compiler$Parser$reorderAccordingToBinopPrecedence$0.ctx), $x));
});

const u0$Compiler$Parser$expr$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$expr$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$expr$2,
  })).ctx), (u0$Compiler$Parser$binopChain$0.usr)(...(u0$Compiler$Parser$binopChain$0.ctx), $env));
});

const u0$Compiler$Parser$expr$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$expr$1,
});

const u0$Compiler$Parser$lowerName$2 = (($env, $1) => {
  const $start = ($1)[1];
  const $end = ($1)[2];
  const $k = ($1)[3];
  return (((($k)[0] === "$Lowercase") && (((($k)[1].attrPath)[0] === "$Nil") && ((($k)[1].maybeModule)[0] === "$Nothing")))
    ? ((() => {
      const $name = ($k)[1].name;
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
        first: (u0$Compiler$Parser$pos$0.usr)(...(u0$Compiler$Parser$pos$0.ctx), $env, $start, $end),
        second: $name,
      }));
    }))()
    : (true
      ? u0$SPLib$Parser$reject$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 185:4', (sp_toHuman)($k))));
});

const u0$Compiler$Parser$lowerName$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$lowerName$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$lowerName$2,
  })).ctx), u0$Compiler$Parser$oneToken$0);
});

const u0$Compiler$Parser$lowerName$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$lowerName$1,
});

const u0$Compiler$Parser$upperName$2 = (($env, $1) => {
  const $start = ($1)[1];
  const $end = ($1)[2];
  const $k = ($1)[3];
  return (((($k)[0] === "$Uppercase") && ((($k)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($k)[1].name;
      return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
        first: (u0$Compiler$Parser$pos$0.usr)(...(u0$Compiler$Parser$pos$0.ctx), $env, $start, $end),
        second: $name,
      }));
    }))()
    : (true
      ? u0$SPLib$Parser$reject$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 194:4', (sp_toHuman)($k))));
});

const u0$Compiler$Parser$upperName$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$upperName$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$upperName$2,
  })).ctx), u0$Compiler$Parser$oneToken$0);
});

const u0$Compiler$Parser$upperName$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$upperName$1,
});

const u0$Compiler$Parser$aliasDef$5 = (($args, $name, $type) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$AliasDef$0.usr)(...(c0$Compiler$FormattableAst$AliasDef$0.ctx), ({
    args: $args,
    name: $name,
    type: $type,
  })));
});

const u0$Compiler$Parser$aliasDef$4 = (($args, $env, $name, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $name,
    ]),
    usr: u0$Compiler$Parser$aliasDef$5,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $name,
    ]),
    usr: u0$Compiler$Parser$aliasDef$5,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env)));
});

const u0$Compiler$Parser$aliasDef$3 = (($env, $name, $args) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$aliasDef$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$aliasDef$4,
  })).ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Defop$0));
});

const u0$Compiler$Parser$aliasDef$2 = (($env, $name) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$aliasDef$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$aliasDef$3,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), (u0$Compiler$Parser$lowerName$0.usr)(...(u0$Compiler$Parser$lowerName$0.ctx), $env)));
});

const u0$Compiler$Parser$aliasDef$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$aliasDef$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$aliasDef$2,
  })).ctx), (u0$Compiler$Parser$upperName$0.usr)(...(u0$Compiler$Parser$upperName$0.ctx), $env));
});

const u0$Compiler$Parser$aliasDef$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$aliasDef$1,
});

const u0$Compiler$Parser$nonFunction$4 = (($names, $1) => {
  const $name = $1.second;
  return ((sp_not_equal)($name, "NonFunction")
    ? (u0$SPLib$Parser$abort$0.usr)(...(u0$SPLib$Parser$abort$0.ctx), "Only NonFunction is supported for now")
    : (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), $names));
});

const u0$Compiler$Parser$nonFunction$3 = (($env, $names) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $names,
    ]),
    usr: u0$Compiler$Parser$nonFunction$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $names,
    ]),
    usr: u0$Compiler$Parser$nonFunction$4,
  })).ctx), (u0$Compiler$Parser$upperName$0.usr)(...(u0$Compiler$Parser$upperName$0.ctx), $env));
});

const u0$Compiler$Parser$nonFunction$2 = (($env, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$nonFunction$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$nonFunction$3,
  })).ctx), (u0$Compiler$Parser$rawList$0.usr)(...(u0$Compiler$Parser$rawList$0.ctx), (u0$Compiler$Parser$lowerName$0.usr)(...(u0$Compiler$Parser$lowerName$0.ctx), $env)));
});

const u0$Compiler$Parser$nonFunction$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$nonFunction$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$nonFunction$2,
  })).ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$With$0));
});

const u0$Compiler$Parser$nonFunction$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$nonFunction$1,
});

const u0$Compiler$Parser$definitionOrEvaluation$6 = (($ex, $maybeDefTail) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ((($maybeDefTail)[0] === "$Nothing")
    ? (c0$Compiler$FormattableAst$Evaluation$0.usr)(...(c0$Compiler$FormattableAst$Evaluation$0.ctx), $ex)
    : ((($maybeDefTail)[0] === "$Just")
      ? ((() => {
        const $maybeNf = ($maybeDefTail)[1].first;
        const $body = ($maybeDefTail)[1].second;
        return (c0$Compiler$FormattableAst$ValueDef$0.usr)(...(c0$Compiler$FormattableAst$ValueDef$0.ctx), ({
          body: $body,
          nonFn: (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Core$Nil$0, $maybeNf),
          pattern: $ex,
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 820:4', (sp_toHuman)($maybeDefTail)))));
});

const u0$Compiler$Parser$definitionOrEvaluation$5 = (($maybeNf, $body) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), ({
    first: $maybeNf,
    second: $body,
  }));
});

const u0$Compiler$Parser$definitionOrEvaluation$4 = (($env, $maybeNf, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $maybeNf,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$5,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $maybeNf,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$5,
  })).ctx), (u0$Compiler$Parser$indentedOrInlineStatements$0.usr)(...(u0$Compiler$Parser$indentedOrInlineStatements$0.ctx), $env));
});

const u0$Compiler$Parser$definitionOrEvaluation$3 = (($env, $maybeNf) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $maybeNf,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $maybeNf,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$4,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Defop$0)));
});

const u0$Compiler$Parser$definitionOrEvaluation$2 = (($env, $ex) => {
  const $definitionTail = ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$3,
  })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$nonFunction$0.usr)(...(u0$Compiler$Parser$nonFunction$0.ctx), $env))));
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $ex,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$6,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $ex,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$6,
  })).ctx), (u0$Compiler$Parser$maybe$0.usr)(...(u0$Compiler$Parser$maybe$0.ctx), $definitionTail));
});

const u0$Compiler$Parser$definitionOrEvaluation$1 = (($env) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$definitionOrEvaluation$2,
  })).ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env));
});

const u0$Compiler$Parser$definitionOrEvaluation$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$definitionOrEvaluation$1,
});

const u0$Compiler$Parser$unionDef$6 = (($args, $name, $constructors) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Compiler$FormattableAst$UnionDef$0.usr)(...(c0$Compiler$FormattableAst$UnionDef$0.ctx), ({
    args: $args,
    constructors: $constructors,
    name: $name,
  })));
});

const u0$Compiler$Parser$unionDef$5 = (($args, $env, $name, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $name,
    ]),
    usr: u0$Compiler$Parser$unionDef$6,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $name,
    ]),
    usr: u0$Compiler$Parser$unionDef$6,
  })).ctx), (u0$Compiler$Parser$inlineOrBelowOrIndented$0.usr)(...(u0$Compiler$Parser$inlineOrBelowOrIndented$0.ctx), (u0$Compiler$Parser$rawList$0.usr)(...(u0$Compiler$Parser$rawList$0.ctx), (u0$Compiler$Parser$expr$0.usr)(...(u0$Compiler$Parser$expr$0.ctx), $env))));
});

const u0$Compiler$Parser$unionDef$4 = (($env, $name, $args) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$unionDef$5,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $args,
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$unionDef$5,
  })).ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$Defop$0));
});

const u0$Compiler$Parser$unionDef$3 = (($env, $name) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$unionDef$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
      $name,
    ]),
    usr: u0$Compiler$Parser$unionDef$4,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), (u0$Compiler$Parser$lowerName$0.usr)(...(u0$Compiler$Parser$lowerName$0.ctx), $env)));
});

const u0$Compiler$Parser$unionDef$2 = (($env, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$unionDef$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$unionDef$3,
  })).ctx), (u0$Compiler$Parser$upperName$0.usr)(...(u0$Compiler$Parser$upperName$0.ctx), $env));
});

const u0$Compiler$Parser$unionDef$1 = (($env) => {
  const $variantKind = (c0$Compiler$Token$Lowercase$0.usr)(...(c0$Compiler$Token$Lowercase$0.ctx), ({
    attrPath: c0$Core$Nil$0,
    maybeModule: c0$Maybe$Nothing$0,
    name: "var",
  }));
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$unionDef$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$unionDef$2,
  })).ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), $variantKind));
});

const u0$Compiler$Parser$unionDef$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$unionDef$1,
});

const u0$SPLib$Parser$breakCircularDefinition$1 = (($a) => {
  return ((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), $a).usr)(...((u0$SPLib$Parser$andThen$0.usr)(...(u0$SPLib$Parser$andThen$0.ctx), $a).ctx), (u0$SPLib$Parser$accept$0.usr)(...(u0$SPLib$Parser$accept$0.ctx), null));
});

const u0$SPLib$Parser$breakCircularDefinition$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$breakCircularDefinition$1,
});

const u0$Compiler$Parser$statementParser$5 = (($acc0, $commentsReversed, $statement) => {
  return (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $statement, (u0$Compiler$Parser$stackCommentsReversedAsStatements$0.usr)(...(u0$Compiler$Parser$stackCommentsReversedAsStatements$0.ctx), $commentsReversed, $acc0)));
});

const u0$Compiler$Parser$statementParser$4 = (($acc0, $env, $commentsReversed) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc0,
      $commentsReversed,
    ]),
    usr: u0$Compiler$Parser$statementParser$5,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc0,
      $commentsReversed,
    ]),
    usr: u0$Compiler$Parser$statementParser$5,
  })).ctx), (u0$SPLib$Parser$oneOf$0.usr)(...(u0$SPLib$Parser$oneOf$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$aliasDef$0.usr)(...(u0$Compiler$Parser$aliasDef$0.ctx), $env), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$unionDef$0.usr)(...(u0$Compiler$Parser$unionDef$0.ctx), $env), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser$definitionOrEvaluation$0.usr)(...(u0$Compiler$Parser$definitionOrEvaluation$0.ctx), $env), c0$Core$Nil$0)))));
});

const u0$Compiler$Parser$statementParser$3 = (($acc0, $env, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc0,
      $env,
    ]),
    usr: u0$Compiler$Parser$statementParser$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc0,
      $env,
    ]),
    usr: u0$Compiler$Parser$statementParser$4,
  })).ctx), u0$Compiler$Parser$pullCommentsReversed$0);
});

const u0$Compiler$Parser$statementParser$2 = (($acc0, $env, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc0,
      $env,
    ]),
    usr: u0$Compiler$Parser$statementParser$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc0,
      $env,
    ]),
    usr: u0$Compiler$Parser$statementParser$3,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$NewSiblingLine$0)));
});

const u0$Compiler$Parser$statementParser$1 = (($env, $acc0) => {
  return (u0$SPLib$Parser$breakCircularDefinition$0.usr)(...(u0$SPLib$Parser$breakCircularDefinition$0.ctx), ({
    ctx: ([
      $acc0,
      $env,
    ]),
    usr: u0$Compiler$Parser$statementParser$2,
  }));
});

const u0$Compiler$Parser$statementParser$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$statementParser$1,
});

const u0$Compiler$Parser$rootStatement$5 = (($env, $0) => {
  return (u0$Compiler$Parser$statementParser$0.usr)(...(u0$Compiler$Parser$statementParser$0.ctx), $env, $0);
});

const u0$Compiler$Parser$rootStatement$4 = (($acc1, $rs) => {
  const $readState = (u0$Compiler$Parser$eatComments$0.usr)(...(u0$Compiler$Parser$eatComments$0.ctx), $rs);
  return ((sp_equal)($readState.tokens, c0$Core$Nil$0)
    ? (u0$Compiler$Parser$ok$0.usr)(...(u0$Compiler$Parser$ok$0.ctx), (u0$Compiler$Parser$stackCommentsReversedAsStatements$0.usr)(...(u0$Compiler$Parser$stackCommentsReversedAsStatements$0.ctx), $readState.commentsReversed, $acc1))
    : u0$SPLib$Parser$reject$0);
});

const u0$Compiler$Parser$rootStatement$3 = (($acc1, _0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc1,
    ]),
    usr: u0$Compiler$Parser$rootStatement$4,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc1,
    ]),
    usr: u0$Compiler$Parser$rootStatement$4,
  })).ctx), u0$SPLib$Parser$here$0);
});

const u0$Compiler$Parser$rootStatement$2 = (($acc1) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc1,
    ]),
    usr: u0$Compiler$Parser$rootStatement$3,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: ([
      $acc1,
    ]),
    usr: u0$Compiler$Parser$rootStatement$3,
  })).ctx), (u0$SPLib$Parser$zeroOrMore$0.usr)(...(u0$SPLib$Parser$zeroOrMore$0.ctx), (u0$Compiler$Parser$kind$0.usr)(...(u0$Compiler$Parser$kind$0.ctx), c0$Compiler$Token$BlockEnd$0)));
});

const u0$Compiler$Parser$rootStatement$1 = (($env, $acc0) => {
  return ((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$rootStatement$2,
  })).usr)(...((u0$Compiler$Parser$on$0.usr)(...(u0$Compiler$Parser$on$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser$rootStatement$2,
  })).ctx), (u0$Compiler$Parser$forZeroOrMore$0.usr)(...(u0$Compiler$Parser$forZeroOrMore$0.ctx), $acc0, ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$rootStatement$5,
  })));
});

const u0$Compiler$Parser$rootStatement$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$rootStatement$1,
});

const u0$SPLib$Parser$runParser$1 = (($parser, $readState) => {
  return ($parser.usr)(...($parser.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $readState, c0$Core$Nil$0), $readState);
});

const u0$SPLib$Parser$runParser$0 = ({
  ctx: [],
  usr: u0$SPLib$Parser$runParser$1,
});

const u0$Compiler$Parser$parse$3 = (($2, _1) => {
  const $endX = ($2)[2];
  return $endX;
});

const u0$Compiler$Parser$parse$2 = (($2, $best) => {
  const $tokens = $2.tokens;
  return (((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $tokens) < (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $best))
    ? $tokens
    : $best);
});

const u0$Compiler$Parser$parse$1 = (($env, $allTokens, $acc) => {
  const $initState = ({
    commentsReversed: c0$Core$Nil$0,
    tokens: $allTokens,
  });
  const $4 = (u0$SPLib$Parser$runParser$0.usr)(...(u0$SPLib$Parser$runParser$0.ctx), (u0$Compiler$Parser$rootStatement$0.usr)(...(u0$Compiler$Parser$rootStatement$0.ctx), $env, $acc), $initState);
  const $outcome = $4.second;
  const $failureStates = $4.first;
  return ((($outcome)[0] === "$Accepted")
    ? ((() => {
      const $readState = ($outcome)[1];
      const $output = ($outcome)[2];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $output);
    }))()
    : ((($outcome)[0] === "$Aborted")
      ? ((() => {
        const $readState = ($outcome)[1];
        const $message = ($outcome)[2];
        return (u0$Compiler$Parser$makeError$0.usr)(...(u0$Compiler$Parser$makeError$0.ctx), $env, $readState.tokens, $message);
      }))()
      : ((($outcome)[0] === "$Rejected")
        ? ((() => {
          const $findMin = ({
            ctx: [],
            usr: u0$Compiler$Parser$parse$2,
          });
          const $farthestParsed = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $allTokens, $failureStates, $findMin);
          const $5 = ({
            first: $farthestParsed,
            second: $allTokens,
          });
          return (((($5.first)[0] === "$Cons") && ((($5.first)[1])[0] === "$Token"))
            ? ((() => {
              const $start = (($5.first)[1])[1];
              const $end = (($5.first)[1])[2];
              const $rest = ($5.first)[2];
              return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $env.errorModule, (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), $start, $end), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I got stuck parsing here. =(", c0$Core$Nil$0));
            }))()
            : (((($5.first)[0] === "$Nil") && ((($5.second)[0] === "$Cons") && ((($5.second)[1])[0] === "$Token")))
              ? ((() => {
                const $start = (($5.second)[1])[1];
                const $end0 = (($5.second)[1])[2];
                const $rest = ($5.second)[2];
                const $end = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $end0, $rest, ({
                  ctx: [],
                  usr: u0$Compiler$Parser$parse$3,
                }));
                return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $env.errorModule, (c0$Compiler$Pos$P$0.usr)(...(c0$Compiler$Pos$P$0.ctx), $start, $end), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I got to the end of the statement and I can't make sense of it. =(", c0$Core$Nil$0));
              }))()
              : (((($5.first)[0] === "$Nil") && (($5.second)[0] === "$Nil"))
                ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), c0$Core$Nil$0)
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 913:12', (sp_toHuman)($5)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 897:4', (sp_toHuman)($outcome)))));
});

const u0$Compiler$Parser$parse$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$parse$1,
});

const u0$Compiler$Parser$textToFormattableModule$3 = (($env, $tokens, $1) => {
  const $es = $1.first;
  const $revStats = $1.second;
  const $3 = (u0$Compiler$Parser$parse$0.usr)(...(u0$Compiler$Parser$parse$0.ctx), $env, $tokens, $revStats);
  return ((($3)[0] === "$Ok")
    ? ((() => {
      const $newReversedStatements = ($3)[1];
      return ({
        first: $es,
        second: $newReversedStatements,
      });
    }))()
    : ((($3)[0] === "$Err")
      ? ((() => {
        const $e = ($3)[1];
        return ({
          first: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $e, $es),
          second: $revStats,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser.sp 939:12', (sp_toHuman)($3))));
});

const u0$Compiler$Parser$textToFormattableModule$2 = (($env, $tokenChunks) => {
  const $2 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
    first: c0$Core$Nil$0,
    second: c0$Core$Nil$0,
  }), $tokenChunks, ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$textToFormattableModule$3,
  }));
  const $reversedStatements = $2.second;
  const $errors = $2.first;
  return ((sp_not_equal)($errors, c0$Core$Nil$0)
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Nested$0.usr)(...(u0$Compiler$Error$Nested$0.ctx), $errors))
    : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $reversedStatements)));
});

const u0$Compiler$Parser$textToFormattableModule$1 = (($env) => {
  const $tokensResult = (u0$Compiler$Lexer$lexer$0.usr)(...(u0$Compiler$Lexer$lexer$0.ctx), $env.keepComments, $env.errorModule);
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$textToFormattableModule$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$Parser$textToFormattableModule$2,
  })).ctx), $tokensResult);
});

const u0$Compiler$Parser$textToFormattableModule$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser$textToFormattableModule$1,
});

const u0$Compiler$MakeCanonical$textToCanonicalModule$2 = (($ro, $faModule) => {
  return (u0$Compiler$MakeCanonical$translateModule$0.usr)(...(u0$Compiler$MakeCanonical$translateModule$0.ctx), $ro, $faModule);
});

const u0$Compiler$MakeCanonical$textToCanonicalModule$1 = (($stripLocations, $ro) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$textToCanonicalModule$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $ro,
    ]),
    usr: u0$Compiler$MakeCanonical$textToCanonicalModule$2,
  })).ctx), (u0$Compiler$Parser$textToFormattableModule$0.usr)(...(u0$Compiler$Parser$textToFormattableModule$0.ctx), ({
    errorModule: $ro.errorModule,
    keepComments: false,
    stripLocations: $stripLocations,
  })));
});

const u0$Compiler$MakeCanonical$textToCanonicalModule$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical$textToCanonicalModule$1,
});

const u0$BuildMain$loadCaModule$7 = (($aliases, $globals, $mod) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ((() => {
    const $0 = $mod;
    return (Object.assign)({}, $0, ({
      umrToAlias: (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Hash$toList$0.usr)(...(c0$Hash$toList$0.ctx), $aliases)),
      usrToGlobal: (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Hash$toList$0.usr)(...(c0$Hash$toList$0.ctx), $globals)),
    }));
  }))());
});

const u0$BuildMain$loadCaModule$6 = (($aliases, $globals, $resolvePars, $pos, $maybeModuleName, $name_) => {
  const $4 = (c0$Compiler$Meta$resolve$0.usr)(...(c0$Compiler$Meta$resolve$0.ctx), ($resolvePars.usr)(...($resolvePars.ctx), $pos), $maybeModuleName, $name_);
  return ((($4)[0] === "$Err")
    ? ((() => {
      const $e = ($4)[1];
      return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), $e);
    }))()
    : ((($4)[0] === "$Ok")
      ? ((() => {
        const $usr = ($4)[1];
        const $5 = $usr;
        const $umr_ = ($5)[1];
        const $__xxx__ = ((($maybeModuleName)[0] === "$Just")
          ? ((() => {
            const $moduleName = ($maybeModuleName)[1];
            return (hash_insert)($aliases, $umr_, $moduleName);
          }))()
          : ((($maybeModuleName)[0] === "$Nothing")
            ? (hash_insert)($globals, $usr, $name_)
            : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 138:24', (sp_toHuman)($maybeModuleName))));
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $usr);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 128:12', (sp_toHuman)($4))));
});

const u0$BuildMain$loadCaModule$5 = (($errorModule, $pos, $0) => {
  return (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), $errorModule, $pos, $0);
});

const u0$BuildMain$loadCaModule$4 = (($errorModule, $imports, $pars, $umr, $pos) => {
  return ({
    currentImports: $imports,
    currentModule: $umr,
    loadExports: $pars.loadExports,
    makeError: ({
      ctx: ([
        $errorModule,
        $pos,
      ]),
      usr: u0$BuildMain$loadCaModule$5,
    }),
  });
});

const u0$BuildMain$loadCaModule$3 = (($fileName, $imports, $pars, $umr, $moduleAsText) => {
  const $errorModule = ({
    content: $moduleAsText,
    fsPath: $fileName,
  });
  const $resolvePars = ({
    ctx: ([
      $errorModule,
      $imports,
      $pars,
      $umr,
    ]),
    usr: u0$BuildMain$loadCaModule$4,
  });
  let $globals = (hash_fromList)(c0$Core$Nil$0);
  let $aliases = (hash_fromList)(c0$Core$Nil$0);
  const $resolveToUsr = ({
    ctx: ([
      $aliases,
      $globals,
      $resolvePars,
    ]),
    usr: u0$BuildMain$loadCaModule$6,
  });
  const $params = ({
    errorModule: $errorModule,
    imports: $imports,
    resolveToUsr: $resolveToUsr,
    umr: $umr,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $aliases,
      $globals,
    ]),
    usr: u0$BuildMain$loadCaModule$7,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $aliases,
      $globals,
    ]),
    usr: u0$BuildMain$loadCaModule$7,
  })).ctx), (u0$Compiler$MakeCanonical$textToCanonicalModule$0.usr)(...(u0$Compiler$MakeCanonical$textToCanonicalModule$0.ctx), false, $params));
});

const u0$BuildMain$loadCaModule$2 = (($importsDir, $modulePath, $pars, $rootDirectory, $sourceDir, $umr, $imports) => {
  const $rootPath = (c0$Compiler$Meta$rootDirectoryToPath$0.usr)(...(c0$Compiler$Meta$rootDirectoryToPath$0.ctx), $pars.rootPaths, $rootDirectory);
  const $fileName = ((path_join)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $rootPath, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $importsDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $sourceDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $modulePath, c0$Core$Nil$0))))) + ".sp");
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $fileName,
      $imports,
      $pars,
      $umr,
    ]),
    usr: u0$BuildMain$loadCaModule$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $fileName,
      $imports,
      $pars,
      $umr,
    ]),
    usr: u0$BuildMain$loadCaModule$3,
  })).ctx), (u0$BuildMain$ioToRes$0.usr)(...(u0$BuildMain$ioToRes$0.ctx), ($pars.readFile.usr)(...($pars.readFile.ctx), $fileName)));
});

const u0$BuildMain$loadCaModule$1 = (($pars, $1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return ((sp_equal)($umr, u0$Compiler$CoreDefs$umr$0)
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), u0$Compiler$CoreDefs$coreModule$0)
    : ((() => {
      const $3 = $umr;
      const $modulePath = ($3)[3];
      const $id = ($3)[2];
      const $rootDirectory = ($3)[1];
      const $4 = ($pars.idToDirs.usr)(...($pars.idToDirs.ctx), $id);
      const $sourceDir = $4.sourceDir;
      const $importsDir = $4.importsDir;
      return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $importsDir,
          $modulePath,
          $pars,
          $rootDirectory,
          $sourceDir,
          $umr,
        ]),
        usr: u0$BuildMain$loadCaModule$2,
      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $importsDir,
          $modulePath,
          $pars,
          $rootDirectory,
          $sourceDir,
          $umr,
        ]),
        usr: u0$BuildMain$loadCaModule$2,
      })).ctx), ($pars.loadImports.usr)(...($pars.loadImports.ctx), (c0$Compiler$Meta$ImportsPath$0.usr)(...(c0$Compiler$Meta$ImportsPath$0.ctx), $rootDirectory, $importsDir)));
    }))());
});

const u0$BuildMain$loadCaModule$0 = ({
  ctx: [],
  usr: u0$BuildMain$loadCaModule$1,
});

const u0$BuildMain$exportsFileName$0 = "exports.sp";

const u0$BuildMain$listSourceDir$5 = (($io, $modulePathWithTrailingSlash, $sourceDirRoot, $subDir) => {
  return (u0$BuildMain$listSourceDir$0.usr)(...(u0$BuildMain$listSourceDir$0.ctx), $io, $sourceDirRoot, (($modulePathWithTrailingSlash + $subDir) + "/"));
});

const u0$BuildMain$listSourceDir$4 = (($directChildren, $descendants) => {
  const $x = (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $directChildren, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), $descendants), c0$Core$Nil$0)));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $x);
});

const u0$BuildMain$listSourceDir$3 = (($modulePathWithTrailingSlash, $fileName) => {
  return ($modulePathWithTrailingSlash + $fileName);
});

const u0$BuildMain$listSourceDir$2 = (($io, $modulePathWithTrailingSlash, $sourceDirRoot, $dirContents) => {
  const $directChildren = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $modulePathWithTrailingSlash,
    ]),
    usr: u0$BuildMain$listSourceDir$3,
  }), (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), u0$BuildMain$asModule$0, $dirContents));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $directChildren,
    ]),
    usr: u0$BuildMain$listSourceDir$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $directChildren,
    ]),
    usr: u0$BuildMain$listSourceDir$4,
  })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
    ctx: ([
      $io,
      $modulePathWithTrailingSlash,
      $sourceDirRoot,
    ]),
    usr: u0$BuildMain$listSourceDir$5,
  }), (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), u0$BuildMain$asModuleDirectory$0, $dirContents)));
});

const u0$BuildMain$listSourceDir$1 = (($io, $sourceDirRoot, $modulePathWithTrailingSlash) => {
  const $path = (($sourceDirRoot + "/") + $modulePathWithTrailingSlash);
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $modulePathWithTrailingSlash,
      $sourceDirRoot,
    ]),
    usr: u0$BuildMain$listSourceDir$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $modulePathWithTrailingSlash,
      $sourceDirRoot,
    ]),
    usr: u0$BuildMain$listSourceDir$2,
  })).ctx), (io_readDir)($io, $path));
});

const u0$BuildMain$listSourceDir$0 = ({
  ctx: [],
  usr: u0$BuildMain$listSourceDir$1,
});

const u0$BuildMain$updateSourceDir$3 = (($name, $m) => {
  return (sp_equal)($m.path, $name);
});

const u0$BuildMain$updateSourceDir$2 = (($name, $sd) => {
  const $3 = (c0$List$find$0.usr)(...(c0$List$find$0.ctx), ({
    ctx: ([
      $name,
    ]),
    usr: u0$BuildMain$updateSourceDir$3,
  }), $sd.modules);
  return ((($3)[0] === "$Just")
    ? $sd
    : ((($3)[0] === "$Nothing")
      ? ((() => {
        const $0 = $sd;
        return (Object.assign)({}, $0, ({
          modules: (sp_cons)(({
            globals: c0$Core$Nil$0,
            path: $name,
            visibleAs: $name,
          }), $0.modules),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 222:8', (sp_toHuman)($3))));
});

const u0$BuildMain$updateSourceDir$1 = (($fileNames, $orig) => {
  const $insertModuleName = ({
    ctx: [],
    usr: u0$BuildMain$updateSourceDir$2,
  });
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $orig, $fileNames, $insertModuleName);
});

const u0$BuildMain$updateSourceDir$0 = ({
  ctx: [],
  usr: u0$BuildMain$updateSourceDir$1,
});

const u0$Compiler$CoreDefs$importsDir$0 = "";

const u0$Compiler$CoreDefs$importsPath$0 = (c0$Compiler$Meta$ImportsPath$0.usr)(...(c0$Compiler$Meta$ImportsPath$0.ctx), c0$Compiler$Meta$Core$0, u0$Compiler$CoreDefs$importsDir$0);

const u0$ImportsFile$insertModules$4 = (($location, $globalName, $dict) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $globalName, $location, $dict);
});

const u0$ImportsFile$insertModules$3 = (($modulePathToLocationFn, $platforms, $module, $imp) => {
  const $location = ($modulePathToLocationFn.usr)(...($modulePathToLocationFn.ctx), $module.path);
  const $moduleAliasToLocation = (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $module.visibleAs, $location, $imp.moduleAliasToLocation);
  const $modulePathToLocation = (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $module.path, $location, $imp.modulePathToLocation);
  const $globalNameToLocation = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $imp.globalNameToLocation, $module.globals, ({
    ctx: ([
      $location,
    ]),
    usr: u0$ImportsFile$insertModules$4,
  }));
  return ({
    globalNameToLocation: $globalNameToLocation,
    moduleAliasToLocation: $moduleAliasToLocation,
    modulePathToLocation: $modulePathToLocation,
    platforms: $platforms,
  });
});

const u0$ImportsFile$insertModules$2 = (($modulePathToLocationFn, $module, $dict) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $module.path, ($modulePathToLocationFn.usr)(...($modulePathToLocationFn.ctx), $module.path), $dict);
});

const u0$ImportsFile$insertModules$1 = (($modulePathToLocationFn, $errors, $platformName, $modules, $imports) => {
  const $platforms = ((sp_equal)($platformName, "")
    ? $imports.platforms
    : (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $platformName, (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $modules, ({
      ctx: ([
        $modulePathToLocationFn,
      ]),
      usr: u0$ImportsFile$insertModules$2,
    })), $imports.platforms));
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $imports, $modules, ({
    ctx: ([
      $modulePathToLocationFn,
      $platforms,
    ]),
    usr: u0$ImportsFile$insertModules$3,
  }));
});

const u0$ImportsFile$insertModules$0 = ({
  ctx: [],
  usr: u0$ImportsFile$insertModules$1,
});

const u0$ImportsFile$parseLibrarySource$1 = (($sourceAsText) => {
  const $2 = (text_split)(":", $sourceAsText);
  return (((($2)[0] === "$Cons") && (("core" === ($2)[1]) && ((($2)[2])[0] === "$Nil")))
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), u0$ImportsFile$Core$0)
    : (((($2)[0] === "$Cons") && (("local" === ($2)[1]) && (((($2)[2])[0] === "$Cons") && (((($2)[2])[2])[0] === "$Nil"))))
      ? ((() => {
        const $path = (($2)[2])[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (u0$ImportsFile$Local$0.usr)(...(u0$ImportsFile$Local$0.ctx), $path));
      }))()
      : (((($2)[0] === "$Cons") && ((($2)[2])[0] === "$Cons"))
        ? ((() => {
          const $protocol = ($2)[1];
          const $address = (($2)[2])[1];
          const $more = (($2)[2])[2];
          return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (u0$ImportsFile$Installed$0.usr)(...(u0$ImportsFile$Installed$0.ctx), ({
            address: (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ":", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $address, $more)),
            protocol: $protocol,
          })));
        }))()
        : (true
          ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ("invalid library source: " + $sourceAsText))
          : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 47:4', (sp_toHuman)($2))))));
});

const u0$ImportsFile$parseLibrarySource$0 = ({
  ctx: [],
  usr: u0$ImportsFile$parseLibrarySource$1,
});

const u0$ImportsFile$insertLibrary$4 = (($0) => {
  return (c0$Compiler$Meta$LocationLibrary$0.usr)(...(c0$Compiler$Meta$LocationLibrary$0.ctx), u0$Compiler$CoreDefs$importsPath$0, $0);
});

const u0$ImportsFile$insertLibrary$3 = (($importsDir, $rootDirectory, $0) => {
  return (c0$Compiler$Meta$LocationLibrary$0.usr)(...(c0$Compiler$Meta$LocationLibrary$0.ctx), (c0$Compiler$Meta$ImportsPath$0.usr)(...(c0$Compiler$Meta$ImportsPath$0.ctx), $rootDirectory, $importsDir), $0);
});

const u0$ImportsFile$insertLibrary$2 = (($importsDir, $0) => {
  return (c0$Compiler$Meta$LocationLibrary$0.usr)(...(c0$Compiler$Meta$LocationLibrary$0.ctx), (c0$Compiler$Meta$ImportsPath$0.usr)(...(c0$Compiler$Meta$ImportsPath$0.ctx), c0$Compiler$Meta$Installed$0, $importsDir), $0);
});

const u0$ImportsFile$insertLibrary$1 = (($pars, $errors, $library, $imports) => {
  const $5 = (u0$ImportsFile$parseLibrarySource$0.usr)(...(u0$ImportsFile$parseLibrarySource$0.ctx), $library.source);
  return ((($5)[0] === "$Err")
    ? ((() => {
      const $msg = ($5)[1];
      (array_push)($errors, $msg);
      return $imports;
    }))()
    : ((($5)[0] === "$Ok")
      ? ((() => {
        const $librarySource = ($5)[1];
        return (u0$ImportsFile$insertModules$0.usr)(...(u0$ImportsFile$insertModules$0.ctx), ((($librarySource)[0] === "$Core")
          ? ({
            ctx: [],
            usr: u0$ImportsFile$insertLibrary$4,
          })
          : ((($librarySource)[0] === "$Local")
            ? ((() => {
              const $libraryDir = ($librarySource)[1];
              const $6 = $pars.importsPath;
              const $currentImportsDir = ($6)[2];
              const $rootDirectory = ($6)[1];
              const $importsDir = ($pars.joinPath.usr)(...($pars.joinPath.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $currentImportsDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $libraryDir, c0$Core$Nil$0)));
              return ({
                ctx: ([
                  $importsDir,
                  $rootDirectory,
                ]),
                usr: u0$ImportsFile$insertLibrary$3,
              });
            }))()
            : ((($librarySource)[0] === "$Installed")
              ? ((() => {
                const $address = ($librarySource)[1].address;
                const $protocol = ($librarySource)[1].protocol;
                const $importsDir = ($pars.joinPath.usr)(...($pars.joinPath.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $protocol, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $address, c0$Core$Nil$0)));
                return ({
                  ctx: ([
                    $importsDir,
                  ]),
                  usr: u0$ImportsFile$insertLibrary$2,
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 127:12', (sp_toHuman)($librarySource))))), $errors, $library.platform, $library.modules, $imports);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 119:4', (sp_toHuman)($5))));
});

const u0$ImportsFile$insertLibrary$0 = ({
  ctx: [],
  usr: u0$ImportsFile$insertLibrary$1,
});

const u0$ImportsFile$insertSourceDir$2 = (($rootDirectory, $sourceDirId, $0) => {
  return (c0$Compiler$Meta$LocationSourceDir$0.usr)(...(c0$Compiler$Meta$LocationSourceDir$0.ctx), (c0$Compiler$Meta$UMR$0.usr)(...(c0$Compiler$Meta$UMR$0.ctx), $rootDirectory, $sourceDirId, $0));
});

const u0$ImportsFile$insertSourceDir$1 = (($pars, $errors, $sourceDir, $imports) => {
  const $5 = $pars.importsPath;
  const $importsDir = ($5)[2];
  const $rootDirectory = ($5)[1];
  const $sourceDirId = ($pars.getSourceDirId.usr)(...($pars.getSourceDirId.ctx), $importsDir, $sourceDir.path);
  const $modulePathToLocation = ({
    ctx: ([
      $rootDirectory,
      $sourceDirId,
    ]),
    usr: u0$ImportsFile$insertSourceDir$2,
  });
  return (u0$ImportsFile$insertModules$0.usr)(...(u0$ImportsFile$insertModules$0.ctx), $modulePathToLocation, $errors, "", $sourceDir.modules, $imports);
});

const u0$ImportsFile$insertSourceDir$0 = ({
  ctx: [],
  usr: u0$ImportsFile$insertSourceDir$1,
});

const u0$ImportsFile$toImports$4 = (($msg) => {
  return (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $msg, c0$Core$Nil$0));
});

const u0$ImportsFile$toImports$3 = (($errors, $pars, $0, $1) => {
  return (u0$ImportsFile$insertLibrary$0.usr)(...(u0$ImportsFile$insertLibrary$0.ctx), $pars, $errors, $0, $1);
});

const u0$ImportsFile$toImports$2 = (($errors, $pars, $0, $1) => {
  return (u0$ImportsFile$insertSourceDir$0.usr)(...(u0$ImportsFile$insertSourceDir$0.ctx), $pars, $errors, $0, $1);
});

const u0$ImportsFile$toImports$1 = (($pars, $importsFile) => {
  let $errors = (array_fromList)(c0$Core$Nil$0);
  const $meta = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Compiler$Meta$initImports$0, $importsFile.libraries, ({
    ctx: ([
      $errors,
      $pars,
    ]),
    usr: u0$ImportsFile$toImports$3,
  })), $importsFile.sourceDirs, ({
    ctx: ([
      $errors,
      $pars,
    ]),
    usr: u0$ImportsFile$toImports$2,
  }));
  const $errs = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$ImportsFile$toImports$4,
  }), (array_toList)($errors));
  return ((sp_equal)($errs, c0$Core$Nil$0)
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $meta)
    : (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Nested$0.usr)(...(u0$Compiler$Error$Nested$0.ctx), $errs)));
});

const u0$ImportsFile$toImports$0 = ({
  ctx: [],
  usr: u0$ImportsFile$toImports$1,
});

const u0$BuildMain$scanSourceDirs$3 = (($importsDir, $io, $rootPath, $sd) => {
  return (u0$BuildMain$listSourceDir$0.usr)(...(u0$BuildMain$listSourceDir$0.ctx), $io, (path_join)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $rootPath, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $importsDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $sd.path, c0$Core$Nil$0)))), "");
});

const u0$BuildMain$scanSourceDirs$2 = (($getSourceDirId, $importsFile, $importsPath, $allSourceDirLists) => {
  const $updatedSourceDirs = (c0$List$map2$0.usr)(...(c0$List$map2$0.ctx), u0$BuildMain$updateSourceDir$0, $allSourceDirLists, $importsFile.sourceDirs);
  return (u0$ImportsFile$toImports$0.usr)(...(u0$ImportsFile$toImports$0.ctx), ({
    getSourceDirId: $getSourceDirId,
    importsPath: $importsPath,
    joinPath: ({
      ctx: [],
      usr: path_join,
    }),
  }), ((() => {
    const $0 = $importsFile;
    return (Object.assign)({}, $0, ({
      sourceDirs: $updatedSourceDirs,
    }));
  }))());
});

const u0$BuildMain$scanSourceDirs$1 = (($io, $getSourceDirId, $rootPaths, $importsPath, $importsFile) => {
  const $6 = $importsPath;
  const $importsDir = ($6)[2];
  const $root = ($6)[1];
  const $rootPath = (c0$Compiler$Meta$rootDirectoryToPath$0.usr)(...(c0$Compiler$Meta$rootDirectoryToPath$0.ctx), $rootPaths, $root);
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $getSourceDirId,
      $importsFile,
      $importsPath,
    ]),
    usr: u0$BuildMain$scanSourceDirs$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $getSourceDirId,
      $importsFile,
      $importsPath,
    ]),
    usr: u0$BuildMain$scanSourceDirs$2,
  })).ctx), (u0$BuildMain$ioToRes$0.usr)(...(u0$BuildMain$ioToRes$0.ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), ({
    ctx: ([
      $importsDir,
      $io,
      $rootPath,
    ]),
    usr: u0$BuildMain$scanSourceDirs$3,
  }), $importsFile.sourceDirs)));
});

const u0$BuildMain$scanSourceDirs$0 = ({
  ctx: [],
  usr: u0$BuildMain$scanSourceDirs$1,
});

const u0$ImportsFile$init$0 = ({
  libraries: c0$Core$Nil$0,
  sourceDirs: c0$Core$Nil$0,
});

const u0$SPLib$SPON$expr$2 = (($aWhat, $getA, $0) => {
  return (((($0)[0] === "$Cons") && (((($0)[1])[0] === "$Evaluation") && (((($0)[1])[1])[0] === "$Expression")))
    ? ((() => {
      const $p = ((($0)[1])[1])[2];
      const $e = ((($0)[1])[1])[3];
      const $tail = ($0)[2];
      const $2 = ($getA.usr)(...($getA.ctx), $e);
      return ((($2)[0] === "$Just")
        ? ((() => {
          const $a = ($2)[1];
          return (u0$SPLib$SPON$Accepted$0.usr)(...(u0$SPLib$SPON$Accepted$0.ctx), $tail, $a);
        }))()
        : ((($2)[0] === "$Nothing")
          ? (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), $p, ("Expecting " + $aWhat)))
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 91:12', (sp_toHuman)($2))));
    }))()
    : (((($0)[0] === "$Cons") && ((($0)[2])[0] === "$Nil"))
      ? ((() => {
        const $s = ($0)[1];
        return (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), (c0$Compiler$FormattableAst$statementPos$0.usr)(...(c0$Compiler$FormattableAst$statementPos$0.ctx), $s), ("Expecting " + $aWhat)));
      }))()
      : (true
        ? (u0$SPLib$SPON$Failed$0.usr)(...(u0$SPLib$SPON$Failed$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), c0$Compiler$Pos$End$0, "Expecting a statement"))
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 88:4', (sp_toHuman)($0)))));
});

const u0$SPLib$SPON$expr$1 = (($aWhat, $getA) => {
  return ({
    ctx: ([
      $aWhat,
      $getA,
    ]),
    usr: u0$SPLib$SPON$expr$2,
  });
});

const u0$SPLib$SPON$expr$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$expr$1,
});

const u0$SPLib$SPON$anyName$1 = (($0) => {
  return (((($0)[0] === "$Lowercase") && (((($0)[1].attrPath)[0] === "$Nil") && (((($0)[1].maybeModule)[0] === "$Nothing") && ((($0)[1].maybeType)[0] === "$Nothing"))))
    ? ((() => {
      const $name = ($0)[1].name;
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name);
    }))()
    : (((($0)[0] === "$Uppercase") && ((($0)[1].maybeModule)[0] === "$Nothing"))
      ? ((() => {
        const $name = ($0)[1].name;
        return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name);
      }))()
      : (((($0)[0] === "$Constructor") && ((($0)[1].maybeModule)[0] === "$Nothing"))
        ? ((() => {
          const $name = ($0)[1].name;
          return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name);
        }))()
        : (true
          ? c0$Maybe$Nothing$0
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 139:4', (sp_toHuman)($0))))));
});

const u0$SPLib$SPON$anyName$0 = (u0$SPLib$SPON$expr$0.usr)(...(u0$SPLib$SPON$expr$0.ctx), "a name", ({
  ctx: [],
  usr: u0$SPLib$SPON$anyName$1,
}));

const u0$SPLib$SPON$expressionToStatements$1 = (($e) => {
  return (((($e)[0] === "$Expression") && (((($e)[3])[0] === "$Statements") && ((((($e)[3])[1])[0] === "$Cons") && (((((($e)[3])[1])[1])[0] === "$Evaluation") && ((((($e)[3])[1])[2])[0] === "$Nil")))))
    ? ((() => {
      const $nested = (((($e)[3])[1])[1])[1];
      return (u0$SPLib$SPON$expressionToStatements$0.usr)(...(u0$SPLib$SPON$expressionToStatements$0.ctx), $nested);
    }))()
    : (((($e)[0] === "$Expression") && ((($e)[3])[0] === "$Statements"))
      ? ((() => {
        const $stats = (($e)[3])[1];
        return $stats;
      }))()
      : (true
        ? (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$Evaluation$0.usr)(...(c0$Compiler$FormattableAst$Evaluation$0.ctx), $e), c0$Core$Nil$0)
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 207:4', (sp_toHuman)($e)))));
});

const u0$SPLib$SPON$expressionToStatements$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$expressionToStatements$1,
});

const u0$SPLib$SPON$field$2 = (($fieldName, $fieldReader, $0) => {
  return (((($0)[0] === "$Cons") && (((($0)[1])[0] === "$ValueDef") && ((((($0)[1])[1].pattern)[0] === "$Expression") && (((((($0)[1])[1].pattern)[3])[0] === "$Lowercase") && ((((((($0)[1])[1].pattern)[3])[1].attrPath)[0] === "$Nil") && ((((((($0)[1])[1].pattern)[3])[1].maybeModule)[0] === "$Nothing") && (((((($0)[1])[1].pattern)[3])[1].maybeType)[0] === "$Nothing")))))))
    ? ((() => {
      const $body = (($0)[1])[1].body;
      const $nonFn = (($0)[1])[1].nonFn;
      const $pos = ((($0)[1])[1].pattern)[2];
      const $name = (((($0)[1])[1].pattern)[3])[1].name;
      const $tail = ($0)[2];
      return ((sp_equal)($name, $fieldName)
        ? ((() => {
          const $2 = ($fieldReader.usr)(...($fieldReader.ctx), (u0$SPLib$SPON$expressionToStatements$0.usr)(...(u0$SPLib$SPON$expressionToStatements$0.ctx), $body));
          return ((($2)[0] === "$Accepted")
            ? ((() => {
              const $unreadStatements = ($2)[1];
              const $a = ($2)[2];
              return ((($unreadStatements)[0] === "$Nil")
                ? (u0$SPLib$SPON$Accepted$0.usr)(...(u0$SPLib$SPON$Accepted$0.ctx), $tail, $a)
                : ((($unreadStatements)[0] === "$Cons")
                  ? ((() => {
                    const $head = ($unreadStatements)[1];
                    return (u0$SPLib$SPON$Failed$0.usr)(...(u0$SPLib$SPON$Failed$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), (c0$Compiler$FormattableAst$statementPos$0.usr)(...(c0$Compiler$FormattableAst$statementPos$0.ctx), $head), (("Could not make sense of all the statements in field `" + $fieldName) + "`.")));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 239:24', (sp_toHuman)($unreadStatements))));
            }))()
            : (true
              ? ((() => {
                const $otherwise = $2;
                return $otherwise;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 236:16', (sp_toHuman)($2))));
        }))()
        : (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), $pos, (("expecting `" + $fieldName) + " =`"))));
    }))()
    : ((($0)[0] === "$Cons")
      ? ((() => {
        const $head = ($0)[1];
        const $tail = ($0)[2];
        return (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), (c0$Compiler$FormattableAst$statementPos$0.usr)(...(c0$Compiler$FormattableAst$statementPos$0.ctx), $head), "missing a simple assignment (ie `something = `)"));
      }))()
      : ((($0)[0] === "$Nil")
        ? (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), c0$Compiler$Pos$End$0, "unexpected end of file"))
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 215:4', (sp_toHuman)($0)))));
});

const u0$SPLib$SPON$field$1 = (($fieldName, $fieldReader) => {
  return ({
    ctx: ([
      $fieldName,
      $fieldReader,
    ]),
    usr: u0$SPLib$SPON$field$2,
  });
});

const u0$SPLib$SPON$field$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$field$1,
});

const u0$SPLib$SPON$many$3 = (($accum, $readerA, $rec, $statements) => {
  return ((sp_equal)($statements, c0$Core$Nil$0)
    ? (u0$SPLib$SPON$Accepted$0.usr)(...(u0$SPLib$SPON$Accepted$0.ctx), c0$Core$Nil$0, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $accum))
    : ((() => {
      const $2 = ($readerA.usr)(...($readerA.ctx), $statements);
      return ((($2)[0] === "$Accepted")
        ? ((() => {
          const $tail = ($2)[1];
          const $a = ($2)[2];
          return (($rec.usr)(...($rec.ctx), (sp_cons)($a, $accum)).usr)(...(($rec.usr)(...($rec.ctx), (sp_cons)($a, $accum)).ctx), $tail);
        }))()
        : ((($2)[0] === "$Rejected")
          ? ((() => {
            const $e = ($2)[1];
            return (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), $e);
          }))()
          : ((($2)[0] === "$Failed")
            ? ((() => {
              const $e = ($2)[1];
              return (u0$SPLib$SPON$Failed$0.usr)(...(u0$SPLib$SPON$Failed$0.ctx), $e);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 187:12', (sp_toHuman)($2)))));
    }))());
});

const u0$SPLib$SPON$many$2 = (($readerA, $accum) => {
  const $rec = ({
    ctx: ([
      $readerA,
    ]),
    usr: u0$SPLib$SPON$many$2,
  });
  return ({
    ctx: ([
      $accum,
      $readerA,
      $rec,
    ]),
    usr: u0$SPLib$SPON$many$3,
  });
});

const u0$SPLib$SPON$many$1 = (($readerA) => {
  const $rec = ({
    ctx: ([
      $readerA,
    ]),
    usr: u0$SPLib$SPON$many$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0);
});

const u0$SPLib$SPON$many$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$many$1,
});

const u0$SPLib$SPON$maybe$2 = (($readerA, $statements) => {
  const $2 = ($readerA.usr)(...($readerA.ctx), $statements);
  return ((($2)[0] === "$Accepted")
    ? ((() => {
      const $tail = ($2)[1];
      const $a = ($2)[2];
      return (u0$SPLib$SPON$Accepted$0.usr)(...(u0$SPLib$SPON$Accepted$0.ctx), $tail, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $a));
    }))()
    : ((($2)[0] === "$Rejected")
      ? (u0$SPLib$SPON$Accepted$0.usr)(...(u0$SPLib$SPON$Accepted$0.ctx), $statements, c0$Maybe$Nothing$0)
      : ((($2)[0] === "$Failed")
        ? ((() => {
          const $r = ($2)[1];
          return (u0$SPLib$SPON$Failed$0.usr)(...(u0$SPLib$SPON$Failed$0.ctx), $r);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 198:4', (sp_toHuman)($2)))));
});

const u0$SPLib$SPON$maybe$1 = (($readerA) => {
  return ({
    ctx: ([
      $readerA,
    ]),
    usr: u0$SPLib$SPON$maybe$2,
  });
});

const u0$SPLib$SPON$maybe$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$maybe$1,
});

const u0$SPLib$SPON$onAcc$3 = (($chainedReaderB, $readerA, $statements) => {
  const $2 = ($readerA.usr)(...($readerA.ctx), $statements);
  return ((($2)[0] === "$Accepted")
    ? ((() => {
      const $newStatements = ($2)[1];
      const $a = ($2)[2];
      return (($chainedReaderB.usr)(...($chainedReaderB.ctx), $a).usr)(...(($chainedReaderB.usr)(...($chainedReaderB.ctx), $a).ctx), $newStatements);
    }))()
    : ((($2)[0] === "$Rejected")
      ? ((() => {
        const $reason = ($2)[1];
        return (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), $reason);
      }))()
      : ((($2)[0] === "$Failed")
        ? ((() => {
          const $reason = ($2)[1];
          return (u0$SPLib$SPON$Failed$0.usr)(...(u0$SPLib$SPON$Failed$0.ctx), $reason);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 20:4', (sp_toHuman)($2)))));
});

const u0$SPLib$SPON$onAcc$2 = (($chainedReaderB, $readerA) => {
  return ({
    ctx: ([
      $chainedReaderB,
      $readerA,
    ]),
    usr: u0$SPLib$SPON$onAcc$3,
  });
});

const u0$SPLib$SPON$onAcc$1 = (($chainedReaderB) => {
  return ({
    ctx: ([
      $chainedReaderB,
    ]),
    usr: u0$SPLib$SPON$onAcc$2,
  });
});

const u0$SPLib$SPON$onAcc$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$onAcc$1,
});

const u0$SPLib$SPON$return$2 = (($a, $statements) => {
  return (u0$SPLib$SPON$Accepted$0.usr)(...(u0$SPLib$SPON$Accepted$0.ctx), $statements, $a);
});

const u0$SPLib$SPON$return$1 = (($a) => {
  return ({
    ctx: ([
      $a,
    ]),
    usr: u0$SPLib$SPON$return$2,
  });
});

const u0$SPLib$SPON$return$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$return$1,
});

const u0$SPLib$SPON$upperName$1 = (($0) => {
  return (((($0)[0] === "$Uppercase") && ((($0)[1].maybeModule)[0] === "$Nothing"))
    ? ((() => {
      const $name = ($0)[1].name;
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name);
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 125:4', (sp_toHuman)($0))));
});

const u0$SPLib$SPON$upperName$0 = (u0$SPLib$SPON$expr$0.usr)(...(u0$SPLib$SPON$expr$0.ctx), "a simple Uppercase name", ({
  ctx: [],
  usr: u0$SPLib$SPON$upperName$1,
}));

const u0$ImportsFile$moduleReader$3 = (($path, $visibleAs, $globals) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), ({
    globals: (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Core$Nil$0, $globals),
    path: $path,
    visibleAs: (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), $path, $visibleAs),
  }));
});

const u0$ImportsFile$moduleReader$2 = (($path, $visibleAs) => {
  return ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
      $visibleAs,
    ]),
    usr: u0$ImportsFile$moduleReader$3,
  })).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
      $visibleAs,
    ]),
    usr: u0$ImportsFile$moduleReader$3,
  })).ctx), (u0$SPLib$SPON$maybe$0.usr)(...(u0$SPLib$SPON$maybe$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "globals", (u0$SPLib$SPON$many$0.usr)(...(u0$SPLib$SPON$many$0.ctx), u0$SPLib$SPON$anyName$0))));
});

const u0$ImportsFile$moduleReader$1 = (($path) => {
  return ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
    ]),
    usr: u0$ImportsFile$moduleReader$2,
  })).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
    ]),
    usr: u0$ImportsFile$moduleReader$2,
  })).ctx), (u0$SPLib$SPON$maybe$0.usr)(...(u0$SPLib$SPON$maybe$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "importAs", u0$SPLib$SPON$upperName$0)));
});

const u0$ImportsFile$moduleReader$0 = ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$moduleReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$moduleReader$1,
})).ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "path", u0$SPLib$SPON$upperName$0));

const u0$SPLib$SPON$lowerName$1 = (($0) => {
  return (((($0)[0] === "$Lowercase") && (((($0)[1].attrPath)[0] === "$Nil") && (((($0)[1].maybeModule)[0] === "$Nothing") && ((($0)[1].maybeType)[0] === "$Nothing"))))
    ? ((() => {
      const $name = ($0)[1].name;
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name);
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 118:4', (sp_toHuman)($0))));
});

const u0$SPLib$SPON$lowerName$0 = (u0$SPLib$SPON$expr$0.usr)(...(u0$SPLib$SPON$expr$0.ctx), "a simple lowercase name", ({
  ctx: [],
  usr: u0$SPLib$SPON$lowerName$1,
}));

const u0$SPLib$SPON$text$1 = (($0) => {
  return ((($0)[0] === "$LiteralText")
    ? ((() => {
      const $t = ($0)[2];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $t);
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 111:4', (sp_toHuman)($0))));
});

const u0$SPLib$SPON$text$0 = (u0$SPLib$SPON$expr$0.usr)(...(u0$SPLib$SPON$expr$0.ctx), "a text literal", ({
  ctx: [],
  usr: u0$SPLib$SPON$text$1,
}));

const u0$ImportsFile$libraryReader$3 = (($platform, $source, $modules) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), ({
    modules: $modules,
    platform: (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), "", $platform),
    source: $source,
  }));
});

const u0$ImportsFile$libraryReader$2 = (($platform, $source) => {
  return ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $platform,
      $source,
    ]),
    usr: u0$ImportsFile$libraryReader$3,
  })).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $platform,
      $source,
    ]),
    usr: u0$ImportsFile$libraryReader$3,
  })).ctx), (u0$SPLib$SPON$many$0.usr)(...(u0$SPLib$SPON$many$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "module", u0$ImportsFile$moduleReader$0)));
});

const u0$ImportsFile$libraryReader$1 = (($platform) => {
  return ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $platform,
    ]),
    usr: u0$ImportsFile$libraryReader$2,
  })).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $platform,
    ]),
    usr: u0$ImportsFile$libraryReader$2,
  })).ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "source", u0$SPLib$SPON$text$0));
});

const u0$ImportsFile$libraryReader$0 = ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$libraryReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$libraryReader$1,
})).ctx), (u0$SPLib$SPON$maybe$0.usr)(...(u0$SPLib$SPON$maybe$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "platform", u0$SPLib$SPON$lowerName$0)));

const u0$ImportsFile$sourceDirectoryReader$2 = (($path, $modules) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), ({
    modules: $modules,
    path: $path,
  }));
});

const u0$ImportsFile$sourceDirectoryReader$1 = (($path) => {
  return ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
    ]),
    usr: u0$ImportsFile$sourceDirectoryReader$2,
  })).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
    ]),
    usr: u0$ImportsFile$sourceDirectoryReader$2,
  })).ctx), (u0$SPLib$SPON$many$0.usr)(...(u0$SPLib$SPON$many$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "module", u0$ImportsFile$moduleReader$0)));
});

const u0$ImportsFile$sourceDirectoryReader$0 = ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$sourceDirectoryReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$sourceDirectoryReader$1,
})).ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "path", u0$SPLib$SPON$text$0));

const u0$SPLib$SPON$oneOf$2 = (($readers, $statements) => {
  return ((($readers)[0] === "$Nil")
    ? ((() => {
      const $pos = ((($statements)[0] === "$Cons")
        ? ((() => {
          const $head = ($statements)[1];
          return (c0$Compiler$FormattableAst$statementPos$0.usr)(...(c0$Compiler$FormattableAst$statementPos$0.ctx), $head);
        }))()
        : (true
          ? c0$Compiler$Pos$End$0
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 159:16', (sp_toHuman)($statements))));
      return (u0$SPLib$SPON$Rejected$0.usr)(...(u0$SPLib$SPON$Rejected$0.ctx), (c0$Compiler$Pos$At$0.usr)(...(c0$Compiler$Pos$At$0.ctx), $pos, "options exhausted"));
    }))()
    : ((($readers)[0] === "$Cons")
      ? ((() => {
        const $headReader = ($readers)[1];
        const $tail = ($readers)[2];
        const $2 = ($headReader.usr)(...($headReader.ctx), $statements);
        return ((($2)[0] === "$Rejected")
          ? ((u0$SPLib$SPON$oneOf$0.usr)(...(u0$SPLib$SPON$oneOf$0.ctx), $tail).usr)(...((u0$SPLib$SPON$oneOf$0.usr)(...(u0$SPLib$SPON$oneOf$0.ctx), $tail).ctx), $statements)
          : (true
            ? ((() => {
              const $otherwise = $2;
              return $otherwise;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 166:12', (sp_toHuman)($2))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 155:4', (sp_toHuman)($readers))));
});

const u0$SPLib$SPON$oneOf$1 = (($readers) => {
  return ({
    ctx: ([
      $readers,
    ]),
    usr: u0$SPLib$SPON$oneOf$2,
  });
});

const u0$SPLib$SPON$oneOf$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$oneOf$1,
});

const u0$ImportsFile$modulesFileReader$2 = (($lib) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), (u0$ImportsFile$Lib$0.usr)(...(u0$ImportsFile$Lib$0.ctx), $lib));
});

const u0$ImportsFile$modulesFileReader$1 = (($dir) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), (u0$ImportsFile$Dir$0.usr)(...(u0$ImportsFile$Dir$0.ctx), $dir));
});

const u0$ImportsFile$modulesFileReader$0 = (u0$SPLib$SPON$many$0.usr)(...(u0$SPLib$SPON$many$0.ctx), (u0$SPLib$SPON$oneOf$0.usr)(...(u0$SPLib$SPON$oneOf$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$modulesFileReader$2,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$modulesFileReader$2,
})).ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "library", u0$ImportsFile$libraryReader$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$modulesFileReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ImportsFile$modulesFileReader$1,
})).ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "sourceDir", u0$ImportsFile$sourceDirectoryReader$0)), c0$Core$Nil$0))));

const u0$SPLib$SPON$run$1 = (($readerA, $errorModule, $statements) => {
  const $4 = ($readerA.usr)(...($readerA.ctx), $statements);
  return (((($4)[0] === "$Accepted") && ((($4)[1])[0] === "$Nil"))
    ? ((() => {
      const $a = ($4)[2];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : (((($4)[0] === "$Accepted") && ((($4)[1])[0] === "$Cons"))
      ? ((() => {
        const $head = (($4)[1])[1];
        const $tail = (($4)[1])[2];
        const $a = ($4)[2];
        return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $errorModule, (c0$Compiler$FormattableAst$statementPos$0.usr)(...(c0$Compiler$FormattableAst$statementPos$0.ctx), $head), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "unread statements", c0$Core$Nil$0));
      }))()
      : (((($4)[0] === "$Rejected") && ((($4)[1])[0] === "$At"))
        ? ((() => {
          const $pos = (($4)[1])[1];
          const $r = (($4)[1])[2];
          return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $errorModule, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $r, c0$Core$Nil$0));
        }))()
        : (((($4)[0] === "$Failed") && ((($4)[1])[0] === "$At"))
          ? ((() => {
            const $pos = (($4)[1])[1];
            const $r = (($4)[1])[2];
            return (u0$Compiler$Error$res$0.usr)(...(u0$Compiler$Error$res$0.ctx), $errorModule, $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $r, c0$Core$Nil$0));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/SPLib/SPON.sp 50:4', (sp_toHuman)($4))))));
});

const u0$SPLib$SPON$run$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$run$1,
});

const u0$SPLib$SPON$read$2 = (($errorModule, $reader, $0) => {
  return (u0$SPLib$SPON$run$0.usr)(...(u0$SPLib$SPON$run$0.ctx), $reader, $errorModule, $0);
});

const u0$SPLib$SPON$read$1 = (($reader, $fsPath, $content) => {
  const $errorModule = ({
    content: $content,
    fsPath: $fsPath,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $errorModule,
      $reader,
    ]),
    usr: u0$SPLib$SPON$read$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $errorModule,
      $reader,
    ]),
    usr: u0$SPLib$SPON$read$2,
  })).ctx), (u0$Compiler$Parser$textToFormattableModule$0.usr)(...(u0$Compiler$Parser$textToFormattableModule$0.ctx), ({
    errorModule: $errorModule,
    keepComments: false,
    stripLocations: false,
  })));
});

const u0$SPLib$SPON$read$0 = ({
  ctx: [],
  usr: u0$SPLib$SPON$read$1,
});

const u0$ImportsFile$fromText$3 = (($insert, $0) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), u0$ImportsFile$init$0, $0, $insert);
});

const u0$ImportsFile$fromText$2 = (($rootEntry, $mf) => {
  return ((($rootEntry)[0] === "$Lib")
    ? ((() => {
      const $lib = ($rootEntry)[1];
      const $0 = $mf;
      return (Object.assign)({}, $0, ({
        libraries: (sp_cons)($lib, $mf.libraries),
      }));
    }))()
    : ((($rootEntry)[0] === "$Dir")
      ? ((() => {
        const $dir = ($rootEntry)[1];
        const $0 = $mf;
        return (Object.assign)({}, $0, ({
          sourceDirs: (sp_cons)($dir, $mf.sourceDirs),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/ImportsFile.sp 240:8', (sp_toHuman)($rootEntry))));
});

const u0$ImportsFile$fromText$1 = (($sponName, $sponContent) => {
  const $insert = ({
    ctx: [],
    usr: u0$ImportsFile$fromText$2,
  });
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), ({
    ctx: ([
      $insert,
    ]),
    usr: u0$ImportsFile$fromText$3,
  }), (u0$SPLib$SPON$read$0.usr)(...(u0$SPLib$SPON$read$0.ctx), u0$ImportsFile$modulesFileReader$0, $sponName, $sponContent));
});

const u0$ImportsFile$fromText$0 = ({
  ctx: [],
  usr: u0$ImportsFile$fromText$1,
});

const u0$BuildMain$loadImports$5 = (($importsPath, $state, $imports) => {
  (hash_insert)($state.loadedImports, $importsPath, $imports);
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $imports);
});

const u0$BuildMain$loadImports$4 = (($getSourceDirId, $importsPath, $io, $rootPaths, $state, $importsFile) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadImports$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadImports$5,
  })).ctx), (u0$BuildMain$scanSourceDirs$0.usr)(...(u0$BuildMain$scanSourceDirs$0.ctx), $io, $getSourceDirId, $rootPaths, $importsPath, $importsFile));
});

const u0$BuildMain$loadImports$3 = (($filePath, $getSourceDirId, $importsPath, $io, $rootPaths, $state, $fileContent) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $getSourceDirId,
      $importsPath,
      $io,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$loadImports$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $getSourceDirId,
      $importsPath,
      $io,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$loadImports$4,
  })).ctx), (u0$ImportsFile$fromText$0.usr)(...(u0$ImportsFile$fromText$0.ctx), $filePath, $fileContent));
});

const u0$BuildMain$loadImports$2 = (($state, $importsDir, $sourceDir) => {
  const $3 = (hash_get)($state.sourcePathToId, ({
    importsDir: $importsDir,
    sourceDir: $sourceDir,
  }));
  return ((($3)[0] === "$Nothing")
    ? ((() => {
      const $id = (basics_cloneUni)($state.nextId);
      ($state.nextId += 1);
      (hash_insert)($state.sourcePathToId, ({
        importsDir: $importsDir,
        sourceDir: $sourceDir,
      }), $id);
      (hash_insert)($state.idToSourcePath, $id, ({
        importsDir: $importsDir,
        sourceDir: $sourceDir,
      }));
      return $id;
    }))()
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $id = ($3)[1];
        return $id;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 307:8', (sp_toHuman)($3))));
});

const u0$BuildMain$loadImports$1 = (($io, $state, $rootPaths, $importsPath) => {
  const $getSourceDirId = ({
    ctx: ([
      $state,
    ]),
    usr: u0$BuildMain$loadImports$2,
  });
  const $5 = (hash_get)($state.loadedImports, $importsPath);
  return ((($5)[0] === "$Just")
    ? ((() => {
      const $imports = ($5)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $imports);
    }))()
    : ((($5)[0] === "$Nothing")
      ? ((() => {
        const $6 = $importsPath;
        const $importsDir = ($6)[2];
        const $rootDirectory = ($6)[1];
        const $filePath = (path_resolve)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Meta$rootDirectoryToPath$0.usr)(...(c0$Compiler$Meta$rootDirectoryToPath$0.ctx), $rootPaths, $rootDirectory), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $importsDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$BuildMain$importsFileName$0, c0$Core$Nil$0))));
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $filePath,
            $getSourceDirId,
            $importsPath,
            $io,
            $rootPaths,
            $state,
          ]),
          usr: u0$BuildMain$loadImports$3,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $filePath,
            $getSourceDirId,
            $importsPath,
            $io,
            $rootPaths,
            $state,
          ]),
          usr: u0$BuildMain$loadImports$3,
        })).ctx), (u0$BuildMain$ioToRes$0.usr)(...(u0$BuildMain$ioToRes$0.ctx), (io_readFile)($io, $filePath)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 324:4', (sp_toHuman)($5))));
});

const u0$BuildMain$loadImports$0 = ({
  ctx: [],
  usr: u0$BuildMain$loadImports$1,
});

const u0$ExportsFile$exposesReader$1 = (($name) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), ({
    name: $name,
    open: true,
  }));
});

const u0$ExportsFile$exposesReader$0 = ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ExportsFile$exposesReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ExportsFile$exposesReader$1,
})).ctx), u0$SPLib$SPON$anyName$0);

const u0$ExportsFile$moduleReader$3 = (($e, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $e.name, $e.open, $d);
});

const u0$ExportsFile$moduleReader$2 = (($path, $maybeExposes) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), ({
    exposes: (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Core$Nil$0, $maybeExposes), ({
      ctx: [],
      usr: u0$ExportsFile$moduleReader$3,
    })),
    path: $path,
  }));
});

const u0$ExportsFile$moduleReader$1 = (($path) => {
  return ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
    ]),
    usr: u0$ExportsFile$moduleReader$2,
  })).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
    ctx: ([
      $path,
    ]),
    usr: u0$ExportsFile$moduleReader$2,
  })).ctx), (u0$SPLib$SPON$maybe$0.usr)(...(u0$SPLib$SPON$maybe$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "exposes", (u0$SPLib$SPON$many$0.usr)(...(u0$SPLib$SPON$many$0.ctx), u0$ExportsFile$exposesReader$0))));
});

const u0$ExportsFile$moduleReader$0 = ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ExportsFile$moduleReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ExportsFile$moduleReader$1,
})).ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "path", u0$SPLib$SPON$upperName$0));

const u0$ExportsFile$exportsFileReader$2 = (($module, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $module.path, $module.exposes, $d);
});

const u0$ExportsFile$exportsFileReader$1 = (($modules) => {
  return (u0$SPLib$SPON$return$0.usr)(...(u0$SPLib$SPON$return$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $modules, ({
    ctx: [],
    usr: u0$ExportsFile$exportsFileReader$2,
  })));
});

const u0$ExportsFile$exportsFileReader$0 = ((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ExportsFile$exportsFileReader$1,
})).usr)(...((u0$SPLib$SPON$onAcc$0.usr)(...(u0$SPLib$SPON$onAcc$0.ctx), ({
  ctx: [],
  usr: u0$ExportsFile$exportsFileReader$1,
})).ctx), (u0$SPLib$SPON$many$0.usr)(...(u0$SPLib$SPON$many$0.ctx), (u0$SPLib$SPON$field$0.usr)(...(u0$SPLib$SPON$field$0.ctx), "module", u0$ExportsFile$moduleReader$0)));

const u0$ExportsFile$fromText$1 = (($0, $1) => {
  return (u0$SPLib$SPON$read$0.usr)(...(u0$SPLib$SPON$read$0.ctx), u0$ExportsFile$exportsFileReader$0, $0, $1);
});

const u0$ExportsFile$fromText$0 = ({
  ctx: [],
  usr: u0$ExportsFile$fromText$1,
});

const u0$ExportsFile$result_withAddError$2 = (($errors, $0) => {
  return (array_push)($errors, $0);
});

const u0$ExportsFile$result_withAddError$1 = (($groupErrors, $collectErrors) => {
  let $errors = (array_fromList)(c0$Core$Nil$0);
  const $addError = ({
    ctx: ([
      $errors,
    ]),
    usr: u0$ExportsFile$result_withAddError$2,
  });
  const $payload = ($collectErrors.usr)(...($collectErrors.ctx), $addError);
  const $errorList = (array_toList)($errors);
  return ((sp_equal)($errorList, c0$Core$Nil$0)
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $payload)
    : (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ($groupErrors.usr)(...($groupErrors.ctx), $errorList)));
});

const u0$ExportsFile$result_withAddError$0 = ({
  ctx: [],
  usr: u0$ExportsFile$result_withAddError$1,
});

const u0$ExportsFile$toExports$6 = (($isOpen, $name, $usr, $0) => {
  return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, ({
    isOpen: $isOpen,
    usr: $usr,
  }), (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Dict$empty$0, $0)));
});

const u0$ExportsFile$toExports$5 = (($modulePath, $umr, $name, $isOpen, $dd) => {
  const $usr = (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $umr, $name);
  const $addNameToModule = ({
    ctx: ([
      $isOpen,
      $name,
      $usr,
    ]),
    usr: u0$ExportsFile$toExports$6,
  });
  return (c0$Dict$update$0.usr)(...(c0$Dict$update$0.ctx), $modulePath, $addNameToModule, $dd);
});

const u0$ExportsFile$toExports$4 = (($addError, $imports, $modulePath, $exposedNames, $d) => {
  const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $modulePath, $imports.modulePathToLocation);
  return ((($4)[0] === "$Nothing")
    ? ((() => {
      ($addError.usr)(...($addError.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("TODO exports refers to a module with path " + $modulePath) + " but that is not in imports."), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $imports.modulePathToLocation)), c0$Core$Nil$0)));
      return $d;
    }))()
    : (((($4)[0] === "$Just") && ((($4)[1])[0] === "$LocationLibrary"))
      ? ((() => {
        const $importsPath = (($4)[1])[1];
        const $modulePath_ = (($4)[1])[2];
        ($addError.usr)(...($addError.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO you can't export modules from a library", c0$Core$Nil$0));
        return $d;
      }))()
      : (((($4)[0] === "$Just") && ((($4)[1])[0] === "$LocationSourceDir"))
        ? ((() => {
          const $umr = (($4)[1])[1];
          return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $d, $exposedNames, ({
            ctx: ([
              $modulePath,
              $umr,
            ]),
            usr: u0$ExportsFile$toExports$5,
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/ExportsFile.sp 53:12', (sp_toHuman)($4)))));
});

const u0$ExportsFile$toExports$3 = (($addError_, $0) => {
  return ($addError_.usr)(...($addError_.ctx), (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), $0));
});

const u0$ExportsFile$toExports$2 = (($exportsFile, $imports, $addError_) => {
  const $addError = ({
    ctx: ([
      $addError_,
    ]),
    usr: u0$ExportsFile$toExports$3,
  });
  return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $exportsFile, ({
    ctx: ([
      $addError,
      $imports,
    ]),
    usr: u0$ExportsFile$toExports$4,
  }));
});

const u0$ExportsFile$toExports$1 = (($imports, $exportsFile) => {
  return (u0$ExportsFile$result_withAddError$0.usr)(...(u0$ExportsFile$result_withAddError$0.ctx), u0$Compiler$Error$Nested$0, ({
    ctx: ([
      $exportsFile,
      $imports,
    ]),
    usr: u0$ExportsFile$toExports$2,
  }));
});

const u0$ExportsFile$toExports$0 = ({
  ctx: [],
  usr: u0$ExportsFile$toExports$1,
});

const u0$BuildMain$loadExports$5 = (($importsPath, $state, $exports) => {
  (hash_insert)($state.loadedExports, $importsPath, $exports);
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $exports);
});

const u0$BuildMain$loadExports$4 = (($imports, $importsPath, $state, $exportsFile) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadExports$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadExports$5,
  })).ctx), (u0$ExportsFile$toExports$0.usr)(...(u0$ExportsFile$toExports$0.ctx), $imports, $exportsFile));
});

const u0$BuildMain$loadExports$3 = (($filePath, $imports, $importsPath, $state, $fileContent) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $imports,
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadExports$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $imports,
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadExports$4,
  })).ctx), (u0$ExportsFile$fromText$0.usr)(...(u0$ExportsFile$fromText$0.ctx), $filePath, $fileContent));
});

const u0$BuildMain$loadExports$2 = (($importsPath, $io, $rootPaths, $state, $imports) => {
  const $2 = $importsPath;
  const $importsDir = ($2)[2];
  const $rootDirectory = ($2)[1];
  const $filePath = (path_resolve)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Meta$rootDirectoryToPath$0.usr)(...(c0$Compiler$Meta$rootDirectoryToPath$0.ctx), $rootPaths, $rootDirectory), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $importsDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$BuildMain$exportsFileName$0, c0$Core$Nil$0))));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $filePath,
      $imports,
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadExports$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $filePath,
      $imports,
      $importsPath,
      $state,
    ]),
    usr: u0$BuildMain$loadExports$3,
  })).ctx), (u0$BuildMain$ioToRes$0.usr)(...(u0$BuildMain$ioToRes$0.ctx), (io_readFile)($io, $filePath)));
});

const u0$BuildMain$loadExports$1 = (($io, $state, $rootPaths, $importsPath) => {
  const $5 = (hash_get)($state.loadedExports, $importsPath);
  return ((($5)[0] === "$Just")
    ? ((() => {
      const $exports = ($5)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $exports);
    }))()
    : ((($5)[0] === "$Nothing")
      ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $importsPath,
          $io,
          $rootPaths,
          $state,
        ]),
        usr: u0$BuildMain$loadExports$2,
      })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
        ctx: ([
          $importsPath,
          $io,
          $rootPaths,
          $state,
        ]),
        usr: u0$BuildMain$loadExports$2,
      })).ctx), (u0$BuildMain$loadImports$0.usr)(...(u0$BuildMain$loadImports$0.ctx), $io, $state, $rootPaths, $importsPath))
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 277:4', (sp_toHuman)($5))));
});

const u0$BuildMain$loadExports$0 = ({
  ctx: [],
  usr: u0$BuildMain$loadExports$1,
});

const u0$BuildMain$searchAncestorDirectories$1 = (($io, $isWantedFile, $searchDir) => {
  const $4 = (io_readDir)($io, $searchDir);
  return ((($4)[0] === "$Err")
    ? c0$Maybe$Nothing$0
    : ((($4)[0] === "$Ok")
      ? ((() => {
        const $dirContents = ($4)[1];
        return ((c0$List$any$0.usr)(...(c0$List$any$0.ctx), $isWantedFile, $dirContents)
          ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $searchDir)
          : ((() => {
            const $parent = (path_resolve)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $searchDir, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "..", c0$Core$Nil$0)));
            return ((sp_equal)($parent, $searchDir)
              ? c0$Maybe$Nothing$0
              : (u0$BuildMain$searchAncestorDirectories$0.usr)(...(u0$BuildMain$searchAncestorDirectories$0.ctx), $io, $isWantedFile, $parent));
          }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 350:4', (sp_toHuman)($4))));
});

const u0$BuildMain$searchAncestorDirectories$0 = ({
  ctx: [],
  usr: u0$BuildMain$searchAncestorDirectories$1,
});

const u0$Compiler$CoreDefs$sourceDir$0 = "src";

const u0$Compiler$LazyBuild$collectUsrDependencies$4 = (($state, $umr, $caModule) => {
  (hash_insert)($state.loadedModulesByUmr, $umr, $caModule);
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $caModule);
});

const u0$Compiler$LazyBuild$collectUsrDependencies$3 = (($state, $u, $c) => {
  return ((sp_equal)((hash_get)($state.done, $u), c0$Maybe$Nothing$0)
    ? (hash_insert)($state.pending, $u, $c)
    : null);
});

const u0$Compiler$LazyBuild$collectUsrDependencies$2 = (($depType, $name, $state, $usr, $caModule) => {
  const $2 = ((($depType)[0] === "$TypeDependency")
    ? ((() => {
      const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $caModule.aliasDefs);
      return ((($3)[0] === "$Just")
        ? ((() => {
          const $d = ($3)[1];
          return ({
            first: (u0$Compiler$LazyBuild$AliasDef$0.usr)(...(u0$Compiler$LazyBuild$AliasDef$0.ctx), $d),
            second: $d.directDeps,
          });
        }))()
        : ((($3)[0] === "$Nothing")
          ? ((() => {
            const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $caModule.variantTypeDefs);
            return ((($4)[0] === "$Just")
              ? ((() => {
                const $d = ($4)[1];
                return ({
                  first: (u0$Compiler$LazyBuild$VariantTypeDef$0.usr)(...(u0$Compiler$LazyBuild$VariantTypeDef$0.ctx), $d),
                  second: c0$Dict$empty$0,
                });
              }))()
              : ((($4)[0] === "$Nothing")
                ? ({
                  first: u0$Compiler$LazyBuild$MissingDef$0,
                  second: c0$Dict$empty$0,
                })
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 78:24', (sp_toHuman)($4))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 72:16', (sp_toHuman)($3))));
    }))()
    : ((($depType)[0] === "$ConstructorDependency")
      ? ((() => {
        const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $caModule.constructorDefs);
        return ((($3)[0] === "$Just")
          ? ((() => {
            const $d = ($3)[1];
            return ({
              first: (u0$Compiler$LazyBuild$ConstructorDef$0.usr)(...(u0$Compiler$LazyBuild$ConstructorDef$0.ctx), $d),
              second: $d.directDeps,
            });
          }))()
          : ((($3)[0] === "$Nothing")
            ? ({
              first: u0$Compiler$LazyBuild$MissingDef$0,
              second: c0$Dict$empty$0,
            })
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 88:16', (sp_toHuman)($3))));
      }))()
      : ((($depType)[0] === "$ValueDependency")
        ? ((() => {
          const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $caModule.valueDefs);
          return ((($3)[0] === "$Just")
            ? ((() => {
              const $d = ($3)[1];
              return ({
                first: (u0$Compiler$LazyBuild$ValueDef$0.usr)(...(u0$Compiler$LazyBuild$ValueDef$0.ctx), $d),
                second: $d.directDeps,
              });
            }))()
            : ((($3)[0] === "$Nothing")
              ? ({
                first: u0$Compiler$LazyBuild$MissingDef$0,
                second: c0$Dict$empty$0,
              })
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 93:16', (sp_toHuman)($3))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 69:8', (sp_toHuman)($depType)))));
  const $deps = $2.second;
  const $def = $2.first;
  (hash_insert)($state.done, $usr, ({
    def: $def,
    deps: $deps,
  }));
  (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $deps, ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$collectUsrDependencies$3,
  }));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null);
});

const u0$Compiler$LazyBuild$collectUsrDependencies$1 = (($env, $state, $usr, $depType) => {
  const $5 = $usr;
  const $name = ($5)[2];
  const $umr = ($5)[1];
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $depType,
      $name,
      $state,
      $usr,
    ]),
    usr: u0$Compiler$LazyBuild$collectUsrDependencies$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $depType,
      $name,
      $state,
      $usr,
    ]),
    usr: u0$Compiler$LazyBuild$collectUsrDependencies$2,
  })).ctx), ((() => {
    const $6 = (hash_get)($state.loadedModulesByUmr, $umr);
    return ((($6)[0] === "$Just")
      ? ((() => {
        const $caModule = ($6)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $caModule);
      }))()
      : ((($6)[0] === "$Nothing")
        ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $state,
            $umr,
          ]),
          usr: u0$Compiler$LazyBuild$collectUsrDependencies$4,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $state,
            $umr,
          ]),
          usr: u0$Compiler$LazyBuild$collectUsrDependencies$4,
        })).ctx), ($env.loadCaModule.usr)(...($env.loadCaModule.ctx), $usr))
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 56:4', (sp_toHuman)($6))));
  }))());
});

const u0$Compiler$LazyBuild$collectUsrDependencies$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$collectUsrDependencies$1,
});

const u0$Compiler$LazyBuild$collectRequiredUsrs$2 = (($env, $state, _0) => {
  return (u0$Compiler$LazyBuild$collectRequiredUsrs$0.usr)(...(u0$Compiler$LazyBuild$collectRequiredUsrs$0.ctx), $env, $state);
});

const u0$Compiler$LazyBuild$collectRequiredUsrs$1 = (($env, $state) => {
  const $3 = (hash_pop)($state.pending);
  return ((($3)[0] === "$Nothing")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null)
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $usr = ($3)[1].first;
        const $depType = ($3)[1].second;
        return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $state,
          ]),
          usr: u0$Compiler$LazyBuild$collectRequiredUsrs$2,
        })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
          ctx: ([
            $env,
            $state,
          ]),
          usr: u0$Compiler$LazyBuild$collectRequiredUsrs$2,
        })).ctx), (u0$Compiler$LazyBuild$collectUsrDependencies$0.usr)(...(u0$Compiler$LazyBuild$collectUsrDependencies$0.ctx), $env, $state, $usr, $depType));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 110:4', (sp_toHuman)($3))));
});

const u0$Compiler$LazyBuild$collectRequiredUsrs$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$collectRequiredUsrs$1,
});

const u0$Compiler$LazyBuild$usrToDependencyType$1 = (($1) => {
  const $umr = ($1)[1];
  const $name = ($1)[2];
  return ((u0$Compiler$Lexer$startsWithUpperChar$0.usr)(...(u0$Compiler$Lexer$startsWithUpperChar$0.ctx), $name)
    ? c0$Compiler$Meta$TypeDependency$0
    : ((text_startsWith)("'", $name)
      ? c0$Compiler$Meta$ConstructorDependency$0
      : c0$Compiler$Meta$ValueDependency$0));
});

const u0$Compiler$LazyBuild$usrToDependencyType$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$usrToDependencyType$1,
});

const u0$Compiler$TypeCheck$nextId$1 = (($last) => {
  ($last.n += 1);
  return (basics_cloneUni)($last.n);
});

const u0$Compiler$TypeCheck$nextId$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$nextId$1,
});

const u0$Compiler$TypeCheck$bug$1 = (($msg) => {
  return (sp_todo)(("Compiler bug: " + $msg));
});

const u0$Compiler$TypeCheck$bug$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$bug$1,
});

const u0$Compiler$TypeCheck$expandTyvarsInType$4 = (($rec, $k, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const u0$Compiler$TypeCheck$expandTyvarsInType$3 = (($rec, $k, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const u0$Compiler$TypeCheck$expandTyvarsInType$2 = (($newLambdaSet, $tyvarIdsToType, $0) => {
  return (u0$Compiler$TypeCheck$expandTyvarsInType$0.usr)(...(u0$Compiler$TypeCheck$expandTyvarsInType$0.ctx), $newLambdaSet, $tyvarIdsToType, $0);
});

const u0$Compiler$TypeCheck$expandTyvarsInType$1 = (($newLambdaSet, $tyvarIdsToType, $type) => {
  const $rec = ({
    ctx: ([
      $newLambdaSet,
      $tyvarIdsToType,
    ]),
    usr: u0$Compiler$TypeCheck$expandTyvarsInType$2,
  });
  return ((($type)[0] === "$TypeExact")
    ? ((() => {
      const $p = ($type)[1];
      const $usr = ($type)[2];
      const $args = ($type)[3];
      return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), $p, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $rec, $args));
    }))()
    : ((($type)[0] === "$TypeFn")
      ? ((() => {
        const $p = ($type)[1];
        const $ins = ($type)[3];
        const $out = ($type)[4];
        return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $p, ($newLambdaSet.usr)(...($newLambdaSet.ctx), null), (c0$Compiler$TypedAst$mapPars$0.usr)(...(c0$Compiler$TypedAst$mapPars$0.ctx), $rec, $ins), ((() => {
          const $0 = $out;
          return (Object.assign)({}, $0, ({
            raw: ($rec.usr)(...($rec.ctx), $0.raw),
          }));
        }))());
      }))()
      : (((($type)[0] === "$TypeRecord") && ((($type)[2])[0] === "$Nothing"))
        ? ((() => {
          const $p = ($type)[1];
          const $attrs = ($type)[3];
          return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, c0$Maybe$Nothing$0, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
            ctx: ([
              $rec,
            ]),
            usr: u0$Compiler$TypeCheck$expandTyvarsInType$4,
          }), $attrs));
        }))()
        : ((($type)[0] === "$TypeVar")
          ? ((() => {
            const $p = ($type)[1];
            const $id = ($type)[2];
            const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $id, $tyvarIdsToType);
            return ((($4)[0] === "$Nothing")
              ? (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), "this is not supposed to happen")
              : ((($4)[0] === "$Just")
                ? ((() => {
                  const $ty = ($4)[1];
                  return $ty;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 538:12', (sp_toHuman)($4))));
          }))()
          : (((($type)[0] === "$TypeRecord") && ((($type)[2])[0] === "$Just"))
            ? ((() => {
              const $p = ($type)[1];
              const $id = (($type)[2])[1];
              const $attrs = ($type)[3];
              return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $id), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                ctx: ([
                  $rec,
                ]),
                usr: u0$Compiler$TypeCheck$expandTyvarsInType$3,
              }), $attrs));
            }))()
            : ((($type)[0] === "$TypeError")
              ? c0$Compiler$TypedAst$TypeError$0
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 526:4', (sp_toHuman)($type))))))));
});

const u0$Compiler$TypeCheck$expandTyvarsInType$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$expandTyvarsInType$1,
});

const u0$Compiler$TypeCheck$getErrorModule$1 = (($env) => {
  const $2 = $env.currentRootUsr;
  const $umr = ($2)[1];
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $env.modulesByUmr);
  return ((($3)[0] === "$Nothing")
    ? ({
      content: "",
      fsPath: "N/A",
    })
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $content = ($3)[1].asText;
        const $fsPath = ($3)[1].fsPath;
        return ({
          content: $content,
          fsPath: $fsPath,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 334:4', (sp_toHuman)($3))));
});

const u0$Compiler$TypeCheck$getErrorModule$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getErrorModule$1,
});

const u0$Compiler$TypeCheck$translateUni$1 = (($originalIdToNewId, $originalUni) => {
  return ((($originalUni)[0] === "$Depends")
    ? ((() => {
      const $originalId = ($originalUni)[1];
      const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $originalId, $originalIdToNewId);
      return ((($3)[0] === "$Just")
        ? ((() => {
          const $newId = ($3)[1];
          return (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), $newId);
        }))()
        : ((($3)[0] === "$Nothing")
          ? $originalUni
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 555:12', (sp_toHuman)($3))));
    }))()
    : (true
      ? $originalUni
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 552:4', (sp_toHuman)($originalUni))));
});

const u0$Compiler$TypeCheck$translateUni$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$translateUni$1,
});

const u0$Compiler$TypeCheck$translateFullType$1 = (($pars, $caFull) => {
  return ({
    raw: (u0$Compiler$TypeCheck$translateRawType$0.usr)(...(u0$Compiler$TypeCheck$translateRawType$0.ctx), $pars, $caFull.raw),
    uni: (u0$Compiler$TypeCheck$translateUni$0.usr)(...(u0$Compiler$TypeCheck$translateUni$0.ctx), $pars.originalIdToNewId, $caFull.uni),
  });
});

const u0$Compiler$TypeCheck$translateFullType$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$translateFullType$1,
});

const u0$Compiler$TypeCheck$translateRawType$7 = (($pars, $rec, $caPar) => {
  return ((($caPar)[0] === "$ParRe")
    ? ((() => {
      const $caRaw = ($caPar)[1];
      return (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), ($rec.usr)(...($rec.ctx), $caRaw));
    }))()
    : ((($caPar)[0] === "$ParSp")
      ? ((() => {
        const $caFull = ($caPar)[1];
        return (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), (u0$Compiler$TypeCheck$translateFullType$0.usr)(...(u0$Compiler$TypeCheck$translateFullType$0.ctx), $pars, $caFull));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 603:20', (sp_toHuman)($caPar))));
});

const u0$Compiler$TypeCheck$translateRawType$6 = (($rec, $name, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const u0$Compiler$TypeCheck$translateRawType$5 = (($pars, $0) => {
  return (u0$Compiler$TypeCheck$translateRawType$0.usr)(...(u0$Compiler$TypeCheck$translateRawType$0.ctx), $pars, $0);
});

const u0$Compiler$TypeCheck$translateRawType$4 = ((_0) => {
  return 0;
});

const u0$Compiler$TypeCheck$translateRawType$3 = (($pars, $0) => {
  return ((c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$translateRawType$4,
  }), $pars.newLambdaSetId).usr)(...((c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$translateRawType$4,
  }), $pars.newLambdaSetId).ctx), $0);
});

const u0$Compiler$TypeCheck$translateRawType$2 = (($pars, $pos, $error) => {
  return ($pars.pushError.usr)(...($pars.pushError.ctx), (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), (u0$Compiler$TypeCheck$getErrorModule$0.usr)(...(u0$Compiler$TypeCheck$getErrorModule$0.ctx), $pars.env), $pos, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $error, c0$Core$Nil$0)));
});

const u0$Compiler$TypeCheck$translateRawType$1 = (($pars, $caType) => {
  const $addErr = ({
    ctx: ([
      $pars,
    ]),
    usr: u0$Compiler$TypeCheck$translateRawType$2,
  });
  const $newLambdaSet = ({
    ctx: ([
      $pars,
    ]),
    usr: u0$Compiler$TypeCheck$translateRawType$3,
  });
  const $rec = ({
    ctx: ([
      $pars,
    ]),
    usr: u0$Compiler$TypeCheck$translateRawType$5,
  });
  return ((($caType)[0] === "$TypeFn")
    ? ((() => {
      const $pos = ($caType)[1];
      const $caPars = ($caType)[2];
      const $caOut = ($caType)[3];
      const $zzz = ({
        ctx: ([
          $pars,
          $rec,
        ]),
        usr: u0$Compiler$TypeCheck$translateRawType$7,
      });
      const $taArgs = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $zzz, $caPars);
      return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $pos, ($newLambdaSet.usr)(...($newLambdaSet.ctx), null), $taArgs, (u0$Compiler$TypeCheck$translateFullType$0.usr)(...(u0$Compiler$TypeCheck$translateFullType$0.ctx), $pars, $caOut));
    }))()
    : ((($caType)[0] === "$TypeRecord")
      ? ((() => {
        const $pos = ($caType)[1];
        const $caAttrs = ($caType)[2];
        return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $pos, c0$Maybe$Nothing$0, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
          ctx: ([
            $rec,
          ]),
          usr: u0$Compiler$TypeCheck$translateRawType$6,
        }), $caAttrs));
      }))()
      : ((($caType)[0] === "$TypeAnnotationVariable")
        ? ((() => {
          const $pos = ($caType)[1];
          const $name = ($caType)[2];
          const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $pars.argsByName);
          return ((($3)[0] === "$Nothing")
            ? ((() => {
              ($addErr.usr)(...($addErr.ctx), $pos, ("Undeclared type variable: " + $name));
              return c0$Compiler$TypedAst$TypeError$0;
            }))()
            : ((($3)[0] === "$Just")
              ? ((() => {
                const $raw = ($3)[1];
                return $raw;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 616:12', (sp_toHuman)($3))));
        }))()
        : ((($caType)[0] === "$TypeNamed")
          ? ((() => {
            const $pos = ($caType)[1];
            const $usr = ($caType)[2];
            const $args = ($caType)[3];
            const $expandedPars = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $rec, $args);
            const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $pars.env.expandedAliases);
            return ((($3)[0] === "$Nothing")
              ? ((() => {
                const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $pars.env.exactTypes);
                return ((($4)[0] === "$Just")
                  ? ((() => {
                    const $exact = ($4)[1];
                    return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), $pos, $usr, $expandedPars);
                  }))()
                  : ((($4)[0] === "$Nothing")
                    ? ((() => {
                      ($addErr.usr)(...($addErr.ctx), $pos, ("Type not found: " + (sp_toHuman)($usr)));
                      return c0$Compiler$TypedAst$TypeError$0;
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 633:20', (sp_toHuman)($4))));
              }))()
              : ((($3)[0] === "$Just")
                ? ((() => {
                  const $expandedAlias = ($3)[1];
                  return ((sp_not_equal)((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $expandedAlias.pars), (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $expandedPars))
                    ? ((() => {
                      ($addErr.usr)(...($addErr.ctx), $pos, ("Wrong number of type arguments for " + (sp_toHuman)($usr)));
                      return c0$Compiler$TypedAst$TypeError$0;
                    }))()
                    : ((() => {
                      const $tyvarIdsToType = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$List$map2$0.usr)(...(c0$List$map2$0.ctx), c0$Tuple$pair$0, $expandedAlias.pars, $expandedPars));
                      return (u0$Compiler$TypeCheck$expandTyvarsInType$0.usr)(...(u0$Compiler$TypeCheck$expandTyvarsInType$0.ctx), $newLambdaSet, $tyvarIdsToType, $expandedAlias.type);
                    }))());
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 630:12', (sp_toHuman)($3))));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 598:4', (sp_toHuman)($caType))))));
});

const u0$Compiler$TypeCheck$translateRawType$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$translateRawType$1,
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$6 = (($errors, $0) => {
  return (array_push)($errors, $0);
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$5 = (($lastLambdaSetId, _0) => {
  return (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $lastLambdaSetId);
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$4 = (($id, _1) => {
  return ({
    annotatedId: $id,
  });
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$3 = (($index, $1) => {
  const $name = $1.first;
  const $nonFn = $1.second.nonFn;
  return ({
    first: $index,
    second: ({
      maybeAnnotated: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
        allowFunctions: (sp_not_equal)($nonFn, c0$Maybe$Nothing$0),
        name: $name,
      })),
    }),
  });
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$2 = (($pos, $index, $name) => {
  return ({
    first: $name,
    second: (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $pos, $index),
  });
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$1 = (($errors, $pos, $usr, $annotation, $env) => {
  let $lastLambdaSetId = ({
    n: 0,
  });
  const $argsByName = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), ({
    ctx: ([
      $pos,
    ]),
    usr: u0$Compiler$TypeCheck$addRootRecursiveInstance$2,
  }), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $annotation.tyvars)));
  const $freeTyvars = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$addRootRecursiveInstance$3,
  }), (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $annotation.tyvars)));
  const $freeUnivars = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$addRootRecursiveInstance$4,
  }), $annotation.univars);
  const $raw = (u0$Compiler$TypeCheck$translateRawType$0.usr)(...(u0$Compiler$TypeCheck$translateRawType$0.ctx), ({
    argsByName: $argsByName,
    env: $env,
    newLambdaSetId: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
      ctx: ([
        $lastLambdaSetId,
      ]),
      usr: u0$Compiler$TypeCheck$addRootRecursiveInstance$5,
    })),
    originalIdToNewId: c0$Dict$empty$0,
    pushError: ({
      ctx: ([
        $errors,
      ]),
      usr: u0$Compiler$TypeCheck$addRootRecursiveInstance$6,
    }),
  }), $annotation.raw);
  const $instance = ({
    definedAt: $pos,
    freeTyvars: $freeTyvars,
    freeUnivars: $freeUnivars,
    lambdaSetConstraints: c0$Dict$empty$0,
    type: ({
      raw: $raw,
      uni: c0$Compiler$Ast$Imm$0,
    }),
  });
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $usr), $instance, $0.variables),
  }));
});

const u0$Compiler$TypeCheck$addRootRecursiveInstance$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addRootRecursiveInstance$1,
});

const u0$Compiler$LazyBuild$evaluateCircularValues$2 = (($circular, $errors, $others, $state, $usr, $envX) => {
  const $3 = (hash_get)($state.done, $usr);
  return (((($3)[0] === "$Just") && ((($3)[1].def)[0] === "$ValueDef"))
    ? ((() => {
      const $def = (($3)[1].def)[1];
      const $4 = $def.maybeAnnotation;
      return ((($4)[0] === "$Just")
        ? ((() => {
          const $ann = ($4)[1];
          return (u0$Compiler$TypeCheck$addRootRecursiveInstance$0.usr)(...(u0$Compiler$TypeCheck$addRootRecursiveInstance$0.ctx), $errors, $def.namePos, $usr, $ann, $envX);
        }))()
        : ((($4)[0] === "$Nothing")
          ? ((() => {
            (array_push)($errors, (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), ((sp_equal)($others, c0$Core$Nil$0)
              ? (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("Value " + $def.name) + "  is recursive, so I need a type annotation for it."), c0$Core$Nil$0)
              : (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (((("Value " + $def.name) + " is mutually recursive with ") + (sp_toHuman)($circular)) + " so I need it to be annotated."), c0$Core$Nil$0))));
            return $envX;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 176:32', (sp_toHuman)($4))));
    }))()
    : (true
      ? $envX
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 173:24', (sp_toHuman)($3))));
});

const u0$Compiler$LazyBuild$evaluateCircularValues$1 = (($state, $errors, $circular, $env0) => {
  return ((($circular)[0] === "$Cons")
    ? ((() => {
      const $u = ($circular)[1];
      const $others = ($circular)[2];
      return ((sp_equal)((u0$Compiler$LazyBuild$usrToDependencyType$0.usr)(...(u0$Compiler$LazyBuild$usrToDependencyType$0.ctx), $u), c0$Compiler$Meta$TypeDependency$0)
        ? $env0
        : (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $env0, $circular, ({
          ctx: ([
            $circular,
            $errors,
            $others,
            $state,
          ]),
          usr: u0$Compiler$LazyBuild$evaluateCircularValues$2,
        })));
    }))()
    : (true
      ? $env0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 165:8', (sp_toHuman)($circular))));
});

const u0$Compiler$LazyBuild$evaluateCircularValues$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$evaluateCircularValues$1,
});

const u0$Compiler$TypeCheck$namedParsToIdParsAndDict$3 = (($index, $1) => {
  const $name = $1.first;
  const $pos = $1.second;
  return ({
    first: $name,
    second: (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $pos, -($index)),
  });
});

const u0$Compiler$TypeCheck$namedParsToIdParsAndDict$2 = (($index, $atName) => {
  return -($index);
});

const u0$Compiler$TypeCheck$namedParsToIdParsAndDict$1 = (($atPars) => {
  const $idPars = (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$namedParsToIdParsAndDict$2,
  }), $atPars);
  const $typeByName = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$namedParsToIdParsAndDict$3,
  }), $atPars));
  return ({
    first: $idPars,
    second: $typeByName,
  });
});

const u0$Compiler$TypeCheck$namedParsToIdParsAndDict$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$namedParsToIdParsAndDict$1,
});

const u0$Compiler$TypeCheck$expandAndInsertAlias$2 = (($errors, $0) => {
  return (array_push)($errors, $0);
});

const u0$Compiler$TypeCheck$expandAndInsertAlias$1 = (($errors, $env, $aliasDef, $aliasAccum) => {
  const $5 = (u0$Compiler$TypeCheck$namedParsToIdParsAndDict$0.usr)(...(u0$Compiler$TypeCheck$namedParsToIdParsAndDict$0.ctx), $aliasDef.pars);
  const $typeByName = $5.second;
  const $pars = $5.first;
  const $originalIdToNewId = c0$Dict$empty$0;
  const $type = (u0$Compiler$TypeCheck$translateRawType$0.usr)(...(u0$Compiler$TypeCheck$translateRawType$0.ctx), ({
    argsByName: $typeByName,
    env: ((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        expandedAliases: $aliasAccum,
      }));
    }))(),
    newLambdaSetId: c0$Maybe$Nothing$0,
    originalIdToNewId: $originalIdToNewId,
    pushError: ({
      ctx: ([
        $errors,
      ]),
      usr: u0$Compiler$TypeCheck$expandAndInsertAlias$2,
    }),
  }), $aliasDef.type);
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $aliasDef.usr, ({
    pars: $pars,
    type: $type,
  }), $aliasAccum);
});

const u0$Compiler$TypeCheck$expandAndInsertAlias$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$expandAndInsertAlias$1,
});

const u0$Compiler$LazyBuild$expandAndInsertType$1 = (($state, $errors, $usr, $env0) => {
  const $5 = (hash_get)($state.done, $usr);
  return ((($5)[0] === "$Nothing")
    ? (sp_todo)(("compiler bug, missing type usr" + (sp_toHuman)($usr)))
    : ((($5)[0] === "$Just")
      ? ((() => {
        const $def = ($5)[1].def;
        const $deps = ($5)[1].deps;
        return ((($def)[0] === "$VariantTypeDef")
          ? ((() => {
            const $variantTypeDef = ($def)[1];
            const $0 = $env0;
            return (Object.assign)({}, $0, ({
              exactTypes: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, $variantTypeDef.pars, $0.exactTypes),
            }));
          }))()
          : ((($def)[0] === "$AliasDef")
            ? ((() => {
              const $aliasDef = ($def)[1];
              const $0 = $env0;
              return (Object.assign)({}, $0, ({
                expandedAliases: (u0$Compiler$TypeCheck$expandAndInsertAlias$0.usr)(...(u0$Compiler$TypeCheck$expandAndInsertAlias$0.ctx), $errors, ((() => {
                  const $1 = $env0;
                  return (Object.assign)({}, $1, ({
                    currentRootUsr: $usr,
                  }));
                }))(), $aliasDef, $0.expandedAliases),
              }));
            }))()
            : (true
              ? $env0
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 131:12', (sp_toHuman)($def)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 125:4', (sp_toHuman)($5))));
});

const u0$Compiler$LazyBuild$expandAndInsertType$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$expandAndInsertType$1,
});

const u0$Compiler$LazyBuild$initState$1 = (($pendingList) => {
  let $pending = (hash_fromList)($pendingList);
  (hash_insert)($pending, u0$Compiler$CoreDefs$noneTypeUsr$0, c0$Compiler$Meta$TypeDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$noneConsUsr$0, c0$Compiler$Meta$ConstructorDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$boolUsr$0, c0$Compiler$Meta$TypeDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$trueUsr$0, c0$Compiler$Meta$ConstructorDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$falseUsr$0, c0$Compiler$Meta$ConstructorDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$numberUsr$0, c0$Compiler$Meta$TypeDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$textUsr$0, c0$Compiler$Meta$TypeDependency$0);
  (hash_insert)($pending, u0$Compiler$CoreDefs$listUsr$0, c0$Compiler$Meta$TypeDependency$0);
  return ({
    done: (hash_fromList)(c0$Core$Nil$0),
    lastUnificationVarId: ({
      n: 0,
    }),
    loadedModulesByUmr: (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: u0$Compiler$CoreDefs$umr$0,
      second: u0$Compiler$CoreDefs$coreModule$0,
    }), c0$Core$Nil$0)),
    pending: $pending,
  });
});

const u0$Compiler$LazyBuild$initState$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$initState$1,
});

const u0$Compiler$LazyBuild$stopOnError$1 = (($pars, $errors) => {
  const $3 = (array_toList)($errors);
  return ((($3)[0] === "$Nil")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null)
    : (true
      ? ((() => {
        const $errorsAsList = $3;
        return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Nested$0.usr)(...(u0$Compiler$Error$Nested$0.ctx), $errorsAsList));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 222:4', (sp_toHuman)($3))));
});

const u0$Compiler$LazyBuild$stopOnError$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$stopOnError$1,
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$7 = (($k, $v) => {
  return c0$Set$empty$0;
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$6 = (($2, $d) => {
  const $n = $2.first;
  const $id = $2.second;
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $id, ({
    maybeAnnotated: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
      allowFunctions: true,
      name: $n,
    })),
  }), $d);
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$5 = (($errors, $0) => {
  return (array_push)($errors, $0);
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$4 = (($2, $d) => {
  const $n = $2.first;
  const $id = $2.second;
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $n, (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$G$0, $id), $d);
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$3 = (($index, $n) => {
  return ({
    first: $n,
    second: -($index),
  });
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$2 = (($in) => {
  return (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), ({
    raw: $in,
    uni: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), 1),
  }));
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$1 = (($errors, $name, $caConstructor, $env) => {
  const $5 = $caConstructor.variantTypeUsr;
  const $umr = ($5)[1];
  const $ins = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$2,
  }), $caConstructor.ins);
  const $caRaw = ((sp_equal)($ins, c0$Core$Nil$0)
    ? $caConstructor.out
    : (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$G$0, $ins, ({
      raw: $caConstructor.out,
      uni: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), 1),
    })));
  const $tyvarNamesAndIds = (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$3,
  }), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), (c0$Compiler$CanonicalAst$typeTyvars$0.usr)(...(c0$Compiler$CanonicalAst$typeTyvars$0.ctx), $caRaw)));
  const $paramsByName = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $tyvarNamesAndIds, ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$4,
  }));
  const $raw = (u0$Compiler$TypeCheck$translateRawType$0.usr)(...(u0$Compiler$TypeCheck$translateRawType$0.ctx), ({
    argsByName: $paramsByName,
    env: $env,
    newLambdaSetId: c0$Maybe$Nothing$0,
    originalIdToNewId: c0$Dict$empty$0,
    pushError: ({
      ctx: ([
        $errors,
      ]),
      usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$5,
    }),
  }), $caRaw);
  const $freeTyvars = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $tyvarNamesAndIds, ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$6,
  }));
  const $taConstructor = ({
    definedAt: c0$Compiler$Pos$G$0,
    freeTyvars: $freeTyvars,
    freeUnivars: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), 1, ({
      annotatedId: 1,
    })),
    lambdaSetConstraints: (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
      ctx: [],
      usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$7,
    }), (c0$Compiler$TypedAst$typeLambdaSets$0.usr)(...(c0$Compiler$TypedAst$typeLambdaSets$0.ctx), $raw)),
    type: (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $raw),
  });
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    constructors: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $umr, $name), $taConstructor, $0.constructors),
  }));
});

const u0$Compiler$TypeCheck$addConstructorToGlobalEnv$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addConstructorToGlobalEnv$1,
});

const u0$Compiler$TypeCheck$applyAllSubs$3 = (($state, $id) => {
  return (hash_get)($state.univarSubs, $id);
});

const u0$Compiler$TypeCheck$applyAllSubs$2 = (($state, $id) => {
  return (hash_get)($state.tyvarSubs, $id);
});

const u0$Compiler$TypeCheck$applyAllSubs$1 = (($state, $raw) => {
  const $subsAsFns = ({
    lSet: c0$Basics$identity$0,
    ty: ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$applyAllSubs$2,
    }),
    uni: ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$applyAllSubs$3,
    }),
  });
  return (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $subsAsFns, $raw);
});

const u0$Compiler$TypeCheck$applyAllSubs$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$applyAllSubs$1,
});

const u0$Compiler$TypeCheck$addErrorText$1 = (($env, $pos, $state, $lines) => {
  return (array_push)($state.errors, (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), (u0$Compiler$TypeCheck$getErrorModule$0.usr)(...(u0$Compiler$TypeCheck$getErrorModule$0.ctx), $env), $pos, $lines));
});

const u0$Compiler$TypeCheck$addErrorText$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addErrorText$1,
});

const u0$Human$Format$chainPrecedence$1 = (($ls) => {
  return ((($ls)[0] === "$Nil")
    ? 0
    : ((($ls)[0] === "$Cons")
      ? ((() => {
        const $op = ($ls)[1].first;
        return $op.precedence;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 114:4', (sp_toHuman)($ls))));
});

const u0$Human$Format$chainPrecedence$0 = ({
  ctx: [],
  usr: u0$Human$Format$chainPrecedence$1,
});

const u0$Human$Format$expressionPrecedence$1 = (($1) => {
  const $e_ = ($1)[3];
  return ((($e_)[0] === "$Statements")
    ? ((() => {
      const $stats = ($e_)[1];
      return 0;
    }))()
    : ((($e_)[0] === "$BinopChain")
      ? ((() => {
        const $priority = ($e_)[1];
        const $binopChain = ($e_)[2];
        return (u0$Human$Format$chainPrecedence$0.usr)(...(u0$Human$Format$chainPrecedence$0.ctx), $binopChain.second);
      }))()
      : ((($e_)[0] === "$Poly")
        ? ((() => {
          const $text = ($e_)[1];
          const $expression = ($e_)[2];
          return 9;
        }))()
        : ((($e_)[0] === "$If")
          ? 9
          : ((($e_)[0] === "$Try")
            ? 9
            : ((($e_)[0] === "$Call")
              ? c0$Compiler$Op$precedence_application$0
              : ((($e_)[0] === "$Fn")
                ? ((() => {
                  const $pars = ($e_)[2];
                  const $body = ($e_)[3];
                  return c0$Compiler$Op$precedence_function$0;
                }))()
                : (((($e_)[0] === "$Lowercase") && ((($e_)[1].maybeType)[0] === "$Just"))
                  ? (c0$Compiler$Op$precedence_tuple$0 - 1)
                  : (true
                    ? 10
                    : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 130:4', (sp_toHuman)($e_)))))))))));
});

const u0$Human$Format$expressionPrecedence$0 = ({
  ctx: [],
  usr: u0$Human$Format$expressionPrecedence$1,
});

const u0$SPLib$Format$indent_map$1 = (($f, $1) => {
  const $indent = ($1)[1];
  const $l = ($1)[2];
  return (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), $indent, ($f.usr)(...($f.ctx), $l));
});

const u0$SPLib$Format$indent_map$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$indent_map$1,
});

const u0$SPLib$Format$indent_spaces$1 = (($n) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $n, c0$Core$Nil$0);
});

const u0$SPLib$Format$indent_spaces$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$indent_spaces$1,
});

const u0$SPLib$Format$mapFirstLine$1 = (($firstFn, $restFn, $b) => {
  return ((($b)[0] === "$Empty")
    ? u0$SPLib$Format$Empty$0
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $breaks = ($b)[1];
        const $l1 = ($b)[2];
        return (u0$SPLib$Format$SingleLine$0.usr)(...(u0$SPLib$Format$SingleLine$0.ctx), $breaks, ($firstFn.usr)(...($firstFn.ctx), $l1));
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $ls = ($b)[2];
          return (u0$SPLib$Format$Stack$0.usr)(...(u0$SPLib$Format$Stack$0.ctx), ($firstFn.usr)(...($firstFn.ctx), $l1), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $restFn, $ls));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 245:4', (sp_toHuman)($b)))));
});

const u0$SPLib$Format$mapFirstLine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$mapFirstLine$1,
});

const u0$SPLib$Format$stripEnd$1 = (($l) => {
  return ((($l)[0] === "$Space")
    ? u0$SPLib$Format$Blank$0
    : ((($l)[0] === "$Row")
      ? ((() => {
        const $r1 = ($l)[1];
        const $r2 = ($l)[2];
        const $2 = (u0$SPLib$Format$stripEnd$0.usr)(...(u0$SPLib$Format$stripEnd$0.ctx), $r2);
        return ((($2)[0] === "$Blank")
          ? (u0$SPLib$Format$stripEnd$0.usr)(...(u0$SPLib$Format$stripEnd$0.ctx), $r1)
          : (true
            ? ((() => {
              const $r2_ = $2;
              return (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $r1, $r2_);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 424:12', (sp_toHuman)($2))));
      }))()
      : (true
        ? $l
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 418:4', (sp_toHuman)($l)))));
});

const u0$SPLib$Format$stripEnd$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$stripEnd$1,
});

const u0$SPLib$Format$prefix$4 = (($addPrefixToLine, $0) => {
  return (u0$SPLib$Format$indent_map$0.usr)(...(u0$SPLib$Format$indent_map$0.ctx), $addPrefixToLine, $0);
});

const u0$SPLib$Format$prefix$3 = (($pref, $x) => {
  return ((($x)[0] === "$Blank")
    ? (u0$SPLib$Format$stripEnd$0.usr)(...(u0$SPLib$Format$stripEnd$0.ctx), $pref)
    : (true
      ? ((() => {
        const $l = $x;
        return (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $pref, $l);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 409:8', (sp_toHuman)($x))));
});

const u0$SPLib$Format$prefix$2 = (($prefixLength, $1) => {
  const $i = ($1)[1];
  const $l = ($1)[2];
  return (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent_spaces$0.usr)(...(u0$SPLib$Format$indent_spaces$0.ctx), $prefixLength), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $i, c0$Core$Nil$0))), $l);
});

const u0$SPLib$Format$prefix$1 = (($prefixLength, $pref, $blocks) => {
  const $padLineWithSpaces = ({
    ctx: ([
      $prefixLength,
    ]),
    usr: u0$SPLib$Format$prefix$2,
  });
  const $addPrefixToLine = ({
    ctx: ([
      $pref,
    ]),
    usr: u0$SPLib$Format$prefix$3,
  });
  return (u0$SPLib$Format$mapFirstLine$0.usr)(...(u0$SPLib$Format$mapFirstLine$0.ctx), ({
    ctx: ([
      $addPrefixToLine,
    ]),
    usr: u0$SPLib$Format$prefix$4,
  }), $padLineWithSpaces, $blocks);
});

const u0$SPLib$Format$prefix$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$prefix$1,
});

const u0$SPLib$Format$for1$1 = (($items, $f) => {
  return ((($items)[0] === "$Nil")
    ? (sp_todo)("for1 got an empty list....")
    : ((($items)[0] === "$Cons")
      ? ((() => {
        const $head = ($items)[1];
        const $tail = ($items)[2];
        return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $head, $tail, $f);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 9:4', (sp_toHuman)($items))));
});

const u0$SPLib$Format$for1$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$for1$1,
});

const u0$SPLib$Format$mkIndentedLine$1 = (($l) => {
  return ((($l)[0] === "$Space")
    ? (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), (u0$SPLib$Format$indent_spaces$0.usr)(...(u0$SPLib$Format$indent_spaces$0.ctx), 1), u0$SPLib$Format$Blank$0)
    : (((($l)[0] === "$Row") && ((($l)[1])[0] === "$Space"))
      ? ((() => {
        const $next = ($l)[2];
        const $2 = (u0$SPLib$Format$mkIndentedLine$0.usr)(...(u0$SPLib$Format$mkIndentedLine$0.ctx), $next);
        const $rest_ = ($2)[2];
        const $i = ($2)[1];
        return (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent_spaces$0.usr)(...(u0$SPLib$Format$indent_spaces$0.ctx), 1), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $i, c0$Core$Nil$0))), $rest_);
      }))()
      : (true
        ? ((() => {
          const $other = $l;
          return (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), c0$Core$Nil$0, $other);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 192:4', (sp_toHuman)($l)))));
});

const u0$SPLib$Format$mkIndentedLine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$mkIndentedLine$1,
});

const u0$SPLib$Format$lineToBlock$1 = (($x) => {
  return (u0$SPLib$Format$SingleLine$0.usr)(...(u0$SPLib$Format$SingleLine$0.ctx), u0$SPLib$Format$NoRequiredBreaks$0, (u0$SPLib$Format$mkIndentedLine$0.usr)(...(u0$SPLib$Format$mkIndentedLine$0.ctx), $x));
});

const u0$SPLib$Format$lineToBlock$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$lineToBlock$1,
});

const u0$SPLib$Format$mustBreak$1 = (($x) => {
  return (u0$SPLib$Format$SingleLine$0.usr)(...(u0$SPLib$Format$SingleLine$0.ctx), u0$SPLib$Format$MustBreakAtEnd$0, (u0$SPLib$Format$mkIndentedLine$0.usr)(...(u0$SPLib$Format$mkIndentedLine$0.ctx), $x));
});

const u0$SPLib$Format$mustBreak$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$mustBreak$1,
});

const u0$SPLib$Format$maybeAllSingleLines$2 = (($rec, $0) => {
  return ($rec.usr)(...($rec.ctx), $0, c0$Core$Nil$0);
});

const u0$SPLib$Format$maybeAllSingleLines$1 = (($blocks, $reversedLines) => {
  const $rec = ({
    ctx: [],
    usr: u0$SPLib$Format$maybeAllSingleLines$1,
  });
  return ((($blocks)[0] === "$Nil")
    ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
      first: $reversedLines,
      second: u0$SPLib$Format$lineToBlock$0,
    }))
    : ((($blocks)[0] === "$Cons")
      ? ((() => {
        const $block = ($blocks)[1];
        const $rest = ($blocks)[2];
        return (((($block)[0] === "$SingleLine") && (((($block)[1])[0] === "$NoRequiredBreaks") && ((($block)[2])[0] === "$Indented")))
          ? ((() => {
            const $l = (($block)[2])[2];
            return ($rec.usr)(...($rec.ctx), $rest, (sp_cons)($l, $reversedLines));
          }))()
          : (((($block)[0] === "$SingleLine") && (((($block)[1])[0] === "$MustBreakAtEnd") && ((($block)[2])[0] === "$Indented")))
            ? ((() => {
              const $l = (($block)[2])[2];
              return ((sp_equal)($rest, c0$Core$Nil$0)
                ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
                  first: (sp_cons)($l, $reversedLines),
                  second: u0$SPLib$Format$mustBreak$0,
                }))
                : c0$Maybe$Nothing$0);
            }))()
            : (true
              ? c0$Maybe$Nothing$0
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 347:16', (sp_toHuman)($block)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 341:8', (sp_toHuman)($blocks))));
});

const u0$SPLib$Format$maybeAllSingleLines$0 = ((() => {
  const $rec = ({
    ctx: [],
    usr: u0$SPLib$Format$maybeAllSingleLines$1,
  });
  return ({
    ctx: ([
      $rec,
    ]),
    usr: u0$SPLib$Format$maybeAllSingleLines$2,
  });
}))();

const u0$SPLib$Format$stack$3 = (($stackForce, $bs) => {
  return ((sp_equal)($bs, c0$Core$Nil$0)
    ? u0$SPLib$Format$Empty$0
    : (u0$SPLib$Format$for1$0.usr)(...(u0$SPLib$Format$for1$0.ctx), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $bs), $stackForce));
});

const u0$SPLib$Format$stack$2 = (($b) => {
  return ((($b)[0] === "$Empty")
    ? c0$Core$Nil$0
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $l1 = ($b)[2];
        return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $l1, c0$Core$Nil$0);
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $rest = ($b)[2];
          return (sp_cons)($l1, $rest);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 213:12', (sp_toHuman)($b)))));
});

const u0$SPLib$Format$stack$1 = (($b1, $b2) => {
  const $toLines = ({
    ctx: [],
    usr: u0$SPLib$Format$stack$2,
  });
  const $3 = ($toLines.usr)(...($toLines.ctx), $b1);
  return ((($3)[0] === "$Nil")
    ? $b2
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $line1first = ($3)[1];
        const $line1rest = ($3)[2];
        return (u0$SPLib$Format$Stack$0.usr)(...(u0$SPLib$Format$Stack$0.ctx), $line1first, (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $line1rest, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($toLines.usr)(...($toLines.ctx), $b2), c0$Core$Nil$0))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 227:8', (sp_toHuman)($3))));
});

const u0$SPLib$Format$stack$0 = ((() => {
  const $stackForce = ({
    ctx: [],
    usr: u0$SPLib$Format$stack$1,
  });
  return ({
    ctx: ([
      $stackForce,
    ]),
    usr: u0$SPLib$Format$stack$3,
  });
}))();

const u0$SPLib$Format$rowOrStackForce$1 = (($forceMultiline, $joiner, $blocks) => {
  return (((($blocks)[0] === "$Cons") && ((($blocks)[2])[0] === "$Nil"))
    ? ((() => {
      const $single = ($blocks)[1];
      return $single;
    }))()
    : (true
      ? ($forceMultiline
        ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), $blocks)
        : ((() => {
          const $4 = (u0$SPLib$Format$maybeAllSingleLines$0.usr)(...(u0$SPLib$Format$maybeAllSingleLines$0.ctx), $blocks);
          return ((($4)[0] === "$Just")
            ? ((() => {
              const $lines = ($4)[1].first;
              const $mkLine = ($4)[1].second;
              return ($mkLine.usr)(...($mkLine.ctx), ((($joiner)[0] === "$Nothing")
                ? (u0$SPLib$Format$for1$0.usr)(...(u0$SPLib$Format$for1$0.ctx), $lines, u0$SPLib$Format$Row$0)
                : ((($joiner)[0] === "$Just")
                  ? ((() => {
                    const $j = ($joiner)[1];
                    return (u0$SPLib$Format$for1$0.usr)(...(u0$SPLib$Format$for1$0.ctx), (c0$List$intersperse$0.usr)(...(c0$List$intersperse$0.ctx), $j, $lines), u0$SPLib$Format$Row$0);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 294:24', (sp_toHuman)($joiner)))));
            }))()
            : (true
              ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), $blocks)
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 291:16', (sp_toHuman)($4))));
        }))())
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 282:4', (sp_toHuman)($blocks))));
});

const u0$SPLib$Format$rowOrStackForce$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$rowOrStackForce$1,
});

const u0$SPLib$Format$rowOrStack$1 = (($0, $1) => {
  return (u0$SPLib$Format$rowOrStackForce$0.usr)(...(u0$SPLib$Format$rowOrStackForce$0.ctx), false, $0, $1);
});

const u0$SPLib$Format$rowOrStack$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$rowOrStack$1,
});

const u0$SPLib$Format$textToBlock$1 = (($f) => {
  return (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $f));
});

const u0$SPLib$Format$textToBlock$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$textToBlock$1,
});

const u0$Human$Format$parens$1 = (($block) => {
  return (u0$SPLib$Format$rowOrStack$0.usr)(...(u0$SPLib$Format$rowOrStack$0.ctx), c0$Maybe$Nothing$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), 1, (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), "("), $block), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), ")"), c0$Core$Nil$0)));
});

const u0$Human$Format$parens$0 = ({
  ctx: [],
  usr: u0$Human$Format$parens$1,
});

const u0$Human$Format$formatExpressionAndMaybeAddParens$1 = (($env, $binopPrecedence, $expression) => {
  const $block = (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expression);
  return (((u0$Human$Format$expressionPrecedence$0.usr)(...(u0$Human$Format$expressionPrecedence$0.ctx), $expression) > $binopPrecedence)
    ? $block
    : (u0$Human$Format$parens$0.usr)(...(u0$Human$Format$parens$0.ctx), $block));
});

const u0$Human$Format$formatExpressionAndMaybeAddParens$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatExpressionAndMaybeAddParens$1,
});

const u0$Human$Format$lineIsNonEmpty$1 = (($s) => {
  return (sp_not_equal)((text_trimLeft)($s), "");
});

const u0$Human$Format$lineIsNonEmpty$0 = ({
  ctx: [],
  usr: u0$Human$Format$lineIsNonEmpty$1,
});

const u0$Human$Format$unindentBlockComment$4 = (($minLead, $0) => {
  return (text_dropLeft)($minLead, $0);
});

const u0$Human$Format$unindentBlockComment$3 = (($countLeadingSpaces, $line, $length) => {
  return (c0$Basics$min$0.usr)(...(c0$Basics$min$0.ctx), ($countLeadingSpaces.usr)(...($countLeadingSpaces.ctx), $line), $length);
});

const u0$Human$Format$unindentBlockComment$2 = (($getLeadingSpaces, $l) => {
  return (text_length)(($getLeadingSpaces.usr)(...($getLeadingSpaces.ctx), $l));
});

const u0$Human$Format$unindentBlockComment$1 = (($indent, $content) => {
  const $3 = (text_split)("\n", $content);
  return ((($3)[0] === "$Nil")
    ? c0$Core$Nil$0
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $head = ($3)[1];
        const $tail = ($3)[2];
        const $getLeadingSpaces = (text_startsWithRegex)("[ ]*");
        const $countLeadingSpaces = ({
          ctx: ([
            $getLeadingSpaces,
          ]),
          usr: u0$Human$Format$unindentBlockComment$2,
        });
        const $minLead = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $indent, (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), u0$Human$Format$lineIsNonEmpty$0, $tail), ({
          ctx: ([
            $countLeadingSpaces,
          ]),
          usr: u0$Human$Format$unindentBlockComment$3,
        }));
        return (sp_cons)($head, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
          ctx: ([
            $minLead,
          ]),
          usr: u0$Human$Format$unindentBlockComment$4,
        }), $tail));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 250:4', (sp_toHuman)($3))));
});

const u0$Human$Format$unindentBlockComment$0 = ({
  ctx: [],
  usr: u0$Human$Format$unindentBlockComment$1,
});

const u0$SPLib$Format$blankLine$0 = (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), u0$SPLib$Format$Blank$0);

const u0$Human$Format$formatComment$3 = (($l) => {
  return (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), (u0$SPLib$Format$CommentIgnoreIndent$0.usr)(...(u0$SPLib$Format$CommentIgnoreIndent$0.ctx), $l));
});

const u0$Human$Format$formatComment$2 = (($text) => {
  return ((u0$Human$Format$lineIsNonEmpty$0.usr)(...(u0$Human$Format$lineIsNonEmpty$0.ctx), $text)
    ? (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), (u0$SPLib$Format$CommentWithIndent$0.usr)(...(u0$SPLib$Format$CommentWithIndent$0.ctx), $text))
    : u0$SPLib$Format$blankLine$0);
});

const u0$Human$Format$formatComment$1 = (($env, $1) => {
  const $end = $1.end;
  const $indent = $1.indent;
  const $isBlock = $1.isBlock;
  const $isFollowedByBlank = $1.isFollowedByBlank;
  const $start = $1.start;
  const $content = (text_slice)($start, $end, $env.originalContent);
  const $blockOrBlank = ({
    ctx: [],
    usr: u0$Human$Format$formatComment$2,
  });
  const $comment = ((sp_equal)($indent, 0)
    ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
      ctx: [],
      usr: u0$Human$Format$formatComment$3,
    }), (u0$Human$Format$unindentBlockComment$0.usr)(...(u0$Human$Format$unindentBlockComment$0.ctx), $indent, $content)))
    : ($isBlock
      ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $blockOrBlank, (u0$Human$Format$unindentBlockComment$0.usr)(...(u0$Human$Format$unindentBlockComment$0.ctx), $indent, $content)))
      : (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), (u0$SPLib$Format$CommentWithIndent$0.usr)(...(u0$SPLib$Format$CommentWithIndent$0.ctx), $content))));
  return ($isFollowedByBlank
    ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $comment, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$Format$blankLine$0, c0$Core$Nil$0)))
    : $comment);
});

const u0$Human$Format$formatComment$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatComment$1,
});

const u0$Human$Format$formatComments$2 = (($env, $0) => {
  return (u0$Human$Format$formatComment$0.usr)(...(u0$Human$Format$formatComment$0.ctx), $env, $0);
});

const u0$Human$Format$formatComments$1 = (($env, $comments) => {
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatComments$2,
  }), $comments));
});

const u0$Human$Format$formatComments$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatComments$1,
});

const u0$Human$Format$stackWithComments$1 = (($env, $comments, $block) => {
  return ((sp_equal)($comments, c0$Core$Nil$0)
    ? $block
    : (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatComments$0.usr)(...(u0$Human$Format$formatComments$0.ctx), $env, $comments), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $block, c0$Core$Nil$0))));
});

const u0$Human$Format$stackWithComments$0 = ({
  ctx: [],
  usr: u0$Human$Format$stackWithComments$1,
});

const u0$SPLib$Format$space$0 = u0$SPLib$Format$Space$0;

const u0$SPLib$Format$spaceSeparatedOrStackForce$1 = (($force, $blocks) => {
  return (u0$SPLib$Format$rowOrStackForce$0.usr)(...(u0$SPLib$Format$rowOrStackForce$0.ctx), $force, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), u0$SPLib$Format$space$0), $blocks);
});

const u0$SPLib$Format$spaceSeparatedOrStackForce$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$spaceSeparatedOrStackForce$1,
});

const u0$Human$Format$formatBinopChain$3 = (($2, $acc) => {
  const $opX = $2.first;
  return $opX;
});

const u0$Human$Format$formatBinopChain$2 = (($env, $1) => {
  const $binop = $1.first;
  const $expr = $1.second;
  return (u0$Human$Format$stackWithComments$0.usr)(...(u0$Human$Format$stackWithComments$0.ctx), $env, $binop.comments, (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), 0, (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), ($binop.symbol + " ")), (u0$Human$Format$formatExpressionAndMaybeAddParens$0.usr)(...(u0$Human$Format$formatExpressionAndMaybeAddParens$0.ctx), $env, $binop.precedence, $expr)));
});

const u0$Human$Format$formatBinopChain$1 = (($env, $priority, $1) => {
  const $left = $1.first;
  const $opsAndRights = $1.second;
  const $formatOpAndRight = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatBinopChain$2,
  });
  const $forceMultiline = ((($opsAndRights)[0] === "$Nil")
    ? false
    : ((($opsAndRights)[0] === "$Cons")
      ? ((() => {
        const $first = ($opsAndRights)[1].first;
        const $rest = ($opsAndRights)[2];
        const $last = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $first, $rest, ({
          ctx: [],
          usr: u0$Human$Format$formatBinopChain$3,
        }));
        return ($last.line > $first.line);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 681:8', (sp_toHuman)($opsAndRights))));
  return (u0$SPLib$Format$spaceSeparatedOrStackForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrStackForce$0.ctx), $forceMultiline, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatExpressionAndMaybeAddParens$0.usr)(...(u0$Human$Format$formatExpressionAndMaybeAddParens$0.ctx), $env, (u0$Human$Format$chainPrecedence$0.usr)(...(u0$Human$Format$chainPrecedence$0.ctx), $opsAndRights), $left), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $formatOpAndRight, $opsAndRights)));
});

const u0$Human$Format$formatBinopChain$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatBinopChain$1,
});

const u0$Human$Format$extractComments$1 = (($1) => {
  const $comments = ($1)[1];
  const $pos = ($1)[2];
  const $expr = ($1)[3];
  return ({
    first: (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, $pos, $expr),
    second: $comments,
  });
});

const u0$Human$Format$extractComments$0 = ({
  ctx: [],
  usr: u0$Human$Format$extractComments$1,
});

const u0$Human$Format$prefixToFirstNonBlank$3 = (($done, $prefix, $indentedLine) => {
  return ((basics_cloneUni)($done.hack)
    ? $indentedLine
    : ((($indentedLine)[0] === "$Indented")
      ? ((() => {
        const $i = ($indentedLine)[1];
        const $line = ($indentedLine)[2];
        const $isDecoration = ((($line)[0] === "$CommentWithIndent")
          ? true
          : ((($line)[0] === "$CommentIgnoreIndent")
            ? true
            : ((($line)[0] === "$Blank")
              ? true
              : (true
                ? false
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 37:32', (sp_toHuman)($line))))));
        return ($isDecoration
          ? $indentedLine
          : ((() => {
            ($done.hack = true);
            return (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), $i, (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $prefix), $line));
          }))());
      }))()
      : (true
        ? $indentedLine
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 32:20', (sp_toHuman)($indentedLine)))));
});

const u0$Human$Format$prefixToFirstNonBlank$2 = (($prefix, $block) => {
  return ((($block)[0] === "$Empty")
    ? $block
    : ((($block)[0] === "$SingleLine")
      ? (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), (text_length)($prefix), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $prefix), $block)
      : ((($block)[0] === "$Stack")
        ? ((() => {
          const $head = ($block)[1];
          const $tail = ($block)[2];
          let $done = ({
            hack: false,
          });
          const $doLine = ({
            ctx: ([
              $done,
              $prefix,
            ]),
            usr: u0$Human$Format$prefixToFirstNonBlank$3,
          });
          const $2 = (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $doLine, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (sp_cons)($head, $tail))));
          return ((($2)[0] === "$Nil")
            ? $block
            : ((($2)[0] === "$Cons")
              ? ((() => {
                const $h = ($2)[1];
                const $t = ($2)[2];
                return ((basics_cloneUni)($done.hack)
                  ? (u0$SPLib$Format$Stack$0.usr)(...(u0$SPLib$Format$Stack$0.ctx), $h, $t)
                  : (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), (text_length)($prefix), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $prefix), $block));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 53:12', (sp_toHuman)($2))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 14:4', (sp_toHuman)($block)))));
});

const u0$Human$Format$prefixToFirstNonBlank$1 = (($prefix) => {
  return ({
    ctx: ([
      $prefix,
    ]),
    usr: u0$Human$Format$prefixToFirstNonBlank$2,
  });
});

const u0$Human$Format$prefixToFirstNonBlank$0 = ({
  ctx: [],
  usr: u0$Human$Format$prefixToFirstNonBlank$1,
});

const u0$SPLib$Format$mapLastLine$1 = (($lastFn, $b) => {
  return ((($b)[0] === "$Empty")
    ? u0$SPLib$Format$Empty$0
    : ((($b)[0] === "$SingleLine")
      ? ((() => {
        const $breaks = ($b)[1];
        const $l1 = ($b)[2];
        return (u0$SPLib$Format$SingleLine$0.usr)(...(u0$SPLib$Format$SingleLine$0.ctx), $breaks, ($lastFn.usr)(...($lastFn.ctx), $l1));
      }))()
      : ((($b)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($b)[1];
          const $ls = ($b)[2];
          const $3 = (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $ls);
          return ((($3)[0] === "$Cons")
            ? ((() => {
              const $last = ($3)[1];
              const $init = ($3)[2];
              return (u0$SPLib$Format$Stack$0.usr)(...(u0$SPLib$Format$Stack$0.ctx), $l1, (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($lastFn.usr)(...($lastFn.ctx), $last), $init)));
            }))()
            : (true
              ? (sp_todo)("what")
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 262:12', (sp_toHuman)($3))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 253:4', (sp_toHuman)($b)))));
});

const u0$SPLib$Format$mapLastLine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$mapLastLine$1,
});

const u0$SPLib$Format$addSuffix$3 = (($suffix, $0) => {
  return (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $0, $suffix);
});

const u0$SPLib$Format$addSuffix$2 = (($suffix, $0) => {
  return (u0$SPLib$Format$indent_map$0.usr)(...(u0$SPLib$Format$indent_map$0.ctx), ({
    ctx: ([
      $suffix,
    ]),
    usr: u0$SPLib$Format$addSuffix$3,
  }), $0);
});

const u0$SPLib$Format$addSuffix$1 = (($suffix, $block) => {
  return (u0$SPLib$Format$mapLastLine$0.usr)(...(u0$SPLib$Format$mapLastLine$0.ctx), ({
    ctx: ([
      $suffix,
    ]),
    usr: u0$SPLib$Format$addSuffix$2,
  }), $block);
});

const u0$SPLib$Format$addSuffix$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$addSuffix$1,
});

const u0$Human$Format$commaSeparatedList$3 = (($a, $b) => {
  return (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $b, $a);
});

const u0$Human$Format$commaSeparatedList$2 = (($0) => {
  return (c0$Tuple$mapFirst$0.usr)(...(c0$Tuple$mapFirst$0.ctx), c0$List$reverse$0, $0);
});

const u0$Human$Format$commaSeparatedList$1 = (($forceMultiline, $open, $close, $closeHasAPrecedingSpace, $items) => {
  return ((sp_equal)($items, c0$Core$Nil$0)
    ? (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $close), $open)
    : ((() => {
      const $z = ($forceMultiline
        ? c0$Maybe$Nothing$0
        : (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), ({
          ctx: [],
          usr: u0$Human$Format$commaSeparatedList$2,
        }), (u0$SPLib$Format$maybeAllSingleLines$0.usr)(...(u0$SPLib$Format$maybeAllSingleLines$0.ctx), (sp_cons)($open, $items))));
      return (((($z)[0] === "$Just") && ((($z)[1].first)[0] === "$Cons"))
        ? ((() => {
          const $openLine = (($z)[1].first)[1];
          const $itemLines = (($z)[1].first)[2];
          const $mkLine = ($z)[1].second;
          const $closeLine = ($closeHasAPrecedingSpace
            ? (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), u0$SPLib$Format$Space$0, (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $close))
            : (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $close));
          return (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), $closeLine, ($mkLine.usr)(...($mkLine.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $openLine, u0$SPLib$Format$Space$0), (c0$List$intersperse$0.usr)(...(c0$List$intersperse$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), ", "), $itemLines), ({
            ctx: [],
            usr: u0$Human$Format$commaSeparatedList$3,
          }))));
        }))()
        : ((($z)[0] === "$Nothing")
          ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $open, c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), (u0$Human$Format$prefixToFirstNonBlank$0.usr)(...(u0$Human$Format$prefixToFirstNonBlank$0.ctx), ", "), $items), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), $close), c0$Core$Nil$0), c0$Core$Nil$0)))))
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 78:8', (sp_toHuman)($z))));
    }))());
});

const u0$Human$Format$commaSeparatedList$0 = ({
  ctx: [],
  usr: u0$Human$Format$commaSeparatedList$1,
});

const u0$Human$Format$formatFunctionHeader$2 = (($env, $0) => {
  return (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $0);
});

const u0$Human$Format$formatFunctionHeader$1 = (($env, $maybeId, $pars) => {
  const $head = ((($maybeId)[0] === "$Nothing")
    ? "fn"
    : ((($maybeId)[0] === "$Just")
      ? ((() => {
        const $id = ($maybeId)[1];
        return (("fn(" + (text_fromNumber)($id)) + ")");
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 623:6', (sp_toHuman)($maybeId))));
  return (u0$Human$Format$commaSeparatedList$0.usr)(...(u0$Human$Format$commaSeparatedList$0.ctx), false, (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), $head), ":", false, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatFunctionHeader$2,
  }), $pars));
});

const u0$Human$Format$formatFunctionHeader$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatFunctionHeader$1,
});

const u0$SPLib$Format$spacesInTab$0 = 4;

const u0$SPLib$Format$indent_tab$0 = (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$Format$spacesInTab$0, c0$Core$Nil$0);

const u0$SPLib$Format$mapLines$1 = (($f, $b) => {
  return (u0$SPLib$Format$mapFirstLine$0.usr)(...(u0$SPLib$Format$mapFirstLine$0.ctx), $f, $f, $b);
});

const u0$SPLib$Format$mapLines$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$mapLines$1,
});

const u0$SPLib$Format$indent$2 = (($1) => {
  const $i = ($1)[1];
  const $l = ($1)[2];
  return (u0$SPLib$Format$Indented$0.usr)(...(u0$SPLib$Format$Indented$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$Format$indent_tab$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $i, c0$Core$Nil$0))), $l);
});

const u0$SPLib$Format$indent$1 = (($0) => {
  return (u0$SPLib$Format$mapLines$0.usr)(...(u0$SPLib$Format$mapLines$0.ctx), ({
    ctx: [],
    usr: u0$SPLib$Format$indent$2,
  }), $0);
});

const u0$SPLib$Format$indent$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$indent$1,
});

const u0$SPLib$Format$rowOrIndentForce$1 = (($forceMultiline, $joiner, $blocks) => {
  return ((($blocks)[0] === "$Nil")
    ? (sp_todo)("blocks is supposed to be NonEmpty")
    : (((($blocks)[0] === "$Cons") && ((($blocks)[2])[0] === "$Nil"))
      ? ((() => {
        const $single = ($blocks)[1];
        return $single;
      }))()
      : ((($blocks)[0] === "$Cons")
        ? ((() => {
          const $b1 = ($blocks)[1];
          const $rest = ($blocks)[2];
          const $4 = (u0$SPLib$Format$maybeAllSingleLines$0.usr)(...(u0$SPLib$Format$maybeAllSingleLines$0.ctx), $blocks);
          return ((($4)[0] === "$Just")
            ? ((() => {
              const $reversedLines = ($4)[1].first;
              const $mkLine = ($4)[1].second;
              return ($forceMultiline
                ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (sp_cons)($b1, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$indent$0, $rest)))
                : ($mkLine.usr)(...($mkLine.ctx), ((($joiner)[0] === "$Nothing")
                  ? (u0$SPLib$Format$for1$0.usr)(...(u0$SPLib$Format$for1$0.ctx), $reversedLines, u0$SPLib$Format$Row$0)
                  : ((($joiner)[0] === "$Just")
                    ? ((() => {
                      const $j = ($joiner)[1];
                      return (u0$SPLib$Format$for1$0.usr)(...(u0$SPLib$Format$for1$0.ctx), (c0$List$intersperse$0.usr)(...(c0$List$intersperse$0.ctx), $j, $reversedLines), u0$SPLib$Format$Row$0);
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 328:24', (sp_toHuman)($joiner))))));
            }))()
            : (true
              ? (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (sp_cons)($b1, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$indent$0, $rest)))
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 321:12', (sp_toHuman)($4))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 312:4', (sp_toHuman)($blocks)))));
});

const u0$SPLib$Format$rowOrIndentForce$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$rowOrIndentForce$1,
});

const u0$SPLib$Format$rowOrIndent$1 = (($0, $1) => {
  return (u0$SPLib$Format$rowOrIndentForce$0.usr)(...(u0$SPLib$Format$rowOrIndentForce$0.ctx), false, $0, $1);
});

const u0$SPLib$Format$rowOrIndent$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$rowOrIndent$1,
});

const u0$SPLib$Format$spaceSeparatedOrIndent$1 = (($0) => {
  return (u0$SPLib$Format$rowOrIndent$0.usr)(...(u0$SPLib$Format$rowOrIndent$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), u0$SPLib$Format$space$0), $0);
});

const u0$SPLib$Format$spaceSeparatedOrIndent$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$spaceSeparatedOrIndent$1,
});

const u0$Human$Format$formatCall$4 = (($asContinuingFn, $lastIndex, $0) => {
  return ($asContinuingFn.usr)(...($asContinuingFn.ctx), $lastIndex, $0);
});

const u0$Human$Format$formatCall$3 = (($asContinuingFn, $env, $index, $arg) => {
  let $3 = ($asContinuingFn.usr)(...($asContinuingFn.ctx), $index, $arg);
  return ((($3)[0] === "$Nothing")
    ? (u0$Human$Format$formatExpressionAndMaybeAddParens$0.usr)(...(u0$Human$Format$formatExpressionAndMaybeAddParens$0.ctx), $env, c0$Compiler$Op$precedence_application$0, $arg)
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $layout = ($3)[1].first;
        const $params = ($3)[1].second;
        const $body = ($3)[1].third;
        return (u0$Human$Format$formatFunctionHeader$0.usr)(...(u0$Human$Format$formatFunctionHeader$0.ctx), $env, c0$Maybe$Nothing$0, $params);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 720:8', (sp_toHuman)($3))));
});

const u0$Human$Format$formatCall$2 = (($lastIndex, $index, $arg) => {
  return (((($arg)[0] === "$Expression") && ((($arg)[3])[0] === "$Fn"))
    ? ((() => {
      const $layout = (($arg)[3])[1];
      const $params = (($arg)[3])[2];
      const $body = (($arg)[3])[3];
      return (((sp_equal)($index, $lastIndex) && (sp_not_equal)($layout, c0$Compiler$FormattableAst$Inline$0))
        ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
          first: $layout,
          second: $params,
          third: $body,
        }))
        : c0$Maybe$Nothing$0);
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 707:8', (sp_toHuman)($arg))));
});

const u0$Human$Format$formatCall$1 = (($env, $ref, $args) => {
  const $lastIndex = ((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $args) - 1);
  const $asContinuingFn = ({
    ctx: ([
      $lastIndex,
    ]),
    usr: u0$Human$Format$formatCall$2,
  });
  const $formatArgument = ({
    ctx: ([
      $asContinuingFn,
      $env,
    ]),
    usr: u0$Human$Format$formatCall$3,
  });
  const $maybeContinuing = ((c0$Maybe$onJust$0.usr)(...(c0$Maybe$onJust$0.ctx), ({
    ctx: ([
      $asContinuingFn,
      $lastIndex,
    ]),
    usr: u0$Human$Format$formatCall$4,
  })).usr)(...((c0$Maybe$onJust$0.usr)(...(c0$Maybe$onJust$0.ctx), ({
    ctx: ([
      $asContinuingFn,
      $lastIndex,
    ]),
    usr: u0$Human$Format$formatCall$4,
  })).ctx), (c0$List$last$0.usr)(...(c0$List$last$0.ctx), $args));
  const $4 = (u0$Human$Format$extractComments$0.usr)(...(u0$Human$Format$extractComments$0.ctx), $ref);
  const $refComments = $4.second;
  const $refNoComments = $4.first;
  const $call = (u0$SPLib$Format$spaceSeparatedOrIndent$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndent$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatExpressionAndMaybeAddParens$0.usr)(...(u0$Human$Format$formatExpressionAndMaybeAddParens$0.ctx), $env, c0$Compiler$Op$precedence_application$0, $refNoComments), (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), $formatArgument, $args)));
  return (u0$Human$Format$stackWithComments$0.usr)(...(u0$Human$Format$stackWithComments$0.ctx), $env, $refComments, ((($maybeContinuing)[0] === "$Nothing")
    ? $call
    : ((($maybeContinuing)[0] === "$Just")
      ? ((() => {
        const $layout = ($maybeContinuing)[1].first;
        const $params = ($maybeContinuing)[1].second;
        const $body = ($maybeContinuing)[1].third;
        return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $call, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((c0$Basics$applyIf$0.usr)(...(c0$Basics$applyIf$0.ctx), (sp_equal)($layout, c0$Compiler$FormattableAst$Indented$0), u0$SPLib$Format$indent$0).usr)(...((c0$Basics$applyIf$0.usr)(...(c0$Basics$applyIf$0.ctx), (sp_equal)($layout, c0$Compiler$FormattableAst$Indented$0), u0$SPLib$Format$indent$0).ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $body)), c0$Core$Nil$0)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 739:4', (sp_toHuman)($maybeContinuing)))));
});

const u0$Human$Format$formatCall$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatCall$1,
});

const u0$Human$Format$formatConstructor$1 = (($env, $maybeModule, $name) => {
  return (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((($maybeModule)[0] === "$Nothing")
    ? c0$Core$Nil$0
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $module, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ".", c0$Core$Nil$0));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 602:10', (sp_toHuman)($maybeModule)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $name, c0$Core$Nil$0), c0$Core$Nil$0)))));
});

const u0$Human$Format$formatConstructor$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatConstructor$1,
});

const u0$Human$Format$formatFunction$1 = (($env, $layout, $pars, $body) => {
  const $5 = ((($layout)[0] === "$Inline")
    ? ({
      first: false,
      second: c0$Maybe$Nothing$0,
    })
    : ((($layout)[0] === "$InlineWithId")
      ? ((() => {
        const $id = ($layout)[1];
        return ({
          first: false,
          second: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $id),
        });
      }))()
      : (true
        ? ({
          first: true,
          second: c0$Maybe$Nothing$0,
        })
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 636:8', (sp_toHuman)($layout)))));
  const $maybeId = $5.second;
  const $forceStack = $5.first;
  return (u0$SPLib$Format$spaceSeparatedOrStackForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrStackForce$0.ctx), $forceStack, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatFunctionHeader$0.usr)(...(u0$Human$Format$formatFunctionHeader$0.ctx), $env, $maybeId, $pars), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((c0$Basics$applyIf$0.usr)(...(c0$Basics$applyIf$0.ctx), (sp_equal)($layout, c0$Compiler$FormattableAst$Indented$0), u0$SPLib$Format$indent$0).usr)(...((c0$Basics$applyIf$0.usr)(...(c0$Basics$applyIf$0.ctx), (sp_equal)($layout, c0$Compiler$FormattableAst$Indented$0), u0$SPLib$Format$indent$0).ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $body)), c0$Core$Nil$0)));
});

const u0$Human$Format$formatFunction$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatFunction$1,
});

const u0$Human$Format$extractIfElses$2 = (($env, $acc, $expr) => {
  const $rec = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$extractIfElses$2,
  });
  return (((($expr)[0] === "$Expression") && ((($expr)[3])[0] === "$If"))
    ? ((() => {
      const $comments = ($expr)[1];
      const $args = (($expr)[3])[1];
      return ($rec.usr)(...($rec.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
        first: $comments,
        second: (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $args.condition),
        third: (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $args.true),
      }), $acc), $args.false);
    }))()
    : (true
      ? ({
        first: (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $acc),
        second: (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expr),
      })
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 757:8', (sp_toHuman)($expr))));
});

const u0$Human$Format$extractIfElses$1 = (($env, $x) => {
  const $rec = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$extractIfElses$2,
  });
  return ($rec.usr)(...($rec.ctx), c0$Core$Nil$0, $x);
});

const u0$Human$Format$extractIfElses$0 = ({
  ctx: [],
  usr: u0$Human$Format$extractIfElses$1,
});

const u0$SPLib$Format$blockAsLine$1 = (($b) => {
  return (((($b)[0] === "$SingleLine") && ((($b)[2])[0] === "$Indented"))
    ? ((() => {
      const $l = (($b)[2])[2];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $l);
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 163:4', (sp_toHuman)($b))));
});

const u0$SPLib$Format$blockAsLine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$blockAsLine$1,
});

const u0$SPLib$Format$spaceSeparatedOrStack$1 = (($0) => {
  return (u0$SPLib$Format$rowOrStack$0.usr)(...(u0$SPLib$Format$rowOrStack$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), u0$SPLib$Format$space$0), $0);
});

const u0$SPLib$Format$spaceSeparatedOrStack$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$spaceSeparatedOrStack$1,
});

const u0$Human$Format$formatIf$3 = (($item, $acc) => {
  return (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $acc, $item);
});

const u0$Human$Format$formatIf$2 = (($env, $index, $1) => {
  const $comments = $1.first;
  const $condition = $1.second;
  const $value = $1.third;
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$stackWithComments$0.usr)(...(u0$Human$Format$stackWithComments$0.ctx), $env, $comments, (u0$SPLib$Format$spaceSeparatedOrStack$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrStack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((sp_equal)($index, 0)
    ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "if")
    : (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "else if")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $condition, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "then"), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), $value), c0$Core$Nil$0)));
});

const u0$Human$Format$formatIf$1 = (($env, $isMultiline, $expr) => {
  const $4 = (u0$Human$Format$extractIfElses$0.usr)(...(u0$Human$Format$extractIfElses$0.ctx), $env, $expr);
  const $default = $4.second;
  const $conditionsAndValues = $4.first;
  const $maybeSingleLine = ($isMultiline
    ? c0$Maybe$Nothing$0
    : (((($conditionsAndValues)[0] === "$Cons") && (((($conditionsAndValues)[1].first)[0] === "$Nil") && ((($conditionsAndValues)[2])[0] === "$Nil")))
      ? ((() => {
        const $condition = ($conditionsAndValues)[1].second;
        const $valueIfTrue = ($conditionsAndValues)[1].third;
        const $l = u0$SPLib$Format$blockAsLine$0;
        const $5 = ({
          first: ($l.usr)(...($l.ctx), $condition),
          second: ($l.usr)(...($l.ctx), $valueIfTrue),
          third: ($l.usr)(...($l.ctx), $default),
        });
        return (((($5.first)[0] === "$Just") && ((($5.second)[0] === "$Just") && (($5.third)[0] === "$Just")))
          ? ((() => {
            const $conditionLine = ($5.first)[1];
            const $trueLine = ($5.second)[1];
            const $falseLine = ($5.third)[1];
            return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
              first: $conditionLine,
              second: $trueLine,
              third: $falseLine,
            }));
          }))()
          : (true
            ? c0$Maybe$Nothing$0
            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 779:20', (sp_toHuman)($5))));
      }))()
      : (true
        ? c0$Maybe$Nothing$0
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 773:12', (sp_toHuman)($conditionsAndValues)))));
  return ((($maybeSingleLine)[0] === "$Just")
    ? ((() => {
      const $conditionLine = ($maybeSingleLine)[1].first;
      const $trueLine = ($maybeSingleLine)[1].second;
      const $falseLine = ($maybeSingleLine)[1].third;
      return (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), (u0$SPLib$Format$for1$0.usr)(...(u0$SPLib$Format$for1$0.ctx), (c0$List$intersperse$0.usr)(...(c0$List$intersperse$0.ctx), u0$SPLib$Format$Space$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), "if"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $conditionLine, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), "then"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $trueLine, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), "else"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $falseLine, c0$Core$Nil$0))))))), ({
        ctx: [],
        usr: u0$Human$Format$formatIf$3,
      })));
    }))()
    : ((($maybeSingleLine)[0] === "$Nothing")
      ? ((() => {
        const $formatCAndV = ({
          ctx: ([
            $env,
          ]),
          usr: u0$Human$Format$formatIf$2,
        });
        return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), $formatCAndV, $conditionsAndValues)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "else"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), $default), c0$Core$Nil$0))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 786:4', (sp_toHuman)($maybeSingleLine))));
});

const u0$Human$Format$formatIf$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatIf$1,
});

const u0$Human$Format$formatList$2 = (($env, $1) => {
  const $isUnpacked = $1.first;
  const $expr = $1.second;
  return ($isUnpacked
    ? (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), "..."), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expr))
    : (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expr));
});

const u0$Human$Format$formatList$1 = (($env, $isMultiline, $unpacksAndExprs) => {
  const $formatListItem = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatList$2,
  });
  return (u0$Human$Format$commaSeparatedList$0.usr)(...(u0$Human$Format$commaSeparatedList$0.ctx), $isMultiline, (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "["), "]", true, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $formatListItem, $unpacksAndExprs));
});

const u0$Human$Format$formatList$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatList$1,
});

const u0$Human$Format$formatLiteralNumber$1 = (($hasPercentage, $numberAsText) => {
  return ($hasPercentage
    ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), ($numberAsText + "%"))
    : (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), $numberAsText));
});

const u0$Human$Format$formatLiteralNumber$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatLiteralNumber$1,
});

const u0$Human$Format$formatLiteralText$1 = (($singleQuote, $tripleQuote, $singleOrTriple, $text) => {
  return ((($singleOrTriple)[0] === "$SingleQuote")
    ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), (($singleQuote + $text) + $singleQuote))
    : ((($singleOrTriple)[0] === "$TripleQuote")
      ? ((() => {
        const $rows = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$textToBlock$0, (text_split)("\n", $text));
        return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $tripleQuote, c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $rows, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $tripleQuote, c0$Core$Nil$0), c0$Core$Nil$0)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 337:4', (sp_toHuman)($singleOrTriple))));
});

const u0$Human$Format$formatLiteralText$0 = ((() => {
  const $singleQuote = "\"";
  const $tripleQuote = (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "\"\"\"");
  return ({
    ctx: ([
      $singleQuote,
      $tripleQuote,
    ]),
    usr: u0$Human$Format$formatLiteralText$1,
  });
}))();

const u0$Human$Format$formatLowercase$2 = (($p) => {
  return ("." + $p);
});

const u0$Human$Format$formatLowercase$1 = (($env, $maybeType, $maybeModule, $name, $attrPath) => {
  const $word = (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((($maybeModule)[0] === "$Nothing")
    ? c0$Core$Nil$0
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $module, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ".", c0$Core$Nil$0));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 563:10', (sp_toHuman)($maybeModule)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $name, c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Human$Format$formatLowercase$2,
  }), $attrPath), c0$Core$Nil$0))))));
  return ((($maybeType)[0] === "$Nothing")
    ? $word
    : ((($maybeType)[0] === "$Just")
      ? ((() => {
        const $type = ($maybeType)[1];
        return (u0$SPLib$Format$spaceSeparatedOrIndent$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndent$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), " as"), $word), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $type), c0$Core$Nil$0)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 573:4', (sp_toHuman)($maybeType))));
});

const u0$Human$Format$formatLowercase$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatLowercase$1,
});

const u0$Human$Format$formatRecord$3 = (($nameExpr) => {
  const $2 = $nameExpr.name;
  return (((($2)[0] === "$Expression") && ((($2)[3])[0] === "$Lowercase"))
    ? ((() => {
      const $name = (($2)[3])[1].name;
      return $name;
    }))()
    : (true
      ? ""
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 529:8', (sp_toHuman)($2))));
});

const u0$Human$Format$formatRecord$2 = (($env, $1) => {
  const $maybeExpr = $1.maybeExpr;
  const $name = $1.name;
  return ((($maybeExpr)[0] === "$Nothing")
    ? (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $name)
    : ((($maybeExpr)[0] === "$Just")
      ? ((() => {
        const $expr = ($maybeExpr)[1];
        return (u0$SPLib$Format$rowOrIndent$0.usr)(...(u0$SPLib$Format$rowOrIndent$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), u0$SPLib$Format$Space$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), " ="), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $name)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expr), c0$Core$Nil$0)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 515:8', (sp_toHuman)($maybeExpr))));
});

const u0$Human$Format$formatRecord$1 = (($env, $isMultiline, $maybeMaybeExt, $attrs) => {
  const $open = ((($maybeMaybeExt)[0] === "$Nothing")
    ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "{")
    : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Nothing"))
      ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "{ with ")
      : (((($maybeMaybeExt)[0] === "$Just") && ((($maybeMaybeExt)[1])[0] === "$Just"))
        ? ((() => {
          const $ext = (($maybeMaybeExt)[1])[1];
          return (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), " with"), (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), 1, (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), "{ "), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $ext)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 499:8', (sp_toHuman)($maybeMaybeExt)))));
  const $formatRecordAttribute = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatRecord$2,
  });
  const $attributeName = ({
    ctx: [],
    usr: u0$Human$Format$formatRecord$3,
  });
  return (u0$Human$Format$commaSeparatedList$0.usr)(...(u0$Human$Format$commaSeparatedList$0.ctx), $isMultiline, $open, "}", true, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $formatRecordAttribute, (list_sortBy)($attributeName, $attrs)));
});

const u0$Human$Format$formatRecord$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatRecord$1,
});

const u0$Human$Format$formatRecordShorthand$2 = (($p) => {
  return ("." + $p);
});

const u0$Human$Format$formatRecordShorthand$1 = (($env, $name, $attrPath) => {
  return (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Human$Format$formatRecordShorthand$2,
  }), (sp_cons)($name, $attrPath))));
});

const u0$Human$Format$formatRecordShorthand$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatRecordShorthand$1,
});

const u0$Human$Format$formatFaWord$1 = (($1) => {
  const $pos = $1.first;
  const $name = $1.second;
  return (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), $name);
});

const u0$Human$Format$formatFaWord$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatFaWord$1,
});

const u0$Human$Format$formatDef$1 = (($maybeKeyword, $name, $args) => {
  const $formattedArgs = ((sp_equal)($args, c0$Core$Nil$0)
    ? c0$Maybe$Nothing$0
    : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$SPLib$Format$spaceSeparatedOrIndent$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndent$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$Human$Format$formatFaWord$0, $args))));
  return (u0$SPLib$Format$spaceSeparatedOrIndent$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndent$0.ctx), (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), c0$Basics$identity$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), u0$SPLib$Format$textToBlock$0, $maybeKeyword), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Human$Format$formatFaWord$0.usr)(...(u0$Human$Format$formatFaWord$0.ctx), $name)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $formattedArgs, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "=")), c0$Core$Nil$0))))));
});

const u0$Human$Format$formatDef$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatDef$1,
});

const u0$Human$Format$formatAliasDef$1 = (($env, $1) => {
  const $args = $1.args;
  const $name = $1.name;
  const $type = $1.type;
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatDef$0.usr)(...(u0$Human$Format$formatDef$0.ctx), c0$Maybe$Nothing$0, $name, $args), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $type)), c0$Core$Nil$0)));
});

const u0$Human$Format$formatAliasDef$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatAliasDef$1,
});

const u0$Human$Format$formatUnionDef$2 = (($env, $c) => {
  return (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), 2, (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), ", "), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $c));
});

const u0$Human$Format$formatUnionDef$1 = (($env, $1) => {
  const $args = $1.args;
  const $constructors = $1.constructors;
  const $name = $1.name;
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatDef$0.usr)(...(u0$Human$Format$formatDef$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "var"), $name, $args), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatUnionDef$2,
  }), $constructors))), c0$Core$Nil$0)));
});

const u0$Human$Format$formatUnionDef$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatUnionDef$1,
});

const u0$Human$Format$formatNonFn$2 = (($1) => {
  const $pos = $1.first;
  const $name = $1.second;
  return (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), $name);
});

const u0$Human$Format$formatNonFn$1 = (($words) => {
  return (u0$Human$Format$commaSeparatedList$0.usr)(...(u0$Human$Format$commaSeparatedList$0.ctx), false, (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "with"), "NonFunction", true, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Human$Format$formatNonFn$2,
  }), $words));
});

const u0$Human$Format$formatNonFn$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatNonFn$1,
});

const u0$Human$Format$formatValueDef$1 = (($env, $1) => {
  const $body = $1.body;
  const $nonFn = $1.nonFn;
  const $pattern = $1.pattern;
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$spaceSeparatedOrIndent$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndent$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $pattern), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((sp_equal)($nonFn, c0$Core$Nil$0)
    ? c0$Core$Nil$0
    : (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatNonFn$0.usr)(...(u0$Human$Format$formatNonFn$0.ctx), $nonFn), c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "="), c0$Core$Nil$0), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $body)), c0$Core$Nil$0)));
});

const u0$Human$Format$formatValueDef$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatValueDef$1,
});

const u0$Human$Format$formatStatement$1 = (($env, $stat) => {
  return ((($stat)[0] === "$CommentStatement")
    ? ((() => {
      const $comment = ($stat)[1];
      return (u0$Human$Format$formatComment$0.usr)(...(u0$Human$Format$formatComment$0.ctx), $env, $comment);
    }))()
    : ((($stat)[0] === "$Evaluation")
      ? ((() => {
        const $expression = ($stat)[1];
        return (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expression);
      }))()
      : ((($stat)[0] === "$ValueDef")
        ? ((() => {
          const $valueDef = ($stat)[1];
          return (u0$Human$Format$formatValueDef$0.usr)(...(u0$Human$Format$formatValueDef$0.ctx), $env, $valueDef);
        }))()
        : ((($stat)[0] === "$AliasDef")
          ? ((() => {
            const $aliasDef = ($stat)[1];
            return (u0$Human$Format$formatAliasDef$0.usr)(...(u0$Human$Format$formatAliasDef$0.ctx), $env, $aliasDef);
          }))()
          : ((($stat)[0] === "$UnionDef")
            ? ((() => {
              const $unionDef = ($stat)[1];
              return (u0$Human$Format$formatUnionDef$0.usr)(...(u0$Human$Format$formatUnionDef$0.ctx), $env, $unionDef);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 408:4', (sp_toHuman)($stat)))))));
});

const u0$Human$Format$formatStatement$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatStatement$1,
});

const u0$Human$Format$formatStatements$2 = (($env, $maybePrevious, $stats, $acc) => {
  const $rec = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatStatements$2,
  });
  return ((($stats)[0] === "$Nil")
    ? (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $acc)
    : ((($stats)[0] === "$Cons")
      ? ((() => {
        const $head = ($stats)[1];
        const $tail = ($stats)[2];
        return ($rec.usr)(...($rec.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $head), $tail, (sp_cons)((u0$Human$Format$formatStatement$0.usr)(...(u0$Human$Format$formatStatement$0.ctx), ((() => {
          const $0 = $env;
          return (Object.assign)({}, $0, ({
            isRoot: false,
          }));
        }))(), $head), ((($maybePrevious)[0] === "$Nothing")
          ? $acc
          : (((($maybePrevious)[0] === "$Just") && ((($maybePrevious)[1])[0] === "$CommentStatement"))
            ? $acc
            : ((($maybePrevious)[0] === "$Just")
              ? ($env.isRoot
                ? (sp_cons)(u0$SPLib$Format$blankLine$0, (sp_cons)(u0$SPLib$Format$blankLine$0, $acc))
                : (sp_cons)(u0$SPLib$Format$blankLine$0, $acc))
              : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 387:16', (sp_toHuman)($maybePrevious)))))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 381:8', (sp_toHuman)($stats))));
});

const u0$Human$Format$formatStatements$1 = (($env, $sss) => {
  const $rec = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatStatements$2,
  });
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), ($rec.usr)(...($rec.ctx), c0$Maybe$Nothing$0, $sss, c0$Core$Nil$0));
});

const u0$Human$Format$formatStatements$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatStatements$1,
});

const u0$Human$Format$formatTry$7 = (($1) => {
  const $paLine = $1.first;
  const $blockLine = $1.second;
  return (u0$SPLib$Format$lineToBlock$0.usr)(...(u0$SPLib$Format$lineToBlock$0.ctx), (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), $paLine, (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), ": "), $blockLine)));
});

const u0$Human$Format$formatTry$6 = (($1) => {
  const $paBlock = $1.first;
  const $blockBlock = $1.second;
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$Format$blankLine$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$addSuffix$0.usr)(...(u0$SPLib$Format$addSuffix$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), ":"), $paBlock), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), $blockBlock), c0$Core$Nil$0))));
});

const u0$Human$Format$formatTry$5 = (($paLine, $blockLine) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    first: $paLine,
    second: $blockLine,
  }));
});

const u0$Human$Format$formatTry$4 = (($bl, $paLine) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $paLine,
    ]),
    usr: u0$Human$Format$formatTry$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $paLine,
    ]),
    usr: u0$Human$Format$formatTry$5,
  })).ctx), (c0$Maybe$toResult$0.usr)(...(c0$Maybe$toResult$0.ctx), null, (u0$SPLib$Format$blockAsLine$0.usr)(...(u0$SPLib$Format$blockAsLine$0.ctx), $bl)));
});

const u0$Human$Format$formatTry$3 = (($1) => {
  const $pa = $1.first;
  const $bl = $1.second;
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $bl,
    ]),
    usr: u0$Human$Format$formatTry$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $bl,
    ]),
    usr: u0$Human$Format$formatTry$4,
  })).ctx), (c0$Maybe$toResult$0.usr)(...(c0$Maybe$toResult$0.ctx), null, (u0$SPLib$Format$blockAsLine$0.usr)(...(u0$SPLib$Format$blockAsLine$0.ctx), $pa)));
});

const u0$Human$Format$formatTry$2 = (($env, $1) => {
  const $pattern = $1.first;
  const $block = $1.second;
  return ({
    first: (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $pattern),
    second: (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $block),
  });
});

const u0$Human$Format$formatTry$1 = (($env, $value, $patterns) => {
  const $formatted = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Human$Format$formatTry$2,
  }), $patterns);
  const $tryOneLine = ({
    ctx: [],
    usr: u0$Human$Format$formatTry$3,
  });
  const $blocks = ((() => {
    const $4 = (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), $tryOneLine, $formatted);
    return ((($4)[0] === "$Ok")
      ? ((() => {
        const $lines = ($4)[1];
        const $formatInline = ({
          ctx: [],
          usr: u0$Human$Format$formatTry$7,
        });
        return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $formatInline, $lines);
      }))()
      : ((($4)[0] === "$Err")
        ? ((() => {
          const $formatIndented = ({
            ctx: [],
            usr: u0$Human$Format$formatTry$6,
          });
          return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $formatIndented, $formatted);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 842:8', (sp_toHuman)($4))));
  }))();
  return (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$spaceSeparatedOrIndent$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndent$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "try"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $value), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "as"), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$indent$0.usr)(...(u0$SPLib$Format$indent$0.ctx), (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), $blocks)), c0$Core$Nil$0)));
});

const u0$Human$Format$formatTry$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatTry$1,
});

const u0$Human$Format$unopToText$1 = (($unopId) => {
  return ((($unopId)[0] === "$UnopPlus")
    ? "+"
    : ((($unopId)[0] === "$UnopMinus")
      ? "-"
      : ((($unopId)[0] === "$UnopUnique")
        ? "!"
        : ((($unopId)[0] === "$UnopRecycle")
          ? "@"
          : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 650:4', (sp_toHuman)($unopId))))));
});

const u0$Human$Format$unopToText$0 = ({
  ctx: [],
  usr: u0$Human$Format$unopToText$1,
});

const u0$Human$Format$formatUnopCall$1 = (($env, $unopId, $expr) => {
  const $unop = (u0$Human$Format$unopToText$0.usr)(...(u0$Human$Format$unopToText$0.ctx), $unopId);
  return (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), (text_length)($unop), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $unop), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expr));
});

const u0$Human$Format$formatUnopCall$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatUnopCall$1,
});

const u0$Human$Format$formatUppercase$1 = (($env, $maybeModule, $name) => {
  return (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((($maybeModule)[0] === "$Nothing")
    ? c0$Core$Nil$0
    : ((($maybeModule)[0] === "$Just")
      ? ((() => {
        const $module = ($maybeModule)[1];
        return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $module, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ".", c0$Core$Nil$0));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 589:10', (sp_toHuman)($maybeModule)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $name, c0$Core$Nil$0), c0$Core$Nil$0)))));
});

const u0$Human$Format$formatUppercase$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatUppercase$1,
});

const u0$Human$Format$formatExpression$1 = (($env, $faExpression) => {
  const $3 = $faExpression;
  const $e_ = ($3)[3];
  const $comments = ($3)[1];
  return (u0$Human$Format$stackWithComments$0.usr)(...(u0$Human$Format$stackWithComments$0.ctx), $env, $comments, ((($e_)[0] === "$LiteralText")
    ? ((() => {
      const $singleOrTriple = ($e_)[1];
      const $text = ($e_)[2];
      return (u0$Human$Format$formatLiteralText$0.usr)(...(u0$Human$Format$formatLiteralText$0.ctx), $singleOrTriple, $text);
    }))()
    : ((($e_)[0] === "$LiteralNumber")
      ? ((() => {
        const $hasPercentage = ($e_)[1];
        const $text = ($e_)[2];
        return (u0$Human$Format$formatLiteralNumber$0.usr)(...(u0$Human$Format$formatLiteralNumber$0.ctx), $hasPercentage, $text);
      }))()
      : ((($e_)[0] === "$ArgumentPlaceholder")
        ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "__")
        : ((($e_)[0] === "$Statements")
          ? ((() => {
            const $stats = ($e_)[1];
            return (u0$Human$Format$formatStatements$0.usr)(...(u0$Human$Format$formatStatements$0.ctx), $env, $stats);
          }))()
          : ((($e_)[0] === "$List")
            ? ((() => {
              const $isMultiline = ($e_)[1];
              const $unpacksAndExprs = ($e_)[2];
              return (u0$Human$Format$formatList$0.usr)(...(u0$Human$Format$formatList$0.ctx), $env, $isMultiline, $unpacksAndExprs);
            }))()
            : ((($e_)[0] === "$Record")
              ? ((() => {
                const $attrs = ($e_)[1].attrs;
                const $isMultiline = ($e_)[1].isMultiline;
                const $maybeExtension = ($e_)[1].maybeExtension;
                return (u0$Human$Format$formatRecord$0.usr)(...(u0$Human$Format$formatRecord$0.ctx), $env, $isMultiline, $maybeExtension, $attrs);
              }))()
              : ((($e_)[0] === "$Lowercase")
                ? ((() => {
                  const $attrPath = ($e_)[1].attrPath;
                  const $maybeModule = ($e_)[1].maybeModule;
                  const $maybeType = ($e_)[1].maybeType;
                  const $name = ($e_)[1].name;
                  return (u0$Human$Format$formatLowercase$0.usr)(...(u0$Human$Format$formatLowercase$0.ctx), $env, $maybeType, $maybeModule, $name, $attrPath);
                }))()
                : ((($e_)[0] === "$Uppercase")
                  ? ((() => {
                    const $maybeModule = ($e_)[1].maybeModule;
                    const $name = ($e_)[1].name;
                    return (u0$Human$Format$formatUppercase$0.usr)(...(u0$Human$Format$formatUppercase$0.ctx), $env, $maybeModule, $name);
                  }))()
                  : ((($e_)[0] === "$Constructor")
                    ? ((() => {
                      const $maybeModule = ($e_)[1].maybeModule;
                      const $name = ($e_)[1].name;
                      return (u0$Human$Format$formatConstructor$0.usr)(...(u0$Human$Format$formatConstructor$0.ctx), $env, $maybeModule, $name);
                    }))()
                    : ((($e_)[0] === "$RecordShorthand")
                      ? ((() => {
                        const $attrPath = ($e_)[1].attrPath;
                        const $name = ($e_)[1].name;
                        return (u0$Human$Format$formatRecordShorthand$0.usr)(...(u0$Human$Format$formatRecordShorthand$0.ctx), $env, $name, $attrPath);
                      }))()
                      : ((($e_)[0] === "$Fn")
                        ? ((() => {
                          const $layout = ($e_)[1];
                          const $pars = ($e_)[2];
                          const $body = ($e_)[3];
                          return (u0$Human$Format$formatFunction$0.usr)(...(u0$Human$Format$formatFunction$0.ctx), $env, $layout, $pars, $body);
                        }))()
                        : ((($e_)[0] === "$UnopCall")
                          ? ((() => {
                            const $unopId = ($e_)[1];
                            const $expr = ($e_)[2];
                            return (u0$Human$Format$formatUnopCall$0.usr)(...(u0$Human$Format$formatUnopCall$0.ctx), $env, $unopId, $expr);
                          }))()
                          : ((($e_)[0] === "$BinopChain")
                            ? ((() => {
                              const $priority = ($e_)[1];
                              const $binopChain = ($e_)[2];
                              return (u0$Human$Format$formatBinopChain$0.usr)(...(u0$Human$Format$formatBinopChain$0.ctx), $env, $priority, $binopChain);
                            }))()
                            : ((($e_)[0] === "$Call")
                              ? ((() => {
                                const $ref = ($e_)[1];
                                const $args = ($e_)[2];
                                return (u0$Human$Format$formatCall$0.usr)(...(u0$Human$Format$formatCall$0.ctx), $env, $ref, $args);
                              }))()
                              : ((($e_)[0] === "$Poly")
                                ? ((() => {
                                  const $text = ($e_)[1];
                                  const $expression = ($e_)[2];
                                  const $prefix = ($text + "?");
                                  return (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), (text_length)($prefix), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $prefix), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), $env, $expression));
                                }))()
                                : ((($e_)[0] === "$If")
                                  ? ((() => {
                                    const $condition = ($e_)[1].condition;
                                    const $false = ($e_)[1].false;
                                    const $isMultiline = ($e_)[1].isMultiline;
                                    const $true = ($e_)[1].true;
                                    return (u0$Human$Format$formatIf$0.usr)(...(u0$Human$Format$formatIf$0.ctx), $env, $isMultiline, $faExpression);
                                  }))()
                                  : ((($e_)[0] === "$Try")
                                    ? ((() => {
                                      const $patterns = ($e_)[1].patterns;
                                      const $value = ($e_)[1].value;
                                      return (u0$Human$Format$formatTry$0.usr)(...(u0$Human$Format$formatTry$0.ctx), $env, $value, $patterns);
                                    }))()
                                    : ((($e_)[0] === "$Native")
                                      ? (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "this_is_sp_native")
                                      : (sp_throw)('Missing pattern in try..as', 'src/Human/Format.sp 177:4', (sp_toHuman)($e_)))))))))))))))))))));
});

const u0$Human$Format$formatExpression$0 = ({
  ctx: [],
  usr: u0$Human$Format$formatExpression$1,
});

const u0$Human$Type$toExpression$1 = (($0) => {
  return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, c0$Compiler$Pos$G$0, $0);
});

const u0$Human$Type$toExpression$0 = ({
  ctx: [],
  usr: u0$Human$Type$toExpression$1,
});

const u0$Human$Type$uniToText$1 = (($contextModule, $uni) => {
  return ((($uni)[0] === "$Imm")
    ? ""
    : ((($uni)[0] === "$Uni")
      ? "!"
      : ((($uni)[0] === "$Depends")
        ? ((() => {
          const $n = ($uni)[1];
          return ((text_fromNumber)($n) + "?");
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 58:4', (sp_toHuman)($uni)))));
});

const u0$Human$Type$uniToText$0 = ({
  ctx: [],
  usr: u0$Human$Type$uniToText$1,
});

const u0$Human$Type$doFullType$1 = (($contextModule, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return (u0$Human$Type$toExpression$0.usr)(...(u0$Human$Type$toExpression$0.ctx), (c0$Compiler$FormattableAst$Poly$0.usr)(...(c0$Compiler$FormattableAst$Poly$0.ctx), (u0$Human$Type$uniToText$0.usr)(...(u0$Human$Type$uniToText$0.ctx), $contextModule, $uni), (u0$Human$Type$doRawType$0.usr)(...(u0$Human$Type$doRawType$0.ctx), $contextModule, $raw)));
});

const u0$Human$Type$doFullType$0 = ({
  ctx: [],
  usr: u0$Human$Type$doFullType$1,
});

const u0$Human$Type$doLowercase$1 = (($contextModule, $name) => {
  return (u0$Human$Type$toExpression$0.usr)(...(u0$Human$Type$toExpression$0.ctx), (c0$Compiler$FormattableAst$Lowercase$0.usr)(...(c0$Compiler$FormattableAst$Lowercase$0.ctx), ({
    attrPath: c0$Core$Nil$0,
    maybeModule: c0$Maybe$Nothing$0,
    maybeType: c0$Maybe$Nothing$0,
    name: $name,
  })));
});

const u0$Human$Type$doLowercase$0 = ({
  ctx: [],
  usr: u0$Human$Type$doLowercase$1,
});

const u0$Human$Type$doParType$1 = (($contextModule, $parType) => {
  return ((($parType)[0] === "$ParSp")
    ? ((() => {
      const $full = ($parType)[1];
      return (u0$Human$Type$doFullType$0.usr)(...(u0$Human$Type$doFullType$0.ctx), $contextModule, $full);
    }))()
    : ((($parType)[0] === "$ParRe")
      ? ((() => {
        const $raw = ($parType)[1];
        return (u0$Human$Type$toExpression$0.usr)(...(u0$Human$Type$toExpression$0.ctx), (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), c0$Compiler$Op$UnopRecycle$0, (u0$Human$Type$doRawType$0.usr)(...(u0$Human$Type$doRawType$0.ctx), $contextModule, $raw)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 141:4', (sp_toHuman)($parType))));
});

const u0$Human$Type$doParType$0 = ({
  ctx: [],
  usr: u0$Human$Type$doParType$1,
});

const u0$Human$Type$doTyvarId$1 = (($contextModule, $tyvarId) => {
  return (c0$Compiler$FormattableAst$Lowercase$0.usr)(...(c0$Compiler$FormattableAst$Lowercase$0.ctx), ({
    attrPath: c0$Core$Nil$0,
    maybeModule: c0$Maybe$Nothing$0,
    maybeType: c0$Maybe$Nothing$0,
    name: (text_fromNumber)($tyvarId),
  }));
});

const u0$Human$Type$doTyvarId$0 = ({
  ctx: [],
  usr: u0$Human$Type$doTyvarId$1,
});

const u0$Human$Type$umrToText$1 = (($contextModule, $umr) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $contextModule.umrToAlias);
  return ((($3)[0] === "$Just")
    ? ((() => {
      const $alias = ($3)[1];
      return $alias;
    }))()
    : ((($3)[0] === "$Nothing")
      ? ((() => {
        const $4 = $umr;
        const $modulePath = ($4)[3];
        const $sourceDirId = ($4)[2];
        const $rootDirectory = ($4)[1];
        return $modulePath;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 15:4', (sp_toHuman)($3))));
});

const u0$Human$Type$umrToText$0 = ({
  ctx: [],
  usr: u0$Human$Type$umrToText$1,
});

const u0$Human$Type$usrToText$1 = (($contextModule, $usr) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $contextModule.usrToGlobal);
  return ((($3)[0] === "$Just")
    ? ((() => {
      const $globalName = ($3)[1];
      return $globalName;
    }))()
    : ((($3)[0] === "$Nothing")
      ? ((() => {
        const $4 = $usr;
        const $name = ($4)[2];
        const $umr = ($4)[1];
        return (((u0$Human$Type$umrToText$0.usr)(...(u0$Human$Type$umrToText$0.ctx), $contextModule, $umr) + ".") + $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 30:4', (sp_toHuman)($3))));
});

const u0$Human$Type$usrToText$0 = ({
  ctx: [],
  usr: u0$Human$Type$usrToText$1,
});

const u0$Human$Type$doUsr$1 = (($contextModule, $usr) => {
  return (u0$Human$Type$toExpression$0.usr)(...(u0$Human$Type$toExpression$0.ctx), (c0$Compiler$FormattableAst$Uppercase$0.usr)(...(c0$Compiler$FormattableAst$Uppercase$0.ctx), ({
    maybeModule: c0$Maybe$Nothing$0,
    name: (u0$Human$Type$usrToText$0.usr)(...(u0$Human$Type$usrToText$0.ctx), $contextModule, $usr),
  })));
});

const u0$Human$Type$doUsr$0 = ({
  ctx: [],
  usr: u0$Human$Type$doUsr$1,
});

const u0$Human$Type$doRawType$4 = (($contextModule, $0) => {
  return (u0$Human$Type$doRawType$0.usr)(...(u0$Human$Type$doRawType$0.ctx), $contextModule, $0);
});

const u0$Human$Type$doRawType$3 = (($contextModule, $0) => {
  return (u0$Human$Type$doParType$0.usr)(...(u0$Human$Type$doParType$0.ctx), $contextModule, $0);
});

const u0$Human$Type$doRawType$2 = (($contextModule, $1) => {
  const $name = $1.first;
  const $raw = $1.second;
  return ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Human$Type$doRawType$0.usr)(...(u0$Human$Type$doRawType$0.ctx), $contextModule, $raw)),
    name: (u0$Human$Type$doLowercase$0.usr)(...(u0$Human$Type$doLowercase$0.ctx), $contextModule, $name),
  });
});

const u0$Human$Type$doRawType$1 = (($contextModule, $rawType) => {
  return (u0$Human$Type$toExpression$0.usr)(...(u0$Human$Type$toExpression$0.ctx), ((($rawType)[0] === "$TypeExact")
    ? ((() => {
      const $usr = ($rawType)[2];
      const $args = ($rawType)[3];
      return (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Human$Type$doUsr$0.usr)(...(u0$Human$Type$doUsr$0.ctx), $contextModule, $usr), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
        ctx: ([
          $contextModule,
        ]),
        usr: u0$Human$Type$doRawType$4,
      }), $args));
    }))()
    : ((($rawType)[0] === "$TypeFn")
      ? ((() => {
        const $id = ($rawType)[2];
        const $parTypes = ($rawType)[3];
        const $full = ($rawType)[4];
        return (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), (c0$Compiler$FormattableAst$InlineWithId$0.usr)(...(c0$Compiler$FormattableAst$InlineWithId$0.ctx), $id), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
          ctx: ([
            $contextModule,
          ]),
          usr: u0$Human$Type$doRawType$3,
        }), $parTypes), (u0$Human$Type$doFullType$0.usr)(...(u0$Human$Type$doFullType$0.ctx), $contextModule, $full));
      }))()
      : ((($rawType)[0] === "$TypeVar")
        ? ((() => {
          const $tyvarId = ($rawType)[2];
          return (u0$Human$Type$doTyvarId$0.usr)(...(u0$Human$Type$doTyvarId$0.ctx), $contextModule, $tyvarId);
        }))()
        : ((($rawType)[0] === "$TypeRecord")
          ? ((() => {
            const $maybeExtId = ($rawType)[2];
            const $taAttrs = ($rawType)[3];
            const $maybeExtension = ((($maybeExtId)[0] === "$Nothing")
              ? c0$Maybe$Nothing$0
              : ((($maybeExtId)[0] === "$Just")
                ? ((() => {
                  const $id = ($maybeExtId)[1];
                  return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Human$Type$toExpression$0.usr)(...(u0$Human$Type$toExpression$0.ctx), (u0$Human$Type$doTyvarId$0.usr)(...(u0$Human$Type$doTyvarId$0.ctx), $contextModule, $id))));
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 86:16', (sp_toHuman)($maybeExtId))));
            const $attrs = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
              ctx: ([
                $contextModule,
              ]),
              usr: u0$Human$Type$doRawType$2,
            }), (list_sortBy)(c0$Tuple$first$0, (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $taAttrs)));
            return (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
              attrs: $attrs,
              isMultiline: false,
              maybeExtension: $maybeExtension,
            }));
          }))()
          : ((($rawType)[0] === "$TypeError")
            ? (c0$Compiler$FormattableAst$LiteralText$0.usr)(...(c0$Compiler$FormattableAst$LiteralText$0.ctx), c0$Compiler$Token$SingleQuote$0, "???")
            : (true
              ? ((() => {
                const $wtf = $rawType;
                return (sp_todo)("bug: this should not be a type");
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Human/Type.sp 73:4', (sp_toHuman)($rawType)))))))));
});

const u0$Human$Type$doRawType$0 = ({
  ctx: [],
  usr: u0$Human$Type$doRawType$1,
});

const u0$SPLib$Format$indent_combine$1 = (($pos, $i) => {
  return ($pos + $i);
});

const u0$SPLib$Format$indent_combine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$indent_combine$1,
});

const u0$SPLib$Format$indent_width$1 = (($0) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), 0, $0, u0$SPLib$Format$indent_combine$0);
});

const u0$SPLib$Format$indent_width$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$indent_width$1,
});

const u0$SPLib$Format$spaces$1 = (($0) => {
  return (c0$Text$repeat$0.usr)(...(c0$Text$repeat$0.ctx), $0, " ");
});

const u0$SPLib$Format$spaces$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$spaces$1,
});

const u0$SPLib$Format$renderLine$1 = (($i, $l) => {
  return ((($l)[0] === "$Text_")
    ? ((() => {
      const $text = ($l)[1];
      return ((u0$SPLib$Format$spaces$0.usr)(...(u0$SPLib$Format$spaces$0.ctx), (u0$SPLib$Format$indent_width$0.usr)(...(u0$SPLib$Format$indent_width$0.ctx), $i)) + $text);
    }))()
    : ((($l)[0] === "$CommentWithIndent")
      ? ((() => {
        const $text = ($l)[1];
        return ((u0$SPLib$Format$spaces$0.usr)(...(u0$SPLib$Format$spaces$0.ctx), (u0$SPLib$Format$indent_width$0.usr)(...(u0$SPLib$Format$indent_width$0.ctx), $i)) + $text);
      }))()
      : ((($l)[0] === "$CommentIgnoreIndent")
        ? ((() => {
          const $text = ($l)[1];
          return $text;
        }))()
        : ((($l)[0] === "$Space")
          ? (u0$SPLib$Format$spaces$0.usr)(...(u0$SPLib$Format$spaces$0.ctx), (1 + (u0$SPLib$Format$indent_width$0.usr)(...(u0$SPLib$Format$indent_width$0.ctx), $i)))
          : ((($l)[0] === "$Row")
            ? ((() => {
              const $left = ($l)[1];
              const $right = ($l)[2];
              return ((u0$SPLib$Format$renderLine$0.usr)(...(u0$SPLib$Format$renderLine$0.ctx), $i, $left) + (u0$SPLib$Format$renderLine$0.usr)(...(u0$SPLib$Format$renderLine$0.ctx), c0$Core$Nil$0, $right));
            }))()
            : ((($l)[0] === "$Blank")
              ? ""
              : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 454:4', (sp_toHuman)($l))))))));
});

const u0$SPLib$Format$renderLine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$renderLine$1,
});

const u0$SPLib$Format$renderIndentedLine$1 = (($1) => {
  const $i = ($1)[1];
  const $line_ = ($1)[2];
  return ((c0$Text$trimRight$0.usr)(...(c0$Text$trimRight$0.ctx), (u0$SPLib$Format$renderLine$0.usr)(...(u0$SPLib$Format$renderLine$0.ctx), $i, (u0$SPLib$Format$stripEnd$0.usr)(...(u0$SPLib$Format$stripEnd$0.ctx), $line_))) + "\n");
});

const u0$SPLib$Format$renderIndentedLine$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$renderIndentedLine$1,
});

const u0$SPLib$Format$render$1 = (($block) => {
  return ((($block)[0] === "$Empty")
    ? ""
    : ((($block)[0] === "$SingleLine")
      ? ((() => {
        const $line_ = ($block)[2];
        return (u0$SPLib$Format$renderIndentedLine$0.usr)(...(u0$SPLib$Format$renderIndentedLine$0.ctx), $line_);
      }))()
      : ((($block)[0] === "$Stack")
        ? ((() => {
          const $l1 = ($block)[1];
          const $rest = ($block)[2];
          return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$renderIndentedLine$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $l1, $rest)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/SPLib/Format.sp 469:4', (sp_toHuman)($block)))));
});

const u0$SPLib$Format$render$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$render$1,
});

const u0$Compiler$TypeCheck$typeToHuman$1 = (($env, $raw) => {
  const $3 = $env.currentRootUsr;
  const $umr = ($3)[1];
  const $module = ((() => {
    const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $env.modulesByUmr);
    return ((($4)[0] === "$Nothing")
      ? u0$Compiler$CoreDefs$coreModule$0
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $m = ($4)[1];
          return $m;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 53:8', (sp_toHuman)($4))));
  }))();
  return (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), ({
    isRoot: true,
    originalContent: "",
  }), (u0$Human$Type$doRawType$0.usr)(...(u0$Human$Type$doRawType$0.ctx), $module, $raw)));
});

const u0$Compiler$TypeCheck$typeToHuman$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$typeToHuman$1,
});

const u0$Compiler$TypeCheck$addErError$1 = (($env, $equality, $message, $state) => {
  const $5 = $equality;
  const $why = $5.why;
  const $type2 = $5.type2;
  const $type1 = $5.type1;
  const $pos = $5.pos;
  const $context = $5.context;
  return (u0$Compiler$TypeCheck$addErrorText$0.usr)(...(u0$Compiler$TypeCheck$addErrorText$0.ctx), $env, $pos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $message, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($context), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($why), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TYPE 1 -----------------------", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck$typeToHuman$0.usr)(...(u0$Compiler$TypeCheck$typeToHuman$0.ctx), $env, $type1), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TYPE 2 -----------------------", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck$typeToHuman$0.usr)(...(u0$Compiler$TypeCheck$typeToHuman$0.ctx), $env, $type2), c0$Core$Nil$0))))))));
});

const u0$Compiler$TypeCheck$addErError$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addErError$1,
});

const u0$Compiler$TypeCheck$addErErrorIf$1 = (($env, $test, $equality, $message, $state) => {
  return ($test
    ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $equality, $message, $state)
    : null);
});

const u0$Compiler$TypeCheck$addErErrorIf$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addErErrorIf$1,
});

const u0$Compiler$TypeCheck$addError$1 = (($env, $pos, $error, $state) => {
  return (u0$Compiler$TypeCheck$addErrorText$0.usr)(...(u0$Compiler$TypeCheck$addErrorText$0.ctx), $env, $pos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($error), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($env.context), c0$Core$Nil$0)));
});

const u0$Compiler$TypeCheck$addError$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addError$1,
});

const u0$Compiler$TypeCheck$addSub$3 = (($replace, $subs, $univarId, $uniqueness) => {
  return (hash_insert)($subs, $univarId, ($replace.usr)(...($replace.ctx), $uniqueness));
});

const u0$Compiler$TypeCheck$addSub$2 = (($newId, $newUni, $uni) => {
  return ((($uni)[0] === "$Depends")
    ? ((() => {
      const $id = ($uni)[1];
      return ((sp_equal)($id, $newId)
        ? $newUni
        : $uni);
    }))()
    : (true
      ? $uni
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2817:8', (sp_toHuman)($uni))));
});

const u0$Compiler$TypeCheck$addSub$1 = (($newId, $newUni, $subs) => {
  const $replace = ({
    ctx: ([
      $newId,
      $newUni,
    ]),
    usr: u0$Compiler$TypeCheck$addSub$2,
  });
  (hash_each)($subs, ({
    ctx: ([
      $replace,
      $subs,
    ]),
    usr: u0$Compiler$TypeCheck$addSub$3,
  }));
  return (hash_insert)($subs, $newId, $newUni);
});

const u0$Compiler$TypeCheck$addSub$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addSub$1,
});

const u0$Compiler$TypeCheck$solveUniquenessConstraint$1 = (($env, $eq, $state) => {
  const $4 = (hash_get)($state.univarSubs, $eq.id);
  return ((($4)[0] === "$Nothing")
    ? (u0$Compiler$TypeCheck$addSub$0.usr)(...(u0$Compiler$TypeCheck$addSub$0.ctx), $eq.id, $eq.uni, $state.univarSubs)
    : ((($4)[0] === "$Just")
      ? ((() => {
        const $subUni = ($4)[1];
        return ((sp_equal)($subUni, $eq.uni)
          ? null
          : ((() => {
            const $5 = ({
              first: $subUni,
              second: $eq.uni,
            });
            return ((($5.first)[0] === "$Depends")
              ? ((() => {
                const $subId = ($5.first)[1];
                return (u0$Compiler$TypeCheck$addSub$0.usr)(...(u0$Compiler$TypeCheck$addSub$0.ctx), $subId, $eq.uni, $state.univarSubs);
              }))()
              : ((($5.second)[0] === "$Depends")
                ? ((() => {
                  const $newId = ($5.second)[1];
                  return (u0$Compiler$TypeCheck$addSub$0.usr)(...(u0$Compiler$TypeCheck$addSub$0.ctx), $newId, $subUni, $state.univarSubs);
                }))()
                : (true
                  ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $eq.pos, (u0$Compiler$TypeCheck$ErrorUnresolvableUniqueness$0.usr)(...(u0$Compiler$TypeCheck$ErrorUnresolvableUniqueness$0.ctx), $eq, $subUni), $state)
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2841:16', (sp_toHuman)($5)))));
          }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2831:4', (sp_toHuman)($4))));
});

const u0$Compiler$TypeCheck$solveUniquenessConstraint$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$solveUniquenessConstraint$1,
});

const u0$Compiler$TypeCheck$uniCanBeCastTo$1 = (($1) => {
  const $given = $1.given;
  const $required = $1.required;
  const $2 = ({
    first: $given,
    second: $required,
  });
  return ((($2.second)[0] === "$Imm")
    ? u0$Compiler$TypeCheck$CanBeCastYes$0
    : ((($2.first)[0] === "$Uni")
      ? u0$Compiler$TypeCheck$CanBeCastYes$0
      : (((($2.first)[0] === "$Imm") && (($2.second)[0] === "$Uni"))
        ? (u0$Compiler$TypeCheck$CanBeCastNo$0.usr)(...(u0$Compiler$TypeCheck$CanBeCastNo$0.ctx), c0$Core$Nil$0)
        : (((($2.first)[0] === "$Depends") && (($2.second)[0] === "$Uni"))
          ? ((() => {
            const $a = ($2.first)[1];
            return (u0$Compiler$TypeCheck$CanBeCastNo$0.usr)(...(u0$Compiler$TypeCheck$CanBeCastNo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
              first: $a,
              second: c0$Compiler$Ast$Uni$0,
            }), c0$Core$Nil$0));
          }))()
          : (((($2.first)[0] === "$Depends") && (($2.second)[0] === "$Depends"))
            ? ((() => {
              const $a = ($2.first)[1];
              const $b = ($2.second)[1];
              return ((sp_equal)($a, $b)
                ? u0$Compiler$TypeCheck$CanBeCastYes$0
                : (u0$Compiler$TypeCheck$CanBeCastNo$0.usr)(...(u0$Compiler$TypeCheck$CanBeCastNo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
                  first: $a,
                  second: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), $b),
                }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
                  first: $b,
                  second: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), $a),
                }), c0$Core$Nil$0))));
            }))()
            : (((($2.first)[0] === "$Imm") && (($2.second)[0] === "$Depends"))
              ? ((() => {
                const $b = ($2.second)[1];
                return (u0$Compiler$TypeCheck$CanBeCastNo$0.usr)(...(u0$Compiler$TypeCheck$CanBeCastNo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
                  first: $b,
                  second: c0$Compiler$Ast$Imm$0,
                }), c0$Core$Nil$0));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 681:4', (sp_toHuman)($2))))))));
});

const u0$Compiler$TypeCheck$uniCanBeCastTo$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$uniCanBeCastTo$1,
});

const u0$Compiler$TypeCheck$compareParTypes$1 = (($env, $currentEquality, $index, $p1, $p2, $state) => {
  const $7 = $currentEquality;
  const $why = $7.why;
  const $pos = $7.pos;
  const $expandedRecursives = $7.expandedRecursives;
  const $context = $7.context;
  const $8 = ({
    first: $p1,
    second: $p2,
  });
  return (((($8.first)[0] === "$ParRe") && (($8.second)[0] === "$ParRe"))
    ? ((() => {
      const $raw1 = ($8.first)[1];
      const $raw2 = ($8.second)[1];
      return (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ({
        context: $context,
        expandedRecursives: $expandedRecursives,
        pos: $pos,
        type1: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $raw1),
        type2: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $raw2),
        why: (u0$Compiler$TypeCheck$Why_FunctionInput$0.usr)(...(u0$Compiler$TypeCheck$Why_FunctionInput$0.ctx), $index, $why),
      }), $state);
    }))()
    : (((($8.first)[0] === "$ParSp") && (($8.second)[0] === "$ParSp"))
      ? ((() => {
        const $full1 = ($8.first)[1];
        const $full2 = ($8.second)[1];
        (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ({
          context: $context,
          expandedRecursives: $expandedRecursives,
          pos: $pos,
          type1: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $full1.raw),
          type2: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $full2.raw),
          why: (u0$Compiler$TypeCheck$Why_FunctionInput$0.usr)(...(u0$Compiler$TypeCheck$Why_FunctionInput$0.ctx), $index, $why),
        }), $state);
        const $9 = (u0$Compiler$TypeCheck$uniCanBeCastTo$0.usr)(...(u0$Compiler$TypeCheck$uniCanBeCastTo$0.ctx), ({
          given: $full1.uni,
          required: $full2.uni,
        }));
        ((($9)[0] === "$CanBeCastYes")
          ? null
          : (((($9)[0] === "$CanBeCastNo") && ((($9)[1])[0] === "$Nil"))
            ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $currentEquality, (("Function call par " + (text_fromNumber)($index)) + " with wrong uniqueness"), $state)
            : (((($9)[0] === "$CanBeCastNo") && ((($9)[1])[0] === "$Cons"))
              ? ((() => {
                const $id = (($9)[1])[1].first;
                const $uni = (($9)[1])[1].second;
                const $tail = (($9)[1])[2];
                return (u0$Compiler$TypeCheck$solveUniquenessConstraint$0.usr)(...(u0$Compiler$TypeCheck$solveUniquenessConstraint$0.ctx), $env, ({
                  context: $context,
                  id: $id,
                  pos: $pos,
                  uni: $uni,
                  why: "fn arg",
                }), $state);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2903:12', (sp_toHuman)($9)))));
        return null;
      }))()
      : (true
        ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, ((() => {
          const $0 = $currentEquality;
          return (Object.assign)({}, $0, ({
            why: (u0$Compiler$TypeCheck$Why_FunctionInput$0.usr)(...(u0$Compiler$TypeCheck$Why_FunctionInput$0.ctx), $index, $why),
          }));
        }))(), "recycling does not match", $state)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2879:4', (sp_toHuman)($8)))));
});

const u0$Compiler$TypeCheck$compareParTypes$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$compareParTypes$1,
});

const u0$Compiler$TypeCheck$newTyvarId$1 = (($state) => {
  return (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastUnificationVarId);
});

const u0$Compiler$TypeCheck$newTyvarId$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$newTyvarId$1,
});

const u0$Compiler$TypeCheck$applySubstitutionToType$3 = ((_0) => {
  return c0$Maybe$Nothing$0;
});

const u0$Compiler$TypeCheck$applySubstitutionToType$2 = (($replacingType, $tyvarId, $id) => {
  return ((sp_equal)($id, $tyvarId)
    ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $replacingType)
    : c0$Maybe$Nothing$0);
});

const u0$Compiler$TypeCheck$applySubstitutionToType$1 = (($tyvarId, $replacingType, $originalType) => {
  const $subsAsFns = ({
    lSet: c0$Basics$identity$0,
    ty: ({
      ctx: ([
        $replacingType,
        $tyvarId,
      ]),
      usr: u0$Compiler$TypeCheck$applySubstitutionToType$2,
    }),
    uni: ({
      ctx: [],
      usr: u0$Compiler$TypeCheck$applySubstitutionToType$3,
    }),
  });
  return (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), $subsAsFns, $originalType);
});

const u0$Compiler$TypeCheck$applySubstitutionToType$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$applySubstitutionToType$1,
});

const u0$Compiler$TypeCheck$occurs$4 = (($rec, $t) => {
  return ($rec.usr)(...($rec.ctx), (c0$Compiler$TypedAst$toRaw$0.usr)(...(c0$Compiler$TypedAst$toRaw$0.ctx), $t));
});

const u0$Compiler$TypeCheck$occurs$3 = (($rec, $k, $v) => {
  return ($rec.usr)(...($rec.ctx), $v);
});

const u0$Compiler$TypeCheck$occurs$2 = (($tyvarId, $0) => {
  return (u0$Compiler$TypeCheck$occurs$0.usr)(...(u0$Compiler$TypeCheck$occurs$0.ctx), $tyvarId, $0);
});

const u0$Compiler$TypeCheck$occurs$1 = (($tyvarId, $type) => {
  const $rec = ({
    ctx: ([
      $tyvarId,
    ]),
    usr: u0$Compiler$TypeCheck$occurs$2,
  });
  return ((($type)[0] === "$TypeFn")
    ? ((() => {
      const $ins = ($type)[3];
      const $out = ($type)[4];
      return ((c0$List$any$0.usr)(...(c0$List$any$0.ctx), ({
        ctx: ([
          $rec,
        ]),
        usr: u0$Compiler$TypeCheck$occurs$4,
      }), $ins) || ($rec.usr)(...($rec.ctx), $out.raw));
    }))()
    : ((($type)[0] === "$TypeVar")
      ? ((() => {
        const $id = ($type)[2];
        return (sp_equal)($id, $tyvarId);
      }))()
      : ((($type)[0] === "$TypeExact")
        ? ((() => {
          const $usr = ($type)[2];
          const $args = ($type)[3];
          return (c0$List$any$0.usr)(...(c0$List$any$0.ctx), $rec, $args);
        }))()
        : ((($type)[0] === "$TypeRecord")
          ? ((() => {
            const $attrs = ($type)[3];
            return (c0$Dict$any$0.usr)(...(c0$Dict$any$0.ctx), ({
              ctx: ([
                $rec,
              ]),
              usr: u0$Compiler$TypeCheck$occurs$3,
            }), $attrs);
          }))()
          : ((($type)[0] === "$TypeError")
            ? false
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 3064:4', (sp_toHuman)($type)))))));
});

const u0$Compiler$TypeCheck$occurs$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$occurs$1,
});

const u0$Compiler$TypeCheck$replaceUnificationVariable$2 = (($new, $replacingType, $tyvarId, $tId, $rawType) => {
  return (hash_insert)($new, $tId, (u0$Compiler$TypeCheck$applySubstitutionToType$0.usr)(...(u0$Compiler$TypeCheck$applySubstitutionToType$0.ctx), $tyvarId, $replacingType, $rawType));
});

const u0$Compiler$TypeCheck$replaceUnificationVariable$1 = (($env, $equality, $tyvarId, $replacingType, $state) => {
  const $isSame = ((($replacingType)[0] === "$TypeVar")
    ? ((() => {
      const $tyvarId2 = ($replacingType)[2];
      return (sp_equal)($tyvarId, $tyvarId2);
    }))()
    : (true
      ? false
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 3039:8', (sp_toHuman)($replacingType))));
  return ($isSame
    ? null
    : ((u0$Compiler$TypeCheck$occurs$0.usr)(...(u0$Compiler$TypeCheck$occurs$0.ctx), $tyvarId, $replacingType)
      ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $equality, "circular!?", $state)
      : ((() => {
        let $new = (hash_fromList)(c0$Core$Nil$0);
        (hash_each)($state.tyvarSubs, ({
          ctx: ([
            $new,
            $replacingType,
            $tyvarId,
          ]),
          usr: u0$Compiler$TypeCheck$replaceUnificationVariable$2,
        }));
        (hash_insert)($new, $tyvarId, $replacingType);
        return ($state.tyvarSubs = $new);
      }))()));
});

const u0$Compiler$TypeCheck$replaceUnificationVariable$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$replaceUnificationVariable$1,
});

const u0$Compiler$TypeCheck$solveRecordExt$2 = (($attrs2, $context, $env, $equality, $state, $swapEquality, $name, $type1) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $attrs2);
  return ((($3)[0] === "$Nothing")
    ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $equality, ("missing attribute " + $name), $state)
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $type2 = ($3)[1];
        const $4 = ($swapEquality
          ? ({
            first: $type2,
            second: $type1,
          })
          : ({
            first: $type1,
            second: $type2,
          }));
        const $b = $4.second;
        const $a = $4.first;
        return (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ((() => {
          const $0 = $equality;
          return (Object.assign)({}, $0, ({
            context: (u0$Compiler$TypeCheck$Context_AttributeName$0.usr)(...(u0$Compiler$TypeCheck$Context_AttributeName$0.ctx), $name, $context),
            type1: $a,
            type2: $b,
          }));
        }))(), $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 3017:8', (sp_toHuman)($3))));
});

const u0$Compiler$TypeCheck$solveRecordExt$1 = (($env, $equality, $swapEquality, $tyvar1, $attrs1, $attrs2, $state) => {
  const $8 = $equality;
  const $why = $8.why;
  const $pos = $8.pos;
  const $context = $8.context;
  (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $attrs1, ({
    ctx: ([
      $attrs2,
      $context,
      $env,
      $equality,
      $state,
      $swapEquality,
    ]),
    usr: u0$Compiler$TypeCheck$solveRecordExt$2,
  }));
  return (u0$Compiler$TypeCheck$replaceUnificationVariable$0.usr)(...(u0$Compiler$TypeCheck$replaceUnificationVariable$0.ctx), $env, $equality, $tyvar1, (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $pos, c0$Maybe$Nothing$0, $attrs2), $state);
});

const u0$Compiler$TypeCheck$solveRecordExt$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$solveRecordExt$1,
});

const u0$SPLib$UnionFind$find$1 = (($uf, $i) => {
  const $3 = (hash_get)($uf, $i);
  return ((($3)[0] === "$Nothing")
    ? ((() => {
      (hash_insert)($uf, $i, $i);
      return $i;
    }))()
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $parent = ($3)[1];
        return ((sp_equal)($parent, $i)
          ? $i
          : ((() => {
            const $result = (u0$SPLib$UnionFind$find$0.usr)(...(u0$SPLib$UnionFind$find$0.ctx), $uf, $parent);
            (hash_insert)($uf, $i, $result);
            return $result;
          }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/UnionFind.sp 20:4', (sp_toHuman)($3))));
});

const u0$SPLib$UnionFind$find$0 = ({
  ctx: [],
  usr: u0$SPLib$UnionFind$find$1,
});

const u0$SPLib$UnionFind$union$1 = (($uf, $i, $j) => {
  const $iRep = (u0$SPLib$UnionFind$find$0.usr)(...(u0$SPLib$UnionFind$find$0.ctx), $uf, $i);
  const $jRep = (u0$SPLib$UnionFind$find$0.usr)(...(u0$SPLib$UnionFind$find$0.ctx), $uf, $j);
  return (hash_insert)($uf, $iRep, $jRep);
});

const u0$SPLib$UnionFind$union$0 = ({
  ctx: [],
  usr: u0$SPLib$UnionFind$union$1,
});

const u0$Compiler$TypeCheck$solveEquality$5 = (($env, $head, $state, $usr1, $why, $index, $raw1, $raw2) => {
  return (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ((() => {
    const $0 = $head;
    return (Object.assign)({}, $0, ({
      type1: $raw1,
      type2: $raw2,
      why: (u0$Compiler$TypeCheck$Why_TypeArgument$0.usr)(...(u0$Compiler$TypeCheck$Why_TypeArgument$0.ctx), $usr1, $index, $why),
    }));
  }))(), $state);
});

const u0$Compiler$TypeCheck$solveEquality$4 = (($env, $head, $state, $0, $1, $2) => {
  return (u0$Compiler$TypeCheck$compareParTypes$0.usr)(...(u0$Compiler$TypeCheck$compareParTypes$0.ctx), $env, $head, $0, $1, $2, $state);
});

const u0$Compiler$TypeCheck$solveEquality$3 = (($env, $head, $state, $why, $attrName, $1) => {
  const $attrType1 = $1.first;
  const $attrType2 = $1.second;
  return (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ((() => {
    const $0 = $head;
    return (Object.assign)({}, $0, ({
      type1: $attrType1,
      type2: $attrType2,
      why: (u0$Compiler$TypeCheck$Why_Attribute$0.usr)(...(u0$Compiler$TypeCheck$Why_Attribute$0.ctx), $why),
    }));
  }))(), $state);
});

const u0$Compiler$TypeCheck$solveEquality$2 = (($context, $env, $expandedRecursives, $pos, $state, $why, $name, $1) => {
  const $t1 = $1.first;
  const $t2 = $1.second;
  return (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ({
    context: (u0$Compiler$TypeCheck$Context_AttributeName$0.usr)(...(u0$Compiler$TypeCheck$Context_AttributeName$0.ctx), $name, $context),
    expandedRecursives: $expandedRecursives,
    pos: $pos,
    type1: $t1,
    type2: $t1,
    why: $why,
  }), $state);
});

const u0$Compiler$TypeCheck$solveEquality$1 = (($env, $head, $state) => {
  const $4 = $head;
  const $why = $4.why;
  const $type2 = $4.type2;
  const $type1 = $4.type1;
  const $pos = $4.pos;
  const $expandedRecursives = $4.expandedRecursives;
  const $context = $4.context;
  const $5 = ({
    first: $type1,
    second: $type2,
  });
  return ((($5.first)[0] === "$TypeVar")
    ? ((() => {
      const $tyvarId = ($5.first)[2];
      const $t2 = $5.second;
      return (u0$Compiler$TypeCheck$replaceUnificationVariable$0.usr)(...(u0$Compiler$TypeCheck$replaceUnificationVariable$0.ctx), $env, $head, $tyvarId, $t2, $state);
    }))()
    : ((($5.second)[0] === "$TypeVar")
      ? ((() => {
        const $t1 = $5.first;
        const $tyvarId = ($5.second)[2];
        return (u0$Compiler$TypeCheck$replaceUnificationVariable$0.usr)(...(u0$Compiler$TypeCheck$replaceUnificationVariable$0.ctx), $env, $head, $tyvarId, $t1, $state);
      }))()
      : (((($5.first)[0] === "$TypeExact") && (($5.second)[0] === "$TypeExact"))
        ? ((() => {
          const $usr1 = ($5.first)[2];
          const $args1 = ($5.first)[3];
          const $usr2 = ($5.second)[2];
          const $args2 = ($5.second)[3];
          return ((sp_not_equal)($usr1, $usr2)
            ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $head, "types are incompatible2", $state)
            : ((() => {
              (c0$List$indexedEach2$0.usr)(...(c0$List$indexedEach2$0.ctx), $args2, $args1, ({
                ctx: ([
                  $env,
                  $head,
                  $state,
                  $usr1,
                  $why,
                ]),
                usr: u0$Compiler$TypeCheck$solveEquality$5,
              }));
              return null;
            }))());
        }))()
        : (((($5.first)[0] === "$TypeFn") && (($5.second)[0] === "$TypeFn"))
          ? ((() => {
            const $set1 = ($5.first)[2];
            const $pars1 = ($5.first)[3];
            const $out1 = ($5.first)[4];
            const $set2 = ($5.second)[2];
            const $pars2 = ($5.second)[3];
            const $out2 = ($5.second)[4];
            return ((sp_not_equal)((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $pars1), (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $pars2))
              ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $head, "functions expect a different number of arguments", $state)
              : ((() => {
                (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ((() => {
                  const $0 = $head;
                  return (Object.assign)({}, $0, ({
                    type1: $out1.raw,
                    type2: $out2.raw,
                    why: (u0$Compiler$TypeCheck$Why_FunctionOutput$0.usr)(...(u0$Compiler$TypeCheck$Why_FunctionOutput$0.ctx), $why),
                  }));
                }))(), $state);
                const $6 = (u0$Compiler$TypeCheck$uniCanBeCastTo$0.usr)(...(u0$Compiler$TypeCheck$uniCanBeCastTo$0.ctx), ({
                  given: $out2.uni,
                  required: $out1.uni,
                }));
                ((($6)[0] === "$CanBeCastYes")
                  ? null
                  : (((($6)[0] === "$CanBeCastNo") && ((($6)[1])[0] === "$Nil"))
                    ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $head, "the function return type have different uniqueness", $state)
                    : (((($6)[0] === "$CanBeCastNo") && ((($6)[1])[0] === "$Cons"))
                      ? ((() => {
                        const $id = (($6)[1])[1].first;
                        const $uni = (($6)[1])[1].second;
                        const $tail = (($6)[1])[2];
                        return (u0$Compiler$TypeCheck$solveUniquenessConstraint$0.usr)(...(u0$Compiler$TypeCheck$solveUniquenessConstraint$0.ctx), $env, ({
                          context: $context,
                          id: $id,
                          pos: $pos,
                          uni: $uni,
                          why: "fn out",
                        }), $state);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2951:16', (sp_toHuman)($6)))));
                (u0$SPLib$UnionFind$union$0.usr)(...(u0$SPLib$UnionFind$union$0.ctx), $state.lambdaSetUnionFind, $set1, $set2);
                return (c0$List$indexedEach2$0.usr)(...(c0$List$indexedEach2$0.ctx), $pars1, $pars2, ({
                  ctx: ([
                    $env,
                    $head,
                    $state,
                  ]),
                  usr: u0$Compiler$TypeCheck$solveEquality$4,
                }));
              }))());
          }))()
          : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[2])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[2])[0] === "$Nothing"))))
            ? ((() => {
              const $attrs1 = ($5.first)[3];
              const $attrs2 = ($5.second)[3];
              const $6 = (c0$Dict$onlyBothOnly$0.usr)(...(c0$Dict$onlyBothOnly$0.ctx), $attrs1, $attrs2);
              const $only2 = $6.third;
              const $both = $6.second;
              const $only1 = $6.first;
              (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $both, ({
                ctx: ([
                  $env,
                  $head,
                  $state,
                  $why,
                ]),
                usr: u0$Compiler$TypeCheck$solveEquality$3,
              }));
              return (u0$Compiler$TypeCheck$addErErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErErrorIf$0.ctx), $env, ((sp_not_equal)($only1, c0$Dict$empty$0) || (sp_not_equal)($only2, c0$Dict$empty$0)), $head, "record attrs don't match", $state);
            }))()
            : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[2])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[2])[0] === "$Nothing"))))
              ? ((() => {
                const $tyvar1 = (($5.first)[2])[1];
                const $attrs1 = ($5.first)[3];
                const $attrs2 = ($5.second)[3];
                return (u0$Compiler$TypeCheck$solveRecordExt$0.usr)(...(u0$Compiler$TypeCheck$solveRecordExt$0.ctx), $env, $head, false, $tyvar1, $attrs1, $attrs2, $state);
              }))()
              : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[2])[0] === "$Nothing") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[2])[0] === "$Just"))))
                ? ((() => {
                  const $attrs1 = ($5.first)[3];
                  const $tyvar2 = (($5.second)[2])[1];
                  const $attrs2 = ($5.second)[3];
                  return (u0$Compiler$TypeCheck$solveRecordExt$0.usr)(...(u0$Compiler$TypeCheck$solveRecordExt$0.ctx), $env, $head, true, $tyvar2, $attrs2, $attrs1, $state);
                }))()
                : (((($5.first)[0] === "$TypeRecord") && (((($5.first)[2])[0] === "$Just") && ((($5.second)[0] === "$TypeRecord") && ((($5.second)[2])[0] === "$Just"))))
                  ? ((() => {
                    const $p = ($5.first)[1];
                    const $tyvar1 = (($5.first)[2])[1];
                    const $attrs1 = ($5.first)[3];
                    const $tyvar2 = (($5.second)[2])[1];
                    const $attrs2 = ($5.second)[3];
                    const $6 = (c0$Dict$onlyBothOnly$0.usr)(...(c0$Dict$onlyBothOnly$0.ctx), $attrs1, $attrs2);
                    const $only2 = $6.third;
                    const $both = $6.second;
                    const $only1 = $6.first;
                    const $newExtId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
                    const $newType = (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $newExtId), (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $attrs1, $only2));
                    (u0$Compiler$TypeCheck$replaceUnificationVariable$0.usr)(...(u0$Compiler$TypeCheck$replaceUnificationVariable$0.ctx), $env, $head, $tyvar1, $newType, $state);
                    (u0$Compiler$TypeCheck$replaceUnificationVariable$0.usr)(...(u0$Compiler$TypeCheck$replaceUnificationVariable$0.ctx), $env, $head, $tyvar2, $newType, $state);
                    return (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $both, ({
                      ctx: ([
                        $context,
                        $env,
                        $expandedRecursives,
                        $pos,
                        $state,
                        $why,
                      ]),
                      usr: u0$Compiler$TypeCheck$solveEquality$2,
                    }));
                  }))()
                  : ((($5.first)[0] === "$TypeError")
                    ? null
                    : ((($5.second)[0] === "$TypeError")
                      ? null
                      : (true
                        ? (u0$Compiler$TypeCheck$addErError$0.usr)(...(u0$Compiler$TypeCheck$addErError$0.ctx), $env, $head, "types are incompatible1", $state)
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2922:4', (sp_toHuman)($5)))))))))))));
});

const u0$Compiler$TypeCheck$solveEquality$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$solveEquality$1,
});

const u0$Compiler$TypeCheck$addEquality$1 = (($env, $pos, $why, $t1, $t2, $state) => {
  return (u0$Compiler$TypeCheck$solveEquality$0.usr)(...(u0$Compiler$TypeCheck$solveEquality$0.ctx), $env, ({
    context: $env.context,
    expandedRecursives: c0$Set$empty$0,
    pos: $pos,
    type1: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $t1),
    type2: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $t2),
    why: $why,
  }), $state);
});

const u0$Compiler$TypeCheck$addEquality$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addEquality$1,
});

const u0$Compiler$TypeCheck$addErrorIf$1 = (($test, $env, $pos, $error, $state) => {
  return ($test
    ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, $error, $state)
    : null);
});

const u0$Compiler$TypeCheck$addErrorIf$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addErrorIf$1,
});

const u0$Compiler$Error$positionToLineAndColumn$1 = (($s, $index) => {
  const $before = (text_slice)(0, $index, $s);
  const $lines = (text_split)("\n", $before);
  const $lineNumber = (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $lines);
  const $colNumber = (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), 0, (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), ({
    ctx: [],
    usr: text_length,
  }), (c0$List$last$0.usr)(...(c0$List$last$0.ctx), $lines)));
  return ({
    col: $colNumber,
    line: $lineNumber,
  });
});

const u0$Compiler$Error$positionToLineAndColumn$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$positionToLineAndColumn$1,
});

const u0$Compiler$Error$highlightSplit$1 = (($h, $x) => {
  const $3 = $x;
  const $lines = $3.second;
  const $words = $3.first;
  return ((($h)[0] === "$HighlightWord")
    ? ((() => {
      const $colEnd = ($h)[1].colEnd;
      const $colStart = ($h)[1].colStart;
      const $line = ($h)[1].line;
      return ({
        first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $line, ({
          first: $colStart,
          second: $colEnd,
        }), $words),
        second: $lines,
      });
    }))()
    : ((($h)[0] === "$HighlightBlock")
      ? ((() => {
        const $lineEnd = ($h)[1].lineEnd;
        const $lineStart = ($h)[1].lineStart;
        return ({
          first: $words,
          second: (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $lines, (c0$List$range$0.usr)(...(c0$List$range$0.ctx), $lineStart, $lineEnd), c0$Set$insert$0),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 137:4', (sp_toHuman)($h))));
});

const u0$Compiler$Error$highlightSplit$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$highlightSplit$1,
});

const u0$Compiler$Error$formatSeparator$0 = "$|$|$";

const u0$Compiler$Error$formatSuffix$0 = "$`$`$";

const u0$Compiler$Error$formatWrap$1 = (($fmtName, $text) => {
  return ((((u0$Compiler$Error$formatSeparator$0 + $fmtName) + u0$Compiler$Error$formatSuffix$0) + $text) + u0$Compiler$Error$formatSeparator$0);
});

const u0$Compiler$Error$formatWrap$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$formatWrap$1,
});

const u0$Compiler$Error$warn$1 = (($0) => {
  return (u0$Compiler$Error$formatWrap$0.usr)(...(u0$Compiler$Error$formatWrap$0.ctx), "warning", $0);
});

const u0$Compiler$Error$warn$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$warn$1,
});

const u0$Compiler$Error$fmtBlock$5 = (($s) => {
  return ($s + "\n");
});

const u0$Compiler$Error$fmtBlock$4 = (($lineDem, $pad, $start, $wordHighlight, $i, $line) => {
  const $index = ($i + $start);
  const $s = (c0$Text$padLeft$0.usr)(...(c0$Text$padLeft$0.ctx), $pad, " ", (text_fromNumber)($index));
  return ((($s + ($lineDem.usr)(...($lineDem.ctx), $index)) + $line) + ($wordHighlight.usr)(...($wordHighlight.ctx), $index));
});

const u0$Compiler$Error$fmtBlock$3 = (($highlightedLines, $lineIndex) => {
  return ((c0$Set$member$0.usr)(...(c0$Set$member$0.ctx), $lineIndex, $highlightedLines)
    ? (u0$Compiler$Error$warn$0.usr)(...(u0$Compiler$Error$warn$0.ctx), " > ")
    : " | ");
});

const u0$Compiler$Error$fmtBlock$2 = (($highlightedWords, $pad, $lineNumber) => {
  const $2 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $lineNumber, $highlightedWords);
  return ((($2)[0] === "$Nothing")
    ? ""
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $s = ($2)[1].first;
        const $e = ($2)[1].second;
        return (((("\n" + (c0$Text$repeat$0.usr)(...(c0$Text$repeat$0.ctx), $pad, " ")) + "    ") + (c0$Text$repeat$0.usr)(...(c0$Text$repeat$0.ctx), ($s - 1), " ")) + (u0$Compiler$Error$warn$0.usr)(...(u0$Compiler$Error$warn$0.ctx), (c0$Text$repeat$0.usr)(...(c0$Text$repeat$0.ctx), (c0$Basics$max$0.usr)(...(c0$Basics$max$0.ctx), 1, ($e - $s)), "`")));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 154:8', (sp_toHuman)($2))));
});

const u0$Compiler$Error$fmtBlock$1 = (($start, $highlights, $ls) => {
  const $4 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
    first: c0$Dict$empty$0,
    second: c0$Set$empty$0,
  }), $highlights, u0$Compiler$Error$highlightSplit$0);
  const $highlightedLines = $4.second;
  const $highlightedWords = $4.first;
  const $pad = (text_length)((text_fromNumber)(($start + (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $ls))));
  const $wordHighlight = ({
    ctx: ([
      $highlightedWords,
      $pad,
    ]),
    usr: u0$Compiler$Error$fmtBlock$2,
  });
  const $lineDem = ({
    ctx: ([
      $highlightedLines,
    ]),
    usr: u0$Compiler$Error$fmtBlock$3,
  });
  const $fmtLine = ({
    ctx: ([
      $lineDem,
      $pad,
      $start,
      $wordHighlight,
    ]),
    usr: u0$Compiler$Error$fmtBlock$4,
  });
  return (({
    ctx: [],
    usr: u0$Compiler$Error$fmtBlock$5,
  }).usr)(...(({
    ctx: [],
    usr: u0$Compiler$Error$fmtBlock$5,
  }).ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), $fmtLine, $ls)));
});

const u0$Compiler$Error$fmtBlock$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$fmtBlock$1,
});

const u0$Compiler$Error$showCodeBlock$1 = (($code, $start, $end) => {
  return (($end.line < 0)
    ? ""
    : ((() => {
      const $highlight = ((sp_not_equal)($start.line, $end.line)
        ? (u0$Compiler$Error$HighlightBlock$0.usr)(...(u0$Compiler$Error$HighlightBlock$0.ctx), ({
          lineEnd: $end.line,
          lineStart: $start.line,
        }))
        : (u0$Compiler$Error$HighlightWord$0.usr)(...(u0$Compiler$Error$HighlightWord$0.ctx), ({
          colEnd: $end.col,
          colStart: $start.col,
          line: $start.line,
        })));
      const $extraLines = 2;
      const $lines = (text_split)("\n", $code);
      const $maxLines = (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $lines);
      const $startLine = (c0$Basics$clamp$0.usr)(...(c0$Basics$clamp$0.ctx), 0, ($maxLines - 1), (($start.line - $extraLines) - 1));
      const $endLine = (c0$Basics$clamp$0.usr)(...(c0$Basics$clamp$0.ctx), 0, ($maxLines - 1), ($end.line + $extraLines));
      const $size = (c0$Basics$max$0.usr)(...(c0$Basics$max$0.ctx), 1, ($endLine - $startLine));
      return (u0$Compiler$Error$fmtBlock$0.usr)(...(u0$Compiler$Error$fmtBlock$0.ctx), ($startLine + 1), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $highlight, c0$Core$Nil$0), (c0$List$take$0.usr)(...(c0$List$take$0.ctx), $size, (c0$List$drop$0.usr)(...(c0$List$drop$0.ctx), $startLine, $lines)));
    }))());
});

const u0$Compiler$Error$showCodeBlock$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$showCodeBlock$1,
});

const u0$Compiler$Error$posToHuman$2 = (($loc) => {
  return ({
    block: "",
    location: $loc,
  });
});

const u0$Compiler$Error$posToHuman$1 = (($mod, $pos) => {
  const $noBlock = ({
    ctx: [],
    usr: u0$Compiler$Error$posToHuman$2,
  });
  return ((($pos)[0] === "$P")
    ? ((() => {
      const $startAsInt = ($pos)[1];
      const $endAsInt = ($pos)[2];
      const $start = (u0$Compiler$Error$positionToLineAndColumn$0.usr)(...(u0$Compiler$Error$positionToLineAndColumn$0.ctx), $mod.content, $startAsInt);
      const $end = (u0$Compiler$Error$positionToLineAndColumn$0.usr)(...(u0$Compiler$Error$positionToLineAndColumn$0.ctx), $mod.content, $endAsInt);
      return ({
        block: (u0$Compiler$Error$showCodeBlock$0.usr)(...(u0$Compiler$Error$showCodeBlock$0.ctx), $mod.content, $start, $end),
        location: (((($mod.fsPath + " ") + (text_fromNumber)($start.line)) + ":") + (text_fromNumber)($start.col)),
      });
    }))()
    : ((($pos)[0] === "$End")
      ? ((() => {
        const $end = (u0$Compiler$Error$positionToLineAndColumn$0.usr)(...(u0$Compiler$Error$positionToLineAndColumn$0.ctx), $mod.content, ((text_length)($mod.content) - 1));
        const $start = ({
          col: 0,
          line: ($end.line - 8),
        });
        return ({
          block: (u0$Compiler$Error$showCodeBlock$0.usr)(...(u0$Compiler$Error$showCodeBlock$0.ctx), $mod.content, $start, $end),
          location: ((($mod.fsPath + " ") + (text_fromNumber)($end.line)) + ":0 (end of file)"),
        });
      }))()
      : ((($pos)[0] === "$N")
        ? ($noBlock.usr)(...($noBlock.ctx), "<native code>")
        : ((($pos)[0] === "$S")
          ? ($noBlock.usr)(...($noBlock.ctx), "<the location information has been stripped>")
          : ((($pos)[0] === "$T")
            ? ($noBlock.usr)(...($noBlock.ctx), "<defined in test modules>")
            : ((($pos)[0] === "$I")
              ? ((() => {
                const $n = ($pos)[1];
                return ($noBlock.usr)(...($noBlock.ctx), (("<inferred " + (text_fromNumber)($n)) + ">"));
              }))()
              : ((($pos)[0] === "$G")
                ? ($noBlock.usr)(...($noBlock.ctx), "<generated>")
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 238:4', (sp_toHuman)($pos)))))))));
});

const u0$Compiler$Error$posToHuman$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$posToHuman$1,
});

const u0$Compiler$TypeCheck$replaceUnivarRec$5 = (($doRaw, $k, $v) => {
  return ($doRaw.usr)(...($doRaw.ctx), $v);
});

const u0$Compiler$TypeCheck$replaceUnivarRec$4 = (($doRaw, $doUni, $par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $r = ($par)[1];
      return (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), ($doRaw.usr)(...($doRaw.ctx), $r));
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $f = ($par)[1];
        return (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), ({
          raw: ($doRaw.usr)(...($doRaw.ctx), $f.raw),
          uni: ($doUni.usr)(...($doUni.ctx), $f.uni),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 509:16', (sp_toHuman)($par))));
});

const u0$Compiler$TypeCheck$replaceUnivarRec$3 = (($new, $old, $uni) => {
  return ((($uni)[0] === "$Depends")
    ? ((() => {
      const $id = ($uni)[1];
      return ((sp_equal)($id, $old)
        ? $new
        : $uni);
    }))()
    : (true
      ? $uni
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 503:16', (sp_toHuman)($uni))));
});

const u0$Compiler$TypeCheck$replaceUnivarRec$2 = (($new, $old, $0) => {
  return (u0$Compiler$TypeCheck$replaceUnivarRec$0.usr)(...(u0$Compiler$TypeCheck$replaceUnivarRec$0.ctx), $old, $new, $0);
});

const u0$Compiler$TypeCheck$replaceUnivarRec$1 = (($old, $new, $raw) => {
  const $doRaw = ({
    ctx: ([
      $new,
      $old,
    ]),
    usr: u0$Compiler$TypeCheck$replaceUnivarRec$2,
  });
  return ((($raw)[0] === "$TypeExact")
    ? ((() => {
      const $p = ($raw)[1];
      const $usr = ($raw)[2];
      const $args = ($raw)[3];
      return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), $p, $usr, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $doRaw, $args));
    }))()
    : ((($raw)[0] === "$TypeRecord")
      ? ((() => {
        const $p = ($raw)[1];
        const $maybeExt = ($raw)[2];
        const $attrs = ($raw)[3];
        return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, $maybeExt, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
          ctx: ([
            $doRaw,
          ]),
          usr: u0$Compiler$TypeCheck$replaceUnivarRec$5,
        }), $attrs));
      }))()
      : ((($raw)[0] === "$TypeError")
        ? c0$Compiler$TypedAst$TypeError$0
        : ((($raw)[0] === "$TypeVar")
          ? ((() => {
            const $p = ($raw)[1];
            const $id = ($raw)[2];
            return (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $p, $id);
          }))()
          : ((($raw)[0] === "$TypeFn")
            ? ((() => {
              const $p = ($raw)[1];
              const $instances = ($raw)[2];
              const $ins = ($raw)[3];
              const $out = ($raw)[4];
              const $doUni = ({
                ctx: ([
                  $new,
                  $old,
                ]),
                usr: u0$Compiler$TypeCheck$replaceUnivarRec$3,
              });
              const $mapPar = ({
                ctx: ([
                  $doRaw,
                  $doUni,
                ]),
                usr: u0$Compiler$TypeCheck$replaceUnivarRec$4,
              });
              return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $p, $instances, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $mapPar, $ins), ({
                raw: ($doRaw.usr)(...($doRaw.ctx), $out.raw),
                uni: ($doUni.usr)(...($doUni.ctx), $out.uni),
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 486:4', (sp_toHuman)($raw)))))));
});

const u0$Compiler$TypeCheck$replaceUnivarRec$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$replaceUnivarRec$1,
});

const u0$Compiler$TypeCheck$generalize$7 = ((_0) => {
  return c0$Maybe$Nothing$0;
});

const u0$Compiler$TypeCheck$generalize$6 = (($originalSetId, $setId, $id) => {
  return ((sp_equal)($id, $originalSetId)
    ? $setId
    : $id);
});

const u0$Compiler$TypeCheck$generalize$5 = ((_0) => {
  return c0$Maybe$Nothing$0;
});

const u0$Compiler$TypeCheck$generalize$4 = (($state, $originalSetId, $constraints, $a) => {
  const $setId = (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaSetId);
  (hash_insert)($state.lambdaSetConstraints, $setId, $constraints);
  return (c0$Compiler$TypedAst$resolveRaw$0.usr)(...(c0$Compiler$TypedAst$resolveRaw$0.ctx), ({
    lSet: ({
      ctx: ([
        $originalSetId,
        $setId,
      ]),
      usr: u0$Compiler$TypeCheck$generalize$6,
    }),
    ty: ({
      ctx: [],
      usr: u0$Compiler$TypeCheck$generalize$5,
    }),
    uni: ({
      ctx: [],
      usr: u0$Compiler$TypeCheck$generalize$7,
    }),
  }), $a);
});

const u0$Compiler$TypeCheck$generalize$3 = (($state, $originalTyvarId, $tyvar, $a) => {
  const $generalizedTyvarId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
  (hash_insert)($state.tyvarsById, $generalizedTyvarId, $tyvar);
  return (u0$Compiler$TypeCheck$applySubstitutionToType$0.usr)(...(u0$Compiler$TypeCheck$applySubstitutionToType$0.ctx), $originalTyvarId, (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$G$0, $generalizedTyvarId), $a);
});

const u0$Compiler$TypeCheck$generalize$2 = (($state, $originalUnivarId, _1, $r) => {
  const $newUnivarId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
  return (u0$Compiler$TypeCheck$replaceUnivarRec$0.usr)(...(u0$Compiler$TypeCheck$replaceUnivarRec$0.ctx), $originalUnivarId, (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), $newUnivarId), $r);
});

const u0$Compiler$TypeCheck$generalize$1 = (($env, $pos, $ref, $instance, $state) => {
  const $replaceUnivar = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$generalize$2,
  });
  const $replaceTyvar = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$generalize$3,
  });
  const $replaceLambdaSet = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$generalize$4,
  });
  const $raw = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $instance.type.raw, $instance.freeUnivars, $replaceUnivar), $instance.freeTyvars, $replaceTyvar), $instance.lambdaSetConstraints, $replaceLambdaSet);
  const $0 = $instance.type;
  return (Object.assign)({}, $0, ({
    raw: $raw,
  }));
});

const u0$Compiler$TypeCheck$generalize$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$generalize$1,
});

const u0$Compiler$TypeCheck$getConstructorByUsr$1 = (($usr, $env) => {
  return (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $env.constructors);
});

const u0$Compiler$TypeCheck$getConstructorByUsr$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getConstructorByUsr$1,
});

const u0$Compiler$TypeCheck$coreTypeNumber$0 = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$N$0, u0$Compiler$CoreDefs$numberDef$0.usr, c0$Core$Nil$0);

const u0$Compiler$TypeCheck$coreTypeText$0 = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$N$0, u0$Compiler$CoreDefs$textDef$0.usr, c0$Core$Nil$0);

const u0$Compiler$TypeCheck$newRawType$1 = (($state) => {
  return (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$G$0, (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state));
});

const u0$Compiler$TypeCheck$newRawType$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$newRawType$1,
});

const u0$Compiler$TypeCheck$translateAnnotationType$4 = (($state, $0) => {
  return (array_push)($state.errors, $0);
});

const u0$Compiler$TypeCheck$translateAnnotationType$3 = (($state, _0) => {
  return (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaSetId);
});

const u0$Compiler$TypeCheck$translateAnnotationType$2 = (($k, $v) => {
  return (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$G$0, $v);
});

const u0$Compiler$TypeCheck$translateAnnotationType$1 = (($env, $state, $ca) => {
  return (u0$Compiler$TypeCheck$translateRawType$0.usr)(...(u0$Compiler$TypeCheck$translateRawType$0.ctx), ({
    argsByName: (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
      ctx: [],
      usr: u0$Compiler$TypeCheck$translateAnnotationType$2,
    }), $env.annotatedTyvarsByName),
    env: $env,
    newLambdaSetId: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$translateAnnotationType$3,
    })),
    originalIdToNewId: $env.annotatedUnivarsByOriginalId,
    pushError: ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$translateAnnotationType$4,
    }),
  }), $ca);
});

const u0$Compiler$TypeCheck$translateAnnotationType$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$translateAnnotationType$1,
});

const u0$Compiler$TypeCheck$inferPatternAny$3 = (($state, $id, _1, $acc) => {
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $id, $acc)
    ? $acc
    : (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $id, (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state), $acc));
});

const u0$Compiler$TypeCheck$inferPatternAny$2 = (($state, $name, $2, $acc) => {
  const $nonFn = $2.nonFn;
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $acc)
    ? $acc
    : (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state), $acc));
});

const u0$Compiler$TypeCheck$inferPatternAny$1 = (($baseEnv, $pos, $uni, $maybeName, $maybeAnnotation, $state) => {
  const $7 = ((($maybeAnnotation)[0] === "$Nothing")
    ? ({
      first: (u0$Compiler$TypeCheck$newRawType$0.usr)(...(u0$Compiler$TypeCheck$newRawType$0.ctx), $state),
      second: $baseEnv,
    })
    : ((($maybeAnnotation)[0] === "$Just")
      ? ((() => {
        const $annotation = ($maybeAnnotation)[1];
        const $annotatedTyvarsByName = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $baseEnv.annotatedTyvarsByName, $annotation.tyvars, ({
          ctx: ([
            $state,
          ]),
          usr: u0$Compiler$TypeCheck$inferPatternAny$2,
        }));
        const $annotatedUnivarsByOriginalId = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $baseEnv.annotatedUnivarsByOriginalId, $annotation.univars, ({
          ctx: ([
            $state,
          ]),
          usr: u0$Compiler$TypeCheck$inferPatternAny$3,
        }));
        const $newEnv = ((() => {
          const $0 = $baseEnv;
          return (Object.assign)({}, $0, ({
            annotatedTyvarsByName: $annotatedTyvarsByName,
            annotatedUnivarsByOriginalId: $annotatedUnivarsByOriginalId,
          }));
        }))();
        return ({
          first: (u0$Compiler$TypeCheck$translateAnnotationType$0.usr)(...(u0$Compiler$TypeCheck$translateAnnotationType$0.ctx), $newEnv, $state, $annotation.raw),
          second: $newEnv,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2393:8', (sp_toHuman)($maybeAnnotation))));
  const $envWithAnnotations = $7.second;
  const $raw = $7.first;
  const $type = ({
    raw: $raw,
    uni: $uni,
  });
  const $envWithVariable = ((($maybeName)[0] === "$Nothing")
    ? $envWithAnnotations
    : ((($maybeName)[0] === "$Just")
      ? ((() => {
        const $name = ($maybeName)[1];
        const $variable = ({
          definedAt: $pos,
          freeTyvars: c0$Dict$empty$0,
          freeUnivars: c0$Dict$empty$0,
          lambdaSetConstraints: c0$Dict$empty$0,
          type: $type,
        });
        const $0 = $envWithAnnotations;
        return (Object.assign)({}, $0, ({
          variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name), $variable, $0.variables),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2423:8', (sp_toHuman)($maybeName))));
  const $typedPattern = (c0$Compiler$TypedAst$PatternAny$0.usr)(...(c0$Compiler$TypedAst$PatternAny$0.ctx), $pos, ({
    maybeName: $maybeName,
    type: $type,
  }));
  return ({
    env: $envWithVariable,
    maybeFullAnnotation: $maybeAnnotation,
    patternType: $raw,
    typedPattern: $typedPattern,
  });
});

const u0$Compiler$TypeCheck$inferPatternAny$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferPatternAny$1,
});

const u0$Compiler$TypeCheck$inferPattern$8 = (($env, $pos, $state, $index, $parType, $argType) => {
  return ((($parType)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($parType)[1];
      return (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), "cons can't recycle?!");
    }))()
    : ((($parType)[0] === "$ParSp")
      ? ((() => {
        const $full = ($parType)[1];
        return (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$Why_Argument$0.usr)(...(u0$Compiler$TypeCheck$Why_Argument$0.ctx), $index), $full.raw, $argType, $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2345:28', (sp_toHuman)($parType))));
});

const u0$Compiler$TypeCheck$inferPattern$7 = (($out) => {
  return $out.patternType;
});

const u0$Compiler$TypeCheck$inferPattern$6 = (($out) => {
  return $out.typedPattern;
});

const u0$Compiler$TypeCheck$inferPattern$5 = (($state, $uni, $arg, $1) => {
  const $argOuts = $1.first;
  const $envX = $1.second;
  const $out = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $envX, $uni, $arg, $state);
  return ({
    first: (sp_cons)($out, $argOuts),
    second: $out.env,
  });
});

const u0$Compiler$TypeCheck$inferPattern$4 = (($k, $o) => {
  return ({
    first: $o.typedPattern,
    second: $o.patternType,
  });
});

const u0$Compiler$TypeCheck$inferPattern$3 = (($name, $out) => {
  return $out.patternType;
});

const u0$Compiler$TypeCheck$inferPattern$2 = (($state, $uni, $name, $pa, $1) => {
  const $dict = $1.first;
  const $envX = $1.second;
  const $out = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $envX, $uni, $pa, $state);
  return ({
    first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $out, $dict),
    second: $out.env,
  });
});

const u0$Compiler$TypeCheck$inferPattern$1 = (($env, $uni, $pattern, $state) => {
  return ((($pattern)[0] === "$PatternAny")
    ? ((() => {
      const $pos = ($pattern)[1];
      const $maybeName = ($pattern)[2];
      const $maybeAnn = ($pattern)[3];
      return (u0$Compiler$TypeCheck$inferPatternAny$0.usr)(...(u0$Compiler$TypeCheck$inferPatternAny$0.ctx), $env, $pos, $uni, $maybeName, $maybeAnn, $state);
    }))()
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $pos = ($pattern)[1];
        const $text = ($pattern)[2];
        return ({
          env: $env,
          maybeFullAnnotation: c0$Maybe$Nothing$0,
          patternType: u0$Compiler$TypeCheck$coreTypeText$0,
          typedPattern: (c0$Compiler$TypedAst$PatternLiteralText$0.usr)(...(c0$Compiler$TypedAst$PatternLiteralText$0.ctx), $pos, $text),
        });
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $pos = ($pattern)[1];
          const $n = ($pattern)[2];
          return ({
            env: $env,
            maybeFullAnnotation: c0$Maybe$Nothing$0,
            patternType: u0$Compiler$TypeCheck$coreTypeNumber$0,
            typedPattern: (c0$Compiler$TypedAst$PatternLiteralNumber$0.usr)(...(c0$Compiler$TypedAst$PatternLiteralNumber$0.ctx), $pos, $n),
          });
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $pos = ($pattern)[1];
            const $usr = ($pattern)[2];
            const $arguments = ($pattern)[3];
            const $5 = (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), ({
              first: c0$Core$Nil$0,
              second: $env,
            }), $arguments, ({
              ctx: ([
                $state,
                $uni,
              ]),
              usr: u0$Compiler$TypeCheck$inferPattern$5,
            }));
            const $newEnv = $5.second;
            const $argumentOuts = $5.first;
            const $typedArguments = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
              ctx: [],
              usr: u0$Compiler$TypeCheck$inferPattern$6,
            }), $argumentOuts);
            const $argumentTypes = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
              ctx: [],
              usr: u0$Compiler$TypeCheck$inferPattern$7,
            }), $argumentOuts);
            const $finalType = ((() => {
              const $6 = (u0$Compiler$TypeCheck$getConstructorByUsr$0.usr)(...(u0$Compiler$TypeCheck$getConstructorByUsr$0.ctx), $usr, $env);
              return ((($6)[0] === "$Nothing")
                ? ((() => {
                  (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.ctx), $usr), $state);
                  return c0$Compiler$TypedAst$TypeError$0;
                }))()
                : ((($6)[0] === "$Just")
                  ? ((() => {
                    const $cons = ($6)[1];
                    const $x = (u0$Compiler$TypeCheck$generalize$0.usr)(...(u0$Compiler$TypeCheck$generalize$0.ctx), $env, $pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $usr), $cons, $state);
                    const $7 = ((() => {
                      const $8 = $x.raw;
                      return ((($8)[0] === "$TypeFn")
                        ? ((() => {
                          const $ins = ($8)[3];
                          const $out = ($8)[4];
                          return ({
                            first: $ins,
                            second: $out.raw,
                          });
                        }))()
                        : (true
                          ? ({
                            first: c0$Core$Nil$0,
                            second: $x.raw,
                          })
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2338:28', (sp_toHuman)($8))));
                    }))();
                    const $returnType = $7.second;
                    const $parTypes = $7.first;
                    (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), (sp_not_equal)((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $parTypes), (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $arguments)), $env, $pos, u0$Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments$0, $state);
                    (c0$List$indexedEach2$0.usr)(...(c0$List$indexedEach2$0.ctx), $parTypes, $argumentTypes, ({
                      ctx: ([
                        $env,
                        $pos,
                        $state,
                      ]),
                      usr: u0$Compiler$TypeCheck$inferPattern$8,
                    }));
                    return $returnType;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2326:16', (sp_toHuman)($6))));
            }))();
            return ({
              env: $newEnv,
              maybeFullAnnotation: c0$Maybe$Nothing$0,
              patternType: $finalType,
              typedPattern: (c0$Compiler$TypedAst$PatternConstructor$0.usr)(...(c0$Compiler$TypedAst$PatternConstructor$0.ctx), $pos, $usr, $typedArguments),
            });
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $pos = ($pattern)[1];
              const $completeness = ($pattern)[2];
              const $pas = ($pattern)[3];
              const $5 = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ({
                first: c0$Dict$empty$0,
                second: $env,
              }), $pas, ({
                ctx: ([
                  $state,
                  $uni,
                ]),
                usr: u0$Compiler$TypeCheck$inferPattern$2,
              }));
              const $newEnv = $5.second;
              const $outs = $5.first;
              const $patternExt = ((($completeness)[0] === "$Complete")
                ? c0$Maybe$Nothing$0
                : ((($completeness)[0] === "$Partial")
                  ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state))
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2374:16', (sp_toHuman)($completeness))));
              const $raw = (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $pos, $patternExt, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                ctx: [],
                usr: u0$Compiler$TypeCheck$inferPattern$3,
              }), $outs));
              return ({
                env: $newEnv,
                maybeFullAnnotation: c0$Maybe$Nothing$0,
                patternType: $raw,
                typedPattern: (c0$Compiler$TypedAst$PatternRecord$0.usr)(...(c0$Compiler$TypedAst$PatternRecord$0.ctx), $pos, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                  ctx: [],
                  usr: u0$Compiler$TypeCheck$inferPattern$4,
                }), $outs)),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2289:4', (sp_toHuman)($pattern)))))));
});

const u0$Compiler$TypeCheck$inferPattern$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferPattern$1,
});

const u0$Compiler$TypeCheck$fullTypeError$0 = ({
  raw: c0$Compiler$TypedAst$TypeError$0,
  uni: c0$Compiler$Ast$Uni$0,
});

const u0$Compiler$TypeCheck$patternError$1 = (($pos) => {
  return (c0$Compiler$TypedAst$PatternAny$0.usr)(...(c0$Compiler$TypedAst$PatternAny$0.ctx), $pos, ({
    maybeName: c0$Maybe$Nothing$0,
    type: u0$Compiler$TypeCheck$fullTypeError$0,
  }));
});

const u0$Compiler$TypeCheck$patternError$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$patternError$1,
});

const u0$Compiler$TypeCheck$checkPatternConstructor$4 = (($state, $2, $1) => {
  const $arg = $2.first;
  const $parType = $2.second;
  const $envX = $1.first;
  const $args = $1.second;
  const $3 = ((($parType)[0] === "$ParSp")
    ? ((() => {
      const $full = ($parType)[1];
      return (u0$Compiler$TypeCheck$checkPattern$0.usr)(...(u0$Compiler$TypeCheck$checkPattern$0.ctx), $envX, $full, $arg, $state);
    }))()
    : ((($parType)[0] === "$ParRe")
      ? ((() => {
        const $raw = ($parType)[1];
        return (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), "should not happen???");
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2588:28', (sp_toHuman)($parType))));
  const $envX1 = $3.second;
  const $taArg = $3.first;
  return ({
    first: $envX1,
    second: (sp_cons)($taArg, $args),
  });
});

const u0$Compiler$TypeCheck$checkPatternConstructor$3 = (($expectedType, $state, $arg, $envX) => {
  const $out = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $envX, $expectedType.uni, $arg, $state);
  return $out.env;
});

const u0$Compiler$TypeCheck$checkPatternConstructor$2 = (($arguments, $expectedType, $state, $0) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $0, $arguments, ({
    ctx: ([
      $expectedType,
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$checkPatternConstructor$3,
  }));
});

const u0$Compiler$TypeCheck$checkPatternConstructor$1 = (($env, $pos, $expectedType, $usr, $arguments, $state) => {
  const $insertArgsOnError = ({
    ctx: ([
      $arguments,
      $expectedType,
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$checkPatternConstructor$2,
  });
  const $7 = (u0$Compiler$TypeCheck$getConstructorByUsr$0.usr)(...(u0$Compiler$TypeCheck$getConstructorByUsr$0.ctx), $usr, $env);
  return ((($7)[0] === "$Nothing")
    ? ((() => {
      (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.ctx), $usr), $state);
      return ({
        first: (u0$Compiler$TypeCheck$patternError$0.usr)(...(u0$Compiler$TypeCheck$patternError$0.ctx), $pos),
        second: ($insertArgsOnError.usr)(...($insertArgsOnError.ctx), $env),
      });
    }))()
    : ((($7)[0] === "$Just")
      ? ((() => {
        const $instance = ($7)[1];
        const $fullType_ = (u0$Compiler$TypeCheck$generalize$0.usr)(...(u0$Compiler$TypeCheck$generalize$0.ctx), $env, $pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $usr), ((() => {
          const $0 = $instance;
          return (Object.assign)({}, $0, ({
            freeUnivars: c0$Dict$empty$0,
          }));
        }))(), $state);
        const $fullType = ((() => {
          const $0 = $fullType_;
          return (Object.assign)({}, $0, ({
            raw: (u0$Compiler$TypeCheck$replaceUnivarRec$0.usr)(...(u0$Compiler$TypeCheck$replaceUnivarRec$0.ctx), 1, $expectedType.uni, $0.raw),
          }));
        }))();
        const $8 = ((() => {
          const $9 = $fullType.raw;
          return ((($9)[0] === "$TypeFn")
            ? ((() => {
              const $ax = ($9)[3];
              const $o = ($9)[4];
              return ({
                first: $ax,
                second: $o,
              });
            }))()
            : (true
              ? ({
                first: c0$Core$Nil$0,
                second: $fullType,
              })
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2576:16', (sp_toHuman)($9))));
        }))();
        const $requiredOut = $8.second;
        const $requiredParTypes = $8.first;
        return ((sp_not_equal)((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $arguments), (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $requiredParTypes))
          ? ((() => {
            (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, u0$Compiler$TypeCheck$ErrorWrongNumberOfConstructorArguments$0, $state);
            return ({
              first: (u0$Compiler$TypeCheck$patternError$0.usr)(...(u0$Compiler$TypeCheck$patternError$0.ctx), $pos),
              second: ($insertArgsOnError.usr)(...($insertArgsOnError.ctx), $env),
            });
          }))()
          : ((() => {
            const $checkArg = ({
              ctx: ([
                $state,
              ]),
              usr: u0$Compiler$TypeCheck$checkPatternConstructor$4,
            });
            const $9 = (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), ({
              first: $env,
              second: c0$Core$Nil$0,
            }), (c0$List$map2$0.usr)(...(c0$List$map2$0.ctx), c0$Tuple$pair$0, $arguments, $requiredParTypes), $checkArg);
            const $typedArgs = $9.second;
            const $newEnv = $9.first;
            (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_CalledAsFunction$0, $requiredOut.raw, $expectedType.raw, $state);
            return ({
              first: (c0$Compiler$TypedAst$PatternConstructor$0.usr)(...(c0$Compiler$TypedAst$PatternConstructor$0.ctx), $pos, $usr, $typedArgs),
              second: $newEnv,
            });
          }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2559:4', (sp_toHuman)($7))));
});

const u0$Compiler$TypeCheck$checkPatternConstructor$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$checkPatternConstructor$1,
});

const u0$Compiler$TypeCheck$checkPatternRecord$3 = (($env, $state, $uni, $name, $2, $1) => {
  const $pa = $2.first;
  const $raw = $2.second;
  const $acc = $1.first;
  const $envX = $1.second;
  const $4 = (u0$Compiler$TypeCheck$checkPattern$0.usr)(...(u0$Compiler$TypeCheck$checkPattern$0.ctx), ((() => {
    const $0 = $envX;
    return (Object.assign)({}, $0, ({
      context: (u0$Compiler$TypeCheck$Context_AttributeName$0.usr)(...(u0$Compiler$TypeCheck$Context_AttributeName$0.ctx), $name, $env.context),
    }));
  }))(), ({
    raw: $raw,
    uni: $uni,
  }), $pa, $state);
  const $envX0 = $4.second;
  const $taPa = $4.first;
  return ({
    first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, ({
      first: $taPa,
      second: $raw,
    }), $acc),
    second: ((() => {
      const $0 = $envX0;
      return (Object.assign)({}, $0, ({
        context: $env.context,
      }));
    }))(),
  });
});

const u0$Compiler$TypeCheck$checkPatternRecord$2 = (($expectedType, $state, $name, $pa, $envX) => {
  const $out = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $envX, $expectedType.uni, $pa, $state);
  return $out.env;
});

const u0$Compiler$TypeCheck$checkPatternRecord$1 = (($env, $pos, $expectedType, $completeness, $pas, $state) => {
  const $7 = $expectedType;
  const $uni = $7.uni;
  const $8 = $expectedType.raw;
  return (((($8)[0] === "$TypeRecord") && ((($8)[2])[0] === "$Nothing"))
    ? ((() => {
      const $attrs = ($8)[3];
      const $9 = (c0$Dict$onlyBothOnly$0.usr)(...(c0$Dict$onlyBothOnly$0.ctx), $pas, $attrs);
      const $typeOnly = $9.third;
      const $both = $9.second;
      const $paOnly = $9.first;
      (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), (sp_not_equal)($paOnly, c0$Dict$empty$0), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0.ctx), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $paOnly)), $state);
      (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), ((sp_not_equal)($typeOnly, c0$Dict$empty$0) && (sp_equal)($completeness, c0$Compiler$CanonicalAst$Complete$0)), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation$0.ctx), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $typeOnly)), $state);
      const $10 = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ({
        first: c0$Dict$empty$0,
        second: $env,
      }), $both, ({
        ctx: ([
          $env,
          $state,
          $uni,
        ]),
        usr: u0$Compiler$TypeCheck$checkPatternRecord$3,
      }));
      const $envF = $10.second;
      const $taPas = $10.first;
      return ({
        first: (c0$Compiler$TypedAst$PatternRecord$0.usr)(...(c0$Compiler$TypedAst$PatternRecord$0.ctx), $pos, $taPas),
        second: $envF,
      });
    }))()
    : (((($8)[0] === "$TypeRecord") && ((($8)[2])[0] === "$Just"))
      ? ((() => {
        const $tyvarId = (($8)[2])[1];
        const $a = ($8)[3];
        return (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), "can't annotate extensible types");
      }))()
      : (true
        ? ((() => {
          (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, u0$Compiler$TypeCheck$ErrorNotCompatibleWithRecord$0, $state);
          const $envF = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $env, $pas, ({
            ctx: ([
              $expectedType,
              $state,
            ]),
            usr: u0$Compiler$TypeCheck$checkPatternRecord$2,
          }));
          return ({
            first: (u0$Compiler$TypeCheck$patternError$0.usr)(...(u0$Compiler$TypeCheck$patternError$0.ctx), $pos),
            second: $envF,
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2506:4', (sp_toHuman)($8)))));
});

const u0$Compiler$TypeCheck$checkPatternRecord$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$checkPatternRecord$1,
});

const u0$Compiler$TypeCheck$checkPattern$1 = (($env, $expectedType, $pattern, $state) => {
  const $5 = ({
    first: $pattern,
    second: $expectedType.raw,
  });
  return ((($5.first)[0] === "$PatternAny")
    ? ((() => {
      const $pos = ($5.first)[1];
      const $maybeName = ($5.first)[2];
      const $maybeAnnotation = ($5.first)[3];
      const $newEnv = ((($maybeName)[0] === "$Nothing")
        ? $env
        : ((($maybeName)[0] === "$Just")
          ? ((() => {
            const $name = ($maybeName)[1];
            const $variable = ({
              definedAt: $pos,
              freeTyvars: c0$Dict$empty$0,
              freeUnivars: c0$Dict$empty$0,
              lambdaSetConstraints: c0$Dict$empty$0,
              type: $expectedType,
            });
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name), $variable, $0.variables),
            }));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2462:16', (sp_toHuman)($maybeName))));
      return ({
        first: (c0$Compiler$TypedAst$PatternAny$0.usr)(...(c0$Compiler$TypedAst$PatternAny$0.ctx), $pos, ({
          maybeName: $maybeName,
          type: $expectedType,
        })),
        second: $newEnv,
      });
    }))()
    : (((($5.first)[0] === "$PatternLiteralText") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[3])[0] === "$Nil")))
      ? ((() => {
        const $pos = ($5.first)[1];
        const $text = ($5.first)[2];
        const $typeUsr = ($5.second)[2];
        (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), (sp_not_equal)($typeUsr, u0$Compiler$CoreDefs$textDef$0.usr), $env, $pos, (u0$Compiler$TypeCheck$ErrorIncompatiblePattern$0.usr)(...(u0$Compiler$TypeCheck$ErrorIncompatiblePattern$0.ctx), $pattern, $expectedType), $state);
        return ({
          first: (c0$Compiler$TypedAst$PatternLiteralText$0.usr)(...(c0$Compiler$TypedAst$PatternLiteralText$0.ctx), $pos, $text),
          second: $env,
        });
      }))()
      : (((($5.first)[0] === "$PatternLiteralNumber") && ((($5.second)[0] === "$TypeExact") && ((($5.second)[3])[0] === "$Nil")))
        ? ((() => {
          const $pos = ($5.first)[1];
          const $text = ($5.first)[2];
          const $typeUsr = ($5.second)[2];
          (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), (sp_not_equal)($typeUsr, u0$Compiler$CoreDefs$numberDef$0.usr), $env, $pos, (u0$Compiler$TypeCheck$ErrorIncompatiblePattern$0.usr)(...(u0$Compiler$TypeCheck$ErrorIncompatiblePattern$0.ctx), $pattern, $expectedType), $state);
          return ({
            first: (c0$Compiler$TypedAst$PatternLiteralNumber$0.usr)(...(c0$Compiler$TypedAst$PatternLiteralNumber$0.ctx), $pos, $text),
            second: $env,
          });
        }))()
        : ((($5.first)[0] === "$PatternConstructor")
          ? ((() => {
            const $pos = ($5.first)[1];
            const $usr = ($5.first)[2];
            const $arguments = ($5.first)[3];
            return (u0$Compiler$TypeCheck$checkPatternConstructor$0.usr)(...(u0$Compiler$TypeCheck$checkPatternConstructor$0.ctx), $env, $pos, $expectedType, $usr, $arguments, $state);
          }))()
          : ((($5.first)[0] === "$PatternRecord")
            ? ((() => {
              const $pos = ($5.first)[1];
              const $completeness = ($5.first)[2];
              const $pas = ($5.first)[3];
              return (u0$Compiler$TypeCheck$checkPatternRecord$0.usr)(...(u0$Compiler$TypeCheck$checkPatternRecord$0.ctx), $env, $pos, $expectedType, $completeness, $pas, $state);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2458:4', (sp_toHuman)($5)))))));
});

const u0$Compiler$TypeCheck$checkPattern$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$checkPattern$1,
});

const u0$Compiler$TypeCheck$checkParameter$1 = (($env, $expectedParType, $par, $state) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $originalUni = ($par)[1];
      const $pa = ($par)[2];
      const $5 = ((($expectedParType)[0] === "$ParRe")
        ? ((() => {
          (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, (c0$Compiler$CanonicalAst$patternPos$0.usr)(...(c0$Compiler$CanonicalAst$patternPos$0.ctx), $pa), u0$Compiler$TypeCheck$ErrorRecyclingDoesNotMatch$0, $state);
          const $o = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $env, c0$Compiler$Ast$Uni$0, $pa, $state);
          return ({
            first: ({
              raw: $o.patternType,
              uni: c0$Compiler$Ast$Uni$0,
            }),
            second: ({
              first: $o.typedPattern,
              second: $o.env,
            }),
          });
        }))()
        : ((($expectedParType)[0] === "$ParSp")
          ? ((() => {
            const $full = ($expectedParType)[1];
            const $uni = (u0$Compiler$TypeCheck$translateUni$0.usr)(...(u0$Compiler$TypeCheck$translateUni$0.ctx), $env.annotatedUnivarsByOriginalId, $originalUni);
            (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), (sp_not_equal)($uni, $full.uni), $env, (c0$Compiler$CanonicalAst$patternPos$0.usr)(...(c0$Compiler$CanonicalAst$patternPos$0.ctx), $pa), (u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter$0.usr)(...(u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchParameter$0.ctx), $uni, $full), $state);
            return ({
              first: $full,
              second: (u0$Compiler$TypeCheck$checkPattern$0.usr)(...(u0$Compiler$TypeCheck$checkPattern$0.ctx), $env, $full, $pa, $state),
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1741:16', (sp_toHuman)($expectedParType))));
      const $env1 = $5.second.second;
      const $typedPa = $5.second.first;
      const $fullType = $5.first;
      return ({
        first: (c0$Compiler$TypedAst$ParameterPattern$0.usr)(...(c0$Compiler$TypedAst$ParameterPattern$0.ctx), $fullType, $typedPa),
        second: $env1,
      });
    }))()
    : ((($par)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $num = ($par)[1];
        return ((($expectedParType)[0] === "$ParRe")
          ? (sp_todo)("TA.ParRe")
          : ((($expectedParType)[0] === "$ParSp")
            ? ((() => {
              const $type = ($expectedParType)[1];
              const $variable = ({
                definedAt: c0$Compiler$Pos$G$0,
                freeTyvars: c0$Dict$empty$0,
                freeUnivars: c0$Dict$empty$0,
                lambdaSetConstraints: c0$Dict$empty$0,
                type: $type,
              });
              return ({
                first: (c0$Compiler$TypedAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$TypedAst$ParameterPlaceholder$0.ctx), $type, $num),
                second: ((() => {
                  const $0 = $env;
                  return (Object.assign)({}, $0, ({
                    variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), $num), $variable, $0.variables),
                  }));
                }))(),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1762:12', (sp_toHuman)($expectedParType))));
      }))()
      : ((($par)[0] === "$ParameterRecycle")
        ? ((() => {
          const $pos = ($par)[1];
          const $name = ($par)[2];
          const $expectedRaw = ((($expectedParType)[0] === "$ParSp")
            ? ((() => {
              const $full = ($expectedParType)[1];
              (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, u0$Compiler$TypeCheck$ErrorRecyclingDoesNotMatch$0, $state);
              return c0$Compiler$TypedAst$TypeError$0;
            }))()
            : ((($expectedParType)[0] === "$ParRe")
              ? ((() => {
                const $raw = ($expectedParType)[1];
                return $raw;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1781:16', (sp_toHuman)($expectedParType))));
          const $variable = ({
            definedAt: $pos,
            freeTyvars: c0$Dict$empty$0,
            freeUnivars: c0$Dict$empty$0,
            lambdaSetConstraints: c0$Dict$empty$0,
            type: ({
              raw: $expectedRaw,
              uni: c0$Compiler$Ast$Uni$0,
            }),
          });
          const $localEnv = ((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name), $variable, $0.variables),
            }));
          }))();
          return ({
            first: (c0$Compiler$TypedAst$ParameterRecycle$0.usr)(...(c0$Compiler$TypedAst$ParameterRecycle$0.ctx), $pos, $expectedRaw, $name),
            second: $localEnv,
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1737:4', (sp_toHuman)($par)))));
});

const u0$Compiler$TypeCheck$checkParameter$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$checkParameter$1,
});

const u0$Compiler$TypeCheck$addConstraint$1 = (($env, $pos, $id, $uni, $state) => {
  const $eq = ({
    context: u0$Compiler$TypeCheck$Context_Global$0,
    id: $id,
    pos: $pos,
    uni: $uni,
    why: "-",
  });
  return (u0$Compiler$TypeCheck$solveUniquenessConstraint$0.usr)(...(u0$Compiler$TypeCheck$solveUniquenessConstraint$0.ctx), $env, $eq, $state);
});

const u0$Compiler$TypeCheck$addConstraint$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$addConstraint$1,
});

const u0$Compiler$TypeCheck$checkUni$1 = (($env, $pos, $2, $state) => {
  const $given = $2.given;
  const $required = $2.required;
  const $5 = (u0$Compiler$TypeCheck$uniCanBeCastTo$0.usr)(...(u0$Compiler$TypeCheck$uniCanBeCastTo$0.ctx), ({
    given: $given,
    required: $required,
  }));
  return ((($5)[0] === "$CanBeCastYes")
    ? null
    : (((($5)[0] === "$CanBeCastNo") && ((($5)[1])[0] === "$Nil"))
      ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatch$0.usr)(...(u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatch$0.ctx), ({
        given: $given,
        required: $required,
      })), $state)
      : (((($5)[0] === "$CanBeCastNo") && ((($5)[1])[0] === "$Cons"))
        ? ((() => {
          const $univarId = (($5)[1])[1].first;
          const $uni = (($5)[1])[1].second;
          const $tail = (($5)[1])[2];
          return (u0$Compiler$TypeCheck$addConstraint$0.usr)(...(u0$Compiler$TypeCheck$addConstraint$0.ctx), $env, $pos, $univarId, $uni, $state);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 711:4', (sp_toHuman)($5)))));
});

const u0$Compiler$TypeCheck$checkUni$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$checkUni$1,
});

const u0$Compiler$TypeCheck$coreTypeBool$0 = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$N$0, u0$Compiler$CoreDefs$boolUsr$0, c0$Core$Nil$0);

const u0$Compiler$TypeCheck$getVariableByRef$1 = (($ref, $env) => {
  return (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $ref, $env.variables);
});

const u0$Compiler$TypeCheck$getVariableByRef$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getVariableByRef$1,
});

const u0$Compiler$TypeCheck$getTypeDef$1 = (($env, $pos, $usr, $state) => {
  const $5 = $usr;
  const $name = ($5)[2];
  const $umr = ($5)[1];
  const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $env.modulesByUmr);
  return ((($6)[0] === "$Nothing")
    ? ((() => {
      (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorModuleNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorModuleNotFound$0.ctx), $umr), $state);
      return c0$Maybe$Nothing$0;
    }))()
    : ((($6)[0] === "$Just")
      ? ((() => {
        const $module = ($6)[1];
        const $7 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $module.aliasDefs);
        return ((($7)[0] === "$Just")
          ? ((() => {
            const $def = ($7)[1];
            return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
              first: $def.pars,
              second: (c0$Self$OpenAliasType$0.usr)(...(c0$Self$OpenAliasType$0.ctx), $def),
            }));
          }))()
          : ((($7)[0] === "$Nothing")
            ? ((() => {
              const $8 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $module.variantTypeDefs);
              return ((($8)[0] === "$Nothing")
                ? ((() => {
                  (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorTypeNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorTypeNotFound$0.ctx), $usr), $state);
                  return c0$Maybe$Nothing$0;
                }))()
                : ((($8)[0] === "$Just")
                  ? ((() => {
                    const $def = ($8)[1];
                    return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
                      first: $def.pars,
                      second: (c0$Self$OpenVarType$0.usr)(...(c0$Self$OpenVarType$0.ctx), $def),
                    }));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1160:20', (sp_toHuman)($8))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1154:12', (sp_toHuman)($7))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1146:4', (sp_toHuman)($6))));
});

const u0$Compiler$TypeCheck$getTypeDef$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getTypeDef$1,
});

const u0$Compiler$TypeCheck$getValueDef$1 = (($env, $pos, $usr, $state) => {
  const $5 = $usr;
  const $name = ($5)[2];
  const $umr = ($5)[1];
  const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $env.modulesByUmr);
  return ((($6)[0] === "$Nothing")
    ? ((() => {
      (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorModuleNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorModuleNotFound$0.ctx), $umr), $state);
      return c0$Maybe$Nothing$0;
    }))()
    : ((($6)[0] === "$Just")
      ? ((() => {
        const $module = ($6)[1];
        const $7 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $module.valueDefs);
        return ((($7)[0] === "$Just")
          ? ((() => {
            const $def = ($7)[1];
            return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $def);
          }))()
          : ((($7)[0] === "$Nothing")
            ? ((() => {
              (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorVariableNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorVariableNotFound$0.ctx), (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $usr)), $state);
              return c0$Maybe$Nothing$0;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1184:12', (sp_toHuman)($7))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1176:4', (sp_toHuman)($6))));
});

const u0$Compiler$TypeCheck$getValueDef$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getValueDef$1,
});

const u0$Compiler$TypeCheck$doIntrospect$1 = (($env, $pos, $introspect, $usr, $state) => {
  const $selfUsr = (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Self"), "Self");
  const $selfType = ((() => {
    const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $selfUsr, $env.expandedAliases);
    return ((($6)[0] === "$Nothing")
      ? (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), "no self?")
      : ((($6)[0] === "$Just")
        ? ((() => {
          const $expandedAlias = ($6)[1];
          return $expandedAlias.type;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1203:8', (sp_toHuman)($6))));
  }))();
  const $expression = ((($introspect)[0] === "$Value")
    ? ((() => {
      const $6 = (u0$Compiler$TypeCheck$getValueDef$0.usr)(...(u0$Compiler$TypeCheck$getValueDef$0.ctx), $env, $pos, $usr, $state);
      return ((($6)[0] === "$Nothing")
        ? (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos)
        : ((($6)[0] === "$Just")
          ? ((() => {
            const $def = ($6)[1];
            return ((sp_equal)($def.maybeAnnotation, c0$Maybe$Nothing$0)
              ? (sp_todo)("cannot introspect non-annotated values")
              : (c0$Compiler$TypedAst$Introspect$0.usr)(...(c0$Compiler$TypedAst$Introspect$0.ctx), ({
                def: (c0$Self$Value$0.usr)(...(c0$Self$Value$0.ctx), ((() => {
                  const $0 = $def;
                  return (Object.assign)({}, $0, ({
                    maybeBody: c0$Maybe$Nothing$0,
                  }));
                }))()),
                usr: $usr,
              })));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1211:16', (sp_toHuman)($6))));
    }))()
    : ((($introspect)[0] === "$Type")
      ? ((() => {
        const $6 = (u0$Compiler$TypeCheck$getTypeDef$0.usr)(...(u0$Compiler$TypeCheck$getTypeDef$0.ctx), $env, $pos, $usr, $state);
        return ((($6)[0] === "$Nothing")
          ? (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos)
          : ((($6)[0] === "$Just")
            ? ((() => {
              const $pars = ($6)[1].first;
              return (c0$Compiler$TypedAst$Introspect$0.usr)(...(c0$Compiler$TypedAst$Introspect$0.ctx), ({
                def: (c0$Self$OpaqueType$0.usr)(...(c0$Self$OpaqueType$0.ctx), ({
                  constructors: c0$Dict$empty$0,
                  pars: $pars,
                  usr: $usr,
                })),
                usr: $usr,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1223:16', (sp_toHuman)($6))));
      }))()
      : ((($introspect)[0] === "$TypeOpen")
        ? ((() => {
          const $6 = (u0$Compiler$TypeCheck$getTypeDef$0.usr)(...(u0$Compiler$TypeCheck$getTypeDef$0.ctx), $env, $pos, $usr, $state);
          return ((($6)[0] === "$Nothing")
            ? (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos)
            : ((($6)[0] === "$Just")
              ? ((() => {
                const $def = ($6)[1].second;
                return (c0$Compiler$TypedAst$Introspect$0.usr)(...(c0$Compiler$TypedAst$Introspect$0.ctx), ({
                  def: $def,
                  usr: $usr,
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1244:16', (sp_toHuman)($6))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1208:8', (sp_toHuman)($introspect)))));
  return ({
    first: $expression,
    second: ({
      raw: $selfType,
      uni: c0$Compiler$Ast$Uni$0,
    }),
  });
});

const u0$Compiler$TypeCheck$doIntrospect$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doIntrospect$1,
});

const u0$Compiler$TypeCheck$doLetIn$1 = (($env, $state, $maybeExpected, $def, $rest) => {
  const $out = (u0$Compiler$TypeCheck$doDefinition$0.usr)(...(u0$Compiler$TypeCheck$doDefinition$0.ctx), $state, ({
    directDeps: c0$Dict$empty$0,
    env: $env,
    maybeBody: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $def.body),
    nameToRef: c0$Compiler$Ast$RefLocal$0,
    pattern: $def.pattern,
    uni: $def.uni,
  }));
  const $6 = ((($maybeExpected)[0] === "$Nothing")
    ? (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $out.env, $rest, $state)
    : ((($maybeExpected)[0] === "$Just")
      ? ((() => {
        const $pars = ($maybeExpected)[1];
        return (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $out.env, $pars, $rest, $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1472:12', (sp_toHuman)($maybeExpected))));
  const $restType = $6.second;
  const $typedRest = $6.first;
  const $localDef = ({
    body: ((() => {
      const $7 = $out.body;
      return ((($7)[0] === "$Just")
        ? ((() => {
          const $b = ($7)[1];
          return $b;
        }))()
        : ((($7)[0] === "$Nothing")
          ? (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), "local def is missing body")
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1479:16', (sp_toHuman)($7))));
    }))(),
    pattern: $out.pattern,
    type: $out.type,
  });
  return ({
    first: (c0$Compiler$TypedAst$LetIn$0.usr)(...(c0$Compiler$TypedAst$LetIn$0.ctx), $localDef, $typedRest, $restType),
    second: $restType,
  });
});

const u0$Compiler$TypeCheck$doLetIn$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doLetIn$1,
});

const u0$Compiler$TypeCheck$inferUni$1 = (($a, $b) => {
  const $3 = ({
    first: $a,
    second: $b,
  });
  return ((($3.first)[0] === "$Imm")
    ? c0$Compiler$Ast$Imm$0
    : ((($3.second)[0] === "$Imm")
      ? c0$Compiler$Ast$Imm$0
      : (((($3.first)[0] === "$Depends") && (($3.second)[0] === "$Depends"))
        ? ((() => {
          const $aId = ($3.first)[1];
          const $bId = ($3.second)[1];
          return c0$Compiler$Ast$Imm$0;
        }))()
        : ((($3.second)[0] === "$Depends")
          ? $b
          : (true
            ? c0$Compiler$Ast$Uni$0
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 756:4', (sp_toHuman)($3)))))));
});

const u0$Compiler$TypeCheck$inferUni$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferUni$1,
});

const u0$Compiler$TypeCheck$doTry$2 = (($env, $expectedRaw, $pos, $state, $valueType, $2, $1) => {
  const $u = $2.first;
  const $pa = $2.second;
  const $exp = $2.third;
  const $uniX = $1.first;
  const $acc = $1.second;
  const $patternOut = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $env, $u, $pa, $state);
  (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_TryPattern$0, $patternOut.patternType, $valueType.raw, $state);
  (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $env, $pos, ({
    given: $valueType.uni,
    required: $u,
  }), $state);
  const $newEnv = ((() => {
    const $0 = $patternOut.env;
    return (Object.assign)({}, $0, ({
      context: u0$Compiler$TypeCheck$Context_TryBranch$0,
    }));
  }))();
  const $3 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $newEnv, $exp, $state);
  const $expressionType = $3.second;
  const $typedExpression = $3.first;
  (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $newEnv, (c0$Compiler$CanonicalAst$expressionPos$0.usr)(...(c0$Compiler$CanonicalAst$expressionPos$0.ctx), $exp), u0$Compiler$TypeCheck$Why_TryExpression$0, $expectedRaw, $expressionType.raw, $state);
  const $uf = (u0$Compiler$TypeCheck$inferUni$0.usr)(...(u0$Compiler$TypeCheck$inferUni$0.ctx), $uniX, $expressionType.uni);
  const $l = (sp_cons)(({
    first: $patternOut.typedPattern,
    second: $typedExpression,
  }), $acc);
  return ({
    first: $uf,
    second: $l,
  });
});

const u0$Compiler$TypeCheck$doTry$1 = (($env, $pos, $expectedRaw, $value, $caPatternsAndExpressions, $state) => {
  const $7 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $value, $state);
  const $valueType = $7.second;
  const $typedValue = $7.first;
  const $8 = (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), ({
    first: c0$Compiler$Ast$Uni$0,
    second: c0$Core$Nil$0,
  }), $caPatternsAndExpressions, ({
    ctx: ([
      $env,
      $expectedRaw,
      $pos,
      $state,
      $valueType,
    ]),
    usr: u0$Compiler$TypeCheck$doTry$2,
  }));
  const $patternsAndExpressions = $8.second;
  const $uni = $8.first;
  return ({
    first: (c0$Compiler$TypedAst$Try$0.usr)(...(c0$Compiler$TypedAst$Try$0.ctx), $pos, ({
      patternsAndExpressions: $patternsAndExpressions,
      value: $typedValue,
      valueType: $valueType,
    })),
    second: ({
      raw: $expectedRaw,
      uni: $uni,
    }),
  });
});

const u0$Compiler$TypeCheck$doTry$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doTry$1,
});

const u0$Compiler$TypeCheck$getLocalRefs$7 = (($n, _1) => {
  return null;
});

const u0$Compiler$TypeCheck$getLocalRefs$6 = (($rec, $arg, $acc) => {
  return ((($arg)[0] === "$ArgumentRecycle")
    ? ((() => {
      const $raw = ($arg)[2];
      const $name = ($arg)[4];
      return (c0$Set$insert$0.usr)(...(c0$Set$insert$0.ctx), $name, $acc);
    }))()
    : ((($arg)[0] === "$ArgumentExpression")
      ? ((() => {
        const $fullType = ($arg)[1];
        const $exp = ($arg)[2];
        return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $acc, ($rec.usr)(...($rec.ctx), $exp));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1392:16', (sp_toHuman)($arg))));
});

const u0$Compiler$TypeCheck$getLocalRefs$5 = (($rec, _0, $exp, $acc) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $acc, ($rec.usr)(...($rec.ctx), $exp));
});

const u0$Compiler$TypeCheck$getLocalRefs$4 = (($name, _1, $acc) => {
  return (c0$Set$remove$0.usr)(...(c0$Set$remove$0.ctx), $name, $acc);
});

const u0$Compiler$TypeCheck$getLocalRefs$3 = (($name, _1, $accX) => {
  return (c0$Set$remove$0.usr)(...(c0$Set$remove$0.ctx), $name, $accX);
});

const u0$Compiler$TypeCheck$getLocalRefs$2 = (($rec, $2, $acc) => {
  const $pattern = $2.first;
  const $exp = $2.second;
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $acc, (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ($rec.usr)(...($rec.ctx), $exp), (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $pattern), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$getLocalRefs$3,
  })));
});

const u0$Compiler$TypeCheck$getLocalRefs$1 = (($expression) => {
  const $rec = u0$Compiler$TypeCheck$getLocalRefs$0;
  return ((($expression)[0] === "$LiteralNumber")
    ? c0$Dict$empty$0
    : ((($expression)[0] === "$LiteralText")
      ? c0$Dict$empty$0
      : ((($expression)[0] === "$Constructor")
        ? c0$Dict$empty$0
        : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
          ? c0$Dict$empty$0
          : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefPlaceholder"))
            ? c0$Dict$empty$0
            : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefLocal"))
              ? ((() => {
                const $name = (($expression)[2])[1];
                return (c0$Set$ofOne$0.usr)(...(c0$Set$ofOne$0.ctx), $name);
              }))()
              : ((($expression)[0] === "$Lambda")
                ? ((() => {
                  const $pars = ($expression)[2];
                  return (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
                    ctx: [],
                    usr: u0$Compiler$TypeCheck$getLocalRefs$7,
                  }), $pars.context);
                }))()
                : ((($expression)[0] === "$Call")
                  ? ((() => {
                    const $p = ($expression)[1];
                    const $setId = ($expression)[2];
                    const $ref = ($expression)[3];
                    const $args = ($expression)[4];
                    return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ($rec.usr)(...($rec.ctx), $ref), $args, ({
                      ctx: ([
                        $rec,
                      ]),
                      usr: u0$Compiler$TypeCheck$getLocalRefs$6,
                    }));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $p = ($expression)[1];
                      const $maybeExt = ($expression)[2];
                      const $attrs = ($expression)[3];
                      return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ((($maybeExt)[0] === "$Nothing")
                        ? c0$Dict$empty$0
                        : ((($maybeExt)[0] === "$Just")
                          ? ((() => {
                            const $ext = ($maybeExt)[1];
                            return ($rec.usr)(...($rec.ctx), $ext);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1397:12', (sp_toHuman)($maybeExt)))), $attrs, ({
                        ctx: ([
                          $rec,
                        ]),
                        usr: u0$Compiler$TypeCheck$getLocalRefs$5,
                      }));
                    }))()
                    : ((($expression)[0] === "$RecordAccess")
                      ? ((() => {
                        const $p = ($expression)[1];
                        const $name = ($expression)[2];
                        const $exp = ($expression)[3];
                        return ($rec.usr)(...($rec.ctx), $exp);
                      }))()
                      : ((($expression)[0] === "$LetIn")
                        ? ((() => {
                          const $def = ($expression)[1];
                          const $rest = ($expression)[2];
                          const $restType = ($expression)[3];
                          return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), ($rec.usr)(...($rec.ctx), $def.body), ($rec.usr)(...($rec.ctx), $rest)), (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $def.pattern), ({
                            ctx: [],
                            usr: u0$Compiler$TypeCheck$getLocalRefs$4,
                          }));
                        }))()
                        : ((($expression)[0] === "$If")
                          ? ((() => {
                            const $p = ($expression)[1];
                            const $condition = ($expression)[2].condition;
                            const $false = ($expression)[2].false;
                            const $true = ($expression)[2].true;
                            return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), ($rec.usr)(...($rec.ctx), $condition), ($rec.usr)(...($rec.ctx), $true)), ($rec.usr)(...($rec.ctx), $false));
                          }))()
                          : ((($expression)[0] === "$Try")
                            ? ((() => {
                              const $p = ($expression)[1];
                              const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                              const $value = ($expression)[2].value;
                              const $valueType = ($expression)[2].valueType;
                              return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ($rec.usr)(...($rec.ctx), $value), $patternsAndExpressions, ({
                                ctx: ([
                                  $rec,
                                ]),
                                usr: u0$Compiler$TypeCheck$getLocalRefs$2,
                              }));
                            }))()
                            : ((($expression)[0] === "$DestroyIn")
                              ? ((() => {
                                const $n = ($expression)[1];
                                const $e = ($expression)[2];
                                return ($rec.usr)(...($rec.ctx), $e);
                              }))()
                              : ((($expression)[0] === "$Error")
                                ? ((() => {
                                  const $p = ($expression)[1];
                                  return c0$Dict$empty$0;
                                }))()
                                : ((($expression)[0] === "$Introspect")
                                  ? c0$Dict$empty$0
                                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1365:4', (sp_toHuman)($expression))))))))))))))))));
});

const u0$Compiler$TypeCheck$getLocalRefs$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getLocalRefs$1,
});

const u0$Compiler$TypeCheck$getContext$4 = (($name, _1, $accX) => {
  return (c0$Set$remove$0.usr)(...(c0$Set$remove$0.ctx), $name, $accX);
});

const u0$Compiler$TypeCheck$getContext$3 = (($par, $acc) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $pattern = ($par)[2];
      return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $acc, (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $pattern), ({
        ctx: [],
        usr: u0$Compiler$TypeCheck$getContext$4,
      }));
    }))()
    : ((($par)[0] === "$ParameterRecycle")
      ? ((() => {
        const $name = ($par)[3];
        return (c0$Set$remove$0.usr)(...(c0$Set$remove$0.ctx), $name, $acc);
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? $acc
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1443:8', (sp_toHuman)($par)))));
});

const u0$Compiler$TypeCheck$getContext$2 = (($env, $expression, $name, _1) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name), $env.variables);
  return ((($3)[0] === "$Nothing")
    ? (u0$Compiler$TypeCheck$bug$0.usr)(...(u0$Compiler$TypeCheck$bug$0.ctx), ((("bleh " + $name) + "\n\n") + (sp_toHuman)($expression)))
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $instance = ($3)[1];
        return $instance.type;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1437:12', (sp_toHuman)($3))));
});

const u0$Compiler$TypeCheck$getContext$1 = (($env, $pars, $expression) => {
  const $getType = ({
    ctx: ([
      $env,
      $expression,
    ]),
    usr: u0$Compiler$TypeCheck$getContext$2,
  });
  return (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), $getType, (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$Compiler$TypeCheck$getLocalRefs$0.usr)(...(u0$Compiler$TypeCheck$getLocalRefs$0.ctx), $expression), $pars, ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$getContext$3,
  })));
});

const u0$Compiler$TypeCheck$getContext$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getContext$1,
});

const u0$Compiler$TypeCheck$lambdaSetMustInclude$1 = (($state, $setId, $ref) => {
  return (hash_insert)($state.lambdaSetConstraints, $setId, (c0$Set$insert$0.usr)(...(c0$Set$insert$0.ctx), $ref, (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), c0$Set$empty$0, (hash_get)($state.lambdaSetConstraints, $setId))));
});

const u0$Compiler$TypeCheck$lambdaSetMustInclude$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$lambdaSetMustInclude$1,
});

const u0$Compiler$TypeCheck$doLambda$1 = (($pars, $state) => {
  const $lambdaId = (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaRefId);
  const $3 = ($pars.runBodyCheck.usr)(...($pars.runBodyCheck.ctx), $state);
  const $bodyType = $3.second;
  const $typedBody = $3.first;
  const $originalContext = (u0$Compiler$TypeCheck$getContext$0.usr)(...(u0$Compiler$TypeCheck$getContext$0.ctx), $pars.env, $pars.typedPars, $typedBody);
  const $lambdaRef = ({
    first: $pars.env.currentRootUsr,
    second: $lambdaId,
  });
  const $4 = ((() => {
    const $5 = (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), (c0$Dict$intersect$0.usr)(...(c0$Dict$intersect$0.ctx), $pars.env.currentLetInNames, $originalContext));
    return ((($5)[0] === "$Nil")
      ? ({
        first: $originalContext,
        second: $typedBody,
      })
      : (((($5)[0] === "$Cons") && ((($5)[2])[0] === "$Nil"))
        ? ((() => {
          const $name = ($5)[1].first;
          const $pos = ($5)[1].second.pos;
          const $type = ($5)[1].second.type;
          const $context0 = (c0$Dict$remove$0.usr)(...(c0$Dict$remove$0.ctx), $name, $originalContext);
          const $body0 = (c0$Compiler$TypedAst$LetIn$0.usr)(...(c0$Compiler$TypedAst$LetIn$0.ctx), ({
            body: (c0$Compiler$TypedAst$Lambda$0.usr)(...(c0$Compiler$TypedAst$Lambda$0.ctx), $pars.lambdaPos, ({
              context: $context0,
              definition: false,
              ref: $lambdaRef,
            })),
            pattern: (c0$Compiler$TypedAst$PatternAny$0.usr)(...(c0$Compiler$TypedAst$PatternAny$0.ctx), $pos, ({
              maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name),
              type: $type,
            })),
            type: $type,
          }), $typedBody, $bodyType);
          return ({
            first: $context0,
            second: $body0,
          });
        }))()
        : (true
          ? ((() => {
            (u0$Compiler$TypeCheck$addErrorText$0.usr)(...(u0$Compiler$TypeCheck$addErrorText$0.ctx), $pars.env, $pars.lambdaPos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "This kind of messy recursion is not supported.", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Better error messages coming at some point.", c0$Core$Nil$0)));
            return ({
              first: $originalContext,
              second: $typedBody,
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1518:8', (sp_toHuman)($5)))));
  }))();
  const $body = $4.second;
  const $context = $4.first;
  (u0$Compiler$TypeCheck$lambdaSetMustInclude$0.usr)(...(u0$Compiler$TypeCheck$lambdaSetMustInclude$0.ctx), $state, $pars.lambdaSet, $lambdaRef);
  (hash_insert)($state.lambdas, $lambdaId, ({
    body: $body,
    lambdaSetId: $pars.lambdaSet,
    pars: $pars.typedPars,
    returnType: $bodyType,
  }));
  const $raw = (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $pars.typePos, $pars.lambdaSet, $pars.parTypes, $bodyType);
  return ({
    first: (c0$Compiler$TypedAst$Lambda$0.usr)(...(c0$Compiler$TypedAst$Lambda$0.ctx), $pars.lambdaPos, ({
      context: $context,
      definition: true,
      ref: $lambdaRef,
    })),
    second: ({
      raw: $raw,
      uni: c0$Compiler$Ast$Uni$0,
    }),
  });
});

const u0$Compiler$TypeCheck$doLambda$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doLambda$1,
});

const u0$Compiler$TypeCheck$inferParam$2 = (($state, $tyvarId, _1) => {
  return (hash_insert)($state.boundTyvars, $tyvarId, null);
});

const u0$Compiler$TypeCheck$inferParam$1 = (($env, $parIndex, $par, $state) => {
  return ((($par)[0] === "$ParameterRecycle")
    ? ((() => {
      const $pos = ($par)[1];
      const $name = ($par)[2];
      const $tyvarId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
      (hash_insert)($state.boundTyvars, $tyvarId, null);
      const $raw = (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$G$0, $tyvarId);
      const $instance = ({
        definedAt: $pos,
        freeTyvars: c0$Dict$empty$0,
        freeUnivars: c0$Dict$empty$0,
        lambdaSetConstraints: c0$Dict$empty$0,
        type: ({
          raw: $raw,
          uni: c0$Compiler$Ast$Uni$0,
        }),
      });
      const $newEnv = ((() => {
        const $0 = $env;
        return (Object.assign)({}, $0, ({
          variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name), $instance, $0.variables),
        }));
      }))();
      return ({
        first: (c0$Compiler$TypedAst$ParameterRecycle$0.usr)(...(c0$Compiler$TypedAst$ParameterRecycle$0.ctx), $pos, $raw, $name),
        second: (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), $raw),
        third: $newEnv,
      });
    }))()
    : ((($par)[0] === "$ParameterPattern")
      ? ((() => {
        const $uni = ($par)[1];
        const $pa = ($par)[2];
        const $out = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $env, $uni, $pa, $state);
        (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $out.patternType), ({
          ctx: ([
            $state,
          ]),
          usr: u0$Compiler$TypeCheck$inferParam$2,
        }));
        const $full = ({
          raw: $out.patternType,
          uni: $uni,
        });
        return ({
          first: (c0$Compiler$TypedAst$ParameterPattern$0.usr)(...(c0$Compiler$TypedAst$ParameterPattern$0.ctx), $full, $out.typedPattern),
          second: (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), $full),
          third: $out.env,
        });
      }))()
      : ((($par)[0] === "$ParameterPlaceholder")
        ? ((() => {
          const $num = ($par)[1];
          const $tyvarId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
          (hash_insert)($state.boundTyvars, $tyvarId, null);
          const $raw = (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$G$0, $tyvarId);
          const $univarId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
          const $type = ({
            raw: $raw,
            uni: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), $univarId),
          });
          const $instance = ({
            definedAt: c0$Compiler$Pos$G$0,
            freeTyvars: c0$Dict$empty$0,
            freeUnivars: c0$Dict$empty$0,
            lambdaSetConstraints: c0$Dict$empty$0,
            type: $type,
          });
          const $newEnv = ((() => {
            const $0 = $env;
            return (Object.assign)({}, $0, ({
              variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), $num), $instance, $0.variables),
            }));
          }))();
          return ({
            first: (c0$Compiler$TypedAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$TypedAst$ParameterPlaceholder$0.ctx), $type, $num),
            second: (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), $type),
            third: $newEnv,
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1291:4', (sp_toHuman)($par)))));
});

const u0$Compiler$TypeCheck$inferParam$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferParam$1,
});

const u0$Compiler$TypeCheck$inferFn$3 = (($body, $env, $newEnv, $pos, $s) => {
  return (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), ((() => {
    const $0 = $newEnv;
    return (Object.assign)({}, $0, ({
      context: (u0$Compiler$TypeCheck$Context_FnBody$0.usr)(...(u0$Compiler$TypeCheck$Context_FnBody$0.ctx), $pos, $env.context),
      currentLetInNames: c0$Dict$empty$0,
    }));
  }))(), $body, $s);
});

const u0$Compiler$TypeCheck$inferFn$2 = (($parTypes, $state, $typedPars, $index, $par, $envX) => {
  const $4 = (u0$Compiler$TypeCheck$inferParam$0.usr)(...(u0$Compiler$TypeCheck$inferParam$0.ctx), $envX, $index, $par, $state);
  const $envX1 = $4.third;
  const $parType = $4.second;
  const $typedPar = $4.first;
  (array_push)($typedPars, $typedPar);
  (array_push)($parTypes, $parType);
  return $envX1;
});

const u0$Compiler$TypeCheck$inferFn$1 = (($env, $pos, $caPars, $body, $state) => {
  let $typedPars = (array_fromList)(c0$Core$Nil$0);
  let $parTypes = (array_fromList)(c0$Core$Nil$0);
  const $newEnv = (c0$List$indexedFor$0.usr)(...(c0$List$indexedFor$0.ctx), $env, $caPars, ({
    ctx: ([
      $parTypes,
      $state,
      $typedPars,
    ]),
    usr: u0$Compiler$TypeCheck$inferFn$2,
  }));
  return (u0$Compiler$TypeCheck$doLambda$0.usr)(...(u0$Compiler$TypeCheck$doLambda$0.ctx), ({
    env: $newEnv,
    lambdaPos: $pos,
    lambdaSet: (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaSetId),
    parTypes: (array_toList)($parTypes),
    runBodyCheck: ({
      ctx: ([
        $body,
        $env,
        $newEnv,
        $pos,
      ]),
      usr: u0$Compiler$TypeCheck$inferFn$3,
    }),
    typePos: $pos,
    typedPars: (array_toList)($typedPars),
  }), $state);
});

const u0$Compiler$TypeCheck$inferFn$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferFn$1,
});

const u0$Compiler$TypeCheck$inferRecord$7 = (($env, $fixedTypes, $pos, $state, $name, $valueType) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $fixedTypes);
  return ((($3)[0] === "$Nothing")
    ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute$0.ctx), $name), $state)
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $ty = ($3)[1];
        return (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_Record$0, $ty, $valueType, $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1696:28', (sp_toHuman)($3))));
});

const u0$Compiler$TypeCheck$inferRecord$6 = (($env, $pos, $state, $name, $1) => {
  const $inAttr = $1.first;
  const $extAttr = $1.second;
  return (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_Record$0, $inAttr, $extAttr, $state);
});

const u0$Compiler$TypeCheck$inferRecord$5 = (($k, $2, $u) => {
  const $full = $2.second;
  return (u0$Compiler$TypeCheck$inferUni$0.usr)(...(u0$Compiler$TypeCheck$inferUni$0.ctx), $full.uni, $u);
});

const u0$Compiler$TypeCheck$inferRecord$4 = (($k, $1) => {
  const $t = $1.second;
  return $t.raw;
});

const u0$Compiler$TypeCheck$inferRecord$3 = (($k, $v) => {
  return (c0$Tuple$first$0.usr)(...(c0$Tuple$first$0.ctx), $v);
});

const u0$Compiler$TypeCheck$inferRecord$2 = (($env, $state, $name, $value) => {
  return (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      context: (u0$Compiler$TypeCheck$Context_Argument$0.usr)(...(u0$Compiler$TypeCheck$Context_Argument$0.ctx), $name, $0.context),
    }));
  }))(), $value, $state);
});

const u0$Compiler$TypeCheck$inferRecord$1 = (($env, $pos, $maybeExt, $caAttrs, $state) => {
  const $taAttrs = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: ([
      $env,
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$inferRecord$2,
  }), $caAttrs);
  const $typedAttrs = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$inferRecord$3,
  }), $taAttrs);
  const $attrTypes = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$inferRecord$4,
  }), $taAttrs);
  const $uni = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Compiler$Ast$Uni$0, $taAttrs, ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$inferRecord$5,
  }));
  return ((($maybeExt)[0] === "$Nothing")
    ? ({
      first: (c0$Compiler$TypedAst$Record$0.usr)(...(c0$Compiler$TypedAst$Record$0.ctx), $pos, c0$Maybe$Nothing$0, $typedAttrs),
      second: ({
        raw: (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $pos, c0$Maybe$Nothing$0, $attrTypes),
        uni: $uni,
      }),
    })
    : ((($maybeExt)[0] === "$Just")
      ? ((() => {
        const $caExt = ($maybeExt)[1];
        const $6 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $caExt, $state);
        const $extType = $6.second;
        const $typedExt = $6.first;
        const $finalType = ((() => {
          const $7 = $extType.raw;
          return (((($7)[0] === "$TypeRecord") && ((($7)[2])[0] === "$Nothing"))
            ? ((() => {
              const $fixedTypes = ($7)[3];
              (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $attrTypes, ({
                ctx: ([
                  $env,
                  $fixedTypes,
                  $pos,
                  $state,
                ]),
                usr: u0$Compiler$TypeCheck$inferRecord$7,
              }));
              return $extType.raw;
            }))()
            : (((($7)[0] === "$TypeRecord") && ((($7)[2])[0] === "$Just"))
              ? ((() => {
                const $p = ($7)[1];
                const $tyvarId = (($7)[2])[1];
                const $extensionAttrTypes = ($7)[3];
                const $8 = (c0$Dict$onlyBothOnly$0.usr)(...(c0$Dict$onlyBothOnly$0.ctx), $attrTypes, $extensionAttrTypes);
                const $extensionOnly = $8.third;
                const $both = $8.second;
                const $expressionOnly = $8.first;
                (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $both, ({
                  ctx: ([
                    $env,
                    $pos,
                    $state,
                  ]),
                  usr: u0$Compiler$TypeCheck$inferRecord$6,
                }));
                const $newExtId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
                return (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $newExtId), (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $attrTypes, $extensionOnly));
              }))()
              : ((($7)[0] === "$TypeVar")
                ? ((() => {
                  const $p = ($7)[1];
                  const $id = ($7)[2];
                  const $ty = (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state)), $attrTypes);
                  (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_RecordExt$0, $extType.raw, $ty, $state);
                  return $ty;
                }))()
                : (true
                  ? ((() => {
                    (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, u0$Compiler$TypeCheck$ErrorNotCompatibleWithRecord$0, $state);
                    return c0$Compiler$TypedAst$TypeError$0;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1692:16', (sp_toHuman)($7))))));
        }))();
        return ({
          first: (c0$Compiler$TypedAst$Record$0.usr)(...(c0$Compiler$TypedAst$Record$0.ctx), $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $typedExt), $typedAttrs),
          second: ({
            raw: $finalType,
            uni: (u0$Compiler$TypeCheck$inferUni$0.usr)(...(u0$Compiler$TypeCheck$inferUni$0.ctx), $uni, $extType.uni),
          }),
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1682:4', (sp_toHuman)($maybeExt))));
});

const u0$Compiler$TypeCheck$inferRecord$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferRecord$1,
});

const u0$Compiler$TypeCheck$inferRecordAccess$1 = (($env, $pos, $attrName, $inferredType, $state) => {
  return (((($inferredType)[0] === "$TypeRecord") && ((($inferredType)[2])[0] === "$Nothing"))
    ? ((() => {
      const $attrTypes = ($inferredType)[3];
      const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $attrName, $attrTypes);
      return ((($6)[0] === "$Just")
        ? ((() => {
          const $type = ($6)[1];
          return $type;
        }))()
        : ((($6)[0] === "$Nothing")
          ? ((() => {
            (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordDoesNotHaveAttribute$0.ctx), $attrName), $state);
            return c0$Compiler$TypedAst$TypeError$0;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1615:12', (sp_toHuman)($6))));
    }))()
    : (((($inferredType)[0] === "$TypeRecord") && ((($inferredType)[2])[0] === "$Just"))
      ? ((() => {
        const $p = ($inferredType)[1];
        const $tyvarId = (($inferredType)[2])[1];
        const $extensionAttrTypes = ($inferredType)[3];
        const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $attrName, $extensionAttrTypes);
        return ((($6)[0] === "$Just")
          ? ((() => {
            const $type = ($6)[1];
            return $type;
          }))()
          : ((($6)[0] === "$Nothing")
            ? ((() => {
              const $newExtId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
              const $newAttrType = (u0$Compiler$TypeCheck$newRawType$0.usr)(...(u0$Compiler$TypeCheck$newRawType$0.ctx), $state);
              const $type = (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $newExtId), (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $attrName, $newAttrType, $extensionAttrTypes));
              (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_RecordAccess$0, (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $p, $tyvarId), $type, $state);
              return $newAttrType;
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1626:12', (sp_toHuman)($6))));
      }))()
      : ((($inferredType)[0] === "$TypeVar")
        ? ((() => {
          const $p = ($inferredType)[1];
          const $id = ($inferredType)[2];
          const $newExtId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
          const $newAttrType = (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), $p, (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state));
          const $type = (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $p, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $newExtId), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $attrName, $newAttrType));
          (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_RecordAccess$0, $inferredType, $type, $state);
          return $newAttrType;
        }))()
        : (true
          ? ((() => {
            (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord$0.usr)(...(u0$Compiler$TypeCheck$ErrorTryingToAccessAttributeOfNonRecord$0.ctx), $attrName, $inferredType), $state);
            return c0$Compiler$TypedAst$TypeError$0;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1612:4', (sp_toHuman)($inferredType))))));
});

const u0$Compiler$TypeCheck$inferRecordAccess$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferRecordAccess$1,
});

const u0$Compiler$TypeCheck$inferExpression$1 = (($env, $caExpression, $state) => {
  return ((($caExpression)[0] === "$LiteralNumber")
    ? ((() => {
      const $pos = ($caExpression)[1];
      const $n = ($caExpression)[2];
      return ({
        first: (c0$Compiler$TypedAst$LiteralNumber$0.usr)(...(c0$Compiler$TypedAst$LiteralNumber$0.ctx), $pos, $n),
        second: ({
          raw: u0$Compiler$TypeCheck$coreTypeNumber$0,
          uni: c0$Compiler$Ast$Uni$0,
        }),
      });
    }))()
    : ((($caExpression)[0] === "$LiteralText")
      ? ((() => {
        const $pos = ($caExpression)[1];
        const $text = ($caExpression)[2];
        return ({
          first: (c0$Compiler$TypedAst$LiteralText$0.usr)(...(c0$Compiler$TypedAst$LiteralText$0.ctx), $pos, $text),
          second: ({
            raw: u0$Compiler$TypeCheck$coreTypeText$0,
            uni: c0$Compiler$Ast$Uni$0,
          }),
        });
      }))()
      : ((($caExpression)[0] === "$Variable")
        ? ((() => {
          const $pos = ($caExpression)[1];
          const $ref = ($caExpression)[2];
          const $ty = ((() => {
            const $4 = (u0$Compiler$TypeCheck$getVariableByRef$0.usr)(...(u0$Compiler$TypeCheck$getVariableByRef$0.ctx), $ref, $env);
            return ((($4)[0] === "$Nothing")
              ? ((() => {
                (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorVariableNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorVariableNotFound$0.ctx), $ref), $state);
                return u0$Compiler$TypeCheck$fullTypeError$0;
              }))()
              : ((($4)[0] === "$Just")
                ? ((() => {
                  const $instance = ($4)[1];
                  const $t = (u0$Compiler$TypeCheck$generalize$0.usr)(...(u0$Compiler$TypeCheck$generalize$0.ctx), $env, $pos, $ref, $instance, $state);
                  return $t;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1053:16', (sp_toHuman)($4))));
          }))();
          return ({
            first: (c0$Compiler$TypedAst$Variable$0.usr)(...(c0$Compiler$TypedAst$Variable$0.ctx), $pos, $ref),
            second: $ty,
          });
        }))()
        : ((($caExpression)[0] === "$Constructor")
          ? ((() => {
            const $pos = ($caExpression)[1];
            const $usr = ($caExpression)[2];
            const $ty = ((() => {
              const $4 = (u0$Compiler$TypeCheck$getConstructorByUsr$0.usr)(...(u0$Compiler$TypeCheck$getConstructorByUsr$0.ctx), $usr, $env);
              return ((($4)[0] === "$Nothing")
                ? ((() => {
                  (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.ctx), $usr), $state);
                  return u0$Compiler$TypeCheck$fullTypeError$0;
                }))()
                : ((($4)[0] === "$Just")
                  ? ((() => {
                    const $cons = ($4)[1];
                    return (u0$Compiler$TypeCheck$generalize$0.usr)(...(u0$Compiler$TypeCheck$generalize$0.ctx), $env, $pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $usr), $cons, $state);
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1073:16', (sp_toHuman)($4))));
            }))();
            return ({
              first: (c0$Compiler$TypedAst$Constructor$0.usr)(...(c0$Compiler$TypedAst$Constructor$0.ctx), $pos, $usr),
              second: ((() => {
                const $0 = $ty;
                return (Object.assign)({}, $0, ({
                  uni: c0$Compiler$Ast$Uni$0,
                }));
              }))(),
            });
          }))()
          : ((($caExpression)[0] === "$Fn")
            ? ((() => {
              const $pos = ($caExpression)[1];
              const $caPars = ($caExpression)[2];
              const $body = ($caExpression)[3];
              return (u0$Compiler$TypeCheck$inferFn$0.usr)(...(u0$Compiler$TypeCheck$inferFn$0.ctx), $env, $pos, $caPars, $body, $state);
            }))()
            : ((($caExpression)[0] === "$Call")
              ? ((() => {
                const $pos = ($caExpression)[1];
                const $reference = ($caExpression)[2];
                const $args = ($caExpression)[3];
                return (u0$Compiler$TypeCheck$doCall$0.usr)(...(u0$Compiler$TypeCheck$doCall$0.ctx), $env, $pos, c0$Maybe$Nothing$0, $reference, $args, $state);
              }))()
              : ((($caExpression)[0] === "$Record")
                ? ((() => {
                  const $pos = ($caExpression)[1];
                  const $maybeExt = ($caExpression)[2];
                  const $attrs = ($caExpression)[3];
                  return (u0$Compiler$TypeCheck$inferRecord$0.usr)(...(u0$Compiler$TypeCheck$inferRecord$0.ctx), $env, $pos, $maybeExt, $attrs, $state);
                }))()
                : ((($caExpression)[0] === "$RecordAccess")
                  ? ((() => {
                    const $pos = ($caExpression)[1];
                    const $attrName = ($caExpression)[2];
                    const $recordExpression = ($caExpression)[3];
                    const $4 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $recordExpression, $state);
                    const $inferredType = $4.second;
                    const $typedExpr = $4.first;
                    return ({
                      first: (c0$Compiler$TypedAst$RecordAccess$0.usr)(...(c0$Compiler$TypedAst$RecordAccess$0.ctx), $pos, $attrName, $typedExpr),
                      second: ((() => {
                        const $0 = $inferredType;
                        return (Object.assign)({}, $0, ({
                          raw: (u0$Compiler$TypeCheck$inferRecordAccess$0.usr)(...(u0$Compiler$TypeCheck$inferRecordAccess$0.ctx), $env, $pos, $attrName, $0.raw, $state),
                        }));
                      }))(),
                    });
                  }))()
                  : ((($caExpression)[0] === "$LetIn")
                    ? ((() => {
                      const $def = ($caExpression)[1];
                      const $rest = ($caExpression)[2];
                      return (u0$Compiler$TypeCheck$doLetIn$0.usr)(...(u0$Compiler$TypeCheck$doLetIn$0.ctx), $env, $state, c0$Maybe$Nothing$0, $def, $rest);
                    }))()
                    : ((($caExpression)[0] === "$If")
                      ? ((() => {
                        const $pos = ($caExpression)[1];
                        const $condition = ($caExpression)[2].condition;
                        const $false = ($caExpression)[2].false;
                        const $true = ($caExpression)[2].true;
                        const $4 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), ((() => {
                          const $0 = $env;
                          return (Object.assign)({}, $0, ({
                            context: u0$Compiler$TypeCheck$Context_IfCondition$0,
                          }));
                        }))(), $condition, $state);
                        const $conditionType = $4.second;
                        const $typedCondition = $4.first;
                        (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_IfCondition$0, u0$Compiler$TypeCheck$coreTypeBool$0, $conditionType.raw, $state);
                        const $5 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), ((() => {
                          const $0 = $env;
                          return (Object.assign)({}, $0, ({
                            context: u0$Compiler$TypeCheck$Context_IfTrue$0,
                          }));
                        }))(), $true, $state);
                        const $trueType = $5.second;
                        const $typedTrue = $5.first;
                        const $6 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), ((() => {
                          const $0 = $env;
                          return (Object.assign)({}, $0, ({
                            context: u0$Compiler$TypeCheck$Context_IfFalse$0,
                          }));
                        }))(), $false, $state);
                        const $falseType = $6.second;
                        const $typedFalse = $6.first;
                        (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_IfBranches$0, $trueType.raw, $falseType.raw, $state);
                        const $expression = (c0$Compiler$TypedAst$If$0.usr)(...(c0$Compiler$TypedAst$If$0.ctx), $pos, ({
                          condition: $typedCondition,
                          false: $typedFalse,
                          true: $typedTrue,
                        }));
                        const $uni = (u0$Compiler$TypeCheck$inferUni$0.usr)(...(u0$Compiler$TypeCheck$inferUni$0.ctx), $trueType.uni, $falseType.uni);
                        return ({
                          first: $expression,
                          second: ({
                            raw: $trueType.raw,
                            uni: $uni,
                          }),
                        });
                      }))()
                      : ((($caExpression)[0] === "$Try")
                        ? ((() => {
                          const $pos = ($caExpression)[1];
                          const $patternsAndExpressions = ($caExpression)[2].patternsAndExpressions;
                          const $value = ($caExpression)[2].value;
                          return (u0$Compiler$TypeCheck$doTry$0.usr)(...(u0$Compiler$TypeCheck$doTry$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$newRawType$0.usr)(...(u0$Compiler$TypeCheck$newRawType$0.ctx), $state), $value, $patternsAndExpressions, $state);
                        }))()
                        : ((($caExpression)[0] === "$Introspect")
                          ? ((() => {
                            const $pos = ($caExpression)[1];
                            const $introspect = ($caExpression)[2];
                            const $usr = ($caExpression)[3];
                            return (u0$Compiler$TypeCheck$doIntrospect$0.usr)(...(u0$Compiler$TypeCheck$doIntrospect$0.ctx), $env, $pos, $introspect, $usr, $state);
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1043:4', (sp_toHuman)($caExpression))))))))))))));
});

const u0$Compiler$TypeCheck$inferExpression$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferExpression$1,
});

const u0$Compiler$TypeCheck$inferArgument$2 = (($env, $pos, $state, $attrName, $tyAcc) => {
  return (u0$Compiler$TypeCheck$inferRecordAccess$0.usr)(...(u0$Compiler$TypeCheck$inferRecordAccess$0.ctx), $env, $pos, $attrName, $tyAcc, $state);
});

const u0$Compiler$TypeCheck$inferArgument$1 = (($env, $arg, $state) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $exp = ($arg)[1];
      const $4 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $exp, $state);
      const $expType = $4.second;
      const $typedExp = $4.first;
      return (c0$Compiler$TypedAst$ArgumentExpression$0.usr)(...(c0$Compiler$TypedAst$ArgumentExpression$0.ctx), $expType, $typedExp);
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $pos = ($arg)[1];
        const $name = ($arg)[2];
        const $attrPath = ($arg)[3];
        const $ref = (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name);
        const $raw = ((() => {
          const $4 = (u0$Compiler$TypeCheck$getVariableByRef$0.usr)(...(u0$Compiler$TypeCheck$getVariableByRef$0.ctx), $ref, $env);
          return ((($4)[0] === "$Nothing")
            ? ((() => {
              (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorVariableNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorVariableNotFound$0.ctx), $ref), $state);
              return c0$Compiler$TypedAst$TypeError$0;
            }))()
            : ((($4)[0] === "$Just")
              ? ((() => {
                const $var = ($4)[1];
                return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $var.type.raw, $attrPath, ({
                  ctx: ([
                    $env,
                    $pos,
                    $state,
                  ]),
                  usr: u0$Compiler$TypeCheck$inferArgument$2,
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2256:16', (sp_toHuman)($4))));
        }))();
        return (c0$Compiler$TypedAst$ArgumentRecycle$0.usr)(...(c0$Compiler$TypedAst$ArgumentRecycle$0.ctx), $pos, $raw, $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2243:4', (sp_toHuman)($arg))));
});

const u0$Compiler$TypeCheck$inferArgument$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$inferArgument$1,
});

const u0$Compiler$TypeCheck$doCall$4 = (($env, $pos, $state, $index, $givenArg, $parType) => {
  const $4 = ({
    first: $givenArg,
    second: $parType,
  });
  return (((($4.first)[0] === "$ArgumentRecycle") && (($4.second)[0] === "$ParRe"))
    ? ((() => {
      const $p = ($4.first)[1];
      const $givenRaw = ($4.first)[2];
      const $attrPath = ($4.first)[3];
      const $name = ($4.first)[4];
      const $inferredRaw = ($4.second)[1];
      const $5 = (u0$Compiler$TypeCheck$getVariableByRef$0.usr)(...(u0$Compiler$TypeCheck$getVariableByRef$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name), $env);
      return ((($5)[0] === "$Nothing")
        ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $p, (u0$Compiler$TypeCheck$ErrorVariableNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorVariableNotFound$0.ctx), (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), $name)), $state)
        : ((($5)[0] === "$Just")
          ? ((() => {
            const $instance = ($5)[1];
            (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), (sp_not_equal)($instance.type.uni, c0$Compiler$Ast$Uni$0), $env, $p, u0$Compiler$TypeCheck$ErrorShouldBeUnique$0, $state);
            return (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$Why_Argument$0.usr)(...(u0$Compiler$TypeCheck$Why_Argument$0.ctx), $index), $givenRaw, $inferredRaw, $state);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2177:32', (sp_toHuman)($5))));
    }))()
    : (((($4.first)[0] === "$ArgumentExpression") && (($4.second)[0] === "$ParSp"))
      ? ((() => {
        const $givenFull = ($4.first)[1];
        const $expr = ($4.first)[2];
        const $inferredFull = ($4.second)[1];
        (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $env, $pos, ({
          given: $givenFull.uni,
          required: $inferredFull.uni,
        }), $state);
        return (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$Why_Argument$0.usr)(...(u0$Compiler$TypeCheck$Why_Argument$0.ctx), $index), $inferredFull.raw, $givenFull.raw, $state);
      }))()
      : (true
        ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, u0$Compiler$TypeCheck$ErrorUniquenessDoesNotMatchArgument$0, $state)
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2174:24', (sp_toHuman)($4)))));
});

const u0$Compiler$TypeCheck$doCall$3 = (($arg) => {
  return ((($arg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $full = ($arg)[1];
      return (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), $full);
    }))()
    : ((($arg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $raw = ($arg)[2];
        return (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), $raw);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2154:8', (sp_toHuman)($arg))));
});

const u0$Compiler$TypeCheck$doCall$2 = (($env, $state, $arg) => {
  return (u0$Compiler$TypeCheck$inferArgument$0.usr)(...(u0$Compiler$TypeCheck$inferArgument$0.ctx), $env, $arg, $state);
});

const u0$Compiler$TypeCheck$doCall$1 = (($env, $pos, $maybeExpected, $reference, $givenArgs, $state) => {
  const $7 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $reference, $state);
  const $inferredReferenceType = $7.second;
  const $typedReference = $7.first;
  const $typedArguments = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$doCall$2,
  }), $givenArgs);
  const $toTypeArg = ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$doCall$3,
  });
  const $8 = ((() => {
    const $9 = $inferredReferenceType.raw;
    return ((($9)[0] === "$TypeFn")
      ? ((() => {
        const $lambdaSet = ($9)[2];
        const $parTypes = ($9)[3];
        const $outType = ($9)[4];
        const $given = (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $typedArguments);
        const $expected = (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $parTypes);
        return ((sp_not_equal)($expected, $given)
          ? ((() => {
            (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorWrongNumberOfArguments$0.usr)(...(u0$Compiler$TypeCheck$ErrorWrongNumberOfArguments$0.ctx), ({
              expected: $expected,
              given: $given,
              reference: $reference,
            })), $state);
            return ({
              first: u0$Compiler$TypeCheck$fullTypeError$0,
              second: $lambdaSet,
            });
          }))()
          : ((() => {
            (c0$List$indexedEach2$0.usr)(...(c0$List$indexedEach2$0.ctx), $typedArguments, $parTypes, ({
              ctx: ([
                $env,
                $pos,
                $state,
              ]),
              usr: u0$Compiler$TypeCheck$doCall$4,
            }));
            return ((($maybeExpected)[0] === "$Nothing")
              ? ({
                first: $outType,
                second: $lambdaSet,
              })
              : ((($maybeExpected)[0] === "$Just")
                ? ((() => {
                  const $e = ($maybeExpected)[1].expectedType;
                  (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $env, $pos, ({
                    given: $outType.uni,
                    required: $e.uni,
                  }), $state);
                  (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_Annotation$0, $outType.raw, $e.raw, $state);
                  return ({
                    first: $e,
                    second: $lambdaSet,
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2197:20', (sp_toHuman)($maybeExpected))));
          }))());
      }))()
      : ((($9)[0] === "$TypeVar")
        ? ((() => {
          const $p = ($9)[1];
          const $id = ($9)[2];
          const $returnType = ((($maybeExpected)[0] === "$Just")
            ? ((() => {
              const $e = ($maybeExpected)[1].expectedType;
              return $e;
            }))()
            : ((($maybeExpected)[0] === "$Nothing")
              ? ({
                raw: (u0$Compiler$TypeCheck$newRawType$0.usr)(...(u0$Compiler$TypeCheck$newRawType$0.ctx), $state),
                uni: c0$Compiler$Ast$Imm$0,
              })
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2211:20', (sp_toHuman)($maybeExpected))));
          const $lambdaSet = (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaSetId);
          const $refTy = (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), $p, $lambdaSet, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $toTypeArg, $typedArguments), $returnType);
          (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_CalledAsFunction$0, $refTy, $inferredReferenceType.raw, $state);
          return ({
            first: $returnType,
            second: $lambdaSet,
          });
        }))()
        : ((($9)[0] === "$TypeError")
          ? ({
            first: u0$Compiler$TypeCheck$fullTypeError$0,
            second: (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaSetId),
          })
          : (true
            ? ((() => {
              const $z = $9;
              (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorCallingANonFunction$0.usr)(...(u0$Compiler$TypeCheck$ErrorCallingANonFunction$0.ctx), $z), $state);
              return ({
                first: u0$Compiler$TypeCheck$fullTypeError$0,
                second: (u0$Compiler$TypeCheck$nextId$0.usr)(...(u0$Compiler$TypeCheck$nextId$0.ctx), $state.lastLambdaSetId),
              });
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2159:8', (sp_toHuman)($9))))));
  }))();
  const $finalLambdaSet = $8.second;
  const $expectedReturnType = $8.first;
  return ({
    first: (c0$Compiler$TypedAst$Call$0.usr)(...(c0$Compiler$TypedAst$Call$0.ctx), $pos, $finalLambdaSet, $typedReference, $typedArguments),
    second: $expectedReturnType,
  });
});

const u0$Compiler$TypeCheck$doCall$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doCall$1,
});

const u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$5 = (($rec, _0, $a1, $a2) => {
  return ($rec.usr)(...($rec.ctx), $a1, $a2);
});

const u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$4 = (($rec, _0, $p1, $p2) => {
  return ($rec.usr)(...($rec.ctx), (c0$Compiler$TypedAst$toRaw$0.usr)(...(c0$Compiler$TypedAst$toRaw$0.ctx), $p1), (c0$Compiler$TypedAst$toRaw$0.usr)(...(c0$Compiler$TypedAst$toRaw$0.ctx), $p2));
});

const u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$3 = (($rec, $k, $1) => {
  const $a1 = $1.first;
  const $a2 = $1.second;
  return ($rec.usr)(...($rec.ctx), $a1, $a2);
});

const u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$2 = (($state, $0, $1) => {
  return (u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.usr)(...(u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.ctx), $state, $0, $1);
});

const u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$1 = (($state, $t1, $t2) => {
  const $rec = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$2,
  });
  const $4 = ({
    first: $t1,
    second: $t2,
  });
  return (((($4.first)[0] === "$TypeExact") && (($4.second)[0] === "$TypeExact"))
    ? ((() => {
      const $args1 = ($4.first)[3];
      const $args2 = ($4.second)[3];
      return (c0$List$indexedEach2$0.usr)(...(c0$List$indexedEach2$0.ctx), $args1, $args2, ({
        ctx: ([
          $rec,
        ]),
        usr: u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$5,
      }));
    }))()
    : (((($4.first)[0] === "$TypeFn") && (($4.second)[0] === "$TypeFn"))
      ? ((() => {
        const $setId1 = ($4.first)[2];
        const $pars1 = ($4.first)[3];
        const $out1 = ($4.first)[4];
        const $setId2 = ($4.second)[2];
        const $pars2 = ($4.second)[3];
        const $out2 = ($4.second)[4];
        (u0$SPLib$UnionFind$union$0.usr)(...(u0$SPLib$UnionFind$union$0.ctx), $state.lambdaSetUnionFind, $setId1, $setId2);
        (c0$List$indexedEach2$0.usr)(...(c0$List$indexedEach2$0.ctx), $pars1, $pars1, ({
          ctx: ([
            $rec,
          ]),
          usr: u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$4,
        }));
        return ($rec.usr)(...($rec.ctx), $out1.raw, $out2.raw);
      }))()
      : (((($4.first)[0] === "$TypeRecord") && (($4.second)[0] === "$TypeRecord"))
        ? ((() => {
          const $attrs1 = ($4.first)[3];
          const $attrs2 = ($4.second)[3];
          const $5 = (c0$Dict$onlyBothOnly$0.usr)(...(c0$Dict$onlyBothOnly$0.ctx), $attrs1, $attrs2);
          const $both = $5.second;
          return (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $both, ({
            ctx: ([
              $rec,
            ]),
            usr: u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$3,
          }));
        }))()
        : (true
          ? null
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 344:4', (sp_toHuman)($4))))));
});

const u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$1,
});

const u0$Compiler$TypeCheck$checkExpression$7 = (($body, $localEnv, $out, $pars, $s) => {
  return (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), ((() => {
    const $0 = $localEnv;
    return (Object.assign)({}, $0, ({
      currentLetInNames: c0$Dict$empty$0,
    }));
  }))(), ((() => {
    const $0 = $pars;
    return (Object.assign)({}, $0, ({
      expectedType: $out,
    }));
  }))(), $body, $s);
});

const u0$Compiler$TypeCheck$checkExpression$6 = (($state, $typedPars, $2, $envX) => {
  const $par = $2.first;
  const $parType = $2.second;
  const $3 = (u0$Compiler$TypeCheck$checkParameter$0.usr)(...(u0$Compiler$TypeCheck$checkParameter$0.ctx), $envX, $parType, $par, $state);
  const $envX1 = $3.second;
  const $typedPar = $3.first;
  (array_push)($typedPars, $typedPar);
  return $envX1;
});

const u0$Compiler$TypeCheck$checkExpression$5 = (($annotatedTypeByName, $env, $pars, $pos, $state, $attrName, $attrExpr, $1) => {
  const $vs = $1.first;
  const $ts = $1.second;
  const $4 = ((() => {
    const $5 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $attrName, $annotatedTypeByName);
    return ((($5)[0] === "$Nothing")
      ? ((() => {
        (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $attrName, c0$Core$Nil$0)), $state);
        return (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $attrExpr, $state);
      }))()
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $attrType = ($5)[1];
          return (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $env, ((() => {
            const $0 = $pars;
            return (Object.assign)({}, $0, ({
              expectedType: ((() => {
                const $1 = $0.expectedType;
                return (Object.assign)({}, $1, ({
                  raw: $attrType,
                }));
              }))(),
            }));
          }))(), $attrExpr, $state);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2029:32', (sp_toHuman)($5))));
  }))();
  const $t = $4.second;
  const $v = $4.first;
  return ({
    first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $attrName, $v, $vs),
    second: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $attrName, $t.raw, $ts),
  });
});

const u0$Compiler$TypeCheck$checkExpression$4 = (($env, $pars, $state, $name, $2, $1) => {
  const $value = $2.first;
  const $type = $2.second;
  const $vs = $1.first;
  const $ts = $1.second;
  const $4 = (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $env, ((() => {
    const $0 = $pars;
    return (Object.assign)({}, $0, ({
      expectedType: ((() => {
        const $1 = $0.expectedType;
        return (Object.assign)({}, $1, ({
          raw: $type,
        }));
      }))(),
    }));
  }))(), $value, $state);
  const $t = $4.second;
  const $v = $4.first;
  return ({
    first: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $v, $vs),
    second: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $t.raw, $ts),
  });
});

const u0$Compiler$TypeCheck$checkExpression$3 = (($addErrorLocal, $test, $typeConstraint) => {
  return ($test
    ? null
    : ($addErrorLocal.usr)(...($addErrorLocal.ctx), $typeConstraint));
});

const u0$Compiler$TypeCheck$checkExpression$2 = (($caExpression, $env, $pars, $state, $typeConstraint) => {
  const $annotatedPatternName = ((() => {
    const $2 = $pars.annotatedPattern;
    return (((($2)[0] === "$PatternAny") && ((($2)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $name = (($2)[2].maybeName)[1];
        return (("`" + $name) + "`");
      }))()
      : (true
        ? "the pattern"
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1869:12', (sp_toHuman)($2))));
  }))();
  const $annotatedPatternLocation = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$TypeCheck$getErrorModule$0.usr)(...(u0$Compiler$TypeCheck$getErrorModule$0.ctx), $env), (c0$Compiler$CanonicalAst$typePos$0.usr)(...(c0$Compiler$CanonicalAst$typePos$0.ctx), $pars.annotation));
  return (u0$Compiler$TypeCheck$addErrorText$0.usr)(...(u0$Compiler$TypeCheck$addErrorText$0.ctx), $env, (c0$Compiler$CanonicalAst$expressionPos$0.usr)(...(c0$Compiler$CanonicalAst$expressionPos$0.ctx), $caExpression), $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $typeConstraint, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("However the annotation for " + $annotatedPatternName) + ":"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $annotatedPatternLocation.block, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "says that it must have type", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("    " + (u0$Compiler$TypeCheck$typeToHuman$0.usr)(...(u0$Compiler$TypeCheck$typeToHuman$0.ctx), $env, $pars.expectedType.raw)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need the annotation and the value to have the same type!", c0$Core$Nil$0))))))))));
});

const u0$Compiler$TypeCheck$checkExpression$1 = (($env, $pars, $caExpression, $state) => {
  const $addErrorLocal = ({
    ctx: ([
      $caExpression,
      $env,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$checkExpression$2,
  });
  const $assertLocal = ({
    ctx: ([
      $addErrorLocal,
    ]),
    usr: u0$Compiler$TypeCheck$checkExpression$3,
  });
  return ((($caExpression)[0] === "$LiteralNumber")
    ? ((() => {
      const $pos = ($caExpression)[1];
      const $n = ($caExpression)[2];
      const $isOk = ((() => {
        const $5 = $pars.expectedType.raw;
        return (((($5)[0] === "$TypeExact") && ((($5)[3])[0] === "$Nil"))
          ? ((() => {
            const $typeUsr = ($5)[2];
            return (sp_equal)($typeUsr, u0$Compiler$CoreDefs$numberDef$0.usr);
          }))()
          : (true
            ? false
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1904:16', (sp_toHuman)($5))));
      }))();
      ($assertLocal.usr)(...($assertLocal.ctx), $isOk, "This is a literal number, which means its type is always `Number`.");
      return ({
        first: (c0$Compiler$TypedAst$LiteralNumber$0.usr)(...(c0$Compiler$TypedAst$LiteralNumber$0.ctx), $pos, $n),
        second: $pars.expectedType,
      });
    }))()
    : ((($caExpression)[0] === "$LiteralText")
      ? ((() => {
        const $pos = ($caExpression)[1];
        const $text = ($caExpression)[2];
        const $isOk = ((() => {
          const $5 = $pars.expectedType.raw;
          return (((($5)[0] === "$TypeExact") && ((($5)[3])[0] === "$Nil"))
            ? ((() => {
              const $typeUsr = ($5)[2];
              return (sp_equal)($typeUsr, u0$Compiler$CoreDefs$textDef$0.usr);
            }))()
            : (true
              ? false
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1914:16', (sp_toHuman)($5))));
        }))();
        ($assertLocal.usr)(...($assertLocal.ctx), $isOk, "This is a literal text, which means its type is always `Text`.");
        return ({
          first: (c0$Compiler$TypedAst$LiteralText$0.usr)(...(c0$Compiler$TypedAst$LiteralText$0.ctx), $pos, $text),
          second: $pars.expectedType,
        });
      }))()
      : ((($caExpression)[0] === "$Variable")
        ? ((() => {
          const $pos = ($caExpression)[1];
          const $ref = ($caExpression)[2];
          const $type = ((() => {
            const $5 = (u0$Compiler$TypeCheck$getVariableByRef$0.usr)(...(u0$Compiler$TypeCheck$getVariableByRef$0.ctx), $ref, $env);
            return ((($5)[0] === "$Nothing")
              ? ((() => {
                (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorVariableNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorVariableNotFound$0.ctx), $ref), $state);
                return $pars.expectedType;
              }))()
              : ((($5)[0] === "$Just")
                ? ((() => {
                  const $var = ($5)[1];
                  const $full = (u0$Compiler$TypeCheck$generalize$0.usr)(...(u0$Compiler$TypeCheck$generalize$0.ctx), $env, $pos, $ref, $var, $state);
                  (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $env, $pos, ({
                    given: $full.uni,
                    required: $pars.expectedType.uni,
                  }), $state);
                  (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_Annotation$0, $full.raw, $pars.expectedType.raw, $state);
                  return $full;
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1924:16', (sp_toHuman)($5))));
          }))();
          return ({
            first: (c0$Compiler$TypedAst$Variable$0.usr)(...(c0$Compiler$TypedAst$Variable$0.ctx), $pos, $ref),
            second: $type,
          });
        }))()
        : ((($caExpression)[0] === "$Constructor")
          ? ((() => {
            const $pos = ($caExpression)[1];
            const $usr = ($caExpression)[2];
            const $type = ((() => {
              const $5 = $pars.expectedType.raw;
              return ((($5)[0] === "$TypeExact")
                ? ((() => {
                  const $6 = (u0$Compiler$TypeCheck$getConstructorByUsr$0.usr)(...(u0$Compiler$TypeCheck$getConstructorByUsr$0.ctx), $usr, $env);
                  return ((($6)[0] === "$Nothing")
                    ? ((() => {
                      (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.usr)(...(u0$Compiler$TypeCheck$ErrorConstructorNotFound$0.ctx), $usr), $state);
                      return $pars.expectedType;
                    }))()
                    : ((($6)[0] === "$Just")
                      ? ((() => {
                        const $cons = ($6)[1];
                        const $full = (u0$Compiler$TypeCheck$generalize$0.usr)(...(u0$Compiler$TypeCheck$generalize$0.ctx), $env, $pos, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), $usr), $cons, $state);
                        (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_Annotation$0, $full.raw, $pars.expectedType.raw, $state);
                        return $full;
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1951:24', (sp_toHuman)($6))));
                }))()
                : (true
                  ? ((() => {
                    ($addErrorLocal.usr)(...($addErrorLocal.ctx), "This is a literal variant, which means its type must always be a variant type.");
                    return $pars.expectedType;
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1948:16', (sp_toHuman)($5))));
            }))();
            return ({
              first: (c0$Compiler$TypedAst$Constructor$0.usr)(...(c0$Compiler$TypedAst$Constructor$0.ctx), $pos, $usr),
              second: $type,
            });
          }))()
          : ((($caExpression)[0] === "$Fn")
            ? ((() => {
              const $pos = ($caExpression)[1];
              const $fnPars = ($caExpression)[2];
              const $body = ($caExpression)[3];
              const $5 = $pars.expectedType.raw;
              return ((($5)[0] === "$TypeFn")
                ? ((() => {
                  const $typePos = ($5)[1];
                  const $lambdaSet = ($5)[2];
                  const $parTypes = ($5)[3];
                  const $out = ($5)[4];
                  return ((sp_not_equal)((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $fnPars), (c0$List$length$0.usr)(...(c0$List$length$0.ctx), $parTypes))
                    ? ((() => {
                      (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, u0$Compiler$TypeCheck$ErrorWrongNumberOfParameters$0, $state);
                      return ({
                        first: (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos),
                        second: $pars.expectedType,
                      });
                    }))()
                    : ((() => {
                      let $typedPars = (array_fromList)(c0$Core$Nil$0);
                      const $localEnv = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $env, (c0$List$map2$0.usr)(...(c0$List$map2$0.ctx), c0$Tuple$pair$0, $fnPars, $parTypes), ({
                        ctx: ([
                          $state,
                          $typedPars,
                        ]),
                        usr: u0$Compiler$TypeCheck$checkExpression$6,
                      }));
                      return (u0$Compiler$TypeCheck$doLambda$0.usr)(...(u0$Compiler$TypeCheck$doLambda$0.ctx), ({
                        env: $localEnv,
                        lambdaPos: $pos,
                        lambdaSet: $lambdaSet,
                        parTypes: $parTypes,
                        runBodyCheck: ({
                          ctx: ([
                            $body,
                            $localEnv,
                            $out,
                            $pars,
                          ]),
                          usr: u0$Compiler$TypeCheck$checkExpression$7,
                        }),
                        typePos: $typePos,
                        typedPars: (array_toList)($typedPars),
                      }), $state);
                    }))());
                }))()
                : (true
                  ? ((() => {
                    ($addErrorLocal.usr)(...($addErrorLocal.ctx), "This expression is a function, which means its type is always a `fn` type.");
                    return ({
                      first: (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos),
                      second: $pars.expectedType,
                    });
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1976:12', (sp_toHuman)($5))));
            }))()
            : ((($caExpression)[0] === "$Call")
              ? ((() => {
                const $pos = ($caExpression)[1];
                const $reference = ($caExpression)[2];
                const $args = ($caExpression)[3];
                return (u0$Compiler$TypeCheck$doCall$0.usr)(...(u0$Compiler$TypeCheck$doCall$0.ctx), $env, $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $pars), $reference, $args, $state);
              }))()
              : (((($caExpression)[0] === "$Record") && ((($caExpression)[2])[0] === "$Just"))
                ? ((() => {
                  const $pos = ($caExpression)[1];
                  const $ext = (($caExpression)[2])[1];
                  const $valueByName = ($caExpression)[3];
                  const $5 = $pars.expectedType.raw;
                  return (((($5)[0] === "$TypeRecord") && ((($5)[2])[0] === "$Nothing"))
                    ? ((() => {
                      const $typePos = ($5)[1];
                      const $annotatedTypeByName = ($5)[3];
                      const $6 = (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $env, $pars, $ext, $state);
                      const $extType = $6.second;
                      const $typedExt = $6.first;
                      const $7 = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ({
                        first: c0$Dict$empty$0,
                        second: c0$Dict$empty$0,
                      }), $valueByName, ({
                        ctx: ([
                          $annotatedTypeByName,
                          $env,
                          $pars,
                          $pos,
                          $state,
                        ]),
                        usr: u0$Compiler$TypeCheck$checkExpression$5,
                      }));
                      const $populatedTypeByName = $7.second;
                      const $typedValueByName = $7.first;
                      (u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.usr)(...(u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.ctx), $state, $extType.raw, (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $typePos, c0$Maybe$Nothing$0, $populatedTypeByName));
                      const $finalExpr = (c0$Compiler$TypedAst$Record$0.usr)(...(c0$Compiler$TypedAst$Record$0.ctx), $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $typedExt), $typedValueByName);
                      return ({
                        first: $finalExpr,
                        second: $pars.expectedType,
                      });
                    }))()
                    : (true
                      ? ((() => {
                        ($addErrorLocal.usr)(...($addErrorLocal.ctx), "This is a literal record, which means its type is always a record type.");
                        return ({
                          first: (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos),
                          second: $pars.expectedType,
                        });
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2018:12', (sp_toHuman)($5))));
                }))()
                : (((($caExpression)[0] === "$Record") && ((($caExpression)[2])[0] === "$Nothing"))
                  ? ((() => {
                    const $pos = ($caExpression)[1];
                    const $valueByName = ($caExpression)[3];
                    const $5 = $pars.expectedType.raw;
                    return (((($5)[0] === "$TypeRecord") && ((($5)[2])[0] === "$Nothing"))
                      ? ((() => {
                        const $typePos = ($5)[1];
                        const $typeByName = ($5)[3];
                        const $6 = (c0$Dict$onlyBothOnly$0.usr)(...(c0$Dict$onlyBothOnly$0.ctx), $valueByName, $typeByName);
                        const $bOnly = $6.third;
                        const $both = $6.second;
                        const $aOnly = $6.first;
                        ((sp_not_equal)($aOnly, c0$Dict$empty$0)
                          ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordHasAttributesNotInAnnotation$0.ctx), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $aOnly)), $state)
                          : ((sp_not_equal)($bOnly, c0$Dict$empty$0)
                            ? (u0$Compiler$TypeCheck$addError$0.usr)(...(u0$Compiler$TypeCheck$addError$0.ctx), $env, $pos, (u0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation$0.usr)(...(u0$Compiler$TypeCheck$ErrorRecordIsMissingAttibutesInAnnotation$0.ctx), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $bOnly)), $state)
                            : null));
                        const $7 = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), ({
                          first: c0$Dict$empty$0,
                          second: c0$Dict$empty$0,
                        }), $both, ({
                          ctx: ([
                            $env,
                            $pars,
                            $state,
                          ]),
                          usr: u0$Compiler$TypeCheck$checkExpression$4,
                        }));
                        const $attrTypes = $7.second;
                        const $typedAttrs = $7.first;
                        return ({
                          first: (c0$Compiler$TypedAst$Record$0.usr)(...(c0$Compiler$TypedAst$Record$0.ctx), $pos, c0$Maybe$Nothing$0, $typedAttrs),
                          second: ({
                            raw: (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $typePos, c0$Maybe$Nothing$0, $attrTypes),
                            uni: $pars.expectedType.uni,
                          }),
                        });
                      }))()
                      : (true
                        ? ((() => {
                          ($addErrorLocal.usr)(...($addErrorLocal.ctx), "This is a literal record, which means its type is always a record type.");
                          return ({
                            first: (c0$Compiler$TypedAst$Error$0.usr)(...(c0$Compiler$TypedAst$Error$0.ctx), $pos),
                            second: $pars.expectedType,
                          });
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 2055:12', (sp_toHuman)($5))));
                  }))()
                  : ((($caExpression)[0] === "$RecordAccess")
                    ? ((() => {
                      const $pos = ($caExpression)[1];
                      const $attrName = ($caExpression)[2];
                      const $exp = ($caExpression)[3];
                      const $5 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $exp, $state);
                      const $expressionType = $5.second;
                      const $typedExpression = $5.first;
                      const $newId = (u0$Compiler$TypeCheck$newTyvarId$0.usr)(...(u0$Compiler$TypeCheck$newTyvarId$0.ctx), $state);
                      const $requiredType = (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), $pos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $newId), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $attrName, $pars.expectedType.raw));
                      (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_RecordAccess$0, $expressionType.raw, $requiredType, $state);
                      (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $env, $pos, ({
                        given: $expressionType.uni,
                        required: $pars.expectedType.uni,
                      }), $state);
                      return ({
                        first: (c0$Compiler$TypedAst$RecordAccess$0.usr)(...(c0$Compiler$TypedAst$RecordAccess$0.ctx), $pos, $attrName, $typedExpression),
                        second: $pars.expectedType,
                      });
                    }))()
                    : ((($caExpression)[0] === "$LetIn")
                      ? ((() => {
                        const $def = ($caExpression)[1];
                        const $rest = ($caExpression)[2];
                        return (u0$Compiler$TypeCheck$doLetIn$0.usr)(...(u0$Compiler$TypeCheck$doLetIn$0.ctx), $env, $state, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $pars), $def, $rest);
                      }))()
                      : ((($caExpression)[0] === "$If")
                        ? ((() => {
                          const $pos = ($caExpression)[1];
                          const $condition = ($caExpression)[2].condition;
                          const $false = ($caExpression)[2].false;
                          const $true = ($caExpression)[2].true;
                          const $5 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $env, $condition, $state);
                          const $conditionType = $5.second;
                          const $typedCondition = $5.first;
                          (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $env, $pos, u0$Compiler$TypeCheck$Why_IfCondition$0, u0$Compiler$TypeCheck$coreTypeBool$0, $conditionType.raw, $state);
                          const $6 = (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $env, $pars, $true, $state);
                          const $trueType = $6.second;
                          const $typedTrue = $6.first;
                          const $7 = (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $env, $pars, $false, $state);
                          const $falseType = $7.second;
                          const $typedFalse = $7.first;
                          (u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.usr)(...(u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.ctx), $state, $trueType.raw, $falseType.raw);
                          const $finalExpr = (c0$Compiler$TypedAst$If$0.usr)(...(c0$Compiler$TypedAst$If$0.ctx), $pos, ({
                            condition: $typedCondition,
                            false: $typedFalse,
                            true: $typedTrue,
                          }));
                          return ({
                            first: $finalExpr,
                            second: $pars.expectedType,
                          });
                        }))()
                        : ((($caExpression)[0] === "$Try")
                          ? ((() => {
                            const $pos = ($caExpression)[1];
                            const $patternsAndExpressions = ($caExpression)[2].patternsAndExpressions;
                            const $value = ($caExpression)[2].value;
                            const $5 = (u0$Compiler$TypeCheck$doTry$0.usr)(...(u0$Compiler$TypeCheck$doTry$0.ctx), $env, $pos, $pars.expectedType.raw, $value, $patternsAndExpressions, $state);
                            const $fullType = $5.second;
                            const $typedExp = $5.first;
                            (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $env, $pos, ({
                              given: $fullType.uni,
                              required: $pars.expectedType.uni,
                            }), $state);
                            return ({
                              first: $typedExp,
                              second: $fullType,
                            });
                          }))()
                          : ((($caExpression)[0] === "$Introspect")
                            ? ((() => {
                              const $pos = ($caExpression)[1];
                              return (sp_todo)("checkExpression 'introspect");
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 1900:4', (sp_toHuman)($caExpression)))))))))))))));
});

const u0$Compiler$TypeCheck$checkExpression$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$checkExpression$1,
});

const u0$Compiler$TypeCheck$getLambdaSetConstraints$4 = (($acc, $resolveSetId, $setId, $setConstraints) => {
  const $key = ($resolveSetId.usr)(...($resolveSetId.ctx), $setId);
  const $3 = (hash_get)($acc, $key);
  return ((($3)[0] === "$Nothing")
    ? null
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $previousConstraints = ($3)[1];
        return (hash_insert)($acc, $key, (c0$Set$join$0.usr)(...(c0$Set$join$0.ctx), $previousConstraints, $setConstraints));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 790:8', (sp_toHuman)($3))));
});

const u0$Compiler$TypeCheck$getLambdaSetConstraints$3 = (($acc, $resolveSetId, $setId, _1) => {
  return (hash_insert)($acc, ($resolveSetId.usr)(...($resolveSetId.ctx), $setId), c0$Set$empty$0);
});

const u0$Compiler$TypeCheck$getLambdaSetConstraints$2 = (($state, $0) => {
  return (u0$SPLib$UnionFind$find$0.usr)(...(u0$SPLib$UnionFind$find$0.ctx), $state.lambdaSetUnionFind, $0);
});

const u0$Compiler$TypeCheck$getLambdaSetConstraints$1 = (($state, $raw) => {
  const $resolveSetId = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$getLambdaSetConstraints$2,
  });
  let $acc = (hash_fromList)(c0$Core$Nil$0);
  (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), (c0$Compiler$TypedAst$typeLambdaSets$0.usr)(...(c0$Compiler$TypedAst$typeLambdaSets$0.ctx), $raw), ({
    ctx: ([
      $acc,
      $resolveSetId,
    ]),
    usr: u0$Compiler$TypeCheck$getLambdaSetConstraints$3,
  }));
  (hash_each)($state.lambdaSetConstraints, ({
    ctx: ([
      $acc,
      $resolveSetId,
    ]),
    usr: u0$Compiler$TypeCheck$getLambdaSetConstraints$4,
  }));
  return (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Hash$toList$0.usr)(...(c0$Hash$toList$0.ctx), $acc));
});

const u0$Compiler$TypeCheck$getLambdaSetConstraints$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$getLambdaSetConstraints$1,
});

const u0$Compiler$TypeCheck$doDefinition$13 = (($instance, $pars, $name, $stuff, $vars) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), ($pars.nameToRef.usr)(...($pars.nameToRef.ctx), $name), ($instance.usr)(...($instance.ctx), $name, $stuff), $vars);
});

const u0$Compiler$TypeCheck$doDefinition$12 = (($typeTyvars, $k, $v) => {
  return (c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $k, $typeTyvars);
});

const u0$Compiler$TypeCheck$doDefinition$11 = (($caNames, $freeTyvars, $freeUnivars, $localEnv, $state, $name, $1) => {
  const $pos = $1.pos;
  const $unresolvedType = $1.type;
  const $type = ((() => {
    const $0 = $unresolvedType;
    return (Object.assign)({}, $0, ({
      raw: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $0.raw),
    }));
  }))();
  const $typeTyvars = (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $type.raw);
  const $actualTyvars = (c0$Dict$filter$0.usr)(...(c0$Dict$filter$0.ctx), ({
    ctx: ([
      $typeTyvars,
    ]),
    usr: u0$Compiler$TypeCheck$doDefinition$12,
  }), $freeTyvars);
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $caNames);
  (((($3)[0] === "$Just") && ((($3)[1].maybeAnnotation)[0] === "$Just"))
    ? ((() => {
      const $annotation = (($3)[1].maybeAnnotation)[1];
      const $p = ($3)[1].pos;
      return (u0$Compiler$TypeCheck$addErrorIf$0.usr)(...(u0$Compiler$TypeCheck$addErrorIf$0.ctx), ((c0$Dict$size$0.usr)(...(c0$Dict$size$0.ctx), $annotation.tyvars) > (c0$Dict$size$0.usr)(...(c0$Dict$size$0.ctx), $actualTyvars)), $localEnv, $p, (u0$Compiler$TypeCheck$ErrorTyvarNotIndependent$0.usr)(...(u0$Compiler$TypeCheck$ErrorTyvarNotIndependent$0.ctx), $name), $state);
    }))()
    : (true
      ? null
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 954:8', (sp_toHuman)($3))));
  const $lambdaSetConstraints = (u0$Compiler$TypeCheck$getLambdaSetConstraints$0.usr)(...(u0$Compiler$TypeCheck$getLambdaSetConstraints$0.ctx), $state, $type.raw);
  return ({
    definedAt: $pos,
    freeTyvars: $actualTyvars,
    freeUnivars: $freeUnivars,
    lambdaSetConstraints: $lambdaSetConstraints,
    type: $type,
  });
});

const u0$Compiler$TypeCheck$doDefinition$10 = (($e) => {
  return $e.name;
});

const u0$Compiler$TypeCheck$doDefinition$9 = (($resolvedParentBoundTyvars, $tyvarAnnotatedNameByTyvarId, $id, _1, $acc) => {
  return ((c0$Set$member$0.usr)(...(c0$Set$member$0.ctx), $id, $resolvedParentBoundTyvars)
    ? $acc
    : (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $id, ((() => {
      const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $id, $tyvarAnnotatedNameByTyvarId);
      return ((($4)[0] === "$Nothing")
        ? ({
          maybeAnnotated: c0$Maybe$Nothing$0,
        })
        : ((($4)[0] === "$Just")
          ? ((() => {
            const $name = ($4)[1];
            return ({
              maybeAnnotated: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
                allowFunctions: true,
                name: $name,
              })),
            });
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 927:16', (sp_toHuman)($4))));
    }))(), $acc));
});

const u0$Compiler$TypeCheck$doDefinition$8 = (($name, $tyvarId, $acc) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $tyvarId, $name, $acc);
});

const u0$Compiler$TypeCheck$doDefinition$7 = (($allBindableTyvarsIn, $parentTyvar, _1, $set) => {
  return (c0$Set$for$0.usr)(...(c0$Set$for$0.ctx), (c0$Set$insert$0.usr)(...(c0$Set$insert$0.ctx), $parentTyvar, $set), ($allBindableTyvarsIn.usr)(...($allBindableTyvarsIn.ctx), $parentTyvar), c0$Set$insert$0);
});

const u0$Compiler$TypeCheck$doDefinition$6 = (($k, $v) => {
  return null;
});

const u0$Compiler$TypeCheck$doDefinition$5 = (($state, $tyvarId) => {
  const $2 = (hash_get)($state.tyvarSubs, $tyvarId);
  return ((($2)[0] === "$Nothing")
    ? c0$Set$empty$0
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $raw = ($2)[1];
        return (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
          ctx: [],
          usr: u0$Compiler$TypeCheck$doDefinition$6,
        }), (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $raw));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 908:12', (sp_toHuman)($2))));
});

const u0$Compiler$TypeCheck$doDefinition$4 = (($entry) => {
  return $entry.maybeAnnotation;
});

const u0$Compiler$TypeCheck$doDefinition$3 = (($annotation, $acc) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $annotation.univars, $acc);
});

const u0$Compiler$TypeCheck$doDefinition$2 = (($localEnv, $annotatedId, _1, $acc) => {
  const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $annotatedId, $localEnv.annotatedUnivarsByOriginalId);
  return ((($4)[0] === "$Nothing")
    ? $acc
    : ((($4)[0] === "$Just")
      ? ((() => {
        const $newId = ($4)[1];
        return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $newId, ({
          annotatedId: $annotatedId,
        }), $acc);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 898:12', (sp_toHuman)($4))));
});

const u0$Compiler$TypeCheck$doDefinition$1 = (($state, $pars) => {
  let $parentBoundTyvars = (basics_cloneUni)($state.boundTyvars);
  const $patternOut = (u0$Compiler$TypeCheck$inferPattern$0.usr)(...(u0$Compiler$TypeCheck$inferPattern$0.ctx), $pars.env, $pars.uni, $pars.pattern, $state);
  const $localEnv = ((() => {
    const $0 = $patternOut.env;
    return (Object.assign)({}, $0, ({
      context: (u0$Compiler$TypeCheck$Context_LetInBody$0.usr)(...(u0$Compiler$TypeCheck$Context_LetInBody$0.ctx), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $patternOut.typedPattern))),
      currentLetInNames: (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $patternOut.typedPattern),
    }));
  }))();
  const $3 = ((() => {
    const $4 = $pars.maybeBody;
    return ((($4)[0] === "$Nothing")
      ? ({
        first: c0$Maybe$Nothing$0,
        second: ({
          raw: $patternOut.patternType,
          uni: $pars.uni,
        }),
      })
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $body = ($4)[1];
          const $5 = $patternOut.maybeFullAnnotation;
          return ((($5)[0] === "$Just")
            ? ((() => {
              const $annotation = ($5)[1];
              const $raw = (u0$Compiler$TypeCheck$translateAnnotationType$0.usr)(...(u0$Compiler$TypeCheck$translateAnnotationType$0.ctx), $localEnv, $state, $annotation.raw);
              const $6 = (u0$Compiler$TypeCheck$checkExpression$0.usr)(...(u0$Compiler$TypeCheck$checkExpression$0.ctx), $localEnv, ({
                annotatedPattern: $patternOut.typedPattern,
                annotation: $annotation.raw,
                expectedType: ({
                  raw: $raw,
                  uni: $pars.uni,
                }),
              }), $body, $state);
              const $exprType = $6.second;
              const $typedExpr = $6.first;
              (u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.usr)(...(u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.ctx), $state, $exprType.raw, $patternOut.patternType);
              return ({
                first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $typedExpr),
                second: $exprType,
              });
            }))()
            : ((($5)[0] === "$Nothing")
              ? ((() => {
                const $6 = (u0$Compiler$TypeCheck$inferExpression$0.usr)(...(u0$Compiler$TypeCheck$inferExpression$0.ctx), $localEnv, $body, $state);
                const $inferredType = $6.second;
                const $typed = $6.first;
                const $pos = (c0$Compiler$CanonicalAst$patternPos$0.usr)(...(c0$Compiler$CanonicalAst$patternPos$0.ctx), $pars.pattern);
                (u0$Compiler$TypeCheck$addEquality$0.usr)(...(u0$Compiler$TypeCheck$addEquality$0.ctx), $localEnv, $pos, u0$Compiler$TypeCheck$Why_LetIn$0, $patternOut.patternType, $inferredType.raw, $state);
                (u0$Compiler$TypeCheck$checkUni$0.usr)(...(u0$Compiler$TypeCheck$checkUni$0.ctx), $localEnv, $pos, ({
                  given: $inferredType.uni,
                  required: $pars.uni,
                }), $state);
                (u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.usr)(...(u0$Compiler$TypeCheck$lambdaSetsMustBeEqual$0.ctx), $state, $inferredType.raw, $patternOut.patternType);
                return ({
                  first: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $typed),
                  second: $inferredType,
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 851:16', (sp_toHuman)($5))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck.sp 845:8', (sp_toHuman)($4))));
  }))();
  const $bodyType = $3.second;
  const $typedBody = $3.first;
  const $defType = ({
    raw: (u0$Compiler$TypeCheck$applyAllSubs$0.usr)(...(u0$Compiler$TypeCheck$applyAllSubs$0.ctx), $state, $bodyType.raw),
    uni: $pars.uni,
  });
  const $freeUnivars = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$doDefinition$4,
  }), (c0$Compiler$CanonicalAst$patternNames$0.usr)(...(c0$Compiler$CanonicalAst$patternNames$0.ctx), $pars.pattern)), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$doDefinition$3,
  })), ({
    ctx: ([
      $localEnv,
    ]),
    usr: u0$Compiler$TypeCheck$doDefinition$2,
  }));
  const $freeTyvars = ((() => {
    const $allBindableTyvarsIn = ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$doDefinition$5,
    });
    const $resolvedParentBoundTyvars = (c0$Hash$for_$0.usr)(...(c0$Hash$for_$0.ctx), c0$Set$empty$0, $parentBoundTyvars, ({
      ctx: ([
        $allBindableTyvarsIn,
      ]),
      usr: u0$Compiler$TypeCheck$doDefinition$7,
    }));
    const $tyvarAnnotatedNameByTyvarId = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $localEnv.annotatedTyvarsByName, ({
      ctx: [],
      usr: u0$Compiler$TypeCheck$doDefinition$8,
    }));
    return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, (c0$Compiler$TypedAst$typeTyvars$0.usr)(...(c0$Compiler$TypedAst$typeTyvars$0.ctx), $defType.raw), ({
      ctx: ([
        $resolvedParentBoundTyvars,
        $tyvarAnnotatedNameByTyvarId,
      ]),
      usr: u0$Compiler$TypeCheck$doDefinition$9,
    }));
  }))();
  const $caNames = (c0$List$indexBy$0.usr)(...(c0$List$indexBy$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck$doDefinition$10,
  }), (c0$Compiler$CanonicalAst$patternNames$0.usr)(...(c0$Compiler$CanonicalAst$patternNames$0.ctx), $pars.pattern));
  const $instance = ({
    ctx: ([
      $caNames,
      $freeTyvars,
      $freeUnivars,
      $localEnv,
      $state,
    ]),
    usr: u0$Compiler$TypeCheck$doDefinition$11,
  });
  const $variables = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $patternOut.env.variables, (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $patternOut.typedPattern), ({
    ctx: ([
      $instance,
      $pars,
    ]),
    usr: u0$Compiler$TypeCheck$doDefinition$13,
  }));
  const $lambdaSetConstraints = (u0$Compiler$TypeCheck$getLambdaSetConstraints$0.usr)(...(u0$Compiler$TypeCheck$getLambdaSetConstraints$0.ctx), $state, $defType.raw);
  return ({
    body: $typedBody,
    env: ((() => {
      const $0 = $pars.env;
      return (Object.assign)({}, $0, ({
        variables: $variables,
      }));
    }))(),
    freeTyvars: $freeTyvars,
    freeUnivars: $freeUnivars,
    lambdaSetConstraints: $lambdaSetConstraints,
    pattern: $patternOut.typedPattern,
    type: $defType,
  });
});

const u0$Compiler$TypeCheck$doDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doDefinition$1,
});

const u0$SPLib$UnionFind$fromList$2 = (($uf, $i) => {
  return (hash_insert)($uf, $i, $i);
});

const u0$SPLib$UnionFind$fromList$1 = (($ls) => {
  let $uf = (hash_fromList)(c0$Core$Nil$0);
  (c0$List$each$0.usr)(...(c0$List$each$0.ctx), $ls, ({
    ctx: ([
      $uf,
    ]),
    usr: u0$SPLib$UnionFind$fromList$2,
  }));
  return $uf;
});

const u0$SPLib$UnionFind$fromList$0 = ({
  ctx: [],
  usr: u0$SPLib$UnionFind$fromList$1,
});

const u0$Compiler$TypeCheck$initState$1 = (($lastUnificationVarId) => {
  return ({
    boundTyvars: (hash_fromList)(c0$Core$Nil$0),
    errors: (array_fromList)(c0$Core$Nil$0),
    lambdaSetConstraints: (hash_fromList)(c0$Core$Nil$0),
    lambdaSetUnionFind: (u0$SPLib$UnionFind$fromList$0.usr)(...(u0$SPLib$UnionFind$fromList$0.ctx), c0$Core$Nil$0),
    lambdas: (hash_fromList)(c0$Core$Nil$0),
    lastLambdaRefId: ({
      n: (basics_cloneImm)(c0$Compiler$TypedAst$rootLambdaRef$0),
    }),
    lastLambdaSetId: ({
      n: 0,
    }),
    lastUnificationVarId: ({
      n: $lastUnificationVarId,
    }),
    tyvarSubs: (hash_fromList)(c0$Core$Nil$0),
    tyvarsById: (hash_fromList)(c0$Core$Nil$0),
    univarSubs: (hash_fromList)(c0$Core$Nil$0),
    univarsById: (hash_fromList)(c0$Core$Nil$0),
  });
});

const u0$Compiler$TypeCheck$initState$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$initState$1,
});

const u0$Compiler$TypeCheck$doRootDefinition$6 = (($errors, $err) => {
  return (array_push)($errors, $err);
});

const u0$Compiler$TypeCheck$doRootDefinition$5 = (($state, $univarId) => {
  return (hash_get)($state.univarSubs, $univarId);
});

const u0$Compiler$TypeCheck$doRootDefinition$4 = (($state, $tyvarId) => {
  return (hash_get)($state.tyvarSubs, $tyvarId);
});

const u0$Compiler$TypeCheck$doRootDefinition$3 = (($state, $0) => {
  return (u0$SPLib$UnionFind$find$0.usr)(...(u0$SPLib$UnionFind$find$0.ctx), $state.lambdaSetUnionFind, $0);
});

const u0$Compiler$TypeCheck$doRootDefinition$2 = (($umr, $name) => {
  return (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), $umr, $name));
});

const u0$Compiler$TypeCheck$doRootDefinition$1 = (($lastUnificationVarId, $errors, $usr, $envRaw, $def) => {
  const $env0 = ((() => {
    const $0 = $envRaw;
    return (Object.assign)({}, $0, ({
      currentRootUsr: $usr,
    }));
  }))();
  let $state = (u0$Compiler$TypeCheck$initState$0.usr)(...(u0$Compiler$TypeCheck$initState$0.ctx), (basics_cloneUni)($lastUnificationVarId.n));
  const $6 = $usr;
  const $_name = ($6)[2];
  const $umr = ($6)[1];
  const $nameToRef = ({
    ctx: ([
      $umr,
    ]),
    usr: u0$Compiler$TypeCheck$doRootDefinition$2,
  });
  const $out = (u0$Compiler$TypeCheck$doDefinition$0.usr)(...(u0$Compiler$TypeCheck$doDefinition$0.ctx), $state, ({
    directDeps: $def.directDeps,
    env: $env0,
    maybeBody: $def.maybeBody,
    nameToRef: $nameToRef,
    pattern: (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), $def.namePos, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $def.name), $def.maybeAnnotation),
    uni: c0$Compiler$Ast$Imm$0,
  }));
  const $subsAsFns = ({
    lSet: ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$doRootDefinition$3,
    }),
    ty: ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$doRootDefinition$4,
    }),
    uni: ({
      ctx: ([
        $state,
      ]),
      usr: u0$Compiler$TypeCheck$doRootDefinition$5,
    }),
  });
  const $rootDef = (c0$Compiler$TypedAst$resolveRootDef$0.usr)(...(c0$Compiler$TypedAst$resolveRootDef$0.ctx), $subsAsFns, ({
    body: $out.body,
    directDeps: $def.directDeps,
    freeTyvars: $out.freeTyvars,
    freeUnivars: $out.freeUnivars,
    lambdaSetConstraints: $out.lambdaSetConstraints,
    lambdas: (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Hash$toList$0.usr)(...(c0$Hash$toList$0.ctx), $state.lambdas)),
    name: $def.name,
    type: $out.type.raw,
  }));
  ($lastUnificationVarId.n = (basics_cloneUni)($state.lastUnificationVarId.n));
  (array_each)($state.errors, ({
    ctx: ([
      $errors,
    ]),
    usr: u0$Compiler$TypeCheck$doRootDefinition$6,
  }));
  const $0 = $out.env;
  return (Object.assign)({}, $0, ({
    reversedRootValueDefs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: $usr,
      second: $rootDef,
    }), $0.reversedRootValueDefs),
  }));
});

const u0$Compiler$TypeCheck$doRootDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$doRootDefinition$1,
});

const u0$Compiler$LazyBuild$typecheckDefinition$1 = (($state, $errors, $usr, $env0) => {
  const $5 = (hash_get)($state.done, $usr);
  return ((($5)[0] === "$Nothing")
    ? (sp_todo)(("compiler bug, missing value usr" + (sp_toHuman)($usr)))
    : ((($5)[0] === "$Just")
      ? ((() => {
        const $def = ($5)[1].def;
        const $deps = ($5)[1].deps;
        return ((($def)[0] === "$ValueDef")
          ? ((() => {
            const $valueDef = ($def)[1];
            return (u0$Compiler$TypeCheck$doRootDefinition$0.usr)(...(u0$Compiler$TypeCheck$doRootDefinition$0.ctx), $state.lastUnificationVarId, $errors, $usr, $env0, $valueDef);
          }))()
          : ((($def)[0] === "$ConstructorDef")
            ? ((() => {
              const $constructorDef = ($def)[1];
              return (u0$Compiler$TypeCheck$addConstructorToGlobalEnv$0.usr)(...(u0$Compiler$TypeCheck$addConstructorToGlobalEnv$0.ctx), $errors, $constructorDef.name, $constructorDef, $env0);
            }))()
            : (true
              ? $env0
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 155:12', (sp_toHuman)($def)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 149:4', (sp_toHuman)($5))));
});

const u0$Compiler$LazyBuild$typecheckDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$typecheckDefinition$1,
});

const u0$Compiler$MakeEmittable$generateName$1 = (($env) => {
  return ({
    first: (text_fromNumber)(($env.genVarCounter + 1)),
    second: ((() => {
      const $0 = $env;
      return (Object.assign)({}, $0, ({
        genVarCounter: (1 + $0.genVarCounter),
      }));
    }))(),
  });
});

const u0$Compiler$MakeEmittable$generateName$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$generateName$1,
});

const u0$Compiler$MakeEmittable$pickMainName$1 = (($pattern) => {
  return (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Just"))
    ? ((() => {
      const $pos = ($pattern)[1];
      const $name = (($pattern)[2].maybeName)[1];
      const $type = ($pattern)[2].type;
      return (u0$Compiler$MakeEmittable$TrivialPattern$0.usr)(...(u0$Compiler$MakeEmittable$TrivialPattern$0.ctx), $name, $type);
    }))()
    : (true
      ? ((sp_not_equal)((c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $pattern), c0$Dict$empty$0)
        ? u0$Compiler$MakeEmittable$GenerateName$0
        : u0$Compiler$MakeEmittable$NoNamedVariables$0)
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 33:4', (sp_toHuman)($pattern))));
});

const u0$Compiler$MakeEmittable$pickMainName$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$pickMainName$1,
});

const u0$Compiler$MakeEmittable$testPattern$3 = (($valueToTest, $index, $argPattern, $a) => {
  return (u0$Compiler$MakeEmittable$testPattern$0.usr)(...(u0$Compiler$MakeEmittable$testPattern$0.ctx), $argPattern, (c0$Compiler$EmittableAst$ConstructorAccess$0.usr)(...(c0$Compiler$EmittableAst$ConstructorAccess$0.ctx), $index, $valueToTest), $a);
});

const u0$Compiler$MakeEmittable$testPattern$2 = (($valueToTest, $name, $2, $a) => {
  const $pa = $2.first;
  const $type = $2.second;
  return (u0$Compiler$MakeEmittable$testPattern$0.usr)(...(u0$Compiler$MakeEmittable$testPattern$0.ctx), $pa, (c0$Compiler$EmittableAst$RecordAccess$0.usr)(...(c0$Compiler$EmittableAst$RecordAccess$0.ctx), $name, $valueToTest), $a);
});

const u0$Compiler$MakeEmittable$testPattern$1 = (($pattern, $valueToTest, $accum) => {
  return ((($pattern)[0] === "$PatternAny")
    ? $accum
    : ((($pattern)[0] === "$PatternLiteralText")
      ? ((() => {
        const $text = ($pattern)[2];
        return (sp_cons)((c0$Compiler$EmittableAst$IsLiteralText$0.usr)(...(c0$Compiler$EmittableAst$IsLiteralText$0.ctx), $text, $valueToTest), $accum);
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? ((() => {
          const $num = ($pattern)[2];
          return (sp_cons)((c0$Compiler$EmittableAst$IsLiteralNumber$0.usr)(...(c0$Compiler$EmittableAst$IsLiteralNumber$0.ctx), $num, $valueToTest), $accum);
        }))()
        : ((($pattern)[0] === "$PatternConstructor")
          ? ((() => {
            const $usr = ($pattern)[2];
            const $pas = ($pattern)[3];
            return (c0$List$indexedFor$0.usr)(...(c0$List$indexedFor$0.ctx), (sp_cons)((c0$Compiler$EmittableAst$IsConstructor$0.usr)(...(c0$Compiler$EmittableAst$IsConstructor$0.ctx), $usr, $valueToTest), $accum), $pas, ({
              ctx: ([
                $valueToTest,
              ]),
              usr: u0$Compiler$MakeEmittable$testPattern$3,
            }));
          }))()
          : ((($pattern)[0] === "$PatternRecord")
            ? ((() => {
              const $attrs = ($pattern)[2];
              return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $accum, $attrs, ({
                ctx: ([
                  $valueToTest,
                ]),
                usr: u0$Compiler$MakeEmittable$testPattern$2,
              }));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 84:4', (sp_toHuman)($pattern)))))));
});

const u0$Compiler$MakeEmittable$testPattern$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$testPattern$1,
});

const u0$Compiler$MakeEmittable$translateArgAndType$1 = (($env, $state, $taArg) => {
  return ((($taArg)[0] === "$ArgumentExpression")
    ? ((() => {
      const $fullType = ($taArg)[1];
      const $exp = ($taArg)[2];
      return (c0$Compiler$EmittableAst$ArgumentSpend$0.usr)(...(c0$Compiler$EmittableAst$ArgumentSpend$0.ctx), $fullType, (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $exp));
    }))()
    : ((($taArg)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $pos = ($taArg)[1];
        const $rawType = ($taArg)[2];
        const $attrPath = ($taArg)[3];
        const $name = ($taArg)[4];
        return (c0$Compiler$EmittableAst$ArgumentRecycle$0.usr)(...(c0$Compiler$EmittableAst$ArgumentRecycle$0.ctx), $rawType, $attrPath, $name);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 147:4', (sp_toHuman)($taArg))));
});

const u0$Compiler$MakeEmittable$translateArgAndType$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$translateArgAndType$1,
});

const u0$Compiler$MakeEmittable$translatePatternRec$3 = (($accessExpr, $index, $pa, $a) => {
  return (u0$Compiler$MakeEmittable$translatePatternRec$0.usr)(...(u0$Compiler$MakeEmittable$translatePatternRec$0.ctx), $pa, (c0$Compiler$EmittableAst$ConstructorAccess$0.usr)(...(c0$Compiler$EmittableAst$ConstructorAccess$0.ctx), $index, $accessExpr), $a);
});

const u0$Compiler$MakeEmittable$translatePatternRec$2 = (($accessExpr, $name, $2, $a) => {
  const $pa = $2.first;
  const $type = $2.second;
  return (u0$Compiler$MakeEmittable$translatePatternRec$0.usr)(...(u0$Compiler$MakeEmittable$translatePatternRec$0.ctx), $pa, (c0$Compiler$EmittableAst$RecordAccess$0.usr)(...(c0$Compiler$EmittableAst$RecordAccess$0.ctx), $name, $accessExpr), $a);
});

const u0$Compiler$MakeEmittable$translatePatternRec$1 = (($pattern, $accessExpr, $accum) => {
  return (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Nothing"))
    ? ((() => {
      const $type = ($pattern)[2].type;
      return $accum;
    }))()
    : (((($pattern)[0] === "$PatternAny") && ((($pattern)[2].maybeName)[0] === "$Just"))
      ? ((() => {
        const $name = (($pattern)[2].maybeName)[1];
        const $type = ($pattern)[2].type;
        return (sp_cons)(({
          first: $type,
          second: $name,
          third: $accessExpr,
        }), $accum);
      }))()
      : ((($pattern)[0] === "$PatternLiteralNumber")
        ? $accum
        : ((($pattern)[0] === "$PatternLiteralText")
          ? $accum
          : ((($pattern)[0] === "$PatternConstructor")
            ? ((() => {
              const $path = ($pattern)[2];
              const $pas = ($pattern)[3];
              return (c0$List$indexedFor$0.usr)(...(c0$List$indexedFor$0.ctx), $accum, $pas, ({
                ctx: ([
                  $accessExpr,
                ]),
                usr: u0$Compiler$MakeEmittable$translatePatternRec$3,
              }));
            }))()
            : ((($pattern)[0] === "$PatternRecord")
              ? ((() => {
                const $attrs = ($pattern)[2];
                return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $accum, $attrs, ({
                  ctx: ([
                    $accessExpr,
                  ]),
                  usr: u0$Compiler$MakeEmittable$translatePatternRec$2,
                }));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 57:4', (sp_toHuman)($pattern))))))));
});

const u0$Compiler$MakeEmittable$translatePatternRec$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$translatePatternRec$1,
});

const u0$Compiler$MakeEmittable$translatePattern$1 = (($pattern, $accessExpr) => {
  return (u0$Compiler$MakeEmittable$translatePatternRec$0.usr)(...(u0$Compiler$MakeEmittable$translatePatternRec$0.ctx), $pattern, $accessExpr, c0$Core$Nil$0);
});

const u0$Compiler$MakeEmittable$translatePattern$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$translatePattern$1,
});

const u0$Compiler$MakeEmittable$translateExpression$10 = (($env, $state, $0) => {
  return (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $0);
});

const u0$Compiler$MakeEmittable$translateExpression$9 = (($env, $state, $0) => {
  return (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $0);
});

const u0$Compiler$MakeEmittable$translateExpression$8 = (($env, $state, $0) => {
  return (c0$Tuple$mapSecond$0.usr)(...(c0$Tuple$mapSecond$0.ctx), ({
    ctx: ([
      $env,
      $state,
    ]),
    usr: u0$Compiler$MakeEmittable$translateExpression$9,
  }), $0);
});

const u0$Compiler$MakeEmittable$translateExpression$7 = (($env, $state, $0) => {
  return (u0$Compiler$MakeEmittable$translateArgAndType$0.usr)(...(u0$Compiler$MakeEmittable$translateArgAndType$0.ctx), $env, $state, $0);
});

const u0$Compiler$MakeEmittable$translateExpression$6 = (($2, $inExpression) => {
  const $type = $2.first;
  const $name = $2.second;
  const $letExpression = $2.third;
  return (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
    inExpression: $inExpression,
    letExpression: $letExpression,
    maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name),
    type: $type,
  }));
});

const u0$Compiler$MakeEmittable$translateExpression$5 = (($newEnv, $state, $valueExpression, $2, $nextTryExpression) => {
  const $pattern = $2.first;
  const $block = $2.second;
  const $testIfPatternMatches = (c0$Compiler$EmittableAst$And$0.usr)(...(c0$Compiler$EmittableAst$And$0.ctx), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), (u0$Compiler$MakeEmittable$testPattern$0.usr)(...(u0$Compiler$MakeEmittable$testPattern$0.ctx), $pattern, $valueExpression, c0$Core$Nil$0)));
  const $namesAndExpressions = (u0$Compiler$MakeEmittable$translatePattern$0.usr)(...(u0$Compiler$MakeEmittable$translatePattern$0.ctx), $pattern, $valueExpression);
  const $whenConditionMatches = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $newEnv, $state, $block), $namesAndExpressions, ({
    ctx: [],
    usr: u0$Compiler$MakeEmittable$translateExpression$6,
  }));
  return (c0$Compiler$EmittableAst$Conditional$0.usr)(...(c0$Compiler$EmittableAst$Conditional$0.ctx), $testIfPatternMatches, $whenConditionMatches, $nextTryExpression);
});

const u0$Compiler$MakeEmittable$translateExpression$4 = (($env_, $state, $tryName, $value, $valueType, $tryExpression) => {
  return (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
    inExpression: $tryExpression,
    letExpression: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env_, $state, $value),
    maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $tryName),
    type: $valueType,
  }));
});

const u0$Compiler$MakeEmittable$translateExpression$3 = (($mainName, $newEnv, $state, $valueDef, $inExpression) => {
  return (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
    inExpression: $inExpression,
    letExpression: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $newEnv, $state, $valueDef.body),
    maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $mainName),
    type: $valueDef.type,
  }));
});

const u0$Compiler$MakeEmittable$translateExpression$2 = (($2, $inExpression) => {
  const $type = $2.first;
  const $name = $2.second;
  const $letExpression = $2.third;
  return (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
    inExpression: $inExpression,
    letExpression: $letExpression,
    maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name),
    type: $type,
  }));
});

const u0$Compiler$MakeEmittable$translateExpression$1 = (($env, $state, $expression) => {
  return ((($expression)[0] === "$LiteralNumber")
    ? ((() => {
      const $num = ($expression)[2];
      return (c0$Compiler$EmittableAst$LiteralNumber$0.usr)(...(c0$Compiler$EmittableAst$LiteralNumber$0.ctx), $num);
    }))()
    : ((($expression)[0] === "$LiteralText")
      ? ((() => {
        const $text = ($expression)[2];
        return (c0$Compiler$EmittableAst$LiteralText$0.usr)(...(c0$Compiler$EmittableAst$LiteralText$0.ctx), $text);
      }))()
      : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefLocal"))
        ? ((() => {
          const $name = (($expression)[2])[1];
          return (c0$Compiler$EmittableAst$LocalVariable$0.usr)(...(c0$Compiler$EmittableAst$LocalVariable$0.ctx), $name);
        }))()
        : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
          ? ((() => {
            const $usr = (($expression)[2])[1];
            return (c0$Compiler$EmittableAst$GlobalVariable$0.usr)(...(c0$Compiler$EmittableAst$GlobalVariable$0.ctx), (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, c0$Compiler$TypedAst$rootLambdaRef$0));
          }))()
          : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefPlaceholder"))
            ? ((() => {
              const $n = (($expression)[2])[1];
              return (c0$Compiler$EmittableAst$PlaceholderVariable$0.usr)(...(c0$Compiler$EmittableAst$PlaceholderVariable$0.ctx), $n);
            }))()
            : ((($expression)[0] === "$Lambda")
              ? ((() => {
                const $pars = ($expression)[2];
                const $4 = $pars.ref;
                const $id = $4.second;
                const $usr = $4.first;
                const $tUsr = (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, $id);
                (hash_insert)($state.lambdaContextes, $tUsr, $pars.context);
                return (c0$Compiler$EmittableAst$Lambda$0.usr)(...(c0$Compiler$EmittableAst$Lambda$0.ctx), $tUsr, $pars.context);
              }))()
              : ((($expression)[0] === "$Constructor")
                ? ((() => {
                  const $usr = ($expression)[2];
                  return (c0$Compiler$EmittableAst$Constructor$0.usr)(...(c0$Compiler$EmittableAst$Constructor$0.ctx), (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, 0));
                }))()
                : ((($expression)[0] === "$RecordAccess")
                  ? ((() => {
                    const $attrName = ($expression)[2];
                    const $exp = ($expression)[3];
                    return (c0$Compiler$EmittableAst$RecordAccess$0.usr)(...(c0$Compiler$EmittableAst$RecordAccess$0.ctx), $attrName, (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $exp));
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $extends = ($expression)[2];
                      const $attrs = ($expression)[3];
                      return (c0$Compiler$EmittableAst$LiteralRecord$0.usr)(...(c0$Compiler$EmittableAst$LiteralRecord$0.ctx), (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), ({
                        ctx: ([
                          $env,
                          $state,
                        ]),
                        usr: u0$Compiler$MakeEmittable$translateExpression$10,
                      }), $extends), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                        ctx: ([
                          $env,
                          $state,
                        ]),
                        usr: u0$Compiler$MakeEmittable$translateExpression$8,
                      }), (list_sortBy)(c0$Tuple$first$0, (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $attrs))));
                    }))()
                    : ((($expression)[0] === "$Call")
                      ? ((() => {
                        const $ref = ($expression)[3];
                        const $argsAndTypes = ($expression)[4];
                        return (c0$Compiler$EmittableAst$Call$0.usr)(...(c0$Compiler$EmittableAst$Call$0.ctx), (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $ref), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                          ctx: ([
                            $env,
                            $state,
                          ]),
                          usr: u0$Compiler$MakeEmittable$translateExpression$7,
                        }), $argsAndTypes));
                      }))()
                      : ((($expression)[0] === "$If")
                        ? ((() => {
                          const $ar = ($expression)[2];
                          return (c0$Compiler$EmittableAst$Conditional$0.usr)(...(c0$Compiler$EmittableAst$Conditional$0.ctx), (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $ar.condition), (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $ar.true), (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $ar.false));
                        }))()
                        : ((($expression)[0] === "$Try")
                          ? ((() => {
                            const $pos = ($expression)[1];
                            const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                            const $value = ($expression)[2].value;
                            const $valueType = ($expression)[2].valueType;
                            const $4 = ((() => {
                              const $5 = ({
                                first: $value,
                                second: $valueType.uni,
                              });
                              return (((($5.first)[0] === "$Variable") && (((($5.first)[2])[0] === "$RefLocal") && (($5.second)[0] === "$Imm")))
                                ? ((() => {
                                  const $name = (($5.first)[2])[1];
                                  return ({
                                    first: (c0$Compiler$EmittableAst$LocalVariable$0.usr)(...(c0$Compiler$EmittableAst$LocalVariable$0.ctx), $name),
                                    second: c0$Basics$identity$0,
                                    third: $env,
                                  });
                                }))()
                                : (((($5.first)[0] === "$Variable") && (((($5.first)[2])[0] === "$RefGlobal") && (($5.second)[0] === "$Imm")))
                                  ? ((() => {
                                    const $usr = (($5.first)[2])[1];
                                    return ({
                                      first: (c0$Compiler$EmittableAst$GlobalVariable$0.usr)(...(c0$Compiler$EmittableAst$GlobalVariable$0.ctx), (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, 0)),
                                      second: c0$Basics$identity$0,
                                      third: $env,
                                    });
                                  }))()
                                  : (((($5.first)[0] === "$Variable") && (((($5.first)[2])[0] === "$RefPlaceholder") && (($5.second)[0] === "$Imm")))
                                    ? ((() => {
                                      const $n = (($5.first)[2])[1];
                                      return ({
                                        first: (c0$Compiler$EmittableAst$PlaceholderVariable$0.usr)(...(c0$Compiler$EmittableAst$PlaceholderVariable$0.ctx), $n),
                                        second: c0$Basics$identity$0,
                                        third: $env,
                                      });
                                    }))()
                                    : (true
                                      ? ((() => {
                                        const $6 = (u0$Compiler$MakeEmittable$generateName$0.usr)(...(u0$Compiler$MakeEmittable$generateName$0.ctx), $env);
                                        const $env_ = $6.second;
                                        const $tryName = $6.first;
                                        const $wrap = ({
                                          ctx: ([
                                            $env_,
                                            $state,
                                            $tryName,
                                            $value,
                                            $valueType,
                                          ]),
                                          usr: u0$Compiler$MakeEmittable$translateExpression$4,
                                        });
                                        return ({
                                          first: (c0$Compiler$EmittableAst$LocalVariable$0.usr)(...(c0$Compiler$EmittableAst$LocalVariable$0.ctx), $tryName),
                                          second: $wrap,
                                          third: $env_,
                                        });
                                      }))()
                                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 221:16', (sp_toHuman)($5))))));
                            }))();
                            const $newEnv = $4.third;
                            const $wrapWithLetIn = $4.second;
                            const $valueExpression = $4.first;
                            const $addTryPatternAndBlock = ({
                              ctx: ([
                                $newEnv,
                                $state,
                                $valueExpression,
                              ]),
                              usr: u0$Compiler$MakeEmittable$translateExpression$5,
                            });
                            const $default = ((() => {
                              const $human = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), ({
                                content: $env.module.asText,
                                fsPath: $env.module.fsPath,
                              }), $pos);
                              return (c0$Compiler$EmittableAst$MissingPattern$0.usr)(...(c0$Compiler$EmittableAst$MissingPattern$0.ctx), $human.location, $valueExpression);
                            }))();
                            return ($wrapWithLetIn.usr)(...($wrapWithLetIn.ctx), (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), $default, $patternsAndExpressions, $addTryPatternAndBlock));
                          }))()
                          : ((($expression)[0] === "$LetIn")
                            ? ((() => {
                              const $valueDef = ($expression)[1];
                              const $e = ($expression)[2];
                              const $bodyType = ($expression)[3];
                              const $env1 = ((() => {
                                const $0 = $env;
                                return (Object.assign)({}, $0, ({
                                  currentLetInNames: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $valueDef.pattern), $0.currentLetInNames),
                                }));
                              }))();
                              const $4 = (u0$Compiler$MakeEmittable$pickMainName$0.usr)(...(u0$Compiler$MakeEmittable$pickMainName$0.ctx), $valueDef.pattern);
                              return ((($4)[0] === "$NoNamedVariables")
                                ? (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
                                  inExpression: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env1, $state, $e),
                                  letExpression: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env1, $state, $valueDef.body),
                                  maybeName: c0$Maybe$Nothing$0,
                                  type: $valueDef.type,
                                }))
                                : ((($4)[0] === "$TrivialPattern")
                                  ? ((() => {
                                    const $defName = ($4)[1];
                                    const $type = ($4)[2];
                                    return (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
                                      inExpression: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env1, $state, $e),
                                      letExpression: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env1, $state, $valueDef.body),
                                      maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $defName),
                                      type: $type,
                                    }));
                                  }))()
                                  : ((($4)[0] === "$GenerateName")
                                    ? ((() => {
                                      const $5 = (u0$Compiler$MakeEmittable$generateName$0.usr)(...(u0$Compiler$MakeEmittable$generateName$0.ctx), $env1);
                                      const $newEnv = $5.second;
                                      const $mainName = $5.first;
                                      const $namesAndExpressions = (u0$Compiler$MakeEmittable$translatePattern$0.usr)(...(u0$Compiler$MakeEmittable$translatePattern$0.ctx), $valueDef.pattern, (c0$Compiler$EmittableAst$LocalVariable$0.usr)(...(c0$Compiler$EmittableAst$LocalVariable$0.ctx), $mainName));
                                      const $wrapWithUnpackedPatternVar = ({
                                        ctx: [],
                                        usr: u0$Compiler$MakeEmittable$translateExpression$2,
                                      });
                                      const $wrapWithActualLetIn = ({
                                        ctx: ([
                                          $mainName,
                                          $newEnv,
                                          $state,
                                          $valueDef,
                                        ]),
                                        usr: u0$Compiler$MakeEmittable$translateExpression$3,
                                      });
                                      return ($wrapWithActualLetIn.usr)(...($wrapWithActualLetIn.ctx), (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $newEnv, $state, $e), $namesAndExpressions, $wrapWithUnpackedPatternVar));
                                    }))()
                                    : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 280:12', (sp_toHuman)($4)))));
                            }))()
                            : ((($expression)[0] === "$DestroyIn")
                              ? ((() => {
                                const $name = ($expression)[1];
                                const $e = ($expression)[2];
                                return (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $e);
                              }))()
                              : ((($expression)[0] === "$Introspect")
                                ? ((() => {
                                  const $self = ($expression)[1];
                                  return (c0$Compiler$EmittableAst$Introspect$0.usr)(...(c0$Compiler$EmittableAst$Introspect$0.ctx), $self);
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 154:4', (sp_toHuman)($expression)))))))))))))))));
});

const u0$Compiler$MakeEmittable$translateExpression$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$translateExpression$1,
});

const u0$Compiler$MakeEmittable$translateParameter$2 = (($2, $inExpression) => {
  const $type = $2.first;
  const $varName = $2.second;
  const $letExpression = $2.third;
  return (c0$Compiler$EmittableAst$LetIn$0.usr)(...(c0$Compiler$EmittableAst$LetIn$0.ctx), ({
    inExpression: $inExpression,
    letExpression: $letExpression,
    maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $varName),
    type: $type,
  }));
});

const u0$Compiler$MakeEmittable$translateParameter$1 = (($env, $bodyAcc, $param) => {
  return ((($param)[0] === "$ParameterRecycle")
    ? ((() => {
      const $pos = ($param)[1];
      const $raw = ($param)[2];
      const $name = ($param)[3];
      return ({
        first: $bodyAcc,
        second: ({
          first: ({
            raw: $raw,
            uni: c0$Compiler$Ast$Uni$0,
          }),
          second: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name),
        }),
      });
    }))()
    : ((($param)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $fullType = ($param)[1];
        const $n = ($param)[2];
        return ({
          first: $bodyAcc,
          second: ({
            first: $fullType,
            second: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (text_fromNumber)($n)),
          }),
        });
      }))()
      : ((($param)[0] === "$ParameterPattern")
        ? ((() => {
          const $fullType = ($param)[1];
          const $pa = ($param)[2];
          const $4 = (u0$Compiler$MakeEmittable$pickMainName$0.usr)(...(u0$Compiler$MakeEmittable$pickMainName$0.ctx), $pa);
          return ((($4)[0] === "$NoNamedVariables")
            ? ({
              first: $bodyAcc,
              second: ({
                first: $fullType,
                second: c0$Maybe$Nothing$0,
              }),
            })
            : ((($4)[0] === "$TrivialPattern")
              ? ((() => {
                const $argName = ($4)[1];
                const $type = ($4)[2];
                return ({
                  first: $bodyAcc,
                  second: ({
                    first: $fullType,
                    second: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $argName),
                  }),
                });
              }))()
              : ((($4)[0] === "$GenerateName")
                ? ((() => {
                  const $5 = (u0$Compiler$MakeEmittable$generateName$0.usr)(...(u0$Compiler$MakeEmittable$generateName$0.ctx), $env);
                  const $newEnv = $5.second;
                  const $mainName = $5.first;
                  const $namesAndExpressions = (u0$Compiler$MakeEmittable$translatePattern$0.usr)(...(u0$Compiler$MakeEmittable$translatePattern$0.ctx), $pa, (c0$Compiler$EmittableAst$LocalVariable$0.usr)(...(c0$Compiler$EmittableAst$LocalVariable$0.ctx), $mainName));
                  const $wrapWithArgumentLetIn = ({
                    ctx: [],
                    usr: u0$Compiler$MakeEmittable$translateParameter$2,
                  });
                  return ({
                    first: (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $bodyAcc, $namesAndExpressions, $wrapWithArgumentLetIn),
                    second: ({
                      first: $fullType,
                      second: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $mainName),
                    }),
                  });
                }))()
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 117:12', (sp_toHuman)($4)))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 108:4', (sp_toHuman)($param)))));
});

const u0$Compiler$MakeEmittable$translateParameter$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$translateParameter$1,
});

const u0$Compiler$MakeEmittable$translateRootDef$3 = (($env, $taPar, $1) => {
  const $bodyAcc = $1.first;
  const $eaParsAcc = $1.second;
  const $3 = (u0$Compiler$MakeEmittable$translateParameter$0.usr)(...(u0$Compiler$MakeEmittable$translateParameter$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      genVarCounter: ((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $eaParsAcc) + $0.genVarCounter),
    }));
  }))(), $bodyAcc, $taPar);
  const $eaPar = $3.second;
  const $bodyX = $3.first;
  return ({
    first: $bodyX,
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $eaPar, $eaParsAcc),
  });
});

const u0$Compiler$MakeEmittable$translateRootDef$2 = (($def, $env, $state, $usr, $index, $lambda, $defs) => {
  const $baseBody = (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      genVarCounter: ((c0$List$length$0.usr)(...(c0$List$length$0.ctx), $lambda.pars) + $0.genVarCounter),
    }));
  }))(), $state, $lambda.body);
  const $4 = (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), ({
    first: $baseBody,
    second: c0$Core$Nil$0,
  }), $lambda.pars, ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$MakeEmittable$translateRootDef$3,
  }));
  const $parameters = $4.second;
  const $wrappedBody = $4.first;
  const $tUsr = (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, $index);
  const $context = ((() => {
    const $5 = (hash_get)($state.lambdaContextes, $tUsr);
    return ((($5)[0] === "$Nothing")
      ? (sp_todo)("Missing lambda context")
      : ((($5)[0] === "$Just")
        ? ((() => {
          const $c = ($5)[1];
          return $c;
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 394:20', (sp_toHuman)($5))));
  }))();
  const $eaDef = ({
    context: $context,
    deps: c0$Dict$empty$0,
    expr: $wrappedBody,
    freeTyvars: $def.freeTyvars,
    freeUnivars: $def.freeUnivars,
    lambdaSetConstraints: $def.lambdaSetConstraints,
    parameters: $parameters,
    returnType: $lambda.returnType,
    usr: $tUsr,
  });
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $eaDef, $defs);
});

const u0$Compiler$MakeEmittable$translateRootDef$1 = (($modulesByUmr, $usr, $def) => {
  const $4 = $def.body;
  return ((($4)[0] === "$Nothing")
    ? c0$Core$Nil$0
    : ((($4)[0] === "$Just")
      ? ((() => {
        const $body = ($4)[1];
        const $5 = $usr;
        const $name = ($5)[2];
        const $umr = ($5)[1];
        const $env = ({
          currentLetInNames: c0$Dict$empty$0,
          genVarCounter: 0,
          module: ((() => {
            const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $modulesByUmr);
            return ((($6)[0] === "$Just")
              ? ((() => {
                const $m = ($6)[1];
                return $m;
              }))()
              : ((($6)[0] === "$Nothing")
                ? (sp_todo)(("compiler bug: no module for " + $name))
                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 355:20', (sp_toHuman)($6))));
          }))(),
        });
        let $state = ({
          lambdaContextes: (hash_fromList)(c0$Core$Nil$0),
        });
        const $valueDef = ({
          context: c0$Dict$empty$0,
          deps: $def.directDeps,
          expr: (u0$Compiler$MakeEmittable$translateExpression$0.usr)(...(u0$Compiler$MakeEmittable$translateExpression$0.ctx), $env, $state, $body),
          freeTyvars: $def.freeTyvars,
          freeUnivars: $def.freeUnivars,
          lambdaSetConstraints: $def.lambdaSetConstraints,
          parameters: c0$Core$Nil$0,
          returnType: ({
            raw: $def.type,
            uni: c0$Compiler$Ast$Imm$0,
          }),
          usr: (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, c0$Compiler$TypedAst$rootLambdaRef$0),
        });
        return (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $valueDef, c0$Core$Nil$0), $def.lambdas, ({
          ctx: ([
            $def,
            $env,
            $state,
            $usr,
          ]),
          usr: u0$Compiler$MakeEmittable$translateRootDef$2,
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeEmittable.sp 341:4', (sp_toHuman)($4))));
});

const u0$Compiler$MakeEmittable$translateRootDef$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeEmittable$translateRootDef$1,
});

const u0$Compiler$TypeCheck$initEnv$1 = (($projectImports, $modulesByUmr) => {
  return ({
    annotatedTyvarsByName: c0$Dict$empty$0,
    annotatedUnivarsByOriginalId: c0$Dict$empty$0,
    constructors: c0$Dict$empty$0,
    context: u0$Compiler$TypeCheck$Context_Global$0,
    currentLetInNames: c0$Dict$empty$0,
    currentRootUsr: (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "error"),
    exactTypes: c0$Dict$empty$0,
    expandedAliases: c0$Dict$empty$0,
    modulesByUmr: $modulesByUmr,
    projectImports: $projectImports,
    reversedRootValueDefs: c0$Core$Nil$0,
    variables: c0$Dict$empty$0,
  });
});

const u0$Compiler$TypeCheck$initEnv$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck$initEnv$1,
});

const u0$Compiler$UniquenessCheck$addPatternToEnv$4 = (($n, $s) => {
  return $s.pos;
});

const u0$Compiler$UniquenessCheck$addPatternToEnv$3 = (($n, $s) => {
  return (sp_not_equal)($s.type.uni, c0$Compiler$Ast$Imm$0);
});

const u0$Compiler$UniquenessCheck$addPatternToEnv$2 = (($name, $2, $z) => {
  const $pos = $2.pos;
  const $type = $2.type;
  const $mode = ((sp_equal)($type.uni, c0$Compiler$Ast$Imm$0)
    ? u0$Compiler$UniquenessCheck$Immutable$0
    : (u0$Compiler$UniquenessCheck$Unique$0.usr)(...(u0$Compiler$UniquenessCheck$Unique$0.ctx), u0$Compiler$UniquenessCheck$Available$0));
  const $variable = ({
    definedAt: $pos,
    mode: $mode,
    name: $name,
    required: c0$Dict$empty$0,
    type: $type,
  });
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $variable, $z);
});

const u0$Compiler$UniquenessCheck$addPatternToEnv$1 = (($state, $pattern, $env) => {
  const $names = (c0$Compiler$TypedAst$patternNames$0.usr)(...(c0$Compiler$TypedAst$patternNames$0.ctx), $pattern);
  const $insertVariable = ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$addPatternToEnv$2,
  });
  const $localEnv = ((() => {
    const $0 = $env;
    return (Object.assign)({}, $0, ({
      variables: (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $0.variables, $names, $insertVariable),
    }));
  }))();
  const $uniques = (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$addPatternToEnv$4,
  }), (c0$Dict$filter$0.usr)(...(c0$Dict$filter$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$addPatternToEnv$3,
  }), $names));
  return ({
    first: (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $names),
    second: $uniques,
    third: $localEnv,
  });
});

const u0$Compiler$UniquenessCheck$addPatternToEnv$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$addPatternToEnv$1,
});

const u0$Compiler$UniquenessCheck$consumeInEnv$2 = (($spent, $name, $variable) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $spent);
  return ((($3)[0] === "$Nothing")
    ? $variable
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $pos = ($3)[1];
        const $0 = $variable;
        return (Object.assign)({}, $0, ({
          mode: (u0$Compiler$UniquenessCheck$Unique$0.usr)(...(u0$Compiler$UniquenessCheck$Unique$0.ctx), (u0$Compiler$UniquenessCheck$ConsumedAt$0.usr)(...(u0$Compiler$UniquenessCheck$ConsumedAt$0.ctx), $pos)),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 292:12', (sp_toHuman)($3))));
});

const u0$Compiler$UniquenessCheck$consumeInEnv$1 = (($spent, $env) => {
  const $translate = ({
    ctx: ([
      $spent,
    ]),
    usr: u0$Compiler$UniquenessCheck$consumeInEnv$2,
  });
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), $translate, $0.variables),
  }));
});

const u0$Compiler$UniquenessCheck$consumeInEnv$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$consumeInEnv$1,
});

const u0$Compiler$UniquenessCheck$getErrorModule$1 = (($env) => {
  const $2 = $env.usr;
  const $umr = ($2)[1];
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $umr, $env.modulesByUmr);
  return ((($3)[0] === "$Nothing")
    ? ({
      content: "",
      fsPath: "N/A",
    })
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $content = ($3)[1].asText;
        const $fsPath = ($3)[1].fsPath;
        return ({
          content: $content,
          fsPath: $fsPath,
        });
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 50:4', (sp_toHuman)($3))));
});

const u0$Compiler$UniquenessCheck$getErrorModule$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$getErrorModule$1,
});

const u0$Compiler$UniquenessCheck$addError$1 = (($env, $pos, $state, $messageConstructor) => {
  return (array_push)($state.errors, (u0$Compiler$Error$Simple$0.usr)(...(u0$Compiler$Error$Simple$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $pos, $messageConstructor));
});

const u0$Compiler$UniquenessCheck$addError$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$addError$1,
});

const u0$Compiler$UniquenessCheck$errorMutatingAConsumed$1 = (($env, $name, $p2, $p1, $state) => {
  const $6 = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $p2);
  const $location = $6.location;
  const $block = $6.block;
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $p1, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (((("This code spends the unique variable `" + $name) + "`, but `") + $name) + "` is being used again here:"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $block, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "If you want to use a unique more than once, you need to use a function that recycles it.", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO: link to uniqueness wiki page", c0$Core$Nil$0)))))));
});

const u0$Compiler$UniquenessCheck$errorMutatingAConsumed$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorMutatingAConsumed$1,
});

const u0$Compiler$UniquenessCheck$errorMutatingAnImmutable$1 = (($env, $name, $p, $state) => {
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $p, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($name + " is immutable, but you are trying to mutate it"), c0$Core$Nil$0));
});

const u0$Compiler$UniquenessCheck$errorMutatingAnImmutable$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorMutatingAnImmutable$1,
});

const u0$Compiler$UniquenessCheck$errorMutatingTwice$1 = (($env, $name, $p1, $p2, $state) => {
  const $6 = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $p2);
  const $location = $6.location;
  const $block = $6.block;
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $p1, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($name + " is already being mutated here: "), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $block, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "You can't use the same unique twice in the same function call", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO: link to wiki explaining why", c0$Core$Nil$0)))));
});

const u0$Compiler$UniquenessCheck$errorMutatingTwice$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorMutatingTwice$1,
});

const u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$1 = (($env, $name, $pos, $consumedPos, $state) => {
  const $6 = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $pos);
  const $location = $6.location;
  const $block = $6.block;
  const $cons = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $consumedPos);
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $pos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("You can't reference again the variable `" + $name) + "` because it was used already here:"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $cons.block, c0$Core$Nil$0)));
});

const u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$1,
});

const u0$Compiler$UniquenessCheck$errorUndefinedVariable$1 = (($env, $p, $name, $state) => {
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $p, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("undefined variable: " + $name), c0$Core$Nil$0));
});

const u0$Compiler$UniquenessCheck$errorUndefinedVariable$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorUndefinedVariable$1,
});

const u0$Compiler$UniquenessCheck$doArgument$2 = (($doneSoFar, $env, $state, $name, $p1) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $doneSoFar.spent);
  return ((($3)[0] === "$Nothing")
    ? null
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $p2 = ($3)[1];
        return (u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0.usr)(...(u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0.ctx), $env, $name, $p1, $p2, $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 399:16', (sp_toHuman)($3))));
});

const u0$Compiler$UniquenessCheck$doArgument$1 = (($env, $state, $pos, $doneSoFar) => {
  const $5 = $doneSoFar.resolved;
  return ((($5)[0] === "$ArgumentExpression")
    ? ((() => {
      const $fullType = ($5)[1];
      const $expr = ($5)[2];
      const $doneExpression = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $expr);
      (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $doneExpression.spent, ({
        ctx: ([
          $doneSoFar,
          $env,
          $state,
        ]),
        usr: u0$Compiler$UniquenessCheck$doArgument$2,
      }));
      return ({
        recycled: $doneSoFar.recycled,
        required: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneExpression.required, $doneSoFar.required),
        resolved: (c0$Compiler$TypedAst$ArgumentExpression$0.usr)(...(c0$Compiler$TypedAst$ArgumentExpression$0.ctx), $fullType, $doneExpression.resolved),
        spent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneExpression.spent, $doneSoFar.spent),
      });
    }))()
    : ((($5)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $p1 = ($5)[1];
        const $rawType = ($5)[2];
        const $attrPath = ($5)[3];
        const $name = ($5)[4];
        const $x = ((() => {
          const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $env.variables);
          return ((($6)[0] === "$Nothing")
            ? (u0$Compiler$UniquenessCheck$errorUndefinedVariable$0.usr)(...(u0$Compiler$UniquenessCheck$errorUndefinedVariable$0.ctx), $env, $p1, $name, $state)
            : ((($6)[0] === "$Just")
              ? ((() => {
                const $variable = ($6)[1];
                const $7 = $variable.mode;
                return (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$Available"))
                  ? null
                  : ((($7)[0] === "$Immutable")
                    ? (u0$Compiler$UniquenessCheck$errorMutatingAnImmutable$0.usr)(...(u0$Compiler$UniquenessCheck$errorMutatingAnImmutable$0.ctx), $env, $name, $p1, $state)
                    : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$ConsumedAt"))
                      ? ((() => {
                        const $p2 = (($7)[1])[1];
                        return (u0$Compiler$UniquenessCheck$errorMutatingAConsumed$0.usr)(...(u0$Compiler$UniquenessCheck$errorMutatingAConsumed$0.ctx), $env, $name, $p1, $p2, $state);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 422:24', (sp_toHuman)($7)))));
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 416:16', (sp_toHuman)($6))));
        }))();
        const $y = ((() => {
          const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $doneSoFar.recycled);
          return ((($6)[0] === "$Nothing")
            ? null
            : ((($6)[0] === "$Just")
              ? ((() => {
                const $p2 = ($6)[1];
                return (u0$Compiler$UniquenessCheck$errorMutatingTwice$0.usr)(...(u0$Compiler$UniquenessCheck$errorMutatingTwice$0.ctx), $env, $name, $p1, $p2, $state);
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 428:16', (sp_toHuman)($6))));
        }))();
        const $0 = $doneSoFar;
        return (Object.assign)({}, $0, ({
          recycled: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $p1, $doneSoFar.recycled),
          resolved: (c0$Compiler$TypedAst$ArgumentRecycle$0.usr)(...(c0$Compiler$TypedAst$ArgumentRecycle$0.ctx), $p1, $rawType, $attrPath, $name),
        }));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 392:4', (sp_toHuman)($5))));
});

const u0$Compiler$UniquenessCheck$doArgument$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$doArgument$1,
});

const u0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions$1 = (($env, $callPos, $name, $required, $state) => {
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $callPos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("This function call could allow some unique values (" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $required))) + ")"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("to be recycled by a functions contained in the argument `" + $name) + "` outside of the scope where they were declared."), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "This would be BAD. [TODO link to wiki]", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO improve this explanation.", c0$Core$Nil$0)))));
});

const u0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions$1,
});

const u0$Compiler$UniquenessCheck$uniOutInit$1 = (($a) => {
  return ({
    recycled: c0$Dict$empty$0,
    required: c0$Dict$empty$0,
    resolved: $a,
    spent: c0$Dict$empty$0,
  });
});

const u0$Compiler$UniquenessCheck$uniOutInit$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$uniOutInit$1,
});

const u0$Compiler$UniquenessCheck$uniOutMap$1 = (($f, $1) => {
  const $recycled = $1.recycled;
  const $required = $1.required;
  const $resolved = $1.resolved;
  const $spent = $1.spent;
  return ({
    recycled: $recycled,
    required: $required,
    resolved: ($f.usr)(...($f.ctx), $resolved),
    spent: $spent,
  });
});

const u0$Compiler$UniquenessCheck$uniOutMap$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$uniOutMap$1,
});

const u0$Compiler$UniquenessCheck$doCall$7 = (($doneArgs, $doneReference, $env, $pos, $state, $name) => {
  return (u0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions$0.usr)(...(u0$Compiler$UniquenessCheck$errorTaintedCallRecyclesFunctions$0.ctx), $env, $pos, $name, (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneArgs.required, $doneReference.required), $state);
});

const u0$Compiler$UniquenessCheck$doCall$6 = (($tyvarId) => {
  return false;
});

const u0$Compiler$UniquenessCheck$doCall$5 = (($arg) => {
  return ((($arg)[0] === "$ArgumentRecycle")
    ? ((() => {
      const $p = ($arg)[1];
      const $raw = ($arg)[2];
      const $path = ($arg)[3];
      const $name = ($arg)[4];
      return ((c0$Compiler$TypedAst$typeAllowsFunctions$0.usr)(...(c0$Compiler$TypedAst$typeAllowsFunctions$0.ctx), ({
        ctx: [],
        usr: u0$Compiler$UniquenessCheck$doCall$6,
      }), $raw)
        ? (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name)
        : c0$Maybe$Nothing$0);
    }))()
    : ((($arg)[0] === "$ArgumentExpression")
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 356:8', (sp_toHuman)($arg))));
});

const u0$Compiler$UniquenessCheck$doCall$4 = (($acc, $resolvedArg) => {
  return (sp_cons)($resolvedArg, $acc.resolved);
});

const u0$Compiler$UniquenessCheck$doCall$3 = (($arg, _0) => {
  return $arg;
});

const u0$Compiler$UniquenessCheck$doCall$2 = (($env, $pos, $state, $arg, $acc) => {
  return (u0$Compiler$UniquenessCheck$uniOutMap$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutMap$0.ctx), ({
    ctx: ([
      $acc,
    ]),
    usr: u0$Compiler$UniquenessCheck$doCall$4,
  }), (u0$Compiler$UniquenessCheck$doArgument$0.usr)(...(u0$Compiler$UniquenessCheck$doArgument$0.ctx), $env, $state, $pos, (u0$Compiler$UniquenessCheck$uniOutMap$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutMap$0.ctx), ({
    ctx: ([
      $arg,
    ]),
    usr: u0$Compiler$UniquenessCheck$doCall$3,
  }), $acc)));
});

const u0$Compiler$UniquenessCheck$doCall$1 = (($env, $state, $pos, $lambdaSet, $reference, $arguments) => {
  const $doneReference = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $reference);
  const $doneArgs = (c0$List$forReversed$0.usr)(...(c0$List$forReversed$0.ctx), (u0$Compiler$UniquenessCheck$uniOutInit$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutInit$0.ctx), c0$Core$Nil$0), $arguments, ({
    ctx: ([
      $env,
      $pos,
      $state,
    ]),
    usr: u0$Compiler$UniquenessCheck$doCall$2,
  }));
  const $asRecyclingFunction = ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$doCall$5,
  });
  (((sp_not_equal)($doneArgs.required, c0$Dict$empty$0) || (sp_not_equal)($doneReference.required, c0$Dict$empty$0))
    ? (c0$List$each$0.usr)(...(c0$List$each$0.ctx), (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), $asRecyclingFunction, $arguments), ({
      ctx: ([
        $doneArgs,
        $doneReference,
        $env,
        $pos,
        $state,
      ]),
      usr: u0$Compiler$UniquenessCheck$doCall$7,
    }))
    : null);
  return ({
    recycled: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneReference.recycled, $doneArgs.recycled),
    required: $doneArgs.required,
    resolved: (c0$Compiler$TypedAst$Call$0.usr)(...(c0$Compiler$TypedAst$Call$0.ctx), $pos, $lambdaSet, $doneReference.resolved, $doneArgs.resolved),
    spent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneReference.spent, $doneArgs.spent),
  });
});

const u0$Compiler$UniquenessCheck$doCall$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$doCall$1,
});

const u0$Compiler$UniquenessCheck$doParameter$1 = (($state, $par, $acc) => {
  return ((($par)[0] === "$ParameterPattern")
    ? ((() => {
      const $fullType = ($par)[1];
      const $pa = ($par)[2];
      const $4 = (u0$Compiler$UniquenessCheck$addPatternToEnv$0.usr)(...(u0$Compiler$UniquenessCheck$addPatternToEnv$0.ctx), $state, $pa, $acc.localEnv);
      const $localEnv = $4.third;
      const $uniques = $4.second;
      const $addedVars = $4.first;
      const $0 = $acc;
      return (Object.assign)({}, $0, ({
        localEnv: $localEnv,
        parsToBeSpent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $uniques, $0.parsToBeSpent),
      }));
    }))()
    : ((($par)[0] === "$ParameterPlaceholder")
      ? ((() => {
        const $fullType = ($par)[1];
        const $n = ($par)[2];
        const $pa = (c0$Compiler$TypedAst$PatternAny$0.usr)(...(c0$Compiler$TypedAst$PatternAny$0.ctx), c0$Compiler$Pos$G$0, ({
          maybeName: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (text_fromNumber)($n)),
          type: $fullType,
        }));
        const $4 = (u0$Compiler$UniquenessCheck$addPatternToEnv$0.usr)(...(u0$Compiler$UniquenessCheck$addPatternToEnv$0.ctx), $state, $pa, $acc.localEnv);
        const $localEnv = $4.third;
        const $uniques = $4.second;
        const $addedVars = $4.first;
        const $0 = $acc;
        return (Object.assign)({}, $0, ({
          localEnv: $localEnv,
          parsToBeSpent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $uniques, $0.parsToBeSpent),
        }));
      }))()
      : ((($par)[0] === "$ParameterRecycle")
        ? ((() => {
          const $pos = ($par)[1];
          const $rawType = ($par)[2];
          const $name = ($par)[3];
          const $var = ({
            definedAt: $pos,
            mode: (u0$Compiler$UniquenessCheck$Unique$0.usr)(...(u0$Compiler$UniquenessCheck$Unique$0.ctx), u0$Compiler$UniquenessCheck$Available$0),
            name: $name,
            required: c0$Dict$empty$0,
            type: ({
              raw: $rawType,
              uni: c0$Compiler$Ast$Uni$0,
            }),
          });
          const $0 = $acc;
          return (Object.assign)({}, $0, ({
            localEnv: ((() => {
              const $1 = $acc.localEnv;
              return (Object.assign)({}, $1, ({
                variables: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $var, $1.variables),
              }));
            }))(),
            parsToBeRecycled: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $pos, $0.parsToBeRecycled),
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 450:4', (sp_toHuman)($par)))));
});

const u0$Compiler$UniquenessCheck$doParameter$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$doParameter$1,
});

const u0$Compiler$UniquenessCheck$errorConsumingRecycledParameters$1 = (($env, $pos, $spentThatShouldHaveBeenRecycled, $state) => {
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $pos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "errorConsumingRecycledParameters", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($spentThatShouldHaveBeenRecycled), c0$Core$Nil$0)));
});

const u0$Compiler$UniquenessCheck$errorConsumingRecycledParameters$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorConsumingRecycledParameters$1,
});

const u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$2 = (($env, $1) => {
  const $name = $1.first;
  const $spentPos = $1.second;
  const $2 = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $spentPos);
  const $location = $2.location;
  const $block = $2.block;
  return ($block + "\n");
});

const u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$1 = (($env, $functionPos, $spentFromParent, $state) => {
  const $zzz = ({
    ctx: ([
      $env,
    ]),
    usr: u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$2,
  });
  const $blocks = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $zzz, (list_sortBy)(c0$Tuple$second$0, (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $spentFromParent)));
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $functionPos, $state, (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("This function is spending the unique variable `" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "`, `", (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $spentFromParent))) + "`"), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $blocks, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "However, functions cannot spend uniques that were declared outside their body.", c0$Core$Nil$0), c0$Core$Nil$0))))));
});

const u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$1,
});

const u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$1 = (($env, $name, $2, $state) => {
  const $fnPos = $2.fnPos;
  const $usedAt = $2.usedAt;
  const $5 = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), (u0$Compiler$UniquenessCheck$getErrorModule$0.usr)(...(u0$Compiler$UniquenessCheck$getErrorModule$0.ctx), $env), $usedAt);
  const $location = $5.location;
  const $block = $5.block;
  return (u0$Compiler$UniquenessCheck$addError$0.usr)(...(u0$Compiler$UniquenessCheck$addError$0.ctx), $env, $fnPos, $state, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("This expression needs to access the unique variable `" + $name) + "` because it uses it here:"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $block, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (((("The problem is that returning a function from the expression could allow accessing `" + $name) + "` from outside of where `") + $name) + "` was declared."), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "This would be BAD. [TODO link to wiki]", c0$Core$Nil$0)))))));
});

const u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$1,
});

const u0$Compiler$UniquenessCheck$doFn$6 = (($doneBody, $env, $state, $varName, $parPos) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $varName, $doneBody.required);
  return ((($3)[0] === "$Nothing")
    ? null
    : ((($3)[0] === "$Just")
      ? ((() => {
        const $r = ($3)[1];
        return (u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$0.usr)(...(u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$0.ctx), $env, $varName, $r, $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 835:12', (sp_toHuman)($3))));
});

const u0$Compiler$UniquenessCheck$doFn$5 = (($tyvarId) => {
  return false;
});

const u0$Compiler$UniquenessCheck$doFn$4 = (($pos, $k, $usedAt) => {
  return ({
    fnPos: $pos,
    usedAt: $usedAt,
  });
});

const u0$Compiler$UniquenessCheck$doFn$3 = (($doneBody, $name, _1, $exp) => {
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $doneBody.spent)
    ? $exp
    : (c0$Compiler$TypedAst$DestroyIn$0.usr)(...(c0$Compiler$TypedAst$DestroyIn$0.ctx), $name, $exp));
});

const u0$Compiler$UniquenessCheck$doFn$2 = (($state, $0, $1) => {
  return (u0$Compiler$UniquenessCheck$doParameter$0.usr)(...(u0$Compiler$UniquenessCheck$doParameter$0.ctx), $state, $0, $1);
});

const u0$Compiler$UniquenessCheck$doFn$1 = (($env, $pos, $state, $lambdaRef, $lambda, $context) => {
  const $7 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), ({
    localEnv: $env,
    parsToBeRecycled: c0$Dict$empty$0,
    parsToBeSpent: c0$Dict$empty$0,
  }), $lambda.pars, ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$UniquenessCheck$doFn$2,
  }));
  const $parsToBeSpent = $7.parsToBeSpent;
  const $parsToBeRecycled = $7.parsToBeRecycled;
  const $localEnv = $7.localEnv;
  const $doneBody = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $localEnv, $state, $lambda.body);
  const $exprWithDestruction = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $doneBody.resolved, $parsToBeSpent, ({
    ctx: ([
      $doneBody,
    ]),
    usr: u0$Compiler$UniquenessCheck$doFn$3,
  }));
  const $spentThatShouldHaveBeenRecycled = (c0$Dict$intersect$0.usr)(...(c0$Dict$intersect$0.ctx), $doneBody.spent, $parsToBeRecycled);
  ((sp_not_equal)($spentThatShouldHaveBeenRecycled, c0$Dict$empty$0)
    ? (u0$Compiler$UniquenessCheck$errorConsumingRecycledParameters$0.usr)(...(u0$Compiler$UniquenessCheck$errorConsumingRecycledParameters$0.ctx), $env, $pos, $spentThatShouldHaveBeenRecycled, $state)
    : null);
  const $spentFromParent = (c0$Dict$diff$0.usr)(...(c0$Dict$diff$0.ctx), $doneBody.spent, $parsToBeSpent);
  (((sp_equal)($spentThatShouldHaveBeenRecycled, c0$Dict$empty$0) && (sp_not_equal)($spentFromParent, c0$Dict$empty$0))
    ? (u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$0.usr)(...(u0$Compiler$UniquenessCheck$errorFunctionsCannotConsumeParentUniques$0.ctx), $env, $pos, $spentFromParent, $state)
    : null);
  const $required = (c0$Dict$diff$0.usr)(...(c0$Dict$diff$0.ctx), (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneBody.required, (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: ([
      $pos,
    ]),
    usr: u0$Compiler$UniquenessCheck$doFn$4,
  }), $doneBody.recycled)), $parsToBeRecycled);
  ((c0$Compiler$TypedAst$typeAllowsFunctions$0.usr)(...(c0$Compiler$TypedAst$typeAllowsFunctions$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$doFn$5,
  }), $lambda.returnType.raw)
    ? (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $parsToBeRecycled, $parsToBeSpent), ({
      ctx: ([
        $doneBody,
        $env,
        $state,
      ]),
      usr: u0$Compiler$UniquenessCheck$doFn$6,
    }))
    : null);
  (hash_insert)($state.lambdas, (c0$Tuple$second$0.usr)(...(c0$Tuple$second$0.ctx), $lambdaRef), ((() => {
    const $0 = $lambda;
    return (Object.assign)({}, $0, ({
      body: $exprWithDestruction,
    }));
  }))());
  return ({
    recycled: (c0$Dict$diff$0.usr)(...(c0$Dict$diff$0.ctx), $doneBody.recycled, $parsToBeRecycled),
    required: $required,
    resolved: (c0$Compiler$TypedAst$Lambda$0.usr)(...(c0$Compiler$TypedAst$Lambda$0.ctx), $pos, ({
      context: $context,
      definition: true,
      ref: $lambdaRef,
    })),
    spent: c0$Dict$empty$0,
  });
});

const u0$Compiler$UniquenessCheck$doFn$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$doFn$1,
});

const u0$Compiler$UniquenessCheck$doVariable$1 = (($env, $state, $pos, $name, $e) => {
  const $6 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $env.variables);
  return ((($6)[0] === "$Nothing")
    ? ((() => {
      (u0$Compiler$UniquenessCheck$errorUndefinedVariable$0.usr)(...(u0$Compiler$UniquenessCheck$errorUndefinedVariable$0.ctx), $env, $pos, $name, $state);
      return (u0$Compiler$UniquenessCheck$uniOutInit$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutInit$0.ctx), $e);
    }))()
    : ((($6)[0] === "$Just")
      ? ((() => {
        const $variable = ($6)[1];
        const $7 = $variable.mode;
        return ((($7)[0] === "$Immutable")
          ? ({
            recycled: c0$Dict$empty$0,
            required: $variable.required,
            resolved: $e,
            spent: c0$Dict$empty$0,
          })
          : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$Available"))
            ? ({
              recycled: c0$Dict$empty$0,
              required: $variable.required,
              resolved: $e,
              spent: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $name, $pos),
            })
            : (((($7)[0] === "$Unique") && ((($7)[1])[0] === "$ConsumedAt"))
              ? ((() => {
                const $consumedPos = (($7)[1])[1];
                (u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0.usr)(...(u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0.ctx), $env, $name, $pos, $consumedPos, $state);
                return ({
                  recycled: c0$Dict$empty$0,
                  required: $variable.required,
                  resolved: $e,
                  spent: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), $name, $pos),
                });
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 747:12', (sp_toHuman)($7)))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 739:4', (sp_toHuman)($6))));
});

const u0$Compiler$UniquenessCheck$doVariable$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$doVariable$1,
});

const u0$Compiler$UniquenessCheck$requireInEnv$4 = (($required, $var) => {
  const $1 = $var;
  return (Object.assign)({}, $1, ({
    required: $required,
  }));
});

const u0$Compiler$UniquenessCheck$requireInEnv$3 = (($required, $0) => {
  return (c0$Maybe$map$0.usr)(...(c0$Maybe$map$0.ctx), ({
    ctx: ([
      $required,
    ]),
    usr: u0$Compiler$UniquenessCheck$requireInEnv$4,
  }), $0);
});

const u0$Compiler$UniquenessCheck$requireInEnv$2 = (($required, $name, $a) => {
  return (c0$Dict$update$0.usr)(...(c0$Dict$update$0.ctx), $name, ({
    ctx: ([
      $required,
    ]),
    usr: u0$Compiler$UniquenessCheck$requireInEnv$3,
  }), $a);
});

const u0$Compiler$UniquenessCheck$requireInEnv$1 = (($varNames, $required, $env) => {
  const $0 = $env;
  return (Object.assign)({}, $0, ({
    variables: (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $0.variables, $varNames, ({
      ctx: ([
        $required,
      ]),
      usr: u0$Compiler$UniquenessCheck$requireInEnv$2,
    })),
  }));
});

const u0$Compiler$UniquenessCheck$requireInEnv$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$requireInEnv$1,
});

const u0$Compiler$UniquenessCheck$doExpression$20 = (($doneFalse, $name, _1, $exp) => {
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $doneFalse.spent)
    ? $exp
    : (c0$Compiler$TypedAst$DestroyIn$0.usr)(...(c0$Compiler$TypedAst$DestroyIn$0.ctx), $name, $exp));
});

const u0$Compiler$UniquenessCheck$doExpression$19 = (($doneTrue, $name, _1, $exp) => {
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $doneTrue.spent)
    ? $exp
    : (c0$Compiler$TypedAst$DestroyIn$0.usr)(...(c0$Compiler$TypedAst$DestroyIn$0.ctx), $name, $exp));
});

const u0$Compiler$UniquenessCheck$doExpression$18 = (($spent, $name, _1, $exp) => {
  return ((c0$Dict$member$0.usr)(...(c0$Dict$member$0.ctx), $name, $spent)
    ? $exp
    : (c0$Compiler$TypedAst$DestroyIn$0.usr)(...(c0$Compiler$TypedAst$DestroyIn$0.ctx), $name, $exp));
});

const u0$Compiler$UniquenessCheck$doExpression$17 = (($allSpent, $1) => {
  const $recycled = $1.recycled;
  const $required = $1.required;
  const $pattern = $1.resolved.first;
  const $blockExpression = $1.resolved.second;
  const $spent = $1.spent;
  const $finalBlock = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $blockExpression, $allSpent, ({
    ctx: ([
      $spent,
    ]),
    usr: u0$Compiler$UniquenessCheck$doExpression$18,
  }));
  return ({
    first: $pattern,
    second: $finalBlock,
  });
});

const u0$Compiler$UniquenessCheck$doExpression$16 = (($d, $a) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $d.spent, $a);
});

const u0$Compiler$UniquenessCheck$doExpression$15 = (($d, $a) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $d.required, $a);
});

const u0$Compiler$UniquenessCheck$doExpression$14 = (($d, $a) => {
  return (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $d.recycled, $a);
});

const u0$Compiler$UniquenessCheck$doExpression$13 = (($pattern, $expr) => {
  return ({
    first: $pattern,
    second: $expr,
  });
});

const u0$Compiler$UniquenessCheck$doExpression$12 = (($doneValue, $newEnv, $state, $1) => {
  const $pattern = $1.first;
  const $block = $1.second;
  const $2 = (u0$Compiler$UniquenessCheck$addPatternToEnv$0.usr)(...(u0$Compiler$UniquenessCheck$addPatternToEnv$0.ctx), $state, $pattern, $newEnv);
  const $env0 = $2.third;
  const $mutables_should_be_empty = $2.second;
  const $addedVars = $2.first;
  const $localEnv = (u0$Compiler$UniquenessCheck$requireInEnv$0.usr)(...(u0$Compiler$UniquenessCheck$requireInEnv$0.ctx), $addedVars, $doneValue.required, $env0);
  return (u0$Compiler$UniquenessCheck$uniOutMap$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutMap$0.ctx), ({
    ctx: ([
      $pattern,
    ]),
    usr: u0$Compiler$UniquenessCheck$doExpression$13,
  }), (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $localEnv, $state, $block));
});

const u0$Compiler$UniquenessCheck$doExpression$11 = (($env, $state, $n, $1) => {
  const $p1 = $1.first;
  const $p2 = $1.second;
  return (u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0.usr)(...(u0$Compiler$UniquenessCheck$errorReferencingConsumedVariable$0.ctx), $env, $n, $p1, $p2, $state);
});

const u0$Compiler$UniquenessCheck$doExpression$10 = (($k, $v, $d) => {
  return $d;
});

const u0$Compiler$UniquenessCheck$doExpression$9 = (($k, $a, $b, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $k, ({
    first: $a,
    second: $b,
  }), $d);
});

const u0$Compiler$UniquenessCheck$doExpression$8 = (($k, $v, $d) => {
  return $d;
});

const u0$Compiler$UniquenessCheck$doExpression$7 = (($env, $state, $name, $value, $doneSoFar) => {
  const $4 = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $value);
  const $spent = $4.spent;
  const $resolved = $4.resolved;
  const $required = $4.required;
  const $recycled = $4.recycled;
  const $consumedTwice = (c0$Dict$merge$0.usr)(...(c0$Dict$merge$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$doExpression$10,
  }), ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$doExpression$9,
  }), ({
    ctx: [],
    usr: u0$Compiler$UniquenessCheck$doExpression$8,
  }), $spent, $doneSoFar.spent, c0$Dict$empty$0);
  (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $consumedTwice, ({
    ctx: ([
      $env,
      $state,
    ]),
    usr: u0$Compiler$UniquenessCheck$doExpression$11,
  }));
  return ({
    recycled: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $recycled, $doneSoFar.recycled),
    required: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $required, $doneSoFar.required),
    resolved: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, $resolved, $doneSoFar.resolved),
    spent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $spent, $doneSoFar.spent),
  });
});

const u0$Compiler$UniquenessCheck$doExpression$6 = (($name, $pos, $0) => {
  return (c0$Compiler$TypedAst$RecordAccess$0.usr)(...(c0$Compiler$TypedAst$RecordAccess$0.ctx), $pos, $name, $0);
});

const u0$Compiler$UniquenessCheck$doExpression$5 = (($name, _1, $d) => {
  return (c0$Dict$remove$0.usr)(...(c0$Dict$remove$0.ctx), $name, $d);
});

const u0$Compiler$UniquenessCheck$doExpression$4 = (($doneExpression, $name, $pos, $exp) => {
  const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $name, $doneExpression.spent);
  return ((($4)[0] === "$Just")
    ? $exp
    : ((($4)[0] === "$Nothing")
      ? (c0$Compiler$TypedAst$DestroyIn$0.usr)(...(c0$Compiler$TypedAst$DestroyIn$0.ctx), $name, $exp)
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 710:20', (sp_toHuman)($4))));
});

const u0$Compiler$UniquenessCheck$doExpression$3 = (($doneExpression, $env, $state, $varName) => {
  const $2 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $varName, $doneExpression.required);
  return ((($2)[0] === "$Nothing")
    ? null
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $r = ($2)[1];
        return (u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$0.usr)(...(u0$Compiler$UniquenessCheck$errorReturnExpressionRequiresUniquesDefinedInTheCurrentScope$0.ctx), $env, $varName, $r, $state);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 701:20', (sp_toHuman)($2))));
});

const u0$Compiler$UniquenessCheck$doExpression$2 = (($tyvarId) => {
  return false;
});

const u0$Compiler$UniquenessCheck$doExpression$1 = (($env, $state, $expression) => {
  const $re = (u0$Compiler$UniquenessCheck$uniOutInit$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutInit$0.ctx), $expression);
  return ((($expression)[0] === "$LiteralText")
    ? ((() => {
      const $pos = ($expression)[1];
      const $l = ($expression)[2];
      return $re;
    }))()
    : ((($expression)[0] === "$LiteralNumber")
      ? ((() => {
        const $pos = ($expression)[1];
        const $l = ($expression)[2];
        return $re;
      }))()
      : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefGlobal"))
        ? ((() => {
          const $pos = ($expression)[1];
          return $re;
        }))()
        : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefLocal"))
          ? ((() => {
            const $pos = ($expression)[1];
            const $name = (($expression)[2])[1];
            return (u0$Compiler$UniquenessCheck$doVariable$0.usr)(...(u0$Compiler$UniquenessCheck$doVariable$0.ctx), $env, $state, $pos, $name, $expression);
          }))()
          : (((($expression)[0] === "$Variable") && ((($expression)[2])[0] === "$RefPlaceholder"))
            ? ((() => {
              const $pos = ($expression)[1];
              const $n = (($expression)[2])[1];
              return (u0$Compiler$UniquenessCheck$doVariable$0.usr)(...(u0$Compiler$UniquenessCheck$doVariable$0.ctx), $env, $state, $pos, (text_fromNumber)($n), $expression);
            }))()
            : ((($expression)[0] === "$Constructor")
              ? ((() => {
                const $pos = ($expression)[1];
                const $usr = ($expression)[2];
                return $re;
              }))()
              : ((($expression)[0] === "$Lambda")
                ? ((() => {
                  const $pos = ($expression)[1];
                  const $pars = ($expression)[2];
                  const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), (c0$Tuple$second$0.usr)(...(c0$Tuple$second$0.ctx), $pars.ref), $env.rootDef.lambdas);
                  return ((($4)[0] === "$Nothing")
                    ? (sp_todo)("compiler bug: lambda not found")
                    : ((($4)[0] === "$Just")
                      ? ((() => {
                        const $lambda = ($4)[1];
                        return ($pars.definition
                          ? (u0$Compiler$UniquenessCheck$doFn$0.usr)(...(u0$Compiler$UniquenessCheck$doFn$0.ctx), $env, $pos, $state, $pars.ref, $lambda, $pars.context)
                          : ({
                            recycled: c0$Dict$empty$0,
                            required: c0$Dict$empty$0,
                            resolved: $expression,
                            spent: c0$Dict$empty$0,
                          }));
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 515:12', (sp_toHuman)($4))));
                }))()
                : ((($expression)[0] === "$Call")
                  ? ((() => {
                    const $pos = ($expression)[1];
                    const $lambdaSet = ($expression)[2];
                    const $reference = ($expression)[3];
                    const $arguments = ($expression)[4];
                    return (u0$Compiler$UniquenessCheck$doCall$0.usr)(...(u0$Compiler$UniquenessCheck$doCall$0.ctx), $env, $state, $pos, $lambdaSet, $reference, $arguments);
                  }))()
                  : ((($expression)[0] === "$If")
                    ? ((() => {
                      const $pos = ($expression)[1];
                      const $condition = ($expression)[2].condition;
                      const $false = ($expression)[2].false;
                      const $true = ($expression)[2].true;
                      const $doneCondition = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $condition);
                      const $newEnv = (u0$Compiler$UniquenessCheck$consumeInEnv$0.usr)(...(u0$Compiler$UniquenessCheck$consumeInEnv$0.ctx), $doneCondition.spent, $env);
                      const $doneTrue = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $newEnv, $state, $true);
                      const $doneFalse = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $newEnv, $state, $false);
                      const $finalTrueExpression = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $doneTrue.resolved, $doneFalse.spent, ({
                        ctx: ([
                          $doneTrue,
                        ]),
                        usr: u0$Compiler$UniquenessCheck$doExpression$19,
                      }));
                      const $finalFalseExpression = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $doneFalse.resolved, $doneTrue.spent, ({
                        ctx: ([
                          $doneFalse,
                        ]),
                        usr: u0$Compiler$UniquenessCheck$doExpression$20,
                      }));
                      const $finalExpression = (c0$Compiler$TypedAst$If$0.usr)(...(c0$Compiler$TypedAst$If$0.ctx), $pos, ({
                        condition: $doneCondition.resolved,
                        false: $finalFalseExpression,
                        true: $finalTrueExpression,
                      }));
                      return ({
                        recycled: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneFalse.recycled, (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneTrue.recycled, $doneCondition.recycled)),
                        required: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneFalse.required, (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneTrue.required, $doneCondition.required)),
                        resolved: $finalExpression,
                        spent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneFalse.spent, (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneTrue.spent, $doneCondition.spent)),
                      });
                    }))()
                    : ((($expression)[0] === "$Try")
                      ? ((() => {
                        const $pos = ($expression)[1];
                        const $patternsAndExpressions = ($expression)[2].patternsAndExpressions;
                        const $value = ($expression)[2].value;
                        const $valueType = ($expression)[2].valueType;
                        const $doneValue = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $value);
                        const $newEnv = (u0$Compiler$UniquenessCheck$consumeInEnv$0.usr)(...(u0$Compiler$UniquenessCheck$consumeInEnv$0.ctx), $doneValue.spent, $env);
                        const $zzz = ({
                          ctx: ([
                            $doneValue,
                            $newEnv,
                            $state,
                          ]),
                          usr: u0$Compiler$UniquenessCheck$doExpression$12,
                        });
                        const $donePatternsAndBlocks = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $zzz, $patternsAndExpressions);
                        const $allRecycled = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $donePatternsAndBlocks, ({
                          ctx: [],
                          usr: u0$Compiler$UniquenessCheck$doExpression$14,
                        }));
                        const $allRequired = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $donePatternsAndBlocks, ({
                          ctx: [],
                          usr: u0$Compiler$UniquenessCheck$doExpression$15,
                        }));
                        const $allSpent = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $donePatternsAndBlocks, ({
                          ctx: [],
                          usr: u0$Compiler$UniquenessCheck$doExpression$16,
                        }));
                        const $newPatternsAndBlocks = ((() => {
                          const $xxx = ({
                            ctx: ([
                              $allSpent,
                            ]),
                            usr: u0$Compiler$UniquenessCheck$doExpression$17,
                          });
                          return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $xxx, $donePatternsAndBlocks);
                        }))();
                        return ({
                          recycled: $allRecycled,
                          required: $allRequired,
                          resolved: (c0$Compiler$TypedAst$Try$0.usr)(...(c0$Compiler$TypedAst$Try$0.ctx), $pos, ({
                            patternsAndExpressions: $newPatternsAndBlocks,
                            value: $doneValue.resolved,
                            valueType: $valueType,
                          })),
                          spent: $allSpent,
                        });
                      }))()
                      : ((($expression)[0] === "$Record")
                        ? ((() => {
                          const $pos = ($expression)[1];
                          const $maybeExtending = ($expression)[2];
                          const $attrValueByName = ($expression)[3];
                          const $doneExt = ((($maybeExtending)[0] === "$Nothing")
                            ? (u0$Compiler$UniquenessCheck$uniOutInit$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutInit$0.ctx), c0$Maybe$Nothing$0)
                            : ((($maybeExtending)[0] === "$Just")
                              ? ((() => {
                                const $extending = ($maybeExtending)[1];
                                return (u0$Compiler$UniquenessCheck$uniOutMap$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutMap$0.ctx), c0$Maybe$Just$0, (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $extending));
                              }))()
                              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 636:16', (sp_toHuman)($maybeExtending))));
                          const $doneAttrs = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (u0$Compiler$UniquenessCheck$uniOutInit$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutInit$0.ctx), c0$Dict$empty$0), $attrValueByName, ({
                            ctx: ([
                              $env,
                              $state,
                            ]),
                            usr: u0$Compiler$UniquenessCheck$doExpression$7,
                          }));
                          return ({
                            recycled: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneExt.recycled, $doneAttrs.recycled),
                            required: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneExt.required, $doneAttrs.required),
                            resolved: (c0$Compiler$TypedAst$Record$0.usr)(...(c0$Compiler$TypedAst$Record$0.ctx), $pos, $doneExt.resolved, $doneAttrs.resolved),
                            spent: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneExt.spent, $doneAttrs.spent),
                          });
                        }))()
                        : ((($expression)[0] === "$RecordAccess")
                          ? ((() => {
                            const $pos = ($expression)[1];
                            const $name = ($expression)[2];
                            const $expr = ($expression)[3];
                            return (u0$Compiler$UniquenessCheck$uniOutMap$0.usr)(...(u0$Compiler$UniquenessCheck$uniOutMap$0.ctx), ({
                              ctx: ([
                                $name,
                                $pos,
                              ]),
                              usr: u0$Compiler$UniquenessCheck$doExpression$6,
                            }), (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $expr));
                          }))()
                          : ((($expression)[0] === "$LetIn")
                            ? ((() => {
                              const $localDef = ($expression)[1];
                              const $rest = ($expression)[2];
                              const $restType = ($expression)[3];
                              const $4 = (u0$Compiler$UniquenessCheck$addPatternToEnv$0.usr)(...(u0$Compiler$UniquenessCheck$addPatternToEnv$0.ctx), $state, $localDef.pattern, $env);
                              const $env1 = $4.third;
                              const $uniques = $4.second;
                              const $addedVars = $4.first;
                              const $doneDefBody = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env1, $state, $localDef.body);
                              const $localEnv = (u0$Compiler$UniquenessCheck$requireInEnv$0.usr)(...(u0$Compiler$UniquenessCheck$requireInEnv$0.ctx), $addedVars, $doneDefBody.required, (u0$Compiler$UniquenessCheck$consumeInEnv$0.usr)(...(u0$Compiler$UniquenessCheck$consumeInEnv$0.ctx), $doneDefBody.spent, $env1));
                              const $doneExpression = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $localEnv, $state, $rest);
                              ((c0$Compiler$TypedAst$typeAllowsFunctions$0.usr)(...(c0$Compiler$TypedAst$typeAllowsFunctions$0.ctx), ({
                                ctx: [],
                                usr: u0$Compiler$UniquenessCheck$doExpression$2,
                              }), $restType.raw)
                                ? (c0$List$each$0.usr)(...(c0$List$each$0.ctx), $addedVars, ({
                                  ctx: ([
                                    $doneExpression,
                                    $env,
                                    $state,
                                  ]),
                                  usr: u0$Compiler$UniquenessCheck$doExpression$3,
                                }))
                                : null);
                              const $finalExpression = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), (c0$Compiler$TypedAst$LetIn$0.usr)(...(c0$Compiler$TypedAst$LetIn$0.ctx), ((() => {
                                const $0 = $localDef;
                                return (Object.assign)({}, $0, ({
                                  body: $doneDefBody.resolved,
                                }));
                              }))(), $doneExpression.resolved, $restType), $uniques, ({
                                ctx: ([
                                  $doneExpression,
                                ]),
                                usr: u0$Compiler$UniquenessCheck$doExpression$4,
                              }));
                              const $spent = (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneDefBody.spent, (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $doneExpression.spent, $uniques, ({
                                ctx: [],
                                usr: u0$Compiler$UniquenessCheck$doExpression$5,
                              })));
                              return ({
                                recycled: (c0$Dict$join$0.usr)(...(c0$Dict$join$0.ctx), $doneDefBody.recycled, $doneExpression.recycled),
                                required: $doneExpression.required,
                                resolved: $finalExpression,
                                spent: $spent,
                              });
                            }))()
                            : ((($expression)[0] === "$Error")
                              ? $re
                              : ((($expression)[0] === "$Introspect")
                                ? $re
                                : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 494:4', (sp_toHuman)($expression)))))))))))))))));
});

const u0$Compiler$UniquenessCheck$doExpression$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$doExpression$1,
});

const u0$Compiler$UniquenessCheck$updateRootDef$2 = (($errors, $e) => {
  return (array_push)($errors, $e);
});

const u0$Compiler$UniquenessCheck$updateRootDef$1 = (($errors, $modulesByUmr, $1) => {
  const $usr = $1.first;
  const $def = $1.second;
  let $state = ({
    errors: (array_fromList)(c0$Core$Nil$0),
    lambdas: (hash_fromList)(c0$Core$Nil$0),
  });
  const $return = ((() => {
    const $4 = $def.body;
    return ((($4)[0] === "$Nothing")
      ? ({
        first: $usr,
        second: $def,
      })
      : ((($4)[0] === "$Just")
        ? ((() => {
          const $body = ($4)[1];
          const $env = ({
            modulesByUmr: $modulesByUmr,
            rootDef: $def,
            usr: $usr,
            variables: c0$Dict$empty$0,
          });
          const $doneExpression = (u0$Compiler$UniquenessCheck$doExpression$0.usr)(...(u0$Compiler$UniquenessCheck$doExpression$0.ctx), $env, $state, $body);
          const $lambdas = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Hash$toList$0.usr)(...(c0$Hash$toList$0.ctx), $state.lambdas));
          return ({
            first: $usr,
            second: ((() => {
              const $0 = $def;
              return (Object.assign)({}, $0, ({
                body: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $doneExpression.resolved),
              }));
            }))(),
          });
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/UniquenessCheck.sp 860:8', (sp_toHuman)($4))));
  }))();
  (array_each)($state.errors, ({
    ctx: ([
      $errors,
    ]),
    usr: u0$Compiler$UniquenessCheck$updateRootDef$2,
  }));
  return $return;
});

const u0$Compiler$UniquenessCheck$updateRootDef$0 = ({
  ctx: [],
  usr: u0$Compiler$UniquenessCheck$updateRootDef$1,
});

const u0$SPLib$RefHierarchy$resolve$3 = (($getEdges, $path, $target, $a, _1, $d) => {
  return (u0$SPLib$RefHierarchy$resolve$0.usr)(...(u0$SPLib$RefHierarchy$resolve$0.ctx), $getEdges, $a, (sp_cons)($target, $path), $d);
});

const u0$SPLib$RefHierarchy$resolve$2 = (($target, $key) => {
  return (sp_not_equal)($key, $target);
});

const u0$SPLib$RefHierarchy$resolve$1 = (($getEdges, $target, $path, $state0) => {
  return ((c0$List$member$0.usr)(...(c0$List$member$0.ctx), $target, $state0.resolved)
    ? $state0
    : ((c0$List$member$0.usr)(...(c0$List$member$0.ctx), $target, $path)
      ? ((() => {
        const $circ = (sp_cons)($target, (c0$List$takeWhile$0.usr)(...(c0$List$takeWhile$0.ctx), ({
          ctx: ([
            $target,
          ]),
          usr: u0$SPLib$RefHierarchy$resolve$2,
        }), $path));
        const $0 = $state0;
        return (Object.assign)({}, $0, ({
          circular: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Set$fromList$0.usr)(...(c0$Set$fromList$0.ctx), $circ), $circ, $0.circular),
        }));
      }))()
      : ((() => {
        const $s = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $state0, ($getEdges.usr)(...($getEdges.ctx), $target), ({
          ctx: ([
            $getEdges,
            $path,
            $target,
          ]),
          usr: u0$SPLib$RefHierarchy$resolve$3,
        }));
        const $0 = $s;
        return (Object.assign)({}, $0, ({
          resolved: (sp_cons)($target, $0.resolved),
        }));
      }))()));
});

const u0$SPLib$RefHierarchy$resolve$0 = ({
  ctx: [],
  usr: u0$SPLib$RefHierarchy$resolve$1,
});

const u0$SPLib$RefHierarchy$reorder$3 = (($keyToEdges, $k, $v, $d) => {
  return (u0$SPLib$RefHierarchy$resolve$0.usr)(...(u0$SPLib$RefHierarchy$resolve$0.ctx), $keyToEdges, $k, c0$Core$Nil$0, $d);
});

const u0$SPLib$RefHierarchy$reorder$2 = (($nodeToEdges, $nodesById, $id) => {
  const $2 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $id, $nodesById);
  return ((($2)[0] === "$Nothing")
    ? c0$Dict$empty$0
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $node = ($2)[1];
        return ($nodeToEdges.usr)(...($nodeToEdges.ctx), $node);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/SPLib/RefHierarchy.sp 40:8', (sp_toHuman)($2))));
});

const u0$SPLib$RefHierarchy$reorder$1 = (($nodeToEdges, $nodesById) => {
  const $keyToEdges = ({
    ctx: ([
      $nodeToEdges,
      $nodesById,
    ]),
    usr: u0$SPLib$RefHierarchy$reorder$2,
  });
  const $state0 = ({
    circular: c0$Dict$empty$0,
    resolved: c0$Core$Nil$0,
  });
  const $stateF = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), $state0, $nodesById, ({
    ctx: ([
      $keyToEdges,
    ]),
    usr: u0$SPLib$RefHierarchy$reorder$3,
  }));
  return ({
    first: (c0$Dict$values$0.usr)(...(c0$Dict$values$0.ctx), $stateF.circular),
    second: (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $stateF.resolved),
  });
});

const u0$SPLib$RefHierarchy$reorder$0 = ({
  ctx: [],
  usr: u0$SPLib$RefHierarchy$reorder$1,
});

const u0$Compiler$LazyBuild$build$20 = (($0) => {
  return (u0$Human$Type$usrToText$0.usr)(...(u0$Human$Type$usrToText$0.ctx), u0$Compiler$CoreDefs$coreModule$0, $0);
});

const u0$Compiler$LazyBuild$build$19 = (($k, $v) => {
  return $v.type.raw;
});

const u0$Compiler$LazyBuild$build$18 = (($1) => {
  const $usr = $1.first;
  const $def = $1.second;
  return (sp_equal)($def.body, c0$Maybe$Nothing$0);
});

const u0$Compiler$LazyBuild$build$17 = (($modulesByUmr, $1) => {
  const $usr = $1.first;
  const $def = $1.second;
  return (u0$Compiler$MakeEmittable$translateRootDef$0.usr)(...(u0$Compiler$MakeEmittable$translateRootDef$0.ctx), $modulesByUmr, $usr, $def);
});

const u0$Compiler$LazyBuild$build$16 = (($envF, $modulesByUmr, $valueDefsWithDestruction, _0) => {
  const $rootValues = (c0$List$concatMap$0.usr)(...(c0$List$concatMap$0.ctx), ({
    ctx: ([
      $modulesByUmr,
    ]),
    usr: u0$Compiler$LazyBuild$build$17,
  }), $valueDefsWithDestruction);
  const $natives = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), c0$Tuple$first$0, (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$LazyBuild$build$18,
  }), $valueDefsWithDestruction));
  const $constructors = (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$LazyBuild$build$19,
  }), $envF.constructors));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    constructors: $constructors,
    natives: $natives,
    rootValues: $rootValues,
  }));
});

const u0$Compiler$LazyBuild$build$15 = (($usr, $2, $errs) => {
  const $def = $2.def;
  const $deps = $2.deps;
  return ((sp_equal)($def, u0$Compiler$LazyBuild$MissingDef$0)
    ? (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $usr, $errs)
    : $errs);
});

const u0$Compiler$LazyBuild$build$14 = (($envF, $modulesByUmr, $state, $valueDefsWithDestruction, _0) => {
  const $missingDefs = (c0$Hash$for_$0.usr)(...(c0$Hash$for_$0.ctx), c0$Core$Nil$0, $state.done, ({
    ctx: [],
    usr: u0$Compiler$LazyBuild$build$15,
  }));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $envF,
      $modulesByUmr,
      $valueDefsWithDestruction,
    ]),
    usr: u0$Compiler$LazyBuild$build$16,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $envF,
      $modulesByUmr,
      $valueDefsWithDestruction,
    ]),
    usr: u0$Compiler$LazyBuild$build$16,
  })).ctx), ((sp_not_equal)($missingDefs, c0$Core$Nil$0)
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Cannot find definitions for:", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
      ctx: [],
      usr: u0$Compiler$LazyBuild$build$20,
    }), $missingDefs))))
    : (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null)));
});

const u0$Compiler$LazyBuild$build$13 = (($errors, $modulesByUmr, $0) => {
  return (u0$Compiler$UniquenessCheck$updateRootDef$0.usr)(...(u0$Compiler$UniquenessCheck$updateRootDef$0.ctx), $errors, $modulesByUmr, $0);
});

const u0$Compiler$LazyBuild$build$12 = (($errors, $state, $0, $1) => {
  return (u0$Compiler$LazyBuild$typecheckDefinition$0.usr)(...(u0$Compiler$LazyBuild$typecheckDefinition$0.ctx), $state, $errors, $0, $1);
});

const u0$Compiler$LazyBuild$build$11 = (($env2, $errors, $modulesByUmr, $orderedUsrs, $pars, $state, _0) => {
  const $envF = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $env2, $orderedUsrs, ({
    ctx: ([
      $errors,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$12,
  }));
  const $valueDefsWithDestruction = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $errors,
      $modulesByUmr,
    ]),
    usr: u0$Compiler$LazyBuild$build$13,
  }), (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $envF.reversedRootValueDefs));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $envF,
      $modulesByUmr,
      $state,
      $valueDefsWithDestruction,
    ]),
    usr: u0$Compiler$LazyBuild$build$14,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $envF,
      $modulesByUmr,
      $state,
      $valueDefsWithDestruction,
    ]),
    usr: u0$Compiler$LazyBuild$build$14,
  })).ctx), (u0$Compiler$LazyBuild$stopOnError$0.usr)(...(u0$Compiler$LazyBuild$stopOnError$0.ctx), $pars, $errors));
});

const u0$Compiler$LazyBuild$build$10 = (($errors, $state, $0, $1) => {
  return (u0$Compiler$LazyBuild$evaluateCircularValues$0.usr)(...(u0$Compiler$LazyBuild$evaluateCircularValues$0.ctx), $state, $errors, $0, $1);
});

const u0$Compiler$LazyBuild$build$9 = (($circulars, $env1, $errors, $modulesByUmr, $orderedUsrs, $pars, $state, _0) => {
  const $env2 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $env1, $circulars, ({
    ctx: ([
      $errors,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$10,
  }));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env2,
      $errors,
      $modulesByUmr,
      $orderedUsrs,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$11,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $env2,
      $errors,
      $modulesByUmr,
      $orderedUsrs,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$11,
  })).ctx), (u0$Compiler$LazyBuild$stopOnError$0.usr)(...(u0$Compiler$LazyBuild$stopOnError$0.ctx), $pars, $errors));
});

const u0$Compiler$LazyBuild$build$8 = (($errors, $state, $0, $1) => {
  return (u0$Compiler$LazyBuild$expandAndInsertType$0.usr)(...(u0$Compiler$LazyBuild$expandAndInsertType$0.ctx), $state, $errors, $0, $1);
});

const u0$Compiler$LazyBuild$build$7 = (($circulars, $errors, $orderedUsrs, $pars, $state, _0) => {
  const $modulesByUmr = (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Hash$toList$0.usr)(...(c0$Hash$toList$0.ctx), $state.loadedModulesByUmr));
  const $env0 = (u0$Compiler$TypeCheck$initEnv$0.usr)(...(u0$Compiler$TypeCheck$initEnv$0.ctx), $pars.projectImports, $modulesByUmr);
  const $env1 = (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $env0, $orderedUsrs, ({
    ctx: ([
      $errors,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$8,
  }));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $circulars,
      $env1,
      $errors,
      $modulesByUmr,
      $orderedUsrs,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$9,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $circulars,
      $env1,
      $errors,
      $modulesByUmr,
      $orderedUsrs,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$9,
  })).ctx), (u0$Compiler$LazyBuild$stopOnError$0.usr)(...(u0$Compiler$LazyBuild$stopOnError$0.ctx), $pars, $errors));
});

const u0$Compiler$LazyBuild$build$6 = (($errors, $circular) => {
  return ((($circular)[0] === "$Cons")
    ? ((() => {
      const $usr = ($circular)[1];
      const $others = ($circular)[2];
      return ((sp_equal)((u0$Compiler$LazyBuild$usrToDependencyType$0.usr)(...(u0$Compiler$LazyBuild$usrToDependencyType$0.ctx), $usr), c0$Compiler$Meta$TypeDependency$0)
        ? (array_push)($errors, (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Circular aliases!", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($circular), c0$Core$Nil$0))))
        : null);
    }))()
    : (true
      ? null
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 282:8', (sp_toHuman)($circular))));
});

const u0$Compiler$LazyBuild$build$5 = (($usr, _1, $dict) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $usr, $usr, $dict);
});

const u0$Compiler$LazyBuild$build$4 = (($state, $usr) => {
  const $2 = (hash_get)($state.done, $usr);
  return ((($2)[0] === "$Nothing")
    ? c0$Dict$empty$0
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $deps = ($2)[1].deps;
        return $deps;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/LazyBuild.sp 255:8', (sp_toHuman)($2))));
});

const u0$Compiler$LazyBuild$build$3 = (($pars, $state, _0) => {
  const $nodeToEdges = ({
    ctx: ([
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$4,
  });
  const $nodesById = (c0$Hash$for_$0.usr)(...(c0$Hash$for_$0.ctx), c0$Dict$empty$0, $state.done, ({
    ctx: [],
    usr: u0$Compiler$LazyBuild$build$5,
  }));
  const $2 = (u0$SPLib$RefHierarchy$reorder$0.usr)(...(u0$SPLib$RefHierarchy$reorder$0.ctx), $nodeToEdges, $nodesById);
  const $orderedUsrs = $2.second;
  const $circulars = $2.first;
  let $errors = (array_fromList)(c0$Core$Nil$0);
  (c0$List$each$0.usr)(...(c0$List$each$0.ctx), $circulars, ({
    ctx: ([
      $errors,
    ]),
    usr: u0$Compiler$LazyBuild$build$6,
  }));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $circulars,
      $errors,
      $orderedUsrs,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$7,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $circulars,
      $errors,
      $orderedUsrs,
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$7,
  })).ctx), (u0$Compiler$LazyBuild$stopOnError$0.usr)(...(u0$Compiler$LazyBuild$stopOnError$0.ctx), $pars, $errors));
});

const u0$Compiler$LazyBuild$build$2 = (($usr) => {
  return ({
    first: $usr,
    second: (u0$Compiler$LazyBuild$usrToDependencyType$0.usr)(...(u0$Compiler$LazyBuild$usrToDependencyType$0.ctx), $usr),
  });
});

const u0$Compiler$LazyBuild$build$1 = (($pars) => {
  let $state = (u0$Compiler$LazyBuild$initState$0.usr)(...(u0$Compiler$LazyBuild$initState$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$LazyBuild$build$2,
  }), $pars.requiredUsrs));
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $pars,
      $state,
    ]),
    usr: u0$Compiler$LazyBuild$build$3,
  })).ctx), (u0$Compiler$LazyBuild$collectRequiredUsrs$0.usr)(...(u0$Compiler$LazyBuild$collectRequiredUsrs$0.ctx), $pars, $state));
});

const u0$Compiler$LazyBuild$build$0 = ({
  ctx: [],
  usr: u0$Compiler$LazyBuild$build$1,
});

const u0$BuildMain$compileMain$14 = (($loadCaModulePars, $0) => {
  return (u0$BuildMain$loadCaModule$0.usr)(...(u0$BuildMain$loadCaModule$0.ctx), $loadCaModulePars, $0);
});

const u0$BuildMain$compileMain$13 = (($io, $outputFile, _0) => {
  return (u0$BuildMain$ioToRes$0.usr)(...(u0$BuildMain$ioToRes$0.ctx), (io_writeStdout)($io, (("---> " + $outputFile) + " written. =)\n")));
});

const u0$BuildMain$compileMain$12 = (($_entryUsr, $rv) => {
  return (sp_equal)($rv.usr, $_entryUsr);
});

const u0$BuildMain$compileMain$11 = (($entryUsr, $io, $makePlatformUmr, $pars, $1) => {
  const $constructors = $1.constructors;
  const $natives = $1.natives;
  const $rootValues = $1.rootValues;
  const $outputFile = (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), $pars.platform.defaultOutputName, $pars.maybeOutputPath);
  const $_entryUsr = (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $entryUsr, 0);
  const $type = ((() => {
    const $2 = (c0$List$find$0.usr)(...(c0$List$find$0.ctx), ({
      ctx: ([
        $_entryUsr,
      ]),
      usr: u0$BuildMain$compileMain$12,
    }), $rootValues);
    return ((($2)[0] === "$Just")
      ? ((() => {
        const $rv = ($2)[1];
        return $rv.returnType;
      }))()
      : ((($2)[0] === "$Nothing")
        ? (sp_todo)("no type!?")
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 516:8', (sp_toHuman)($2))));
  }))();
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $outputFile,
    ]),
    usr: u0$BuildMain$compileMain$13,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $outputFile,
    ]),
    usr: u0$BuildMain$compileMain$13,
  })).ctx), (u0$BuildMain$ioToRes$0.usr)(...(u0$BuildMain$ioToRes$0.ctx), (io_writeFile)($io, $outputFile, (($pars.platform.makeExecutable.usr)(...($pars.platform.makeExecutable.ctx), $makePlatformUmr).usr)(...(($pars.platform.makeExecutable.usr)(...($pars.platform.makeExecutable.ctx), $makePlatformUmr).ctx), ({
    constructors: $constructors,
    defs: $rootValues,
    entryUsr: $_entryUsr,
    type: $type,
  })))));
});

const u0$BuildMain$compileMain$10 = (($io, $0) => {
  return (io_readFile)($io, $0);
});

const u0$BuildMain$compileMain$9 = (($io, $rootPaths, $state, $0) => {
  return (u0$BuildMain$loadImports$0.usr)(...(u0$BuildMain$loadImports$0.ctx), $io, $state, $rootPaths, $0);
});

const u0$BuildMain$compileMain$8 = (($io, $rootPaths, $state, $0) => {
  return (u0$BuildMain$loadExports$0.usr)(...(u0$BuildMain$loadExports$0.ctx), $io, $state, $rootPaths, $0);
});

const u0$BuildMain$compileMain$7 = (($state, $0) => {
  return (u0$BuildMain$idToDirs$0.usr)(...(u0$BuildMain$idToDirs$0.ctx), $state, $0);
});

const u0$BuildMain$compileMain$6 = (($io, $pars, $platformModuleLocations, $rootPaths, $state, $modulePath) => {
  const $2 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $modulePath, $platformModuleLocations);
  return ((($2)[0] === "$Nothing")
    ? (sp_todo)((("no " + $modulePath) + "in loaded platform."))
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $location = ($2)[1];
        return ((($location)[0] === "$LocationSourceDir")
          ? ((() => {
            const $umr = ($location)[1];
            return $umr;
          }))()
          : ((($location)[0] === "$LocationLibrary")
            ? ((() => {
              const $libraryImportsPath = ($location)[1];
              const $modulePath2 = ($location)[2];
              const $3 = (u0$BuildMain$loadImports$0.usr)(...(u0$BuildMain$loadImports$0.ctx), $io, $state, $rootPaths, $libraryImportsPath);
              return ((($3)[0] === "$Err")
                ? ((() => {
                  const $err = ($3)[1];
                  return (sp_todo)((sp_toHuman)($err));
                }))()
                : ((($3)[0] === "$Ok")
                  ? ((() => {
                    const $libraryImports = ($3)[1];
                    const $4 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $modulePath, $libraryImports.modulePathToLocation);
                    return ((($4)[0] === "$Nothing")
                      ? (sp_todo)(((("Platform bug: no module " + $modulePath) + " the library imports for platform ") + $pars.platform.name))
                      : (((($4)[0] === "$Just") && ((($4)[1])[0] === "$LocationLibrary"))
                        ? (sp_todo)(("Platform bug: platform wants the UMR of a library module: " + $modulePath))
                        : (((($4)[0] === "$Just") && ((($4)[1])[0] === "$LocationSourceDir"))
                          ? ((() => {
                            const $umr = (($4)[1])[1];
                            return $umr;
                          }))()
                          : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 481:32', (sp_toHuman)($4)))));
                  }))()
                  : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 475:24', (sp_toHuman)($3))));
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 469:16', (sp_toHuman)($location))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 463:8', (sp_toHuman)($2))));
});

const u0$BuildMain$compileMain$5 = (($entryUsr, $io, $pars, $projectImports, $rootPaths, $state, $platformModuleLocations) => {
  const $makePlatformUmr = ({
    ctx: ([
      $io,
      $pars,
      $platformModuleLocations,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$6,
  });
  const $loadCaModulePars = ({
    idToDirs: ({
      ctx: ([
        $state,
      ]),
      usr: u0$BuildMain$compileMain$7,
    }),
    loadExports: ({
      ctx: ([
        $io,
        $rootPaths,
        $state,
      ]),
      usr: u0$BuildMain$compileMain$8,
    }),
    loadImports: ({
      ctx: ([
        $io,
        $rootPaths,
        $state,
      ]),
      usr: u0$BuildMain$compileMain$9,
    }),
    readFile: ({
      ctx: ([
        $io,
      ]),
      usr: u0$BuildMain$compileMain$10,
    }),
    rootPaths: $rootPaths,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $entryUsr,
      $io,
      $makePlatformUmr,
      $pars,
    ]),
    usr: u0$BuildMain$compileMain$11,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $entryUsr,
      $io,
      $makePlatformUmr,
      $pars,
    ]),
    usr: u0$BuildMain$compileMain$11,
  })).ctx), (u0$Compiler$LazyBuild$build$0.usr)(...(u0$Compiler$LazyBuild$build$0.ctx), ({
    loadCaModule: ({
      ctx: ([
        $loadCaModulePars,
      ]),
      usr: u0$BuildMain$compileMain$14,
    }),
    projectImports: $projectImports,
    requiredUsrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $entryUsr, ($pars.platform.extraRequiredUsrs.usr)(...($pars.platform.extraRequiredUsrs.ctx), $makePlatformUmr)),
  })));
});

const u0$BuildMain$compileMain$4 = (($io, $pars, $projectImports, $rootPaths, $state, $entryUsr) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $entryUsr,
      $io,
      $pars,
      $projectImports,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $entryUsr,
      $io,
      $pars,
      $projectImports,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$5,
  })).ctx), (c0$Maybe$toResult$0.usr)(...(c0$Maybe$toResult$0.ctx), (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (("project imports.sp does not specify a '" + $pars.platform.name) + "' platform."), c0$Core$Nil$0)), (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $pars.platform.name, $projectImports.platforms)));
});

const u0$BuildMain$compileMain$3 = (($io, $pars, $rootPaths, $state, $projectImports) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $pars,
      $projectImports,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $pars,
      $projectImports,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$4,
  })).ctx), (u0$BuildMain$getEntryUsr$0.usr)(...(u0$BuildMain$getEntryUsr$0.ctx), $projectImports, $pars.entryPoint));
});

const u0$BuildMain$compileMain$2 = (($1) => {
  const $isDirectory = $1.first;
  const $fileName = $1.second;
  return ((c0$Basics$not$0.usr)(...(c0$Basics$not$0.ctx), $isDirectory) && (sp_equal)($fileName, u0$BuildMain$importsFileName$0));
});

const u0$BuildMain$compileMain$1 = (($io, $pars) => {
  const $projectRoot = (c0$Maybe$withDefault$0.usr)(...(c0$Maybe$withDefault$0.ctx), ".", (u0$BuildMain$searchAncestorDirectories$0.usr)(...(u0$BuildMain$searchAncestorDirectories$0.ctx), $io, ({
    ctx: [],
    usr: u0$BuildMain$compileMain$2,
  }), "."));
  (io_writeStdout)($io, (("Project root is " + (path_resolve)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $projectRoot, c0$Core$Nil$0))) + "\n"));
  const $importsPath = (c0$Compiler$Meta$ImportsPath$0.usr)(...(c0$Compiler$Meta$ImportsPath$0.ctx), c0$Compiler$Meta$User$0, "");
  const $corelibPath = ((() => {
    const $3 = $pars.corelib;
    return ((($3)[0] === "$Just")
      ? ((() => {
        const $corelib = ($3)[1];
        return $corelib;
      }))()
      : ((($3)[0] === "$Nothing")
        ? ((() => {
          const $executablePath = (path_dirname)((path_resolve)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $pars.selfPath, c0$Core$Nil$0)));
          return (path_join)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $executablePath, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$BuildMain$defaultCorelibDir$0, c0$Core$Nil$0)));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/BuildMain.sp 402:8', (sp_toHuman)($3))));
  }))();
  const $rootPaths = ({
    core: $corelibPath,
    installed: (path_join)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $projectRoot, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$BuildMain$installedDir$0, c0$Core$Nil$0))),
    project: $projectRoot,
  });
  let $state = ({
    idToSourcePath: (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: u0$Compiler$CoreDefs$pathId$0,
      second: ({
        importsDir: u0$Compiler$CoreDefs$importsDir$0,
        sourceDir: u0$Compiler$CoreDefs$sourceDir$0,
      }),
    }), c0$Core$Nil$0)),
    loadedExports: (hash_fromList)(c0$Core$Nil$0),
    loadedImports: (hash_fromList)(c0$Core$Nil$0),
    nextId: (u0$Compiler$CoreDefs$pathId$0 + 1),
    sourcePathToId: (hash_fromList)((c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: ({
        importsDir: u0$Compiler$CoreDefs$importsDir$0,
        sourceDir: u0$Compiler$CoreDefs$sourceDir$0,
      }),
      second: u0$Compiler$CoreDefs$pathId$0,
    }), c0$Core$Nil$0)),
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $pars,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $pars,
      $rootPaths,
      $state,
    ]),
    usr: u0$BuildMain$compileMain$3,
  })).ctx), (u0$BuildMain$loadImports$0.usr)(...(u0$BuildMain$loadImports$0.ctx), $io, $state, $rootPaths, $importsPath));
});

const u0$BuildMain$compileMain$0 = ({
  ctx: [],
  usr: u0$BuildMain$compileMain$1,
});

const u0$Compiler$Error$breakDownText$2 = (($index, $snippet) => {
  return ((sp_equal)((basics_modBy)(2, $index), 0)
    ? (u0$Compiler$Error$FormattedText_Default$0.usr)(...(u0$Compiler$Error$FormattedText_Default$0.ctx), $snippet)
    : ((() => {
      const $3 = (text_split)(u0$Compiler$Error$formatSuffix$0, $snippet);
      return (((($3)[0] === "$Cons") && (("emphasys" === ($3)[1]) && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil"))))
        ? ((() => {
          const $s = (($3)[2])[1];
          return (u0$Compiler$Error$FormattedText_Emphasys$0.usr)(...(u0$Compiler$Error$FormattedText_Emphasys$0.ctx), $s);
        }))()
        : (((($3)[0] === "$Cons") && (("warning" === ($3)[1]) && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil"))))
          ? ((() => {
            const $s = (($3)[2])[1];
            return (u0$Compiler$Error$FormattedText_Warning$0.usr)(...(u0$Compiler$Error$FormattedText_Warning$0.ctx), $s);
          }))()
          : (((($3)[0] === "$Cons") && (("decoration" === ($3)[1]) && (((($3)[2])[0] === "$Cons") && (((($3)[2])[2])[0] === "$Nil"))))
            ? ((() => {
              const $s = (($3)[2])[1];
              return (u0$Compiler$Error$FormattedText_Decoration$0.usr)(...(u0$Compiler$Error$FormattedText_Decoration$0.ctx), $s);
            }))()
            : (true
              ? (u0$Compiler$Error$FormattedText_Default$0.usr)(...(u0$Compiler$Error$FormattedText_Default$0.ctx), $snippet)
              : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 76:12', (sp_toHuman)($3))))));
    }))());
});

const u0$Compiler$Error$breakDownText$1 = (($text) => {
  const $formatSnippet = ({
    ctx: [],
    usr: u0$Compiler$Error$breakDownText$2,
  });
  return (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), $formatSnippet, (text_split)(u0$Compiler$Error$formatSeparator$0, $text));
});

const u0$Compiler$Error$breakDownText$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$breakDownText$1,
});

const u0$Compiler$Error$count$2 = (($err, $total) => {
  return ($total + (u0$Compiler$Error$count$0.usr)(...(u0$Compiler$Error$count$0.ctx), $err));
});

const u0$Compiler$Error$count$1 = (($e) => {
  return ((($e)[0] === "$Simple")
    ? ((() => {
      const $mod = ($e)[1];
      const $pos = ($e)[2];
      const $desc = ($e)[3];
      return 1;
    }))()
    : ((($e)[0] === "$Raw")
      ? ((() => {
        const $desc = ($e)[1];
        return 1;
      }))()
      : ((($e)[0] === "$Nested")
        ? ((() => {
          const $ls = ($e)[1];
          return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), 0, $ls, ({
            ctx: [],
            usr: u0$Compiler$Error$count$2,
          }));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 47:4', (sp_toHuman)($e)))));
});

const u0$Compiler$Error$count$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$count$1,
});

const u0$Compiler$Error$deco$1 = (($0) => {
  return (u0$Compiler$Error$formatWrap$0.usr)(...(u0$Compiler$Error$formatWrap$0.ctx), "decoration", $0);
});

const u0$Compiler$Error$deco$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$deco$1,
});

const u0$Compiler$Error$rawToText$3 = (($s) => {
  return ("  " + $s);
});

const u0$Compiler$Error$rawToText$2 = (($0) => {
  return (text_split)("\n", $0);
});

const u0$Compiler$Error$rawToText$1 = (($desc) => {
  const $description = (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Error$rawToText$3,
  }), (c0$List$concatMap$0.usr)(...(c0$List$concatMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Error$rawToText$2,
  }), $desc)));
  return (u0$Compiler$Error$breakDownText$0.usr)(...(u0$Compiler$Error$breakDownText$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $description, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", c0$Core$Nil$0))))));
});

const u0$Compiler$Error$rawToText$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$rawToText$1,
});

const u0$Compiler$Error$simpleToText$3 = (($s) => {
  return ("  " + $s);
});

const u0$Compiler$Error$simpleToText$2 = (($0) => {
  return (text_split)("\n", $0);
});

const u0$Compiler$Error$simpleToText$1 = (($mod, $pos, $desc) => {
  const $4 = (u0$Compiler$Error$posToHuman$0.usr)(...(u0$Compiler$Error$posToHuman$0.ctx), $mod, $pos);
  const $location = $4.location;
  const $block = $4.block;
  const $description = (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Error$simpleToText$3,
  }), (c0$List$concatMap$0.usr)(...(c0$List$concatMap$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Error$simpleToText$2,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $block, $desc))));
  return (u0$Compiler$Error$breakDownText$0.usr)(...(u0$Compiler$Error$breakDownText$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Error$deco$0.usr)(...(u0$Compiler$Error$deco$0.ctx), (c0$Text$padLeft$0.usr)(...(c0$Text$padLeft$0.ctx), 79, "=", (" " + $location))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $description, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", c0$Core$Nil$0))))))));
});

const u0$Compiler$Error$simpleToText$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$simpleToText$1,
});

const u0$Compiler$Error$flatten$1 = (($e, $accum) => {
  return ((($e)[0] === "$Simple")
    ? ((() => {
      const $mod = ($e)[1];
      const $pos = ($e)[2];
      const $desc = ($e)[3];
      return (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $accum, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Error$simpleToText$0.usr)(...(u0$Compiler$Error$simpleToText$0.ctx), $mod, $pos, $desc), c0$Core$Nil$0)));
    }))()
    : ((($e)[0] === "$Raw")
      ? ((() => {
        const $desc = ($e)[1];
        return (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $accum, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Error$rawToText$0.usr)(...(u0$Compiler$Error$rawToText$0.ctx), $desc), c0$Core$Nil$0)));
      }))()
      : ((($e)[0] === "$Nested")
        ? ((() => {
          const $ls = ($e)[1];
          return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $accum, $ls, u0$Compiler$Error$flatten$0);
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Error.sp 39:4', (sp_toHuman)($e)))));
});

const u0$Compiler$Error$flatten$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$flatten$1,
});

const u0$Compiler$Error$toFormattedText$1 = (($0) => {
  return (u0$Compiler$Error$flatten$0.usr)(...(u0$Compiler$Error$flatten$0.ctx), $0, c0$Core$Nil$0);
});

const u0$Compiler$Error$toFormattedText$0 = ({
  ctx: [],
  usr: u0$Compiler$Error$toFormattedText$1,
});

const u0$Compiler$Lexer_Test$codeTest$1 = (($0, $1, $2, $3) => {
  return (i2$Test$codeTest$0.usr)(...(i2$Test$codeTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2, $3);
});

const u0$Compiler$Lexer_Test$codeTest$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$codeTest$1,
});

const u0$Compiler$TestHelpers$errorModule$1 = (($content) => {
  return ({
    content: $content,
    fsPath: "<Test>",
  });
});

const u0$Compiler$TestHelpers$errorModule$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$errorModule$1,
});

const u0$Compiler$TestHelpers$formattedToStrippedText$2 = (($fmt) => {
  return ((($fmt)[0] === "$FormattedText_Default")
    ? ((() => {
      const $t = ($fmt)[1];
      return $t;
    }))()
    : ((($fmt)[0] === "$FormattedText_Emphasys")
      ? ((() => {
        const $t = ($fmt)[1];
        return $t;
      }))()
      : ((($fmt)[0] === "$FormattedText_Warning")
        ? ((() => {
          const $t = ($fmt)[1];
          return $t;
        }))()
        : ((($fmt)[0] === "$FormattedText_Decoration")
          ? ((() => {
            const $t = ($fmt)[1];
            return $t;
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 37:8', (sp_toHuman)($fmt))))));
});

const u0$Compiler$TestHelpers$formattedToStrippedText$1 = (($formatted) => {
  const $strip = ({
    ctx: [],
    usr: u0$Compiler$TestHelpers$formattedToStrippedText$2,
  });
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), $strip, $formatted));
});

const u0$Compiler$TestHelpers$formattedToStrippedText$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$formattedToStrippedText$1,
});

const u0$Compiler$TestHelpers$errorToStrippedText$1 = (($0) => {
  return (u0$Compiler$TestHelpers$formattedToStrippedText$0.usr)(...(u0$Compiler$TestHelpers$formattedToStrippedText$0.ctx), (u0$Compiler$Error$toFormattedText$0.usr)(...(u0$Compiler$Error$toFormattedText$0.ctx), $0));
});

const u0$Compiler$TestHelpers$errorToStrippedText$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$errorToStrippedText$1,
});

const u0$Compiler$TestHelpers$resErrorToStrippedText$1 = (($0) => {
  return (c0$Result$mapError$0.usr)(...(c0$Result$mapError$0.ctx), u0$Compiler$TestHelpers$errorToStrippedText$0, $0);
});

const u0$Compiler$TestHelpers$resErrorToStrippedText$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$resErrorToStrippedText$1,
});

const u0$Compiler$Lexer_Test$lexTokens$1 = (($s) => {
  return (u0$Compiler$TestHelpers$resErrorToStrippedText$0.usr)(...(u0$Compiler$TestHelpers$resErrorToStrippedText$0.ctx), (u0$Compiler$Lexer$lexer$0.usr)(...(u0$Compiler$Lexer$lexer$0.ctx), true, (u0$Compiler$TestHelpers$errorModule$0.usr)(...(u0$Compiler$TestHelpers$errorModule$0.ctx), $s)));
});

const u0$Compiler$Lexer_Test$lexTokens$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$lexTokens$1,
});

const u0$Compiler$Lexer_Test$lexTokensAndDrop$4 = (($name, $0) => {
  return (c0$List$drop$0.usr)(...(c0$List$drop$0.ctx), $name, $0);
});

const u0$Compiler$Lexer_Test$lexTokensAndDrop$3 = (($name, $0) => {
  return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $name,
    ]),
    usr: u0$Compiler$Lexer_Test$lexTokensAndDrop$4,
  }), $0);
});

const u0$Compiler$Lexer_Test$lexTokensAndDrop$2 = (($name, $s) => {
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), ({
    ctx: ([
      $name,
    ]),
    usr: u0$Compiler$Lexer_Test$lexTokensAndDrop$3,
  }), (u0$Compiler$Lexer_Test$lexTokens$0.usr)(...(u0$Compiler$Lexer_Test$lexTokens$0.ctx), $s));
});

const u0$Compiler$Lexer_Test$lexTokensAndDrop$1 = (($name) => {
  return ({
    ctx: ([
      $name,
    ]),
    usr: u0$Compiler$Lexer_Test$lexTokensAndDrop$2,
  });
});

const u0$Compiler$Lexer_Test$lexTokensAndDrop$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$lexTokensAndDrop$1,
});

const u0$Compiler$Lexer_Test$lowerName$1 = (($name) => {
  return (c0$Compiler$Token$Lowercase$0.usr)(...(c0$Compiler$Token$Lowercase$0.ctx), ({
    attrPath: c0$Core$Nil$0,
    maybeModule: c0$Maybe$Nothing$0,
    name: $name,
  }));
});

const u0$Compiler$Lexer_Test$lowerName$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$lowerName$1,
});

const u0$Compiler$Lexer_Test$comments$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Comments", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] statement after comment", "\n#\na = 1\n", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Core$Nil$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 3, 4, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 5, 6, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 7, 8, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), false, "1")), c0$Core$Nil$0))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] nested comments allow a spurious newline?", "\n[#[##]#]\na = 1\n", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 9, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: false,
}))), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 10, 10, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 10, 11, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 12, 13, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 14, 15, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), false, "1")), c0$Core$Nil$0)))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "Single line", "# hello", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 7, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 0,
  isBlock: false,
  isFollowedByBlank: false,
}))), c0$Core$Nil$0), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "Multi line", "[# single line #]\n\na [# inline #] = 1\n\n[#\n    multi line\n#]\n\n[# [# nested #] #]", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 17, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: true,
}))), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 19, 19, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 19, 20, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 21, 33, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 2,
  isBlock: true,
  isFollowedByBlank: false,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 34, 35, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 36, 37, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), false, "1")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 39, 59, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: true,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 61, 79, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 0,
  isBlock: true,
  isFollowedByBlank: false,
}))), c0$Core$Nil$0))))))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "brackets", "[]", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 1, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), 0, c0$Compiler$Token$Open$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 2, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), 0, c0$Compiler$Token$Closed$0)), c0$Core$Nil$0)), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] Inline comments should not break a block", "allTests = [\n    , a\n#\n    ]", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 0, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 8, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "allTests")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 9, 10, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 11, 12, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), 0, c0$Compiler$Token$Open$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 17, 18, c0$Compiler$Token$Comma$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 19, 20, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 21, 22, (c0$Compiler$Token$Comment$0.usr)(...(c0$Compiler$Token$Comment$0.ctx), ({
  indent: 0,
  isBlock: false,
  isFollowedByBlank: false,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 27, 28, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), 3, c0$Compiler$Token$Closed$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 28, 28, c0$Compiler$Token$BlockEnd$0), c0$Core$Nil$0))))))))), c0$Core$Nil$0))), c0$Core$Nil$0)))))));

const u0$Compiler$Lexer_Test$upperName$1 = (($name) => {
  return (c0$Compiler$Token$Uppercase$0.usr)(...(c0$Compiler$Token$Uppercase$0.ctx), ({
    maybeModule: c0$Maybe$Nothing$0,
    name: $name,
  }));
});

const u0$Compiler$Lexer_Test$upperName$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$upperName$1,
});

const u0$Compiler$Lexer_Test$indentation$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Blocks, sibling lines, indentation", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "1", "\na =\n 1\nb = 1", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 1, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 2, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 3, 4, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 6, 6, c0$Compiler$Token$BlockStart$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 6, 7, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), false, "1")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 8, 8, c0$Compiler$Token$BlockEnd$0), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 8, 8, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 8, 9, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "b")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 10, 11, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 12, 13, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), false, "1")), c0$Core$Nil$0)))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] spurious spaces in front of field name", "module =\n   importAs =\n      SPCore\n   globalTypes =\n      None", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 0, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 6, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "module")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 7, 8, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 12, 12, c0$Compiler$Token$BlockStart$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 12, 20, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "importAs")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 21, 22, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 29, 29, c0$Compiler$Token$BlockStart$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 29, 35, (u0$Compiler$Lexer_Test$upperName$0.usr)(...(u0$Compiler$Lexer_Test$upperName$0.ctx), "SPCore")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 39, 39, c0$Compiler$Token$BlockEnd$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 39, 39, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 39, 50, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "globalTypes")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 51, 52, c0$Compiler$Token$Defop$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 59, 59, c0$Compiler$Token$BlockStart$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 59, 63, (u0$Compiler$Lexer_Test$upperName$0.usr)(...(u0$Compiler$Lexer_Test$upperName$0.ctx), "None")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 63, 63, c0$Compiler$Token$BlockEnd$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 63, 63, c0$Compiler$Token$BlockEnd$0), c0$Core$Nil$0)))))))))))))))), c0$Core$Nil$0))), c0$Core$Nil$0)));

const u0$Compiler$Lexer_Test$names$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Names", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] Simple record access", "a.b", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 3, (c0$Compiler$Token$Lowercase$0.usr)(...(c0$Compiler$Token$Lowercase$0.ctx), ({
  attrPath: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", c0$Core$Nil$0),
  maybeModule: c0$Maybe$Nothing$0,
  name: "a",
}))), c0$Core$Nil$0), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] Nested record access", "a.b.c", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 5, (c0$Compiler$Token$Lowercase$0.usr)(...(c0$Compiler$Token$Lowercase$0.ctx), ({
  attrPath: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", c0$Core$Nil$0)),
  maybeModule: c0$Maybe$Nothing$0,
  name: "a",
}))), c0$Core$Nil$0), c0$Core$Nil$0))), c0$Core$Nil$0)));

const u0$Compiler$Lexer_Test$numberLiterals$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Number literals", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "Percent", "10%", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 2, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), true, "10")), c0$Core$Nil$0), c0$Core$Nil$0))), c0$Core$Nil$0));

const u0$Compiler$Lexer_Test$ops$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Operators", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] .. set Default", ".. []", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 3, (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), 0, u0$Compiler$CoreDefs$textConcat$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 3, 4, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), 0, c0$Compiler$Token$Open$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 4, 5, (c0$Compiler$Token$SquareBracket$0.usr)(...(c0$Compiler$Token$SquareBracket$0.ctx), 0, c0$Compiler$Token$Closed$0)), c0$Core$Nil$0))), c0$Core$Nil$0))), c0$Core$Nil$0));

const u0$Compiler$Lexer_Test$position$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Position", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] ops position", "blah <>", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "blah <>", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] ops position, with newline", "blah <>\n", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "blah <>", c0$Core$Nil$0))), c0$Core$Nil$0)));

const u0$Compiler$Lexer_Test$recordLiterals$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Record literals", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "[reg] .shorthand should work on its own line", "x =\n  .b", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 3), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 6, 6, c0$Compiler$Token$BlockStart$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 6, 8, (c0$Compiler$Token$RecordShorthand$0.usr)(...(c0$Compiler$Token$RecordShorthand$0.ctx), ({
  attrPath: c0$Core$Nil$0,
  name: "b",
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 8, 8, c0$Compiler$Token$BlockEnd$0), c0$Core$Nil$0))), c0$Core$Nil$0))), c0$Core$Nil$0));

const u0$Compiler$Lexer_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const u0$Compiler$Lexer_Test$valueTest$0 = ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$valueTest$1,
});

const u0$Compiler$Lexer_Test$textLiterals$1 = ((_0) => {
  return (u0$Compiler$Lexer$unindent$0.usr)(...(u0$Compiler$Lexer$unindent$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "  a\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "      \n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "  b\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "  ", c0$Core$Nil$0))))))));
});

const u0$Compiler$Lexer_Test$textLiterals$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Text literals", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "Empty Text", "\"\"", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 0, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 2, (c0$Compiler$Token$TextLiteral$0.usr)(...(c0$Compiler$Token$TextLiteral$0.ctx), c0$Compiler$Token$SingleQuote$0, "")), c0$Core$Nil$0)), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "Followed by colon", "\"n\":\n", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 0, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 3, (c0$Compiler$Token$TextLiteral$0.usr)(...(c0$Compiler$Token$TextLiteral$0.ctx), c0$Compiler$Token$SingleQuote$0, "n")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 3, 4, c0$Compiler$Token$Colon$0), c0$Core$Nil$0))), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$valueTest$0.usr)(...(u0$Compiler$Lexer_Test$valueTest$0.ctx), "Unindent function", ({
  ctx: [],
  usr: u0$Compiler$Lexer_Test$textLiterals$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    \n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", c0$Core$Nil$0))))))), c0$Core$Nil$0))));

const u0$Compiler$Lexer_Test$unaryAddittiveOps$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Unary addittive ops", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "-a", "-a", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 1, (c0$Compiler$Token$Unop$0.usr)(...(c0$Compiler$Token$Unop$0.ctx), c0$Compiler$Op$UnopMinus$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 2, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), c0$Core$Nil$0)), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "a - -a", "a - -a", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 1, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 2, 3, (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), 0, u0$Compiler$CoreDefs$subtract$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 4, 5, (c0$Compiler$Token$Unop$0.usr)(...(c0$Compiler$Token$Unop$0.ctx), c0$Compiler$Op$UnopMinus$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 5, 6, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), c0$Core$Nil$0)))), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "SKIP a-a", "a-a", u0$Compiler$Lexer_Test$lexTokens$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 0, c0$Compiler$Token$NewSiblingLine$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 1, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 1, 2, (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), 1, u0$Compiler$CoreDefs$subtract$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 2, 3, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "a")), c0$Core$Nil$0)))), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "-=", "-=", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 2, (c0$Compiler$Token$Binop$0.usr)(...(c0$Compiler$Token$Binop$0.ctx), 0, u0$Compiler$CoreDefs$mutableSubtract$0)), c0$Core$Nil$0), c0$Core$Nil$0))), c0$Core$Nil$0)))));

const u0$Compiler$Lexer_Test$underscores$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Underscores", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "'_' as a Name", "_", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 1, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "_")), c0$Core$Nil$0), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "'_10_20' as a Name", "_10_20", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 6, (u0$Compiler$Lexer_Test$lowerName$0.usr)(...(u0$Compiler$Lexer_Test$lowerName$0.ctx), "_10_20")), c0$Core$Nil$0), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Lexer_Test$codeTest$0.usr)(...(u0$Compiler$Lexer_Test$codeTest$0.ctx), "'10_20' as a Number", "10_20", (u0$Compiler$Lexer_Test$lexTokensAndDrop$0.usr)(...(u0$Compiler$Lexer_Test$lexTokensAndDrop$0.ctx), 1), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$Token$Token$0.usr)(...(c0$Compiler$Token$Token$0.ctx), 0, 5, (c0$Compiler$Token$NumberLiteral$0.usr)(...(c0$Compiler$Token$NumberLiteral$0.ctx), false, "10_20")), c0$Core$Nil$0), c0$Core$Nil$0))), c0$Core$Nil$0))));

const u0$Compiler$Lexer_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Lexer", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$names$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$ops$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$unaryAddittiveOps$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$indentation$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$comments$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$underscores$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$position$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$textLiterals$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$numberLiterals$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$recordLiterals$0, c0$Core$Nil$0)))))))))));

const u0$Compiler$MakeCanonical_Test$codeTest$1 = (($0, $1, $2, $3) => {
  return (i2$Test$codeTest$0.usr)(...(i2$Test$codeTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2, $3);
});

const u0$Compiler$MakeCanonical_Test$codeTest$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$codeTest$1,
});

const u0$Compiler$TestHelpers$importsPath$0 = (c0$Compiler$Meta$ImportsPath$0.usr)(...(c0$Compiler$Meta$ImportsPath$0.ctx), c0$Compiler$Meta$User$0, "<testImportsPath/>");

const u0$DefaultImports$mod$1 = (($path, $globals) => {
  return ({
    globals: $globals,
    path: $path,
    visibleAs: $path,
  });
});

const u0$DefaultImports$mod$0 = ({
  ctx: [],
  usr: u0$DefaultImports$mod$1,
});

const u0$DefaultImports$defaultImportsFile$0 = ({
  libraries: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    modules: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Core", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "None", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Bool", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Text", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Number", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'none", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'true", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'false", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "mut", c0$Core$Nil$0))))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Basics", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Int", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "assert", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "clamp", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "identity", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "modBy", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "min", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "max", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "cloneImm", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "cloneUni", c0$Core$Nil$0)))))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Text", c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Tuple", c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Debug", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "log", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "todo", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Self", c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "List", c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Dict", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Dict", c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Array", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Array", c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Hash", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Hash", c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Set", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Set", c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Maybe", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Maybe", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'just", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'nothing", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), "Result", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Result", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'ok", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "'err", c0$Core$Nil$0)))), c0$Core$Nil$0))))))))))))),
    platform: "",
    source: "core",
  }), c0$Core$Nil$0),
  sourceDirs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    modules: c0$Core$Nil$0,
    path: ".",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    modules: c0$Core$Nil$0,
    path: "src/",
  }), c0$Core$Nil$0)),
});

const u0$Compiler$TestHelpers$imports$1 = (($importsDir, $sourceDir) => {
  return 1;
});

const u0$Compiler$TestHelpers$imports$0 = ((() => {
  const $pars = ({
    getSourceDirId: ({
      ctx: [],
      usr: u0$Compiler$TestHelpers$imports$1,
    }),
    importsPath: u0$Compiler$TestHelpers$importsPath$0,
    joinPath: ({
      ctx: [],
      usr: path_join,
    }),
  });
  const $1 = (u0$ImportsFile$toImports$0.usr)(...(u0$ImportsFile$toImports$0.ctx), $pars, u0$DefaultImports$defaultImportsFile$0);
  return ((($1)[0] === "$Err")
    ? ((() => {
      const $e = ($1)[1];
      (sp_log)("Error in DefaultImports.sp: ", $e);
      return (sp_todo)("error loading DefaultImports.sp");
    }))()
    : ((($1)[0] === "$Ok")
      ? ((() => {
        const $m = ($1)[1];
        return $m;
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 69:4', (sp_toHuman)($1))));
}))();

const u0$Compiler$TestHelpers$moduleUmr$0 = (c0$Compiler$Meta$UMR$0.usr)(...(c0$Compiler$Meta$UMR$0.ctx), c0$Compiler$Meta$User$0, 0, "<TestModulePath>");

const u0$Compiler$TestHelpers$exports$0 = ((() => {
  const $isOpen = false;
  return (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "Core", (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "None",
    second: ({
      isOpen: true,
      usr: u0$Compiler$CoreDefs$noneTypeUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "'none",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$noneConsUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "Bool",
    second: ({
      isOpen: true,
      usr: u0$Compiler$CoreDefs$boolUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "'true",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$trueUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "'false",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$falseUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "List",
    second: ({
      isOpen: true,
      usr: u0$Compiler$CoreDefs$listUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "'nil",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$nilUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "'cons",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$consUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "Text",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$textUsr$0,
    }),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "Number",
    second: ({
      isOpen: $isOpen,
      usr: u0$Compiler$CoreDefs$numberUsr$0,
    }),
  }), c0$Core$Nil$0))))))))))));
}))();

const u0$Compiler$TestHelpers$loadExports$1 = (($ip) => {
  return (((($ip)[0] === "$ImportsPath") && (((($ip)[1])[0] === "$Core") && ("" === ($ip)[2])))
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), u0$Compiler$TestHelpers$exports$0)
    : (true
      ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TestHelpers: trying to load an unknown export:", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)($ip), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "", c0$Core$Nil$0))))))
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TestHelpers.sp 111:4', (sp_toHuman)($ip))));
});

const u0$Compiler$TestHelpers$loadExports$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$loadExports$1,
});

const u0$Compiler$TestHelpers$resolvePars$1 = (($0) => {
  return (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), $0);
});

const u0$Compiler$TestHelpers$resolvePars$0 = ({
  currentImports: u0$Compiler$TestHelpers$imports$0,
  currentModule: u0$Compiler$TestHelpers$moduleUmr$0,
  loadExports: u0$Compiler$TestHelpers$loadExports$0,
  makeError: ({
    ctx: [],
    usr: u0$Compiler$TestHelpers$resolvePars$1,
  }),
});

const u0$Compiler$TestHelpers$resolveToUsr$1 = (($pos, $maybeModule, $name) => {
  return (c0$Compiler$Meta$resolve$0.usr)(...(c0$Compiler$Meta$resolve$0.ctx), u0$Compiler$TestHelpers$resolvePars$0, $maybeModule, $name);
});

const u0$Compiler$TestHelpers$resolveToUsr$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$resolveToUsr$1,
});

const u0$Compiler$MakeCanonical_Test$params$1 = (($errorModule) => {
  return ({
    errorModule: $errorModule,
    imports: u0$Compiler$TestHelpers$imports$0,
    resolveToUsr: u0$Compiler$TestHelpers$resolveToUsr$0,
    umr: u0$Compiler$TestHelpers$moduleUmr$0,
  });
});

const u0$Compiler$MakeCanonical_Test$params$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$params$1,
});

const u0$Compiler$MakeCanonical_Test$textToModule$1 = (($code) => {
  return (u0$Compiler$TestHelpers$resErrorToStrippedText$0.usr)(...(u0$Compiler$TestHelpers$resErrorToStrippedText$0.ctx), (u0$Compiler$MakeCanonical$textToCanonicalModule$0.usr)(...(u0$Compiler$MakeCanonical$textToCanonicalModule$0.ctx), true, (u0$Compiler$MakeCanonical_Test$params$0.usr)(...(u0$Compiler$MakeCanonical_Test$params$0.ctx), (u0$Compiler$TestHelpers$errorModule$0.usr)(...(u0$Compiler$TestHelpers$errorModule$0.ctx), $code))));
});

const u0$Compiler$MakeCanonical_Test$textToModule$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$textToModule$1,
});

const u0$Compiler$MakeCanonical_Test$firstDefinition$2 = (($mod) => {
  return (c0$Result$fromMaybe$0.usr)(...(c0$Result$fromMaybe$0.ctx), "firstDefinition fail", (c0$List$head$0.usr)(...(c0$List$head$0.ctx), (c0$Dict$values$0.usr)(...(c0$Dict$values$0.ctx), $mod.valueDefs)));
});

const u0$Compiler$MakeCanonical_Test$firstDefinition$1 = (($code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$firstDefinition$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$firstDefinition$2,
  })).ctx), (u0$Compiler$MakeCanonical_Test$textToModule$0.usr)(...(u0$Compiler$MakeCanonical_Test$textToModule$0.ctx), $code));
});

const u0$Compiler$MakeCanonical_Test$firstDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$firstDefinition$1,
});

const u0$Compiler$MakeCanonical_Test$firstEvaluation$3 = (($def) => {
  return (c0$Maybe$toResult$0.usr)(...(c0$Maybe$toResult$0.ctx), "body is 'nothing", $def.maybeBody);
});

const u0$Compiler$MakeCanonical_Test$firstEvaluation$2 = (($code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$firstEvaluation$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$firstEvaluation$3,
  })).ctx), (u0$Compiler$MakeCanonical_Test$firstDefinition$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstDefinition$0.ctx), $code));
});

const u0$Compiler$MakeCanonical_Test$firstEvaluation$1 = (($name) => {
  return ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$firstEvaluation$2,
  });
});

const u0$Compiler$MakeCanonical_Test$firstEvaluation$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$firstEvaluation$1,
});

const u0$Compiler$MakeCanonical_Test$annotations$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Annotations", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "annotation on unique value", "x =\n  !a as Number =\n    3\n  a", u0$Compiler$MakeCanonical_Test$firstDefinition$0, i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "annotation on immutable value", "b as Number =\n  3", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "annotation of recycling function", "b as fn @List a: !List a =\n  3", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), i2$Test$isOk$0), c0$Core$Nil$0))));

const u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$2 = (($v) => {
  const $0 = $v;
  return (Object.assign)({}, $0, ({
    directDeps: c0$Dict$empty$0,
  }));
});

const u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$1 = (($0) => {
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$2,
  }), (u0$Compiler$MakeCanonical_Test$firstDefinition$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstDefinition$0.ctx), $0));
});

const u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$1,
});

const u0$Compiler$MakeCanonical_Test$p$0 = c0$Compiler$Pos$T$0;

const u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$2 = (($getter, $1) => {
  const $a = $1.first;
  const $b = $1.second;
  return ((sp_equal)(($getter.usr)(...($getter.ctx), $a), ($getter.usr)(...($getter.ctx), $b))
    ? c0$Maybe$Nothing$0
    : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "The two don't match:", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)(($getter.usr)(...($getter.ctx), $a)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (sp_toHuman)(($getter.usr)(...($getter.ctx), $b)), c0$Core$Nil$0))))));
});

const u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$1 = (($getter) => {
  return (i2$Test$freeform$0.usr)(...(i2$Test$freeform$0.ctx), ({
    ctx: ([
      $getter,
    ]),
    usr: u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$2,
  }));
});

const u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$1,
});

const u0$Compiler$MakeCanonical_Test$transformAB$4 = (($findAB, $x) => {
  return (c0$Result$fromMaybe$0.usr)(...(c0$Result$fromMaybe$0.ctx), "findAB fail", ($findAB.usr)(...($findAB.ctx), $x));
});

const u0$Compiler$MakeCanonical_Test$transformAB$3 = (($def) => {
  return $def.name;
});

const u0$Compiler$MakeCanonical_Test$transformAB$2 = (($mod) => {
  const $2 = (list_sortBy)(({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$transformAB$3,
  }), (c0$Dict$values$0.usr)(...(c0$Dict$values$0.ctx), $mod.valueDefs));
  return (((($2)[0] === "$Cons") && (((($2)[2])[0] === "$Cons") && (((($2)[2])[2])[0] === "$Nil")))
    ? ((() => {
      const $a = ($2)[1];
      const $b = (($2)[2])[1];
      return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
        first: $a,
        second: $b,
      }));
    }))()
    : (true
      ? c0$Maybe$Nothing$0
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical_Test.sp 82:8', (sp_toHuman)($2))));
});

const u0$Compiler$MakeCanonical_Test$transformAB$1 = (($code) => {
  const $findAB = ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$transformAB$2,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $findAB,
    ]),
    usr: u0$Compiler$MakeCanonical_Test$transformAB$4,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $findAB,
    ]),
    usr: u0$Compiler$MakeCanonical_Test$transformAB$4,
  })).ctx), (u0$Compiler$MakeCanonical_Test$textToModule$0.usr)(...(u0$Compiler$MakeCanonical_Test$textToModule$0.ctx), $code));
});

const u0$Compiler$MakeCanonical_Test$transformAB$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$transformAB$1,
});

const u0$Compiler$TestHelpers$moduleUsr$1 = (($0) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), u0$Compiler$TestHelpers$moduleUmr$0, $0);
});

const u0$Compiler$TestHelpers$moduleUsr$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$moduleUsr$1,
});

const u0$Compiler$MakeCanonical_Test$argumentPlaceholders$3 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$argumentPlaceholders$2 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$argumentPlaceholders$1 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$argumentPlaceholders$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Argument placeholders", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Base", "f = f __ __", u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: c0$Maybe$Nothing$0,
  maybeBody: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 1), c0$Core$Nil$0)), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "f"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 1))), c0$Core$Nil$0))))),
  name: "f",
  namePos: u0$Compiler$MakeCanonical_Test$p$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Pipelines work with placeholders", "f = __ >> a >> b", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "f"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 0), c0$Core$Nil$0), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "b"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 0))), c0$Core$Nil$0))), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "try..as", "f = try __ as \"\": 1", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "f"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 0), c0$Core$Nil$0), (c0$Compiler$CanonicalAst$Try$0.usr)(...(c0$Compiler$CanonicalAst$Try$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, ({
  patternsAndExpressions: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: c0$Compiler$Ast$Imm$0,
    second: (c0$Compiler$CanonicalAst$PatternLiteralText$0.usr)(...(c0$Compiler$CanonicalAst$PatternLiteralText$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, ""),
    third: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1),
  }), c0$Core$Nil$0),
  value: (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 0)),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Simple placeholder gets inlined", "a = v >> blah __\nb = blah v", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$argumentPlaceholders$3,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Pipeline with placeholders gets inlined", "a = v >> blah x __ y >> z a __\nb = z a (blah x v y)", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$argumentPlaceholders$2,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Multiple placeholders get inlined", "a = (blah x __ y __) p q\nb = blah x p y q", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$argumentPlaceholders$1,
}))), c0$Core$Nil$0)))))));

const u0$Compiler$MakeCanonical_Test$binops$7 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$6 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$5 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$4 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$3 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$2 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$1 = (($x) => {
  return $x.maybeBody;
});

const u0$Compiler$MakeCanonical_Test$binops$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Binops", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "left associativity", "a = v >> f >> g\nb = (v >> f) >> g", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$7,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "[reg] minus should be left-associative", "a = x - y - z\nb = (x - y) - z", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$6,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "[reg] division should be left-associative", "a = x / y / z\nb = (x / y) / z", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$5,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "right associativity", "a = v :: f :: g\nb = v :: (f :: g)", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$4,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "precedence", "a = 1 + 2 * 3 + 4\nb = 1 + (2 * 3) + 4", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$3,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "SKIP (burned out) Pipe optimization 1", "a = b >> a __\nb = a b", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$2,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "SKIP (burned out) Pipe optimization 2", "a = (__ >> __ >> __) a b c\nb = a >> b >> c", u0$Compiler$MakeCanonical_Test$transformAB$0, (u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.usr)(...(u0$Compiler$MakeCanonical_Test$shouldHaveSameAB$0.ctx), ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$binops$1,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Op chain definition and optimization", "a = __ + __ + 3 + __", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 1), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPlaceholder$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPlaceholder$0.ctx), 2), c0$Core$Nil$0))), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), u0$Compiler$CoreDefs$add$0.usr)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), u0$Compiler$CoreDefs$add$0.usr)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), u0$Compiler$CoreDefs$add$0.usr)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 1))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 3)), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefPlaceholder$0.usr)(...(c0$Compiler$Ast$RefPlaceholder$0.ctx), 2))), c0$Core$Nil$0)))))), c0$Core$Nil$0)))))))));

const u0$Compiler$TestHelpers$rootLocal$1 = (($name) => {
  return (c0$Compiler$Ast$RefGlobal$0.usr)(...(c0$Compiler$Ast$RefGlobal$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), u0$Compiler$TestHelpers$moduleUmr$0, $name));
});

const u0$Compiler$TestHelpers$rootLocal$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$rootLocal$1,
});

const u0$Compiler$MakeCanonical_Test$functions$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Functions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "[rec] function with call", "a =\n    fn x:\n        add x 1", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "f"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPattern$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPattern$0.ctx), c0$Compiler$Ast$Imm$0, (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "x"), c0$Maybe$Nothing$0)), c0$Core$Nil$0), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "add")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), "x"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1)), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "[rec] function with two arguments", "f =\n  fn a, b: 1", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "f"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPattern$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPattern$0.ctx), c0$Compiler$Ast$Imm$0, (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), c0$Maybe$Nothing$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPattern$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPattern$0.ctx), c0$Compiler$Ast$Imm$0, (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), c0$Maybe$Nothing$0)), c0$Core$Nil$0)), (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1)))), c0$Core$Nil$0)));

const u0$Compiler$TestHelpers$caBool$0 = (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Bool"), c0$Core$Nil$0);

const u0$Compiler$MakeCanonical_Test$lists$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Lists", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "list type sugar", "l as [ Bool ] =\n  l", u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    raw: (u0$Compiler$CoreDefs$listType$0.usr)(...(u0$Compiler$CoreDefs$listType$0.ctx), u0$Compiler$TestHelpers$caBool$0),
    tyvars: c0$Dict$empty$0,
    univars: c0$Dict$empty$0,
  })),
  maybeBody: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "l"))),
  name: "l",
  namePos: u0$Compiler$MakeCanonical_Test$p$0,
}))), c0$Core$Nil$0));

const u0$Compiler$MakeCanonical_Test$localDef$1 = (($name, $body) => {
  return ({
    body: $body,
    pattern: (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), c0$Compiler$Pos$G$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $name), c0$Maybe$Nothing$0),
    uni: c0$Compiler$Ast$Imm$0,
  });
});

const u0$Compiler$MakeCanonical_Test$localDef$0 = ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$localDef$1,
});

const u0$Compiler$MakeCanonical_Test$moduleAndAttributePaths$2 = (($s, $m) => {
  return (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), $s, ("a = " + $s), u0$Compiler$MakeCanonical_Test$firstDefinition$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $m, c0$Core$Nil$0)));
});

const u0$Compiler$MakeCanonical_Test$moduleAndAttributePaths$1 = (($s) => {
  return (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), $s, ("a = " + $s), u0$Compiler$MakeCanonical_Test$firstDefinition$0, i2$Test$isOk$0);
});

const u0$Compiler$MakeCanonical_Test$moduleAndAttributePaths$0 = ((() => {
  const $accept = ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$moduleAndAttributePaths$1,
  });
  const $reject = ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$moduleAndAttributePaths$2,
  });
  return (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Module and Attribute Paths", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($accept.usr)(...($accept.ctx), "blah.blah.blah"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), "Blah.Blah.blah", "attribute"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), "List.blah.Blah", "lower"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), "List..blah", "space"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), ".Blah", "must start with a lowercase"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), ".blah.blah", "shorthand"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), ".blah", "shorthand"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($reject.usr)(...($reject.ctx), "...", ""), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($accept.usr)(...($accept.ctx), "x .. y"), c0$Core$Nil$0))))))))));
}))();

const u0$Compiler$MakeCanonical_Test$nonFunction$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "NonFunction", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "one", "funz as a with a NonFunction =\n    1", u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    raw: (c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.usr)(...(c0$Compiler$CanonicalAst$TypeAnnotationVariable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, "a"),
    tyvars: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "a", ({
      nonFn: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Compiler$Pos$T$0),
    })),
    univars: c0$Dict$empty$0,
  })),
  maybeBody: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1)),
  name: "funz",
  namePos: u0$Compiler$MakeCanonical_Test$p$0,
}))), c0$Core$Nil$0));

const u0$Compiler$MakeCanonical_Test$numbers$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Numbers", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Percent", "a = 1%", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 0.01))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Underscore", "a = 1_000_000", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (1000 * 1000)))), c0$Core$Nil$0)));

const u0$Compiler$MakeCanonical_Test$patterns$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Patterns", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Record patterns can be partial", "a =\n  { with c } = d", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "[reg] record patterns are NOT extensible", "a =\n  { b with c } = d", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "extend pattern", c0$Core$Nil$0))), c0$Core$Nil$0)));

const u0$Compiler$MakeCanonical_Test$pipes$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Pipes", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "sendLeft is inlined", "a = thing >> function", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "function")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "thing"))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "sendRight is inlined", "a = function << thing", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Call$0.usr)(...(c0$Compiler$CanonicalAst$Call$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "function")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ArgumentExpression$0.usr)(...(c0$Compiler$CanonicalAst$ArgumentExpression$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "thing"))), c0$Core$Nil$0)))), c0$Core$Nil$0)));

const u0$Compiler$MakeCanonical_Test$polymorphicUniques$2 = (($def) => {
  const $2 = $def.maybeAnnotation;
  return ((($2)[0] === "$Just")
    ? ((() => {
      const $ann = ($2)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $ann.univars);
    }))()
    : (true
      ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "no ann")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/MakeCanonical_Test.sp 829:17', (sp_toHuman)($2))));
});

const u0$Compiler$MakeCanonical_Test$polymorphicUniques$1 = (($t) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$polymorphicUniques$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$MakeCanonical_Test$polymorphicUniques$2,
  })).ctx), (u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0.ctx), $t));
});

const u0$Compiler$MakeCanonical_Test$polymorphicUniques$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Polymorphic Uniques", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "In pattern", "f =\n    fn 1?a:\n    1?b = a\n    b", u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: c0$Maybe$Nothing$0,
  maybeBody: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Fn$0.usr)(...(c0$Compiler$CanonicalAst$Fn$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$CanonicalAst$ParameterPattern$0.usr)(...(c0$Compiler$CanonicalAst$ParameterPattern$0.ctx), (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), 1), (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "a"), c0$Maybe$Nothing$0)), c0$Core$Nil$0), (c0$Compiler$CanonicalAst$LetIn$0.usr)(...(c0$Compiler$CanonicalAst$LetIn$0.ctx), ({
    body: (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), "a")),
    pattern: (c0$Compiler$CanonicalAst$PatternAny$0.usr)(...(c0$Compiler$CanonicalAst$PatternAny$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), "b"), c0$Maybe$Nothing$0),
    uni: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), 1),
  }), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), "b"))))),
  name: "f",
  namePos: u0$Compiler$MakeCanonical_Test$p$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "In annotation", "isOk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = meh", ({
  ctx: [],
  usr: u0$Compiler$MakeCanonical_Test$polymorphicUniques$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Set$fromList$0.usr)(...(c0$Set$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, c0$Core$Nil$0))))), c0$Core$Nil$0)));

const u0$Compiler$MakeCanonical_Test$records$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Records", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "functional update", "a = { m with b, c = 1 }", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$LetIn$0.usr)(...(c0$Compiler$CanonicalAst$LetIn$0.ctx), (u0$Compiler$MakeCanonical_Test$localDef$0.usr)(...(u0$Compiler$MakeCanonical_Test$localDef$0.ctx), "0", (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "m"))), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), c0$Compiler$Pos$G$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), "0"))), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "c",
  second: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "b",
  second: (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "b")),
}), c0$Core$Nil$0))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Update shorthand", "b = { a with y = .x }", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$LetIn$0.usr)(...(c0$Compiler$CanonicalAst$LetIn$0.ctx), (u0$Compiler$MakeCanonical_Test$localDef$0.usr)(...(u0$Compiler$MakeCanonical_Test$localDef$0.ctx), "0", (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "a"))), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), c0$Compiler$Pos$G$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), "0"))), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "y",
  second: (c0$Compiler$CanonicalAst$RecordAccess$0.usr)(...(c0$Compiler$CanonicalAst$RecordAccess$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, "x", (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), c0$Compiler$Pos$G$0, (c0$Compiler$Ast$RefLocal$0.usr)(...(c0$Compiler$Ast$RefLocal$0.ctx), "0"))),
}), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "annotation, extensible", "a as { b with x as Bool } =\n  a", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "disabled", c0$Core$Nil$0))), c0$Core$Nil$0))));

const u0$Compiler$MakeCanonical_Test$shadowing$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Shadowing", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Root", "a = 0\na = 0", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "`a`", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Local", "a = 0\nb =\n    a = 0\n    a + a", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "`a`", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Function parameter", "a = 0\nb = fn a: a + a", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "`a`", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "try..as", "a = 0\nb = try x as\n     a: 0", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "`a`", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "already been defined", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Types", "var X = 'meh\nX = {}\nb = 0", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "X", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "twice", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Constructors", "var A = 'meh\nvar B = 'meh\nb = 0", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "b"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "meh", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "already been defined", c0$Core$Nil$0)))), c0$Core$Nil$0)))))));

const u0$Compiler$TestHelpers$caNumber$0 = (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Number"), c0$Core$Nil$0);

const u0$Compiler$MakeCanonical_Test$tuples$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Tuples", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "tuple2", "a = 1 & 2", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, c0$Maybe$Nothing$0, (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "first",
  second: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "second",
  second: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 2),
}), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "tuple3", "a = 1 & 2 & 3", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Compiler$CanonicalAst$Record$0.usr)(...(c0$Compiler$CanonicalAst$Record$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, c0$Maybe$Nothing$0, (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "first",
  second: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 1),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "second",
  second: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 2),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "third",
  second: (c0$Compiler$CanonicalAst$LiteralNumber$0.usr)(...(c0$Compiler$CanonicalAst$LiteralNumber$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, 3),
}), c0$Core$Nil$0))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "tuple4", "a = 1 & 2 & 3 & 4", (u0$Compiler$MakeCanonical_Test$firstEvaluation$0.usr)(...(u0$Compiler$MakeCanonical_Test$firstEvaluation$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "use a record", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Tuple2 type", "a as Number & Number =\n  a", u0$Compiler$MakeCanonical_Test$firstDefinitionStripDeps$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    raw: (c0$Compiler$CanonicalAst$TypeRecord$0.usr)(...(c0$Compiler$CanonicalAst$TypeRecord$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "second", u0$Compiler$TestHelpers$caNumber$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "first", u0$Compiler$TestHelpers$caNumber$0, c0$Dict$empty$0))),
    tyvars: c0$Dict$empty$0,
    univars: c0$Dict$empty$0,
  })),
  maybeBody: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Compiler$CanonicalAst$Variable$0.usr)(...(c0$Compiler$CanonicalAst$Variable$0.ctx), u0$Compiler$MakeCanonical_Test$p$0, (u0$Compiler$TestHelpers$rootLocal$0.usr)(...(u0$Compiler$TestHelpers$rootLocal$0.ctx), "a"))),
  name: "a",
  namePos: u0$Compiler$MakeCanonical_Test$p$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "tuple4, type", "a as Blah & Blah & Blah & Blah =\n  a", u0$Compiler$MakeCanonical_Test$firstDefinition$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "use a record", c0$Core$Nil$0))), c0$Core$Nil$0))))));

const u0$Compiler$MakeCanonical_Test$varTypes$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Variant types", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Tuples op precedence", "var A = 'x Bool & Bool", u0$Compiler$MakeCanonical_Test$textToModule$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need a 'constructor", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "Tuples op precedence works with parens", "var A = 'x (Bool & Bool)", u0$Compiler$MakeCanonical_Test$textToModule$0, i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$MakeCanonical_Test$codeTest$0.usr)(...(u0$Compiler$MakeCanonical_Test$codeTest$0.ctx), "SKIP (make `var` a keyword?) [reg] Should reject uppercase arg name", "var Outcome Token output = 'a", u0$Compiler$MakeCanonical_Test$textToModule$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "must start with a lowercase", c0$Core$Nil$0))), c0$Core$Nil$0))));

const u0$Compiler$MakeCanonical_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "MakeCanonical", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$varTypes$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$binops$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$tuples$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$lists$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$moduleAndAttributePaths$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$records$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$patterns$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$annotations$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$pipes$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$functions$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$nonFunction$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$argumentPlaceholders$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$polymorphicUniques$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$numbers$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$shadowing$0, c0$Core$Nil$0))))))))))))))));

const u0$Compiler$Parser_Test$e$1 = (($0) => {
  return (c0$Compiler$FormattableAst$Expression$0.usr)(...(c0$Compiler$FormattableAst$Expression$0.ctx), c0$Core$Nil$0, c0$Compiler$Pos$T$0, $0);
});

const u0$Compiler$Parser_Test$e$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$e$1,
});

const u0$Compiler$Parser_Test$annotatedVariable$1 = (($name, $type) => {
  return (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Lowercase$0.usr)(...(c0$Compiler$FormattableAst$Lowercase$0.ctx), ({
    attrPath: c0$Core$Nil$0,
    maybeModule: c0$Maybe$Nothing$0,
    maybeType: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $type),
    name: $name,
  })));
});

const u0$Compiler$Parser_Test$annotatedVariable$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$annotatedVariable$1,
});

const u0$Compiler$Parser_Test$codeTest$1 = (($0, $1, $2, $3) => {
  return (i2$Test$codeTest$0.usr)(...(i2$Test$codeTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2, $3);
});

const u0$Compiler$Parser_Test$codeTest$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$codeTest$1,
});

const u0$Compiler$Parser_Test$asDefinition$1 = (($s) => {
  return ((($s)[0] === "$ValueDef")
    ? ((() => {
      const $a = ($s)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : (true
      ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "Test says: no def")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 32:4', (sp_toHuman)($s))));
});

const u0$Compiler$Parser_Test$asDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$asDefinition$1,
});

const u0$Compiler$Parser_Test$firstStatement$2 = (($stats) => {
  return ((($stats)[0] === "$Nil")
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "Test says: no statements")
    : ((($stats)[0] === "$Cons")
      ? ((() => {
        const $head = ($stats)[1];
        const $tail = ($stats)[2];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $head);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 48:8', (sp_toHuman)($stats))));
});

const u0$Compiler$Parser_Test$firstStatement$1 = (($code) => {
  const $grabFirst = ({
    ctx: [],
    usr: u0$Compiler$Parser_Test$firstStatement$2,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), $grabFirst).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), $grabFirst).ctx), (u0$Compiler$TestHelpers$resErrorToStrippedText$0.usr)(...(u0$Compiler$TestHelpers$resErrorToStrippedText$0.ctx), (u0$Compiler$Parser$textToFormattableModule$0.usr)(...(u0$Compiler$Parser$textToFormattableModule$0.ctx), ({
    errorModule: ({
      content: $code,
      fsPath: "Test",
    }),
    keepComments: true,
    stripLocations: true,
  }))));
});

const u0$Compiler$Parser_Test$firstStatement$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$firstStatement$1,
});

const u0$Compiler$Parser_Test$firstDefinition$1 = (($code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), u0$Compiler$Parser_Test$asDefinition$0).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), u0$Compiler$Parser_Test$asDefinition$0).ctx), (u0$Compiler$Parser_Test$firstStatement$0.usr)(...(u0$Compiler$Parser_Test$firstStatement$0.ctx), $code));
});

const u0$Compiler$Parser_Test$firstDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$firstDefinition$1,
});

const u0$Compiler$Parser_Test$lowercase$1 = (($name) => {
  return (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Lowercase$0.usr)(...(c0$Compiler$FormattableAst$Lowercase$0.ctx), ({
    attrPath: c0$Core$Nil$0,
    maybeModule: c0$Maybe$Nothing$0,
    maybeType: c0$Maybe$Nothing$0,
    name: $name,
  })));
});

const u0$Compiler$Parser_Test$lowercase$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$lowercase$1,
});

const u0$Compiler$Parser_Test$faBinop$1 = (($op) => {
  return ({
    comments: c0$Core$Nil$0,
    line: -(1),
    pos: c0$Compiler$Pos$T$0,
    precedence: $op.precedence,
    symbol: $op.symbol,
    usr: $op.usr,
  });
});

const u0$Compiler$Parser_Test$faBinop$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$faBinop$1,
});

const u0$Compiler$Parser_Test$tuple$1 = (($a, $b) => {
  return (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), c0$Compiler$Op$precedence_tuple$0, ({
    first: $a,
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$tuple$0),
      second: $b,
    }), c0$Core$Nil$0),
  })));
});

const u0$Compiler$Parser_Test$tuple$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$tuple$1,
});

const u0$Compiler$Parser_Test$annotations$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Annotations", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Trivial case", "a as b =\n    z", u0$Compiler$Parser_Test$firstDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  body: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "z"),
  nonFn: c0$Core$Nil$0,
  pattern: (u0$Compiler$Parser_Test$annotatedVariable$0.usr)(...(u0$Compiler$Parser_Test$annotatedVariable$0.ctx), "a", (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b")),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Tuple precedence", "a as fn int & int: bool =\n    b", u0$Compiler$Parser_Test$firstDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  body: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
  nonFn: c0$Core$Nil$0,
  pattern: (u0$Compiler$Parser_Test$annotatedVariable$0.usr)(...(u0$Compiler$Parser_Test$annotatedVariable$0.ctx), "a", (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Inline$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$tuple$0.usr)(...(u0$Compiler$Parser_Test$tuple$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "int"), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "int")), c0$Core$Nil$0), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "bool")))),
}))), c0$Core$Nil$0)));

const u0$Compiler$Parser_Test$asEvaluation$1 = (($s) => {
  return ((($s)[0] === "$Evaluation")
    ? ((() => {
      const $a = ($s)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : (true
      ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "Test says: no eval")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 39:4', (sp_toHuman)($s))));
});

const u0$Compiler$Parser_Test$asEvaluation$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$asEvaluation$1,
});

const u0$Compiler$Parser_Test$firstEvaluation$1 = (($code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), u0$Compiler$Parser_Test$asEvaluation$0).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), u0$Compiler$Parser_Test$asEvaluation$0).ctx), (u0$Compiler$Parser_Test$firstStatement$0.usr)(...(u0$Compiler$Parser_Test$firstStatement$0.ctx), $code));
});

const u0$Compiler$Parser_Test$firstEvaluation$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$firstEvaluation$1,
});

const u0$Compiler$Parser_Test$firstEvaluationOfDefinition$2 = (($def) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $def.body);
});

const u0$Compiler$Parser_Test$firstEvaluationOfDefinition$1 = (($code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser_Test$firstEvaluationOfDefinition$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$Parser_Test$firstEvaluationOfDefinition$2,
  })).ctx), ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), u0$Compiler$Parser_Test$asDefinition$0).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), u0$Compiler$Parser_Test$asDefinition$0).ctx), (u0$Compiler$Parser_Test$firstStatement$0.usr)(...(u0$Compiler$Parser_Test$firstStatement$0.ctx), $code)));
});

const u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$firstEvaluationOfDefinition$1,
});

const u0$Compiler$Parser_Test$binops$0 = ((() => {
  const $sendBtoC = (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), c0$Compiler$Op$precedence_pipe$0, ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$sendRight$0),
      second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
    }), c0$Core$Nil$0),
  })));
  const $sendBtoCtoD = (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), c0$Compiler$Op$precedence_pipe$0, ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$sendRight$0),
      second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
    }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$sendRight$0),
      second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "d"),
    }), c0$Core$Nil$0)),
  })));
  return (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Binops", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "no indent", "b >> c", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), $sendBtoC)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "pipe indent 1", "b\n  >> c", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), $sendBtoC)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "pipe indent 2", "b\n  >> c\n  >> d", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), $sendBtoCtoD)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "pyramid indent", "b\n  >> c\n    >> d", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), $sendBtoCtoD)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "no indent", "x =\n    b\n    >>\n    c", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), $sendBtoC)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "SKIP (I'm tired) Starting", "x = >> c", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "SKIP (I'm tired) Double", "x = a >> >> c", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "SKIP (I'm tired) Ending", "x = a >>", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "TODO", c0$Core$Nil$0))), c0$Core$Nil$0)))))))));
}))();

const u0$Compiler$Parser_Test$comments$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Comments", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] trailing", "a =\n  b\n  # c", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), c0$Core$Nil$0));

const u0$Compiler$Parser_Test$constructor$1 = (($name) => {
  return (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Constructor$0.usr)(...(c0$Compiler$FormattableAst$Constructor$0.ctx), ({
    maybeModule: c0$Maybe$Nothing$0,
    name: $name,
  })));
});

const u0$Compiler$Parser_Test$constructor$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$constructor$1,
});

const u0$Compiler$Parser_Test$functions$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "functions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Inline body", "fn a, b: 3", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Inline$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), c0$Core$Nil$0)), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$LiteralNumber$0.usr)(...(c0$Compiler$FormattableAst$LiteralNumber$0.ctx), false, "3")))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Indented body", "fn a:\n    3", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Indented$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$LiteralNumber$0.usr)(...(c0$Compiler$FormattableAst$LiteralNumber$0.ctx), false, "3")))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Sibling nesting", "z =\n  fn a:\n  fn b:\n  3", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Aligned$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Aligned$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$LiteralNumber$0.usr)(...(c0$Compiler$FormattableAst$LiteralNumber$0.ctx), false, "3")))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Tuple vs lambda precedence", "fn a & b: a", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Inline$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$tuple$0.usr)(...(u0$Compiler$Parser_Test$tuple$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b")), c0$Core$Nil$0), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] Pass to function without parens", "xxx fn y: y", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "xxx"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Inline$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y"))), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Pass to function without parens, below", "z =\n  xxx fn y:\n  y", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "xxx"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Aligned$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y"))), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "SKIP Function should not swallow pipeline", "value\n>> map fn x: blah\n>> sblorp", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), c0$Compiler$Op$precedence_pipe$0, ({
  first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "value"),
  second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$sendRight$0),
    second: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "map"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Aligned$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "blah"))), c0$Core$Nil$0))),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$sendRight$0),
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "sblorp"),
  }), c0$Core$Nil$0)),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] Fn with multiple indented statements", "fn x:\n  x\n  x", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Indented$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Statements$0.usr)(...(c0$Compiler$FormattableAst$Statements$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$Evaluation$0.usr)(...(c0$Compiler$FormattableAst$Evaluation$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$Evaluation$0.usr)(...(c0$Compiler$FormattableAst$Evaluation$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x")), c0$Core$Nil$0)))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] Fn with definition", "a =\n    fn x:\n    y = 1\n    x", u0$Compiler$Parser_Test$firstDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  body: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Aligned$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"), c0$Core$Nil$0), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Statements$0.usr)(...(c0$Compiler$FormattableAst$Statements$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$ValueDef$0.usr)(...(c0$Compiler$FormattableAst$ValueDef$0.ctx), ({
    body: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$LiteralNumber$0.usr)(...(c0$Compiler$FormattableAst$LiteralNumber$0.ctx), false, "1")),
    nonFn: c0$Core$Nil$0,
    pattern: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y"),
  })), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$FormattableAst$Evaluation$0.usr)(...(c0$Compiler$FormattableAst$Evaluation$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x")), c0$Core$Nil$0)))))),
  nonFn: c0$Core$Nil$0,
  pattern: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] argument not being recognized?", "@b += 1", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$BinopChain$0.usr)(...(c0$Compiler$FormattableAst$BinopChain$0.ctx), c0$Compiler$Op$precedence_mutop$0, ({
  first: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), c0$Compiler$Op$UnopRecycle$0, (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"))),
  second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$faBinop$0.usr)(...(u0$Compiler$Parser_Test$faBinop$0.ctx), u0$Compiler$CoreDefs$mutableAdd$0),
    second: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$LiteralNumber$0.usr)(...(c0$Compiler$FormattableAst$LiteralNumber$0.ctx), false, "1")),
  }), c0$Core$Nil$0),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] multiple lines, compact", "x =\n    a = pop a\n    b = 1", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), c0$Core$Nil$0))))))))))));

const u0$Compiler$Parser_Test$ifs$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Ifs", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Inline", "if a then b else c", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$If$0.usr)(...(c0$Compiler$FormattableAst$If$0.ctx), ({
  condition: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
  false: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
  isMultiline: false,
  true: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Multiline, formatted", "z =\n  if a then\n      b\n  else\n      c", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$If$0.usr)(...(c0$Compiler$FormattableAst$If$0.ctx), ({
  condition: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
  false: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
  isMultiline: true,
  true: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Multiline, compact", "z =\n  if a then b\n  else c", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$If$0.usr)(...(c0$Compiler$FormattableAst$If$0.ctx), ({
  condition: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
  false: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
  isMultiline: true,
  true: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}))))), c0$Core$Nil$0))));

const u0$Compiler$Parser_Test$lists$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Lists", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Empty", "[]", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), false, c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Inline", "[a, b]", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), false, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Multiline", "z =\n  [\n  , a\n  , b\n  ]", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), true, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Ancient egyptian", "z =\n  blah [\n  , a\n  , b\n  ]", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "blah"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), true, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}), c0$Core$Nil$0)))), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Dots", "[a..., b, c...]", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), false, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: true,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: false,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: true,
  second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
}), c0$Core$Nil$0))))))), c0$Core$Nil$0))))));

const u0$Compiler$Parser_Test$parens$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Parens", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Can exist on multiple lines even when useless", "tests =\n    (Ok\n    )", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Can exist on multiple lines", "tests =\n    blah\n        (Ok\n        )", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), c0$Core$Nil$0)));

const u0$Compiler$Parser_Test$uppercase$1 = (($name) => {
  return (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Uppercase$0.usr)(...(c0$Compiler$FormattableAst$Uppercase$0.ctx), ({
    maybeModule: c0$Maybe$Nothing$0,
    name: $name,
  })));
});

const u0$Compiler$Parser_Test$uppercase$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$uppercase$1,
});

const u0$Compiler$Parser_Test$patterns$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Patterns", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "List unpacking", "[a as Int, b] = x", u0$Compiler$Parser_Test$firstDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  body: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"),
  nonFn: c0$Core$Nil$0,
  pattern: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), false, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: false,
    second: (u0$Compiler$Parser_Test$annotatedVariable$0.usr)(...(u0$Compiler$Parser_Test$annotatedVariable$0.ctx), "a", (u0$Compiler$Parser_Test$uppercase$0.usr)(...(u0$Compiler$Parser_Test$uppercase$0.ctx), "Int")),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: false,
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
  }), c0$Core$Nil$0)))),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Record argument unpacking", "fn { with a, b }:\n  x", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Fn$0.usr)(...(c0$Compiler$FormattableAst$Fn$0.ctx), c0$Compiler$FormattableAst$Indented$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: c0$Maybe$Nothing$0,
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: c0$Maybe$Nothing$0,
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
  }), c0$Core$Nil$0)),
  isMultiline: false,
  maybeExtension: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Maybe$Nothing$0),
}))), c0$Core$Nil$0), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"))))), c0$Core$Nil$0)));

const u0$Compiler$Parser_Test$records$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Records", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Empty", "{}", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: c0$Core$Nil$0,
  isMultiline: false,
  maybeExtension: c0$Maybe$Nothing$0,
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Inline", "{ x = b }", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b")),
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"),
  }), c0$Core$Nil$0),
  isMultiline: false,
  maybeExtension: c0$Maybe$Nothing$0,
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Multiline", "z =\n  {\n  , x = a\n  , y = b\n  }", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a")),
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b")),
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y"),
  }), c0$Core$Nil$0)),
  isMultiline: true,
  maybeExtension: c0$Maybe$Nothing$0,
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Pattern extension", "z =\n  { with\n  , x = a\n  }", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a")),
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"),
  }), c0$Core$Nil$0),
  isMultiline: true,
  maybeExtension: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), c0$Maybe$Nothing$0),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Expression extension", "q =\n  { z with\n  , x = a\n  }", u0$Compiler$Parser_Test$firstEvaluationOfDefinition$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a")),
    name: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "x"),
  }), c0$Core$Nil$0),
  isMultiline: true,
  maybeExtension: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "z"))),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Type or annotated implicit value", "{ x as Bool }", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: c0$Maybe$Nothing$0,
    name: (u0$Compiler$Parser_Test$annotatedVariable$0.usr)(...(u0$Compiler$Parser_Test$annotatedVariable$0.ctx), "x", (u0$Compiler$Parser_Test$uppercase$0.usr)(...(u0$Compiler$Parser_Test$uppercase$0.ctx), "Bool")),
  }), c0$Core$Nil$0),
  isMultiline: false,
  maybeExtension: c0$Maybe$Nothing$0,
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Type or annotated explicit value", "{ x as Bool = y }", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Record$0.usr)(...(c0$Compiler$FormattableAst$Record$0.ctx), ({
  attrs: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    maybeExpr: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "y")),
    name: (u0$Compiler$Parser_Test$annotatedVariable$0.usr)(...(u0$Compiler$Parser_Test$annotatedVariable$0.ctx), "x", (u0$Compiler$Parser_Test$uppercase$0.usr)(...(u0$Compiler$Parser_Test$uppercase$0.ctx), "Bool")),
  }), c0$Core$Nil$0),
  isMultiline: false,
  maybeExtension: c0$Maybe$Nothing$0,
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] real-world use", "a =\n  { state with\n      , pos = endPos\n      , code = rest\n      , accum =\n          [\n          , { kind = Token.Comment\n            , start = startPos\n            , end = endPos\n            }\n          , state.accum...\n          ]\n  }", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), c0$Core$Nil$0)))))))));

const u0$Compiler$Parser_Test$tries$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Try", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Multiline, formatted", "try a as\n   b:\n    c\n   d:\n    e", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Try$0.usr)(...(c0$Compiler$FormattableAst$Try$0.ctx), ({
  patterns: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "d"),
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "e"),
  }), c0$Core$Nil$0)),
  value: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Multiline, compact", "try a as\n   b: c\n   d: e", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Try$0.usr)(...(c0$Compiler$FormattableAst$Try$0.ctx), ({
  patterns: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "d"),
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "e"),
  }), c0$Core$Nil$0)),
  value: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Nested", "try a as\n   b:\n    try c as\n         q:\n            q\n   d:\n    e", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Try$0.usr)(...(c0$Compiler$FormattableAst$Try$0.ctx), ({
  patterns: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"),
    second: (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Try$0.usr)(...(c0$Compiler$FormattableAst$Try$0.ctx), ({
      patterns: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
        first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "q"),
        second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "q"),
      }), c0$Core$Nil$0),
      value: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"),
    }))),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "d"),
    second: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "e"),
  }), c0$Core$Nil$0)),
  value: (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"),
}))))), c0$Core$Nil$0))));

const u0$Compiler$Parser_Test$word$1 = (($name) => {
  return ({
    first: c0$Compiler$Pos$T$0,
    second: $name,
  });
});

const u0$Compiler$Parser_Test$word$0 = ({
  ctx: [],
  usr: u0$Compiler$Parser_Test$word$1,
});

const u0$Compiler$Parser_Test$unionDefs$2 = (($asTypeDef, $x) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), $asTypeDef).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), $asTypeDef).ctx), (u0$Compiler$Parser_Test$firstStatement$0.usr)(...(u0$Compiler$Parser_Test$firstStatement$0.ctx), $x));
});

const u0$Compiler$Parser_Test$unionDefs$1 = (($s) => {
  return ((($s)[0] === "$UnionDef")
    ? ((() => {
      const $a = ($s)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : (true
      ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "no type def")
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/Parser_Test.sp 442:8', (sp_toHuman)($s))));
});

const u0$Compiler$Parser_Test$unionDefs$0 = ((() => {
  const $asTypeDef = ({
    ctx: [],
    usr: u0$Compiler$Parser_Test$unionDefs$1,
  });
  const $firstTypeDef = ({
    ctx: ([
      $asTypeDef,
    ]),
    usr: u0$Compiler$Parser_Test$unionDefs$2,
  });
  return (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Type Definitions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Parse inline def", "var A b c = 'v1 b, 'v2 c, 'v3, 'v4 b c", $firstTypeDef, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
    args: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "b"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "c"), c0$Core$Nil$0)),
    constructors: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v1"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v2"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v3"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v4"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"), c0$Core$Nil$0)))), c0$Core$Nil$0)))),
    name: (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "A"),
  }))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Parse multiline def", "var A b c =\n    , 'v1 b\n    , 'v2 c\n    , 'v3\n    , 'v4 b c", $firstTypeDef, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
    args: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "b"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "c"), c0$Core$Nil$0)),
    constructors: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v1"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v2"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v3"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'v4"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"), c0$Core$Nil$0)))), c0$Core$Nil$0)))),
    name: (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "A"),
  }))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "List argument", "var A = 'a [Int]", $firstTypeDef, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
    args: c0$Core$Nil$0,
    constructors: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$constructor$0.usr)(...(u0$Compiler$Parser_Test$constructor$0.ctx), "'a"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$List$0.usr)(...(c0$Compiler$FormattableAst$List$0.ctx), false, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: false,
      second: (u0$Compiler$Parser_Test$uppercase$0.usr)(...(u0$Compiler$Parser_Test$uppercase$0.ctx), "Int"),
    }), c0$Core$Nil$0))), c0$Core$Nil$0))), c0$Core$Nil$0),
    name: (u0$Compiler$Parser_Test$word$0.usr)(...(u0$Compiler$Parser_Test$word$0.ctx), "A"),
  }))), c0$Core$Nil$0))));
}))();

const u0$Compiler$Parser_Test$unops$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Unops", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] Unop", "a = f -n", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Precedence 1", "-a b", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), c0$Compiler$Op$UnopMinus$0, (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"), c0$Core$Nil$0))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Precedence 2", "a -b", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), c0$Compiler$Op$UnopMinus$0, (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"))), c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "Precedence 3", "a -b c", u0$Compiler$Parser_Test$firstEvaluation$0, (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$Call$0.usr)(...(c0$Compiler$FormattableAst$Call$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "a"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$e$0.usr)(...(u0$Compiler$Parser_Test$e$0.ctx), (c0$Compiler$FormattableAst$UnopCall$0.usr)(...(c0$Compiler$FormattableAst$UnopCall$0.ctx), c0$Compiler$Op$UnopMinus$0, (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "b"))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$lowercase$0.usr)(...(u0$Compiler$Parser_Test$lowercase$0.ctx), "c"), c0$Core$Nil$0)))))), c0$Core$Nil$0)))));

const u0$Compiler$Parser_Test$values$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Values", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] Parse root comments", "# blank\na = 1", u0$Compiler$Parser_Test$firstStatement$0, i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] deal with spurious NewSiblingLine introduced by inline comments", "library =\n    # \"spcore\" is a special value for the core library\n    source = \"spcore\"", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$Parser_Test$codeTest$0.usr)(...(u0$Compiler$Parser_Test$codeTest$0.ctx), "[reg] SPON", "library =\n    source = \"core:prelude\"\n\n    module =\n        path = Core\n        importAs = Core", u0$Compiler$Parser_Test$firstDefinition$0, i2$Test$isOk$0), c0$Core$Nil$0))));

const u0$Compiler$Parser_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Parser", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$values$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$parens$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$functions$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$annotations$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$unionDefs$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$lists$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$records$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$ifs$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$tries$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$patterns$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$binops$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$unops$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$comments$0, c0$Core$Nil$0))))))))))))));

const u0$Compiler$TestHelpers$caFunction$2 = (($t) => {
  return (c0$Compiler$CanonicalAst$ParSp$0.usr)(...(c0$Compiler$CanonicalAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $t));
});

const u0$Compiler$TestHelpers$caFunction$1 = (($from, $to) => {
  return (c0$Compiler$CanonicalAst$TypeFn$0.usr)(...(c0$Compiler$CanonicalAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TestHelpers$caFunction$2,
  }), $from), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $to));
});

const u0$Compiler$TestHelpers$caFunction$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$caFunction$1,
});

const u0$Compiler$TestHelpers$caNone$0 = (c0$Compiler$CanonicalAst$TypeNamed$0.usr)(...(c0$Compiler$CanonicalAst$TypeNamed$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "None"), c0$Core$Nil$0);

const u0$Compiler$TestHelpers$taBool$0 = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Bool"), c0$Core$Nil$0);

const u0$Compiler$TestHelpers$taFunction$2 = (($t) => {
  return (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $t));
});

const u0$Compiler$TestHelpers$taFunction$1 = (($id, $from, $to) => {
  return (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, $id, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TestHelpers$taFunction$2,
  }), $from), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), $to));
});

const u0$Compiler$TestHelpers$taFunction$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$taFunction$1,
});

const u0$Compiler$TestHelpers$taList$1 = (($item) => {
  return (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "List"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $item, c0$Core$Nil$0));
});

const u0$Compiler$TestHelpers$taList$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$taList$1,
});

const u0$Compiler$TestHelpers$taNone$0 = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "None"), c0$Core$Nil$0);

const u0$Compiler$TestHelpers$taNumber$0 = (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$CoreDefs$usr$0.usr)(...(u0$Compiler$CoreDefs$usr$0.ctx), "Number"), c0$Core$Nil$0);

const u0$Compiler$TestHelpers$taTyvar$1 = (($0) => {
  return (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$T$0, $0);
});

const u0$Compiler$TestHelpers$taTyvar$0 = ({
  ctx: [],
  usr: u0$Compiler$TestHelpers$taTyvar$1,
});

const u0$Compiler$TypeCheck_Test$add$0 = ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    raw: (u0$Compiler$TestHelpers$caFunction$0.usr)(...(u0$Compiler$TestHelpers$caFunction$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$caNumber$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$caNumber$0, c0$Core$Nil$0)), u0$Compiler$TestHelpers$caNumber$0),
    tyvars: c0$Dict$empty$0,
    univars: c0$Dict$empty$0,
  })),
  maybeBody: c0$Maybe$Nothing$0,
  name: "add",
  namePos: c0$Compiler$Pos$T$0,
});

const u0$Compiler$TypeCheck_Test$outToHuman$2 = (($extraGetter, $extraName, $out) => {
  const $env = (u0$Compiler$TypeCheck$initEnv$0.usr)(...(u0$Compiler$TypeCheck$initEnv$0.ctx), u0$Compiler$TestHelpers$imports$0, c0$Dict$empty$0);
  const $type = (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$Human$Format$formatExpression$0.usr)(...(u0$Human$Format$formatExpression$0.ctx), ({
    isRoot: true,
    originalContent: "",
  }), (u0$Human$Type$doRawType$0.usr)(...(u0$Human$Type$doRawType$0.ctx), u0$Compiler$CoreDefs$coreModule$0, $out.type)));
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((("  " + $extraName) + " = ") + (sp_toHuman)(($extraGetter.usr)(...($extraGetter.ctx), $out))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("  type = " + $type), c0$Core$Nil$0)));
});

const u0$Compiler$TypeCheck_Test$outToHuman$1 = (($extraName, $extraGetter) => {
  return ({
    ctx: ([
      $extraGetter,
      $extraName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$outToHuman$2,
  });
});

const u0$Compiler$TypeCheck_Test$outToHuman$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$outToHuman$1,
});

const u0$Compiler$TypeCheck_Test$codeTest$2 = (($out) => {
  return (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $out.freeTyvars);
});

const u0$Compiler$TypeCheck_Test$codeTest$1 = (($0, $1, $2, $3) => {
  return (i2$Test$codeTest$0.usr)(...(i2$Test$codeTest$0.ctx), (u0$Compiler$TypeCheck_Test$outToHuman$0.usr)(...(u0$Compiler$TypeCheck_Test$outToHuman$0.ctx), "tyvars", ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$codeTest$2,
  })), $0, $1, $2, $3);
});

const u0$Compiler$TypeCheck_Test$codeTest$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$codeTest$1,
});

const u0$Compiler$TypeCheck_Test$reset$0 = ({
  directDeps: c0$Dict$empty$0,
  maybeAnnotation: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
    raw: (u0$Compiler$TestHelpers$caFunction$0.usr)(...(u0$Compiler$TestHelpers$caFunction$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$caNumber$0, c0$Core$Nil$0), u0$Compiler$TestHelpers$caNone$0),
    tyvars: c0$Dict$empty$0,
    univars: c0$Dict$empty$0,
  })),
  maybeBody: c0$Maybe$Nothing$0,
  name: "reset",
  namePos: c0$Compiler$Pos$T$0,
});

const u0$Compiler$TypeCheck_Test$inferRootDef$7 = (($targetUsr, $rv) => {
  return (sp_equal)($rv.usr, $targetUsr);
});

const u0$Compiler$TypeCheck_Test$inferRootDef$6 = (($targetName, $1) => {
  const $constructors = $1.constructors;
  const $natives = $1.natives;
  const $rootValues = $1.rootValues;
  const $targetUsr = (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), u0$Compiler$TestHelpers$moduleUmr$0, $targetName), 0);
  const $2 = (c0$List$find$0.usr)(...(c0$List$find$0.ctx), ({
    ctx: ([
      $targetUsr,
    ]),
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$7,
  }), $rootValues);
  return ((($2)[0] === "$Nothing")
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "find fail")
    : ((($2)[0] === "$Just")
      ? ((() => {
        const $def = ($2)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $def);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Compiler/TypeCheck_Test.sp 169:4', (sp_toHuman)($2))));
});

const u0$Compiler$TypeCheck_Test$inferRootDef$5 = (($caModule, $1) => {
  const $umr = ($1)[1];
  return ((sp_equal)($umr, u0$Compiler$TestHelpers$moduleUmr$0)
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $caModule)
    : ((sp_equal)($umr, u0$Compiler$CoreDefs$umr$0)
      ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), u0$Compiler$CoreDefs$coreModule$0)
      : (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Compiler$Error$Raw$0.usr)(...(u0$Compiler$Error$Raw$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ("no module " + (sp_toHuman)($umr)), c0$Core$Nil$0)))));
});

const u0$Compiler$TypeCheck_Test$inferRootDef$4 = (($0) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), u0$Compiler$TestHelpers$moduleUmr$0, $0);
});

const u0$Compiler$TypeCheck_Test$inferRootDef$3 = (($0) => {
  return (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$4,
  }), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $0));
});

const u0$Compiler$TypeCheck_Test$inferRootDef$2 = (($targetName, $caModuleRaw) => {
  const $caModule = ((() => {
    const $0 = $caModuleRaw;
    return (Object.assign)({}, $0, ({
      valueDefs: (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "reset", u0$Compiler$TypeCheck_Test$reset$0, (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), "add", u0$Compiler$TypeCheck_Test$add$0, $0.valueDefs)),
    }));
  }))();
  const $keysToUsrs = ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$3,
  });
  const $requiredUsrs = (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($keysToUsrs.usr)(...($keysToUsrs.ctx), $caModule.valueDefs), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($keysToUsrs.usr)(...($keysToUsrs.ctx), $caModule.constructorDefs), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($keysToUsrs.usr)(...($keysToUsrs.ctx), $caModule.variantTypeDefs), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($keysToUsrs.usr)(...($keysToUsrs.ctx), $caModule.aliasDefs), c0$Core$Nil$0)))));
  const $loadCaModule = ({
    ctx: ([
      $caModule,
    ]),
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$5,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $targetName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$6,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $targetName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$6,
  })).ctx), (u0$Compiler$TestHelpers$resErrorToStrippedText$0.usr)(...(u0$Compiler$TestHelpers$resErrorToStrippedText$0.ctx), (u0$Compiler$LazyBuild$build$0.usr)(...(u0$Compiler$LazyBuild$build$0.ctx), ({
    loadCaModule: $loadCaModule,
    projectImports: u0$Compiler$TestHelpers$imports$0,
    requiredUsrs: $requiredUsrs,
  }))));
});

const u0$Compiler$TypeCheck_Test$inferRootDef$1 = (($targetName, $code) => {
  const $params = ({
    errorModule: (u0$Compiler$TestHelpers$errorModule$0.usr)(...(u0$Compiler$TestHelpers$errorModule$0.ctx), $code),
    imports: u0$Compiler$TestHelpers$imports$0,
    resolveToUsr: u0$Compiler$TestHelpers$resolveToUsr$0,
    umr: u0$Compiler$TestHelpers$moduleUmr$0,
  });
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $targetName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $targetName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$inferRootDef$2,
  })).ctx), (u0$Compiler$TestHelpers$resErrorToStrippedText$0.usr)(...(u0$Compiler$TestHelpers$resErrorToStrippedText$0.ctx), (u0$Compiler$MakeCanonical$textToCanonicalModule$0.usr)(...(u0$Compiler$MakeCanonical$textToCanonicalModule$0.ctx), true, $params)));
});

const u0$Compiler$TypeCheck_Test$inferRootDef$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$inferRootDef$1,
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$7 = (($out) => {
  return $out.lambdaSetConstraints;
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$6 = (($inferLambdaSets, $name, $code, $target, $test) => {
  return (i2$Test$codeTest$0.usr)(...(i2$Test$codeTest$0.ctx), (u0$Compiler$TypeCheck_Test$outToHuman$0.usr)(...(u0$Compiler$TypeCheck_Test$outToHuman$0.ctx), "lSets", ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$7,
  })), $name, $code, ($inferLambdaSets.usr)(...($inferLambdaSets.ctx), $target), $test);
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$5 = (($k, $v) => {
  return (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $v);
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$4 = (($hash, $id, $tc, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$TypedAst$normalizeTyvarId$0.usr)(...(c0$Compiler$TypedAst$normalizeTyvarId$0.ctx), $hash, $id), $tc, $d);
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$3 = (($def) => {
  let $hash = (hash_fromList)(c0$Core$Nil$0);
  const $ft = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $def.freeTyvars, ({
    ctx: ([
      $hash,
    ]),
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$4,
  }));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    lambdaSetConstraints: (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), (c0$Dict$map$0.usr)(...(c0$Dict$map$0.ctx), ({
      ctx: [],
      usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$5,
    }), $def.lambdaSetConstraints)),
    type: (c0$Compiler$TypedAst$stripTypePos$0.usr)(...(c0$Compiler$TypedAst$stripTypePos$0.ctx), (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $def.returnType.raw)),
  }));
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$2 = (($targetName, $code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$3,
  })).ctx), (u0$Compiler$TypeCheck_Test$inferRootDef$0.usr)(...(u0$Compiler$TypeCheck_Test$inferRootDef$0.ctx), $targetName, $code));
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$1 = (($targetName) => {
  return ({
    ctx: ([
      $targetName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$2,
  });
});

const u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$0 = ((() => {
  const $inferLambdaSets = ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$1,
  });
  return ({
    ctx: ([
      $inferLambdaSets,
    ]),
    usr: u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$6,
  });
}))();

const u0$Compiler$TypeCheck_Test$freeTyvars$2 = (($id, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $id, ({
    maybeAnnotated: c0$Maybe$Nothing$0,
  }), $d);
});

const u0$Compiler$TypeCheck_Test$freeTyvars$1 = (($ids) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $ids, ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$freeTyvars$2,
  }));
});

const u0$Compiler$TypeCheck_Test$freeTyvars$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$freeTyvars$1,
});

const u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$2 = (($2, $d) => {
  const $id = $2.first;
  const $name = $2.second;
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $id, ({
    maybeAnnotated: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), ({
      allowFunctions: true,
      name: $name,
    })),
  }), $d);
});

const u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$1 = (($ids) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $ids, ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$2,
  }));
});

const u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$1,
});

const u0$Compiler$TypeCheck_Test$infer$4 = (($hash, $id, $tc, $d) => {
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$TypedAst$normalizeTyvarId$0.usr)(...(c0$Compiler$TypedAst$normalizeTyvarId$0.ctx), $hash, $id), $tc, $d);
});

const u0$Compiler$TypeCheck_Test$infer$3 = (($def) => {
  let $hash = (hash_fromList)(c0$Core$Nil$0);
  const $ft = (c0$Dict$for$0.usr)(...(c0$Dict$for$0.ctx), c0$Dict$empty$0, $def.freeTyvars, ({
    ctx: ([
      $hash,
    ]),
    usr: u0$Compiler$TypeCheck_Test$infer$4,
  }));
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ({
    freeTyvars: $ft,
    type: (c0$Compiler$TypedAst$stripTypePos$0.usr)(...(c0$Compiler$TypedAst$stripTypePos$0.ctx), (c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $def.returnType.raw)),
  }));
});

const u0$Compiler$TypeCheck_Test$infer$2 = (($targetName, $code) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$infer$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: [],
    usr: u0$Compiler$TypeCheck_Test$infer$3,
  })).ctx), (u0$Compiler$TypeCheck_Test$inferRootDef$0.usr)(...(u0$Compiler$TypeCheck_Test$inferRootDef$0.ctx), $targetName, $code));
});

const u0$Compiler$TypeCheck_Test$infer$1 = (($targetName) => {
  return ({
    ctx: ([
      $targetName,
    ]),
    usr: u0$Compiler$TypeCheck_Test$infer$2,
  });
});

const u0$Compiler$TypeCheck_Test$infer$0 = ({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$infer$1,
});

const u0$Compiler$TypeCheck_Test$tyvar$0 = u0$Compiler$TestHelpers$taTyvar$0;

const u0$Compiler$TypeCheck_Test$functions$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "functions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Known function with correct params", "a = add 3 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: u0$Compiler$TestHelpers$taNumber$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Known function with wrong *number* of args", "a = add 'false", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Number", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Arguments", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Known function with wrong params", "a = add 'false 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Bool", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Function inference 1", "a = fn x: add x 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$taNumber$0, c0$Core$Nil$0), u0$Compiler$TestHelpers$taNumber$0),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Function inference 2: same as 1, but with swapped args", "a = fn x: add 1 x", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$taNumber$0, c0$Core$Nil$0), u0$Compiler$TestHelpers$taNumber$0),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] fn had type None", "a = fn x: 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1))), c0$Core$Nil$0), (c0$Compiler$Ast$toUni$0.usr)(...(c0$Compiler$Ast$toUni$0.ctx), u0$Compiler$TestHelpers$taNumber$0)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Multiple arguments are correctly inferred", "a = fn x, y, z: x + y + z", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Annotation should be consistent with mutability", "f as fn @Number: Number = fn a:\n  a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "RecyclingDoesNotMatch", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Free tyvar should not be compatible with constructor", "listCons as fn item: item =\n    fn item:\n    []", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "listCons"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "I need the annotation and the value to have the same type", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Annotations that are too general should be rejected", "f as fn a: b =\n    fn a: a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Should unify bound tyvars when needed", "for as fn a, b, (fn b, a: a): a =\n    fn a, b, f: a\n\nz =\n    for \"\" 1 fn b, a:\n        b", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "z"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Text", c0$Core$Nil$0))), c0$Core$Nil$0))))))))))));

const u0$Compiler$TypeCheck_Test$higherOrderTypes$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "higher order types", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Parse precedence", "var T a = 't a\n\na as fn T a: T a =\n    fn l: l", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: "a",
  }), c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "T"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0)), c0$Core$Nil$0), (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "T"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0))),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Variant type constructors", "var X a = 'l\nl = 'l", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "l"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "X"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] type check mistakes a variant type with free tyvars for a free tyvar?", "var O r e o = 'o r e o\n\nrun as fn (fn r: O r e o), r: O r e o =\n   fn rToOreo, r:\n   rToOreo r", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "run"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Wrong should be Text", "var O o = 'o Text o\n\nfun as Number: Text: O wrong = _: a:\n    'o a a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "fun"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "wrong", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Should complain about undefined type argument", "var O a = 'o Text output\nx = 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "output", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Named vars can't be refined?", "var Wrap a = 'w a\n\nf as fn a: Wrap a =\n    fn a: a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Wrap", c0$Core$Nil$0))), c0$Core$Nil$0)))))));

const u0$Compiler$TypeCheck_Test$if_else$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "if..else", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "basic functionality", "x =\n    fn q:\n    if q then 1\n    else 2", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), u0$Compiler$TestHelpers$taBool$0)), c0$Core$Nil$0), (c0$Compiler$Ast$toUni$0.usr)(...(c0$Compiler$Ast$toUni$0.ctx), u0$Compiler$TestHelpers$taNumber$0)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "rejects non-bool conditions", "x =\n    fn q:\n    if 1 then 1\n    else 2", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Bool", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "rejects non-matching blocks", "x =\n    fn q:\n    if q then 2\n    else 'false", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Number", c0$Core$Nil$0))), c0$Core$Nil$0))));

const u0$Compiler$TypeCheck_Test$lambdaSets$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "lambdaSets", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$0.ctx), "Adds a lambda constraint to its argument (no annotation)", "a =\n    fn bool, fun:\n        if bool then fun\n        else fn x: x", "a", (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  lambdaSetConstraints: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"),
      second: 1,
    }), c0$Core$Nil$0),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 2,
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"),
      second: 2,
    }), c0$Core$Nil$0),
  }), c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$taBool$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 2, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)), c0$Core$Nil$0)), (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 2, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1))),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTestWithLambdaSetConstraints$0.ctx), "Calls expand lambda constraints", "a =\n    fn bool, fun1, fun2, meta:\n\n    if bool then\n        meta fun1\n    else if 'false then\n        meta fun2\n    else if 'true then\n        meta fn x: x\n    else\n        meta fn x: x\n\np = fn x: x\nq = fn x: x\nm = fn f: f\n\nb =\n    a 'false p q m\n\nc =\n    a 'false q q m\n\nz =\n    { b, c }", "z", (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  lambdaSetConstraints: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 3,
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"),
      second: 1,
    }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"),
      second: 2,
    }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "p"),
      second: 1,
    }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "q"),
      second: 1,
    }), c0$Core$Nil$0)))),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 4,
    second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"),
      second: 1,
    }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "a"),
      second: 2,
    }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
      first: (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "q"),
      second: 1,
    }), c0$Core$Nil$0))),
  }), c0$Core$Nil$0)),
  type: (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, c0$Maybe$Nothing$0, (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "b",
    second: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 3, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 2), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 2)),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "c",
    second: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 4, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
  }), c0$Core$Nil$0)))),
}))), c0$Core$Nil$0)));

const u0$Compiler$TypeCheck_Test$misc$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Misc", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Undefined types should be rejected", "v as ThisTypeIsNotDefined = this_is_sp_native", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "v"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "ThisTypeIsNotDefined", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Placeholder works with unique args", "stuff as fn !Number: Number = this_is_sp_native\nv =\n    1 >> stuff __", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "v"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: u0$Compiler$TestHelpers$taNumber$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] named tyvars should not \"bleed\" to other definitions", "var DD q =\n    , 'RBEmpty_elm_builtin\n\nempty as DD key =\n    'RBEmpty_elm_builtin\n\nmerge as fn (fn key, b, res: res), res: res =\n  fn rightStep, initialResult:\n\n  stepState as fn key, b, [key & a] & res: [key & a] & res =\n    fn rKey, rValue, q:\n    try q.first as\n       []: q\n\n  initialResult", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "merge"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Constructors not being generalized led to tyvar bleed", "var DD a b = 'Blah\n\nddget as fn a, DD a b: DD a b =\n    fn a, b:\n    'Blah\n\nformatSnippet as Text =\n    try [\"\"] as\n         [\"emphasys\", s]: s\n\nfmtBlock as Text =\n    try ddget 1 'Blah as\n         'Blah:\n            \"\"", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "formatSnippet"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Non-annotated variables are not correctly inserted", "n = 3\n\nz as Number = n + 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "z"), i2$Test$isOk$0), c0$Core$Nil$0))))));

const u0$Compiler$TypeCheck_Test$nonFunction$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "NonFunction", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "SKIP (burnedout) Basic functionality", "blah as fn [a]: [a] with a NonFunction =\n  fn a:\n  a\n\nmeh =\n    blah [fn x: x]", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "meh"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "ErrorTypeAllowsFunctions", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "SKIP (burnedout) Constraint is enforced with annotation", "blah as fn [a]: [a] with a NonFunction =\n  fn a: a\n\nmeh as fn b: b =\n    fn a: blah a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "meh"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "ErrorTypeAllowsFunctions", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "SKIP (burnedout) Constraint is enforced without annotation", "blah as fn [a]: [a] with a NonFunction =\n    fn a: a\n\nmeh =\n    fn a: blah a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "meh"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), 1, ({
    maybeAnnotated: c0$Maybe$Nothing$0,
  })),
  type: u0$Compiler$TestHelpers$taNumber$0,
}))), c0$Core$Nil$0))));

const u0$Compiler$TypeCheck_Test$patterns$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Patterns", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Constructor unpacking", "var Z a = 'z a\n\nidentityFunction =\n   fn a:\n   'z b = 'z a\n   b", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "identityFunction"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "List unpacking", "x =\n   fn q:\n   [ first, second ] = q\n   first", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TestHelpers$taList$0.usr)(...(u0$Compiler$TestHelpers$taList$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Complete records are correctly unpacked", "x =\n    fn q:\n    { first } = q\n    first", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, c0$Maybe$Nothing$0, (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "first",
    second: (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1),
  }), c0$Core$Nil$0))), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Incomplete records are correctly unpacked", "x =\n    fn q:\n    { with first } = q\n    first", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, c0$Core$Nil$0))),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 2), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "first",
    second: (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1),
  }), c0$Core$Nil$0))), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Constructors should instantiate their variable types", "each as fn [a], (fn a: b): None =\n    fn ls, f:\n    try ls as\n         Core.'nil: 'none\n\nresult =\n    1 :: Core.'nil = Core.'nil", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "result"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Trying to check against an inferred value?", "tuple as Text & Number =\n    \"\" & 1\n\nx =\n    (a as Text) & (b as Number) =\n        tuple", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), i2$Test$isOk$0), c0$Core$Nil$0)))))));

const u0$Compiler$TypeCheck_Test$records$3 = (($re) => {
  return ({
    freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
    type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $re, c0$Core$Nil$0), $re),
  });
});

const u0$Compiler$TypeCheck_Test$records$2 = (($re) => {
  return ({
    freeTyvars: c0$Dict$empty$0,
    type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $re, c0$Core$Nil$0), $re),
  });
});

const u0$Compiler$TypeCheck_Test$records$1 = (($re) => {
  return ({
    freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, c0$Core$Nil$0))),
    type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $re, c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 2)),
  });
});

const u0$Compiler$TypeCheck_Test$records$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Records", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Attribute access", "a = fn b: b.meh.blah", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 3, c0$Core$Nil$0)))),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "meh", (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 2), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "blah", (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 3))))), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 3)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Attribute mutation", "a = fn @b: @b.meh.blah += 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 2, c0$Core$Nil$0))),
  type: (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$ParRe$0.usr)(...(c0$Compiler$TypedAst$ParRe$0.ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "meh", (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 2), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "blah", u0$Compiler$TestHelpers$taNumber$0))))), c0$Core$Nil$0), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), u0$Compiler$TestHelpers$taNone$0)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Tuple3 direct item mutability", "x =\n    !a = 3 & 'false & 2\n\n    @a.third += 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Tuple2 direct item mutability, annotated", "x =\n   fn _:\n   !a as Number & Number =\n     1 & 2\n\n   @a.first += 1", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "functional update", "a = fn b: { b with x = 1 }", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$records$3,
}).usr)(...(({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$records$3,
}).ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "x", u0$Compiler$TestHelpers$taNumber$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "SKIP(needs reordering) instantiate and refine inferred records", "a = fn t: { t with x = 1 }\nc = a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "c"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$records$2,
}).usr)(...(({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$records$2,
}).ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "x", u0$Compiler$TestHelpers$taNumber$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] excessive forallness in records", "x =\n  fn q:\n  a = q.first\n  a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$records$1,
}).usr)(...(({
  ctx: [],
  usr: u0$Compiler$TypeCheck_Test$records$1,
}).ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1), (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), "first", (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 2)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] refineType when the record has a non-extensible alias", "A = { c as Number, d as Number }\n\nupd as fn A: A = fn a:\n  { a with c = .c + 1 }", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "upd"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] infinite recursion on addSubstitution/unify_", "B = { l as [Text] }\n\nreadOne as fn B: (Text & B) =\n    fn b:\n    try b.l as\n         []: \"\" & b\n         [h, t...]: h & { b with l = t }", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "readOne"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] unifyToNonExtensibleRecord correctly substitutes the record extension", "R = { x as Number, y as Number }\n\nrec as fn R: R =\n    fn s:\n\n    if 'true then\n        { s with y = .y }\n    else\n        rec { s with y = .y }", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "rec"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Record missing attributes", "R = { x as Number, y as Number }\n\nr as R = {\n  , x = 3\n  }", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "r"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Missing", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Inferring and then generalizing an extensible record should still constrain the tyvar to a record!", "f =\n    fn record:\n    record.attr\n\nmain =\n    f 'true", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Bool", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "attr", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Inferred records are correctly merged", "f =\n    fn record:\n    record.attr\n\ng =\n    fn record:\n    record.blah\n\nmeh as fn a, (fn a: Bool), (fn a: Number): Bool =\n    fn a, ff, gg:\n    'false\n\nmain =\n    fn r:\n    meh r f g", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "main"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$TypeRecord$0.usr)(...(c0$Compiler$TypedAst$TypeRecord$0.ctx), c0$Compiler$Pos$T$0, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), 1), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "attr",
    second: u0$Compiler$TestHelpers$taBool$0,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "blah",
    second: u0$Compiler$TestHelpers$taNumber$0,
  }), c0$Core$Nil$0)))), c0$Core$Nil$0), u0$Compiler$TestHelpers$taBool$0),
}))), c0$Core$Nil$0))))))))))))));

const u0$Compiler$TypeCheck_Test$recursiveTypes$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Recursive types", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Normal types cannot be self recursive", "A = { a as A }\na as A = this_is_sp_native", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Circular", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Normal types cannot be mutually recursive", "A = { b as B }\nB = { a as A }\na as A = this_is_sp_native", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Circular", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Variant types can be recursive", "var A = 'a1, 'a2 B\nB = { a as A }\na as A = 'a2 b\nb as B = { a = 'a1 }", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), i2$Test$isOk$0), c0$Core$Nil$0))));

const u0$Compiler$TypeCheck_Test$statements$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "statements", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Statement blocks should return the last statement's type", "a =\n  3\n  'false", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: u0$Compiler$TestHelpers$taBool$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Definition statements return type None", "a =\n  f = fn x: 3", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: u0$Compiler$TestHelpers$taNone$0,
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Definition statement with annotation return type None", "a as None =\n  f = 3", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "a"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Annotated declarations are actually typechecked", "x as None =\n    q = 1 + \"\"", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), c0$Core$Nil$0)), c0$Core$Nil$0)))));

const u0$Compiler$TypeCheck_Test$try_as$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "try..as", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "basic functionality", "x =\n    fn q:\n    try q as\n         'true: 2\n         _: 3", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), (c0$Compiler$Ast$toImm$0.usr)(...(c0$Compiler$Ast$toImm$0.ctx), u0$Compiler$TestHelpers$taBool$0)), c0$Core$Nil$0), (c0$Compiler$Ast$toUni$0.usr)(...(c0$Compiler$Ast$toUni$0.ctx), u0$Compiler$TestHelpers$taNumber$0)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "rejects non-matching patterns", "x =\n    fn q:\n    try q as\n         'true: 2\n         []: 3", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "List", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Bool", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "rejects non-matching blocks", "x =\n    fn q:\n    try q as\n         'true: 2\n         'false: 'false", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Number", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Bool", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] actually infers blocks", "x as Number =\n    try \"\" as\n         \"\": y", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "y", c0$Core$Nil$0))), c0$Core$Nil$0)))));

const u0$Compiler$TypeCheck_Test$variableTypes$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Variable types", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Identity, annotated", "id as fn a: a =\n  fn a: a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "id"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvarsAnnotated$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: 1,
    second: "a",
  }), c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Identity, inferred", "id =\n  fn a: a", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "id"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taFunction$0.usr)(...(u0$Compiler$TestHelpers$taFunction$0.ctx), 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1), c0$Core$Nil$0), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "Annotated vars are instantiated when referenced", "q as [item] =\n  Core.'nil\n\nr as [Text] =\n      q", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "r"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] on is missing tyvars", "andThen as [a] = []\n\non = andThen", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "on"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (u0$Compiler$TypeCheck_Test$freeTyvars$0.usr)(...(u0$Compiler$TypeCheck_Test$freeTyvars$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), 1, c0$Core$Nil$0)),
  type: (u0$Compiler$TestHelpers$taList$0.usr)(...(u0$Compiler$TestHelpers$taList$0.ctx), (u0$Compiler$TypeCheck_Test$tyvar$0.usr)(...(u0$Compiler$TypeCheck_Test$tyvar$0.ctx), 1)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Compiler$TypeCheck_Test$codeTest$0.usr)(...(u0$Compiler$TypeCheck_Test$codeTest$0.ctx), "[reg] Unifying functions does not unfiy their args", "var Dict_ k v = 'empty\ndict_member as fn k, Dict_ k v: Bool = this_is_sp_native\ndict_filter as fn (fn k, v: Bool), Dict_ k v: Dict_ k v = this_is_sp_native\n\nfreeTyvars as Dict_ Number {} = this_is_sp_native\ntypeTyvars as Dict_ Number None = this_is_sp_native\n\nx = dict_filter (fn k, v: dict_member v typeTyvars) freeTyvars", (u0$Compiler$TypeCheck_Test$infer$0.usr)(...(u0$Compiler$TypeCheck_Test$infer$0.ctx), "x"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "{}", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Number", c0$Core$Nil$0)))), c0$Core$Nil$0))))));

const u0$Compiler$TypeCheck_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "TypeCheck", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$functions$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$lambdaSets$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$statements$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$recursiveTypes$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$variableTypes$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$higherOrderTypes$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$records$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$patterns$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$try_as$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$if_else$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$nonFunction$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$misc$0, c0$Core$Nil$0)))))))))))));

const u0$DefaultImports$platformDefaultImportsFile$2 = (($1) => {
  const $path = $1.first;
  const $globals = $1.second;
  return (u0$DefaultImports$mod$0.usr)(...(u0$DefaultImports$mod$0.ctx), $path, $globals);
});

const u0$DefaultImports$platformDefaultImportsFile$1 = (($name, $modules) => {
  const $platform = ({
    modules: (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
      ctx: [],
      usr: u0$DefaultImports$platformDefaultImportsFile$2,
    }), $modules),
    platform: "",
    source: (":" + $name),
  });
  const $0 = u0$DefaultImports$defaultImportsFile$0;
  return (Object.assign)({}, $0, ({
    libraries: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $platform, $0.libraries),
  }));
});

const u0$DefaultImports$platformDefaultImportsFile$0 = ({
  ctx: [],
  usr: u0$DefaultImports$platformDefaultImportsFile$1,
});

const u0$Human$Format_Test$format$2 = (($input, $faStatements) => {
  const $env = ({
    isRoot: true,
    originalContent: $input,
  });
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$Human$Format$formatStatements$0.usr)(...(u0$Human$Format$formatStatements$0.ctx), $env, $faStatements)));
});

const u0$Human$Format_Test$format$1 = (($input) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $input,
    ]),
    usr: u0$Human$Format_Test$format$2,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $input,
    ]),
    usr: u0$Human$Format_Test$format$2,
  })).ctx), (c0$Result$mapError$0.usr)(...(c0$Result$mapError$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), (u0$Compiler$Parser$textToFormattableModule$0.usr)(...(u0$Compiler$Parser$textToFormattableModule$0.ctx), ({
    errorModule: ({
      content: $input,
      fsPath: "test",
    }),
    keepComments: true,
    stripLocations: false,
  }))));
});

const u0$Human$Format_Test$format$0 = ({
  ctx: [],
  usr: u0$Human$Format_Test$format$1,
});

const u0$Human$Format_Test$formatTest$3 = (($input, $quote, $toMaybeError, _0) => {
  return (i2$Test$maybeToOutcome$0.usr)(...(i2$Test$maybeToOutcome$0.ctx), ($toMaybeError.usr)(...($toMaybeError.ctx), $quote, (u0$Human$Format_Test$format$0.usr)(...(u0$Human$Format_Test$format$0.ctx), $input)));
});

const u0$Human$Format_Test$formatTest$2 = (($0) => {
  return (("```\n" + $0) + "\n```");
});

const u0$Human$Format_Test$formatTest$1 = (($title, $input, $expectedOutput) => {
  const $quote = ({
    ctx: [],
    usr: u0$Human$Format_Test$formatTest$2,
  });
  const $4 = (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), $expectedOutput);
  const $toMaybeError = ($4)[1];
  return (i2$Test$Single$0.usr)(...(i2$Test$Single$0.ctx), $title, "", ({
    ctx: ([
      $input,
      $quote,
      $toMaybeError,
    ]),
    usr: u0$Human$Format_Test$formatTest$3,
  }));
});

const u0$Human$Format_Test$formatTest$0 = ({
  ctx: [],
  usr: u0$Human$Format_Test$formatTest$1,
});

const u0$Human$Format_Test$calls$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Calls", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Arguments indentation", "a =\n   fun\n      #comment1\n      a\n        #comment2\n        b", "a =\n    fun\n        #comment1\n        a\n        #comment2\n        b\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "precedence", "a (b  c)", "a (b c)\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "With multiline args", "a =\n    (x >> y)\n       fn _:\n          a\n          b\n      (assert blah)\n      (zak meh)", "a =\n    (x >> y)\n        (fn _:\n             a\n\n             b\n        )\n        (assert blah)\n        (zak meh)\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve aligned", "a =\n    x fn _:\n    y", "a =\n    x fn _:\n    y\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve indent", "a =\n    x fn _:\n      y", "a =\n    x fn _:\n        y\n"), c0$Core$Nil$0))))));

const u0$Human$Format_Test$comments$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Comments", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] Should not add indent to empty lines", "if a then\n    [#\n\n        comment\n\n    #]\n    b\n  else\n    c", "if a then\n    [#\n\n        comment\n\n    #]\n    b\nelse\n    c\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve whether a comment has a trailing blank, line", "# blank\n\na = 1\n\n# no blank\nb = 1", "# blank\n\na =\n    1\n\n\n# no blank\nb =\n    1\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve whether a comment has a trailing blank, block", "[# blank #]\n\na = 1\n\n[# no blank #]\nb = 1", "[# blank #]\n\na =\n    1\n\n\n[# no blank #]\nb =\n    1\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Comment order is preserved", "# a\n# b\n# c\naaaaa =\n# d\n# e\n# f\n      bbbbb\n\n      #g\n      #h\n      #i\n      ccccc", "# a\n# b\n# c\naaaaa =\n# d\n# e\n# f\n    bbbbb\n\n    #g\n    #h\n    #i\n    ccccc\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Normal comments get indented, line", "a =\n # b\n    1", "a =\n    # b\n    1\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "\"Quick\" comments remain untouched, line", "a =\n# b\n  1", "a =\n# b\n    1\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Normal comments get indented, block", "a =\n [# b\nblah#]\n    1", "a =\n    [# b\n    blah#]\n    1\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "\"Quick\" comments remain untouched, block", "a =\n[# b\n#]\n  1", "a =\n[# b\n#]\n    1\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] Section comment should stay before the if", "f =\n    a = 1\n\n# comment\n\n    if a then\n        b\n      else\n        c", "f =\n    a =\n        1\n\n# comment\n\n    if a then\n        b\n    else\n        c\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] Block comment internal indent should remain consistent", "x =\n    [#\n        comment\n    #]\n    d", "x =\n    [#\n        comment\n    #]\n    d\n"), c0$Core$Nil$0)))))))))));

const u0$Human$Format_Test$definitions$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Definitions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Alias", "Meh a b = Int", "Meh a b =\n    Int\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Unions 1", "var Meh = 'meh z", "var Meh =\n    , 'meh z\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Unions 2", "var Meh a b = 'blah, 'meh x y z", "var Meh a b =\n    , 'blah\n    , 'meh x y z\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Annotated values", "(x as Type) & (y as Kind) = thing", "(x as Type) & (y as Kind) =\n    thing\n"), c0$Core$Nil$0)))));

const u0$Human$Format_Test$functions$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Functions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "SKIP (low priority) Named functions should always have their body below", "f =\n    fn a: fn b: c", "f =\n    fn a:\n    fn b:\n    c"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Named functions should always have their body below", "x =\n  a\n  >> onOk fn b:\n\n  c\n  >> onOk fn d:\n\n  e", "x =\n    a\n    >> onOk fn b:\n    c\n    >> onOk fn d:\n    e\n"), c0$Core$Nil$0)));

const u0$Human$Format_Test$ifs$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "if..then", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Single line", "x = if blah   then a  else b", "x =\n    if blah then a else b\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Make multiline", "x = if blah then\n      a = 1\n      a + b\n  else  b", "x =\n    if blah then\n        a =\n            1\n\n        a + b\n    else\n        b\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve multiline", "x =\n    if blah then\n        a\n    else b", "x =\n    if blah then\n        a\n    else\n        b\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "if else", "x = if blah then a else if o then b else q", "x =\n    if blah then\n        a\n    else if o then\n        b\n    else\n        q\n"), c0$Core$Nil$0)))));

const u0$Human$Format_Test$lists$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Lists", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve one-liners", "a = [1, 2, 3]", "a =\n    [ 1, 2, 3 ]\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve multilines", "a = [1\n  , 2, 3]", "a =\n    [\n    , 1\n    , 2\n    , 3\n    ]\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] weird shit happening when a definition is preceded by a blank line?", "\nll as [Int] = []", "ll as [ Int ] =\n    []\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Expansion", "\nll = [a..., b, fun arg..., (pas)...]", "ll =\n    [ a..., b, fun arg..., pas... ]\n"), c0$Core$Nil$0)))));

const u0$Human$Format_Test$operators$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Operators", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Precedence", "a = (1 + 2 * 3 + 4)\nb = 5*(6+ 7)*8", "a =\n    1 + 2 * 3 + 4\n\n\nb =\n    5 * (6 + 7) * 8\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Pipe on a single line stays on a single line", "a = b >> c >> d >> e", "a =\n    b >> c >> d >> e\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Pipe right gets indented if there is at least one line break", "a = b >> c\n  >> d >> e", "a =\n    b\n    >> c\n    >> d\n    >> e\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] Preserve comment", "escape =\n    x\n    # comment\n    >> replace\n    >> replace", "escape =\n    x\n    # comment\n    >> replace\n    >> replace\n"), c0$Core$Nil$0)))));

const u0$Human$Format_Test$records$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Records", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Reorder attributes", "a = { z, e, r }", "a =\n    { e, r, z }\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Comments", "a = {\n    , z = 1\n    # AAA\n    , e = 2\n    , r =\n      # BBB\n       3\n   }", "a =\n    {\n    # AAA\n    , e =\n        2\n    , r =\n        # BBB\n        3\n    , z = 1\n    }\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Extension", "{ z with e }", "{ z with e }\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Shorthands", "a = { b with c = .d }", "a =\n    { b with c = .d }\n"), c0$Core$Nil$0)))));

const u0$Human$Format_Test$textLiterals$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Text literals", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Single quotes escape quotes and backspaces", "a = \"\\\"\\\\\"", "a =\n    \"\\\"\\\\\"\n"), c0$Core$Nil$0));

const u0$Human$Format_Test$tryAs$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "try..as", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Compact", "x = try blah as\n  Just a: a\n  Nothing:  b", "x =\n    try blah as\n        Just a: a\n        Nothing: b\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Long", "x = try blah as\n  Just a:\n        b = 1\n        b + a\n  Nothing:  b", "x =\n    try blah as\n\n        Just a:\n            b =\n                1\n\n            b + a\n\n        Nothing:\n            b\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "SKIP (low priority) Preserves comments (compact)", "try e  as\n    T: 9\n    # comment\n    _:  10", "try e as\n    T: 9\n    # comment\n    _: 10\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserves comments (long, inline comments)", "try e as\n    # AAA\n    T:\n    # BBB\n        9\n    _: 10", "try e as\n\n    # AAA\n    T:\n        # BBB\n        9\n\n    _:\n        10\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserves comments (long, block comments)", "try e as\n    [# AAA #]\n    T:\n    [# BBB #]\n        9\n    _: 10", "try e as\n\n    [# AAA #]\n    T:\n        [# BBB #]\n        9\n\n    _:\n        10\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Comments", "x =\n          try char as\n            \"\":\n                None\n\n#            \"@\":\n\n            \"#\":\n                start\n", "x =\n    try char as\n\n        \"\":\n            None\n\n#            \"@\":\n\n        \"#\":\n            start\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] Should not move a comma inside a multi-line comment", "try char as\n  a: b\n\n  [#\n  comment\n  #]\n\n  d: c", "try char as\n\n    a:\n        b\n\n    [#\n    comment\n    #]\n\n    d:\n        c\n"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "[reg] Comments should not cause content to multiline", "try value as\n\n    # TODO restore `None` here once it doesn't break JS any more\n    Err _:\n        formatIndented", "try value as\n\n    # TODO restore `None` here once it doesn't break JS any more\n    Err _:\n        formatIndented\n"), c0$Core$Nil$0)))))))));

const u0$Human$Format_Test$uniqueness$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Uniqueness", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Human$Format_Test$formatTest$0.usr)(...(u0$Human$Format_Test$formatTest$0.ctx), "Preserve uniqueness annotations", "f as fn !a, 2?b, @c: !d = fn !a, 2?b, @c: blah", "f as fn !a, 2?b, @c: !d =\n    fn !a, 2?b, @c: blah\n"), c0$Core$Nil$0));

const u0$Human$Format_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Formatter", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$definitions$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$operators$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$functions$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$calls$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$lists$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$records$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$comments$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$textLiterals$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$uniqueness$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$tryAs$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$ifs$0, c0$Core$Nil$0))))))))))));

const u0$SPLib$Format$spaceSeparatedOrIndentForce$1 = (($force, $blocks) => {
  return (u0$SPLib$Format$rowOrIndentForce$0.usr)(...(u0$SPLib$Format$rowOrIndentForce$0.ctx), $force, (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), u0$SPLib$Format$space$0), $blocks);
});

const u0$SPLib$Format$spaceSeparatedOrIndentForce$0 = ({
  ctx: [],
  usr: u0$SPLib$Format$spaceSeparatedOrIndentForce$1,
});

const u0$SPLib$Format_Test$format1$2 = (($0) => {
  return (sp_not_equal)($0, "");
});

const u0$SPLib$Format_Test$format1$1 = (($breakFirst, $breakRest, $f, $1) => {
  const $arg0 = ($1)[1];
  const $args = ($1)[2];
  return (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
    ctx: [],
    usr: u0$SPLib$Format_Test$format1$2,
  }), (text_split)("\n", (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$SPLib$Format$spaceSeparatedOrIndentForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndentForce$0.ctx), $breakRest, (sp_cons)((u0$SPLib$Format$spaceSeparatedOrIndentForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndentForce$0.ctx), $breakFirst, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $f, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $arg0, c0$Core$Nil$0))), $args)))));
});

const u0$SPLib$Format_Test$format1$0 = ({
  ctx: [],
  usr: u0$SPLib$Format_Test$format1$1,
});

const u0$SPLib$Format_Test$format2$4 = (($0) => {
  return (sp_not_equal)($0, "");
});

const u0$SPLib$Format_Test$format2$3 = (($formatEntry, $0) => {
  return ($formatEntry.usr)(...($formatEntry.ctx), ",", $0);
});

const u0$SPLib$Format_Test$format2$2 = (($open, $block) => {
  return (u0$SPLib$Format$prefix$0.usr)(...(u0$SPLib$Format$prefix$0.ctx), 2, (u0$SPLib$Format$Row$0.usr)(...(u0$SPLib$Format$Row$0.ctx), (u0$SPLib$Format$Text_$0.usr)(...(u0$SPLib$Format$Text_$0.ctx), $open), u0$SPLib$Format$space$0), $block);
});

const u0$SPLib$Format_Test$format2$1 = (($break, $1) => {
  const $first = ($1)[1];
  const $rest = ($1)[2];
  const $formatEntry = ({
    ctx: [],
    usr: u0$SPLib$Format_Test$format2$2,
  });
  return (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
    ctx: [],
    usr: u0$SPLib$Format_Test$format2$4,
  }), (text_split)("\n", (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$SPLib$Format$spaceSeparatedOrStackForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrStackForce$0.ctx), $break, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$rowOrStackForce$0.usr)(...(u0$SPLib$Format$rowOrStackForce$0.ctx), $break, c0$Maybe$Nothing$0, (sp_cons)(($formatEntry.usr)(...($formatEntry.ctx), "[", $first), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $formatEntry,
    ]),
    usr: u0$SPLib$Format_Test$format2$3,
  }), $rest))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "]"), c0$Core$Nil$0))))));
});

const u0$SPLib$Format_Test$format2$0 = ({
  ctx: [],
  usr: u0$SPLib$Format_Test$format2$1,
});

const u0$SPLib$Format_Test$format3$4 = (($0) => {
  return (sp_not_equal)($0, "");
});

const u0$SPLib$Format_Test$format3$3 = (($formatEntry, $0) => {
  return ($formatEntry.usr)(...($formatEntry.ctx), ",", $0);
});

const u0$SPLib$Format_Test$format3$2 = (($open, $1) => {
  const $key = $1.first;
  const $break = $1.second;
  const $value = $1.third;
  return (u0$SPLib$Format$spaceSeparatedOrIndentForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndentForce$0.ctx), $break, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$spaceSeparatedOrStack$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrStack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), $open), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $key, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "="), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $value, c0$Core$Nil$0)));
});

const u0$SPLib$Format_Test$format3$1 = (($1) => {
  const $first = ($1)[1];
  const $rest = ($1)[2];
  const $formatEntry = ({
    ctx: [],
    usr: u0$SPLib$Format_Test$format3$2,
  });
  return (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
    ctx: [],
    usr: u0$SPLib$Format_Test$format3$4,
  }), (text_split)("\n", (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$SPLib$Format$stack$0.usr)(...(u0$SPLib$Format$stack$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($formatEntry.usr)(...($formatEntry.ctx), "{", $first), c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $formatEntry,
    ]),
    usr: u0$SPLib$Format_Test$format3$3,
  }), $rest), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "}"), c0$Core$Nil$0), c0$Core$Nil$0))))))));
});

const u0$SPLib$Format_Test$format3$0 = ({
  ctx: [],
  usr: u0$SPLib$Format_Test$format3$1,
});

const u0$SPLib$Format_Test$format4$2 = (($0) => {
  return (sp_not_equal)($0, "");
});

const u0$SPLib$Format_Test$format4$1 = (($breakCond, $breakBodies, $2, $elseBody) => {
  const $ifCond = $2.first;
  const $ifBody = $2.second;
  return (c0$List$filter$0.usr)(...(c0$List$filter$0.ctx), ({
    ctx: [],
    usr: u0$SPLib$Format_Test$format4$2,
  }), (text_split)("\n", (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$SPLib$Format$spaceSeparatedOrStack$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrStack$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$spaceSeparatedOrIndentForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndentForce$0.ctx), $breakBodies, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$rowOrStack$0.usr)(...(u0$SPLib$Format$rowOrStack$0.ctx), c0$Maybe$Nothing$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$rowOrIndentForce$0.usr)(...(u0$SPLib$Format$rowOrIndentForce$0.ctx), $breakCond, c0$Maybe$Nothing$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "if ("), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $ifCond, c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), ") {"), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $ifBody, c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$spaceSeparatedOrIndentForce$0.usr)(...(u0$SPLib$Format$spaceSeparatedOrIndentForce$0.ctx), ($breakBodies || $breakCond), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "} else {"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $elseBody, c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "}"), c0$Core$Nil$0)))))));
});

const u0$SPLib$Format_Test$format4$0 = ({
  ctx: [],
  usr: u0$SPLib$Format_Test$format4$1,
});

const u0$SPLib$Format_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const u0$SPLib$Format_Test$valueTest$0 = ({
  ctx: [],
  usr: u0$SPLib$Format_Test$valueTest$1,
});

const u0$SPLib$Format_Test$tests$10 = ((_0) => {
  return (u0$SPLib$Format_Test$format1$0.usr)(...(u0$SPLib$Format_Test$format1$0.ctx), false, false, (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "f"), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$textToBlock$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", c0$Core$Nil$0))));
});

const u0$SPLib$Format_Test$tests$9 = ((_0) => {
  return (u0$SPLib$Format_Test$format1$0.usr)(...(u0$SPLib$Format_Test$format1$0.ctx), true, false, (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "f"), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$textToBlock$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", c0$Core$Nil$0))));
});

const u0$SPLib$Format_Test$tests$8 = ((_0) => {
  return (u0$SPLib$Format_Test$format1$0.usr)(...(u0$SPLib$Format_Test$format1$0.ctx), false, true, (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "f"), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$textToBlock$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", c0$Core$Nil$0))));
});

const u0$SPLib$Format_Test$tests$7 = ((_0) => {
  return (u0$SPLib$Format_Test$format2$0.usr)(...(u0$SPLib$Format_Test$format2$0.ctx), false, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$textToBlock$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", c0$Core$Nil$0)))));
});

const u0$SPLib$Format_Test$tests$6 = ((_0) => {
  return (u0$SPLib$Format_Test$format2$0.usr)(...(u0$SPLib$Format_Test$format2$0.ctx), true, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$SPLib$Format$textToBlock$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", c0$Core$Nil$0)))));
});

const u0$SPLib$Format_Test$tests$5 = ((_0) => {
  return (u0$SPLib$Format_Test$format3$0.usr)(...(u0$SPLib$Format_Test$format3$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "a"),
    second: false,
    third: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "1"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "b"),
    second: false,
    third: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "2"),
  }), c0$Core$Nil$0)));
});

const u0$SPLib$Format_Test$tests$4 = ((_0) => {
  return (u0$SPLib$Format_Test$format3$0.usr)(...(u0$SPLib$Format_Test$format3$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "a"),
    second: true,
    third: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "1"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "b"),
    second: false,
    third: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "2"),
  }), c0$Core$Nil$0)));
});

const u0$SPLib$Format_Test$tests$3 = ((_0) => {
  return (u0$SPLib$Format_Test$format4$0.usr)(...(u0$SPLib$Format_Test$format4$0.ctx), false, false, ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "p"),
    second: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "a"),
  }), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "b"));
});

const u0$SPLib$Format_Test$tests$2 = ((_0) => {
  return (u0$SPLib$Format_Test$format4$0.usr)(...(u0$SPLib$Format_Test$format4$0.ctx), false, true, ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "p"),
    second: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "a"),
  }), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "b"));
});

const u0$SPLib$Format_Test$tests$1 = ((_0) => {
  return (u0$SPLib$Format_Test$format4$0.usr)(...(u0$SPLib$Format_Test$format4$0.ctx), true, false, ({
    first: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "p"),
    second: (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "a"),
  }), (u0$SPLib$Format$textToBlock$0.usr)(...(u0$SPLib$Format$textToBlock$0.ctx), "b"));
});

const u0$SPLib$Format_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Block examples", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Elm-like examples", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "function application", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "Formats on a single line", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$10,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "f a b", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats with all arguments split", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$9,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "f", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    b", c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats with first argument joined", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$8,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "f a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    b", c0$Core$Nil$0)))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "list", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats single-line", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$7,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "[ a, b, c ]", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats multiline", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$6,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "[ a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ", b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ", c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "]", c0$Core$Nil$0)))))), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "record", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats single-line entries", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$5,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "{ a = 1", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ", b = 2", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "}", c0$Core$Nil$0))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats multiline entries", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$4,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "{ a =", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    1", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ", b = 2", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "}", c0$Core$Nil$0)))))), c0$Core$Nil$0))), c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Javascript-like examples", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "if-else", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats single-line", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$3,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "if (p) { a } else { b }", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats multiline", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "if (p) {", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "} else {", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "}", c0$Core$Nil$0))))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$Format_Test$valueTest$0.usr)(...(u0$SPLib$Format_Test$valueTest$0.ctx), "formats multiline condition", ({
  ctx: [],
  usr: u0$SPLib$Format_Test$tests$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "if (", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    p", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ") {", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "} else {", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "    b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "}", c0$Core$Nil$0))))))))), c0$Core$Nil$0)))), c0$Core$Nil$0)), c0$Core$Nil$0)));

const u0$SPLib$RefHierarchy_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const u0$SPLib$RefHierarchy_Test$valueTest$0 = ({
  ctx: [],
  usr: u0$SPLib$RefHierarchy_Test$valueTest$1,
});

const u0$SPLib$RefHierarchy_Test$canonicalJsTest$1 = ((_0) => {
  return (basics_compare)(null, null);
});

const u0$SPLib$RefHierarchy_Test$canonicalJsTest$0 = (u0$SPLib$RefHierarchy_Test$valueTest$0.usr)(...(u0$SPLib$RefHierarchy_Test$valueTest$0.ctx), "[reg] THIS SHOULD BE IN CANONICALTOJS", ({
  ctx: [],
  usr: u0$SPLib$RefHierarchy_Test$canonicalJsTest$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), 0));

const u0$SPLib$RefHierarchy_Test$graph1$1 = (($k, $l) => {
  return ({
    first: $k,
    second: ({
      first: $k,
      second: (c0$Set$fromList$0.usr)(...(c0$Set$fromList$0.ctx), $l),
    }),
  });
});

const u0$SPLib$RefHierarchy_Test$graph1$0 = ((() => {
  const $x = ({
    ctx: [],
    usr: u0$SPLib$RefHierarchy_Test$graph1$1,
  });
  return (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "e", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "e", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "d", c0$Core$Nil$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "e", c0$Core$Nil$0), c0$Core$Nil$0))))));
}))();

const u0$SPLib$RefHierarchy_Test$graph2$1 = (($k, $l) => {
  return ({
    first: $k,
    second: ({
      first: $k,
      second: (c0$Set$fromList$0.usr)(...(c0$Set$fromList$0.ctx), $l),
    }),
  });
});

const u0$SPLib$RefHierarchy_Test$graph2$0 = ((() => {
  const $x = ({
    ctx: [],
    usr: u0$SPLib$RefHierarchy_Test$graph2$1,
  });
  return (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "a", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "e", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "e", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "d", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($x.usr)(...($x.ctx), "e", c0$Core$Nil$0), c0$Core$Nil$0))))));
}))();

const u0$SPLib$RefHierarchy_Test$tests$2 = ((_0) => {
  return (u0$SPLib$RefHierarchy$reorder$0.usr)(...(u0$SPLib$RefHierarchy$reorder$0.ctx), c0$Tuple$second$0, u0$SPLib$RefHierarchy_Test$graph1$0);
});

const u0$SPLib$RefHierarchy_Test$tests$1 = ((_0) => {
  return (u0$SPLib$RefHierarchy$reorder$0.usr)(...(u0$SPLib$RefHierarchy$reorder$0.ctx), c0$Tuple$second$0, u0$SPLib$RefHierarchy_Test$graph2$0);
});

const u0$SPLib$RefHierarchy_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "RefHierarchy", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$RefHierarchy_Test$canonicalJsTest$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$RefHierarchy_Test$valueTest$0.usr)(...(u0$SPLib$RefHierarchy_Test$valueTest$0.ctx), "Basic", ({
  ctx: [],
  usr: u0$SPLib$RefHierarchy_Test$tests$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  first: c0$Core$Nil$0,
  second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "e", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0))))),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$SPLib$RefHierarchy_Test$valueTest$0.usr)(...(u0$SPLib$RefHierarchy_Test$valueTest$0.ctx), "Circular", ({
  ctx: [],
  usr: u0$SPLib$RefHierarchy_Test$tests$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  first: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", c0$Core$Nil$0))), c0$Core$Nil$0),
  second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "d", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "e", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "c", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "b", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "a", c0$Core$Nil$0))))),
}))), c0$Core$Nil$0))));

const u0$Targets$Emitted_Test$valueTest$1 = (($0, $1, $2) => {
  return (i2$Test$valueTest$0.usr)(...(i2$Test$valueTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2);
});

const u0$Targets$Emitted_Test$valueTest$0 = ({
  ctx: [],
  usr: u0$Targets$Emitted_Test$valueTest$1,
});

const u0$Targets$Emitted_Test$javascript$2 = ((_0) => {
  let $2 = false;
  (!($2)
    ? 1
    : ($2
      ? 2
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Emitted_Test.sp 32:17', (sp_toHuman)($2))));
  return "abc";
});

const u0$Targets$Emitted_Test$javascript$1 = ((_0) => {
  let $2 = null;
  return (true
    ? 1
    : (sp_throw)('Missing pattern in try..as', 'src/Targets/Emitted_Test.sp 44:17', (sp_toHuman)($2)));
});

const u0$Targets$Emitted_Test$javascript$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "JavaScript", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Emitted_Test$valueTest$0.usr)(...(u0$Targets$Emitted_Test$valueTest$0.ctx), "[reg] Imperative try..as should not force the function to return prematurely", ({
  ctx: [],
  usr: u0$Targets$Emitted_Test$javascript$2,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), "abc")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Emitted_Test$valueTest$0.usr)(...(u0$Targets$Emitted_Test$valueTest$0.ctx), "[reg] Pattern matching fails on None", ({
  ctx: [],
  usr: u0$Targets$Emitted_Test$javascript$1,
}), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), 1)), c0$Core$Nil$0)));

const u0$Targets$Emitted_Test$tests$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Emitted", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Targets$Emitted_Test$javascript$0, c0$Core$Nil$0));

const u1$Uniqueness$codeTest$1 = (($0, $1, $2, $3) => {
  return (i2$Test$codeTest$0.usr)(...(i2$Test$codeTest$0.ctx), ({
    ctx: [],
    usr: sp_toHuman,
  }), $0, $1, $2, $3);
});

const u1$Uniqueness$codeTest$0 = ({
  ctx: [],
  usr: u1$Uniqueness$codeTest$1,
});

const u1$Uniqueness$infer$0 = u0$Compiler$TypeCheck_Test$infer$0;

const u1$Uniqueness$howDoesItLookLike$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "How does mutability look like?", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Example: maintaining mutable state", "someFunction = this_is_sp_native\n\naverage as fn [Number]: Number =\n    fn numbers:\n\n    # Unique values can be changed in place, ie, \"mutated\"\n    !total as Number =\n        0\n\n    !count as Number =\n        0\n\n    someFunction numbers fn number:\n        @total += number\n        @count += 1\n\n    # In Squarepants division by 0 yields 0\n    total / count", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "average"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "SKIP (needs IO in the test env) Example: File IO", "logToFile as fn @IO, Text: Result IO.Error None =\n    fn @io, content:\n\n    IO.openFile @io IO.Append \"blah.log\"\n    >> isOk fn @fileDescriptor:\n\n    IO.writeFile @io content @fileDescriptor\n\n    # fileDescriptor is automatically closed here", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "logToFile"), i2$Test$isOk$0), c0$Core$Nil$0)));

const u1$Uniqueness$mutation$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Mutation", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Uniques can be mutated in place", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Mutation does NOT consume the unique", "scope =\n    !x = 1\n    @x += 1\n    @x += 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Recycling requires the unique not to be spent", "someFunction = this_is_sp_native\n\nscope =\n    !x = 1\n    someFunction x\n    @x += 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "used again here", c0$Core$Nil$0))), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "A function can be defined to mutate its arguments", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "base", "funz as fn @Number: None =\n    fn @a:\n    @a += 3\n\nscope =\n    !x = 0\n    funz @x\n    funz @x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Calling a function that recycles a unique variable temporarily consumes the variable.", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "base", "someFunction = this_is_sp_native\nscope =\n    !x = 0\n    someFunction @x @x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "twice", c0$Core$Nil$0))), c0$Core$Nil$0)), c0$Core$Nil$0))));

const u1$Uniqueness$parentScope$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Recycling a variable in the parent scope", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "A function that recycles any unique belonging to an ancestor scope \"requires\" that unique.", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "LetIns cannot return functions with requirements", "scope =\n    !x =\n        1\n\n    f =\n        fn n:\n        @x += n\n        'none\n\n    f", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "from outside", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Functions cannot return functions with UNIQUE requirements", "f =\n    fn !x:\n    fn n:\n    @x += n\n    'none", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "from outside", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Functions cannot return functions with RECYCLED requirements", "f =\n    fn @x:\n    fn n:\n    @x += n\n    'none", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "from outside", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "The Array Test", "var Array_ a = 'meh\n\narray_push as fn a, @Array_ a: None =\n    this_is_sp_native\n\naddFunctions as fn @Array_ (fn Number: Number): None =\n    fn @functions:\n\n    !x =\n        1\n\n    f as fn Number: Number =\n        fn n:\n        @x += 1\n        n\n\n    array_push f @functions\n    'none", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "addFunctions"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "outside", c0$Core$Nil$0)))), c0$Core$Nil$0))))), c0$Core$Nil$0));

const u1$Uniqueness$polymorphism$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Polymorphism", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Basic syntax", "fun as fn (fn 1?a: 2?b), 1?a: 2?b =\n    fn f, 1?a:\n\n    f a", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "fun"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "A function that returns a Uni can be used in place of a function that returns an Imm", "meh as fn (fn None: Number): Number =\n    fn f: f 'none\n\nblah = meh (fn 'none: 1)", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "blah"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "A function that returns an Imm CANNOT be used in place of a function that returns an Uni", "meh as fn (fn None: !Number): !Number =\n    fn f: f 'none\n\nx as Number = 1\n\nblah = meh (fn 'none: x)", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "blah"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "return", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "uniqueness", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "a Uni, b Uni", "var Re error payload = 'er error, 'okk payload\nisOkk as fn (fn 1?a: 2?Re error b), 1?Re error a: 2?Re error b = this_is_sp_native\n\nscope =\n    !v = isOkk (fn !a: 'okk 0) ('okk 0)", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "a Uni, b Imm", "var Result_ error payload = 'err_ error, 'ok_ payload\nisOk_ as fn (fn 1?a: 2?Result_ error b), 1?Result_ error a: 2?Result_ error b = this_is_sp_native\nimmB as Number = 1\n\nv = isOk_ (fn !a: 'ok_ immB) ('ok_ 0)", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "v"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "No annotation", "na = fn 0?x: x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "na"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: (c0$Dict$ofOne$0.usr)(...(c0$Dict$ofOne$0.ctx), 1, ({
    maybeAnnotated: c0$Maybe$Nothing$0,
  })),
  type: (c0$Compiler$TypedAst$TypeFn$0.usr)(...(c0$Compiler$TypedAst$TypeFn$0.ctx), c0$Compiler$Pos$T$0, 1, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (c0$Compiler$TypedAst$ParSp$0.usr)(...(c0$Compiler$TypedAst$ParSp$0.ctx), ({
    raw: (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$T$0, 1),
    uni: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), 0),
  })), c0$Core$Nil$0), ({
    raw: (c0$Compiler$TypedAst$TypeVar$0.usr)(...(c0$Compiler$TypedAst$TypeVar$0.ctx), c0$Compiler$Pos$T$0, 1),
    uni: (c0$Compiler$Ast$Depends$0.usr)(...(c0$Compiler$Ast$Depends$0.ctx), 0),
  })),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Generalization", "na as fn 1?a: 1?a =\n    fn 1?x: x\n\nscope as None =\n    !uni = na 0\n\nnone as None =\n    na scope", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "na"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "[rec] variable without any uniqueness flag should be imm", "scope =\n    num = 1\n\n    x as Number = num + 1\n    y as Number = num + 2", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), c0$Core$Nil$0)))))))));

const u1$Uniqueness$records$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Records", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "The attribute of a mutable record can be accessed as a mutable:", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Simple case", "scope =\n    !record = { x = 0, y = 0 }\n    @record.x += 3", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Reject double reference", "someFunction =\n    this_is_sp_native\n\nscope =\n    !record = { x = 0, y = 0 }\n    someFunction @record.x @record.y", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "same unique twice in the same function call", c0$Core$Nil$0))), c0$Core$Nil$0))), c0$Core$Nil$0));

const u1$Uniqueness$unions$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Unions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Uniques inside immutables are converted to immutables", "var Z a = 'z a\nx = 'z 0", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "x"), (i2$Test$isOkAndEqualTo$0.usr)(...(i2$Test$isOkAndEqualTo$0.ctx), ({
  freeTyvars: c0$Dict$empty$0,
  type: (c0$Compiler$TypedAst$TypeExact$0.usr)(...(c0$Compiler$TypedAst$TypeExact$0.ctx), c0$Compiler$Pos$T$0, (u0$Compiler$TestHelpers$moduleUsr$0.usr)(...(u0$Compiler$TestHelpers$moduleUsr$0.ctx), "Z"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TestHelpers$taNumber$0, c0$Core$Nil$0)),
}))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "[reg] Lists of immutables", "i as Number = 1\nx = [ i, i ]", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "x"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "[reg] solveOneEquality can receive switched given/required when evaluating a cast?", "z as [fn None: None] = (fn 'none: 'none) :: []", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "z"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "LetIn: Unpack immutable to immutable", "var Z a = 'z a\nscope =\n    x = 'z 0\n    ('z y) = x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "LetIn: Unpack unique to immutable", "var Z a = 'z a\nscope =\n    !x = 'z 0\n    ('z y) = x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "LetIn: Unpack unique to unique", "var Z a = 'z a\nscope =\n    !x = 'z 0\n    !('z y) = x\n    @y += 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "LetIn: Unpack immutable to unique", "var Z a = 'z a\nscope =\n    x = 'z 0\n    !('z y) = x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "y", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Unique", c0$Core$Nil$0)))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Fn: Unpack immutable to immutable", "var Z a = 'z a\nf as fn Z a: Z a =\n     fn 'z a: 'z a", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Fn: Unpack unique to immutable", "var Z a = 'z a\nf as fn !(Z a): Z a =\n     fn !('z a): 'z a", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Fn: Unpack unique to unique", "var Z a = 'z a\nf as fn !(Z a): !(Z a) =\n     fn !('z a): 'z a", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Fn: Unpack immutable to unique", "var Z a = 'z a\nf as fn Z a: !(Z a) =\n     fn 'z a: 'z a", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "Unique", c0$Core$Nil$0))), c0$Core$Nil$0))))))))))));

const u1$Uniqueness$uniquenessTyping$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Uniqueness Typing", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "All literal expressions allow uniqueness", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "failure", "f as fn Number: !Number = fn x: x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "ErrorUniquenessDoesNotMatch", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Number", "f as fn a: !Number = fn _: 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Text", "f as fn a: !Text = fn _: \"meh\"", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Record", "f as fn a: !{} = fn _: {}", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Constructor 1", "f as fn a: !Bool = fn _: 'true", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "f"), i2$Test$isOk$0), c0$Core$Nil$0)))))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Conversions", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Immutables cannot be used in place of uniques 2", "scope =\n    x = 1\n    @x += 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "a"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "ErrorShouldBeUnique", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "Uniques can be implicitly transformed in immutables", "a as Number = 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "a"), i2$Test$isOk$0), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "A variable with mutable type must be explicitly declared as mutable with `!`", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "1", "z =\n    !a as Number = 1", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "z"), i2$Test$isOk$0), c0$Core$Nil$0)), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Referencing a mutable variable \"spends\" it", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "base", "scope =\n    !x =\n        1\n\n    !y =\n        # The first time we do it it works!\n        x\n\n    !z =\n        # But here `x` is now spent, so we get a compiler error!\n        x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "used already here", c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "tuple", "scope =\n    !x =\n        1\n\n    !y =\n        x & x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "used already here", c0$Core$Nil$0))), c0$Core$Nil$0))), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "A function cannot consume uniques outside its own scope.", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u1$Uniqueness$codeTest$0.usr)(...(u1$Uniqueness$codeTest$0.ctx), "base", "scope =\n    !x = 1\n    fn z: x", (u1$Uniqueness$infer$0.usr)(...(u1$Uniqueness$infer$0.ctx), "scope"), (i2$Test$errorContains$0.usr)(...(i2$Test$errorContains$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "outside their body", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "x", c0$Core$Nil$0)))), c0$Core$Nil$0)), c0$Core$Nil$0))))));

const u1$Uniqueness$specs$0 = (i2$Test$Group$0.usr)(...(i2$Test$Group$0.ctx), "Uniqueness", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$howDoesItLookLike$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$uniquenessTyping$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$mutation$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$parentScope$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$polymorphism$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$unions$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$records$0, c0$Core$Nil$0))))))));

const u0$Main$allTests$0 = (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Human$Format_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Lexer_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$Parser_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$MakeCanonical_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Compiler$TypeCheck_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Targets$Emitted_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Hash_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Array_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$List_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Dict_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), c0$Self_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u1$Uniqueness$specs$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$Format_Test$tests$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$SPLib$RefHierarchy_Test$tests$0, c0$Core$Nil$0))))))))))))));

const u0$Targets$Javascript$EmittableToJs$accessAttrs$1 = (($attrPath, $e) => {
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $e, $attrPath, u0$Targets$Javascript$Ast$AccessWithDot$0);
});

const u0$Targets$Javascript$EmittableToJs$accessAttrs$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$accessAttrs$1,
});

const u0$Targets$Javascript$EmittableToJs$_usrToText$1 = (($0) => {
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "$", $0);
});

const u0$Targets$Javascript$EmittableToJs$_usrToText$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$_usrToText$1,
});

const u0$Targets$Javascript$EmittableToJs$accessArrayIndex$1 = (($index, $j) => {
  return (u0$Targets$Javascript$Ast$AccessWithBrackets$0.usr)(...(u0$Targets$Javascript$Ast$AccessWithBrackets$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), (text_fromNumber)($index)), $j);
});

const u0$Targets$Javascript$EmittableToJs$accessArrayIndex$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$accessArrayIndex$1,
});

const u0$Targets$Javascript$EmittableToJs$typeIsPointy$1 = (($raw) => {
  return ((($raw)[0] === "$TypeRecord")
    ? true
    : (((($raw)[0] === "$TypeExact") && (((($raw)[2])[0] === "$USR") && ((((($raw)[2])[1])[0] === "$UMR") && ((((($raw)[2])[1])[1])[0] === "$Core"))))
      ? ((() => {
        const $pathId = ((($raw)[2])[1])[2];
        const $moduleName = ((($raw)[2])[1])[3];
        const $typeName = (($raw)[2])[2];
        const $2 = ({
          first: $moduleName,
          second: $typeName,
        });
        return ((("Array" === $2.first) && ("Array" === $2.second))
          ? true
          : ((("Hash" === $2.first) && ("Hash" === $2.second))
            ? true
            : (true
              ? false
              : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 404:12', (sp_toHuman)($2)))));
      }))()
      : (true
        ? false
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 398:4', (sp_toHuman)($raw)))));
});

const u0$Targets$Javascript$EmittableToJs$typeIsPointy$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$typeIsPointy$1,
});

const u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$1 = (($ref, $raw) => {
  return ((u0$Targets$Javascript$EmittableToJs$typeIsPointy$0.usr)(...(u0$Targets$Javascript$EmittableToJs$typeIsPointy$0.ctx), $raw)
    ? null
    : ((() => {
      (sp_log)("JS does not support this type as mutable: ", $raw);
      (sp_log)("Please wrap it into a record or something in", $ref);
      (sp_log)("sorry for this T_T", "");
      return (sp_todo)("aborting");
    }))());
});

const u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$1,
});

const u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$1 = (($ref, $1) => {
  const $raw = $1.raw;
  const $uni = $1.uni;
  return ((($uni)[0] === "$Uni")
    ? (u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$0.usr)(...(u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$0.ctx), $ref, $raw)
    : (true
      ? null
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 415:4', (sp_toHuman)($uni))));
});

const u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$1,
});

const u0$Targets$Javascript$EmittableToJs$contextCall$2 = (($env, $0) => {
  return (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
    nativeBinop: false,
  }), $env, $0);
});

const u0$Targets$Javascript$EmittableToJs$contextCall$1 = (($env, $jaRef, $eaArgs) => {
  return (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), (u0$Targets$Javascript$Ast$AccessWithDot$0.usr)(...(u0$Targets$Javascript$Ast$AccessWithDot$0.ctx), "usr", $jaRef), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$Ast$ThreeDots$0.usr)(...(u0$Targets$Javascript$Ast$ThreeDots$0.ctx), (u0$Targets$Javascript$Ast$AccessWithDot$0.usr)(...(u0$Targets$Javascript$Ast$AccessWithDot$0.ctx), "ctx", $jaRef)), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Targets$Javascript$EmittableToJs$contextCall$2,
  }), $eaArgs)));
});

const u0$Targets$Javascript$EmittableToJs$contextCall$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$contextCall$1,
});

const u0$Targets$Javascript$EmittableToJs$literalString$1 = (($str) => {
  const $escaped = $str;
  return (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), (("\"" + $escaped) + "\""));
});

const u0$Targets$Javascript$EmittableToJs$literalString$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$literalString$1,
});

const u0$Targets$Javascript$EmittableToJs$maybeOverrideUsr$1 = (($env, $usr) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $env.overrides);
  return (((($3)[0] === "$Just") && ((($3)[1])[0] === "$Override"))
    ? ((() => {
      const $call = (($3)[1])[1].call;
      const $value = (($3)[1])[1].value;
      return ($value.usr)(...($value.ctx), $env);
    }))()
    : ((($3)[0] === "$Nothing")
      ? (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $usr))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 255:4', (sp_toHuman)($3))));
});

const u0$Targets$Javascript$EmittableToJs$maybeOverrideUsr$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$maybeOverrideUsr$1,
});

const u0$Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor$1 = (($env, $usr) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $env.overrides);
  return (((($3)[0] === "$Just") && ((($3)[1])[0] === "$Override"))
    ? ((() => {
      const $call = (($3)[1])[1].call;
      const $value = (($3)[1])[1].value;
      return ($value.usr)(...($value.ctx), $env);
    }))()
    : ((($3)[0] === "$Nothing")
      ? (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $usr))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 262:4', (sp_toHuman)($3))));
});

const u0$Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor$1,
});

const u0$Targets$Javascript$EmittableToJs$translateName$1 = (($0) => {
  return ("$" + (c0$Compiler$EmittableAst$translateName$0.usr)(...(c0$Compiler$EmittableAst$translateName$0.ctx), $0));
});

const u0$Targets$Javascript$EmittableToJs$translateName$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateName$1,
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$6 = (($0) => {
  return (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $0));
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$5 = (($usr, $name, $full) => {
  return (u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$0.usr)(...(u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$0.ctx), $usr, $full);
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$4 = (($test, $expr) => {
  return (u0$Targets$Javascript$Ast$Binop$0.usr)(...(u0$Targets$Javascript$Ast$Binop$0.ctx), "&&", $test, $expr);
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$3 = (($env, $0) => {
  return (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $0);
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$2 = (($env, $2, $d) => {
  const $name = $2.first;
  const $value = $2.second;
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), $name, (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $value), $d);
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$1 = (($env, $mustReturnValue, $eaExpression) => {
  const $perhapsReturn = ($mustReturnValue
    ? u0$Targets$Javascript$Ast$Return$0
    : u0$Targets$Javascript$Ast$Eval$0);
  return ((($eaExpression)[0] === "$LocalVariable")
    ? ((() => {
      const $name = ($eaExpression)[1];
      return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $name)));
    }))()
    : ((($eaExpression)[0] === "$PlaceholderVariable")
      ? ((() => {
        const $n = ($eaExpression)[1];
        return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), (text_fromNumber)($n))));
      }))()
      : ((($eaExpression)[0] === "$GlobalVariable")
        ? ((() => {
          const $usr = ($eaExpression)[1];
          return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$EmittableToJs$maybeOverrideUsr$0.usr)(...(u0$Targets$Javascript$EmittableToJs$maybeOverrideUsr$0.ctx), $env, $usr));
        }))()
        : ((($eaExpression)[0] === "$Call")
          ? ((() => {
            const $ref = ($eaExpression)[1];
            const $args = ($eaExpression)[2];
            const $maybeNativeOverride = ((($ref)[0] === "$GlobalVariable")
              ? ((() => {
                const $usr = ($ref)[1];
                return (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $usr, $env.overrides);
              }))()
              : (true
                ? c0$Maybe$Nothing$0
                : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 465:16', (sp_toHuman)($ref))));
            return (((($maybeNativeOverride)[0] === "$Just") && ((($maybeNativeOverride)[1])[0] === "$Override"))
              ? ((() => {
                const $call = (($maybeNativeOverride)[1])[1].call;
                return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), ($call.usr)(...($call.ctx), $env, $args));
              }))()
              : ((($maybeNativeOverride)[0] === "$Nothing")
                ? (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$EmittableToJs$contextCall$0.usr)(...(u0$Targets$Javascript$EmittableToJs$contextCall$0.ctx), $env, (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $ref), $args))
                : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 469:12', (sp_toHuman)($maybeNativeOverride))));
          }))()
          : ((($eaExpression)[0] === "$Lambda")
            ? ((() => {
              const $usr = ($eaExpression)[1];
              const $context = ($eaExpression)[2];
              (c0$Dict$each$0.usr)(...(c0$Dict$each$0.ctx), $context, ({
                ctx: ([
                  $usr,
                ]),
                usr: u0$Targets$Javascript$EmittableToJs$translateExpression$5,
              }));
              const $contextItems = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                ctx: [],
                usr: u0$Targets$Javascript$EmittableToJs$translateExpression$6,
              }), (c0$Dict$keys$0.usr)(...(c0$Dict$keys$0.ctx), $context));
              return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Record$0.usr)(...(u0$Targets$Javascript$Ast$Record$0.ctx), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
                first: "usr",
                second: (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $usr)),
              }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
                first: "ctx",
                second: (u0$Targets$Javascript$Ast$Array$0.usr)(...(u0$Targets$Javascript$Ast$Array$0.ctx), $contextItems),
              }), c0$Core$Nil$0)))));
            }))()
            : ((($eaExpression)[0] === "$LetIn")
              ? ((() => {
                const $inExpression = ($eaExpression)[1].inExpression;
                const $letExpression = ($eaExpression)[1].letExpression;
                const $maybeName = ($eaExpression)[1].maybeName;
                const $type = ($eaExpression)[1].type;
                const $inStatements = ((() => {
                  const $4 = (u0$Targets$Javascript$EmittableToJs$translateExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpression$0.ctx), $env, true, $inExpression);
                  return ((($4)[0] === "$Block")
                    ? ((() => {
                      const $stats = ($4)[1];
                      return $stats;
                    }))()
                    : ((($4)[0] === "$Inline")
                      ? ((() => {
                        const $jaExpression = ($4)[1];
                        return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ($perhapsReturn.usr)(...($perhapsReturn.ctx), $jaExpression), c0$Core$Nil$0);
                      }))()
                      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 492:16', (sp_toHuman)($4))));
                }))();
                return ((($maybeName)[0] === "$Nothing")
                  ? ((() => {
                    const $4 = (u0$Targets$Javascript$EmittableToJs$translateExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpression$0.ctx), $env, false, $letExpression);
                    return ((($4)[0] === "$Inline")
                      ? ((() => {
                        const $expr = ($4)[1];
                        return (u0$Targets$Javascript$EmittableToJs$Block$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Block$0.ctx), (sp_cons)((u0$Targets$Javascript$Ast$Eval$0.usr)(...(u0$Targets$Javascript$Ast$Eval$0.ctx), $expr), $inStatements));
                      }))()
                      : ((($4)[0] === "$Block")
                        ? ((() => {
                          const $stats = ($4)[1];
                          return (u0$Targets$Javascript$EmittableToJs$Block$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Block$0.ctx), (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $stats, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $inStatements, c0$Core$Nil$0))));
                        }))()
                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 499:20', (sp_toHuman)($4))));
                  }))()
                  : ((($maybeName)[0] === "$Just")
                    ? ((() => {
                      const $name = ($maybeName)[1];
                      const $letStatement = (u0$Targets$Javascript$Ast$Define$0.usr)(...(u0$Targets$Javascript$Ast$Define$0.ctx), (sp_equal)($type.uni, c0$Compiler$Ast$Uni$0), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $name), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $letExpression));
                      return (u0$Targets$Javascript$EmittableToJs$Block$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Block$0.ctx), (sp_cons)($letStatement, $inStatements));
                    }))()
                    : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 496:12', (sp_toHuman)($maybeName))));
              }))()
              : ((($eaExpression)[0] === "$LiteralText")
                ? ((() => {
                  const $string = ($eaExpression)[1];
                  return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$EmittableToJs$literalString$0.usr)(...(u0$Targets$Javascript$EmittableToJs$literalString$0.ctx), $string));
                }))()
                : ((($eaExpression)[0] === "$LiteralNumber")
                  ? ((() => {
                    const $num = ($eaExpression)[1];
                    return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), (text_fromNumber)($num)));
                  }))()
                  : ((($eaExpression)[0] === "$Conditional")
                    ? ((() => {
                      const $test = ($eaExpression)[1];
                      const $true = ($eaExpression)[2];
                      const $false = ($eaExpression)[3];
                      return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Conditional$0.usr)(...(u0$Targets$Javascript$Ast$Conditional$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $test), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $true), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $false)));
                    }))()
                    : ((($eaExpression)[0] === "$And")
                      ? ((() => {
                        const $eaTests = ($eaExpression)[1];
                        const $jaTests = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                          ctx: ([
                            $env,
                          ]),
                          usr: u0$Targets$Javascript$EmittableToJs$translateExpression$3,
                        }), $eaTests);
                        const $4 = (c0$List$reverse$0.usr)(...(c0$List$reverse$0.ctx), $jaTests);
                        return ((($4)[0] === "$Nil")
                          ? (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), "true"))
                          : ((($4)[0] === "$Cons")
                            ? ((() => {
                              const $head = ($4)[1];
                              const $tail = ($4)[2];
                              return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), $head, $tail, ({
                                ctx: [],
                                usr: u0$Targets$Javascript$EmittableToJs$translateExpression$4,
                              })));
                            }))()
                            : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 526:12', (sp_toHuman)($4))));
                      }))()
                      : ((($eaExpression)[0] === "$IsLiteralText")
                        ? ((() => {
                          const $text = ($eaExpression)[1];
                          const $b = ($eaExpression)[2];
                          return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Binop$0.usr)(...(u0$Targets$Javascript$Ast$Binop$0.ctx), "===", (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, (c0$Compiler$EmittableAst$LiteralText$0.usr)(...(c0$Compiler$EmittableAst$LiteralText$0.ctx), $text)), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $b)));
                        }))()
                        : ((($eaExpression)[0] === "$IsLiteralNumber")
                          ? ((() => {
                            const $number = ($eaExpression)[1];
                            const $b = ($eaExpression)[2];
                            return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Binop$0.usr)(...(u0$Targets$Javascript$Ast$Binop$0.ctx), "===", (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, (c0$Compiler$EmittableAst$LiteralNumber$0.usr)(...(c0$Compiler$EmittableAst$LiteralNumber$0.ctx), $number)), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $b)));
                          }))()
                          : ((($eaExpression)[0] === "$Constructor")
                            ? ((() => {
                              const $usr = ($eaExpression)[1];
                              return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor$0.usr)(...(u0$Targets$Javascript$EmittableToJs$maybeOverrideUsrForConstructor$0.ctx), $env, $usr));
                            }))()
                            : ((($eaExpression)[0] === "$ConstructorAccess")
                              ? ((() => {
                                const $argIndex = ($eaExpression)[1];
                                const $value = ($eaExpression)[2];
                                return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$EmittableToJs$accessArrayIndex$0.usr)(...(u0$Targets$Javascript$EmittableToJs$accessArrayIndex$0.ctx), ($argIndex + 1), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $value)));
                              }))()
                              : ((($eaExpression)[0] === "$IsConstructor")
                                ? ((() => {
                                  const $usr = ($eaExpression)[1];
                                  const $eaValue = ($eaExpression)[2];
                                  const $jaValue = (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $eaValue);
                                  return ((sp_equal)($usr, u0$Compiler$CoreDefs$noneConsUsr$0)
                                    ? (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), "true"))
                                    : ((sp_equal)($usr, u0$Compiler$CoreDefs$trueUsr$0)
                                      ? (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), $jaValue)
                                      : ((sp_equal)($usr, u0$Compiler$CoreDefs$falseUsr$0)
                                        ? (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Unop$0.usr)(...(u0$Targets$Javascript$Ast$Unop$0.ctx), "!", $jaValue))
                                        : ((() => {
                                          const $4 = $usr;
                                          const $name = ($4)[2];
                                          return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Binop$0.usr)(...(u0$Targets$Javascript$Ast$Binop$0.ctx), "===", (u0$Targets$Javascript$EmittableToJs$accessArrayIndex$0.usr)(...(u0$Targets$Javascript$EmittableToJs$accessArrayIndex$0.ctx), 0, $jaValue), (u0$Targets$Javascript$EmittableToJs$literalString$0.usr)(...(u0$Targets$Javascript$EmittableToJs$literalString$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $name))));
                                        }))())));
                                }))()
                                : ((($eaExpression)[0] === "$LiteralRecord")
                                  ? ((() => {
                                    const $maybeExtend = ($eaExpression)[1];
                                    const $attrNamesAndValues = ($eaExpression)[2];
                                    const $obj = (u0$Targets$Javascript$Ast$Record$0.usr)(...(u0$Targets$Javascript$Ast$Record$0.ctx), (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, $attrNamesAndValues, ({
                                      ctx: ([
                                        $env,
                                      ]),
                                      usr: u0$Targets$Javascript$EmittableToJs$translateExpression$2,
                                    })));
                                    return ((($maybeExtend)[0] === "$Nothing")
                                      ? (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), $obj)
                                      : ((($maybeExtend)[0] === "$Just")
                                        ? ((() => {
                                          const $extend = ($maybeExtend)[1];
                                          return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), "Object.assign"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$Ast$Record$0.usr)(...(u0$Targets$Javascript$Ast$Record$0.ctx), c0$Dict$empty$0), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $extend), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $obj, c0$Core$Nil$0)))));
                                        }))()
                                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 575:12', (sp_toHuman)($maybeExtend))));
                                  }))()
                                  : ((($eaExpression)[0] === "$RecordAccess")
                                    ? ((() => {
                                      const $attrName = ($eaExpression)[1];
                                      const $value = ($eaExpression)[2];
                                      return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$AccessWithDot$0.usr)(...(u0$Targets$Javascript$Ast$AccessWithDot$0.ctx), $attrName, (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $value)));
                                    }))()
                                    : ((($eaExpression)[0] === "$MissingPattern")
                                      ? ((() => {
                                        const $location = ($eaExpression)[1];
                                        const $value = ($eaExpression)[2];
                                        return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), "sp_throw"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), "'Missing pattern in try..as'"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), (("'" + $location) + "'")), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), "sp_toHuman"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $value), c0$Core$Nil$0)), c0$Core$Nil$0)))));
                                      }))()
                                      : ((($eaExpression)[0] === "$Introspect")
                                        ? ((() => {
                                          const $self = ($eaExpression)[1];
                                          return (u0$Targets$Javascript$EmittableToJs$Inline$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Inline$0.ctx), (u0$Targets$Javascript$Ast$Literal$0.usr)(...(u0$Targets$Javascript$Ast$Literal$0.ctx), (JSON.stringify)($self)));
                                        }))()
                                        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 445:4', (sp_toHuman)($eaExpression)))))))))))))))))))));
});

const u0$Targets$Javascript$EmittableToJs$translateExpression$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateExpression$1,
});

const u0$Targets$Javascript$EmittableToJs$wrapInAutoLambda$1 = (($statements) => {
  return (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), (u0$Targets$Javascript$Ast$BlockLambda$0.usr)(...(u0$Targets$Javascript$Ast$BlockLambda$0.ctx), c0$Core$Nil$0, $statements), c0$Core$Nil$0);
});

const u0$Targets$Javascript$EmittableToJs$wrapInAutoLambda$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$wrapInAutoLambda$1,
});

const u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$1 = (($env, $mustReturnValue, $expr) => {
  const $4 = (u0$Targets$Javascript$EmittableToJs$translateExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpression$0.ctx), $env, $mustReturnValue, $expr);
  return ((($4)[0] === "$Inline")
    ? ((() => {
      const $e = ($4)[1];
      return $e;
    }))()
    : ((($4)[0] === "$Block")
      ? ((() => {
        const $block = ($4)[1];
        return (u0$Targets$Javascript$EmittableToJs$wrapInAutoLambda$0.usr)(...(u0$Targets$Javascript$EmittableToJs$wrapInAutoLambda$0.ctx), $block);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 375:4', (sp_toHuman)($4))));
});

const u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$1,
});

const u0$Targets$Javascript$EmittableToJs$translateArg$1 = (($stuff, $env, $eaExpression) => {
  return ((($eaExpression)[0] === "$ArgumentSpend")
    ? ((() => {
      const $fullType = ($eaExpression)[1];
      const $e = ($eaExpression)[2];
      return (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $e);
    }))()
    : ((($eaExpression)[0] === "$ArgumentRecycle")
      ? ((() => {
        const $rawType = ($eaExpression)[1];
        const $attrPath = ($eaExpression)[2];
        const $name = ($eaExpression)[3];
        return (u0$Targets$Javascript$EmittableToJs$accessAttrs$0.usr)(...(u0$Targets$Javascript$EmittableToJs$accessAttrs$0.ctx), $attrPath, (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $name)));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 295:4', (sp_toHuman)($eaExpression))));
});

const u0$Targets$Javascript$EmittableToJs$translateArg$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateArg$1,
});

const u0$Targets$Javascript$EmittableToJs$binop$3 = (($jsOp, $env, $arguments) => {
  return (((($arguments)[0] === "$Cons") && (((($arguments)[2])[0] === "$Cons") && (((($arguments)[2])[2])[0] === "$Nil")))
    ? ((() => {
      const $right = ($arguments)[1];
      const $left = (($arguments)[2])[1];
      return (u0$Targets$Javascript$Ast$Binop$0.usr)(...(u0$Targets$Javascript$Ast$Binop$0.ctx), $jsOp, (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
        nativeBinop: true,
      }), $env, $right), (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
        nativeBinop: true,
      }), $env, $left));
    }))()
    : (true
      ? (sp_todo)(("compiler bug: wrong number of arguments for binop" + (sp_toHuman)(({
        arguments: $arguments,
        jsOp: $jsOp,
      }))))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 175:8', (sp_toHuman)($arguments))));
});

const u0$Targets$Javascript$EmittableToJs$binop$2 = (($jsOp, $env) => {
  return (sp_todo)((("binop " + $jsOp) + " has no raw value"));
});

const u0$Targets$Javascript$EmittableToJs$binop$1 = (($jsOp) => {
  return (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
    call: ({
      ctx: ([
        $jsOp,
      ]),
      usr: u0$Targets$Javascript$EmittableToJs$binop$3,
    }),
    value: ({
      ctx: ([
        $jsOp,
      ]),
      usr: u0$Targets$Javascript$EmittableToJs$binop$2,
    }),
  }));
});

const u0$Targets$Javascript$EmittableToJs$binop$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$binop$1,
});

const u0$Targets$Javascript$EmittableToJs$binopMutableAssign$2 = (($env) => {
  return (sp_todo)("binop := has no raw value");
});

const u0$Targets$Javascript$EmittableToJs$binopMutableAssign$1 = (($env, $arguments) => {
  return (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentRecycle") && ((((($arguments)[1])[2])[0] === "$Nil") && (((($arguments)[2])[0] === "$Cons") && (((($arguments)[2])[2])[0] === "$Nil")))))
    ? ((() => {
      const $raw = (($arguments)[1])[1];
      const $name = (($arguments)[1])[3];
      (sp_log)((("@" + $name) + " := ..."), "");
      (sp_log)("Mutable assignment without a path is not yet implemented in JS.", "");
      return (sp_todo)((":= for non-paths is not (yet) supported in JS. Sorry. =( " + (sp_toHuman)(({
        arguments: $arguments,
      }))));
    }))()
    : (((($arguments)[0] === "$Cons") && (((($arguments)[2])[0] === "$Cons") && (((($arguments)[2])[2])[0] === "$Nil")))
      ? ((() => {
        const $right = ($arguments)[1];
        const $left = (($arguments)[2])[1];
        return (u0$Targets$Javascript$Ast$Binop$0.usr)(...(u0$Targets$Javascript$Ast$Binop$0.ctx), "=", (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
          nativeBinop: true,
        }), $env, $right), (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
          nativeBinop: true,
        }), $env, $left));
      }))()
      : (true
        ? (sp_todo)(("compiler bug: wrong number of arguments for :=" + (sp_toHuman)(({
          arguments: $arguments,
        }))))
        : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 149:8', (sp_toHuman)($arguments)))));
});

const u0$Targets$Javascript$EmittableToJs$binopMutableAssign$0 = ((() => {
  const $call = ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$binopMutableAssign$1,
  });
  const $value = ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$binopMutableAssign$2,
  });
  return (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
    call: $call,
    value: $value,
  }));
}))();

const u0$Targets$Javascript$EmittableToJs$simpleCall$2 = (($env, $0) => {
  return (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
    nativeBinop: false,
  }), $env, $0);
});

const u0$Targets$Javascript$EmittableToJs$simpleCall$1 = (($env, $jaRef, $eaArgs) => {
  return (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), $jaRef, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Targets$Javascript$EmittableToJs$simpleCall$2,
  }), $eaArgs));
});

const u0$Targets$Javascript$EmittableToJs$simpleCall$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$simpleCall$1,
});

const u0$Targets$Javascript$EmittableToJs$constructor$3 = (($jsValue, $env, $args) => {
  return (u0$Targets$Javascript$EmittableToJs$simpleCall$0.usr)(...(u0$Targets$Javascript$EmittableToJs$simpleCall$0.ctx), $env, (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), $jsValue), $args);
});

const u0$Targets$Javascript$EmittableToJs$constructor$2 = (($jsValue, $env) => {
  return (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), $jsValue);
});

const u0$Targets$Javascript$EmittableToJs$constructor$1 = (($jsValue) => {
  return (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
    call: ({
      ctx: ([
        $jsValue,
      ]),
      usr: u0$Targets$Javascript$EmittableToJs$constructor$3,
    }),
    value: ({
      ctx: ([
        $jsValue,
      ]),
      usr: u0$Targets$Javascript$EmittableToJs$constructor$2,
    }),
  }));
});

const u0$Targets$Javascript$EmittableToJs$constructor$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$constructor$1,
});

const u0$Targets$Javascript$EmittableToJs$function$3 = (($jaName, $env, $args) => {
  return (u0$Targets$Javascript$EmittableToJs$simpleCall$0.usr)(...(u0$Targets$Javascript$EmittableToJs$simpleCall$0.ctx), $env, (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), $jaName), $args);
});

const u0$Targets$Javascript$EmittableToJs$function$2 = (($jaName, $env) => {
  return (u0$Targets$Javascript$Ast$Record$0.usr)(...(u0$Targets$Javascript$Ast$Record$0.ctx), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "ctx",
    second: (u0$Targets$Javascript$Ast$Array$0.usr)(...(u0$Targets$Javascript$Ast$Array$0.ctx), c0$Core$Nil$0),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: "usr",
    second: (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), $jaName),
  }), c0$Core$Nil$0))));
});

const u0$Targets$Javascript$EmittableToJs$function$1 = (($jaName) => {
  return (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
    call: ({
      ctx: ([
        $jaName,
      ]),
      usr: u0$Targets$Javascript$EmittableToJs$function$3,
    }),
    value: ({
      ctx: ([
        $jaName,
      ]),
      usr: u0$Targets$Javascript$EmittableToJs$function$2,
    }),
  }));
});

const u0$Targets$Javascript$EmittableToJs$function$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$function$1,
});

const u0$Targets$Javascript$EmittableToJs$loadOverride$3 = (($env) => {
  return (sp_todo)("TODO: load as value... I guess we need monomorphization?");
});

const u0$Targets$Javascript$EmittableToJs$loadOverride$2 = (($env, $0) => {
  return (u0$Targets$Javascript$EmittableToJs$translateArg$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateArg$0.ctx), ({
    nativeBinop: false,
  }), $env, $0);
});

const u0$Targets$Javascript$EmittableToJs$loadOverride$1 = (($env, $eaArgs) => {
  const $jaArgs = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Targets$Javascript$EmittableToJs$loadOverride$2,
  }), $eaArgs);
  const $requestedTypeHumanized = (((($eaArgs)[0] === "$Cons") && (((($eaArgs)[2])[0] === "$Cons") && ((((($eaArgs)[2])[1])[0] === "$ArgumentSpend") && (((((($eaArgs)[2])[1])[1].raw)[0] === "$TypeFn") && ((((((($eaArgs)[2])[1])[1].raw)[3])[0] === "$Cons") && (((((((($eaArgs)[2])[1])[1].raw)[3])[1])[0] === "$ParSp") && (((((((($eaArgs)[2])[1])[1].raw)[3])[2])[0] === "$Nil") && (((($eaArgs)[2])[2])[0] === "$Nil"))))))))
    ? ((() => {
      const $loadPars = ($eaArgs)[1];
      const $compiledType = (((((($eaArgs)[2])[1])[1].raw)[3])[1])[1].raw;
      let $hash = (hash_fromList)(c0$Core$Nil$0);
      return (u0$Targets$Javascript$EmittableToJs$literalString$0.usr)(...(u0$Targets$Javascript$EmittableToJs$literalString$0.ctx), (c0$Text$replace$0.usr)(...(c0$Text$replace$0.ctx), "\n", "", (c0$Text$replace$0.usr)(...(c0$Text$replace$0.ctx), "\"", "", (sp_toHuman)((c0$Compiler$TypedAst$normalizeType$0.usr)(...(c0$Compiler$TypedAst$normalizeType$0.ctx), $hash, $compiledType)))));
    }))()
    : (true
      ? (sp_todo)("loadOverride BUG?!")
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 220:12', (sp_toHuman)($eaArgs))));
  return (u0$Targets$Javascript$Ast$Call$0.usr)(...(u0$Targets$Javascript$Ast$Call$0.ctx), (u0$Targets$Javascript$Ast$Var$0.usr)(...(u0$Targets$Javascript$Ast$Var$0.ctx), "self_load"), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $requestedTypeHumanized, $jaArgs));
});

const u0$Targets$Javascript$EmittableToJs$loadOverride$0 = ((() => {
  const $call = ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$loadOverride$1,
  });
  return (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
    call: $call,
    value: ({
      ctx: [],
      usr: u0$Targets$Javascript$EmittableToJs$loadOverride$3,
    }),
  }));
}))();

const u0$Targets$Javascript$EmittableToJs$unaryMinus$2 = (($env, $arguments) => {
  return (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentSpend") && ((($arguments)[2])[0] === "$Nil")))
    ? ((() => {
      const $fullType = (($arguments)[1])[1];
      const $arg = (($arguments)[1])[2];
      return (u0$Targets$Javascript$Ast$Unop$0.usr)(...(u0$Targets$Javascript$Ast$Unop$0.ctx), "-", (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $arg));
    }))()
    : (true
      ? (sp_todo)("compiler bug: wrong number of arguments for unop")
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 133:8', (sp_toHuman)($arguments))));
});

const u0$Targets$Javascript$EmittableToJs$unaryMinus$1 = (($env) => {
  return (sp_todo)("unaryMinus has no raw value");
});

const u0$Targets$Javascript$EmittableToJs$unaryMinus$0 = (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
  call: ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$unaryMinus$2,
  }),
  value: ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$unaryMinus$1,
  }),
}));

const u0$Targets$Javascript$EmittableToJs$unaryPlus$2 = (($env, $arguments) => {
  return (((($arguments)[0] === "$Cons") && (((($arguments)[1])[0] === "$ArgumentSpend") && ((($arguments)[2])[0] === "$Nil")))
    ? ((() => {
      const $fullType = (($arguments)[1])[1];
      const $arg = (($arguments)[1])[2];
      return (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $arg);
    }))()
    : (true
      ? (sp_todo)("compiler bug: wrong number of arguments for unop")
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 116:8', (sp_toHuman)($arguments))));
});

const u0$Targets$Javascript$EmittableToJs$unaryPlus$1 = (($env) => {
  return (sp_todo)("unaryPlus has no raw value");
});

const u0$Targets$Javascript$EmittableToJs$unaryPlus$0 = (u0$Targets$Javascript$EmittableToJs$Override$0.usr)(...(u0$Targets$Javascript$EmittableToJs$Override$0.ctx), ({
  call: ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$unaryPlus$2,
  }),
  value: ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$unaryPlus$1,
  }),
}));

const u0$Targets$Javascript$EmittableToJs$coreOverrides$3 = (($2, $d) => {
  const $usr = $2.first;
  const $override = $2.second;
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, 0), $override, $d);
});

const u0$Targets$Javascript$EmittableToJs$coreOverrides$2 = (($module, $name) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), $module), $name);
});

const u0$Targets$Javascript$EmittableToJs$coreOverrides$1 = ((_0) => {
  const $corelib = ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$coreOverrides$2,
  });
  return (c0$List$for$0.usr)(...(c0$List$for$0.ctx), c0$Dict$empty$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$unaryPlus$0.usr,
    second: u0$Targets$Javascript$EmittableToJs$unaryPlus$0,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$unaryMinus$0.usr,
    second: u0$Targets$Javascript$EmittableToJs$unaryMinus$0,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$add$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "+"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$multiply$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "*"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$subtract$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "-"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$mutableAssign$0.usr,
    second: u0$Targets$Javascript$EmittableToJs$binopMutableAssign$0,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$mutableAdd$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "+="),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$mutableSubtract$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "-="),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$textConcat$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "+"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$greaterThan$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), ">"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$lesserThan$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "<"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$greaterOrEqualThan$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), ">="),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$lesserOrEqualThan$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "<="),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$or_$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "||"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$and_$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$binop$0.usr)(...(u0$Targets$Javascript$EmittableToJs$binop$0.ctx), "&&"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$trueUsr$0,
    second: (u0$Targets$Javascript$EmittableToJs$constructor$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructor$0.ctx), "true"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$falseUsr$0,
    second: (u0$Targets$Javascript$EmittableToJs$constructor$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructor$0.ctx), "false"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$noneConsUsr$0,
    second: (u0$Targets$Javascript$EmittableToJs$constructor$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructor$0.ctx), "null"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$divide$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_divide"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$listCons$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_cons"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$equal$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_equal"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: u0$Compiler$CoreDefs$notEqual$0.usr,
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_not_equal"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Basics", "modBy"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "basics_modBy"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Basics", "round"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "Math.round"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Basics", "cloneImm"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "basics_cloneImm"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Basics", "cloneUni"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "basics_cloneUni"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Basics", "compare"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "basics_compare"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Debug", "log"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_log"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Debug", "todo"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_todo"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Debug", "toHuman"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_toHuman"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Debug", "benchStart"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_benchStart"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Debug", "benchStop"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "sp_benchStop"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "fromNumber"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_fromNumber"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "toLower"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_toLower"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "toUpper"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_toUpper"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "toNumber"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_toNumber"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "split"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_split"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "length"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_length"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "slice"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_slice"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "startsWith"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_startsWith"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "startsWithRegex"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_startsWithRegex"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "replaceRegex"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_replaceRegex"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "trimLeft"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_trimLeft"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "dropLeft"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_dropLeft"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Text", "forEach"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "text_forEach"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "fromList"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_fromList"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "insert"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_insert"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "remove"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_remove"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "get"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_get"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "for"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_for"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "each"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_each"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Hash", "pop"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "hash_pop"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "each"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_each"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "push"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_push"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "pop"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_pop"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "get"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_get"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "set"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_set"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "sortBy"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_sortBy"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "fromList"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_fromList"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Array", "toList"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "array_toList"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "List", "sortBy"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "list_sortBy"),
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Self", "load"),
    second: u0$Targets$Javascript$EmittableToJs$loadOverride$0,
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($corelib.usr)(...($corelib.ctx), "Self", "internalRepresentation"),
    second: (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), "JSON.stringify"),
  }), c0$Core$Nil$0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))), ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$coreOverrides$3,
  }));
});

const u0$Targets$Javascript$EmittableToJs$coreOverrides$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$coreOverrides$1,
});

const u0$Targets$Javascript$EmittableToJs$constructorArgumentName$1 = (($i) => {
  return ("$" + (text_fromNumber)($i));
});

const u0$Targets$Javascript$EmittableToJs$constructorArgumentName$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$constructorArgumentName$1,
});

const u0$Targets$Javascript$EmittableToJs$constructorUsrToText$1 = (($usr) => {
  return (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, 0));
});

const u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$constructorUsrToText$1,
});

const u0$Targets$Javascript$EmittableToJs$translateConstructorDef$3 = (($usr, $par) => {
  return ((($par)[0] === "$ParRe")
    ? ((() => {
      const $raw = ($par)[1];
      return (u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$0.usr)(...(u0$Targets$Javascript$EmittableToJs$assertThatRawIsPointy$0.ctx), $usr, $raw);
    }))()
    : ((($par)[0] === "$ParSp")
      ? ((() => {
        const $full = ($par)[1];
        return (u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$0.usr)(...(u0$Targets$Javascript$EmittableToJs$assertThatFullIsPointy$0.ctx), $usr, $full);
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 626:20', (sp_toHuman)($par))));
});

const u0$Targets$Javascript$EmittableToJs$translateConstructorDef$2 = (($index, $name) => {
  return (u0$Targets$Javascript$EmittableToJs$constructorArgumentName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorArgumentName$0.ctx), ($index + 1));
});

const u0$Targets$Javascript$EmittableToJs$translateConstructorDef$1 = (($1) => {
  const $usr = $1.first;
  const $taType = $1.second;
  const $2 = $usr;
  const $nameWithApostrophe = ($2)[2];
  const $umr = ($2)[1];
  const $arrayHead = (u0$Targets$Javascript$EmittableToJs$literalString$0.usr)(...(u0$Targets$Javascript$EmittableToJs$literalString$0.ctx), (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $nameWithApostrophe));
  const $definitionBody = ((($taType)[0] === "$TypeFn")
    ? ((() => {
      const $pars = ($taType)[3];
      const $out = ($taType)[4];
      const $argNames = (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), ({
        ctx: [],
        usr: u0$Targets$Javascript$EmittableToJs$translateConstructorDef$2,
      }), $pars);
      (c0$List$each$0.usr)(...(c0$List$each$0.ctx), $pars, ({
        ctx: ([
          $usr,
        ]),
        usr: u0$Targets$Javascript$EmittableToJs$translateConstructorDef$3,
      }));
      const $fun = (u0$Targets$Javascript$Ast$SimpleLambda$0.usr)(...(u0$Targets$Javascript$Ast$SimpleLambda$0.ctx), $argNames, (u0$Targets$Javascript$Ast$Array$0.usr)(...(u0$Targets$Javascript$Ast$Array$0.ctx), (sp_cons)($arrayHead, (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$Targets$Javascript$Ast$Var$0, $argNames))));
      return (u0$Targets$Javascript$Ast$Record$0.usr)(...(u0$Targets$Javascript$Ast$Record$0.ctx), (c0$Dict$fromList$0.usr)(...(c0$Dict$fromList$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
        first: "usr",
        second: $fun,
      }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
        first: "ctx",
        second: (u0$Targets$Javascript$Ast$Array$0.usr)(...(u0$Targets$Javascript$Ast$Array$0.ctx), c0$Core$Nil$0),
      }), c0$Core$Nil$0))));
    }))()
    : (true
      ? (u0$Targets$Javascript$Ast$Array$0.usr)(...(u0$Targets$Javascript$Ast$Array$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $arrayHead, c0$Core$Nil$0))
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 619:8', (sp_toHuman)($taType))));
  return (u0$Targets$Javascript$Ast$Define$0.usr)(...(u0$Targets$Javascript$Ast$Define$0.ctx), false, (u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), $usr), $definitionBody);
});

const u0$Targets$Javascript$EmittableToJs$translateConstructorDef$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateConstructorDef$1,
});

const u0$Targets$Javascript$EmittableToJs$translateDef$3 = (($index, $1) => {
  const $fullType = $1.first;
  const $maybeName = $1.second;
  const $re = (sp_equal)($fullType.uni, c0$Compiler$Ast$Uni$0);
  return ((($maybeName)[0] === "$Just")
    ? ((() => {
      const $name = ($maybeName)[1];
      return ({
        first: $re,
        second: (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $name),
      });
    }))()
    : ((($maybeName)[0] === "$Nothing")
      ? ({
        first: $re,
        second: ("_" + (text_fromNumber)($index)),
      })
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 676:24', (sp_toHuman)($maybeName))));
});

const u0$Targets$Javascript$EmittableToJs$translateDef$2 = (($1) => {
  const $name = $1.first;
  const $full = $1.second;
  return ({
    first: (sp_equal)($full.uni, c0$Compiler$Ast$Uni$0),
    second: (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), $name),
  });
});

const u0$Targets$Javascript$EmittableToJs$translateDef$1 = (($env, $def) => {
  const $3 = (c0$Dict$get$0.usr)(...(c0$Dict$get$0.ctx), $def.usr, $env.overrides);
  return ((($3)[0] === "$Just")
    ? c0$Maybe$Nothing$0
    : ((($3)[0] === "$Nothing")
      ? ((sp_equal)($def.parameters, c0$Core$Nil$0)
        ? ((() => {
          const $body = (u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpressionToExpression$0.ctx), $env, true, $def.expr);
          return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Targets$Javascript$Ast$Define$0.usr)(...(u0$Targets$Javascript$Ast$Define$0.ctx), false, (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $def.usr), $body));
        }))()
        : ((() => {
          const $body = (u0$Targets$Javascript$EmittableToJs$translateExpression$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateExpression$0.ctx), $env, true, $def.expr);
          const $contextParameters = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
            ctx: [],
            usr: u0$Targets$Javascript$EmittableToJs$translateDef$2,
          }), (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $def.context));
          const $directParameters = ((() => {
            const $zzz = ({
              ctx: [],
              usr: u0$Targets$Javascript$EmittableToJs$translateDef$3,
            });
            return (c0$List$indexedMap$0.usr)(...(c0$List$indexedMap$0.ctx), $zzz, $def.parameters);
          }))();
          const $parsWithNames = (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $contextParameters, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $directParameters, c0$Core$Nil$0)));
          const $statementsRaw = ((($body)[0] === "$Inline")
            ? ((() => {
              const $expr = ($body)[1];
              return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), (u0$Targets$Javascript$Ast$Return$0.usr)(...(u0$Targets$Javascript$Ast$Return$0.ctx), $expr), c0$Core$Nil$0);
            }))()
            : ((($body)[0] === "$Block")
              ? ((() => {
                const $block = ($body)[1];
                return $block;
              }))()
              : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 686:20', (sp_toHuman)($body))));
          return (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (u0$Targets$Javascript$Ast$Define$0.usr)(...(u0$Targets$Javascript$Ast$Define$0.ctx), false, (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $def.usr), (u0$Targets$Javascript$Ast$BlockLambda$0.usr)(...(u0$Targets$Javascript$Ast$BlockLambda$0.ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), c0$Tuple$second$0, $parsWithNames), $statementsRaw)));
        }))())
      : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/EmittableToJs.sp 650:4', (sp_toHuman)($3))));
});

const u0$Targets$Javascript$EmittableToJs$translateDef$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateDef$1,
});

const u0$Targets$Javascript$EmittableToJs$translateAll$4 = (($env, $0) => {
  return (u0$Targets$Javascript$EmittableToJs$translateDef$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateDef$0.ctx), $env, $0);
});

const u0$Targets$Javascript$EmittableToJs$translateAll$3 = (($2, $d) => {
  const $usr = $2.first;
  const $runtimeName = $2.second;
  return (c0$Dict$insert$0.usr)(...(c0$Dict$insert$0.ctx), (c0$Compiler$EmittableAst$translateUsr$0.usr)(...(c0$Compiler$EmittableAst$translateUsr$0.ctx), $usr, 0), (u0$Targets$Javascript$EmittableToJs$function$0.usr)(...(u0$Targets$Javascript$EmittableToJs$function$0.ctx), $runtimeName), $d);
});

const u0$Targets$Javascript$EmittableToJs$translateAll$2 = (($0) => {
  return (u0$Targets$Javascript$EmittableToJs$translateConstructorDef$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateConstructorDef$0.ctx), $0);
});

const u0$Targets$Javascript$EmittableToJs$translateAll$1 = (($pars) => {
  const $2 = $pars;
  const $platformOverrides = $2.platformOverrides;
  const $eaDefs = $2.eaDefs;
  const $constructors = $2.constructors;
  const $jaConstructors = (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Targets$Javascript$EmittableToJs$translateAll$2,
  }), $constructors);
  const $env = ({
    overrides: (c0$List$for$0.usr)(...(c0$List$for$0.ctx), (u0$Targets$Javascript$EmittableToJs$coreOverrides$0.usr)(...(u0$Targets$Javascript$EmittableToJs$coreOverrides$0.ctx), null), $platformOverrides, ({
      ctx: [],
      usr: u0$Targets$Javascript$EmittableToJs$translateAll$3,
    })),
  });
  const $jaStatements = (c0$List$filterMap$0.usr)(...(c0$List$filterMap$0.ctx), ({
    ctx: ([
      $env,
    ]),
    usr: u0$Targets$Javascript$EmittableToJs$translateAll$4,
  }), $eaDefs);
  return (c0$List$concat$0.usr)(...(c0$List$concat$0.ctx), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $jaConstructors, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), $jaStatements, c0$Core$Nil$0)));
});

const u0$Targets$Javascript$EmittableToJs$translateAll$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$EmittableToJs$translateAll$1,
});

const u0$Targets$Javascript$JsToText$id$1 = (($level) => {
  return (c0$Text$repeat$0.usr)(...(c0$Text$repeat$0.ctx), $level, "  ");
});

const u0$Targets$Javascript$JsToText$id$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$JsToText$id$1,
});

const u0$Targets$Javascript$JsToText$emitBlock$2 = (($l, $0) => {
  return (u0$Targets$Javascript$JsToText$emitStatement$0.usr)(...(u0$Targets$Javascript$JsToText$emitStatement$0.ctx), ($l + 1), $0);
});

const u0$Targets$Javascript$JsToText$emitBlock$1 = (($l, $block) => {
  const $lines = (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: ([
      $l,
    ]),
    usr: u0$Targets$Javascript$JsToText$emitBlock$2,
  }), $block));
  return (((("{\n" + $lines) + "\n") + (u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), $l)) + "}");
});

const u0$Targets$Javascript$JsToText$emitBlock$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$JsToText$emitBlock$1,
});

const u0$Targets$Javascript$JsToText$emitExpr$7 = (($l, $0) => {
  return (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $0);
});

const u0$Targets$Javascript$JsToText$emitExpr$6 = (($l, $1) => {
  const $key = $1.first;
  const $value = $1.second;
  return (((((u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), ($l + 1)) + $key) + ": ") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), ($l + 1), $value)) + ",");
});

const u0$Targets$Javascript$JsToText$emitExpr$5 = (($l, $a) => {
  return (((("({\n" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", $a)) + "\n") + (u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), $l)) + "})");
});

const u0$Targets$Javascript$JsToText$emitExpr$4 = (($l, $i) => {
  return (((u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), ($l + 1)) + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), ($l + 1), $i)) + ",");
});

const u0$Targets$Javascript$JsToText$emitExpr$3 = (($l, $a) => {
  return (((("([\n" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", $a)) + "\n") + (u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), $l)) + "])");
});

const u0$Targets$Javascript$JsToText$emitExpr$2 = (($l, $0) => {
  return (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $0);
});

const u0$Targets$Javascript$JsToText$emitExpr$1 = (($l, $expression) => {
  return ((($expression)[0] === "$Literal")
    ? ((() => {
      const $s = ($expression)[1];
      return $s;
    }))()
    : ((($expression)[0] === "$Var")
      ? ((() => {
        const $n = ($expression)[1];
        return $n;
      }))()
      : ((($expression)[0] === "$Call")
        ? ((() => {
          const $ref = ($expression)[1];
          const $args = ($expression)[2];
          return (((("(" + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $ref)) + ")(") + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
            ctx: ([
              $l,
            ]),
            usr: u0$Targets$Javascript$JsToText$emitExpr$7,
          }), $args))) + ")");
        }))()
        : ((($expression)[0] === "$Unop")
          ? ((() => {
            const $op = ($expression)[1];
            const $left = ($expression)[2];
            return ((($op + "(") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $left)) + ")");
          }))()
          : ((($expression)[0] === "$Binop")
            ? ((() => {
              const $op = ($expression)[1];
              const $left = ($expression)[2];
              const $right = ($expression)[3];
              return (((((("(" + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $left)) + " ") + $op) + " ") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $right)) + ")");
            }))()
            : ((($expression)[0] === "$Mutop")
              ? ((() => {
                const $op = ($expression)[1];
                const $yield = ($expression)[2];
                const $left = ($expression)[3];
                const $right = ($expression)[4];
                return (((((((("(" + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $left)) + " ") + $op) + " ") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $right)) + ", ") + $yield) + ")");
              }))()
              : ((($expression)[0] === "$SimpleLambda")
                ? ((() => {
                  const $params = ($expression)[1];
                  const $expr = ($expression)[2];
                  return (((("((" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", $params)) + ") => ") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $expr)) + ")");
                }))()
                : ((($expression)[0] === "$BlockLambda")
                  ? ((() => {
                    const $params = ($expression)[1];
                    const $stats = ($expression)[2];
                    return (((("((" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", $params)) + ") => ") + (u0$Targets$Javascript$JsToText$emitBlock$0.usr)(...(u0$Targets$Javascript$JsToText$emitBlock$0.ctx), $l, $stats)) + ")");
                  }))()
                  : ((($expression)[0] === "$Record")
                    ? ((() => {
                      const $attrs = ($expression)[1];
                      return ((sp_equal)($attrs, c0$Dict$empty$0)
                        ? "{}"
                        : (({
                          ctx: ([
                            $l,
                          ]),
                          usr: u0$Targets$Javascript$JsToText$emitExpr$5,
                        }).usr)(...(({
                          ctx: ([
                            $l,
                          ]),
                          usr: u0$Targets$Javascript$JsToText$emitExpr$5,
                        }).ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                          ctx: ([
                            $l,
                          ]),
                          usr: u0$Targets$Javascript$JsToText$emitExpr$6,
                        }), (list_sortBy)(c0$Tuple$first$0, (c0$Dict$toList$0.usr)(...(c0$Dict$toList$0.ctx), $attrs)))));
                    }))()
                    : ((($expression)[0] === "$AccessWithDot")
                      ? ((() => {
                        const $name = ($expression)[1];
                        const $e = ($expression)[2];
                        return (((u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $e) + ".") + $name);
                      }))()
                      : ((($expression)[0] === "$AccessWithBrackets")
                        ? ((() => {
                          const $i = ($expression)[1];
                          const $expr = ($expression)[2];
                          return (((("(" + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $expr)) + ")[") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $i)) + "]");
                        }))()
                        : ((($expression)[0] === "$Conditional")
                          ? ((() => {
                            const $p = ($expression)[1];
                            const $true = ($expression)[2];
                            const $false = ($expression)[3];
                            return (((((("(" + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $p)) + "\n") + (((u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), ($l + 1)) + "? ") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), ($l + 1), $true))) + "\n") + (((u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), ($l + 1)) + ": ") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), ($l + 1), $false))) + ")");
                          }))()
                          : ((($expression)[0] === "$Array")
                            ? ((() => {
                              const $items = ($expression)[1];
                              return ((sp_equal)($items, c0$Core$Nil$0)
                                ? "[]"
                                : (({
                                  ctx: ([
                                    $l,
                                  ]),
                                  usr: u0$Targets$Javascript$JsToText$emitExpr$3,
                                }).usr)(...(({
                                  ctx: ([
                                    $l,
                                  ]),
                                  usr: u0$Targets$Javascript$JsToText$emitExpr$3,
                                }).ctx), (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                                  ctx: ([
                                    $l,
                                  ]),
                                  usr: u0$Targets$Javascript$JsToText$emitExpr$4,
                                }), $items)));
                            }))()
                            : ((($expression)[0] === "$Comma")
                              ? ((() => {
                                const $expr = ($expression)[1];
                                return (("(" + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), ", ", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
                                  ctx: ([
                                    $l,
                                  ]),
                                  usr: u0$Targets$Javascript$JsToText$emitExpr$2,
                                }), $expr))) + ")");
                              }))()
                              : ((($expression)[0] === "$ThreeDots")
                                ? ((() => {
                                  const $expr = ($expression)[1];
                                  return (("...(" + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $expr)) + ")");
                                }))()
                                : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/JsToText.sp 43:4', (sp_toHuman)($expression)))))))))))))))));
});

const u0$Targets$Javascript$JsToText$emitExpr$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$JsToText$emitExpr$1,
});

const u0$Targets$Javascript$JsToText$emitStatement$2 = (($l, $mid, $expr) => {
  return ((((u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), $l) + $mid) + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $expr)) + ";");
});

const u0$Targets$Javascript$JsToText$emitStatement$1 = (($l, $stat) => {
  const $std = ({
    ctx: ([
      $l,
    ]),
    usr: u0$Targets$Javascript$JsToText$emitStatement$2,
  });
  return ((($stat)[0] === "$Eval")
    ? ((() => {
      const $e = ($stat)[1];
      return ($std.usr)(...($std.ctx), "", $e);
    }))()
    : ((($stat)[0] === "$Return")
      ? ((() => {
        const $e = ($stat)[1];
        return ($std.usr)(...($std.ctx), "return ", $e);
      }))()
      : ((($stat)[0] === "$Define")
        ? ((() => {
          const $isReassignable = ($stat)[1];
          const $name = ($stat)[2];
          const $e = ($stat)[3];
          const $modifier = ($isReassignable
            ? "let"
            : "const");
          return ($std.usr)(...($std.ctx), ((($modifier + " ") + $name) + " = "), $e);
        }))()
        : ((($stat)[0] === "$If")
          ? ((() => {
            const $condition = ($stat)[1];
            const $block = ($stat)[2];
            return (((((u0$Targets$Javascript$JsToText$id$0.usr)(...(u0$Targets$Javascript$JsToText$id$0.ctx), $l) + "if (") + (u0$Targets$Javascript$JsToText$emitExpr$0.usr)(...(u0$Targets$Javascript$JsToText$emitExpr$0.ctx), $l, $condition)) + ") ") + (u0$Targets$Javascript$JsToText$emitBlock$0.usr)(...(u0$Targets$Javascript$JsToText$emitBlock$0.ctx), $l, $block));
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Targets/Javascript/JsToText.sp 12:4', (sp_toHuman)($stat))))));
});

const u0$Targets$Javascript$JsToText$emitStatement$0 = ({
  ctx: [],
  usr: u0$Targets$Javascript$JsToText$emitStatement$1,
});

const u0$Platforms$Browser$compile$2 = (($0) => {
  return (u0$Targets$Javascript$JsToText$emitStatement$0.usr)(...(u0$Targets$Javascript$JsToText$emitStatement$0.ctx), 0, $0);
});

const u0$Platforms$Browser$compile$1 = (($platformOverrides, $loadPars) => {
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Platforms$Browser$compile$2,
  }), (u0$Targets$Javascript$EmittableToJs$translateAll$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateAll$0.ctx), ({
    constructors: $loadPars.constructors,
    eaDefs: $loadPars.defs,
    platformOverrides: $platformOverrides,
  }))));
});

const u0$Platforms$Browser$compile$0 = ({
  ctx: [],
  usr: u0$Platforms$Browser$compile$1,
});

const u0$Platforms$Browser$defaultImportsFile$0 = (u0$DefaultImports$platformDefaultImportsFile$0.usr)(...(u0$DefaultImports$platformDefaultImportsFile$0.ctx), "browser", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "Browser",
  second: c0$Core$Nil$0,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "Html",
  second: c0$Core$Nil$0,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "VirtualDom",
  second: c0$Core$Nil$0,
}), c0$Core$Nil$0))));

const u0$Platforms$Browser$virtualDomUsr$2 = (($makePlatformUmr, $0) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), ($makePlatformUmr.usr)(...($makePlatformUmr.ctx), "VirtualDom"), $0);
});

const u0$Platforms$Browser$virtualDomUsr$1 = (($makePlatformUmr) => {
  return ({
    ctx: ([
      $makePlatformUmr,
    ]),
    usr: u0$Platforms$Browser$virtualDomUsr$2,
  });
});

const u0$Platforms$Browser$virtualDomUsr$0 = ({
  ctx: [],
  usr: u0$Platforms$Browser$virtualDomUsr$1,
});

const u0$Platforms$Browser$extraRequiredUsrs$1 = (($makePlatformUmr) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ((u0$Platforms$Browser$virtualDomUsr$0.usr)(...(u0$Platforms$Browser$virtualDomUsr$0.ctx), $makePlatformUmr).usr)(...((u0$Platforms$Browser$virtualDomUsr$0.usr)(...(u0$Platforms$Browser$virtualDomUsr$0.ctx), $makePlatformUmr).ctx), "updateDomNode"), c0$Core$Nil$0);
});

const u0$Platforms$Browser$extraRequiredUsrs$0 = ({
  ctx: [],
  usr: u0$Platforms$Browser$extraRequiredUsrs$1,
});

const u0$Platforms$Browser$footer$1 = (($makePlatformUmr, $pars) => {
  const $mainName = (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $pars.entryUsr);
  const $updateDomNode = (u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), ((u0$Platforms$Browser$virtualDomUsr$0.usr)(...(u0$Platforms$Browser$virtualDomUsr$0.ctx), $makePlatformUmr).usr)(...((u0$Platforms$Browser$virtualDomUsr$0.usr)(...(u0$Platforms$Browser$virtualDomUsr$0.ctx), $makePlatformUmr).ctx), "updateDomNode"));
  return (((((((("\n// TODO these globals will be a hell of trouble if we want to run more than one app\nlet effects = [];\nlet oldVirtualDom = {}; // TODO this should be properly initialized\nlet model = null;\nlet elementId = null;\n\nfunction dispatch(msgResult) {\n    if (msgResult[0] === \"Ok\") {\n\n        const msg = msgResult[1];\n\n        model =" + $mainName) + ".update(effects, msg, model)[0];\n\n            // TODO set a flag and use requestAnimationFrame\n            updateDom();\n        } else {\n            console.log('rejecting msg: ', msgResult[1]);\n        }\n    }\n\n\n    function updateDom() {\n        const e = win.document.getElementById(elementId);\n\n        const newVirtualDom =") + $mainName) + ".view(model);\n\n") + $updateDomNode) + "(newVirtualDom, oldVirtualDom, e.childNodes[0]);\n\n        oldVirtualDom = newVirtualDom;\n\n        effects.forEach((e) => e());\n        effects = [];\n    }\n\n\n\n    function main(eid) {\n        elementId = eid;\n        model =") + $mainName) + ".init(effects)[0];\n        updateDom();\n    }\n\n\n\n\n\n    win.Squarepants = {\n        main: main,\n    };\n\n})(this);\n");
});

const u0$Platforms$Browser$footer$0 = ({
  ctx: [],
  usr: u0$Platforms$Browser$footer$1,
});

const u0$Platforms$Browser$header$0 = "(function (win) {\n";

const u0$Platforms$Browser$overrides$1 = (($usr) => {
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsCreateTextNode"),
    second: "virtualDom_jsCreateTextNode",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsCreateElement"),
    second: "virtualDom_jsCreateElement",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsReplaceWith"),
    second: "virtualDom_jsReplaceWith",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsAppendChild"),
    second: "virtualDom_jsAppendChild",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsSetProperty"),
    second: "virtualDom_jsSetProperty",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsSetAttribute"),
    second: "virtualDom_jsSetAttribute",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsRemoveAttribute"),
    second: "virtualDom_jsRemoveAttribute",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsAddEventListener"),
    second: "virtualDom_jsAddEventListener",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "jsRemoveEventListener"),
    second: "virtualDom_jsRemoveEventListener",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "eventToText"),
    second: "virtualDom_eventToText",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "eventToFloat"),
    second: "virtualDom_eventToFloat",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "setChild"),
    second: "virtualDom_setChild",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "removeAllChildrenStartingFromIndex"),
    second: "virtualDom_removeAllChildrenStartingFromIndex",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "drawCanvas"),
    second: "virtualDom_drawCanvas",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($usr.usr)(...($usr.ctx), "setViewportOf"),
    second: "virtualDom_setViewportOf",
  }), c0$Core$Nil$0)))))))))))))));
});

const u0$Platforms$Browser$overrides$0 = ({
  ctx: [],
  usr: u0$Platforms$Browser$overrides$1,
});

const u0$Platforms$Browser$runtime$0 = "const crawlObject = (path, type, object) => {\n\n    while(path[0] === 'Cons') {\n\n        const head = path[1];\n        const tail = path[2];\n\n        const o = object[head];\n\n        if (o === undefined) {\n            return [ 'Err', 'no field named: ' + head ];\n        }\n\n        object = o;\n        path = path[2];\n    }\n\n    return typeof object === type\n        ? [ 'Ok', object ]\n        : [ 'Err', 'wrong type: ' + typeof object ]\n        ;\n}\n\n\nconst virtualDom_eventToText = (path, event) => crawlObject(path, 'string', event);\nconst virtualDom_eventToFloat = (path, event) => crawlObject(path, 'number', event);\n\n// TODO ensure that those who must return None actually return None (ie, null)\nconst virtualDom_jsCreateTextNode = (content) => document.createTextNode(content);\nconst virtualDom_jsCreateElement = (tag) => document.createElement(tag);\nconst virtualDom_jsReplaceWith = (new_, old) => { old.replaceWith(new_); return new_; }\nconst virtualDom_jsAppendChild = (pars) => pars.parent.appendChild(pars.child);\nconst virtualDom_jsSetAttribute = (name, value, node) => node.setAttribute(name, value);\nconst virtualDom_jsRemoveAttribute = (name, node) => node.removeAttribute(name);\nconst virtualDom_jsSetProperty = (name, value, node) => node[name] = value;\n\n\nconst virtualDom_setChild = (upd, index, parentNode) => {\n    const child = parentNode.childNodes[index];\n    child && upd(child);\n};\n\n\nconst virtualDom_removeAllChildrenStartingFromIndex = (index, parentNode) => {\n    while(parentNode.childNodes[index]) {\n      parentNode.removeChild(parentNode.childNodes[index]);\n    }\n}\n\n\n// an EventHandler is a function that takes an Event and produces a msg\nconst virtualDom_jsAddEventListener = (eventName, handler, node) => {\n\n    node.squarepantsEventHandlers = node.squarepantsEventHandlers || {};\n\n    if (node.squarepantsEventHandlers[eventName]) {\n      node.removeEventListener(eventName, node.squarepantsEventHandlers[eventName]);\n    }\n\n    const onEvent = (event) => dispatch(handler(event));\n    node.squarepantsEventHandlers[eventName] = onEvent;\n    node.addEventListener(eventName, onEvent);\n};\n\nconst virtualDom_jsRemoveEventListener = (eventName, handler, node) => {\n    node.removeEventListener(eventName, node.squarepantsEventHandlers[eventName]);\n    node.squarepantsEventHandlers[eventName] = undefined;\n}\n\n\nconst virtualDom_setViewportOf = (id, top, left) => () => {\n    const e = document.getElementById(id);\n    if (!e) {\n        console.error('could not find element #' + id);\n        return\n    }\n\n    e.scrollTop = top;\n    e.scrollLeft = left;\n}\n\n\nconst virtualDom_drawCanvas = (canvasId, shaderFn) => () => {\n\n    const canvas = document.getElementById(canvasId);\n    if (!canvas) {\n        console.error('could not find canvas', canvasId);\n        return\n    }\n\n    const w = canvas.width;\n    const h = canvas.height;\n\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.createImageData(w, h);\n\n    for (let x = 0; x < w; x++) for (let y = 0; y < h; y++) {\n\n        const frag = shaderFn(x / (w - 1), 1 - y / (h - 1));\n\n        let j = (x + y * w) * 4;\n        imageData.data[j + 0] = frag.r * 255;\n        imageData.data[j + 1] = frag.g * 255;\n        imageData.data[j + 2] = frag.b * 255;\n        imageData.data[j + 3] = 255;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n};";

const u0$Targets$Javascript$Runtime$listConsName$0 = (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), u0$Compiler$CoreDefs$consName$0);

const u0$Targets$Javascript$Runtime$listNilName$0 = (u0$Targets$Javascript$EmittableToJs$translateName$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateName$0.ctx), u0$Compiler$CoreDefs$nilName$0);

const u0$Targets$Javascript$Runtime$nativeDefinitions$0 = ((() => {
  const $okRef = ((u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Result"), "'ok")) + ".usr");
  const $errRef = ((u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Result"), "'err")) + ".usr");
  const $nothingRef = (u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Maybe"), "'nothing"));
  const $justRef = ((u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Maybe"), "'just")) + ".usr");
  return (((((((((((((((((((((((((((((((((((((("let __re__;\n\n\nconst sp_clone = (src) => {\n if (Array.isArray(src))\n   return src.map(sp_clone);\n\n if (typeof(src) === 'object') {\n   const dest = {};\n   for (let k in src) { dest[k] = sp_clone(src[k]); }\n   return dest;\n }\n\n return src;\n}\n\n\n//\n// Basic ops\n//\n\n\nconst sp_equal = (a, b) => {\n  if (a === b)\n    return true\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n\n    const l = a.length;\n    if (l !== b.length) return false;\n\n    let i = 0;\n    while (i < l) {\n      if (!sp_equal(a[i], b[i])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  if (typeof(a) === 'object') {\n    if (typeof(b) !== 'object') return false;\n\n    const keys = Object.keys(a);\n    const l = keys.length;\n    if (l !== Object.keys(b).length) return false;\n\n    let i = 0;\n    while (i < l) {\n      let k = keys[i];\n      if (!sp_equal(a[k], b[k])) return false;\n      ++i;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nconst sp_not_equal = (a, b) => {\n  return !sp_equal(a, b);\n}\n\n\nconst basics_compare = (a, b) => {\n\n  // union type\n  if (Array.isArray(a)) {\n    // compare constructor names\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    for (let i = 1; i < a.length; i++) {\n        const cmp = basics_compare(a[i], b[i]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  // None is represented as null\n  if (a === null)\n      return 0;\n\n  if (typeof a === 'object') {\n    const keys = Object.keys(a).sort();\n    for (let k of keys) {\n        const cmp = basics_compare(a[k], b[k]);\n        if (cmp) return cmp;\n    }\n    return 0;\n  }\n\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nconst sp_divide = (left, right) => {\n  if (right === 0) return 0;\n  return left / right;\n}\n\n\n// TODO remove this and handle it like any other op?\nconst basics_modBy = (a, b) => b % a;\n\n\nconst basics_cloneImm = sp_clone;\n\n\nconst basics_cloneUni = sp_clone;\n\n\n//\n// Debug\n//\n\n\nconst sp_todo = (message) => {\n  throw new Error(\"TODO: \" + message);\n}\n\n\nconst sp_log = (message, thing) => {\n  console.log(message, sp_toHuman(thing));\n  return thing;\n}\n\n\nconst sp_throw = function (errorName) {\n    console.error(...arguments);\n    throw new Error(errorName);\n}\n\n\n//\n// Benchmarking\n//\n\n\nvar debug_benchStartTime = null;\nvar debug_benchStartStack = null;\nvar debug_benchEntries = {};\n\n\nconst pad = (l, s) => ' '.repeat(Math.max(0, l - s.length)) + s;\n\n\nconst fmt = (n) => {\n    const s = Math.floor(n) + '';\n    return s.slice(0, -3) + '.' + pad(3, s.slice(-3));\n}\n\n\n// TODO how should benchmark work in a browser?\ntypeof process !== 'undefined' && process.on('beforeExit', (code) => {\n    if (debug_benchStartStack !== null)\n        console.error(`ERROR: a benchmark has been started but not stopped!\nStart was at:${debug_benchStartStack}`);\n\n    const ks = Object.keys(debug_benchEntries);\n    if (ks.length) {\n        console.error(\"\");\n        console.error(\"Benchmark results:\");\n        ks.sort().forEach(k => {\n            const entry = debug_benchEntries[k];\n            console.error(\n                    'TotalTime:', pad(10, fmt(entry.dt )) + 's',\n                    '   ',\n                    'Runs:', pad(6, '' + entry.n),\n                    '   ',\n                    'Key:', k,\n            );\n        });\n    }\n});\n\n\nconst sp_benchStart = (none) => {\n    if (debug_benchStartStack !== null)\n        throw new Error(`\nbenchStart called when a benchmark is already ongoing!\nPrevious benchStart call was ${debug_benchStartStack}\n`);\n\n    debug_benchStartStack = new Error().stack;\n    debug_benchStartTime = performance.now();\n}\n\n\nconst sp_benchStop = (name) => {\n    const now = performance.now();\n\n    if (debug_benchStartStack === null)\n        throw new Error(\"benchStop called while no benchmark is ongoing!\");\n\n    debug_benchStartStack = null;\n\n    const dt = now - debug_benchStartTime;\n\n    const entry = debug_benchEntries[name] || { dt: 0, n: 0 };\n    entry.dt += dt;\n    entry.n += 1;\n    debug_benchEntries[name] = entry;\n}\n\n\n\n\n//\n// To Human\n//\n\n\nconst id = (n) => '    '.repeat(n);\n\n\nconst sp_toHuman = (a, l = 0) => {\n\n  if (Array.isArray(a))\n    return sp_toHumanAsList([], a, l) || sp_toHumanAsDict(a, l) || sp_toHumanAsUnion(a, l);\n\n  if (typeof a === 'function') {\n    return '<fn ' + a.length + '>';\n  }\n\n  if (typeof a === 'object') {\n    let acc = '{\\n';\n    for (let key in a)\n        acc += id(l + 1) + key + ' = ' + sp_toHuman(a[key], l + 1) + '\\n';\n\n    return acc + id(l) + '}';\n  }\n\n  return JSON.stringify(a, null, 0);\n}\n\n\nconst sp_toHumanAsUnion = (a, l) => {\n\n  if (a.length === 1) {\n      return a[0];\n  }\n\n  let acc = a[0] + '\\n';\n\n  a.slice(1).forEach(arg => {\n\n      const sub = sp_toHuman(arg, l + 1);\n      if (!sub.startsWith('{') && sub.indexOf('\\n') > -1)\n          acc += id(l + 1) + '(' + sub + id(l + 1) + ')\\n';\n      else\n          acc += id(l + 1) + sub + '\\n';\n\n  })\n\n  return acc;\n}\n\n\nconst sp_toHumanAsList = (arrayAccum, list, l) => {\n  if (list[0] === '" + u0$Targets$Javascript$Runtime$listConsName$0) + "' && list.length === 3) {\n    arrayAccum.push(sp_toHuman(list[1], l));\n    return sp_toHumanAsList(arrayAccum, list[2], l);\n  }\n\n  if (list[0] === '") + u0$Targets$Javascript$Runtime$listNilName$0) + "')\n    return '[' + arrayAccum.join(', ') + ']';\n\n  return false;\n}\n\nconst sp_toHumanAsDict = (dict, l) => {\n  if (dict[0] === 'RBNode_elm_builtin') {\n      return 'DICT' + sp_toHumanAsList([], $core$Dict$toList(dict), l);\n  }\n\n  return false;\n}\n\n\n//\n// Text\n//\n\n\nconst text_fromNumber = (n) => '' + n;\n\nconst text_toNumber = (t) => {\n    const n = +t;\n\n    return isNaN(n) ?") + $nothingRef) + ":") + $justRef) + "(n);\n    }\n\n    const text_toLower = (s) => s.toLowerCase()\n\n    const text_toUpper = (s) => s.toUpperCase()\n\n    const text_split = (separator, target) => arrayToListLow(target.split(separator));\n\n    const text_length = (s) => s.length;\n\n    const text_slice = (start, end, s) => s.slice(start, end);\n\n    const text_startsWith = (sub, s) => s.startsWith(sub);\n\n    const text_startsWithRegex = (regex) => {\n      let re, f;\n      try {\n        re = new RegExp('^' + regex, 's');\n      } catch (e) {\n        f = () => \"\";\n      }\n\n      f = (s) => {\n        let m = s.match(re);\n        return m ? m[0] : \"\";\n      };\n\n      return { ctx: [], usr: f };\n    }\n\n    const text_replaceRegex = (regex) => {\n      let re, f;\n      try {\n        re = new RegExp(regex, 'g');\n      } catch (e) {\n        f = () => \"\"\n      }\n\n      f = (replacer, s) => s.replace(re, replacer);\n\n      return { ctx: [], usr: f };\n    }\n\n    const text_trimLeft = (s) => s.trimLeft();\n\n    const text_dropLeft = (n, s) => s.slice(n);\n\n    const text_forEach = (s, f) => {\n      for (let i of s) f.usr(...f.ctx, i);\n      return null;\n    }\n\n\n    //\n    // Hashes\n    //\n\n    const hash_pop = (hash) => {\n        for (let key in hash) {\n            const [actualKey, value] = hash[key];\n            delete hash[key];\n            return ") + $justRef) + "({ first: actualKey, second: value });\n        }\n\n        return ") + $nothingRef) + ";\n        }\n\n\n        const hash_fromList = (list) => {\n          const hash = {};\n\n          // TODO iteration instead of recursion\n          const rec = (ls) => {\n            if (ls[0] === '") + u0$Targets$Javascript$Runtime$listNilName$0) + "')\n              return hash;\n\n            const { first, second } = ls[1];\n\n            hash[JSON.stringify(first)] = [first, second];\n\n            return rec(ls[2]);\n          };\n\n          return rec(list);\n        }\n\n\n        const hash_insert = (hash, key, value) => {\n            hash[JSON.stringify(key)] = [key, value];\n            return null;\n        }\n\n\n        const hash_remove = (hash, key) => {\n            delete hash[JSON.stringify(key)];\n            return null;\n        }\n\n\n        const hash_get = (hash, key) => {\n            const r = hash[JSON.stringify(key)];\n            return r === undefined ?\n    ") + $nothingRef) + ":") + $justRef) + "(r[1]);\n    }\n\n\n    const hash_for = (hash, f, acc) => {\n        for (let k in hash) {\n            const kv = hash[k];\n            acc = f.usr(...f.ctx, kv[0], kv[1], acc);\n        }\n        return acc;\n    }\n\n\n    const hash_each = (hash, f) => {\n        for (let k in hash) {\n            const kv = hash[k];\n            f.usr(...f.ctx, kv[0], kv[1]);\n        }\n        return null;\n    }\n\n\n    //\n    // Arrays\n    //\n\n    const array_each = (array, f) => {\n        array.forEach((e) => f.usr(...f.ctx, e));\n        return null;\n    }\n\n    const array_push = (array, item) => {\n        array.push(item);\n        return null;\n    }\n\n    const array_pop = (a) => {\n        return a.length ?") + $justRef) + "(a.pop()) :") + $nothingRef) + ";\n    }\n\n    const array_get = (array, index) => {\n        const r = array[index];\n        return r === undefined ?") + $nothingRef) + ":") + $justRef) + "(r);\n    }\n\n    const array_set = (a, index, item) => {\n        if (index < 0) return false;\n        if (index >= a.length) return false;\n        a[index] = item;\n        return true;\n    }\n\n    const array_sortBy = (arr, f) => {\n        arr.sort((a, b) => basics_compare(f.usr(...f.ctx, a), f.usr(...f.ctx, b)));\n        return null;\n    }\n\n    const arrayToListLow = (arr) => {\n      const length = arr.length;\n      let list = [ '") + u0$Targets$Javascript$Runtime$listNilName$0) + "' ];\n      for (let i = length - 1; i >= 0; i--) {\n          list = [ '") + u0$Targets$Javascript$Runtime$listConsName$0) + "', arr[i], list ];\n      }\n      return list;\n    }\n\n    const array_toList = arrayToListLow;\n\n\n    const arrayFromListLow = (list) => {\n      const array = [];\n      const rec = (ls) => {\n        if (ls[0] === '") + u0$Targets$Javascript$Runtime$listNilName$0) + "')\n          return array;\n\n        array.push(ls[1]);\n        return rec(ls[2]);\n      };\n\n      return rec(list);\n    }\n\n    const array_fromList = arrayFromListLow;\n\n\n    //\n    // Lists\n    //\n\n\n    const sp_cons = (item, list) => {\n      return [ '") + u0$Targets$Javascript$Runtime$listConsName$0) + "', item, list];\n    }\n\n    const list_sortBy = (f, list) => arrayToListLow(arrayFromListLow(list).sort((a, b) => basics_compare(f.usr(...f.ctx, a), f.usr(...f.ctx, b))));\n\n\n    //\n    // Dynamic loading\n    //\n    const self_load = (requestedTypeHumanized, pars, variantConstructor) => {\n\n        const re = (s) => s.replace(/[\" \\n]/g, '');\n\n        const actualTypeHumanized = sp_toHuman(pars.type);\n        if (re(actualTypeHumanized) !== re(requestedTypeHumanized)) {\n            return ") + $errRef) + "(pars.type);\n            }\n\n            const tUsrToString = (tUsr) => array_fromList(tUsr).join('$');\n\n            const js = c0$BuildInfo$compile(arrayToListLow([]), pars);\n\n            //   { name1, name2, name3, ... } = externals;\n            const unpackExterns = ''; //'const { ' + pars.externalValues.map((e) => tUsrToString(e.usr)).join(', ') + ' } = externs;';\n\n            const body = `{ ${unpackExterns}\n${js}; return ${tUsrToString(pars.entryUsr)}; }`;\n\n            const arg = {};\n            //pars.externalValues.forEach((e) => arg[tUsrToString(e.usr)] = e.self.value);\n\n            return ") + $okRef) + " (variantConstructor(Function('externs', body)(arg)));\n        };\n\n\n    ");
}))();

const u0$Platforms$Browser$makeExecutable$2 = (($makePlatformUmr, $platformOverrides, $loadPars) => {
  const $compiledStatements = (u0$Platforms$Browser$compile$0.usr)(...(u0$Platforms$Browser$compile$0.ctx), $platformOverrides, $loadPars);
  const $natives = u0$Targets$Javascript$Runtime$nativeDefinitions$0;
  return ((((u0$Platforms$Browser$header$0 + $natives) + u0$Platforms$Browser$runtime$0) + $compiledStatements) + (u0$Platforms$Browser$footer$0.usr)(...(u0$Platforms$Browser$footer$0.ctx), $makePlatformUmr, $loadPars));
});

const u0$Platforms$Browser$makeExecutable$1 = (($makePlatformUmr) => {
  const $platformOverrides = (u0$Platforms$Browser$overrides$0.usr)(...(u0$Platforms$Browser$overrides$0.ctx), (u0$Platforms$Browser$virtualDomUsr$0.usr)(...(u0$Platforms$Browser$virtualDomUsr$0.ctx), $makePlatformUmr));
  return ({
    ctx: ([
      $makePlatformUmr,
      $platformOverrides,
    ]),
    usr: u0$Platforms$Browser$makeExecutable$2,
  });
});

const u0$Platforms$Browser$makeExecutable$0 = ({
  ctx: [],
  usr: u0$Platforms$Browser$makeExecutable$1,
});

const u0$Platforms$Browser$platform$0 = ({
  compile: u0$Platforms$Browser$compile$0,
  defaultImportsFile: u0$Platforms$Browser$defaultImportsFile$0,
  defaultOutputName: "index.js",
  extraRequiredUsrs: u0$Platforms$Browser$extraRequiredUsrs$0,
  makeExecutable: u0$Platforms$Browser$makeExecutable$0,
  name: "browser",
  quickstart: "TODO",
});

const u0$Main$platformBrowser$0 = u0$Platforms$Browser$platform$0;

const u0$Platforms$Posix$defaultImportsFile$0 = (u0$DefaultImports$platformDefaultImportsFile$0.usr)(...(u0$DefaultImports$platformDefaultImportsFile$0.ctx), "posix", (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "IO",
  second: (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), "IO", c0$Core$Nil$0),
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  first: "Path",
  second: c0$Core$Nil$0,
}), c0$Core$Nil$0)));

const u0$Platforms$Posix$header$0 = "#!/usr/bin/env -S node --stack-size=65500 --max-old-space-size=4096\n\n//Error.stackTraceLimit = 100;\n\nconst { performance } = require('perf_hooks');\n\n";

const u0$Platforms$Posix$overrides$3 = (($makePlatformUmr, $0) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), ($makePlatformUmr.usr)(...($makePlatformUmr.ctx), "Path"), $0);
});

const u0$Platforms$Posix$overrides$2 = (($makePlatformUmr, $0) => {
  return (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), ($makePlatformUmr.usr)(...($makePlatformUmr.ctx), "IO"), $0);
});

const u0$Platforms$Posix$overrides$1 = (($makePlatformUmr) => {
  const $ioModule = ({
    ctx: ([
      $makePlatformUmr,
    ]),
    usr: u0$Platforms$Posix$overrides$2,
  });
  const $pathModule = ({
    ctx: ([
      $makePlatformUmr,
    ]),
    usr: u0$Platforms$Posix$overrides$3,
  });
  return (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "parallel"),
    second: "io_parallel",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "readDir"),
    second: "io_readDir",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "readFile"),
    second: "io_readFile",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "writeFile"),
    second: "io_writeFile",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "readStdin"),
    second: "io_readStdin",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "writeStdout"),
    second: "io_writeStdout",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($ioModule.usr)(...($ioModule.ctx), "writeStderr"),
    second: "io_writeStderr",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($pathModule.usr)(...($pathModule.ctx), "dirname"),
    second: "path_dirname",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($pathModule.usr)(...($pathModule.ctx), "resolve"),
    second: "path_resolve",
  }), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
    first: ($pathModule.usr)(...($pathModule.ctx), "join"),
    second: "path_join",
  }), c0$Core$Nil$0))))))))));
});

const u0$Platforms$Posix$overrides$0 = ({
  ctx: [],
  usr: u0$Platforms$Posix$overrides$1,
});

const u0$Platforms$Posix$runtime$0 = ((() => {
  const $makeOk = ((u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Result"), "'ok")) + ".usr");
  const $makeErr = ((u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$constructorUsrToText$0.ctx), (c0$Compiler$Meta$USR$0.usr)(...(c0$Compiler$Meta$USR$0.ctx), (u0$Compiler$CoreDefs$makeUmr$0.usr)(...(u0$Compiler$CoreDefs$makeUmr$0.ctx), "Result"), "'err")) + ".usr");
  return (((((((((((((((((((((((("\n//\n// Platform: IO\n//\nconst fs = require('fs');\nconst path = require('path');\n\nconst io_readDir = (io, dirPath) => {\n    // as @IO, Text: Re [Bool & Text]\n\n    var entries;\n    try {\n        entries = fs.readdirSync(dirPath, { withFileTypes: true });\n    } catch (e) {\n        return " + $makeErr) + "(e.message);\n        }\n\n        return ") + $makeOk) + "(arrayToListLow(entries.map((dirent) => ({\n            first: dirent.isDirectory(),\n            second: dirent.name,\n        }))));\n    };\n\n\n    const io_readFile = (io, path) => {\n        // as @IO, Text: Re Text\n\n        var content;\n        try {\n            content = fs.readFileSync(path, 'utf8');\n        } catch (e) {\n            return ") + $makeErr) + "(e.message);\n        }\n\n        return ") + $makeOk) + "(content);\n    };\n\n\n    const io_writeFile = (io, path, content) => {\n        // as @IO, Text, Text: Re Int\n\n        try {\n            fs.writeFileSync(path, content);\n        } catch (e) {\n            return ") + $makeErr) + "(e.message);\n        }\n\n        return ") + $makeOk) + "(0);\n    };\n\n\n    const io_readStdin = (io) => {\n        // as @IO: Re Text\n\n        try {\n            return ") + $makeOk) + "(fs.readFileSync(0, 'utf8'));\n        } catch (e) {\n            return ") + $makeErr) + "(e.message);\n        }\n    };\n\n\n    const io_writeStdout = (io, content) => {\n        // as @IO, Text: Re None\n\n        try {\n            fs.writeFileSync(1, content);\n        } catch (e) {\n            return ") + $makeErr) + "(e.message);\n        }\n\n        return ") + $makeOk) + "(null);\n    };\n\n\n    const io_writeStderr = (io, content) => {\n        // as @IO, Text: Re Int\n\n        try {\n            fs.writeFileSync(2, content);\n        } catch (e) {\n            return ") + $makeErr) + "(e.message);\n        }\n\n        return ") + $makeOk) + "(null);\n    };\n\n\n    const path_resolve = (p) => path.resolve(...arrayFromListLow(p));\n\n    const path_join = (p) => path.join(...arrayFromListLow(p));\n\n    const path_dirname = path.dirname;\n\n");
}))();

const u0$Platforms$Posix$makeExecutable$3 = (($0) => {
  return (u0$Targets$Javascript$JsToText$emitStatement$0.usr)(...(u0$Targets$Javascript$JsToText$emitStatement$0.ctx), 0, $0);
});

const u0$Platforms$Posix$makeExecutable$2 = (($makePlatformUmr, $out) => {
  const $entryName = (u0$Targets$Javascript$EmittableToJs$_usrToText$0.usr)(...(u0$Targets$Javascript$EmittableToJs$_usrToText$0.ctx), $out.entryUsr);
  const $callMain = (("\n\nconst args = arrayToListLow(process.argv.slice(1));\nprocess.exitCode = " + $entryName) + ".usr\n        (null, process.env, args);\n        ");
  const $compiledStatements = ((() => {
    const $jaStatements = (u0$Targets$Javascript$EmittableToJs$translateAll$0.usr)(...(u0$Targets$Javascript$EmittableToJs$translateAll$0.ctx), ({
      constructors: $out.constructors,
      eaDefs: $out.defs,
      platformOverrides: (u0$Platforms$Posix$overrides$0.usr)(...(u0$Platforms$Posix$overrides$0.ctx), $makePlatformUmr),
    }));
    return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
      ctx: [],
      usr: u0$Platforms$Posix$makeExecutable$3,
    }), $jaStatements));
  }))();
  const $natives = u0$Targets$Javascript$Runtime$nativeDefinitions$0;
  return ((((u0$Platforms$Posix$header$0 + $natives) + u0$Platforms$Posix$runtime$0) + $compiledStatements) + $callMain);
});

const u0$Platforms$Posix$makeExecutable$1 = (($makePlatformUmr) => {
  return ({
    ctx: ([
      $makePlatformUmr,
    ]),
    usr: u0$Platforms$Posix$makeExecutable$2,
  });
});

const u0$Platforms$Posix$makeExecutable$0 = ({
  ctx: [],
  usr: u0$Platforms$Posix$makeExecutable$1,
});

const u0$Platforms$Posix$platform$1 = ((_0) => {
  return c0$Core$Nil$0;
});

const u0$Platforms$Posix$platform$0 = ({
  compile: u0$Platforms$Browser$compile$0,
  defaultImportsFile: u0$Platforms$Posix$defaultImportsFile$0,
  defaultOutputName: "nodeExecutable.js",
  extraRequiredUsrs: ({
    ctx: [],
    usr: u0$Platforms$Posix$platform$1,
  }),
  makeExecutable: u0$Platforms$Posix$makeExecutable$0,
  name: "posix",
  quickstart: "TODO",
});

const u0$Main$platformPosix$0 = u0$Platforms$Posix$platform$0;

const u0$Main$availablePlatforms$0 = (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Main$platformPosix$0, (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), u0$Main$platformBrowser$0, c0$Core$Nil$0));

const u0$Main$cliDefaults$0 = ({
  corelib: c0$Maybe$Nothing$0,
  platform: u0$Main$platformPosix$0,
});

const u0$Main$parseCorelibPath$1 = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "$Nothing")
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "Please specify the path where your corelib is.")
    : ((($maybeValue)[0] === "$Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ((() => {
          const $0 = $cliState;
          return (Object.assign)({}, $0, ({
            corelib: (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), $value),
          }));
        }))());
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 265:4', (sp_toHuman)($maybeValue))));
});

const u0$Main$parseCorelibPath$0 = ({
  ctx: [],
  usr: u0$Main$parseCorelibPath$1,
});

const u0$Main$parsePlatformName$3 = (($p) => {
  return ("    " + $p.name);
});

const u0$Main$parsePlatformName$2 = (($value, $p) => {
  return (sp_equal)($p.name, $value);
});

const u0$Main$parsePlatformName$1 = (($maybeValue, $cliState) => {
  return ((($maybeValue)[0] === "$Nothing")
    ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), "Please specify a platform name, for example: `--platform=posix`")
    : ((($maybeValue)[0] === "$Just")
      ? ((() => {
        const $value = ($maybeValue)[1];
        const $3 = (c0$List$find$0.usr)(...(c0$List$find$0.ctx), ({
          ctx: ([
            $value,
          ]),
          usr: u0$Main$parsePlatformName$2,
        }), u0$Main$availablePlatforms$0);
        return ((($3)[0] === "$Nothing")
          ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ((("I don't know this platform name: `" + $value) + "`\n\n                    Valid platform names are:\n\n") + (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
            ctx: [],
            usr: u0$Main$parsePlatformName$3,
          }), u0$Main$availablePlatforms$0))))
          : ((($3)[0] === "$Just")
            ? ((() => {
              const $platform = ($3)[1];
              return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), ((() => {
                const $0 = $cliState;
                return (Object.assign)({}, $0, ({
                  platform: $platform,
                }));
              }))());
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 242:12', (sp_toHuman)($3))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 236:4', (sp_toHuman)($maybeValue))));
});

const u0$Main$parsePlatformName$0 = ({
  ctx: [],
  usr: u0$Main$parsePlatformName$1,
});

const u0$Main$cliOptions$0 = (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  info: "select build platform",
  name: "--platform",
  parser: u0$Main$parsePlatformName$0,
}), (c0$Core$Cons$0.usr)(...(c0$Core$Cons$0.ctx), ({
  info: "specify the path for for the corelib",
  name: "--corelib",
  parser: u0$Main$parseCorelibPath$0,
}), c0$Core$Nil$0));

const u0$Term$color$2 = (($code, $text) => {
  return (($code + $text) + "\x1b[0m");
});

const u0$Term$color$1 = (($code) => {
  return ({
    ctx: ([
      $code,
    ]),
    usr: u0$Term$color$2,
  });
});

const u0$Term$color$0 = ({
  ctx: [],
  usr: u0$Term$color$1,
});

const u0$Term$blue$0 = (u0$Term$color$0.usr)(...(u0$Term$color$0.ctx), "\x1b[34m");

const u0$Term$red$0 = (u0$Term$color$0.usr)(...(u0$Term$color$0.ctx), "\x1b[31m");

const u0$Term$yellow$0 = (u0$Term$color$0.usr)(...(u0$Term$color$0.ctx), "\x1b[33m");

const u0$Main$formattedToConsoleColoredText$1 = (($formattedText) => {
  return ((($formattedText)[0] === "$FormattedText_Default")
    ? ((() => {
      const $t = ($formattedText)[1];
      return $t;
    }))()
    : ((($formattedText)[0] === "$FormattedText_Emphasys")
      ? ((() => {
        const $t = ($formattedText)[1];
        return (u0$Term$yellow$0.usr)(...(u0$Term$yellow$0.ctx), $t);
      }))()
      : ((($formattedText)[0] === "$FormattedText_Warning")
        ? ((() => {
          const $t = ($formattedText)[1];
          return (u0$Term$red$0.usr)(...(u0$Term$red$0.ctx), $t);
        }))()
        : ((($formattedText)[0] === "$FormattedText_Decoration")
          ? ((() => {
            const $t = ($formattedText)[1];
            return (u0$Term$blue$0.usr)(...(u0$Term$blue$0.ctx), $t);
          }))()
          : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 25:4', (sp_toHuman)($formattedText))))));
});

const u0$Main$formattedToConsoleColoredText$0 = ({
  ctx: [],
  usr: u0$Main$formattedToConsoleColoredText$1,
});

const u0$Main$errorToText$1 = (($error) => {
  const $errors = (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), u0$Main$formattedToConsoleColoredText$0, (u0$Compiler$Error$toFormattedText$0.usr)(...(u0$Compiler$Error$toFormattedText$0.ctx), $error)));
  const $count = (u0$Term$red$0.usr)(...(u0$Term$red$0.ctx), (text_fromNumber)((u0$Compiler$Error$count$0.usr)(...(u0$Compiler$Error$count$0.ctx), $error)));
  return (($errors + "\n\nNumber of errors: ") + $count);
});

const u0$Main$errorToText$0 = ({
  ctx: [],
  usr: u0$Main$errorToText$1,
});

const u0$Main$resToIo$1 = (($res) => {
  return ((($res)[0] === "$Ok")
    ? ((() => {
      const $a = ($res)[1];
      return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $a);
    }))()
    : ((($res)[0] === "$Err")
      ? ((() => {
        const $e = ($res)[1];
        return (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), (u0$Main$errorToText$0.usr)(...(u0$Main$errorToText$0.ctx), $e));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 51:4', (sp_toHuman)($res))));
});

const u0$Main$resToIo$0 = ({
  ctx: [],
  usr: u0$Main$resToIo$1,
});

const u0$Main$formatMain$9 = ((_0) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), null);
});

const u0$Main$formatMain$8 = (($io, $formatted) => {
  return (io_writeStdout)($io, $formatted);
});

const u0$Main$formatMain$7 = (($formatText, $io, $moduleAsText) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
    ]),
    usr: u0$Main$formatMain$8,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
    ]),
    usr: u0$Main$formatMain$8,
  })).ctx), ($formatText.usr)(...($formatText.ctx), "<stdin>", $moduleAsText));
});

const u0$Main$formatMain$6 = (($io, $name, $formatted) => {
  return (io_writeFile)($io, $name, $formatted);
});

const u0$Main$formatMain$5 = (($formatText, $io, $name, $moduleAsText) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $name,
    ]),
    usr: u0$Main$formatMain$6,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $io,
      $name,
    ]),
    usr: u0$Main$formatMain$6,
  })).ctx), ($formatText.usr)(...($formatText.ctx), $name, $moduleAsText));
});

const u0$Main$formatMain$4 = (($formatText, $io, $name) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $formatText,
      $io,
      $name,
    ]),
    usr: u0$Main$formatMain$5,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $formatText,
      $io,
      $name,
    ]),
    usr: u0$Main$formatMain$5,
  })).ctx), (io_readFile)($io, $name));
});

const u0$Main$formatMain$3 = (($content, $formattableAst) => {
  return (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), (u0$SPLib$Format$render$0.usr)(...(u0$SPLib$Format$render$0.ctx), (u0$Human$Format$formatStatements$0.usr)(...(u0$Human$Format$formatStatements$0.ctx), ({
    isRoot: true,
    originalContent: $content,
  }), $formattableAst)));
});

const u0$Main$formatMain$2 = (($fsPath, $content) => {
  return ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $content,
    ]),
    usr: u0$Main$formatMain$3,
  })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
    ctx: ([
      $content,
    ]),
    usr: u0$Main$formatMain$3,
  })).ctx), (u0$Main$resToIo$0.usr)(...(u0$Main$resToIo$0.ctx), (u0$Compiler$Parser$textToFormattableModule$0.usr)(...(u0$Compiler$Parser$textToFormattableModule$0.ctx), ({
    errorModule: ({
      content: $content,
      fsPath: $fsPath,
    }),
    keepComments: true,
    stripLocations: false,
  }))));
});

const u0$Main$formatMain$1 = (($io, $targets) => {
  const $formatText = ({
    ctx: [],
    usr: u0$Main$formatMain$2,
  });
  const $formatFile = ({
    ctx: ([
      $formatText,
      $io,
    ]),
    usr: u0$Main$formatMain$4,
  });
  return ((sp_equal)($targets, c0$Core$Nil$0)
    ? ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $formatText,
        $io,
      ]),
      usr: u0$Main$formatMain$7,
    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: ([
        $formatText,
        $io,
      ]),
      usr: u0$Main$formatMain$7,
    })).ctx), (io_readStdin)($io))
    : ((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: [],
      usr: u0$Main$formatMain$9,
    })).usr)(...((c0$Result$onOk$0.usr)(...(c0$Result$onOk$0.ctx), ({
      ctx: [],
      usr: u0$Main$formatMain$9,
    })).ctx), (c0$List$mapRes$0.usr)(...(c0$List$mapRes$0.ctx), $formatFile, $targets)));
});

const u0$Main$formatMain$0 = ({
  ctx: [],
  usr: u0$Main$formatMain$1,
});

const u0$Main$indent$2 = (($l) => {
  return ("  " + $l);
});

const u0$Main$indent$1 = (($s) => {
  return (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Main$indent$2,
  }), (text_split)("\n", $s)));
});

const u0$Main$indent$0 = ({
  ctx: [],
  usr: u0$Main$indent$1,
});

const u0$Main$parseArguments$5 = (($others, $0) => {
  return (c0$Tuple$pair$0.usr)(...(c0$Tuple$pair$0.ctx), $others, $0);
});

const u0$Main$parseArguments$4 = (($optionName, $o) => {
  return (sp_equal)($o.name, $optionName);
});

const u0$Main$parseArguments$3 = (($options, $optionText, $state) => {
  const $3 = (text_split)("=", $optionText);
  return ((($3)[0] === "$Nil")
    ? (c0$Result$Ok$0.usr)(...(c0$Result$Ok$0.ctx), $state)
    : ((($3)[0] === "$Cons")
      ? ((() => {
        const $optionName = ($3)[1];
        const $rest = ($3)[2];
        const $4 = (c0$List$find$0.usr)(...(c0$List$find$0.ctx), ({
          ctx: ([
            $optionName,
          ]),
          usr: u0$Main$parseArguments$4,
        }), $options);
        return ((($4)[0] === "$Nothing")
          ? (c0$Result$Err$0.usr)(...(c0$Result$Err$0.ctx), ("Unknown option " + $optionName))
          : ((($4)[0] === "$Just")
            ? ((() => {
              const $option = ($4)[1];
              const $value = ((sp_equal)($rest, c0$Core$Nil$0)
                ? c0$Maybe$Nothing$0
                : (c0$Maybe$Just$0.usr)(...(c0$Maybe$Just$0.ctx), (c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "=", $rest)));
              return ($option.parser.usr)(...($option.parser.ctx), $value, $state);
            }))()
            : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 86:16', (sp_toHuman)($4))));
      }))()
      : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 80:8', (sp_toHuman)($3))));
});

const u0$Main$parseArguments$2 = (($0) => {
  return (text_startsWith)("--", $0);
});

const u0$Main$parseArguments$1 = (($options, $args, $initState) => {
  const $4 = (c0$List$partition$0.usr)(...(c0$List$partition$0.ctx), ({
    ctx: [],
    usr: u0$Main$parseArguments$2,
  }), $args);
  const $others = $4.second;
  const $optionTexts = $4.first;
  const $findOption = ({
    ctx: ([
      $options,
    ]),
    usr: u0$Main$parseArguments$3,
  });
  return (c0$Result$map$0.usr)(...(c0$Result$map$0.ctx), ({
    ctx: ([
      $others,
    ]),
    usr: u0$Main$parseArguments$5,
  }), (c0$List$forRes$0.usr)(...(c0$List$forRes$0.ctx), $initState, $optionTexts, $findOption));
});

const u0$Main$parseArguments$0 = ({
  ctx: [],
  usr: u0$Main$parseArguments$1,
});

const u0$Main$order$1 = (($outcome) => {
  return ((($outcome)[0] === "$Success")
    ? 0
    : ((($outcome)[0] === "$Skipped")
      ? 1
      : ((($outcome)[0] === "$Error")
        ? 2
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 124:4', (sp_toHuman)($outcome)))));
});

const u0$Main$order$0 = ({
  ctx: [],
  usr: u0$Main$order$1,
});

const u0$Term$green$0 = (u0$Term$color$0.usr)(...(u0$Term$color$0.ctx), "\x1b[32m");

const u0$Main$testOutcomeToText$1 = (($name, $code, $outcome) => {
  return ((($outcome)[0] === "$Success")
    ? (u0$Term$green$0.usr)(...(u0$Term$green$0.ctx), ("* PASS: " + $name))
    : ((($outcome)[0] === "$Skipped")
      ? (u0$Term$yellow$0.usr)(...(u0$Term$yellow$0.ctx), ("* skip: " + $name))
      : ((($outcome)[0] === "$Error")
        ? ((() => {
          const $error = ($outcome)[1];
          return (((((u0$Term$red$0.usr)(...(u0$Term$red$0.ctx), ("FAIL ! " + $name)) + "\n") + (u0$Main$indent$0.usr)(...(u0$Main$indent$0.ctx), $code)) + "\n") + (u0$Main$indent$0.usr)(...(u0$Main$indent$0.ctx), $error));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 116:4', (sp_toHuman)($outcome)))));
});

const u0$Main$testOutcomeToText$0 = ({
  ctx: [],
  usr: u0$Main$testOutcomeToText$1,
});

const u0$Main$selftestMain$3 = (($x) => {
  return (u0$Main$testOutcomeToText$0.usr)(...(u0$Main$testOutcomeToText$0.ctx), $x.name, $x.code, $x.outcome);
});

const u0$Main$selftestMain$2 = (($x) => {
  return ({
    first: (u0$Main$order$0.usr)(...(u0$Main$order$0.ctx), $x.outcome),
    second: $x.name,
  });
});

const u0$Main$selftestMain$1 = (($io) => {
  return (io_writeStdout)($io, ((c0$Text$join$0.usr)(...(c0$Text$join$0.ctx), "\n", (c0$List$map$0.usr)(...(c0$List$map$0.ctx), ({
    ctx: [],
    usr: u0$Main$selftestMain$3,
  }), (list_sortBy)(({
    ctx: [],
    usr: u0$Main$selftestMain$2,
  }), (i2$Test$flattenAndRun$0.usr)(...(i2$Test$flattenAndRun$0.ctx), u0$Main$allTests$0)))) + "\n"));
});

const u0$Main$selftestMain$0 = ({
  ctx: [],
  usr: u0$Main$selftestMain$1,
});

const u0$Main$main$1 = (($io, $env, $rawArgs) => {
  return (i3$IO$reToStderr$0.usr)(...(i3$IO$reToStderr$0.ctx), $io, ((() => {
    const $4 = (u0$Main$parseArguments$0.usr)(...(u0$Main$parseArguments$0.ctx), u0$Main$cliOptions$0, $rawArgs, u0$Main$cliDefaults$0);
    return ((($4)[0] === "$Err")
      ? ((() => {
        const $message = ($4)[1];
        return (io_writeStderr)($io, ($message + "\n"));
      }))()
      : ((($4)[0] === "$Ok")
        ? ((() => {
          const $args = ($4)[1].first;
          const $cliState = ($4)[1].second;
          return (((($args)[0] === "$Cons") && (((($args)[2])[0] === "$Cons") && ("selftest" === (($args)[2])[1])))
            ? ((() => {
              const $self = ($args)[1];
              const $tail = (($args)[2])[2];
              return (u0$Main$selftestMain$0.usr)(...(u0$Main$selftestMain$0.ctx), $io);
            }))()
            : (((($args)[0] === "$Cons") && (((($args)[2])[0] === "$Cons") && ("format" === (($args)[2])[1])))
              ? ((() => {
                const $self = ($args)[1];
                const $tail = (($args)[2])[2];
                return (u0$Main$formatMain$0.usr)(...(u0$Main$formatMain$0.ctx), $io, $tail);
              }))()
              : (((($args)[0] === "$Cons") && ((($args)[2])[0] === "$Cons"))
                ? ((() => {
                  const $self = ($args)[1];
                  const $entryPoint = (($args)[2])[1];
                  const $tail = (($args)[2])[2];
                  const $maybeOutputPath = (c0$List$head$0.usr)(...(c0$List$head$0.ctx), $tail);
                  return (u0$Main$resToIo$0.usr)(...(u0$Main$resToIo$0.ctx), (u0$BuildMain$compileMain$0.usr)(...(u0$BuildMain$compileMain$0.ctx), $io, ({
                    corelib: $cliState.corelib,
                    entryPoint: $entryPoint,
                    maybeOutputPath: $maybeOutputPath,
                    platform: $cliState.platform,
                    selfPath: $self,
                  })));
                }))()
                : (true
                  ? (io_writeStdout)($io, "\nHi! This is the Squarepants compiler!\n\nTo compile something, write:\n\n    squarepants pathToMainModule.sp\n\n")
                  : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 297:12', (sp_toHuman)($args))))));
        }))()
        : (sp_throw)('Missing pattern in try..as', 'src/Main.sp 291:4', (sp_toHuman)($4))));
  }))());
});

const u0$Main$main$0 = ({
  ctx: [],
  usr: u0$Main$main$1,
});

const args = arrayToListLow(process.argv.slice(1));
process.exitCode = u0$Main$main$0.usr
        (null, process.env, args);
        